<html><head></head><body>
  <div id="_idContainer116" class="Basic-Text-Frame">
    <h1 class="chapterNumber">2</h1>
    <h1 id="_idParaDest-69" class="chapterTitle">Objects, Immutability, Switch Expressions, and Pattern Matching</h1>
    <p class="normal">This chapter includes 30 problems, tackling, among others, some less-known features of <code class="inlineCode">java.util.Objects</code>, some interesting aspects of immutability, the newest features of <code class="inlineCode">switch</code> expressions, and deep coverage of the cool pattern matching capabilities of <code class="inlineCode">instanceof</code> and <code class="inlineCode">switch</code> expressions.</p>
    <p class="normal">At the end of this chapter, you’ll be up to date with all these topics, which are non-optional in any Java developer’s arsenal.</p>
    <h1 id="_idParaDest-70" class="heading-1">Problems</h1>
    <p class="normal">Use the following problems to test your programming prowess on <code class="inlineCode">Objects</code>, immutability, <code class="inlineCode">switch</code> expressions, and pattern matching. I strongly encourage you to give each problem a try before you turn to the solutions and download the example programs:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="38"><strong class="keyWord">Explaining and exemplifying UTF-8, UTF-16, and UTF-32</strong>: Provide a detailed explanation of what UTF-8, UTF-16, and UTF-32 are. Include several snippets of code to show how these work in Java.</li>
      <li class="numberedList"><strong class="keyWord">Checking a sub-range in the range from 0 to length</strong>: Write a program that checks whether the given sub-range [<em class="italic">given start</em>, <em class="italic">given start </em>+ <em class="italic">given end</em>) is within the bounds of the range from [<em class="italic">0</em>, <em class="italic">given length</em>). If the given sub-range is not in the [<em class="italic">0</em>, <em class="italic">given length</em>) range, then throw an <code class="inlineCode">IndexOutOfBoundsException</code>.</li>
      <li class="numberedList"><strong class="keyWord">Returning an identity string</strong>: Write a program that returns a string representation of an object without calling the overridden <code class="inlineCode">toString()</code> or <code class="inlineCode">hashCode()</code>.</li>
      <li class="numberedList"><strong class="keyWord">Hooking unnamed classes and instance main methods</strong>: Give a quick introduction to JDK 21 unnamed classes and instance main methods.</li>
      <li class="numberedList"><strong class="keyWord">Adding code snippets in Java API documentation</strong>: Provide examples of adding code snippets in Java API documentation via the new <code class="inlineCode">@snippet</code> tag.</li>
      <li class="numberedList"><strong class="keyWord">Invoking default methods from </strong><code class="inlineCode">Proxy</code><strong class="keyWord"> instances</strong>: Write several programs that invoke interface <code class="inlineCode">default</code> methods from <code class="inlineCode">Proxy</code> instances in JDK 8, JDK 9, and JDK 16.</li>
      <li class="numberedList"><strong class="keyWord">Converting between bytes and hex-encoded strings</strong>: Provide several snippets of code for converting between bytes and hex-encoded strings (including byte arrays).</li>
      <li class="numberedList"><strong class="keyWord">Exemplify the initialization-on-demand holder design pattern</strong>: Write a program that implements the initialization-on-demand holder design pattern in the classical way (before JDK 16) and another program that implements this design pattern based on the fact that, from JDK 16+, Java inner classes can have static members and static initializers.</li>
      <li class="numberedList"><strong class="keyWord">Adding nested classes in anonymous classes</strong>: Write a meaningful example that uses nested classes in anonymous classes (pre-JDK 16, and JDK 16+).</li>
      <li class="numberedList"><strong class="keyWord">Exemplify erasure vs. overloading</strong>: Explain in a nutshell what type erasure in Java and polymorphic overloading are, and exemplify how they work together.</li>
      <li class="numberedList"><strong class="keyWord">Xlinting default constructors</strong>: Explain and exemplify the JDK 16+ hint for classes with default constructors,<code class="inlineCode">-Xlint:missing-explicit-ctor</code>.</li>
      <li class="numberedList"><strong class="keyWord">Working with the receiver parameter</strong>: Explain the role of the Java receiver parameter and exemplify its usage in code.</li>
      <li class="numberedList"><strong class="keyWord">Implementing an immutable stack</strong>: Provide a program that creates an immutable stack implementation from zero (implement <code class="inlineCode">isEmpty()</code>, <code class="inlineCode">push()</code>, <code class="inlineCode">pop()</code>, and <code class="inlineCode">peek()</code> operations).</li>
      <li class="numberedList"><strong class="keyWord">Revealing a common mistake with Strings</strong>: Write a simple use case of strings that contain a common mistake (for instance, related to the <code class="inlineCode">String</code> immutability characteristic).</li>
      <li class="numberedList"><strong class="keyWord">Using the enhanced NullPointerException</strong>: Exemplify, from your experience, the top 5 causes of <code class="inlineCode">NullPointerException</code> and explain how JDK 14 improves NPE messages.</li>
      <li class="numberedList"><strong class="keyWord">Using yield in switch expressions</strong>: Explain and exemplify the usage of the <code class="inlineCode">yield</code> keyword with <code class="inlineCode">switch</code> expressions in JDK 13+.</li>
      <li class="numberedList"><strong class="keyWord">Tackling the case null clause in switch</strong>: Write a bunch of examples to show different approaches for handling <code class="inlineCode">null</code> values in <code class="inlineCode">switch</code> expressions (including JDK 17+ approaches).</li>
      <li class="numberedList"><strong class="keyWord">Taking on the hard way to discover equals()</strong>: Explain and exemplify how <code class="inlineCode">equals()</code> is different from the <code class="inlineCode">==</code> operator.</li>
      <li class="numberedList"><strong class="keyWord">Hooking instanceof in a nutshell</strong>: Provide a brief overview with snippets of code to highlight the main aspect of the <code class="inlineCode">instanceof</code> operator. </li>
      <li class="numberedList"><strong class="keyWord">Introducing pattern matching</strong>: Provide a theoretical dissertation including the main aspects and terminology for <em class="italic">pattern matching</em> in Java.</li>
      <li class="numberedList"><strong class="keyWord">Introducing type pattern matching for instanceof</strong>: Provide the theoretical and practical support for using the <em class="italic">type pattern matching</em> for <code class="inlineCode">instanceof</code>.</li>
      <li class="numberedList"><strong class="keyWord">Handling the scope of a binding variable in type patterns for instanceof</strong>: Explain in detail, including snippets of code, the scope of <em class="italic">binding variables</em> in <em class="italic">type patterns</em> for <code class="inlineCode">instanceof</code>.</li>
      <li class="numberedList"><strong class="keyWord">Rewriting equals() via type patterns for instanceof</strong>: Exemplify in code the implementation of <code class="inlineCode">equals()</code> (including for generic classes) before and after <em class="italic">type patterns</em> for <code class="inlineCode">instanceof</code> have been introduced.</li>
      <li class="numberedList"><strong class="keyWord">Tackling type patterns for instanceof and generics</strong>: Provide several examples that use the combo <em class="italic">type patterns</em> for <code class="inlineCode">instanceof</code> and generics.</li>
      <li class="numberedList"><strong class="keyWord">Tackling type patterns for instanceof and streams</strong>: Can we use <em class="italic">type patterns</em> for <code class="inlineCode">instanceof</code> and the Stream API together? If yes, provide at least an example. </li>
      <li class="numberedList"><strong class="keyWord">Introducing type pattern matching for switch</strong>: <em class="italic">Type patterns</em> are available for <code class="inlineCode">instanceof</code> but are also available for <code class="inlineCode">switch</code>. Provide here the theoretical headlines and an example of this topic.</li>
      <li class="numberedList"><strong class="keyWord">Adding guarded pattern labels in switch</strong>: Provide a brief coverage of <em class="italic">guarded pattern labels</em> in <code class="inlineCode">switch</code> for JDK 17 and 21.</li>
      <li class="numberedList"><strong class="keyWord">Dealing with pattern label dominance in switch</strong>: Pattern label dominance in <code class="inlineCode">switch</code> is a cool feature, so exemplify it here in a comprehensive approach with plenty of examples.</li>
      <li class="numberedList"><strong class="keyWord">Dealing with completeness (type coverage) in pattern labels for switch</strong>: This is another cool topic for <code class="inlineCode">switch</code> expressions. Explain and exemplify it in detail (theory ad examples).</li>
      <li class="numberedList"><strong class="screenText">Understanding the unconditional patterns and nulls in switch expressions</strong>: Explain how <code class="inlineCode">null</code> values are handled by unconditional patterns of <code class="inlineCode">switch</code> expressions before and after JDK 19.</li>
    </ol>
    <p class="normal">The following sections describe solutions to the preceding problems. Remember that there usually isn’t a single correct way to solve a particular problem. Also remember that the explanations shown here include only the most interesting and important details needed to solve the problems. Download the example solutions to see additional details and to experiment with the programs at <a href="https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter02"><span class="url">https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter02</span></a>.</p>
    <h1 id="_idParaDest-71" class="heading-1">38. Explain and exemplifying UTF-8, UTF-16, and UTF-32</h1>
    <p class="normal">Character encoding/decoding is<a id="_idIndexMarker180"/> important for browsers, databases, text editors, filesystems, networking, and<a id="_idIndexMarker181"/> so on, so it’s a major topic for any programmer. Check out the <a id="_idIndexMarker182"/>following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_01.png" alt="Figure 2.1.png"/></figure>
    <p class="packt_figref">Figure 2.1: Representing text with different char sets</p>
    <p class="normal">In <em class="italic">Figure 2.1</em>, we see several Chinese characters represented in UTF-8, UTF-16, and ANSI on a computer screen. But, what are these? What is ANSI? What is UTF-8 and how did we get to it? Why don’t these characters look normal in ANSI?</p>
    <p class="normal">Well, the story may begin with computers trying to represent characters (such as letters from the alphabet or digits or punctuation marks). The computers understand/process everything from the real world as a binary representation, so as a sequence of 0 and 1. This means that every character (for instance, A, 5, +, and so on) has to be mapped to a sequence of 0 and 1.</p>
    <p class="normal">The process of mapping a character to a sequence of 0 and 1 is known as <em class="italic">character encoding </em>or simply <em class="italic">encoding</em>. The reverse process of un-mapping a sequence of 0 and 1 to a character is known as <em class="italic">character decoding</em> or simply <em class="italic">decoding</em>. Ideally, an encoding-decoding cycle should return<a id="_idIndexMarker183"/> the same character; otherwise, we obtain something that we don’t understand or we cannot use.</p>
    <p class="normal">For instance, the Chinese character, <img src="../Images/B19665_02_001.png" alt="" role="presentation"/>, should be encoded in the computer’s memory as a sequence of 0 and 1. Next, when this sequence is decoded, we expect back the same Chinese letter, <img src="../Images/B19665_02_002.png" alt="" role="presentation"/>. In <em class="italic">Figure 2.1</em>, this happens in the left and middle screenshots, while in the right screenshot, the returned character is <img src="../Images/B19665_02_003.png" alt="" role="presentation"/>…. A Chinese speaker will not understand this (actually, nobody will), so something went wrong!</p>
    <p class="normal">Of course, we don’t have only Chinese characters to represent. We have many other sets of characters grouped in <a id="_idIndexMarker184"/>alphabets, emoticons, and so on. A set of characters has well-defined<a id="_idIndexMarker185"/> content (for instance, an alphabet has a certain <a id="_idIndexMarker186"/>number of well-defined characters) and is known as a <em class="italic">character set</em> or, in short, a <em class="italic">charset</em>.</p>
    <p class="normal">Having a charset, the problem is to define a set of rules (a standard) that clearly explains how the characters of this charset should be encoded/decoded in the computer memory. Without having a clear set of rules, the encoding and decoding may lead to errors or indecipherable <a id="_idIndexMarker187"/>characters. Such a standard is known as an <em class="italic">encoding scheme</em>.</p>
    <p class="normal">One of the first encoding schemes was ASCII.</p>
    <h2 id="_idParaDest-72" class="heading-2">Introducing ASCII encoding scheme (or single-byte encoding)</h2>
    <p class="normal">ASCII stands for American Standard Code for Information Interchange. This encoding scheme relies on a 7-bit binary system. In other <a id="_idIndexMarker188"/>words, each character that is part of the ASCII charset (<a href="http://ee.hawaii.edu/~tep/EE160/Book/chap4/subsection2.1.1.1.html"><span class="url">http://ee.hawaii.edu/~tep/EE160/Book/chap4/subsection2.1.1.1.html</span></a>) should be representable (encoded) on 7 bits. A 7-bit number can be a decimal between 0 and 127, as in the next figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_02.png" alt="Figure 2.2.png"/></figure>
    <p class="packt_figref">Figure 2.2: ASCII charset encoding</p>
    <p class="normal">So, ASCII is an encoding scheme based on a 7-bit system that supports 128 different characters. But, we know that computers operate on bytes (octets) and a byte has 8 bits. This means that ASCII is a <a id="_idIndexMarker189"/>single-byte encoding scheme that leaves a bit free for each byte. See the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_03.png" alt="Figure 2.3.png"/></figure>
    <p class="packt_figref">Figure 2.3: The highlighted bit is left free in ASCII encoding</p>
    <p class="normal">In ASCII encoding, the letter A is 65, the letter B is 66, and so on. In Java, we can easily check this via the existing API, as in the following simple code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span> <span class="hljs-variable">decimalA</span> <span class="hljs-operator">=</span> <span class="hljs-string">"A"</span>.charAt(<span class="hljs-number">0</span>); <span class="hljs-comment">// 65</span>
<span class="hljs-type">String</span> <span class="hljs-variable">binaryA</span> <span class="hljs-operator">=</span> Integer.toBinaryString(decimalA); <span class="hljs-comment">// 1000001</span>
</code></pre>
    <p class="normal">Or, let’s see the encoding of the text <em class="italic">Hello World</em>. This time, we added the free bit as well, so the result will be 01001000 01100101 01101100 01101100 01101111 0100000 01010111 01101111 01110010 01101100 01100100:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">char</span>[] chars = <span class="hljs-string">"Hello World"</span>.toCharArray();
<span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : chars) {
  System.out.print(<span class="hljs-string">"0"</span> + Integer.toBinaryString(ch) + <span class="hljs-string">" "</span>);
}
</code></pre>
    <p class="normal">If we perform a match, then we see that 01001000 is <em class="italic">H</em>, 01100101 is <em class="italic">e</em>, 01101100 is <em class="italic">l</em>, 01101111 is <em class="italic">o</em>, 0100000 is space, 01010111 is <em class="italic">W</em>, 01110010 is <em class="italic">r</em>, and 01100100 is <em class="italic">d</em>. So, besides letters, the ASCII encoding can represent the English alphabet (upper and lower case), digits, space, punctuation marks, and some special characters.</p>
    <p class="normal">Besides the core ASCII for English, we also have ASCII extensions, which are basically variations of the original ASCII to support other alphabets. Most probably, you’ve heard about the ISO-8859-1 (known as ISO Latin 1), which is a famous ASCII extension. But, even with ASCII extensions, there are still a lot of characters in the world that cannot be encoded yet. There are countries that have a lot more characters than ASCII can encode, and even countries that don’t use alphabets. So, ASCII has its limitations.</p>
    <p class="normal">I know what you are thinking … let’s use that free bit (2<sup class="superscript">7</sup>+127). Yes, but even so, we can go up to 256 characters. Still <a id="_idIndexMarker190"/>not enough! It is time to encode characters using more than 1 byte.</p>
    <h2 id="_idParaDest-73" class="heading-2">Introducing multi-byte encoding</h2>
    <p class="normal">In different parts of the world, people started to <a id="_idIndexMarker191"/>create multi-byte encoding schemes (commonly, 2 bytes). For instance, speaker of the Chinese language, which has a lot of characters, created Shift-JIS and Big5, which use 1 or 2 bytes to represent characters.</p>
    <p class="normal">But, what happens when most of the countries come up with their own multi-byte encoding schemes trying to cover their special characters, symbols, and so on? Obviously, this leads to a huge incompatibility between the encoding schemes used in different countries. Even worse, some countries have multiple encoding schemes that are totally incompatible with each other. For instance, Japan has three different incompatible encoding schemes, which means that encoding a document with one of these encoding schemes and decoding with another will lead to a garbled document.</p>
    <p class="normal">However, this incompatibility was not such a big issue before the Internet, since which documents have been massively shared all around the globe using computers. At that moment, the incompatibility between the encoding schemes conceived in isolation (for instance, countries and geographical regions) started to be painful.</p>
    <p class="normal">It was the perfect moment for the Unicode Consortium to be created. </p>
    <h3 id="_idParaDest-74" class="heading-3">Unicode</h3>
    <p class="normal">In a nutshell, Unicode (<a href="https://unicode-table.com/en/"><span class="url">https://unicode-table.com/en/</span></a>) is a universal encoding standard capable of encoding/decoding <a id="_idIndexMarker192"/>every possible character in the world (we are talking about hundreds of thousands of characters).</p>
    <p class="normal">Unicode needs more bytes to <a id="_idIndexMarker193"/>represent all these characters. But, Unicode didn’t get involved in this representation. It just assigned a number to each character. This number is named a <em class="italic">code point</em>. For instance, the letter <em class="italic">A</em> in Unicode is associated with the code point 65 in decimal, and we refer to it as U+0041. This is the constant U+ followed by 65 in hexadecimal. As you can see, in Unicode, <em class="italic">A</em> is 65, exactly as in the ASCII encoding. In other words, Unicode is backward compatible with ASCII. As you’ll see soon, this is big, so keep it in mind!</p>
    <p class="normal">Early versions of Unicode contain characters having code points less than 65,535 (0xFFFF). Java represents these characters via the 16-bit <code class="inlineCode">char</code> data type. For instance, the French <img src="../Images/B19665_02_004.png" alt="" role="presentation"/> (<em class="italic">e</em> with circumflex) is associated with the Unicode 234 decimal or U+00EA hexadecimal. In Java, we can use <code class="inlineCode">charAt()</code> to reveal this for any Unicode character less than 65,535:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ê"</span>.charAt(<span class="hljs-number">0</span>);                <span class="hljs-comment">// 234</span>
<span class="hljs-type">String</span> <span class="hljs-variable">hexe</span> <span class="hljs-operator">=</span> Integer.toHexString(e); <span class="hljs-comment">// ea</span>
</code></pre>
    <p class="normal">We also may see the binary representation of this character:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">binarye</span> <span class="hljs-operator">=</span> Integer.toBinaryString(e); <span class="hljs-comment">// 11101010 = 234</span>
</code></pre>
    <p class="normal">Later, Unicode <a id="_idIndexMarker194"/>added more and more characters up to 1,114,112 (0x10FFFF). Obviously, the 16-bit Java <code class="inlineCode">char</code> was not enough to represent these characters, and calling <code class="inlineCode">charAt()</code> was not useful anymore.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">Java 19+ supports Unicode 14.0. The <code class="inlineCode">java.lang.Character</code> API supports Level 14 of the <strong class="keyWord">Unicode Character Database</strong> (<strong class="keyWord">UCD</strong>). In numbers, we have 47 new emojis, 838 new characters, and 5 <a id="_idIndexMarker195"/>new scripts. Java 20+ supports Unicode 15.0, which means 4,489 new characters for <code class="inlineCode">java.lang.Character</code>.</p>
      <p class="normal">In addition, JDK 21 has added a set of methods especially for working with emojis based on their code point. Among these methods, we have <code class="inlineCode">boolean isEmoji(int codePoint)</code>, <code class="inlineCode">boolean isEmojiPresentation(int codePoint)</code>, <code class="inlineCode">boolean isEmojiModifier(int codePoint)</code>, <code class="inlineCode">boolean isEmojiModifierBase(int</code> <code class="inlineCode">codePoint)</code>, <code class="inlineCode">boolean isEmojiComponent(int codePoint)</code>, and <code class="inlineCode">boolean isExtendedPictographic(int codePoint)</code>. In the bundled code, you can find a small application showing you how to fetch all available emojis and check if a given string contains emoji. So, we can easily obtain the code point of a character via <code class="inlineCode">Character.codePointAt()</code> and pass it as an argument to these methods to determine whether the character is an emoji or not.</p>
    </div>
    <p class="normal">However, Unicode doesn’t get involved in how these code points are encoded into bits. This is the job of special encoding schemes within <a id="_idIndexMarker196"/>Unicode, such as the <strong class="keyWord">Unicode Transformation Format</strong> (<strong class="keyWord">UTF</strong>) schemes. Most commonly, we use UTF-32, UTF-16, and UTF-8.</p>
    <h4 class="heading-4">UTF-32</h4>
    <p class="normal">UTF-32 is an encoding<a id="_idIndexMarker197"/> scheme for Unicode that represents every code point on 4 bytes (32 bits). For instance, the letter <em class="italic">A</em> (having code point 65), which can be encoded on a 7-bit system, is encoded in UTF-32 as in the following figure next to the other two characters:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_04.png" alt="Figure 2.4.png"/></figure>
    <p class="packt_figref">Figure 2.4: Three characters sample encoded in UTF-32</p>
    <p class="normal">As you can see in <em class="italic">Figure 2.4</em>, UTF-32 uses 4 bytes (fixed length) to represent every character. In the case of the letter <em class="italic">A</em>, we see that UTF-32 wasted 3 bytes of memory. This means that converting an ASCII file to UTF-32 will increase its size by 4 times (for instance, a 1KB ASCII file is a 4KB UTF-32 file). Because of this shortcoming, UTF-32 is not very popular.</p>
    <p class="normal">Java doesn’t support UTF-32 as a standard charset but it relies on <em class="italic">surrogate pairs</em> (introduced in the next section).</p>
    <h4 class="heading-4">UTF-16</h4>
    <p class="normal">UTF-16 is an encoding scheme for <a id="_idIndexMarker198"/>Unicode that represents every code point on 2 or 4 bytes (not on 3 bytes). UTF-16 has a variable length and uses an optional <strong class="keyWord">Byte-Order Mark</strong> (<strong class="keyWord">BOM</strong>), but it <a id="_idIndexMarker199"/>is recommended to use UTF-16BE (BE stands for Big-Endian byte order), or UTF-16LE (LE stands for Little-Endian byte order). While more details about Big-Endian vs. Little-Endian are available at <a href="https://en.wikipedia.org/wiki/Endianness"><span class="url">https://en.wikipedia.org/wiki/Endianness</span></a>, the following figure reveals how the orders of bytes differ in UTF-16BE (left side) vs. UTF-16LE (right side) for three characters:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_05.png" alt="Figure 2.5.png"/></figure>
    <p class="packt_figref">Figure 2.5: UTF-16BE (left side) vs. UTF-16LE (right side)</p>
    <p class="normal">Since the figure is self-explanatory, let’s move forward. Now, we have to tackle a trickier aspect of UTF-16. We <a id="_idIndexMarker200"/>know that in UTF-32, we take the <em class="italic">code point</em> and transform it into a 32-bit number and that’s it. But, in UTF-16, we can’t do that every time because we have code points that don’t accommodate 16 bits. This being said, UTF-16 uses the so-called 16-bit <em class="italic">code units</em>. It can use 1 or 2 <em class="italic">code units</em> per <em class="italic">code point</em>. There are three types of code units, as follows:</p>
    <ul>
      <li class="bulletList">A code point needs a single code unit: these are 16-bit code units (covering U+0000 to U+D7FF, and U+E000 to U+FFFF)</li>
      <li class="bulletList">A code point needs 2 code units:<ul>
          <li class="bulletList">The first code unit is named <em class="italic">high surrogate</em> and it covers 1,024 values (U+D800 to U+DBFF)</li>
          <li class="bulletList">The second code unit is named <em class="italic">low surrogate</em> and it covers 1,024 values (U+DC00 to U+DFFF)</li>
        </ul>
      </li>
    </ul>
    <p class="normal">A <em class="italic">high surrogate</em> followed by a <em class="italic">low surrogate</em> is named a <em class="italic">surrogate pair</em>. Surrogate pairs are needed to represent the so-called <em class="italic">supplementary</em> Unicode characters or characters having a code point larger than 65,535 (0xFFFF).</p>
    <p class="normal">Characters such as the letter A (65) or the Chinese <img src="../Images/B19665_02_005.png" alt="" role="presentation"/> (26263) have a code point that can be represented via a single code unit. The following figure shows these characters in UTF-16BE:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_06.png" alt="Figure 2.6.png"/></figure>
    <p class="packt_figref">Figure 2.6: UTF-16 encoding of A and <img src="../Images/B19665_02_006.png" alt="" role="presentation"/></p>
    <p class="normal">This was easy! Now, let’s consider<a id="_idIndexMarker201"/> the following figure (encoding of Unicode, <em class="italic">Smiling Face with Heart-Shaped Eyes</em>):</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_07.png" alt="Figure 2.7.png"/></figure>
    <p class="packt_figref">Figure 2.7: UTF-16 encoding using a surrogate pair</p>
    <p class="normal">The character from this figure has a code point of 128525 (or, 1 F60D) and is represented on 4 bytes.</p>
    <p class="normal">Check the first byte: the sequence of 6 bits, 110110, identifies a high surrogate.</p>
    <p class="normal">Check the third byte: the sequence of 6 bits, 110111, identifies a low surrogate.</p>
    <p class="normal">These 12 bits (identifying the high and low surrogates) can be dropped and we keep the rest of the 20 bits: 00001111011000001101. We can compute this number as 2<sup class="superscript">0 </sup>+ 2<sup class="superscript">2 </sup>+ 2<sup class="superscript">3 </sup>+ 2<sup class="superscript">9 </sup>+ 2<sup class="superscript">10 </sup>+ 2<sup class="superscript">12 </sup>+ 2<sup class="superscript">13 </sup>+ 2<sup class="superscript">14 </sup>+ 2<sup class="superscript">15 </sup>= 1 + 4 + 8 + 512 + 1024 + 4096 + 8192 + 16384 + 32768 = 62989 (or, the hexadecimal, F60D).</p>
    <p class="normal">Finally, we have to compute F60D + 0x10000 = 1 F60D, or in decimal 62989 + 65536 = 128525 (the code point of this Unicode character). We have to add 0x10000 because the characters that use 2 code units(a surrogate pair) are always of form 1 F…</p>
    <p class="normal">Java supports UTF-16, UTF-16BE, and UTF-16LE. Actually, UTF-16 is the native character encoding for Java.</p>
    <h4 class="heading-4">UTF-8</h4>
    <p class="normal">UTF-8 is an encoding scheme for <a id="_idIndexMarker202"/>Unicode that represents every code point on 1, 2, 3, or 4 bytes. Having this 1- to 4-byte flexibility, UTF-8 uses space in a very efficient way.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">UTF-8 is the most popular encoding scheme that dominates the Internet and applications.</p>
    </div>
    <p class="normal">For instance, we know that the code point of the letter A is 65 and it can be encoded using a 7-bit binary representation. The following figure represents this letter encoded in UTF-8:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_08.png" alt="Figure 2.8.png"/></figure>
    <p class="packt_figref">Figure 2.8: Letter A encoded in UTF-8</p>
    <p class="normal">This is very cool! UTF-8 has used a single byte to encode A. The first (leftmost) 0 signals that this is a single-byte encoding. Next, let’s see the Chinese character, <img src="../Images/B19665_02_007.png" alt="" role="presentation"/>:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_09.png" alt="Figure 2.9.png"/></figure>
    <p class="packt_figref">Figure 2.9: Chinese character, <img src="../Images/B19665_02_006.png" alt="" role="presentation"/>, encoded in UTF-8</p>
    <p class="normal">The code point of <img src="../Images/B19665_02_007.png" alt="" role="presentation"/> is 26263, so UTF-8 uses 3 bytes to represent it. The first byte contains 4 bits (1110) that signal that this is a 3-byte encoding. The next two bytes start with 2 bits of 10. All these 8 bits <a id="_idIndexMarker203"/>can be dropped and we keep only the remaining 16 bits, which gives us the expected code point.</p>
    <p class="normal">Finally, let’s tackle the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_10.png" alt="Figure 2.10.png"/></figure>
    <p class="packt_figref">Figure 2.10: UTF-8 encoding with 4 bytes</p>
    <p class="normal">This time, the first byte signals that this is a 4-byte encoding via 11110. The remaining 3 bytes start with 10. All these 11 bits can be dropped and we keep only the remaining 21 bits, 000011111011000001101, which gives us the expected code point, 128525.</p>
    <p class="normal">In the following figure you can see the UTF-8 template used for encoding Unicode characters:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_11.png" alt="Figure 2.11.png"/></figure>
    <p class="packt_figref">Figure 2.11: UTF-8 template used for encoding Unicode characters</p>
    <p class="normal">Did you know that 8 zeros in a row (00000000 – U+0000) are interpreted as NULL? A NULL represents the end of the <a id="_idIndexMarker204"/>string, so sending it “accidentally” will be a problem because the remaining string will not be processed. Fortunately, UTF-8 prevents this issue, and sending a NULL can be done only if we effectively send the U+0000 code point.</p>
    <h2 id="_idParaDest-75" class="heading-2">Java and Unicode</h2>
    <p class="normal">As long as we use characters with <a id="_idIndexMarker205"/>code points less than 65,535 (0xFFFF), we can<a id="_idIndexMarker206"/> rely on the <code class="inlineCode">charAt()</code> method to obtain the code point. Here are some examples:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span> <span class="hljs-variable">cp1</span> <span class="hljs-operator">=</span> <span class="hljs-string">"A"</span>.charAt(<span class="hljs-number">0</span>);                   <span class="hljs-comment">// 65</span>
<span class="hljs-type">String</span> <span class="hljs-variable">hcp1</span> <span class="hljs-operator">=</span> Integer.toHexString(cp1);    <span class="hljs-comment">// 41</span>
<span class="hljs-type">String</span> <span class="hljs-variable">bcp1</span> <span class="hljs-operator">=</span> Integer.toBinaryString(cp1); <span class="hljs-comment">// 1000001</span>
<span class="hljs-type">int</span> <span class="hljs-variable">cp2</span> <span class="hljs-operator">=</span> <span class="hljs-string">"</span><img src="../Images/B19665_02_010.png" alt="" role="presentation"/><span class="hljs-string">"</span>.charAt(<span class="hljs-number">0</span>);                  <span class="hljs-comment">// 26263</span>
<span class="hljs-type">String</span> <span class="hljs-variable">hcp2</span> <span class="hljs-operator">=</span> Integer.toHexString(cp2);    <span class="hljs-comment">// 6697</span>
<span class="hljs-type">String</span> <span class="hljs-variable">bcp2</span> <span class="hljs-operator">=</span> Integer.toBinaryString(cp2); <span class="hljs-comment">// 1101100000111101</span>
</code></pre>
    <p class="normal">Based on these examples, we may write a helper method that returns the binary representation of strings having code points less than 65,535 (0xFFFF) as follows (you already saw the imperative version of the following functional code earlier):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">strToBinary</span><span class="hljs-params">(String str)</span> {
   <span class="hljs-type">String</span> <span class="hljs-variable">binary</span> <span class="hljs-operator">=</span> str.chars()
     .mapToObj(Integer::toBinaryString)
     .map(t -&gt; <span class="hljs-string">"0"</span> +  t)
     .collect(Collectors.joining(<span class="hljs-string">"</span><span class="hljs-string"> "</span>));
   <span class="hljs-keyword">return</span> binary;
}
</code></pre>
    <p class="normal">If you run this code against a Unicode character having a code point greater than 65,535 (0xFFFF), then you’ll get the wrong result. You’ll not get an exception or any kind of warning.</p>
    <p class="normal">So, <code class="inlineCode">charAt()</code> covers only a subset of Unicode characters. For covering all Unicode characters, Java provides an API that consists of several methods. For instance, if we replace <code class="inlineCode">charAt()</code> with <code class="inlineCode">codePointAt()</code>, then we obtain the correct code point in all cases, as you can see in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_12.png" alt="Figure 2.12.png"/></figure>
    <p class="packt_figref">Figure 2.12: charAt() vs. codePointAt()</p>
    <p class="normal">Check out the last example, <code class="inlineCode">c2</code>. Since <code class="inlineCode">codePointAt()</code> returns the correct code point (128525), we can obtain the<a id="_idIndexMarker207"/> binary representation as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">uc</span> <span class="hljs-operator">=</span> Integer.toBinaryString(c2); <span class="hljs-comment">// 11111011000001101</span>
</code></pre>
    <p class="normal">So, if we need a method that returns <a id="_idIndexMarker208"/>the binary encoding of any Unicode character, then we can replace the <code class="inlineCode">chars()</code> call with the <code class="inlineCode">codePoints()</code> call. The <code class="inlineCode">codePoints()</code> method returns the code points of the given sequence:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">codePointToBinary</span><span class="hljs-params">(String str)</span> {
   <span class="hljs-type">String</span> <span class="hljs-variable">binary</span> <span class="hljs-operator">=</span> str.codePoints()
      .mapToObj(Integer::toBinaryString)
      .collect(Collectors.joining(<span class="hljs-string">" "</span>));
   <span class="hljs-keyword">return</span> binary;
}
</code></pre>
    <p class="normal">The <code class="inlineCode">codePoints()</code> method is just one of the methods provided by Java to work around code points. The Java API also includes <code class="inlineCode">codePointAt()</code>, <code class="inlineCode">offsetByCodePoints()</code>, <code class="inlineCode">codePointCount()</code>, <code class="inlineCode">codePointBefore()</code>, <code class="inlineCode">codePointOf()</code>, and so on. You can find several examples of them in the bundled code next to this one for obtaining a <code class="inlineCode">String</code> from a given code point:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> String.valueOf(Character.toChars(<span class="hljs-number">65</span>)); <span class="hljs-comment">// A</span>
<span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> String.valueOf(Character.toChars(<span class="hljs-number">128525</span>));
</code></pre>
    <p class="normal">The <code class="inlineCode">toChars()</code> method gets a code point and returns the UTF-16 representation via a <code class="inlineCode">char[]</code>. The string returned by the first example (<code class="inlineCode">str1</code>) has a length of 1 and is the letter A. The second example returns a string of length 2 since the character having the code point 128525 needs a surrogate pair. The returned <code class="inlineCode">char[]</code> contains both the high and low surrogates.</p>
    <p class="normal">Finally, let’s have a helper method that allows us to obtain the binary representation of a string for a given<a id="_idIndexMarker209"/> encoding scheme:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">stringToBinaryEncoding</span><span class="hljs-params">(</span>
<span class="hljs-params">      String str, String encoding)</span> {
   <span class="hljs-keyword">final</span> <span class="hljs-type">Charset</span> <span class="hljs-variable">charset</span> <span class="hljs-operator">=</span> Charset.forName(encoding);
   <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] strBytes = str.getBytes(charset);
   <span class="hljs-keyword">final</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">strBinary</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">StringBuilder</span>();
   <span class="hljs-keyword">for</span> (<span class="hljs-type">byte</span> strByte : strBytes) {
      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) {
        strBinary.append((strByte &amp; <span class="hljs-number">128</span>) == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);
        strByte &lt;&lt;= <span class="hljs-number">1</span>;
      }
      strBinary.append(<span class="hljs-string">" "</span>);
   }
   <span class="hljs-keyword">return</span> strBinary.toString().trim();
}
</code></pre>
    <p class="normal">Using this method is quite <a id="_idIndexMarker210"/>simple, as you can see in the following examples:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// 00000000 00000000 00000000 01000001</span>
<span class="hljs-type">String</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Charsets.stringToBinaryEncoding(<span class="hljs-string">"A"</span>, <span class="hljs-string">"UTF-32"</span>);
<span class="hljs-comment">// 10010111 01100110</span>
<span class="hljs-type">String</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Charsets.stringToBinaryEncoding(<span class="hljs-string">"</span><img src="../Images/B19665_02_010.png" alt="" role="presentation"/><span class="hljs-string">"</span>, 
              StandardCharsets.UTF_16LE.name());
</code></pre>
    <p class="normal">You can practice more examples in the bundled code.</p>
    <h3 id="_idParaDest-76" class="heading-3">JDK 18 defaults the charset to UTF-8</h3>
    <p class="normal">Before JDK 18, the<a id="_idIndexMarker211"/> default charset was determined based on the operating system charset and locale (for instance, on a Windows machine, it could be windows-1252). Starting with JDK 18, the default charset is UTF-8 (<code class="inlineCode">Charset.defaultCharset()</code> returns the string, UTF-8). Or, having a <code class="inlineCode">PrintStream</code> instance, we can find out the used charset via the <code class="inlineCode">charset()</code> method (starting with JDK 18).</p>
    <p class="normal">But, the default charset can be explicitly set via the <code class="inlineCode">file.encoding</code> and <code class="inlineCode">native.encoding</code> system properties at the command line. For instance, you may need to perform such modification to compile legacy code developed before JDK 18:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// the default charset is computed from native.encoding</span>
java -Dfile-encoding = COMPAT 
<span class="hljs-comment">// the default charset is windows-1252</span>
java -Dfile-encoding = windows-<span class="hljs-number">1252</span> 
</code></pre>
    <p class="normal">So, since JDK 18, classes that use encoding (for instance, <code class="inlineCode">FileReader</code>/<code class="inlineCode">FileWriter</code>, <code class="inlineCode">InputStreamReader</code>/<code class="inlineCode">OutputStreamWriter</code>, <code class="inlineCode">PrintStream</code>, <code class="inlineCode">Formatter</code>, <code class="inlineCode">Scanner</code>, and <code class="inlineCode">URLEncoder</code>/<code class="inlineCode">URLDecoder</code>) can take advantage of UTF-8 out of the box. For instance, using UTF-8 before JDK 18 for<a id="_idIndexMarker212"/> reading a file can be accomplished by explicitly specifying this charset encoding scheme as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> ( <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title">FileReader</span>(
   chineseUtf8File.toFile(), StandardCharsets.UTF_8))) {
   ...
}
</code></pre>
    <p class="normal">Accomplishing the same thing in JDK 18+ doesn’t require explicitly specifying the charset encoding scheme:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> ( <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">BufferedReader</span>(
   <span class="hljs-keyword">new</span> <span class="hljs-title">FileReader</span>(chineseUtf8File.toFile()))) {
   ...
}
</code></pre>
    <p class="normal">However, for <code class="inlineCode">System.out</code> and <code class="inlineCode">System.err</code>, JDK 18+ still uses the default system charset. So, if you are using <code class="inlineCode">System.out</code>/<code class="inlineCode">err</code> and you see question marks (?) instead of the expected characters, then most probably you should set UTF-8 via the new properties <code class="inlineCode">-Dstdout.encoding</code> and <code class="inlineCode">-Dstderr.encoding</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">-Dstderr.encoding=utf8 -Dstdout.encoding=utf8
</code></pre>
    <p class="normal">Or, you can set them as environment variables to set them globally:</p>
    <pre class="programlisting code"><code class="hljs-code">_JAVA_OPTIONS=<span class="hljs-string">"-Dstdout.encoding=utf8 -Dstderr.encoding=utf8"</span>
</code></pre>
    <p class="normal">In the bundled code you can see more examples.</p>
    <h1 id="_idParaDest-77" class="heading-1">39. Checking a sub-range in the range from 0 to length</h1>
    <p class="normal">Checking that a given sub-range is in the range from 0 to the given length is a common check in a lot of problems. For instance, let’s consider that we have to write a function responsible for checking if the client <a id="_idIndexMarker213"/>can increase the pressure in a water pipe. The client gives us the current average pressure (<code class="inlineCode">avgPressure</code>), the maximum pressure (<code class="inlineCode">maxPressure</code>), and the amount of extra pressure that should be applied (<code class="inlineCode">unitsOfPressure</code>).</p>
    <p class="normal">But, before we can apply our secret algorithm, we have to check that the inputs are correct. So, we have to ensure that none of the following cases happens:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">avgPressure</code> is less than 0</li>
      <li class="bulletList"><code class="inlineCode">unitsOfPressure</code> is less than 0</li>
      <li class="bulletList"><code class="inlineCode">maxPressure</code> is less than 0</li>
      <li class="bulletList">The range [<code class="inlineCode">avgPressure</code>, <code class="inlineCode">avgPressure</code> + <code class="inlineCode">unitsOfPressure</code>) is out of bounds represented by <code class="inlineCode">maxPressure</code></li>
    </ul>
    <p class="normal">So, in code lines, our function may look as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isPressureSupported</span><span class="hljs-params">(</span>
<span class="hljs-params">      </span><span class="hljs-type">int</span><span class="hljs-params"> avgPressure, </span><span class="hljs-type">int</span><span class="hljs-params"> unitsOfPressure, </span><span class="hljs-type">int</span><span class="hljs-params"> maxPressure)</span> {
  <span class="hljs-keyword">if</span>(avgPresure &lt; <span class="hljs-number">0</span> || unitsOfPressure &lt; <span class="hljs-number">0</span> || maxPressure &lt; <span class="hljs-number">0</span>
    || (avgPresure + unitsOfPressure) &gt; maxPressure) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">IndexOutOfBoundsException</span>(
           <span class="hljs-string">"One or more parameters are out of bounds"</span>);
  }
  <span class="hljs-comment">// the secret algorithm</span>
  <span class="hljs-keyword">return</span> (avgPressure + unitsOfPressure) &lt;
    (maxPressure - maxPressure/<span class="hljs-number">4</span>);
}
</code></pre>
    <p class="normal">Writing composite conditions such as ours is prone to accidental mistakes. It is better to rely on the Java API whenever possible. And, for this use case, it is possible! Starting with JDK 9, in <code class="inlineCode">java.util.Objects</code>, we have the method <code class="inlineCode">checkFromIndexSize(int fromIndex, int size, int length)</code>, and starting with JDK 16, we also have a flavor for <code class="inlineCode">long</code> arguments, <code class="inlineCode">checkFromIndexSize(int fromIndex, int size, int length)</code>. If we consider that <code class="inlineCode">avgPressure</code> is <code class="inlineCode">fromIndex</code>, <code class="inlineCode">unitsOfPressure</code> is <code class="inlineCode">size</code>, and <code class="inlineCode">maxPressure</code> is <code class="inlineCode">length</code>, then <code class="inlineCode">checkFromIndexSize()</code> performs the arguments validation and throws an <code class="inlineCode">IndexOutOfBoundsException</code> if something goes wrong. So, we write the code as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isPressureSupported</span><span class="hljs-params">(</span>
<span class="hljs-params">      </span><span class="hljs-type">int</span><span class="hljs-params"> avgPressure, </span><span class="hljs-type">int</span><span class="hljs-params"> unitsOfPressure, </span><span class="hljs-type">int</span><span class="hljs-params"> maxPressure)</span> {
  Objects.checkFromIndexSize(
    avgPressure, unitsOfPressure, maxPressure);
  <span class="hljs-comment">// the secret algorithm</span>
  <span class="hljs-keyword">return</span> (avgPressure + unitsOfPressure) &lt;
   (maxPressure - maxPressure/<span class="hljs-number">4</span>);
}
</code></pre>
    <p class="normal">In the code bundle, you can see one more example of using <code class="inlineCode">checkFromIndexSize()</code>.</p>
    <p class="normal">Besides <code class="inlineCode">checkFromIndexSize()</code>, in <code class="inlineCode">java.util.Objects</code>, we can find several other companions that cover common<a id="_idIndexMarker214"/> composite conditions such as <code class="inlineCode">checkIndex(int index, int length)</code> – JDK 9, <code class="inlineCode">checkIndex(long index, long length)</code> – JDK 16, <code class="inlineCode">checkFromToIndex(int fromIndex, int toIndex, int length)</code> – JDK 9, and <code class="inlineCode">checkFromToIndex(long fromIndex, long toIndex, long length)</code> – JDK 16.</p>
    <p class="normal">And, by the way, if we switch the context to strings, then JDK 21 provides an overload of the well-known <code class="inlineCode">String.indexOf()</code>, capable of searching a character/substring in a given string between a given begin index and end index. The signature is <code class="inlineCode">indexOf(String str, int beginIndex, int endIndex)</code> and it returns the index of the first occurrence of <code class="inlineCode">str</code>, or -1 if <code class="inlineCode">str</code> is not found. Basically, this is a neat version of <code class="inlineCode">s.substring(beginIndex, endIndex).indexOf(str) + beginIndex</code>.</p>
    <h1 id="_idParaDest-78" class="heading-1">40. Returning an identity string</h1>
    <p class="normal">So, what’s an <em class="italic">identity string</em>? An identity string is a<a id="_idIndexMarker215"/> string built from an object without calling the overridden <code class="inlineCode">toString()</code> or <code class="inlineCode">hashCode()</code>. It is equivalent to the following concatenation:</p>
    <pre class="programlisting code"><code class="hljs-code">object.getClass().getName() + <span class="hljs-string">"@"</span> 
  + Integer.toHexString(System.identityHashCode(object))
</code></pre>
    <p class="normal">Starting with JDK 19, this string is wrapped in <code class="inlineCode">Objects.toIdentityString(Object object)</code>. Consider the following class (<code class="inlineCode">object</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyPoint</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> x;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> y;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> z;
  ...
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"MyPoint{"</span> + <span class="hljs-string">"x="</span> + x + <span class="hljs-string">", y="</span> + y 
                      + <span class="hljs-string">", z="</span> + z + <span class="hljs-string">'</span><span class="hljs-string">}'</span>;
  }  
}
</code></pre>
    <p class="normal">By calling <code class="inlineCode">toIdentityString()</code>, we<a id="_idIndexMarker216"/> obtain something as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MyPoint</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">MyPoint</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">// modern.challenge.MyPoint@76ed5528</span>
Objects.toIdentityString(p);
</code></pre>
    <p class="normal">Obviously, the overridden <code class="inlineCode">MyPoint.toString()</code> method was not called. If we print out the hash code of <code class="inlineCode">p</code>, we get <code class="inlineCode">76ed5528</code>, which is exactly what <code class="inlineCode">toIdentityString()</code> returned. Now, let’s override <code class="inlineCode">hashCode()</code> as well:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> {
  <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span>;
  hash = <span class="hljs-number">23</span> * hash + <span class="hljs-built_in">this</span>.x;
  hash = <span class="hljs-number">23</span> * hash + <span class="hljs-built_in">this</span>.y;
  hash = <span class="hljs-number">23</span> * hash + <span class="hljs-built_in">this</span>.z;
  <span class="hljs-keyword">return</span> hash;
}
</code></pre>
    <p class="normal">This time, <code class="inlineCode">toIdentityString()</code> returns the same thing, while our <code class="inlineCode">hashCode()</code> returns <code class="inlineCode">14ef3</code>.</p>
    <h1 id="_idParaDest-79" class="heading-1">41. Hooking unnamed classes and instance main methods</h1>
    <p class="normal">Imagine that you have to initiate a<a id="_idIndexMarker217"/> student in Java. The classical approach of introducing Java is to show the student a <em class="italic">Hello World!</em> Example, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> { 
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> { 
    System.out.println(<span class="hljs-string">"Hello World!"</span>);
  }
}
</code></pre>
    <p class="normal">This is the simplest Java example but it is not simple to explain to the student what <code class="inlineCode">public</code> or <code class="inlineCode">static</code> or <code class="inlineCode">String[]</code> are. The ceremony involved in this simple example may scare the student – <em class="italic">if this is a simple example, then how is it a more complex one</em>?</p>
    <p class="normal">Fortunately, starting with JDK 21 (JEP 445), we have <em class="italic">instance main methods</em>, which is a preview feature that allows us to shorten the previous example as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> { 
  <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> { 
    System.out.println(<span class="hljs-string">"Hello World!"</span>);
  }
}
</code></pre>
    <p class="normal">We can even go further and remove the <a id="_idIndexMarker218"/>explicit class declaration as well. This feature is known as <em class="italic">unnamed classes</em>. An unnamed class resides in the unnamed package that resides in the unnamed module:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> { 
  System.out.println(<span class="hljs-string">"Hello World!"</span>);
}
</code></pre>
    <p class="normal">Java will generate the class on our behalf. The name of the class will be the same as the name of the source file.</p>
    <p class="normal">That’s all we need to introduce Java to a student. I strongly encourage you to read JEP 445 (and the new JEPs that will continue this JDK 21 preview feature work) to discover all the aspects involved in these features.</p>
    <h1 id="_idParaDest-80" class="heading-1">42. Adding code snippets in Java API documentation</h1>
    <p class="normal">I’m sure that you are familiar with generating <strong class="keyWord">Java API documentation</strong> (<strong class="keyWord">Javadoc</strong>) for your projects. We can<a id="_idIndexMarker219"/> do it via the <code class="inlineCode">javadoc</code> tool from the command line, via IDE support, via the Maven plugin (<code class="inlineCode">maven-javadoc-plugin</code>), and so on.</p>
    <p class="normal">A common case in writing the Javadoc consists of adding snippets of code to exemplify the usage of a non-trivial class or method. Before JDK 18, adding snippets of code in documentation can be done via <code class="inlineCode">{@code...}</code> or the <code class="inlineCode">&lt;pre&gt;</code> tag. The added code is treated as plain text, is not validated for correctness, and is not discoverable by other tools. Let’s quickly see an example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * A telemeter with laser ranging from 0 to 60 ft including   </span>
<span class="hljs-comment"> * calculation of surfaces and volumes with high-precision</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * &lt;pre&gt;{@code</span>
<span class="hljs-comment"> *     Telemeter.Calibrate.at(0.00001);</span>
<span class="hljs-comment"> *     Telemeter telemeter = new Telemeter(0.15, 2, "IP54");</span>
<span class="hljs-comment"> * }&lt;/pre&gt;</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Telemeter</span> {
   ...
</code></pre>
    <p class="normal">In the bundled code, you can see the full example. The Javadoc is generated at build time via the Maven plugin (<code class="inlineCode">maven-javadoc-plugin</code>), so simply trigger a build.</p>
    <p class="normal">Starting with JDK 18 (JEP 413 - <em class="italic">Code Snippets in Java API Documentation</em>), we have brand new support for adding snippets of code in documentation via the <code class="inlineCode">{@snippet...}</code> tag. The code added via <code class="inlineCode">@snippet</code> can be discovered and validated by third-party tools (not by the <code class="inlineCode">javadoc</code> tool itself). </p>
    <p class="normal">For instance, the previous<a id="_idIndexMarker220"/> snippet can be added via <code class="inlineCode">@snippet</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * A telemeter with laser ranging from 0 to 60 ft including   </span>
<span class="hljs-comment"> * calculation of surfaces and volumes with high-precision</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * {@snippet :</span>
<span class="hljs-comment"> *     Telemeter.Calibrate.at(0.00001);</span>
<span class="hljs-comment"> *     Telemeter telemeter = new Telemeter(0.15, 2, "IP54");</span>
<span class="hljs-comment"> * }</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Telemeter</span> {
   ...
</code></pre>
    <p class="normal">A screenshot of the output is in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_13.png" alt="Figure 2.13.png"/></figure>
    <p class="packt_figref">Figure 2.13: Simple output from @snippet</p>
    <p class="normal">The effective code starts from the newline placed after the colon (<code class="inlineCode">:</code>) and ends before the closing right curly bracket (<code class="inlineCode">}</code>). The code indentation is treated as in code blocks, so the compiler removes the incidental white spaces and we can indent the code with respect to the closing right curly bracket (<code class="inlineCode">}</code>). Check out the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_14.png" alt="Figure 2.14.png"/></figure>
    <p class="packt_figref">Figure 2.14: Indentation of code snippets</p>
    <p class="normal">In the top example, the closing<a id="_idIndexMarker221"/> right curly bracket is aligned under the opening left curly bracket, while in the bottom example, we shifted the closing right curly bracket to the right.</p>
    <h2 id="_idParaDest-81" class="heading-2">Adding attributes</h2>
    <p class="normal">We can specify attributes for a <code class="inlineCode">@snippet</code> via <em class="italic">name=value</em> pairs. For instance, we can provide a tip about the<a id="_idIndexMarker222"/> programming language of our snippet via the <code class="inlineCode">lang</code> attribute. The value of the attribute is available to external tools and is present in the generated HTML. Here are two examples:</p>
    <pre class="programlisting code"><code class="hljs-code"> * {<span class="hljs-meta">@snippet</span> lang=<span class="hljs-string">"java"</span> :
 *     Telemeter.Calibrate.at(<span class="hljs-number">0.00001</span>);
 *     <span class="hljs-type">Telemeter</span> <span class="hljs-variable">telemeter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Telemeter</span>(<span class="hljs-number">0.15</span>, <span class="hljs-number">2</span>, <span class="hljs-string">"IP54"</span>);
 * }
</code></pre>
    <p class="normal">In the generated HTML, you’ll easily identify this attribute as:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">code</span><span class="hljs-tag"> </span><span class="hljs-attr">class</span><span class="hljs-tag">=</span><span class="hljs-string">"language-java"</span><span class="hljs-tag">&gt;</span> … <span class="hljs-tag">&lt;/</span><span class="hljs-name">code</span><span class="hljs-tag">&gt;</span>
</code></pre>
    <p class="normal">If the code is a structured text such as a <em class="italic">properties</em> file, then you can follow this example:</p>
    <pre class="programlisting code"><code class="hljs-code"> * {<span class="hljs-meta">@snippet</span> lang=<span class="hljs-string">"properties"</span> :
 *   telemeter.precision.<span class="hljs-keyword">default</span>=<span class="hljs-number">42</span>
 *   telemeter.clazz.<span class="hljs-keyword">default</span>=<span class="hljs-number">2</span>
 * }
</code></pre>
    <p class="normal">In the generated HTML, you’ll have:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">code</span><span class="hljs-tag"> </span><span class="hljs-attr">class</span><span class="hljs-tag">=</span><span class="hljs-string">"language-properties"</span><span class="hljs-tag">&gt;&lt;/</span><span class="hljs-name">code</span><span class="hljs-tag">&gt;</span>
</code></pre>
    <p class="normal">Next, let’s see how can we alter <a id="_idIndexMarker223"/>what is displayed in a snippet.</p>
    <h2 id="_idParaDest-82" class="heading-2">Using markup comments and regions</h2>
    <p class="normal">We can visually alter a<a id="_idIndexMarker224"/> snippet of code via <em class="italic">markup comments</em>. A markup comment occurs at the end of the line and it contains one or more <em class="italic">markup tags</em> of the form <code class="inlineCode">@name args</code>, where <code class="inlineCode">args</code> are commonly <em class="italic">name=value</em> pairs. Common markup comments include highlighting, linking, and content (text) modifications.</p>
    <h3 id="_idParaDest-83" class="heading-3">Highlighting</h3>
    <p class="normal">Highlighting a whole line can be<a id="_idIndexMarker225"/> done via <code class="inlineCode">@highlight</code> without arguments, as in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_15.png" alt="Figure 2.15.png"/></figure>
    <p class="packt_figref">Figure 2.15: Highlighting a whole line of code</p>
    <p class="normal">As you can see in this figure, the first line of code was bolded.</p>
    <p class="normal">If we want to highlight multiple lines, then we can define <em class="italic">regions</em>. A region can be treated as anonymous or have an explicit name. An anonymous region is demarcated by the word <code class="inlineCode">region</code> placed as an argument of the markup tag and the <code class="inlineCode">@end</code> tag placed at the end of the region. Here is an example for highlighting two regions (an anonymous one and a named one (<code class="inlineCode">R1</code>)):</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_16.png" alt="Figure 2.16.png"/></figure>
    <p class="packt_figref">Figure 2.16: Highlighting a block of code using regions</p>
    <p class="normal">Regular expressions allow <a id="_idIndexMarker226"/>us to highlight a certain part of the code. For instance, highlighting everything that occurs between quotes can be done via <code class="inlineCode">@highlight regex='".*"'</code>. Or, highlighting only the word <em class="italic">Calibrate</em> can be done via the <code class="inlineCode">substring="Calibrate"</code> argument, as in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_17.png" alt="Figure 2.17.png"/></figure>
    <p class="packt_figref">Figure 2.17: Highlighting only the word “Calibrate”</p>
    <p class="normal">Next, let’s talk about adding links in code.</p>
    <h3 id="_idParaDest-84" class="heading-3">Linking</h3>
    <p class="normal">Adding links in code can be done via the <code class="inlineCode">@link</code> tag. The common arguments are <code class="inlineCode">substring="…"</code> and <code class="inlineCode">target="…"</code>. For instance, the following<a id="_idIndexMarker227"/> snippet provides a link for the text <em class="italic">Calibrate</em> that navigates in documentation to the description of the <code class="inlineCode">Calibrate.at()</code> method:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_18.png" alt="Figure 2.18.png"/></figure>
    <p class="packt_figref">Figure 2.18: Adding links in code</p>
    <p class="normal">Next, let’s see how we can <a id="_idIndexMarker228"/>modify the code’s text.</p>
    <h3 id="_idParaDest-85" class="heading-3">Modifying the code’s text</h3>
    <p class="normal">Sometimes we may need to alter the<a id="_idIndexMarker229"/> code’s text. For instance, instead of <code class="inlineCode">Telemeter.Calibrate.at(0.00001, "HIGH");</code>, we want to render in documentation <code class="inlineCode">Telemeter.Calibrate.at(eps, "HIGH");</code>. So, we need to replace <code class="inlineCode">0.00001</code> with <code class="inlineCode">eps</code>. This is the perfect job for the <code class="inlineCode">@replace</code> tag. Common arguments include <code class="inlineCode">substring="…"</code> (or, <code class="inlineCode">regex="…"</code>) and <code class="inlineCode">replacement="..."</code>. Here is the snippet:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_19.png" alt="Figure 2.19.png"/></figure>
    <p class="packt_figref">Figure 2.19: Replacing the code’s text</p>
    <p class="normal">If you need to perform multiple replacements in a block of code, then rely on regions. In the following example, we apply a regular expression to a block of code:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_20.png" alt="Figure 2.20.png"/></figure>
    <p class="packt_figref">Figure 2.20: Applying multiple replacements via a simple regex and an anonymous region</p>
    <p class="normal">If you need to perform more replacements on the same line, then just chain multiple <code class="inlineCode">@replace</code> tags (this statement applies to all tags such as <code class="inlineCode">@highlight</code>, <code class="inlineCode">@link</code>, and so on).</p>
    <h2 id="_idParaDest-86" class="heading-2">Using external snippets</h2>
    <p class="normal">So far, we have used only inlined <a id="_idIndexMarker230"/>snippets. But, there are scenarios when using inlined snippets is not a convenient approach (for instance, if we need to repeat some parts of the documentation) or it is not possible to use them (for instance, if we want to embed <code class="inlineCode">/*…*/</code> comments, which cannot be added in inlined snippets).</p>
    <p class="normal">For such cases, we can use external snippets. Without any further configurations, JDK automatically recognizes external snippets if they are placed in a subfolder of the package (folder) containing the snippet tag. This subfolder should be named <code class="inlineCode">snippet-files</code> and it can contain external snippets as Java sources, plain text files, or properties files. In the following figure, we have a single external file named <code class="inlineCode">MainSnippet.txt</code>:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_21.png" alt="Figure 2.21.png"/></figure>
    <p class="packt_figref">Figure 2.21: External snippets in snippet-files</p>
    <p class="normal">If the external snippet is<a id="_idIndexMarker231"/> not a Java file, then it can be loaded via <code class="inlineCode">{@snippet file …}</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">{<span class="hljs-meta">@snippet</span> file = MainSnippet.txt}
{<span class="hljs-meta">@snippet</span> file = <span class="hljs-string">"MainSnippet.txt"</span>}
{<span class="hljs-meta">@snippet</span> file = <span class="hljs-string">'MainSnippet.txt'</span>}
</code></pre>
    <p class="normal">But, we can also customize the place and folder name of external snippets. For instance, let’s place the external snippets in a folder named <code class="inlineCode">snippet-src</code>, as follows:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_22.png" alt="Figure 2.22.png"/></figure>
    <p class="packt_figref">Figure 2.22: External snippets in a custom folder and place</p>
    <p class="normal">This time, we have to instruct the compiler where to find the external snippets. This is done by passing the <code class="inlineCode">--snippet-path</code> option to <code class="inlineCode">javadoc</code>. Of course, you can pass it via the command line, via your IDE, or via <code class="inlineCode">maven-javadoc-plugin</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">&lt;additionalJOption&gt;
  --snippet-path C:\...\src\snippet-src
&lt;/additionalJOption&gt;
</code></pre>
    <p class="normal">This path is relative to your <a id="_idIndexMarker232"/>machine, so feel free to adjust it accordingly in <code class="inlineCode">pom.xml</code>.</p>
    <p class="normal">Next, <code class="inlineCode">AtSnippet.txt</code> and <code class="inlineCode">ParamDefaultSnippet.properties</code> can be loaded exactly as you saw earlier for <code class="inlineCode">MainSnippet.txt</code>. However, loading Java sources, such as <code class="inlineCode">DistanceSnippet.java</code>, can be done via <code class="inlineCode">{@snippet class…}</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">{<span class="hljs-meta">@snippet</span> class = DistanceSnippet}
{<span class="hljs-meta">@snippet</span> class = <span class="hljs-string">"DistanceSnippet"</span>}
{<span class="hljs-meta">@snippet</span> class = <span class="hljs-string">'DistanceSnippet'</span>}
</code></pre>
    <p class="normal">But, do not add explicitly the <code class="inlineCode">.java</code> extension because you’ll get an error such as <em class="italic">file not found on source path or snippet path: DistanceSnippet/java.java</em>:</p>
    <pre class="programlisting code"><code class="hljs-code">{<span class="hljs-meta">@snippet</span> class = DistanceSnippet.java}
</code></pre>
    <p class="normal">When using Java sources as external snippets, pay attention to the following note.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">Even if the predefined <code class="inlineCode">snippet-files</code> name is an invalid name for a Java package, some systems may treat this folder as being part of the package hierarchy. In such cases, if you place Java sources in this folder, you’ll get an error such as <em class="italic">Illegal package name: “foo.buzz.snippet-files”</em>. If you find yourself in this scenario, then simply use another folder name and location for the documentation external snippets written in Java sources.</p>
    </div>
    <h3 id="_idParaDest-87" class="heading-3">Regions in external snippets</h3>
    <p class="normal">The external snippets support<a id="_idIndexMarker233"/> regions via <code class="inlineCode">@start region=…</code> and <code class="inlineCode">@end region=…</code>. For instance, in <code class="inlineCode">AtSnippet.txt</code>, we have the following region:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// This is an example used in the documentation</span>
<span class="hljs-comment">// @start region=only-code </span>
   Telemeter.Calibrate.at(<span class="hljs-number">0.00001</span>, <span class="hljs-string">"HIGH"</span>);  
<span class="hljs-comment">// @end region=only-code</span>
</code></pre>
    <p class="normal">Now, if we load the region as:</p>
    <pre class="programlisting code"><code class="hljs-code">{<span class="hljs-meta">@snippet</span> file = AtSnippet.txt region=only-code}
</code></pre>
    <p class="normal">We obtain only the code from the region without the text, <em class="italic">// This is an example used in the documentation</em>.</p>
    <p class="normal">Here is another example of a properties file with two regions:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># @start region=dist</span>
<span class="hljs-attr">sc</span>=<span class="hljs-string">[0,0]</span>
<span class="hljs-attr">ec</span>=<span class="hljs-string">[0,0]</span>
<span class="hljs-attr">interpolation</span>=<span class="hljs-string">false</span>
<span class="hljs-comment"># @end region=dist</span>
<span class="hljs-comment"># @start region=at</span>
<span class="hljs-attr">eps</span>=<span class="hljs-string">0.1</span>
<span class="hljs-attr">type</span>=<span class="hljs-string">null</span>
<span class="hljs-comment"># @end region=at</span>
</code></pre>
    <p class="normal">The region <code class="inlineCode">dist</code> is used to<a id="_idIndexMarker234"/> show the default values for the arguments of the <code class="inlineCode">distance()</code> method in the documentation:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_23.png" alt="Figure 2.23.png"/></figure>
    <p class="packt_figref">Figure 2.23: Using the dist region</p>
    <p class="normal">And, the <code class="inlineCode">at</code> region is used to show the default values for the arguments of the <code class="inlineCode">at()</code> method in the documentation:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_24.png" alt="Figure 2.24.png"/></figure>
    <p class="packt_figref">Figure 2.24: Using the “at” region</p>
    <p class="normal">In external snippets, we can use the same tags as in the inlined snippets. For instance, in the following figure, you<a id="_idIndexMarker235"/> can see the complete source of <code class="inlineCode">AtSnippet.txt</code>:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_25.png" alt="Figure 2.25.png"/></figure>
    <p class="packt_figref">Figure 2.25: Source of AtSnippet.txt </p>
    <p class="normal">Notice the presence of <code class="inlineCode">@highlight</code> and <code class="inlineCode">@replace</code>.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">Starting with JDK 19, the Javadoc search feature was also improved. In other words, JDK 19+ can generate a standalone search page for searching in the Javadoc API documentation. Moreover, the search syntax has been enhanced to support multiple search words.</p>
    </div>
    <p class="normal">You can practice these examples in the bundled code.</p>
    <h1 id="_idParaDest-88" class="heading-1">43. Invoking default methods from Proxy instances</h1>
    <p class="normal">Starting with JDK 8, we can define <code class="inlineCode">default</code> methods in interfaces. For instance, let’s consider the following<a id="_idIndexMarker236"/> interfaces (for brevity, all methods from these interfaces are declared as <code class="inlineCode">default</code>):</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_26.png" alt="Figure 2.26.png"/></figure>
    <p class="packt_figref">Figure 2.26: Interfaces: Printable, Writable, Draft, and Book</p>
    <p class="normal">Next, let’s assume that we want to use the Java Reflection API to invoke these default methods. As a quick reminder, the <code class="inlineCode">Proxy</code> class goal is used to provide support for creating dynamic implementations of interfaces at runtime.</p>
    <p class="normal">That being said, let’s see how we can use the Proxy API for calling our <code class="inlineCode">default</code> methods.</p>
    <h2 id="_idParaDest-89" class="heading-2">JDK 8</h2>
    <p class="normal">Calling a <code class="inlineCode">default</code> method of an interface in JDK 8 relies on a little trick. Basically, we create from scratch a <em class="italic">package-private</em> constructor from the Lookup API. Next, we make this constructor accessible – this means that Java will not check the access modifiers to this constructor and, therefore, will not<a id="_idIndexMarker237"/> throw an <code class="inlineCode">IllegalAccessException</code> when we try to use it. Finally, we use this constructor to wrap an instance of an interface (for instance, <code class="inlineCode">Printable</code>) and use reflective access to the <code class="inlineCode">default</code> methods declared in this interface.</p>
    <p class="normal">So, in code lines, we can invoke the default method <code class="inlineCode">Printable.print()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// invoke Printable.print(String)</span>
<span class="hljs-type">Printable</span> <span class="hljs-variable">pproxy</span> <span class="hljs-operator">=</span> (Printable) Proxy.newProxyInstance(
  Printable.class.getClassLoader(),
  <span class="hljs-keyword">new</span> <span class="hljs-title">Class</span>&lt;?&gt;[]{Printable.class}, (o, m, p) -&gt; {
    <span class="hljs-keyword">if</span> (m.isDefault()) {
      Constructor&lt;Lookup&gt; cntr = Lookup.class
        .getDeclaredConstructor(Class.class);
      cntr.setAccessible(<span class="hljs-literal">true</span>);
      <span class="hljs-keyword">return</span> cntr.newInstance(Printable.class)
                 .in(Printable.class)
                 .unreflectSpecial(m, Printable.class)
                 .bindTo(o)
                 .invokeWithArguments(p);
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  });
<span class="hljs-comment">// invoke Printable.print()</span>
pproxy.print(<span class="hljs-string">"Chapter 2"</span>);
</code></pre>
    <p class="normal">Next, let’s focus on the <code class="inlineCode">Writable</code> and <code class="inlineCode">Draft</code> interfaces. <code class="inlineCode">Draft</code> extends <code class="inlineCode">Writable</code> and overrides the <code class="inlineCode">default write()</code>method. Now, every time we explicitly invoke the <code class="inlineCode">Writable.write()</code> method, we<a id="_idIndexMarker238"/> expect that the <code class="inlineCode">Draft.write()</code> method is invoked automatically behind the scenes. A possible implementation looks as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// invoke Draft.write(String) and Writable.write(String)</span>
<span class="hljs-type">Writable</span> <span class="hljs-variable">dpproxy</span> <span class="hljs-operator">=</span> (Writable) Proxy.newProxyInstance(
 Writable.class.getClassLoader(),
  <span class="hljs-keyword">new</span> <span class="hljs-title">Class</span>&lt;?&gt;[]{Writable.class, Draft.class}, (o, m, p) -&gt; {
   <span class="hljs-keyword">if</span> (m.isDefault() &amp;&amp; m.getName().equals(<span class="hljs-string">"write"</span>)) {
    Constructor&lt;Lookup&gt; cntr = Lookup.class
     .getDeclaredConstructor(Class.class);
    cntr.setAccessible(<span class="hljs-literal">true</span>); 
    cntr.newInstance(Draft.class)
        .in(Draft.class)
        .findSpecial(Draft.class, <span class="hljs-string">"write"</span>,
           MethodType.methodType(<span class="hljs-keyword">void</span>.class, String.class), 
           Draft.class)
        .bindTo(o)
        .invokeWithArguments(p);
    <span class="hljs-keyword">return</span> cntr.newInstance(Writable.class)
        .in(Writable.class)
        .findSpecial(Writable.class, <span class="hljs-string">"write"</span>,
           MethodType.methodType(<span class="hljs-keyword">void</span>.class, String.class), 
           Writable.class)
        .bindTo(o)
        .invokeWithArguments(p);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  });
<span class="hljs-comment">// invoke Writable.write(String)</span>
dpproxy.write(<span class="hljs-string">"Chapter 1"</span>);
</code></pre>
    <p class="normal">Finally, let’s focus on the <code class="inlineCode">Printable</code> and <code class="inlineCode">Book</code> interfaces. <code class="inlineCode">Book</code> extends <code class="inlineCode">Printable</code> and doesn’t define any methods. So, when<a id="_idIndexMarker239"/> we call the inherited <code class="inlineCode">print()</code> method, we expect that the <code class="inlineCode">Printable.print()</code> method is invoked. While you can check this solution in the bundled code, let’s focus on the same tasks using JDK 9+.</p>
    <h2 id="_idParaDest-90" class="heading-2">JDK 9+, pre-JDK 16</h2>
    <p class="normal">As you just saw, before JDK 9, the<a id="_idIndexMarker240"/> Java Reflection API provides access to non-public class members. This means that external reflective code (for instance, third-party libraries) can have deep access to <a id="_idIndexMarker241"/>JDK internals. But, starting with JDK 9, this is not possible because the new module system relies on strong encapsulation.</p>
    <p class="normal">For a smooth transition from JDK 8 to JDK 9, we can use the <code class="inlineCode">--illegal-access</code> option. The values of this option range from <code class="inlineCode">deny</code> (sustains strong encapsulation, so no illegal reflective code is permitted) to <code class="inlineCode">permit</code> (the most relaxed level of strong encapsulation, allowing access to platform modules only from unnamed modules). Between <code class="inlineCode">permit</code> (which is the default in JDK 9) and <code class="inlineCode">deny</code>, we have two more values: <code class="inlineCode">warn</code> and <code class="inlineCode">debug</code>. However, <code class="inlineCode">--illegal-access=permit;</code> support was removed in JDK 17.</p>
    <p class="normal">In this context, the previous code may not work in JDK 9+, or it might still work but you’ll see a warning such as <em class="italic">WARNING: An illegal reflective access operation has occurred</em>.</p>
    <p class="normal">But, we can “fix” our code to avoid illegal reflective access via <code class="inlineCode">MethodHandles</code>. Among its goodies, this class exposes lookup methods for creating method handles for fields and methods. Once we have a <code class="inlineCode">Lookup</code>, we can rely on its <code class="inlineCode">findSpecial()</code> method to gain access to the <code class="inlineCode">default</code> methods of an interface.</p>
    <p class="normal">Based on <code class="inlineCode">MethodHandles</code>, we can invoke the default method <code class="inlineCode">Printable.print()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// invoke Printable.print(String doc)</span>
<span class="hljs-type">Printable</span> <span class="hljs-variable">pproxy</span> <span class="hljs-operator">=</span> (Printable) Proxy.newProxyInstance(
    Printable.class.getClassLoader(),
    <span class="hljs-keyword">new</span> <span class="hljs-title">Class</span>&lt;?&gt;[]{Printable.class}, (o, m, p) -&gt; {
      <span class="hljs-keyword">if</span> (m.isDefault()) {
       <span class="hljs-keyword">return</span> MethodHandles.lookup()
         .findSpecial(Printable.class, <span class="hljs-string">"print"</span>,  
           MethodType.methodType(<span class="hljs-keyword">void</span>.class, String.class), 
           Printable.class)
         .bindTo(o)
         .invokeWithArguments(p);
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  });
<span class="hljs-comment">// invoke Printable.print()</span>
pproxy.print(<span class="hljs-string">"Chapter 2"</span>);
</code></pre>
    <p class="normal">While in the bundled code, you <a id="_idIndexMarker242"/>can see more examples; let’s tackle the same topic starting <a id="_idIndexMarker243"/>with JDK 16.</p>
    <h2 id="_idParaDest-91" class="heading-2">JDK 16+</h2>
    <p class="normal">Starting with JDK 16, we can simplify<a id="_idIndexMarker244"/> the previous code thanks to the new static method, <code class="inlineCode">InvocationHandler.invokeDefault()</code>. As its name suggests, this method is useful for invoking <code class="inlineCode">default</code> methods. In code lines, our previous examples for calling <code class="inlineCode">Printable.print()</code> can be simplified via <code class="inlineCode">invokeDefault()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// invoke Printable.print(String doc)</span>
<span class="hljs-type">Printable</span> <span class="hljs-variable">pproxy</span> <span class="hljs-operator">=</span> (Printable) Proxy.newProxyInstance(
  Printable.class.getClassLoader(),
    <span class="hljs-keyword">new</span> <span class="hljs-title">Class</span>&lt;?&gt;[]{Printable.class}, (o, m, p) -&gt; {
      <span class="hljs-keyword">if</span> (m.isDefault()) {
        <span class="hljs-keyword">return</span> InvocationHandler.invokeDefault(o, m, p);
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  });
<span class="hljs-comment">// invoke Printable.print()</span>
pproxy.print(<span class="hljs-string">"Chapter 2"</span>);
</code></pre>
    <p class="normal">In the next example, every time we explicitly invoke the <code class="inlineCode">Writable.write()</code> method, we expect that the <code class="inlineCode">Draft.write()</code> method is invoked automatically behind the scenes:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// invoke Draft.write(String) and Writable.write(String)</span>
<span class="hljs-type">Writable</span> <span class="hljs-variable">dpproxy</span> <span class="hljs-operator">=</span> (Writable) Proxy.newProxyInstance(
 Writable.class.getClassLoader(),
  <span class="hljs-keyword">new</span> <span class="hljs-title">Class</span>&lt;?&gt;[]{Writable.class, Draft.class}, (o, m, p) -&gt; {
   <span class="hljs-keyword">if</span> (m.isDefault() &amp;&amp; m.getName().equals(<span class="hljs-string">"write"</span>)) {
    <span class="hljs-type">Method</span> <span class="hljs-variable">writeInDraft</span> <span class="hljs-operator">=</span> Draft.class.getMethod(
     m.getName(), m.getParameterTypes());
    InvocationHandler.invokeDefault(o, writeInDraft, p);
    <span class="hljs-keyword">return</span> InvocationHandler.invokeDefault(o, m, p);
   }
   <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
 });
<span class="hljs-comment">// invoke Writable.write(String)</span>
dpproxy.write(<span class="hljs-string">"Chapter 1"</span>);
</code></pre>
    <p class="normal">In the bundled code, you can practice more<a id="_idIndexMarker245"/> examples.</p>
    <h1 id="_idParaDest-92" class="heading-1">44. Converting between bytes and hex-encoded strings</h1>
    <p class="normal">Converting bytes to hexadecimal (and vice versa) is a common operation in applications that manipulate fluxes of files/messages, perform <a id="_idIndexMarker246"/>encoding/decoding tasks, process images, and so on.</p>
    <p class="normal">A Java byte is a number in the [-128, +127] range and is represented using 1 signed byte (8 bits). A hexadecimal (base 16) is a system based on 16 digits (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, and F). In other words, those 8 bits of a byte value accommodate exactly 2 hexadecimal characters in the range 00 to FF. The decimal &lt;-&gt; binary &lt;-&gt; hexadecimal mapping is resumed in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_27.png" alt="Figure 2.27.png"/></figure>
    <p class="packt_figref">Figure 2.27: Decimal to binary to hexadecimal conversion</p>
    <p class="normal">For instance, 122 in binary is 01111010. Since 0111 is in hexadecimal 7, and 1010 is A, this results in 122 being 7A in hexadecimal (also written as 0x7A). </p>
    <p class="normal">How about a negative byte? We know from the previous chapter that Java represents a negative number as <em class="italic">two’s complement</em> of the positive number. This means that -122 in binary is 10000110 (retain the first 7 bits of positive 122 = 1111010, flip(1111010) = 0000101, add(0000001) = 00000110, and append sign bit 1, 10000110) and in hexadecimal, is 0x86.</p>
    <p class="normal">Converting a negative number to <a id="_idIndexMarker247"/>hexadecimal can be done in several ways, but we can easily obtain the lower 4 bits as 10000110 &amp; 0xF = 0110, and the higher four bits as (10000110&gt;&gt; 4) &amp; 0xF = 1000 &amp; 0xF = 1000 (here, the 0xF (binary, 1111) mask is useful only for negative numbers). Since, 0110 = 6 and 1000 = 8, we see that 10000110 is in hexadecimal 0x86. </p>
    <p class="normal">If you need a deep coverage of bits manipulation in Java or you simply face issues in understanding the current topic, then please consider the book <em class="italic">The Complete Coding Interview Guide in Java</em>, especially <em class="italic">Chapter 9</em>.</p>
    <p class="normal">So, in code lines, we can rely on this simple algorithm and <code class="inlineCode">Character.forDigit(int d, int r)</code>, which returns the character representation for the given digit (<code class="inlineCode">d</code>) in the given radix (<code class="inlineCode">r</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">byteToHexString</span><span class="hljs-params">(</span><span class="hljs-type">byte</span><span class="hljs-params"> v)</span> {
  <span class="hljs-type">int</span> <span class="hljs-variable">higher</span> <span class="hljs-operator">=</span> (v &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0xF</span>;
  <span class="hljs-type">int</span> <span class="hljs-variable">lower</span> <span class="hljs-operator">=</span> v &amp; <span class="hljs-number">0xF</span>;
  <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> String.valueOf(
    <span class="hljs-keyword">new</span> <span class="hljs-title">char</span>[]{
      Character.forDigit(higher, <span class="hljs-number">16</span>),
      Character.forDigit(lower, <span class="hljs-number">16</span>)}
    );
  <span class="hljs-keyword">return</span> result;
}
</code></pre>
    <p class="normal">There are many other ways to solve this problem (in the bundled code, you can see another flavor of this solution). For example, if we know that the <code class="inlineCode">Integer.toHexString(int n)</code> method returns a string that represents the unsigned integer in base 16 of the given argument, then all we need is to apply the 0xFF (binary, 11111111) mask for negatives as:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">byteToHexString</span><span class="hljs-params">(</span><span class="hljs-type">byte</span><span class="hljs-params"> v)</span> {
  <span class="hljs-keyword">return</span> Integer.toHexString(v &amp; <span class="hljs-number">0xFF</span>);
}
</code></pre>
    <p class="normal">If there is an approach that we should avoid, then that is the one based on <code class="inlineCode">String.format()</code>. The <code class="inlineCode">String.format("%02x ", byte_nr)</code> approach is concise but very slow!</p>
    <p class="normal">How about the reverse process? Converting a given hexadecimal string (for instance, 7d, 09, and so on) to a byte is quite<a id="_idIndexMarker248"/> easy. Just take the first (<code class="inlineCode">d1</code>) and second (<code class="inlineCode">d2</code>) character of the given string and apply the relation, <code class="inlineCode">(byte) ((d1 &lt;&lt; 4) + d2)</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span> <span class="hljs-title">hexToByte</span><span class="hljs-params">(String s)</span> {
  <span class="hljs-type">int</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> Character.digit(s.charAt(<span class="hljs-number">0</span>), <span class="hljs-number">16</span>);
  <span class="hljs-type">int</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> Character.digit(s.charAt(<span class="hljs-number">1</span>), <span class="hljs-number">16</span>);
  <span class="hljs-keyword">return</span> (<span class="hljs-type">byte</span>) ((d1 &lt;&lt; <span class="hljs-number">4</span>) + d2);
} 
</code></pre>
    <p class="normal">More examples are available in the bundled code. If you rely on third-party libraries, then check Apache Commons Codec (<code class="inlineCode">Hex.encodeHexString()</code>), Guava (<code class="inlineCode">BaseEncoding</code>), Spring Security (<code class="inlineCode">Hex.encode()</code>), Bouncy Castle (<code class="inlineCode">Hex.toHexString()</code>), and so on.</p>
    <h2 id="_idParaDest-93" class="heading-2">JDK 17+</h2>
    <p class="normal">Starting with JDK 17, we can use the <code class="inlineCode">java.util.HexFormat</code> class. This class has plenty of static methods for handling <a id="_idIndexMarker249"/>hexadecimal numbers, including <code class="inlineCode">String toHexDigits(byte value)</code> and <code class="inlineCode">byte[]parseHex(CharSequence string)</code>. So, we can convert a byte to a hexadecimal string as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">byteToHexString</span><span class="hljs-params">(</span><span class="hljs-type">byte</span><span class="hljs-params"> v)</span> {
  <span class="hljs-type">HexFormat</span> <span class="hljs-variable">hex</span> <span class="hljs-operator">=</span> HexFormat.of();
  <span class="hljs-keyword">return</span> hex.toHexDigits(v);
}
</code></pre>
    <p class="normal">And, vice versa as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span> <span class="hljs-title">hexToByte</span><span class="hljs-params">(String s)</span> {
  <span class="hljs-type">HexFormat</span> <span class="hljs-variable">hex</span> <span class="hljs-operator">=</span> HexFormat.of();
  <span class="hljs-keyword">return</span> hex.parseHex(s)[<span class="hljs-number">0</span>];
}
</code></pre>
    <p class="normal">In the bundled code, you can also see the extrapolation of these solutions for converting an array of <a id="_idIndexMarker250"/>bytes (<code class="inlineCode">byte[]</code>) to a <code class="inlineCode">String</code>, and vice versa.</p>
    <h1 id="_idParaDest-94" class="heading-1">45. Exemplify the initialization-on-demand holder design pattern</h1>
    <p class="normal">Before we tackle the solution of implementing<a id="_idIndexMarker251"/> the initialization-on-demand holder design pattern, let’s quickly recap a few ingredients of this solution.</p>
    <h2 id="_idParaDest-95" class="heading-2">Static vs. non-static blocks</h2>
    <p class="normal">In Java, we can have <em class="italic">initialization non-static blocks </em>and <em class="italic">static blocks</em>. An initialization non-static block (or simply, a non-static block) is automatically called every single time we instantiate the class. On the <a id="_idIndexMarker252"/>other hand, an initialization static block (or simply, a static block) is called a single time when the class itself is initialized. No matter how many subsequent instances of that class we create, the static block will never get executed again. In code lines:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">A</span> {
  {
    System.out.println(<span class="hljs-string">"Non-static initializer ..."</span>);
  }
  <span class="hljs-keyword">static</span> {
    System.out.println(<span class="hljs-string">"Static initializer ..."</span>);
  }
}
</code></pre>
    <p class="normal">Next, let’s run the following test code to create three instances of <code class="inlineCode">A</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">A</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">A</span>();
<span class="hljs-type">A</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">A</span>();
<span class="hljs-type">A</span> <span class="hljs-variable">a3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">A</span>();
</code></pre>
    <p class="normal">The output reveals that the static initializer is called only once, while the non-static initializer is called three times:</p>
    <pre class="programlisting con"><code class="hljs-con">Static initializer ...
Non-static initializer ...
Non-static initializer ...
Non-static initializer ...
</code></pre>
    <p class="normal">Moreover, the static initializer is<a id="_idIndexMarker253"/> called before the non-static one. Next, let’s talk about nested classes.</p>
    <h2 id="_idParaDest-96" class="heading-2">Nested classes</h2>
    <p class="normal">Let’s look at a quick <a id="_idIndexMarker254"/>example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">A</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">B</span> { ... }
}
</code></pre>
    <p class="normal">Nested classes can be static or<a id="_idIndexMarker255"/> non-static. A non-static nested class is referred to as an <em class="italic">inner clas</em>s; further, it can be a <em class="italic">local inner class </em>(declared in a method) or an<em class="italic"> anonymous inner class </em>(class with no name). On the other hand, a nested class that is declared static is referred to as a <em class="italic">static nested class</em>. The following figure clarifies these statements:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_28.png" alt="Figure 2.28.png"/></figure>
    <p class="packt_figref">Figure 2.28: Java nested classes</p>
    <p class="normal">Since <code class="inlineCode">B</code> is a static class declared in <code class="inlineCode">A</code>, we say that <code class="inlineCode">B</code> is a static nested class.</p>
    <h2 id="_idParaDest-97" class="heading-2">Tackling the initialization-on-demand holder design pattern</h2>
    <p class="normal">The initialization-on-demand holder design pattern refers to a thread-safe lazy-loaded singleton (single instance) implementation. Before <a id="_idIndexMarker256"/>JDK 16, we can exemplify this design pattern in code as follows (we want a single thread-safe instance of <code class="inlineCode">Connection</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Connection</span> { <span class="hljs-comment">// singleton</span>
  <span class="hljs-keyword">private</span> <span class="hljs-title">Connection</span><span class="hljs-params">()</span> {
  }
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LazyConnection </span>{ <span class="hljs-comment">// holder</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Connection</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Connection</span>();
    <span class="hljs-keyword">static</span> {
      System.out.println(<span class="hljs-string">"Initializing connection ..."</span> 
        + INSTANCE);
    }
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">get</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> LazyConnection.INSTANCE;
  }
}
</code></pre>
    <p class="normal">No matter how many times a thread (multiple threads) calls <code class="inlineCode">Connection.get()</code>, we always get the same instance of <code class="inlineCode">Connection</code>. This is the instance created when we called <code class="inlineCode">get()</code> for the first time (first thread), and Java has initialized the <code class="inlineCode">LazyConnection</code> class and its statics. In<a id="_idIndexMarker257"/> other words, if we never call <code class="inlineCode">get()</code>, then the <code class="inlineCode">LazyConnection</code> class and its statics are never initialized (this is why we name it lazy initialization). And, this is thread-safe because static initializers can be constructed (here, <code class="inlineCode">INSTANCE</code>) and referenced without explicit synchronization since they are run before any thread can use the class (here, <code class="inlineCode">LazyConnection</code>).</p>
    <h2 id="_idParaDest-98" class="heading-2">JDK 16+</h2>
    <p class="normal">Until JDK 16, an inner class could <a id="_idIndexMarker258"/>contain static members as constant variables but it couldn’t contain static initializers. In other words, the following code would not compile because of the static initializer:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">A</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">B</span> {
    {
      System.out.println(<span class="hljs-string">"Non-static initializer ..."</span>);
    }
    <span class="hljs-keyword">static</span> {
      System.out.println(<span class="hljs-string">"Static initializer ..."</span>);
    }
  }
}
</code></pre>
    <p class="normal">But, starting with JDK 16, the previous code is compiled without issues. In other words, starting with JDK 16, Java inner classes can have static members and static initializers.</p>
    <p class="normal">This allows us to tackle the initialization-on-demand holder design pattern from another angle. We can replace<a id="_idIndexMarker259"/> the static nested class, <code class="inlineCode">LazyConnection</code>, with a local inner class as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Connection</span> { <span class="hljs-comment">// singleton</span>
  <span class="hljs-keyword">private</span> <span class="hljs-title">Connection</span><span class="hljs-params">()</span> {
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">get</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">class</span> <span class="hljs-title">LazyConnection </span>{ <span class="hljs-comment">// holder</span>
      <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Connection</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Connection</span>();
      <span class="hljs-keyword">static</span> {
        System.out.println(<span class="hljs-string">"Initializing connection ..."</span> 
          + INSTANCE);
      }
    }
    <span class="hljs-keyword">return</span> LazyConnection.INSTANCE;
  }
}
</code></pre>
    <p class="normal">Now, the <code class="inlineCode">LazyConnection</code> is visible only in its containing method, <code class="inlineCode">get()</code>. As long as we don’t call the <code class="inlineCode">get()</code> method, the connection will not be initialized.</p>
    <h1 id="_idParaDest-99" class="heading-1">46. Adding nested classes in anonymous classes</h1>
    <p class="normal">In the previous problem, we had a brief overview of nested classes. As a quick reminder, an anonymous class (or, anonymous inner class) is like a local inner class without a name. Their purpose is to <a id="_idIndexMarker260"/>provide a more concise and expressive code. However, the code readability may be affected (look ugly), but it may be worth it if you can perform some specific task without having to do a full-blown class. For instance, an anonymous class is useful for altering the behavior of an existing method without spinning a new class. Java uses them typically for event handling and listeners (in GUI applications). Probably the most famous example of an anonymous class is this one from Java code:</p>
    <pre class="programlisting code"><code class="hljs-code">button.addActionListener(<span class="hljs-keyword">new</span> <span class="hljs-title">ActionListener</span>() {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span> {
    ...
  }
}
</code></pre>
    <p class="normal">Nevertheless, while local inner classes are actually class declarations, anonymous classes are expressions. To create <a id="_idIndexMarker261"/>an anonymous class, we have to extend an existing class or implement an interface, as shown in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_29.png" alt="Figure 2.28.png"/></figure>
    <p class="packt_figref">Figure 2.29: Anonymous class via class extension and interface implementation</p>
    <p class="normal">Because they don’t have names, anonymous classes must be declared and instantiated in a single expression. The resulting instance can be assigned to a variable that can be referred to later. The standard syntax for expressions looks like calling a regular Java constructor having the class in a code block ending with a semi-colon (<code class="inlineCode">;</code>). The presence of a semi-colon is a hint that an anonymous class is an expression that must be part of a statement.</p>
    <p class="normal">Finally, anonymous classes cannot have explicit constructors, be abstract, have a single instance, implement multiple interfaces, or be extended. </p>
    <p class="normal">Next, let’s tackle a few examples of nesting classes in anonymous classes. For instance, let’s consider the following interface of a printing service:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Printer</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String quality)</span>;
}
</code></pre>
    <p class="normal">We use the <code class="inlineCode">Printer</code> interface all over the place in our printing service, but we also want to have a helper method that is compact and simply tests our printer functions without requiring further actions or an extra class. We decided to hide this code in a static method named <code class="inlineCode">printerTest()</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printerTest</span><span class="hljs-params">()</span> {
  <span class="hljs-type">Printer</span> <span class="hljs-variable">printer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Printer</span>() {
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String quality)</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-string">"best"</span>.equals(quality)) {
      <span class="hljs-type">Tools</span> <span class="hljs-variable">tools</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Tools</span>();
      tools.enableLaserGuidance();
      tools.setHighResolution();
    }
    System.out.println(<span class="hljs-string">"Printing photo-test ..."</span>);
  }
<span class="hljs-keyword">class</span> <span class="hljs-title">Tools</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enableLaserGuidance</span><span class="hljs-params">()</span> {
      System.out.println(<span class="hljs-string">"Adding laser guidance ..."</span>);
    }
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHighResolution</span><span class="hljs-params">()</span> {
      System.out.println(<span class="hljs-string">"Set high resolution ..."</span>);
    }
  }
};
</code></pre>
    <p class="normal">Testing the <code class="inlineCode">best</code> quality print requires some extra settings wrapped in the inner <code class="inlineCode">Tools</code> class. As you can see, the inner <code class="inlineCode">Tools</code> class is nested in the anonymous class. Another approach consists of moving<a id="_idIndexMarker262"/> the <code class="inlineCode">Tools</code> class inside the <code class="inlineCode">print()</code> method. So, <code class="inlineCode">Tools</code> becomes a local inner class as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Printer</span> <span class="hljs-variable">printer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Printer</span>() {
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String quality)</span> {
    <span class="hljs-keyword">class</span> <span class="hljs-title">Tools</span> {
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enableLaserGuidance</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"Adding laser guidance ..."</span>);
      }
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHighResolution</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">"Set high resolution ..."</span>);
      }
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-string">"best"</span>.equals(quality)) {
      <span class="hljs-type">Tools</span> <span class="hljs-variable">tools</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Tools</span>();
      tools.enableLaserGuidance();
      tools.setHighResolution();
    }
    System.out.println(<span class="hljs-string">"Printing photo-test ..."</span>);
  }
};
</code></pre>
    <p class="normal">The problem with this approach is that the <code class="inlineCode">Tools</code> class cannot be used outside of <code class="inlineCode">print()</code>. So, this strict <a id="_idIndexMarker263"/>encapsulation will restrict us from adding a new method (next to <code class="inlineCode">print()</code>) that also needs the <code class="inlineCode">Tools</code> class.</p>
    <h2 id="_idParaDest-100" class="heading-2">JDK 16+</h2>
    <p class="normal">But, remember from the previous problem that, starting with JDK 16, Java inner classes can have static members and static initializers. This means that we can drop the <code class="inlineCode">Tools</code> class and rely on two static methods as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Printer</span> <span class="hljs-variable">printer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Printer</span>() {
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String quality)</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-string">"best"</span>.equals(quality)) {
      enableLaserGuidance();
      setHighResolution();
    }
    System.out.println(<span class="hljs-string">"Printing your photos ..."</span>);
  }
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enableLaserGuidance</span><span class="hljs-params">()</span> {
    System.out.println(<span class="hljs-string">"Adding laser guidance ..."</span>);
  }
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHighResolution</span><span class="hljs-params">()</span> {
    System.out.println(<span class="hljs-string">"Set high resolution ..."</span>);
  }
};
</code></pre>
    <p class="normal">If you find it more convenient <a id="_idIndexMarker264"/>to pick up these helpers in a static class, then do it:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Printer</span> <span class="hljs-variable">printer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Printer</span>() {
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String quality)</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-string">"best"</span>.equals(quality)) {
      Tools.enableLaserGuidance();
      Tools.setHighResolution();
    }
    System.out.println(<span class="hljs-string">"</span><span class="hljs-string">Printing photo-test ..."</span>);
  }
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Tools</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enableLaserGuidance</span><span class="hljs-params">()</span> {
      System.out.println(<span class="hljs-string">"Adding laser guidance ..."</span>);
    }
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHighResolution</span><span class="hljs-params">()</span> {
      System.out.println(<span class="hljs-string">"Set high resolution ..."</span>);
    }
  }
};
</code></pre>
    <p class="normal">You can practice these examples in the bundled code.</p>
    <h1 id="_idParaDest-101" class="heading-1">47. Exemplify erasure vs. overloading</h1>
    <p class="normal">Before we join them in an <a id="_idIndexMarker265"/>example, let’s quickly tackle erasure and overloading separately.</p>
    <h2 id="_idParaDest-102" class="heading-2">Erasure in a nutshell</h2>
    <p class="normal">Java uses <em class="italic">type erasure</em> at compile time in <a id="_idIndexMarker266"/>order to enforce type constraints and backward compatibility with old bytecode. Basically, at compilation time, all type arguments are replaced by <code class="inlineCode">Object</code> (any generic must be convertible to <code class="inlineCode">Object</code>) or type bounds (<code class="inlineCode">extends</code> or <code class="inlineCode">super</code>). Next, at runtime, the type erased by the compiler will be<a id="_idIndexMarker267"/> replaced by our type. A common case of type erasure implies generics.</p>
    <h3 id="_idParaDest-103" class="heading-3">Erasure of generic types</h3>
    <p class="normal">Practically, the compiler erases the unbound types (such as <code class="inlineCode">E</code>, <code class="inlineCode">T</code>, <code class="inlineCode">U</code>, and so on) with the bounded <code class="inlineCode">Object</code>. This enforces type<a id="_idIndexMarker268"/> safety, as in the following example of <em class="italic">class type erasure</em>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ImmutableStack</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Stack</span>&lt;E&gt; {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E head;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Stack&lt;E&gt; tail;
  ...
</code></pre>
    <p class="normal">The compiler applies type erasure to replace <code class="inlineCode">E</code> with <code class="inlineCode">Object</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ImmutableStack</span>&lt;Object&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Stack</span>&lt;Object&gt; {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object head;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Stack&lt;Object&gt; tail;
  ...
</code></pre>
    <p class="normal">If the <code class="inlineCode">E</code> parameter is bound, then the compiler uses the first bound class. For instance, in a class such as <code class="inlineCode">class Node&lt;T extends Comparable&lt;T&gt;&gt; {...}</code>, the compiler will replace <code class="inlineCode">T</code> with <code class="inlineCode">Comparable</code>. In the same manner, in a class such as <code class="inlineCode">class Computation&lt;T extends Number&gt; {...}</code>, all occurrences of <code class="inlineCode">T</code> would be replaced by the compiler with the upper bound <code class="inlineCode">Number</code>.</p>
    <p class="normal">Check out the following case, which is a classical case of <em class="italic">method type erasure</em>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, R <span class="hljs-keyword">extends</span> <span class="hljs-title">T</span>&gt; List&lt;T&gt; listOf(T t, R r) {
  List&lt;T&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;();
  list.add(t);
  list.add(r);
  <span class="hljs-keyword">return</span> list;
}
<span class="hljs-comment">// use this method</span>
List&lt;Object&gt; list = listOf(<span class="hljs-number">1</span>, <span class="hljs-string">"one"</span>);
</code></pre>
    <p class="normal">How does this work? When we call <code class="inlineCode">listOf(1, "one")</code>, we are actually passing two different types to the generic<a id="_idIndexMarker269"/> parameters <code class="inlineCode">T</code> and <code class="inlineCode">R</code>. The compiler type erasure has replaced <code class="inlineCode">T</code> with <code class="inlineCode">Object</code>. In this way, we can insert different types in the <code class="inlineCode">ArrayList</code> and the code works just fine.</p>
    <h3 id="_idParaDest-104" class="heading-3">Erasure and bridge methods</h3>
    <p class="normal"><em class="italic">Bridge methods</em> are created by the compiler to cover corner cases. Specifically, when the compiler encounters an implementation of a parameterized interface or an extension of a parameterized class, it <a id="_idIndexMarker270"/>may need to generate a bridge method (also known as a<a id="_idIndexMarker271"/> synthetic method) as part of the type erasure phase. For instance, let’s consider the following parameterized class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Puzzle</span>&lt;E&gt; {
  <span class="hljs-keyword">public</span> E piece;
  <span class="hljs-keyword">public</span> <span class="hljs-title">Puzzle</span><span class="hljs-params">(E piece)</span> {
<span class="hljs-built_in">    this</span>.piece = piece;
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPiece</span><span class="hljs-params">(E piece)</span> { 
<span class="hljs-built_in">    this</span>.piece = piece;
  }
}
</code></pre>
    <p class="normal">And, an extension of this class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FunPuzzle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Puzzle</span>&lt;String&gt; {
  <span class="hljs-keyword">public</span> <span class="hljs-title">FunPuzzle</span><span class="hljs-params">(String piece)</span> {
    <span class="hljs-built_in">super</span>(piece);
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPiece</span><span class="hljs-params">(String piece)</span> { 
<span class="hljs-built_in">    super</span>.setPiece(piece);
  }
}
</code></pre>
    <p class="normal">Type erasure modifies <code class="inlineCode">Puzzle.setPiece(E)</code> as <code class="inlineCode">Puzzle.setPiece(Object)</code>. This means that the <code class="inlineCode">FunPuzzle.setPiece(String)</code> method does not override the <code class="inlineCode">Puzzle.setPiece(Object)</code> method. Since the signatures of the methods are not compatible, the compiler must accommodate the polymorphism of generic types via a bridge (synthetic) method meant to guarantee that sub-typing works as expected. Let’s highlight this method in<a id="_idIndexMarker272"/> the code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">/* Decompiler 8ms, total 3470ms, lines 18 */</span>
<span class="hljs-keyword">package</span> modern.challenge;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FunPuzzle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Puzzle</span>&lt;String&gt; {
   <span class="hljs-keyword">public</span> <span class="hljs-title">FunPuzzle</span><span class="hljs-params">(String piece)</span> {
      <span class="hljs-built_in">super</span>(piece);
   }
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPiece</span><span class="hljs-params">(String piece)</span> {
      <span class="hljs-built_in">super</span>.setPiece(piece);
   }
<span class="code-highlight"><strong class="hljs-slc">   </strong><strong class="hljs-comment-slc">// $FF: synthetic method</strong></span>
<span class="code-highlight"><strong class="hljs-slc">   </strong><strong class="hljs-comment-slc">// $FF: bridge method</strong></span>
<span class="code-highlight"><strong class="hljs-slc">   </strong><strong class="hljs-keyword-slc">public</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">void</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">setPiece</strong><strong class="hljs-params-slc">(Object var1)</strong><strong class="hljs-slc"> {</strong></span>
<span class="code-highlight"><strong class="hljs-slc">      </strong><strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.setPiece((String)var1);</strong></span>
<span class="code-highlight"><strong class="hljs-slc">   }</strong></span>
}
</code></pre>
    <p class="normal">Now, whenever you see a bridge method in the stack trace, you will know what it is and why it is there.</p>
    <h3 id="_idParaDest-105" class="heading-3">Type erasure and heap pollution</h3>
    <p class="normal">Have you ever seen an unchecked warning? I’m sure you have! It’s one of those things that is common to all Java developers. They <a id="_idIndexMarker273"/>may occur at compile-time as the result of type checking, or at runtime as a result of a cast or method call. In both cases, we talk about the fact that the compiler cannot validate the correctness of an operation, which implies some parameterized types. Not every unchecked warning is dangerous, but there are cases when we have to consider and deal with them.</p>
    <p class="normal">A particular case is represented by <em class="italic">heap pollution.</em> If a parameterized variable of a certain type points to an object that is not <a id="_idIndexMarker274"/>of that type, then we are prone to deal with a code that leads to heap pollution. A good candidate for such scenarios involves methods with <code class="inlineCode">varargs</code> arguments.</p>
    <p class="normal">Check out this code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">listOf</span><span class="hljs-params">(List&lt;T&gt; list, T... ts)</span> {
  list.addAll(Arrays.asList(ts));    
}
</code></pre>
    <p class="normal">The <code class="inlineCode">listOf()</code> declaration will cause this warning: <em class="italic">Possible heap pollution from parameterized vararg type T</em>. So, what’s happening here?</p>
    <p class="normal">The story begins when the compiler replaces the formal <code class="inlineCode">T...</code> parameter into an array. After applying type erasure, the <code class="inlineCode">T...</code> parameter becomes <code class="inlineCode">T[]</code>, and finally <code class="inlineCode">Object[]</code>. Consequently, we opened a gate to possible heap pollution. But, our code just added the elements of <code class="inlineCode">Object[]</code> into a <code class="inlineCode">List&lt;Object&gt;</code>, so we are in the safe area. </p>
    <p class="normal">In other words, if you know that the <a id="_idIndexMarker275"/>body of the <code class="inlineCode">varargs</code> method is not prone to generate a specific exception (for example, <code class="inlineCode">ClassCastException</code>) or to use the <code class="inlineCode">varargs</code> parameter in an improper operation, then we can instruct the compiler to suppress these warnings. We can do it via the <code class="inlineCode">@SafeVarargs</code> annotation as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@SafeVarargs</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">listOf</span><span class="hljs-params">(List&lt;T&gt; list, T... ts)</span> {...}
</code></pre>
    <p class="normal">The <code class="inlineCode">@SafeVarargs</code> is a hint that sustains that the annotated method will use the <code class="inlineCode">varargs</code> formal parameter only<a id="_idIndexMarker276"/> in proper operations. More common, but less recommended, is to use <code class="inlineCode">@SuppressWarnings({"unchecked", "varargs"})</code>, which simply suppresses such warnings without claiming that the <code class="inlineCode">varargs</code> formal parameter is not used in improper operations.</p>
    <p class="normal">Now, let’s tackle this code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> {
  List&lt;Integer&gt; ints = <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;();
  Main.listOf(ints, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
  Main.listsOfYeak(ints);
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listsOfYeak</span><span class="hljs-params">(List&lt;Integer&gt;... lists)</span> {
  Object[] listsAsArray = lists;     
  listsAsArray[<span class="hljs-number">0</span>] = Arrays.asList(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>); 
  <span class="hljs-type">Integer</span> <span class="hljs-variable">someInt</span> <span class="hljs-operator">=</span> lists[<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>);   
  listsAsArray[<span class="hljs-number">0</span>] = Arrays.asList(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>); 
  <span class="hljs-type">Integer</span> <span class="hljs-variable">someIntYeak</span> <span class="hljs-operator">=</span> lists[<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>); <span class="hljs-comment">// ClassCastException</span>
}
</code></pre>
    <p class="normal">This time, the type erasure transforms the <code class="inlineCode">List&lt;Integer&gt;...</code> into <code class="inlineCode">List[]</code>, which is a subtype of <code class="inlineCode">Object[]</code>. This allows us to do the assignment: <code class="inlineCode">Object[] listsAsArray = lists;</code>. But, check out the last two lines of code where we create a <code class="inlineCode">List&lt;String&gt;</code> and store it in <code class="inlineCode">listsAsArray[0]</code>. In the last <a id="_idIndexMarker277"/>line, we try to access the first <code class="inlineCode">Integer</code> from <code class="inlineCode">lists[0]</code>, which obviously <a id="_idIndexMarker278"/>leads to a <code class="inlineCode">ClassCastException</code>. This is an improper operation of using <code class="inlineCode">varargs</code>, so it is not advisable to use <code class="inlineCode">@SafeVarargs</code> in this case. We should have taken the following warnings seriously:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// unchecked generic array creation for varargs parameter </span>
<span class="hljs-comment">// of type java.util.List&lt;java.lang.Integer&gt;[]</span>
Main.listsOfYeak(ints);
<span class="hljs-comment">// Possible heap pollution from parameterized vararg</span>
<span class="hljs-comment">// type java.util.List&lt;java.lang.Integer&gt;</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listsOfYeak</span><span class="hljs-params">(List&lt;Integer&gt;... lists)</span> { ... }
</code></pre>
    <p class="normal">Now, that you are familiar with type erasure, let’s briefly cover polymorphic overloading.</p>
    <h2 id="_idParaDest-106" class="heading-2">Polymorphic overloading in a nutshell</h2>
    <p class="normal">Since <em class="italic">overloading</em> (also known as “ad hoc” polymorphism) is a core concept of <strong class="keyWord">Object-Oriented Programming</strong> (<strong class="keyWord">OOP</strong>), I’m sure you are familiar with Java method overloading, so I’ll not insist on the basic theory of this concept.</p>
    <p class="normal">Also, I’m aware that some people don’t<a id="_idIndexMarker279"/> agree that overloading can be a form of polymorphism, but that is another topic that we will not tackle here. </p>
    <p class="normal">We will be more practical and jump into a suite of quizzes meant to highlight some interesting aspects of overloading. More precisely, we will discuss <em class="italic">type dominance</em>. So, let’s tackle the first quiz (<code class="inlineCode">wordie</code> is an initially empty string):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kaboom</span><span class="hljs-params">(</span><span class="hljs-type">byte</span><span class="hljs-params"> b)</span> { wordie += <span class="hljs-string">"a"</span>;}   
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kaboom</span><span class="hljs-params">(</span><span class="hljs-type">short</span><span class="hljs-params"> s)</span> { wordie += <span class="hljs-string">"b"</span>;}   
kaboom(<span class="hljs-number">1</span>);
</code></pre>
    <p class="normal">What will happen? If you answered that the compiler will point out that there is no suitable method found for <code class="inlineCode">kaboom(1)</code>, then you’re right. The compiler looks for a method that gets an integer argument, <code class="inlineCode">kaboom(int)</code>. Okay, that was easy! Here is the next one:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kaboom</span><span class="hljs-params">(</span><span class="hljs-type">byte</span><span class="hljs-params"> b)</span> { wordie += <span class="hljs-string">"</span><span class="hljs-string">a"</span>;}   
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kaboom</span><span class="hljs-params">(</span><span class="hljs-type">short</span><span class="hljs-params"> s)</span> { wordie += <span class="hljs-string">"b"</span>;}  
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kaboom</span><span class="hljs-params">(</span><span class="hljs-type">long</span><span class="hljs-params"> l)</span> { wordie += <span class="hljs-string">"d"</span>;}   
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kaboom</span><span class="hljs-params">(Integer i)</span> { wordie += <span class="hljs-string">"i"</span>;}   
kaboom(<span class="hljs-number">1</span>);
</code></pre>
    <p class="normal">We know that the first two <code class="inlineCode">kaboom()</code> instances are useless. How about <code class="inlineCode">kaboom(long)</code> and <code class="inlineCode">kaboom(Integer)</code>? You are<a id="_idIndexMarker280"/> right, <code class="inlineCode">kaboom(long)</code> will be called. If we remove <code class="inlineCode">kaboom(long)</code>, then <code class="inlineCode">kaboom(Integer)</code> is called.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">In primitive overloading, the compiler starts by searching for a one-to-one match. If this attempt fails, then the compiler searches for an overloading flavor taking a primitive broader domain than the primitive current domain (for instance, for an <code class="inlineCode">int</code>, it looks for <code class="inlineCode">int</code>, <code class="inlineCode">long</code>, <code class="inlineCode">float</code>, or <code class="inlineCode">double</code>). If this fails as well, then the compiler checks for overloading taking boxed types (<code class="inlineCode">Integer</code>, <code class="inlineCode">Float</code>, and so on).</p>
    </div>
    <p class="normal">Following the previous statements, let’s have this one:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kaboom</span><span class="hljs-params">(Integer i)</span> { wordie += <span class="hljs-string">"i"</span>;} 
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kaboom</span><span class="hljs-params">(Long l)</span> { wordie += <span class="hljs-string">"j"</span>;} 
kaboom(<span class="hljs-number">1</span>);
</code></pre>
    <p class="normal">This time, <code class="inlineCode">wordie</code> will be <code class="inlineCode">i</code>. The <code class="inlineCode">kaboom(Integer)</code> is called since there is no <code class="inlineCode">kaboom(int</code>/<code class="inlineCode">long</code>/<code class="inlineCode">float</code>/<code class="inlineCode">double)</code>. If we had a <code class="inlineCode">kaboom(double)</code>, then that method has higher precedence than <code class="inlineCode">kaboom(Integer)</code>. Interesting, right?! On the other hand, if we remove <code class="inlineCode">kaboom(Integer)</code>, then don’t expect that <code class="inlineCode">kaboom(Long)</code> will be called. Any other <code class="inlineCode">kaboom(boxed type)</code> with a broader/narrow domain than <code class="inlineCode">Integer</code> will not be called. This is happening because the compiler follows the inheritance path based on an IS-A relationship, so after <code class="inlineCode">kaboom(Integer)</code>, it looks for <code class="inlineCode">kaboom(Number)</code>, since <code class="inlineCode">Integer</code> is a <code class="inlineCode">Number</code>.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">In boxed type overloading, the compiler starts by searching for a one-to-one match. If this attempt fails, then the compiler will not consider any overloading flavor taking a boxed type with a broader domain than the current domain (of course, a narrow domain is ignored as well). It looks for <code class="inlineCode">Number</code> as being the superclass of all boxed types. If <code class="inlineCode">Number</code> is not found, the compiler goes up in the hierarchy until it reaches the <code class="inlineCode">java.lang.Object</code>, which is the end of the road.</p>
    </div>
    <p class="normal">Okay, let’s complicate <a id="_idIndexMarker281"/>things a little bit:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kaboom</span><span class="hljs-params">(Object... ov)</span> { wordie += <span class="hljs-string">"o"</span>;}   
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kaboom</span><span class="hljs-params">(Number n)</span> { wordie += <span class="hljs-string">"p"</span>;}   
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kaboom</span><span class="hljs-params">(Number... nv)</span> { wordie += <span class="hljs-string">"q"</span>;}  
kaboom(<span class="hljs-number">1</span>);
</code></pre>
    <p class="normal">So, which method will be called this time? I know, you think <code class="inlineCode">kaboom(Number)</code>, right? At least, my simple logic pushes me to think that this is a common-sense choice. And it is correct!</p>
    <p class="normal">If we remove <code class="inlineCode">kaboom(Number)</code>, then the compiler will call the <code class="inlineCode">varargs</code> method, <code class="inlineCode">kaboom(Number...)</code>. This makes sense since <code class="inlineCode">kaboom(1)</code> uses a single argument, so <code class="inlineCode">kaboom(Number)</code> should have higher precedence than <code class="inlineCode">kaboom(Number...)</code>. This logic reverses if we call <code class="inlineCode">kaboom(1,2,3)</code> since <code class="inlineCode">kaboom(Number)</code> is no longer representing a valid overloading for this call, and <code class="inlineCode">kaboom(Number...)</code> is the right choice.</p>
    <p class="normal">But, this logic applies because <code class="inlineCode">Number</code> is the superclass of all boxed classes (<code class="inlineCode">Integer</code>, <code class="inlineCode">Double</code>, <code class="inlineCode">Float</code>, and so on).</p>
    <p class="normal">How about now?</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kaboom</span><span class="hljs-params">(Object... ov)</span> { wordie += <span class="hljs-string">"o"</span>;}   
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kaboom</span><span class="hljs-params">(File... fv)</span> { wordie += <span class="hljs-string">"s"</span>;}   
kaboom(<span class="hljs-number">1</span>);
</code></pre>
    <p class="normal">This time, the compiler will “bypass” <code class="inlineCode">kaboom(File...)</code> and will call <code class="inlineCode">kaboom(Object...)</code>. Based on the same logic, a call of <code class="inlineCode">kaboom(1, 2, 3)</code> will call <code class="inlineCode">kaboom(Object...)</code> since there is no <code class="inlineCode">kaboom(Number...)</code>.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">In overloading, if the call has a single argument, then the method with a single argument has higher precedence than its <code class="inlineCode">varargs</code> counterpart. On the other hand, if the call has more arguments of the same type, then the <code class="inlineCode">varargs</code> method is called since the one-argument method is not suitable anymore. When the call has a single argument but only the <code class="inlineCode">varargs</code> overloading is available, then this method is called.</p>
    </div>
    <p class="normal">This leads us to the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kaboom</span><span class="hljs-params">(Number... nv)</span> { wordie += <span class="hljs-string">"q"</span>;}   
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kaboom</span><span class="hljs-params">(File... fv)</span> { wordie += <span class="hljs-string">"s"</span>;}   
kaboom();
</code></pre>
    <p class="normal">This time, <code class="inlineCode">kaboom()</code> has no arguments and the compiler cannot find a unique match. This means that the <a id="_idIndexMarker282"/>reference to <code class="inlineCode">kaboom()</code> is ambiguous since both methods match (<code class="inlineCode">kaboom(java.lang.Number...)</code> in <code class="inlineCode">modern.challenge.Main</code> and method <code class="inlineCode">kaboom(java.io.File...)</code> in <code class="inlineCode">modern.challenge.Main</code>).</p>
    <p class="normal">In the bundled code, you can play even more with polymorphic overloading and test your knowledge. Moreover, try to challenge yourself and introduce generics in the equation as well.</p>
    <h2 id="_idParaDest-107" class="heading-2">Erasure vs. overloading</h2>
    <p class="normal">Okay, based on the previous <a id="_idIndexMarker283"/>experience, check out this<a id="_idIndexMarker284"/> code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(List&lt;A&gt; listOfA)</span> {
  System.out.println(<span class="hljs-string">"Printing A: "</span> + listOfA);
}
<span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(List&lt;B&gt; listofB)</span> {
  System.out.println(<span class="hljs-string">"Printing B: "</span> + listofB);
}
</code></pre>
    <p class="normal">What will happen? Well, this is a case where overloading and type erasure collide. The type erasure will replace <code class="inlineCode">List&lt;A&gt;</code> with <code class="inlineCode">List&lt;Object&gt;</code> and <code class="inlineCode">List&lt;B&gt;</code> with <code class="inlineCode">List&lt;Object&gt;</code> as well. So, overloading is not possible and we get an error such as <em class="italic">name clash: print(java.util.List&lt;modern.challenge.B&gt;) and print (java.util.List&lt;modern.challenge.A&gt;) have the same erasure</em>.</p>
    <p class="normal">In order to solve this issue, we can add a dummy argument to one of these two methods:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(List&lt;A&gt; listOfA, Void... v)</span> {
  System.out.println(<span class="hljs-string">"Printing A: "</span> + listOfA);
}
</code></pre>
    <p class="normal">Now, we can have the same call for both methods:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">new</span> <span class="hljs-title">Main</span>().print(List.of(<span class="hljs-keyword">new</span> <span class="hljs-title">A</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title">A</span>()));
<span class="hljs-keyword">new</span> <span class="hljs-title">Main</span>().print(List.of(<span class="hljs-keyword">new</span> <span class="hljs-title">B</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title">B</span>()));
</code></pre>
    <p class="normal">Done! You can practice <a id="_idIndexMarker285"/>these examples in the bundled<a id="_idIndexMarker286"/> code.</p>
    <h1 id="_idParaDest-108" class="heading-1">48. Xlinting default constructors</h1>
    <p class="normal">We know that a Java class with no explicit constructor automatically gets an “invisible” default constructor for setting default <a id="_idIndexMarker287"/>values of the instance variables. The following <code class="inlineCode">House</code> class falls in this scenario:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">House</span> {
  <span class="hljs-keyword">private</span> String location;
  <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> price;
  ...
}
</code></pre>
    <p class="normal">If this is exactly what we wanted, then it is no problem. But, if we are concerned about the fact that the default constructors are exposed by classes to publicly exported packages, then we have to consider using JDK 16+. </p>
    <p class="normal">JDK 16+ added a dedicated <em class="italic">lint </em>meant to warn us about the classes that have default constructors. In order to take advantage of this <em class="italic">lint</em>, we have to follow two steps:</p>
    <ul>
      <li class="bulletList">Export the package containing that class</li>
      <li class="bulletList">Compile with <code class="inlineCode">-Xlint:missing-explicit-ctor</code> (or <code class="inlineCode">-Xlint</code>, <code class="inlineCode">-Xlint:all</code>)</li>
    </ul>
    <p class="normal">In our case, we export the package <code class="inlineCode">modern.challenge</code> in <code class="inlineCode">module-info</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">module</span> P48_XlintDefaultConstructor {
  <span class="hljs-keyword">exports</span> modern.challenge;
} 
</code></pre>
    <p class="normal">Once you compile the code with <code class="inlineCode">-Xlint:missing-explicit-ctor</code>, you’ll see a warning like in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_30.png" alt="Figure 2.30.png"/></figure>
    <p class="packt_figref">Figure 2.30: The warning produced by -Xlint:missing-explicit-ctor</p>
    <p class="normal">Now, you can easily find <a id="_idIndexMarker288"/>out which classes have default constructors.</p>
    <h1 id="_idParaDest-109" class="heading-1">49. Working with the receiver parameter</h1>
    <p class="normal">Starting with JDK 8, we can enrich any <a id="_idIndexMarker289"/>of our instance methods with the optional <em class="italic">receiver parameter</em>. This is a purely syntactic parameter of enclosing type exposed via the <code class="inlineCode">this</code> keyword. The following two snippets of code are identical:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Truck</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">revision1</span><span class="hljs-params">(Truck </span><span class="hljs-built_in">this</span><span class="hljs-params">)</span> {
    <span class="hljs-type">Truck</span> <span class="hljs-variable">thisTruck</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;
    System.out.println(<span class="hljs-string">"Truck: "</span> + thisTruck);
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">revision2</span><span class="hljs-params">()</span> {
    <span class="hljs-type">Truck</span> <span class="hljs-variable">thisTruck</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;
    System.out.println(<span class="hljs-string">"Truck: "</span> + thisTruck);
  }
}
</code></pre>
    <p class="normal">Do not conclude that <code class="inlineCode">revision2()</code> is an overloading of <code class="inlineCode">revision1()</code>, or vice versa. Both methods have the same output, the same signature, and produce the same bytecode.</p>
    <p class="normal">The receiver parameter can be used in inner classes as well. Here is an example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PaymentService</span> {
  <span class="hljs-keyword">class</span> <span class="hljs-title">InvoiceCalculation</span> {
    <span class="hljs-keyword">final</span> PaymentService paymentService;
    InvoiceCalculation(PaymentService PaymentService.<span class="hljs-built_in">this</span>) {
      paymentService = PaymentService.<span class="hljs-built_in">this</span>;
    }
  }
}
</code></pre>
    <p class="normal">Okay, but why use the receiver parameter? Well, JDK 8 introduced so-called <em class="italic">type annotations</em>, which are exactly as the <a id="_idIndexMarker290"/>name suggests: annotations that can be applied to types. In this context, the receiver parameter was added for annotating the type of object for which the method is called. Check out the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Target(ElementType.TYPE_USE)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ValidAddress {}
<span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">(</span><span class="hljs-meta">@ValidAddress</span><span class="hljs-params"> Person </span><span class="hljs-built_in">this</span><span class="hljs-params">)</span> { ... }
</code></pre>
    <p class="normal">Or, check this more elaborate example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Parcel</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">order</span><span class="hljs-params">(</span><span class="hljs-meta">@New</span><span class="hljs-params"> Parcel </span><span class="hljs-built_in">this</span><span class="hljs-params">)</span> {...}
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shipping</span><span class="hljs-params">(</span><span class="hljs-meta">@Ordered</span><span class="hljs-params"> Parcel </span><span class="hljs-built_in">this</span><span class="hljs-params">)</span> {...}
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deliver</span><span class="hljs-params">(</span><span class="hljs-meta">@Shipped</span><span class="hljs-params"> Parcel </span><span class="hljs-built_in">this</span><span class="hljs-params">)</span> {...}
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cashit</span><span class="hljs-params">(</span><span class="hljs-meta">@Delivered</span><span class="hljs-params"> Parcel </span><span class="hljs-built_in">this</span><span class="hljs-params">)</span> {...}
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">done</span><span class="hljs-params">(</span><span class="hljs-meta">@Cashed</span><span class="hljs-params"> Parcel </span><span class="hljs-built_in">this</span><span class="hljs-params">)</span> {...}
}
</code></pre>
    <p class="normal">Every client of a <code class="inlineCode">Parcel</code> must call these <a id="_idIndexMarker291"/>methods in a precise sequence drawn via type annotations and receiver parameters. In other words, an order can be placed only if it is a new order, it can be shipped only if the order was placed, it can be delivered only if it was shipped, it can be paid only if it was delivered, and it can be closed only if it was paid.</p>
    <p class="normal">At this moment, this strict sequence is pointed out only by these hypothetical annotations. But, this is the right road to implement further a static analysis tool that will understand the meaning of these annotations and trigger warnings every time a client of <code class="inlineCode">Parcel</code> doesn’t follow this precise sequence.</p>
    <h1 id="_idParaDest-110" class="heading-1">50. Implementing an immutable stack</h1>
    <p class="normal">A common coding challenge<a id="_idIndexMarker292"/> in interviews is this: Implement an immutable stack in Java.</p>
    <p class="normal">Being an abstract data type, a stack needs at least this contract:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Stack</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Iterable</span>&lt;T&gt; {
  <span class="hljs-type">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span>;
  Stack&lt;T&gt; <span class="hljs-title">push</span><span class="hljs-params">(T value)</span>;
  Stack&lt;T&gt; <span class="hljs-title">pop</span><span class="hljs-params">()</span>;
  T <span class="hljs-title">peek</span><span class="hljs-params">()</span>;    
}
</code></pre>
    <p class="normal">Having this contract, we can focus on the immutable implementation. Generally speaking, an immutable data structure stays the same until an operation attempts to change it (for instance, to add, put, remove, delete, push, and so on). If an operation attempts to alter the content of an immutable data structure, a new instance of that data structure must be created and used by that operation, while the previous instance remains unchanged.</p>
    <p class="normal">Now, in our context, we have two operations that can alter the stack content: push and pop. The push operation should return a new stack containing the pushed element, while the pop operation<a id="_idIndexMarker293"/> should return the previous stack. But, in order to accomplish this, we need to start from somewhere, so we need an empty initial stack. This is a singleton stack that can be implemented as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EmptyStack</span>&lt;U&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Stack</span>&lt;U&gt; {
<span class="hljs-meta">  @Override</span>
    <span class="hljs-keyword">public</span> Stack&lt;U&gt; <span class="hljs-title">push</span><span class="hljs-params">(U u)</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ImmutableStack</span>&lt;&gt;(u, <span class="hljs-built_in">this</span>);
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Stack&lt;U&gt; <span class="hljs-title">pop</span><span class="hljs-params">()</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">UnsupportedOperationException</span>(
        <span class="hljs-string">"Unsupported operation on an empty stack"</span>);
    } 
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> U <span class="hljs-title">peek</span><span class="hljs-params">()</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">UnsupportedOperationException</span> (
        <span class="hljs-string">"</span><span class="hljs-string">Unsupported operation on an empty stack"</span>);
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Iterator&lt;U&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">StackIterator</span>&lt;&gt;(<span class="hljs-built_in">this</span>);
  }
}
</code></pre>
    <p class="normal">The <code class="inlineCode">StackIterator</code> is a trivial implementation of the Java <code class="inlineCode">Iterator</code>. Nothing fancy here:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StackIterator</span>&lt;U&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;U&gt; {
  <span class="hljs-keyword">private</span> Stack&lt;U&gt; stack;
  <span class="hljs-keyword">public</span> <span class="hljs-title">StackIterator</span><span class="hljs-params">(</span><span class="hljs-keyword">final</span><span class="hljs-params"> Stack&lt;U&gt; stack)</span> {
    <span class="hljs-built_in">this</span>.stack = stack;
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> !<span class="hljs-built_in">this</span>.stack.isEmpty();
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> U <span class="hljs-title">next</span><span class="hljs-params">()</span> {
    <span class="hljs-type">U</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.stack.peek();
    <span class="hljs-built_in">this</span>.stack = <span class="hljs-built_in">this</span>.stack.pop();
    <span class="hljs-keyword">return</span> e;
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> {
  }
}
</code></pre>
    <p class="normal">So far, we have the <code class="inlineCode">Iterator</code> and an empty stack singleton. Finally, we can implement the logic of the immutable stack<a id="_idIndexMarker294"/> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ImmutableStack</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Stack</span>&lt;E&gt; {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E head;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Stack&lt;E&gt; tail;
  <span class="hljs-keyword">private</span> <span class="hljs-title">ImmutableStack</span><span class="hljs-params">(</span><span class="hljs-keyword">final</span><span class="hljs-params"> E head, </span><span class="hljs-keyword">final</span><span class="hljs-params"> Stack&lt;E&gt; tail)</span> {
    <span class="hljs-built_in">this</span>.head = head;
    <span class="hljs-built_in">this</span>.tail = tail;
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; Stack&lt;U&gt; <span class="hljs-title">empty</span><span class="hljs-params">(</span><span class="hljs-keyword">final</span><span class="hljs-params"> Class&lt;U&gt; type)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">EmptyStack</span>&lt;&gt;();
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> Stack&lt;E&gt; <span class="hljs-title">push</span><span class="hljs-params">(E e)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ImmutableStack</span>&lt;&gt;(e, <span class="hljs-built_in">this</span>);
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> Stack&lt;E&gt; <span class="hljs-title">pop</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.tail;
  }    
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> E <span class="hljs-title">peek</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.head;
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">StackIterator</span>&lt;&gt;(<span class="hljs-built_in">this</span>);
  }
  <span class="hljs-comment">// iterator code</span>
  <span class="hljs-comment">// empty stack singleton code</span>
}
</code></pre>
    <p class="normal">Creating a stack starts by <a id="_idIndexMarker295"/>calling the<code class="inlineCode">ImmutableStack.empty()</code> method, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Stack&lt;String&gt; s = ImmutableStack.empty(String.class);
</code></pre>
    <p class="normal">In the bundled code, you can how this stack can be used further.</p>
    <h1 id="_idParaDest-111" class="heading-1">51. Revealing a common mistake with Strings</h1>
    <p class="normal">Everybody knows that <code class="inlineCode">String</code> is an immutable class.</p>
    <p class="normal">Even so, we are still prone to accidentally<a id="_idIndexMarker296"/> write code that ignores the fact that <code class="inlineCode">String</code> is immutable. Check out this code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">"start"</span>;
str = stopIt(str);
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">stopIt</span><span class="hljs-params">(String str)</span> {
  str.replace(str, <span class="hljs-string">"stop"</span>);
  <span class="hljs-keyword">return</span> str;
}
</code></pre>
    <p class="normal">Somehow, it is logical to think that the <code class="inlineCode">replace()</code> call has replaced the text <em class="italic">start</em> with <em class="italic">stop</em> and now <code class="inlineCode">str</code> is <em class="italic">stop</em>. This is the cognitive power of words (<em class="italic">replace</em> is a verb that clearly induces the idea that the text was replaced). But, <code class="inlineCode">String</code> is immutable! Oh… we already know that! This means that <code class="inlineCode">replace()</code> cannot alter the original <code class="inlineCode">str</code>. There are many such silly mistakes that we are <a id="_idIndexMarker297"/>prone to accidentally make, so pay extra attention to such simple things, since they can waste your time in the debugging stage.</p>
    <p class="normal">The solution is obvious and self-explanatory:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">stopIt</span><span class="hljs-params">(String str)</span> {
  str =  str.replace(str, <span class="hljs-string">"stop"</span>);
  <span class="hljs-keyword">return</span> str;
}
</code></pre>
    <p class="normal">Or, simply:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">stopIt</span><span class="hljs-params">(String str)</span> {
  <span class="hljs-keyword">return</span> str.replace(str, <span class="hljs-string">"stop"</span>);
}
</code></pre>
    <p class="normal">Don’t forget that <code class="inlineCode">String</code> is immutable!</p>
    <h1 id="_idParaDest-112" class="heading-1">52. Using the enhanced NullPointerException</h1>
    <p class="normal">Take your time to dissect the following trivial code and try to identify the parts that are prone to cause a <code class="inlineCode">NullPointerException</code> (these parts are marked as numbered warnings, which will be explained after <a id="_idIndexMarker298"/>the snippet):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ChainSaw</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;String&gt; MODELS
    = List.of(<span class="hljs-string">"T300"</span>, <span class="hljs-string">"T450"</span>, <span class="hljs-string">"T700"</span>, <span class="hljs-string">"T800"</span>, <span class="hljs-string">"</span><span class="hljs-string">T900"</span>);
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String model;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String power;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> speed;
  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> started;
  <span class="hljs-keyword">private</span> <span class="hljs-title">ChainSaw</span><span class="hljs-params">(String model, String power, </span><span class="hljs-type">int</span><span class="hljs-params"> speed)</span> {
    <span class="hljs-built_in">this</span>.model = model;
    <span class="hljs-built_in">this</span>.power = power;
    <span class="hljs-built_in">this</span>.speed = speed;
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ChainSaw<span class="hljs-title"> initChainSaw</span><span class="hljs-params">(String model)</span> {
    <span class="hljs-keyword">for</span> (String m : MODELS) {
      <span class="hljs-keyword">if</span> (model.endsWith(m)) {<span class="code-highlight"><strong class="hljs-slc">WARNING </strong><strong class="hljs-number-slc">3</strong><strong class="hljs-slc">!</strong></span> 
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ChainSaw</span>(model, <span class="hljs-literal">null</span>, <span class="code-highlight"><strong class="hljs-slc">WARNING </strong><strong class="hljs-number-slc">5</strong><strong class="hljs-slc">!</strong></span>
          (<span class="hljs-type">int</span>) (Math.random() * <span class="hljs-number">100</span>));
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="code-highlight"><strong class="hljs-slc">WARNING </strong><strong class="hljs-number-slc">1</strong><strong class="hljs-slc">,</strong><strong class="hljs-number-slc">2</strong><strong class="hljs-slc">!</strong></span>
  }
  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">performance</span><span class="hljs-params">(ChainSaw[] css)</span> {
    <span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (ChainSaw cs : css) { <span class="code-highlight"><strong class="hljs-slc">WARNING </strong><strong class="hljs-number-slc">3</strong><strong class="hljs-slc">!</strong></span>
      score += Integer.compare(
        <span class="hljs-built_in">this</span>.speed,cs.speed); <span class="code-highlight"><strong class="hljs-slc">WARNING </strong><strong class="hljs-number-slc">4</strong><strong class="hljs-slc">!</strong></span>
    }
    <span class="hljs-keyword">return</span> score;
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">if</span> (!started) {
      System.out.println(<span class="hljs-string">"Started ..."</span>);
      started = <span class="hljs-literal">true</span>;
    }
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">if</span> (started) {
      System.out.println(<span class="hljs-string">"Stopped ..."</span>);
      started = <span class="hljs-literal">false</span>;
    }
  } 
  <span class="hljs-keyword">public</span> String <span class="hljs-title">getPower</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> power; <span class="code-highlight"><strong class="hljs-slc">WARNING </strong><strong class="hljs-number-slc">5</strong><strong class="hljs-slc">!</strong></span>
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"ChainSaw{"</span> + <span class="hljs-string">"model="</span> + model 
      + <span class="hljs-string">", speed="</span> + speed + <span class="hljs-string">", started="</span> + started + <span class="hljs-string">'}'</span>;
  } 
}
</code></pre>
    <p class="normal">You noticed the warnings? Of course, you<a id="_idIndexMarker299"/> did! There are five major scenarios behind most <strong class="keyWord">NullPointerException</strong> (<strong class="keyWord">NPEs</strong>) and each of them is present in the previous class. Prior to JDK 14, an NPE doesn’t contain detailed information about the cause. Look at this exception:</p>
    <pre class="programlisting con"><code class="hljs-con">Exception in thread "main" java.lang.NullPointerException
    at modern.challenge.Main.main(Main.java:21)
</code></pre>
    <p class="normal">This message is just a starting point for the debugging process. We don’t know the root cause of this NPE or which variable is <code class="inlineCode">null</code>. But, starting with JDK 14 (JEP 358), we have really helpful NPE messages. For example, in JDK 14+, the previous message looks as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">Exception in thread "main" java.lang.NullPointerException: Cannot invoke "modern.challenge.Strings.reverse()" because "str" is null
    at modern.challenge.Main.main(Main.java:21)
</code></pre>
    <p class="normal">The highlighted part of the message gives us important information about the root cause of this NPE. Now, we know that the <code class="inlineCode">str</code> variable is <code class="inlineCode">null</code>, so no need to debug further. We can just focus on how to fix this issue.</p>
    <p class="normal">Next, let’s tackle each of the five major root causes of NPEs.</p>
    <h2 id="_idParaDest-113" class="heading-2">WARNING 1! NPE when calling an instance method via a null object</h2>
    <p class="normal">Consider the following code <a id="_idIndexMarker300"/>written by a client of <code class="inlineCode">ChainSaw</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">ChainSaw</span> <span class="hljs-variable">cs</span> <span class="hljs-operator">=</span> ChainSaw.initChainSaw(<span class="hljs-string">"QW-T650"</span>);
cs.start(); <span class="hljs-comment">// 'cs' is null</span>
</code></pre>
    <p class="normal">The client passes a chainsaw model that is not supported by this class, so the <code class="inlineCode">initChainSaw()</code> method returns <code class="inlineCode">null</code>. This is really bad because every time the client uses the <code class="inlineCode">cs</code> variable, they will get back an NPE as follows: </p>
    <pre class="programlisting con"><code class="hljs-con">Exception in thread "main" java.lang.NullPointerException: Cannot invoke "modern.challenge.ChainSaw.start()" because "cs" is null
    at modern.challenge.Main.main(Main.java:9)
</code></pre>
    <p class="normal">Instead of returning <code class="inlineCode">null</code>, it is better to throw an explicit exception that informs the client that they cannot continue<a id="_idIndexMarker301"/> because we don’t have this chainsaw model (we can go for the classical <code class="inlineCode">IllegalArgumentException</code> or, the more suggestive one in this case (but quite uncommon for <code class="inlineCode">null</code> value handling), <code class="inlineCode">UnsupportedOperationException</code>). This may be the proper fix in this case, but it is not universally true. There are cases when it is better to return an empty object (for example, an empty string, collection, or array) or a default object (for example, an object with minimalist settings) that doesn’t break the client code. Since JDK 8, we can use <code class="inlineCode">Optional</code> as well. Of course, there are cases when returning <code class="inlineCode">null</code> makes sense but that is more common in APIs and special situations.</p>
    <h2 id="_idParaDest-114" class="heading-2">WARNING 2! NPE when accessing (or modifying) the field of a null object</h2>
    <p class="normal">Consider the following code written by a client of <code class="inlineCode">ChainSaw</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">ChainSaw</span> <span class="hljs-variable">cs</span> <span class="hljs-operator">=</span> ChainSaw.initChainSaw(<span class="hljs-string">"QW-T650"</span>);
<span class="hljs-type">boolean</span> <span class="hljs-variable">isStarted</span> <span class="hljs-operator">=</span> cs.started; <span class="hljs-comment">// 'cs' is null</span>
</code></pre>
    <p class="normal">Practically, the NPE, in this case, has the same root cause as the previous case. We try to access the <code class="inlineCode">started</code> field of <code class="inlineCode">ChainSaw</code>. Since this is a primitive <code class="inlineCode">boolean</code>, it was initialized by JVM with <code class="inlineCode">false</code>, but we cannot “see” that since we try to access this field through a <code class="inlineCode">null</code> variable represented by <code class="inlineCode">cs</code>.</p>
    <h2 id="_idParaDest-115" class="heading-2">WARNING 3! NPE when null is passed in the method argument</h2>
    <p class="normal">Consider the following code written by a client of <code class="inlineCode">ChainSaw</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">ChainSaw</span> <span class="hljs-variable">cs</span> <span class="hljs-operator">=</span> ChainSaw.initChainSaw(<span class="hljs-literal">null</span>);
</code></pre>
    <p class="normal">You are not a good citizen if you want a <code class="inlineCode">null ChainSaw</code>, but who am I to judge? It is possible for this to happen and will lead to the following NPE:</p>
    <pre class="programlisting con"><code class="hljs-con">Exception in thread "main" java.lang.NullPointerException: Cannot invoke "String.endsWith(String)" because "model" is null
   at modern.challenge.ChainSaw.initChainSaw(ChainSaw.java:25)
   at modern.challenge.Main.main(Main.java:16)
</code></pre>
    <p class="normal">The message is crystal clear. We attempt to call the <code class="inlineCode">String.endWith()</code> method with a <code class="inlineCode">null</code> argument represented by the <code class="inlineCode">model</code> variable. To fix this issue, we have to add a guard condition to ensure that the passed <code class="inlineCode">model</code> argument is not <code class="inlineCode">null</code> (and eventually, not empty). In this case, we can throw an <code class="inlineCode">IllegalArgumentException</code> to inform the client that we are here and we are guarding. Another approach may consist of replacing the given <code class="inlineCode">null</code> with a dummy model that passes through our code without issues (for instance, since the model is a <code class="inlineCode">String</code>, we can reassign an empty string, <strong class="keyWord">““</strong>). However, personally, I don’t recommend this approach, not even for small methods. You never know how the code will evolve and such dummy reassignments can lead to brittle code.</p>
    <h2 id="_idParaDest-116" class="heading-2">WARNING 4! NPE when accessing the index value of a null array/collection</h2>
    <p class="normal">Consider the following code written by a client of <code class="inlineCode">ChainSaw</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">ChainSaw</span> <span class="hljs-variable">myChainSaw</span> <span class="hljs-operator">=</span> ChainSaw.initChainSaw(<span class="hljs-string">"QWE-T800"</span>);
ChainSaw[] friendsChainSaw = <span class="hljs-keyword">new</span> <span class="hljs-title">ChainSaw</span>[]{
  ChainSaw.initChainSaw(<span class="hljs-string">"Q22-T450"</span>),
  ChainSaw.initChainSaw(<span class="hljs-string">"QRT-T300"</span>),
  ChainSaw.initChainSaw(<span class="hljs-string">"Q-T900"</span>),
  <span class="hljs-literal">null</span>, <span class="hljs-comment">// ops!</span>
  ChainSaw.initChainSaw(<span class="hljs-string">"QMM-T850"</span>), <span class="hljs-comment">// model is not supported</span>
  ChainSaw.initChainSaw(<span class="hljs-string">"ASR-T900"</span>)
};
<span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> myChainSaw.performance(friendsChainSaw);
</code></pre>
    <p class="normal">Creating an array of <code class="inlineCode">ChainSaw</code> was <a id="_idIndexMarker302"/>quite challenging in this example. We accidentally slipped a <code class="inlineCode">null</code> value (actually, we did it intentionally) and an unsupported model. In return, we get the following NPE:</p>
    <pre class="programlisting con"><code class="hljs-con">Exception in thread "main" java.lang.NullPointerException: Cannot read field "speed" because "cs" is null
    at modern.challenge.ChainSaw.performance(ChainSaw.java:37)
    at modern.challenge.Main.main(Main.java:31)
</code></pre>
    <p class="normal">The message informs us that the <code class="inlineCode">cs</code> variable is <code class="inlineCode">null</code>. This is happening at line 37 in <code class="inlineCode">ChainSaw</code>, so in the for loop of the <code class="inlineCode">performance()</code> method. While looping the given array, our code iterated over the <code class="inlineCode">null</code> value, which doesn’t have the <code class="inlineCode">speed</code> field. Pay attention to this kind of scenario: even if the given array/collection itself is not <code class="inlineCode">null</code>, it doesn’t mean that it cannot contain <code class="inlineCode">null</code> items. So, adding a guarding check before handling each item can save us from an NPE in this case. Depending on the context, we can throw an <code class="inlineCode">IllegalArgumentException</code> when the loop passes over the first <code class="inlineCode">null</code> or simply ignore <code class="inlineCode">null</code> values and don’t break the flow (in general, this is more suitable). Of course, using a collection that doesn’t accept <code class="inlineCode">null</code> values is also a good approach (Apache Commons Collection <a id="_idIndexMarker303"/>and Guava have such collections).</p>
    <h2 id="_idParaDest-117" class="heading-2">WARNING 5! NPE when accessing a field via a getter</h2>
    <p class="normal">Consider the following code written by a client of <code class="inlineCode">ChainSaw</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">ChainSaw</span> <span class="hljs-variable">cs</span> <span class="hljs-operator">=</span> ChainSaw.initChainSaw(<span class="hljs-string">"T5A-T800"</span>);
<span class="hljs-type">String</span> <span class="hljs-variable">power</span> <span class="hljs-operator">=</span> cs.getPower();
System.out.println(power.concat(<span class="hljs-string">" Watts"</span>));
</code></pre>
    <p class="normal">And, the associated NPE:</p>
    <pre class="programlisting con"><code class="hljs-con">Exception in thread "main" java.lang.NullPointerException: Cannot invoke "String.concat(String)" because "power" is null
    at modern.challenge.Main.main(Main.java:37)
</code></pre>
    <p class="normal">Practically, the getter <code class="inlineCode">getPower()</code> returned <code class="inlineCode">null</code> since the <code class="inlineCode">power</code> field is <code class="inlineCode">null</code>. Why? The answer is in the line <code class="inlineCode">return new ChainSaw(model, null, (int) (Math.random() * 100));</code> of the <code class="inlineCode">initChainSaw()</code> method. Because we didn’t decide yet on the algorithm for calculating the power of a chainsaw, we passed <code class="inlineCode">null</code> to the <code class="inlineCode">ChainSaw</code> constructor. Further, the constructor simply sets the <code class="inlineCode">power</code> field as <code class="inlineCode">this.power = power</code>. If it was a public constructor, then most probably we would have added some guarded conditions, but being a private constructor, it is better to fix the issue right from the root and not pass that <code class="inlineCode">null</code>. Since the <code class="inlineCode">power</code> is a <code class="inlineCode">String</code>, we can simply pass an empty string or a suggestive string such as <code class="inlineCode">UNKNOWN_POWER</code>. We also may leave a TODO comment in code such as <code class="inlineCode">// TODO (JIRA ####): replace UNKNOWN_POWER with code</code>. This will remind us to fix this in the next release. Meanwhile, the code has eliminated the NPE risk.</p>
    <p class="normal">Okay, after we fixed all these five NPE risks, the code has become the following (the added code is highlighted):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ChainSaw</span> {
<span class="hljs-keyword">  private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">UNKNOWN_POWER</span> <span class="hljs-operator">=</span> <span class="hljs-string">"UNKNOWN"</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;String&gt; MODELS
    = List.of(<span class="hljs-string">"T300"</span>, <span class="hljs-string">"T450"</span>, <span class="hljs-string">"T700"</span>, <span class="hljs-string">"T800"</span>, <span class="hljs-string">"T900"</span>);
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String model;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String power;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> speed;
  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> started;
  <span class="hljs-keyword">private</span> <span class="hljs-title">ChainSaw</span><span class="hljs-params">(String model, String power, </span><span class="hljs-type">int</span><span class="hljs-params"> speed)</span> {
    <span class="hljs-built_in">this</span>.model = model;
    <span class="hljs-built_in">this</span>.power = power;
    <span class="hljs-built_in">this</span>.speed = speed;
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ChainSaw <span class="hljs-title">initChainSaw</span><span class="hljs-params">(String model)</span> {
    <span class="hljs-keyword">if</span> (model == <span class="hljs-literal">null</span> || model.isBlank()) {
     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">IllegalArgumentException</span>(<span class="hljs-string">"The given model </span>
<span class="hljs-string">               cannot be null/empty"</span>);
    }
    <span class="hljs-keyword">for</span> (String m : MODELS) {
      <span class="hljs-keyword">if</span> (model.endsWith(m)) { 
        <span class="hljs-comment">// TO DO (JIRA ####): replace UNKNOWN_POWER with code</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ChainSaw</span>(model, <span class="code-highlight"><strong class="hljs-slc">UNKNOWN_POWER</strong></span>, 
         (<span class="hljs-type">int</span>) (Math.random() * <span class="hljs-number">100</span>));
        }
    }
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">UnsupportedOperationException</span>(
      <span class="hljs-string">"Model "</span> + model + <span class="hljs-string">" is not supported"</span>);
  }
  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">performance</span><span class="hljs-params">(ChainSaw[] css)</span> {
    <span class="hljs-keyword">if</span> (css == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">IllegalArgumentException</span>(
        <span class="hljs-string">"The given models cannot be null"</span>);
    }
    <span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (ChainSaw cs : css) {
      <span class="hljs-keyword">if</span> (cs != <span class="hljs-literal">null</span>) {
        score += Integer.compare(<span class="hljs-built_in">this</span>.speed, cs.speed);
      }
    }
    <span class="hljs-keyword">return</span> score;
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">if</span> (!started) {
      System.out.println(<span class="hljs-string">"</span><span class="hljs-string">Started ..."</span>);
      started = <span class="hljs-literal">true</span>;
    }
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">if</span> (started) {
      System.out.println(<span class="hljs-string">"Stopped ..."</span>);
      started = <span class="hljs-literal">false</span>;
    }
  }
  <span class="hljs-keyword">public</span> String <span class="hljs-title">getPower</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> power;
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"ChainSaw{"</span> + <span class="hljs-string">"model="</span> + model
      + <span class="hljs-string">", speed="</span> + speed + <span class="hljs-string">", started="</span> + started + <span class="hljs-string">'}'</span>;
  }
}
</code></pre>
    <p class="normal">Done! Now, our code is NPE-free. At <a id="_idIndexMarker304"/>least until reality contradicts us and a new NPE occurs.</p>
    <h1 id="_idParaDest-118" class="heading-1">53. Using yield in switch expressions</h1>
    <p class="normal">Here, we’re going to look at how <code class="inlineCode">switch</code> expressions have evolved in JDK 13+.</p>
    <p class="normal">Java SE 13 added the new <code class="inlineCode">yield</code> statement, which <a id="_idIndexMarker305"/>can be used instead of the <code class="inlineCode">break</code> statement in switch expressions.</p>
    <p class="normal">We know that a JDK 12+ <code class="inlineCode">switch</code> expression can <a id="_idIndexMarker306"/>be written as follows (<code class="inlineCode">playerType</code> is a Java enum):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (playerType) {
  <span class="hljs-keyword">case</span> TENNIS -&gt;
    <span class="hljs-keyword">new</span> <span class="hljs-title">TennisPlayer</span>();
  <span class="hljs-keyword">case</span> FOOTBALL -&gt;
    <span class="hljs-keyword">new</span> <span class="hljs-title">FootballPlayer</span>();
  ...
};
</code></pre>
    <p class="normal">Moreover, we know that a label’s arrow can point to a curly-braces block as well (this works only in JDK 12, <strong class="keyWord">not in JDK 13+</strong>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (playerType) {
  <span class="hljs-keyword">case</span> TENNIS -&gt; {
    System.out.println(<span class="hljs-string">"Creating a TennisPlayer ..."</span>);
    <span class="hljs-keyword">break</span> <span class="hljs-keyword">new</span> <span class="hljs-title">TennisPlayer</span>();
  }
  <span class="hljs-keyword">case</span> FOOTBALL -&gt; {
    System.out.println(<span class="hljs-string">"Creating a FootballPlayer ..."</span>);
    <span class="hljs-keyword">break</span> <span class="hljs-keyword">new</span> <span class="hljs-title">FootballPlayer</span>();
  }
  ...
};
</code></pre>
    <p class="normal">Since <code class="inlineCode">break</code> can be confusing because it can be used in old-school <code class="inlineCode">switch</code> statements and in the new <code class="inlineCode">switch</code> expressions, JDK 13 added the <code class="inlineCode">yield</code> statement to be used instead of <code class="inlineCode">break</code>. The <code class="inlineCode">yield</code> statement <a id="_idIndexMarker307"/>takes one argument representing the value produced by the current case. The<a id="_idIndexMarker308"/> previous examples can be written from JDK 13+ as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (playerType) {
  <span class="hljs-keyword">case</span> TENNIS:
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">new</span> <span class="hljs-title">TennisPlayer</span>();
  <span class="hljs-keyword">case</span> FOOTBALL:
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">new</span> <span class="hljs-title">FootballPlayer</span>();
  ...
};
<span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (playerType) {
  <span class="hljs-keyword">case</span> TENNIS -&gt; {
    System.out.println(<span class="hljs-string">"Creating a TennisPlayer ..."</span>);
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">new</span> <span class="hljs-title">TennisPlayer</span>();
  }
  <span class="hljs-keyword">case</span> FOOTBALL -&gt; {
    System.out.println(<span class="hljs-string">"Creating a FootballPlayer ..."</span>);
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">new</span> <span class="hljs-title">FootballPlayer</span>();
  }
  ...
};
</code></pre>
    <p class="normal">In other words, starting with JDK 13+, a <code class="inlineCode">switch</code> expression can rely on <code class="inlineCode">yield</code> but not on <code class="inlineCode">break</code>, and a <code class="inlineCode">switch</code> statement can rely on <code class="inlineCode">break</code> but not on <code class="inlineCode">yield</code>.</p>
    <h1 id="_idParaDest-119" class="heading-1">54. Tackling the case null clause in switch</h1>
    <p class="normal">Before JDK 17, a <code class="inlineCode">null</code> case in a <code class="inlineCode">switch</code> was<a id="_idIndexMarker309"/> commonly coded as a guarding condition outside the <code class="inlineCode">switch</code>, as in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Player <span class="hljs-title">createPlayer</span><span class="hljs-params">(PlayerTypes playerType)</span> {
  <span class="hljs-comment">// handling null values in a condition outside switch</span>
  <span class="hljs-keyword">if</span> (playerType == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">IllegalArgumentException</span>(
     <span class="hljs-string">"Player type cannot be null"</span>);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (playerType) {
    <span class="hljs-keyword">case</span> TENNIS -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title">TennisPlayer</span>();
    <span class="hljs-keyword">case</span> FOOTBALL -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title">FootballPlayer</span>();
    ...
  };
}
</code></pre>
    <p class="normal">Starting with JDK 17+ (JEP 427), we can treat a <code class="inlineCode">null</code> case as any other common case. For instance, here we have a <code class="inlineCode">null</code> case that is responsible for handling the scenarios when the passed argument is <code class="inlineCode">null</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Player <span class="hljs-title">createPlayer</span><span class="hljs-params">(PlayerTypes playerType)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (playerType) {
    <span class="hljs-keyword">case</span> TENNIS -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title">TennisPlayer</span>();
    <span class="hljs-keyword">case</span> FOOTBALL -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title">FootballPlayer</span>();
    <span class="hljs-keyword">case</span> SNOOKER -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title">SnookerPlayer</span>();
<span class="hljs-keyword">    case</span> <span class="hljs-literal">null</span> -&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">NullPointerException</span>(
                   <span class="hljs-string">"</span><span class="hljs-string">Player type cannot be null"</span>);
    <span class="hljs-keyword">case</span> UNKNOWN -&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">UnknownPlayerException</span>(
                      <span class="hljs-string">"Player type is unknown"</span>);
    <span class="hljs-comment">// default is not mandatory</span>
    <span class="hljs-keyword">default</span> -&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">IllegalArgumentException</span>(
                 <span class="hljs-string">"Invalid player type: "</span> + playerType);
  };
}
</code></pre>
    <p class="normal">In certain contexts, <code class="inlineCode">null</code> and <code class="inlineCode">default</code> have the same<a id="_idIndexMarker310"/> meaning, so we can chain them in the same <code class="inlineCode">case</code> statement:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Player <span class="hljs-title">createPlayer</span><span class="hljs-params">(PlayerTypes playerType)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (playerType) {
    <span class="hljs-keyword">case</span> TENNIS -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title">TennisPlayer</span>();
    <span class="hljs-keyword">case</span> FOOTBALL -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title">FootballPlayer</span>();
    ...
    <span class="hljs-keyword">case</span> <span class="hljs-literal">null</span>, <span class="hljs-keyword">default</span> -&gt;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">IllegalArgumentException</span>(
       <span class="hljs-string">"Invalid player type: "</span> + playerType);
  };
}
</code></pre>
    <p class="normal">Or you might find it more readable like this:</p>
    <pre class="programlisting code"><code class="hljs-code">...    
<span class="hljs-keyword">case</span> TENNIS: <span class="hljs-keyword">yield</span> <span class="hljs-keyword">new</span> <span class="hljs-title">TennisPlayer</span>();
<span class="hljs-keyword">case</span> FOOTBALL: <span class="hljs-keyword">yield</span> <span class="hljs-keyword">new</span> <span class="hljs-title">FootballPlayer</span>();
...
<span class="hljs-keyword">case</span> <span class="hljs-literal">null</span>, <span class="hljs-keyword">default</span>:
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">IllegalArgumentException</span>(
    <span class="hljs-string">"Invalid player type: "</span> + playerType);
...
</code></pre>
    <p class="normal">Personally, I suggest you think twice before patching your <code class="inlineCode">switch</code> expressions with <code class="inlineCode">case null</code>, especially if you plan to do it only for silently sweeping these values. Overall, your code may become brittle and exposed to unexpected behaviors/results that ignore the presence of <code class="inlineCode">null</code> values. In the bundled code, you can test the complete examples.</p>
    <h1 id="_idParaDest-120" class="heading-1">55. Taking on the hard way to discover equals()</h1>
    <p class="normal">Check out the following<a id="_idIndexMarker311"/> code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Integer</span> <span class="hljs-variable">x1</span> <span class="hljs-operator">=</span> <span class="hljs-number">14</span>; <span class="hljs-type">Integer</span> <span class="hljs-variable">y1</span> <span class="hljs-operator">=</span> <span class="hljs-number">14</span>;
<span class="hljs-type">Integer</span> <span class="hljs-variable">x2</span> <span class="hljs-operator">=</span> <span class="hljs-number">129</span>; <span class="hljs-type">Integer</span> <span class="hljs-variable">y2</span> <span class="hljs-operator">=</span> <span class="hljs-number">129</span>;
List&lt;Integer&gt; listOfInt1 = <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;(
 Arrays.asList(x1, y1, x2, y2));
listOfInt1.removeIf(t -&gt; t == x1 || t == x2);
List&lt;Integer&gt; listOfInt2 = <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;(
 Arrays.asList(x1, y1, x2, y2));
listOfInt2.removeIf(t -&gt; t.equals(x1) || t.equals(x2));
</code></pre>
    <p class="normal">So, initially, <code class="inlineCode">listOfInt1</code> and <code class="inlineCode">listOfInt2</code> have the same items, [<code class="inlineCode">x1</code>=14, <code class="inlineCode">y1</code>=14, <code class="inlineCode">x2</code>=129, <code class="inlineCode">y2</code>=129]. But, what will contain <code class="inlineCode">listOfInt1</code>/<code class="inlineCode">listOfInt2</code> after executing the code based on <code class="inlineCode">removeIf()</code> and <code class="inlineCode">==</code>, respectively <code class="inlineCode">equals()</code>?</p>
    <p class="normal">The first list will remain with a single item, [129]. When <code class="inlineCode">t</code> is <code class="inlineCode">x1</code>, we know that <code class="inlineCode">x1 == x1</code>, so 14 is removed. But, why is <code class="inlineCode">x2</code> removed? When <code class="inlineCode">t</code> is <code class="inlineCode">y1</code>, we know that <code class="inlineCode">y1 == x1</code> should be <code class="inlineCode">false</code> since, via <code class="inlineCode">==</code>, we compare the object’s references in memory, not their values. Obviously, <code class="inlineCode">y1</code> and <code class="inlineCode">x1</code> should have different references in the memory… or shouldn’t they ? Actually, Java has an internal rule to cache integers in -127 … 128. Since <code class="inlineCode">x1</code>=14 is cached, <code class="inlineCode">y1</code>=14 uses the<a id="_idIndexMarker312"/> cache so no new <code class="inlineCode">Integer</code> is created. This is why <code class="inlineCode">y1 == x1</code> and <code class="inlineCode">y1</code> is removed as well. Next, <code class="inlineCode">t</code> is <code class="inlineCode">x2</code>, and <code class="inlineCode">x2 == x2</code>, so <code class="inlineCode">x2</code> is removed. Finally, <code class="inlineCode">t</code> is <code class="inlineCode">y2</code>, but <code class="inlineCode">y2 == x2</code> returns <code class="inlineCode">false</code>, since 129 &gt; 128 is not cached, so <code class="inlineCode">x2</code> and <code class="inlineCode">y2</code> have different references in memory.</p>
    <p class="normal">On the other hand, when we use <code class="inlineCode">equals()</code>, which is the recommended approach for comparing the object’s values, the resulting list is empty. When <code class="inlineCode">t</code> is <code class="inlineCode">x1</code>, <code class="inlineCode">x1</code> =<code class="inlineCode">x1</code>, so 14 is removed. When <code class="inlineCode">t</code> is <code class="inlineCode">y1</code>, <code class="inlineCode">y1</code> =<code class="inlineCode">x1</code>, so <code class="inlineCode">y1</code> is removed as well. Next, <code class="inlineCode">t</code> is <code class="inlineCode">x2</code>, and <code class="inlineCode">x2</code>= <code class="inlineCode">x2</code>, so <code class="inlineCode">x2</code> is removed. Finally, <code class="inlineCode">t</code> is <code class="inlineCode">y2</code>, and <code class="inlineCode">y2</code> =<code class="inlineCode">x2</code>, so <code class="inlineCode">y2</code> is removed as well.</p>
    <h1 id="_idParaDest-121" class="heading-1">56. Hooking instanceof in a nutshell</h1>
    <p class="normal">Having an object (<code class="inlineCode">o</code>) and a type (<code class="inlineCode">t</code>), we can use the <code class="inlineCode">instanceof</code> operator to test if <code class="inlineCode">o</code> is of type <code class="inlineCode">t</code> by writing <code class="inlineCode">o instanceof t</code>. This is<a id="_idIndexMarker313"/> a <code class="inlineCode">boolean</code> operator that is very useful to ensure the success of a subsequent casting operation. For instance, check the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">interface</span> <span class="hljs-title">Furniture</span> {};
<span class="hljs-keyword">class</span> <span class="hljs-title">Plywood</span> {};
<span class="hljs-keyword">class</span> <span class="hljs-title">Wardrobe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Plywood</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Furniture</span> {};
</code></pre>
    <p class="normal"><code class="inlineCode">instanceof</code> returns <code class="inlineCode">true</code> if we test the object (for instance, <code class="inlineCode">Wardrobe</code>) against the type itself:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Wardrobe</span> <span class="hljs-variable">wardrobe</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Wardrobe</span>();
<span class="hljs-keyword">if</span>(wardrobe <span class="hljs-keyword">instanceof</span> Wardrobe) { } <span class="hljs-comment">// true</span>
<span class="hljs-type">Plywood</span> <span class="hljs-variable">plywood</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Plywood</span>();
<span class="hljs-keyword">if</span>(plywood <span class="hljs-keyword">instanceof</span> Plywood) { } <span class="hljs-comment">// true</span>
</code></pre>
    <p class="normal"><code class="inlineCode">instanceof</code> returns true if the tested object (for instance, <code class="inlineCode">Wardrobe</code>) is an instance of a subclass of the type (for instance <code class="inlineCode">Plywood</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Wardrobe</span> <span class="hljs-variable">wardrobe</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Wardrobe</span>();
<span class="hljs-keyword">if</span>(wardrobe <span class="hljs-keyword">instanceof</span> Plywood) {} <span class="hljs-comment">// true</span>
</code></pre>
    <p class="normal"><code class="inlineCode">instanceof</code> returns <code class="inlineCode">true</code> if the tested object (for instance, <code class="inlineCode">Wardrobe</code>) implements the interface represented by the type (for instance, <code class="inlineCode">Furniture</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Wardrobe</span> <span class="hljs-variable">wardrobe</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Wardrobe</span>();
<span class="hljs-keyword">if</span>(wardrobe <span class="hljs-keyword">instanceof</span> Furniture) {} <span class="hljs-comment">// true</span>
</code></pre>
    <p class="normal">Based on this, consider the following note:</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">The logic behind <code class="inlineCode">instanceof</code> relies on the IS-A relationship (this is detailed in <em class="italic">The Complete Coding Interview Guide in Java</em>, <em class="chapterRef">Chapter 6</em>, <em class="italic">What is inheritance?</em>). In a nutshell, this relationship is based on interface implementation or class inheritance. For instance, <code class="inlineCode">wardrobe instanceof Plywood</code> returns <code class="inlineCode">true</code> because <code class="inlineCode">Wardrobe</code> extends <code class="inlineCode">Plywood</code>, so <code class="inlineCode">Wardrobe</code> IS A <code class="inlineCode">Plywood</code>. Similarly, <code class="inlineCode">Wardrobe</code> IS A <code class="inlineCode">Furniture</code>. On the other hand, <code class="inlineCode">Plywood</code> IS-not-A <code class="inlineCode">Furniture</code>, so <code class="inlineCode">plywood instanceof Furniture</code> returns <code class="inlineCode">false</code>. In this context, since every Java class extends <code class="inlineCode">Object</code>, we know that <code class="inlineCode">foo instanceof Object</code> returns <code class="inlineCode">true</code> as long as <code class="inlineCode">foo</code> is an instance of a Java class. In addition, <code class="inlineCode">null instanceof Object</code> (or any other object) returns <code class="inlineCode">false</code>, so this operator doesn’t require an explicit <code class="inlineCode">null</code> check.</p>
    </div>
    <p class="normal">Finally, keep in <a id="_idIndexMarker314"/>mind that <code class="inlineCode">instanceof</code> works only with reified types (reified type information is available at runtime), which include:</p>
    <ul>
      <li class="bulletList">Primitive types (<code class="inlineCode">int</code>, <code class="inlineCode">float</code>)</li>
      <li class="bulletList">Raw types (<code class="inlineCode">List</code>, <code class="inlineCode">Set</code>)</li>
      <li class="bulletList">Non-generic classes/interfaces (<code class="inlineCode">String</code>)</li>
      <li class="bulletList">Generic types with unbounded wildcards (<code class="inlineCode">List&lt;?&gt;</code>,<code class="inlineCode"> Map&lt;?, ?&gt;</code>)</li>
      <li class="bulletList">Arrays of reifiable types (<code class="inlineCode">String[]</code>,<code class="inlineCode"> Map&lt;?, ?&gt;[]</code>,<code class="inlineCode"> Set&lt;?&gt;[]</code>)</li>
    </ul>
    <p class="normal">This means that we cannot use the <code class="inlineCode">instanceof</code> operator (or casts) with parameterized types because the type erasures alter all type parameters in generic code, so we cannot say which parameterized type for a generic type is in use at runtime.</p>
    <h1 id="_idParaDest-122" class="heading-1">57. Introducing pattern matching</h1>
    <p class="normal">JDK 16 has introduced one of the major<a id="_idIndexMarker315"/> and complex features of Java, referred to as <em class="italic">pattern matching</em>. The future is wide open for this topic.</p>
    <p class="normal">In a nutshell, <em class="italic">pattern matching </em>defines a synthetic expression for checking/testing whether a given variable has certain properties. If those properties are met, then automatically extract one or more parts of that variable into other variables. From this point forward, we can use those extracted variables.</p>
    <p class="normal">A pattern matching instance (pay attention, this has nothing to do with design patterns) is a structure made of several components as follows (this is basically the pattern matching terminology):</p>
    <ul>
      <li class="bulletList">The <em class="italic">target operand</em> or the argument of the predicate: This is a variable (or an expression) that we aim to match.</li>
      <li class="bulletList">The <em class="italic">predicate</em> (or <em class="italic">test</em>): This is a check that takes place at runtime and aims to determine if the given <em class="italic">target operand</em> does or doesn’t have one or more properties (we match the <em class="italic">target operand</em> against the properties).</li>
      <li class="bulletList">One or more variables are <a id="_idIndexMarker316"/>referred to as <em class="italic">pattern variables</em> or <em class="italic">binding variables</em>: these variables are automatically extracted from the <em class="italic">target operand</em> if and only if the <em class="italic">predicate</em>/<em class="italic">test</em> succeeds.</li>
      <li class="bulletList">Finally, we have the <em class="italic">pattern</em> itself, which is represented by the <em class="italic">predicate</em> + <em class="italic">binding variables</em>.</li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B19665_02_31.png" alt="Figure 2.31.png"/></figure>
    <p class="packt_figref">Figure 2.31: Pattern matching components</p>
    <p class="normal">So, we can say that Java pattern matching is a synthetic expression of a complex solution composed of four components: target operand, predicate/test, binding variable(s), and pattern = predicate + binding variable(s).</p>
    <h2 id="_idParaDest-123" class="heading-2">The scope of binding variables in pattern matching</h2>
    <p class="normal">The compiler decides the scope (visibility) of the binding variables, so we don’t have to bother with such aspects via <a id="_idIndexMarker317"/>special modifiers or other tricks. In the case of predicates that always pass (like an <code class="inlineCode">if(true) {}</code>), the compiler scopes the binding variables exactly as for the Java <em class="italic">local variables</em>.</p>
    <p class="normal">But, most patterns make sense precisely because the predicate may fail. In such cases, the compiler applies a technique called <em class="italic">flow scoping</em>. That is<a id="_idIndexMarker318"/> actually a combination of the <em class="italic">regular scoping</em> and <em class="italic">definitive assignment</em>.</p>
    <p class="normal">The <em class="italic">definitive assignment</em> is a technique <a id="_idIndexMarker319"/>used by the compiler based on the structure of statements and expressions to ensure that a local variable (or blank <code class="inlineCode">final</code> field) is definitely assigned before it is accessed by the code. In a pattern-matching context, a binding variable is assigned only if the predicate passes, so the <em class="italic">definitive assignment </em>aim is to find out the precise place when this is happening. Next, the regular block scope represents the code <a id="_idIndexMarker320"/>where the binding variable is in scope.</p>
    <p class="normal">Do you want this as a simple important note? Here it is.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">In pattern matching, the binding variable is flow-scoped. In other words, the scope of a binding variable covers only the block where the predicate passed.</p>
    </div>
    <p class="normal">We will cover this topic in <em class="italic">Problem 59</em>.</p>
    <h2 id="_idParaDest-124" class="heading-2">Guarded patterns</h2>
    <p class="normal">So far, we know that a pattern relies on a predicate/test for deciding whether the binding variables should be extracted<a id="_idIndexMarker321"/> from the target operand or not. In addition, sometimes we need to refine this predicate by appending to it extra <code class="inlineCode">boolean</code> checks based on the extracted binding variables. We name this a <em class="italic">guarded pattern</em>. In other words, if the predicate evaluates to <code class="inlineCode">true</code>, then the binding variables are extracted and they enter in further <code class="inlineCode">boolean</code> checks. If these checks are evaluated to <code class="inlineCode">true</code>, we can say that the target operand matches this guarded pattern.</p>
    <p class="normal">We cover this in <em class="italic">Problem 64</em>.</p>
    <h2 id="_idParaDest-125" class="heading-2">Type coverage</h2>
    <p class="normal">In a nutshell, the <code class="inlineCode">switch</code> expressions<a id="_idIndexMarker322"/> and <code class="inlineCode">switch</code> statements that use <code class="inlineCode">null</code> and/or pattern labels should be exhaustive. In other words, we must cover all the possible values with <code class="inlineCode">switch case</code> labels.</p>
    <p class="normal">We cover this in <em class="italic">Problem 66</em>.</p>
    <h2 id="_idParaDest-126" class="heading-2">Current status of pattern matching</h2>
    <p class="normal">Currently, Java supports type <a id="_idIndexMarker323"/>pattern matching for <code class="inlineCode">instanceof</code> and <code class="inlineCode">switch</code>, and record pattern-destructuring patterns for records (covered in <em class="italic">Chapter 4</em>). These are the final releases in JDK 21.</p>
    <h1 id="_idParaDest-127" class="heading-1">58. Introducing type pattern matching for instanceof</h1>
    <p class="normal">Can you name the shortcomings of the following<a id="_idIndexMarker324"/> classical snippet of <a id="_idIndexMarker325"/>code (this is a simple code used to save different kinds of artifacts on a USB device)?</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">save</span><span class="hljs-params">(Object o)</span> <span class="hljs-keyword">throws</span> IOException {
  <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> File) {
    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> (File) o;
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Saving a file of size: "</span> 
      + String.format(<span class="hljs-string">"</span><span class="hljs-string">%,d bytes"</span>, file.length());
  } 
  <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Path) {
    <span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> (Path) o;
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Saving a file of size: "</span> 
      + String.format(<span class="hljs-string">"%,d bytes"</span>, Files.size(path));
  }
  <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> String) {
    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> (String) o;
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Saving a string of size: "</span> 
      + String.format(<span class="hljs-string">"%,d bytes"</span>, str.length());
  }
  <span class="hljs-keyword">return</span> <span class="hljs-string">"I cannot save the given object"</span>;
}
</code></pre>
    <p class="normal">You’re right…type checking and casting are burdensome to write and read. Moreover, those check-cast sequences are error-prone (it is easy to change the checked type or the casted type and forget to change the type of the other object). Basically, in each conditional statement, we do three steps, as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">First, we do a type check (for instance, <code class="inlineCode">o instanceof File</code>).</li>
      <li class="numberedList">Second, we do a type conversion via cast (for instance, <code class="inlineCode">(File) o</code>).</li>
      <li class="numberedList">Third, we do a variable assignment (for instance, <code class="inlineCode">File file =</code>).</li>
    </ol>
    <p class="normal">But, starting with JDK 16 (JEP 394), we can use <em class="italic">type pattern matching for instanceof </em>to perform the previous three steps in one expression. The type pattern is the first category of patterns supported <a id="_idIndexMarker326"/>by Java. Let’s see the previous code <a id="_idIndexMarker327"/>rewritten via the <em class="italic">type pattern</em>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">save</span><span class="hljs-params">(Object o)</span> <span class="hljs-keyword">throws</span> IOException {
  <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> File file) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Saving a file of size: "</span> 
      + String.format(<span class="hljs-string">"%,d bytes"</span>, file.length());
  }
  <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> String str) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Saving a string of size: "</span> 
      + String.format(<span class="hljs-string">"%,d bytes"</span>, str.length());
  }
  <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Path path) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Saving a file of size: "</span> 
      + String.format(<span class="hljs-string">"%,d bytes"</span>, Files.size(path));
  }
  <span class="hljs-keyword">return</span> <span class="hljs-string">"I cannot save the given object"</span>;
}
</code></pre>
    <p class="normal">In each <code class="inlineCode">if</code>-<code class="inlineCode">then</code> statement, we have a test/predicate to determine the type of <code class="inlineCode">Object o</code>, a cast of <code class="inlineCode">Object o</code> to <code class="inlineCode">File</code>, <code class="inlineCode">Path</code>, or <code class="inlineCode">String</code>, and a destructuring phase for extracting either the length or the size from <code class="inlineCode">Object o</code>.</p>
    <p class="normal">The piece of code, (<code class="inlineCode">o instanceof File file</code>) is not just some syntactic sugar. It is not just a convenient shortcut of the old-fashioned code to reduce the ceremony of conditional state extraction. This is a <em class="italic">type pattern</em> in action!</p>
    <p class="normal">Practically, we match the variable <code class="inlineCode">o</code> against <code class="inlineCode">File file</code>. More precisely, we match the type of <code class="inlineCode">o</code> against the type <code class="inlineCode">File</code>. We have that <code class="inlineCode">o</code> is the <em class="italic">target operand </em>(the argument of the predicate), <code class="inlineCode">instanceof File</code> is the predicate, and the variable <code class="inlineCode">file</code> is the <em class="italic">pattern </em>or <em class="italic">binding variable </em>that is automatically created only if <code class="inlineCode">instanceof File</code> returns <code class="inlineCode">true</code>. Moreover, <code class="inlineCode">instanceof File file</code> is the <em class="italic">type pattern</em>, or in short, <code class="inlineCode">File file</code> is the pattern itself. The following figure illustrates this statement:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_32.png" alt="Figure 2.32.png"/></figure>
    <p class="packt_figref">Figure 2.32: Type pattern matching for instanceof</p>
    <p class="normal">In the type pattern for <code class="inlineCode">instanceof</code>, there is no need to perform explicit <code class="inlineCode">null</code> checks (exactly as in the case of <a id="_idIndexMarker328"/>plain <code class="inlineCode">instanceof</code>), and no upcasting is allowed. Both of the following examples generate a <a id="_idIndexMarker329"/>compilation error in JDK 16-20, but not in JDK 14/15/21 (this is weird indeed):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (<span class="hljs-string">"foo"</span> <span class="hljs-keyword">instanceof</span> String str) {}
<span class="hljs-keyword">if</span> (<span class="hljs-string">"foo"</span> <span class="hljs-keyword">instanceof</span> CharSequence sequence) {}
</code></pre>
    <p class="normal">The compilation error points out that the expression type cannot be a subtype of pattern type (no upcasting is allowed). However, with plain <code class="inlineCode">instanceof</code>, this works in all JDKs:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (<span class="hljs-string">"foo"</span> <span class="hljs-keyword">instanceof</span> String) {}
<span class="hljs-keyword">if</span> (<span class="hljs-string">"foo"</span> <span class="hljs-keyword">instanceof</span> CharSequence) {}
</code></pre>
    <p class="normal">Next, let’s talk about the scope of binding variables.</p>
    <h1 id="_idParaDest-128" class="heading-1">59. Handling the scope of a binding variable in type patterns for instanceof</h1>
    <p class="normal">From <em class="italic">Problem 57</em>, we know the headlines of scoping the binding variables in pattern matching. Moreover, we know from <a id="_idIndexMarker330"/>the previous problem that in the type pattern for <code class="inlineCode">instanceof</code>, we have a single binding variable. It is time to see some <a id="_idIndexMarker331"/>practical examples, so let’s quickly crop this snippet from the previous problem:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> File <span class="code-highlight"><strong class="hljs-slc">file</strong></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">"Saving a file of size: "</span> 
    + String.format(<span class="hljs-string">"%,d bytes"</span>, <span class="code-highlight"><strong class="hljs-slc">file.length()</strong></span>);
}
<span class="hljs-comment">// 'file' is out of scope here</span>
</code></pre>
    <p class="normal">In this snippet, the <code class="inlineCode">file</code> binding variable is visible in the <code class="inlineCode">if</code>-then block. Once the block is closed, the <code class="inlineCode">file</code> binding variable is out of scope. But, thanks to flow scoping, a binding variable can be used in the <code class="inlineCode">if</code> statement <a id="_idIndexMarker332"/>that has introduced it to define a so-called <em class="italic">guarded pattern</em>. Here it is:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// 'file' is created ONLY if 'instanceof' returns true</span>
<span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> File file
    <span class="hljs-comment">// this is evaluated ONLY if 'file' was created</span>
    &amp;&amp; file.length() &gt; <span class="hljs-number">0</span> &amp;&amp; file.length() &lt; <span class="hljs-number">1000</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">"Saving a file of size: "</span> 
    + String.format(<span class="hljs-string">"%,d bytes"</span>, file.length());
}
<span class="hljs-comment">// another example</span>
<span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Path path
     &amp;&amp; Files.size(path) &gt; <span class="hljs-number">0</span> &amp;&amp; Files.size(path) &lt; <span class="hljs-number">1000</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">"Saving a file of size: "</span> 
    + String.format(<span class="hljs-string">"%,d bytes"</span>, Files.size(path));
}
</code></pre>
    <p class="normal">The conditional part that starts <a id="_idIndexMarker333"/>with the <code class="inlineCode">&amp;&amp;</code> short-circuit operator is evaluated by the compiler only if the <code class="inlineCode">instanceof</code> operator is evaluated to <code class="inlineCode">true</code>. This <a id="_idIndexMarker334"/>means that you cannot use the <code class="inlineCode">||</code> operator instead of <code class="inlineCode">&amp;&amp;</code>. For instance, is not logical to write this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// this will not compile</span>
<span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Path path
  || Files.size(path) &gt; <span class="hljs-number">0</span> &amp;&amp; Files.size(path) &lt; <span class="hljs-number">1000</span>) {...}
</code></pre>
    <p class="normal">On the other hand, this is perfectly acceptable:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Path path
  &amp;&amp; (Files.size(path) &gt; <span class="hljs-number">0</span> || Files.size(path) &lt; <span class="hljs-number">1000</span>)) {...}
</code></pre>
    <p class="normal">We can also extend the scope of the binding variable as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> String str)) {
  <span class="hljs-comment">// str is not available here</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">"I cannot save the given object"</span>;
} <span class="hljs-keyword">else</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-string">"Saving a string of size: "</span> 
    + String.format(<span class="hljs-string">"%,d bytes"</span>, str.length());
}
</code></pre>
    <p class="normal">Since we negate the <code class="inlineCode">if</code>-then statement, the <code class="inlineCode">str</code> binding variable is available in the <code class="inlineCode">else</code> branch. Following this logic, we can use <em class="italic">early returns</em> as well:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">getStringLength</span><span class="hljs-params">(Object o)</span> { 
  <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> String str)) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }
  <span class="hljs-keyword">return</span> str.length();
}
</code></pre>
    <p class="normal">Thanks to flow scoping, the compiler can set up strict boundaries for the scope of binding variables. For instance, in<a id="_idIndexMarker335"/> the following code, there is no risk of<a id="_idIndexMarker336"/> overlapping even if we keep using the same name for the binding variables:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> String <span class="hljs-title">strNumber</span><span class="hljs-params">(Object o)</span> {
 <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Integer <span class="code-highlight"><strong class="hljs-slc">nr</strong></span>) {
   <span class="hljs-keyword">return</span> String.valueOf(nr.intValue());
 } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Long <span class="code-highlight"><strong class="hljs-slc">nr</strong></span>) {
   <span class="hljs-keyword">return</span> String.valueOf(nr.longValue());
 } <span class="hljs-keyword">else</span> {
   <span class="hljs-comment">// nr is out of scope here</span>
   <span class="hljs-keyword">return</span> <span class="hljs-string">"Probably a float number"</span>;
 }
}
</code></pre>
    <p class="normal">Here, each <code class="inlineCode">nr</code> binding variable has a scope that covers only its own branch. No overlapping, no conflicts! However, using the same name for the multiple binding variables can be a little bit confusing, so it is better to avoid it. For instance, we can use <code class="inlineCode">intNr</code> and <code class="inlineCode">longNr</code> instead of simple <code class="inlineCode">nr</code>.</p>
    <p class="normal">Another confusing scenario that is highly recommended to be avoided implies binding variables that hide fields. Check out this code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="code-highlight"><strong class="hljs-variable-slc">str</strong></span>
  <span class="hljs-operator">=</span> <span class="hljs-string">"   I am a string with leading and trailing spaces     "</span>;
<span class="hljs-keyword">public</span> String <span class="hljs-title">convert</span><span class="hljs-params">(Object o)</span> {
  <span class="hljs-comment">// local variable (binding variable) hides a field</span>
  <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> String <span class="code-highlight"><strong class="hljs-slc">str</strong></span>) { 
    <span class="hljs-keyword">return</span> str.strip(); <span class="hljs-comment">// refers to binding variable, str</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> str.strip(); <span class="hljs-comment">// refers to field, str</span>
  } 
}
</code></pre>
    <p class="normal">So, using the same name for binding variables (this is true for any local variable as well) and fields is a bad practice that should be avoided.</p>
    <p class="normal">In JDK 14/15, we cannot reassign binding variables because they are declared <code class="inlineCode">final</code> by default. However, JDK 16+ solved the asymmetries that may occur between local and binding variables by removing<a id="_idIndexMarker337"/> the <code class="inlineCode">final</code> modifier. So, starting <a id="_idIndexMarker338"/>with JDK 16+, we can reassign binding variables as in the following snippet:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-string">""</span>;
<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title">getLength</span><span class="hljs-params">(Object o)</span> { 
<span class="hljs-keyword">  if</span>(o <span class="hljs-keyword">instanceof</span> String str) {
      str = dummy; <span class="hljs-comment">// reassigning binding variable</span>
      <span class="hljs-comment">// returns the length of 'dummy' not the passed 'str'</span>
      <span class="hljs-keyword">return</span> str.length(); 
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
    <p class="normal">Even if this is possible, it is highly recommended to avoid such <em class="italic">code smells</em> and keep the world clean and happy by not re-assigning your binding variables.</p>
    <h1 id="_idParaDest-129" class="heading-1">60. Rewriting equals() via type patterns for instanceof</h1>
    <p class="normal">It is not mandatory to<a id="_idIndexMarker339"/> rely on <code class="inlineCode">instanceof</code> to implement the <code class="inlineCode">equals()</code> method, but it is a convenient approach to write something as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyPoint</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> x;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> y;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> z;
  <span class="hljs-keyword">public</span> <span class="hljs-title">MyPoint</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> x, </span><span class="hljs-type">int</span><span class="hljs-params"> y, </span><span class="hljs-type">int</span><span class="hljs-params"> z)</span> {
    <span class="hljs-built_in">this</span>.x = x;
    <span class="hljs-built_in">this</span>.y = y;
    <span class="hljs-built_in">this</span>.z = z;
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == obj) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">if</span> (!(obj <span class="hljs-keyword">instanceof</span> MyPoint)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">final</span> <span class="hljs-type">MyPoint</span> <span class="hljs-variable">other</span> <span class="hljs-operator">=</span> (MyPoint) obj;
    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.x == other.x &amp;&amp; <span class="hljs-built_in">this</span>.y == other.y
      &amp;&amp; <span class="hljs-built_in">this</span>.z == other.z); 
  }       
}
</code></pre>
    <p class="normal">If you are a fan of the <a id="_idIndexMarker340"/>previous approach for implementing <code class="inlineCode">equals()</code>, then you’ll love rewriting it via a type pattern for <code class="inlineCode">instanceof</code>. Check out the following snippet:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> {
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == obj) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">return</span> obj <span class="hljs-keyword">instanceof</span> MyPoint other
    &amp;&amp; <span class="hljs-built_in">this</span>.x == other.x &amp;&amp; <span class="hljs-built_in">this</span>.y == other.y
    &amp;&amp; <span class="hljs-built_in">this</span>.z == other.z; 
}
</code></pre>
    <p class="normal">If <code class="inlineCode">MyPoint</code> is generic (<code class="inlineCode">MyPoint&lt;E&gt;</code>) then simply use a wildcard as follows (more details are available in the next problem):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> obj <span class="hljs-keyword">instanceof</span> MyPoint&lt;?&gt; other
  &amp;&amp; <span class="hljs-built_in">this</span>.x == other.x &amp;&amp; <span class="hljs-built_in">this</span>.y == other.y
  &amp;&amp; <span class="hljs-built_in">this</span>.z == other.z;
</code></pre>
    <p class="normal">Cool, right?! However, pay attention that using <code class="inlineCode">instanceof</code> to express the <code class="inlineCode">equals()</code> contract imposes the usage of a <code class="inlineCode">final</code> class of <code class="inlineCode">final equals()</code>. Otherwise, if subclasses are allowed to override <code class="inlineCode">equals()</code>, then <code class="inlineCode">instanceof</code> may cause transitivity/symmetry bugs. A good approach is to pass <code class="inlineCode">equals()</code> through a dedicated verifier such as equals verifier (<a href="https://github.com/jqno/equalsverifier"><span class="url">https://github.com/jqno/equalsverifier</span></a>), which is capable of checking the<a id="_idIndexMarker341"/> validity of the <code class="inlineCode">equals()</code> and <code class="inlineCode">hashCode()</code> contracts.</p>
    <h1 id="_idParaDest-130" class="heading-1">61. Tackling type patterns for instanceof and generics</h1>
    <p class="normal">Consider the following <a id="_idIndexMarker342"/>snippet of code that uses <code class="inlineCode">instanceof</code> in the old-school fashion:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(Map&lt;K, ? extends V&gt; map)</span> {
  <span class="hljs-keyword">if</span> (map <span class="hljs-keyword">instanceof</span> EnumMap&lt;?, ? <span class="hljs-keyword">extends</span> <span class="hljs-title">V</span>&gt;) {
    EnumMap&lt;?, ? <span class="hljs-keyword">extends</span> <span class="hljs-title">V</span>&gt; books 
     = (EnumMap&lt;?, ? <span class="hljs-keyword">extends</span> <span class="hljs-title">V</span>&gt;) map;
    <span class="hljs-keyword">if</span> (books.get(Status.DRAFT) <span class="hljs-keyword">instanceof</span> Book) {
      <span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> (Book) books.get(Status.DRAFT);
      book.review();
    }
  }
}
<span class="hljs-comment">// use case</span>
EnumMap&lt;Status, Book&gt; books = <span class="hljs-keyword">new</span> <span class="hljs-title">EnumMap</span>&lt;&gt;(Status.class);
books.put(Status.DRAFT, <span class="hljs-keyword">new</span> <span class="hljs-title">Book</span>());
books.put(Status.READY, <span class="hljs-keyword">new</span> <span class="hljs-title">Book</span>());
process(books);
</code></pre>
    <p class="normal">As we know from <em class="italic">Problem 56</em>, we can combine <code class="inlineCode">instanceof</code> with generic types via unbounded wildcards, such as our <code class="inlineCode">EnumMap&lt;?, ? extends V&gt;</code> (or <code class="inlineCode">EnumMap&lt;?, ?&gt;</code>, but not <code class="inlineCode">EnumMap&lt;K, ? extends V&gt;</code>, <code class="inlineCode">EnumMap&lt;K, ?&gt;</code>, or <code class="inlineCode">EnumMap&lt;K, V&gt;</code>).</p>
    <p class="normal">This code can be written more concisely via the type pattern for <code class="inlineCode">instanceof</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(Map&lt;K, ? extends V&gt; map)</span> {
  <span class="hljs-keyword">if</span> (map <span class="hljs-keyword">instanceof</span> EnumMap&lt;?, ? <span class="hljs-keyword">extends</span> <span class="hljs-title">V</span>&gt; books
    &amp;&amp; books.get(Status.DRAFT) <span class="hljs-keyword">instanceof</span> Book book) {
      book.review();
  }
}
</code></pre>
    <p class="normal">In the example based on plain <code class="inlineCode">instanceof</code>, we can also replace <code class="inlineCode">EnumMap&lt;?, ? extends V&gt;</code> with <code class="inlineCode">Map&lt;?, ? extends V&gt;</code>. But, as we know from <em class="italic">Problem 53</em>, this is not possible with type patterns because the expression type cannot be a subtype of pattern type (upcasting is allowed). However, this is not an issue anymore starting with JDK 21.</p>
    <h1 id="_idParaDest-131" class="heading-1">62. Tackling type patterns for instanceof and streams</h1>
    <p class="normal">Let’s consider a <code class="inlineCode">List&lt;Engine&gt;</code> where <code class="inlineCode">Engine</code> is an interface implemented by several classes such as <code class="inlineCode">HypersonicEngine</code>, <code class="inlineCode">HighSpeedEngine</code>, and <code class="inlineCode">RegularEngine</code>. Our goal is to filter this <code class="inlineCode">List</code> and eliminate all <code class="inlineCode">RegularEngine</code> classes that are electric and cannot pass our autonomy test. So, we can<a id="_idIndexMarker343"/> write code as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Engine&gt; <span class="hljs-title">filterRegularEngines</span><span class="hljs-params">(</span>
<span class="hljs-params">              List&lt;Engine&gt; engines, </span><span class="hljs-type">int</span><span class="hljs-params"> testSpeed)</span> {
  <span class="hljs-keyword">for</span> (Iterator&lt;Engine&gt; i = engines.iterator(); i.hasNext();){
    <span class="hljs-keyword">final</span> <span class="hljs-type">Engine</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> i.next();
    <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> RegularEngine) {
      <span class="hljs-keyword">final</span> <span class="hljs-type">RegularEngine</span> <span class="hljs-variable">popularEngine</span> <span class="hljs-operator">=</span> (RegularEngine) e;
      <span class="hljs-keyword">if</span> (popularEngine.isElectric()) {
        <span class="hljs-keyword">if</span> (!hasEnoughAutonomy(popularEngine, testSpeed)) {
          i.remove();
        }
      }
    }
  }
  <span class="hljs-keyword">return</span> engines;
}
</code></pre>
    <p class="normal">But, starting with JDK 8, we can safely remove from a <code class="inlineCode">List</code> without using an <code class="inlineCode">Iterator</code> via a <code class="inlineCode">default</code> method from <code class="inlineCode">java.util.Collection</code> named <code class="inlineCode">public default boolean removeIf(Predicate&lt;? super E&gt; filter)</code>. If we combine this method (and, therefore, the Stream API) with type patterns for <code class="inlineCode">instanceof</code>, then we can simplify the previous code as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Engine&gt; <span class="hljs-title">filterRegularEngines</span><span class="hljs-params">(</span>
<span class="hljs-params">              List&lt;Engine&gt; engines, </span><span class="hljs-type">int</span><span class="hljs-params"> testSpeed)</span> {
  engines.removeIf(e -&gt; e <span class="hljs-keyword">instanceof</span> RegularEngine engine 
    &amp;&amp; engine.isElectric()
    &amp;&amp; !hasEnoughAutonomy(engine, testSpeed));
  <span class="hljs-keyword">return</span> engines;
}
</code></pre>
    <p class="normal">So, whenever you have the chance to use type patterns with the Stream API, don’t hesitate.</p>
    <h1 id="_idParaDest-132" class="heading-1">63. Introducing type pattern matching for switch</h1>
    <p class="normal">JDK 17 (JEP 406) added type pattern matching for <code class="inlineCode">switch</code> as a preview feature. A second preview was available in JDK 18 (JEP 420). The final<a id="_idIndexMarker344"/> release is available in JDK 21 as JEP 441.</p>
    <p class="normal">Type pattern matching for <code class="inlineCode">switch</code> allows the <em class="italic">selector expression </em>(that is, <code class="inlineCode">o</code> in <code class="inlineCode">switch(o)</code>) to be of any type not just an <code class="inlineCode">enum</code> constant, number, or string. By “any type,” I mean any type (any object type, <code class="inlineCode">enum</code> type, array type, record type, or sealed type)! The type pattern matching is not limited to a single hierarchy as it happens in the case of inheritance polymorphism. The <code class="inlineCode">case</code> labels can have type patterns (referred to as case pattern labels or, simply, pattern labels), so the selector expression (<code class="inlineCode">o</code>) can be matched against a type pattern, not only against a constant.</p>
    <p class="normal">In the next snippet of code, we rewrote the example from <em class="italic">Problem 58</em> via a type pattern for <code class="inlineCode">switch</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">save</span><span class="hljs-params">(Object o)</span> <span class="hljs-keyword">throws</span> IOException {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(o) {
    <span class="hljs-keyword">case</span> File file -&gt; <span class="hljs-string">"Saving a file of size: "</span> 
              + String.format(<span class="hljs-string">"%,d bytes"</span>, file.length());
    <span class="hljs-keyword">case</span> Path path -&gt; <span class="hljs-string">"Saving a file of size: "</span> 
              + String.format(<span class="hljs-string">"%,d bytes"</span>, Files.size(path));
    <span class="hljs-keyword">case</span> String str -&gt; <span class="hljs-string">"Saving a string of size: "</span> 
              + String.format(<span class="hljs-string">"%,d bytes"</span>, str.length());
    <span class="hljs-keyword">case</span> <span class="hljs-literal">null</span> -&gt; <span class="hljs-string">"Why are you doing this?"</span>;
    <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">"I cannot save the given object"</span>;
  }; 
}
</code></pre>
    <p class="normal">The following figure identifies the main players of a <code class="inlineCode">switch</code> branch:</p>
    <figure class="mediaobject"><img src="../Images/B19665_02_33.png" alt="Figure 2.33.png"/></figure>
    <p class="packt_figref">Figure 2.33: Type pattern matching for switch</p>
    <p class="normal">The <code class="inlineCode">case</code> for <code class="inlineCode">null</code> is not <a id="_idIndexMarker345"/>mandatory. We have added it just for the sake of completeness. On the other hand, the <code class="inlineCode">default</code> branch is a must, but this topic is covered later in this chapter.</p>
    <h1 id="_idParaDest-133" class="heading-1">64. Adding guarded pattern labels in switch</h1>
    <p class="normal">Do you remember that type patterns for <code class="inlineCode">instanceof</code> can be refined with extra <code class="inlineCode">boolean</code> checks applied to the binding variables to<a id="_idIndexMarker346"/> obtain fine-grained use cases? Well, we can do the same for the <code class="inlineCode">switch</code> expressions that <a id="_idIndexMarker347"/>use pattern labels. The result is named <em class="italic">guarded pattern labels</em>. Let’s consider the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">turnOnTheHeat</span><span class="hljs-params">(Heater heater)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (heater) {
    <span class="hljs-keyword">case</span> Stove stove -&gt; <span class="hljs-string">"Make a fire in the stove"</span>;
    <span class="hljs-keyword">case</span> Chimney chimney -&gt; <span class="hljs-string">"Make a fire in the chimney"</span>;
    <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">"</span><span class="hljs-string">No heater available!"</span>;
  };
}
</code></pre>
    <p class="normal">Having a <code class="inlineCode">Stove</code> and a <code class="inlineCode">Chimney</code>, this <code class="inlineCode">switch</code> decides where to make a fire based on pattern labels. But, what will happen if <code class="inlineCode">Chimney</code> is electric? Obviously, we will have to plug <code class="inlineCode">Chimney</code> in instead of firing it up. This means that we should add a guarded pattern label that helps us to make the difference between an electric and non-electric <code class="inlineCode">Chimney</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (heater) {
  <span class="hljs-keyword">case</span> Stove stove -&gt; <span class="hljs-string">"Make a fire in the stove"</span>;
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-keyword-slc">case</strong><strong class="hljs-slc"> Chimney chimney</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    &amp;&amp; chimney.isElectric() -&gt; </strong><strong class="hljs-string-slc">"Plug in the chimney"</strong><strong class="hljs-slc">;</strong></span>
  <span class="hljs-keyword">case</span> Chimney chimney -&gt; <span class="hljs-string">"Make a fire in the chimney"</span>;
  <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">"No heater available!"</span>;
};
</code></pre>
    <p class="normal">Well, that was easy, wasn’t it? Let’s have another example that starts from the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">enum</span> <span class="hljs-title">FuelType </span>{ GASOLINE, HYDROGEN, KEROSENE }
<span class="hljs-keyword">class</span> <span class="hljs-title">Vehicle</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> gallon;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> FuelType fuel;
  ...
}
</code></pre>
    <p class="normal">For each <code class="inlineCode">Vehicle</code>, we know the fuel type and how many gallons of fuel fit in the tank. Now, we can write a <code class="inlineCode">switch</code> that can rely <a id="_idIndexMarker348"/>on guarded pattern labels to<a id="_idIndexMarker349"/> try to guess the type of the vehicle based on this information:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">theVehicle</span><span class="hljs-params">(Vehicle vehicle)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (vehicle) {
    <span class="hljs-keyword">case</span> Vehicle v &amp;&amp; v.getFuel().equals(GASOLINE)
      &amp;&amp; v.getGallon() &lt; <span class="hljs-number">120</span> -&gt; <span class="hljs-string">"probably a car/van"</span>; 
    <span class="hljs-keyword">case</span> Vehicle v &amp;&amp; v.getFuel().equals(GASOLINE)
      &amp;&amp; v.getGallon() &gt; <span class="hljs-number">120</span> -&gt; <span class="hljs-string">"probably a big rig"</span>; 
    <span class="hljs-keyword">case</span> Vehicle v &amp;&amp; v.getFuel().equals(HYDROGEN) 
      &amp;&amp; v.getGallon() &lt; <span class="hljs-number">300_000</span> -&gt; <span class="hljs-string">"probably an aircraft"</span>;
    <span class="hljs-keyword">case</span> Vehicle v &amp;&amp; v.getFuel().equals(HYDROGEN) 
      &amp;&amp; v.getGallon() &gt; <span class="hljs-number">300_000</span> -&gt; <span class="hljs-string">"probably a rocket"</span>;
    <span class="hljs-keyword">case</span> Vehicle v &amp;&amp; v.getFuel().equals(KEROSENE) 
      &amp;&amp; v.getGallon() &gt; <span class="hljs-number">2_000</span> &amp;&amp; v.getGallon() &lt; <span class="hljs-number">6_000</span> 
         -&gt; <span class="hljs-string">"probably a narrow-body aircraft"</span>;
    <span class="hljs-keyword">case</span> Vehicle v &amp;&amp; v.getFuel().equals(KEROSENE) 
      &amp;&amp; v.getGallon() &gt; <span class="hljs-number">6_000</span> &amp;&amp; v.getGallon() &lt; <span class="hljs-number">55_000</span>
         -&gt; <span class="hljs-string">"probably a large (B747-400) aircraft"</span>;
    <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">"no clue"</span>;
  };
}
</code></pre>
    <p class="normal">Notice that the pattern labels are the same in all cases (<code class="inlineCode">Vehicle v</code>) and the decision is refined via the guarded conditions. The previous examples work just fine in JDK 17 and 18, but they don’t work starting with JDK 19+. Because the <code class="inlineCode">&amp;&amp;</code> operator was considered confusing, starting with JDK 19+, we have to deal with a refinement syntax. Practically, instead of the <code class="inlineCode">&amp;&amp;</code> operator, we use the new context-specific keyword <code class="inlineCode">when</code> between the pattern label and the refining <code class="inlineCode">boolean</code> checks. So, in JDK 19+, the previous code becomes:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (vehicle) {
  <span class="hljs-keyword">case</span> Vehicle v <span class="hljs-title">when</span> <span class="hljs-params">(v.getFuel()</span>.equals(GASOLINE)
    &amp;&amp; v.getGallon() &lt; <span class="hljs-number">120</span>) -&gt; <span class="hljs-string">"probably a car/van"</span>; 
  <span class="hljs-keyword">case</span> Vehicle v <span class="hljs-title">when</span> <span class="hljs-params">(v.getFuel()</span>.equals(GASOLINE)
    &amp;&amp; v.getGallon() &gt; <span class="hljs-number">120</span>) -&gt; <span class="hljs-string">"probably a big rig"</span>; 
  ...
  <span class="hljs-keyword">case</span> Vehicle v <span class="hljs-title">when</span> <span class="hljs-params">(v.getFuel()</span>.equals(KEROSENE) 
    &amp;&amp; v.getGallon() &gt; <span class="hljs-number">6_000</span> &amp;&amp; v.getGallon() &lt; <span class="hljs-number">55_000</span>)
      -&gt; <span class="hljs-string">"probably a large (B747-400) aircraft"</span>;
  <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">"no clue"</span>;
};
</code></pre>
    <p class="normal">In the bundled code, you can find <a id="_idIndexMarker350"/>both versions for JDK 17/18, and <a id="_idIndexMarker351"/>JDK 19+.</p>
    <h1 id="_idParaDest-134" class="heading-1">65. Dealing with pattern label dominance in switch</h1>
    <p class="normal">The compiler matches the selector expression against the available pattern labels by testing the selector expression <a id="_idIndexMarker352"/>against each label starting from top to bottom (or, from the first to the last) in the exact order in which we wrote them in the <code class="inlineCode">switch</code> block. This means that the first match wins. Let’s assume that we have the following base class (<code class="inlineCode">Pill</code>) and some pills (<code class="inlineCode">Nurofen</code>, <code class="inlineCode">Ibuprofen</code>, and <code class="inlineCode">Piafen</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Pill</span> {}
<span class="hljs-keyword">class</span> <span class="hljs-title">Nurofen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pill</span> {}
<span class="hljs-keyword">class</span> <span class="hljs-title">Ibuprofen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pill</span> {}
<span class="hljs-keyword">class</span> <span class="hljs-title">Piafen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pill</span> {}
</code></pre>
    <p class="normal">Hierarchically speaking, <code class="inlineCode">Nurofen</code>, <code class="inlineCode">Ibuprofen</code>, and <code class="inlineCode">Piafen</code> are three classes placed at the same hierarchical level since all of them have the <code class="inlineCode">Pill</code> class as the base class. In an IS-A inheritance relationship, we say that <code class="inlineCode">Nurofen</code> is a <code class="inlineCode">Pill</code>, <code class="inlineCode">Ibuprofen</code> is a <code class="inlineCode">Pill</code>, and <code class="inlineCode">Piafen</code> is also a <code class="inlineCode">Pill</code>. Next, let’s use a <code class="inlineCode">switch</code> to serve our clients the proper headache pill:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">headache</span><span class="hljs-params">(Pill o)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(o) {
    <span class="hljs-keyword">case</span> Nurofen nurofen -&gt; <span class="hljs-string">"Get Nurofen ..."</span>;
    <span class="hljs-keyword">case</span> Ibuprofen ibuprofen -&gt; <span class="hljs-string">"Get Ibuprofen ..."</span>;
    <span class="hljs-keyword">case</span> Piafen piafen -&gt; <span class="hljs-string">"Get Piafen ..."</span>;
    <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">"Sorry, we cannot solve your headache!"</span>;
  };
}
</code></pre>
    <p class="normal">Calling <code class="inlineCode">headache(new Nurofen())</code> will match the first pattern label, <code class="inlineCode">Nurofen nurofen</code>. In the same manner, <code class="inlineCode">headache(new Ibuprofen())</code> matches the second pattern label, and <code class="inlineCode">headache(new Piafen())</code> matches the third one. No matter how we mix the order of these label cases, they will work as expected because they are on the same level and none of them dominate the<a id="_idIndexMarker353"/> others.</p>
    <p class="normal">For instance, since people don’t want headaches, they order a lot of Nurofen, so we don’t have any anymore. We represent this by removing/comment the corresponding case:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(o) { 
  <span class="hljs-comment">// case Nurofen nurofen -&gt; "Get Nurofen ...";</span>
  <span class="hljs-keyword">case</span> Ibuprofen ibuprofen -&gt; <span class="hljs-string">"Get Ibuprofen ..."</span>;
  <span class="hljs-keyword">case</span> Piafen piafen -&gt; <span class="hljs-string">"Get Piafen ..."</span>;
  <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">"Sorry, we cannot solve your headache!"</span>;
}; 
</code></pre>
    <p class="normal">So, what happens when a client wants Nurofen? You’re right … the <code class="inlineCode">default</code> branch will take action since <code class="inlineCode">Ibuprofen</code> and <code class="inlineCode">Piafen</code> don’t match the selector expression.</p>
    <p class="normal">But, what will happen if we modify the <code class="inlineCode">switch</code> as follows?</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(o) { 
  <span class="hljs-keyword">case</span> Pill pill -&gt; <span class="hljs-string">"Get a headache pill ..."</span>;
  <span class="hljs-keyword">case</span> Nurofen nurofen -&gt; <span class="hljs-string">"Get Nurofen ..."</span>;
  <span class="hljs-keyword">case</span> Ibuprofen ibuprofen -&gt; <span class="hljs-string">"Get Ibuprofen ..."</span>;
  <span class="hljs-keyword">case</span> Piafen piafen -&gt; <span class="hljs-string">"Get Piafen ..."</span>;
};
</code></pre>
    <p class="normal">Adding the <code class="inlineCode">Pill</code> base class as a pattern label case allows us to remove the <code class="inlineCode">default</code> branch since we cover all possible values (this is covered in detail in <em class="italic">Problem 66</em>). This time, the compiler will raise an error to inform us that the <code class="inlineCode">Pill</code> label case dominates the rest of the label cases. Practically, the first label case <code class="inlineCode">Pill pill</code> dominates all other label cases because every value that matches any of the <code class="inlineCode">Nurofen nurofen</code>, <code class="inlineCode">Ibuprofen ibuprofen</code>, <code class="inlineCode">Piafen piafen</code> patterns also matches the pattern <code class="inlineCode">Pill pill</code>. So, <code class="inlineCode">Pill pill</code> always wins while the rest of the label cases are useless. Switching <code class="inlineCode">Pill pill </code>with <code class="inlineCode">Nurofen nurofen</code> will give a chance to <code class="inlineCode">Nurofen nurofen</code>, but <code class="inlineCode">Pill pill </code>will still dominate the remaining two. So, we can eliminate the dominance of the base class <code class="inlineCode">Pill</code> by moving its label case to the last position:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(o) { 
  <span class="hljs-keyword">case</span> Nurofen nurofen -&gt; <span class="hljs-string">"Get Nurofen ..."</span>;
  <span class="hljs-keyword">case</span> Ibuprofen ibuprofen -&gt; <span class="hljs-string">"Get Ibuprofen ..."</span>;
  <span class="hljs-keyword">case</span> Piafenpiafen -&gt; <span class="hljs-string">"Get Piafen ..."</span>;
<span class="hljs-keyword">  case</span> Pill pill -&gt; <span class="hljs-string">"Get a headache pill ..."</span>;
};
</code></pre>
    <p class="normal">Now, every pattern label has a chance to win.</p>
    <p class="normal">Let’s have another example that starts from this hierarchy:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Drink</span> {}
<span class="hljs-keyword">class</span> <span class="hljs-title">Small</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Drink</span> {}
<span class="hljs-keyword">class</span> <span class="hljs-title">Medium</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Small</span> {}
<span class="hljs-keyword">class</span> <span class="hljs-title">Large</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Medium</span> {}
<span class="hljs-keyword">class</span> <span class="hljs-title">Extra</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Medium</span> {}
<span class="hljs-keyword">class</span> <span class="hljs-title">Huge</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Large</span> {}
<span class="hljs-keyword">class</span> <span class="hljs-title">Jumbo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Extra</span> {}
</code></pre>
    <p class="normal">This time, we have seven classes<a id="_idIndexMarker354"/> disposed of in a multi-level hierarchy. If we exclude the base class <code class="inlineCode">Drink</code>, we can represent the rest of them in a <code class="inlineCode">switch</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">buyDrink</span><span class="hljs-params">(Drink o)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(o) { 
    <span class="hljs-keyword">case</span> Jumbo j: <span class="hljs-keyword">yield</span> <span class="hljs-string">"We can give a Jumbo ..."</span>;
    <span class="hljs-keyword">case</span> Huge h: <span class="hljs-keyword">yield</span> <span class="hljs-string">"We can give a Huge ..."</span>; 
    <span class="hljs-keyword">case</span> Extra e: <span class="hljs-keyword">yield</span> <span class="hljs-string">"We can give a Extra ..."</span>;
    <span class="hljs-keyword">case</span> Large l: <span class="hljs-keyword">yield</span> <span class="hljs-string">"</span><span class="hljs-string">We can give a Large ..."</span>;
    <span class="hljs-keyword">case</span> Medium m: <span class="hljs-keyword">yield</span> <span class="hljs-string">"We can give a Medium ..."</span>;
    <span class="hljs-keyword">case</span> Small s: <span class="hljs-keyword">yield</span> <span class="hljs-string">"We can give a Small ..."</span>;
    <span class="hljs-keyword">default</span>: <span class="hljs-keyword">yield</span> <span class="hljs-string">"Sorry, we don't have this drink!"</span>;
  };
}
</code></pre>
    <p class="normal">The order of pattern labels is imposed by the class hierarchy and is quite strict, but we can make some changes without creating any dominance issues. For instance, since <code class="inlineCode">Extra</code> and <code class="inlineCode">Large</code> are subclasses of <code class="inlineCode">Medium</code>, we can switch their positions. Some things apply to <code class="inlineCode">Jumbo</code> and <code class="inlineCode">Huge</code> since they are both subclasses of <code class="inlineCode">Medium</code> via <code class="inlineCode">Extra</code>, respectively <code class="inlineCode">Large</code>.</p>
    <p class="normal">In this context, the compiler evaluates the selection expression by trying to match it against this hierarchy via an IS-A inheritance relationship. For instance, let’s order a <code class="inlineCode">Jumbo</code> drink while there are no more <code class="inlineCode">Jumbo</code> and <code class="inlineCode">Extra</code> drinks:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(o) { 
  <span class="hljs-keyword">case</span> Huge h: <span class="hljs-keyword">yield</span> <span class="hljs-string">"We can give a Huge ..."</span>;
  <span class="hljs-keyword">case</span> Large l: <span class="hljs-keyword">yield</span> <span class="hljs-string">"We can give a Large ..."</span>;
  <span class="hljs-keyword">case</span> Medium m: <span class="hljs-keyword">yield</span> <span class="hljs-string">"We can give a Medium ..."</span>;
  <span class="hljs-keyword">case</span> Small s: <span class="hljs-keyword">yield</span> <span class="hljs-string">"We can give a Small ..."</span>;
  <span class="hljs-keyword">default</span>: <span class="hljs-keyword">yield</span> <span class="hljs-string">"Sorry, we don't have this drink!"</span>;
};
</code></pre>
    <p class="normal">If we order <code class="inlineCode">Jumbo</code> (<code class="inlineCode">o</code> is <code class="inlineCode">Jumbo</code>), then we will get <code class="inlineCode">Medium</code>. Why? The compiler matches <code class="inlineCode">Jumbo</code> against <code class="inlineCode">Huge</code> without success. The same result is obtained while matching <code class="inlineCode">Jumbo</code> against <code class="inlineCode">Large</code>. However, when it matches <code class="inlineCode">Jumbo</code> against <code class="inlineCode">Medium</code>, it sees that <code class="inlineCode">Jumbo</code> is a <code class="inlineCode">Medium</code> subclass via the <code class="inlineCode">Extra</code> class. So, since <code class="inlineCode">Jumbo</code> is <code class="inlineCode">Medium</code>, the compiler chooses the <code class="inlineCode">Medium m</code> pattern label. At this <a id="_idIndexMarker355"/>point, <code class="inlineCode">Medium</code> matches <code class="inlineCode">Jumbo</code>, <code class="inlineCode">Extra</code>, and <code class="inlineCode">Medium</code>. So, soon we will be out of <code class="inlineCode">Medium</code> as well:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(o) {
  <span class="hljs-keyword">case</span> Huge h: <span class="hljs-keyword">yield</span> <span class="hljs-string">"We can give a Huge ..."</span>;
  <span class="hljs-keyword">case</span> Large l: <span class="hljs-keyword">yield</span> <span class="hljs-string">"We can give a Large ..."</span>;
  <span class="hljs-keyword">case</span> Small s: <span class="hljs-keyword">yield</span> <span class="hljs-string">"We can give a Small ..."</span>;
  <span class="hljs-keyword">default</span>: <span class="hljs-keyword">yield</span> <span class="hljs-string">"Sorry, we don't have this drink!"</span>;
};
</code></pre>
    <p class="normal">This time, any request for <code class="inlineCode">Jumbo</code>, <code class="inlineCode">Extra</code>, <code class="inlineCode">Medium</code>, or <code class="inlineCode">Small</code> will give us a <code class="inlineCode">Small</code>. I think you get the idea.</p>
    <p class="normal">Let’s take a step further, and analyze this code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title">oneHundredDividedBy</span><span class="hljs-params">(Integer value)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(value) { 
    <span class="hljs-keyword">case</span> Integer i -&gt; <span class="hljs-number">100</span>/i;
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> -&gt; <span class="hljs-number">0</span>;
  };
}
</code></pre>
    <p class="normal">Have you spotted the problem? A pattern label case dominates a constant label case, so the compiler will complain about the fact that the second case (<code class="inlineCode">case 0</code>) is dominated by the first case. This is normal, since 0 is an <code class="inlineCode">Integer</code> as well, so it will match the pattern label. The solution requires switching the cases:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(value) { 
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> -&gt; <span class="hljs-number">0</span>;
    <span class="hljs-keyword">case</span> Integer i -&gt; <span class="hljs-number">100</span>/i;
  };
</code></pre>
    <p class="normal">Here is another case to enforce this type of dominance:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">enum</span> <span class="hljs-title">Hero</span> { CAPTAIN_AMERICA, IRON_MAN, HULK }
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">callMyMarvelHero</span><span class="hljs-params">(Hero hero)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(hero) {
    <span class="hljs-keyword">case</span> Hero h -&gt; <span class="hljs-string">"Calling "</span> + h;
<span class="hljs-keyword">    case</span> HULK -&gt; <span class="hljs-string">"Sorry, we cannot call this guy!"</span>;
  };
}
</code></pre>
    <p class="normal">In this case, the constant is <code class="inlineCode">HULK</code> and it is dominated by the <code class="inlineCode">Hero h</code> pattern label case. This is normal, since <code class="inlineCode">HULK</code> is also a <a id="_idIndexMarker356"/>Marvel hero, so <code class="inlineCode">Hero h</code> will match all Marvel heroes including <code class="inlineCode">HULK</code>. Again, the fix relies on switching the cases:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(hero) { 
    <span class="hljs-keyword">case</span> HULK -&gt; <span class="hljs-string">"Sorry, we cannot call this guy!"</span>;
    <span class="hljs-keyword">case</span> Hero h -&gt; <span class="hljs-string">"Calling "</span> + h;
  };
</code></pre>
    <p class="normal">Okay, finally, let’s tackle this snippet of code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title">oneHundredDividedByPositive</span><span class="hljs-params">(Integer value)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(value) { 
    <span class="hljs-keyword">case</span> Integer i when i &gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">100</span>/i;
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> -&gt; <span class="hljs-number">0</span>;
    <span class="hljs-keyword">case</span> Integer i -&gt; (-<span class="hljs-number">1</span>) * <span class="hljs-number">100</span>/i;
  };
}
</code></pre>
    <p class="normal">You may think that if we enforce the <code class="inlineCode">Integer i</code> pattern label with a condition that forces <code class="inlineCode">i</code> to be strictly positive, then the constant label will not be dominated. But, this is not true; a guarded pattern label still dominates a constant label. The proper order places the constant labels first, followed by guarded pattern labels, and finally, by non-guarded pattern labels. The next code fixes the previous one:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(value) { 
  <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> -&gt; <span class="hljs-number">0</span>;
  <span class="hljs-keyword">case</span> Integer i when i &gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">100</span>/i;
  <span class="hljs-keyword">case</span> Integer i -&gt; (-<span class="hljs-number">1</span>) * <span class="hljs-number">100</span>/i;
};
</code></pre>
    <p class="normal">Okay, I think you get the idea. Feel<a id="_idIndexMarker357"/> free to practice all these examples in the bundled code.</p>
    <h1 id="_idParaDest-135" class="heading-1">66. Dealing with completeness (type coverage) in pattern labels for switch</h1>
    <p class="normal">In a nutshell, <code class="inlineCode">switch</code> expressions and <code class="inlineCode">switch</code> statements that use null and/or pattern labels should be exhaustive. In other<a id="_idIndexMarker358"/> words, we must cover with explicit switch case labels all the possible values. Let’s consider the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span> <span class="hljs-title">Vehicle</span> {}
<span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Vehicle</span> {}
<span class="hljs-keyword">class</span> <span class="hljs-title">Van</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Vehicle</span> {}
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">whatAmI</span><span class="hljs-params">(Vehicle vehicle)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(vehicle) {
    <span class="hljs-keyword">case</span> Car car -&gt; <span class="hljs-string">"You're a car"</span>;
    <span class="hljs-keyword">case</span> Van van -&gt; <span class="hljs-string">"You're a van"</span>;
  };
}
</code></pre>
    <p class="normal">This snippet of code doesn’t compile. The error is clear: <em class="italic">The switch expression does not cover all possible input values.</em> The compiler complains because we don’t have a case pattern label for <code class="inlineCode">Vehicle</code>. This base class can be legitimately used without being a <code class="inlineCode">Car</code> or a <code class="inlineCode">Van</code>, so it is a valid candidate for our <code class="inlineCode">switch</code>. We can add a <code class="inlineCode">case Vehicle</code> or a <code class="inlineCode">default</code> label. If you know that <code class="inlineCode">Vehicle</code> will remain an empty base class, then you’ll probably go for a <code class="inlineCode">default</code> label:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(vehicle) {
    <span class="hljs-keyword">case</span> Car car -&gt; <span class="hljs-string">"You're a car"</span>;
    <span class="hljs-keyword">case</span> Van van -&gt; <span class="hljs-string">"You're a van"</span>;
    <span class="code-highlight"><strong class="hljs-keyword-slc">default</strong><strong class="hljs-slc"> -&gt; </strong><strong class="hljs-string-slc">"I have no idea ... what are you?"</strong><strong class="hljs-slc">;</strong></span>
  };
</code></pre>
    <p class="normal">If we continue by adding another vehicle such as <code class="inlineCode">class Truck extends Vehicle {}</code>, then this will be handled by the <code class="inlineCode">default</code> branch. If we plan to use <code class="inlineCode">Vehicle</code> as an independent class (for instance, to enrich it with methods and functionalities), then we will prefer to add a <code class="inlineCode">case Vehicle</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(vehicle) {
    <span class="hljs-keyword">case</span> Car car -&gt; <span class="hljs-string">"You're a car"</span>;
    <span class="hljs-keyword">case</span> Van van -&gt; <span class="hljs-string">"You're a van"</span>;
    <span class="code-highlight"><strong class="hljs-keyword-slc">case</strong><strong class="hljs-slc"> Vehicle v -&gt; </strong><strong class="hljs-string-slc">"You're a vehicle"</strong><strong class="hljs-slc">; </strong><strong class="hljs-comment-slc">// total pattern</strong></span>
};
</code></pre>
    <p class="normal">This time, the <code class="inlineCode">Truck</code> class will match the <code class="inlineCode">case Vehicle</code> branch. Of course, we can add a <code class="inlineCode">case Truck</code> as well.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">The <code class="inlineCode">Vehicle v</code> pattern is named a <em class="italic">total type pattern</em>. There are two labels that we can use to match all possible values: the total type pattern (for instance, a base class or an interface) and the <code class="inlineCode">default</code> label. Generally speaking, a total pattern is a pattern that can be used instead of the <code class="inlineCode">default</code> label.</p>
    </div>
    <p class="normal">In the previous example, we can<a id="_idIndexMarker359"/> accommodate all possible values via the total pattern or the <code class="inlineCode">default</code> label but not both. This makes sense since the <code class="inlineCode">whatAmI(Vehicle vehicle)</code> method gets <code class="inlineCode">Vehicle</code> as an argument. So, in this example, the selector expression can be only <code class="inlineCode">Vehicle</code> or a subclass of <code class="inlineCode">Vehicle</code>. How about modifying this method as <code class="inlineCode">whatAmI(Object o)</code>?</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">whatAmI</span><span class="hljs-params">(Object o)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(o) {
    <span class="hljs-keyword">case</span> Car car -&gt; <span class="hljs-string">"You're a car"</span>;
    <span class="hljs-keyword">case</span> Van van -&gt; <span class="hljs-string">"You're a van"</span>;
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-keyword-slc">case</strong><strong class="hljs-slc"> Vehicle v -&gt; </strong><strong class="hljs-string-slc">"You're a vehicle"</strong><strong class="hljs-slc">; </strong><strong class="hljs-comment-slc">// optional</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-keyword-slc">default</strong><strong class="hljs-slc"> -&gt; </strong><strong class="hljs-string-slc">"I have no idea ... what are you?"</strong><strong class="hljs-slc">;</strong></span>
  };
}
</code></pre>
    <p class="normal">Now, the selector expression can be any type, which means that the total pattern <code class="inlineCode">Vehicle v</code> is not total anymore. While <code class="inlineCode">Vehicle v</code> becomes an optional ordinary pattern, the new total pattern is <code class="inlineCode">case Object obj</code>. This means that we can cover all possible values by adding the <code class="inlineCode">default</code> label or the <code class="inlineCode">case Object obj</code> total pattern:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(o) {
  <span class="hljs-keyword">case</span> Car car -&gt; <span class="hljs-string">"You're a car"</span>;
  <span class="hljs-keyword">case</span> Van van -&gt; <span class="hljs-string">"You're a van"</span>;
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-keyword-slc">case</strong><strong class="hljs-slc"> Vehicle v -&gt; </strong><strong class="hljs-string-slc">"You're a vehicle"</strong><strong class="hljs-slc">;  </strong><strong class="hljs-comment-slc">// optional</strong></span>
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-keyword-slc">case</strong><strong class="hljs-slc"> Object obj -&gt; </strong><strong class="hljs-string-slc">"You're an object"</strong><strong class="hljs-slc">; </strong><strong class="hljs-comment-slc">// total pattern</strong></span>
};
</code></pre>
    <p class="normal">I think you get the idea! How about using an interface for the base type? For instance, here is an example based on the Java built-in <code class="inlineCode">CharSequence</code> interface:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">whatAmI</span><span class="hljs-params">(CharSequence cs)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(cs) { 
    <span class="hljs-keyword">case</span> String str -&gt; <span class="hljs-string">"You're a string"</span>;
    <span class="hljs-keyword">case</span> Segment segment -&gt; <span class="hljs-string">"You're a Segment"</span>;
    <span class="hljs-keyword">case</span> CharBuffer charbuffer -&gt; <span class="hljs-string">"You're a CharBuffer"</span>;
    <span class="hljs-keyword">case</span> StringBuffer strbuffer -&gt; <span class="hljs-string">"You're a StringBuffer"</span>;
    <span class="hljs-keyword">case</span> StringBuilder strbuilder -&gt; <span class="hljs-string">"You're a StringBuilder"</span>;
  };
}
</code></pre>
    <p class="normal">This snippet of code doesn’t compile. The error is clear: <em class="italic">The switch expression does not cover all possible input values</em>. But, if we check the documentation of <code class="inlineCode">CharSequence</code>, we see that it is implemented by five classes: <code class="inlineCode">CharBuffer</code>, <code class="inlineCode">Segment</code>, <code class="inlineCode">String</code>, <code class="inlineCode">StringBuffer</code>, and <code class="inlineCode">StringBuilder</code>. In our code, each of these classes is covered by a pattern label, so we have covered all possible <a id="_idIndexMarker360"/>values, right? Well, yes and no… “Yes” because we cover all possible values for the moment, and “no” because anyone can implement the <code class="inlineCode">CharSequence</code> interface, which will break the exhaustive coverage of our <code class="inlineCode">switch</code>. We can do this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CoolChar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CharSequence </span>{ ... }
</code></pre>
    <p class="normal">At this moment, the <code class="inlineCode">switch</code> expression doesn’t cover the <code class="inlineCode">CoolChar</code> type. So, we still need a <code class="inlineCode">default</code> label or the total pattern, <code class="inlineCode">case CharSequence charseq</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(cs) { 
  <span class="hljs-keyword">case</span> String str -&gt; <span class="hljs-string">"You're a string"</span>;
  ...
  <span class="hljs-keyword">case</span> StringBuilder strbuilder -&gt; <span class="hljs-string">"</span><span class="hljs-string">You're a StringBuilder"</span>;
<span class="code-highlight"><strong class="hljs-comment-slc">  // we have created this</strong></span>
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-keyword-slc">case</strong><strong class="hljs-slc"> CoolChar cool -&gt; </strong><strong class="hljs-string-slc">"Welcome ... you're a CoolChar"</strong><strong class="hljs-slc">;</strong></span>
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-comment-slc">// this is a total pattern</strong></span>
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-keyword-slc">case</strong><strong class="hljs-slc"> CharSequence charseq -&gt; </strong><strong class="hljs-string-slc">"You're a CharSequence"</strong><strong class="hljs-slc">;</strong></span>
  <span class="hljs-comment">// can be used instead of the total pattern</span>
  <span class="hljs-comment">// default -&gt; "I have no idea ... what are you?";</span>
};
</code></pre>
    <p class="normal">Okay, let’s tackle this scenario on the <code class="inlineCode">java.lang.constant.ClassDesc</code> built-in interface:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">whatAmI</span><span class="hljs-params">(ConstantDesc constantDesc)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(constantDesc) { 
    <span class="hljs-keyword">case</span> Integer i -&gt; <span class="hljs-string">"You're an Integer"</span>;
    <span class="hljs-keyword">case</span> Long l -&gt; <span class="hljs-string">"You're a Long"</span>;
    <span class="hljs-keyword">case</span> Float f -&gt; <span class="hljs-string">" You're a Float"</span>;
    <span class="hljs-keyword">case</span> Double d -&gt; <span class="hljs-string">"You're a Double"</span>;
    <span class="hljs-keyword">case</span> String s -&gt; <span class="hljs-string">"You're a String"</span>;
    <span class="hljs-keyword">case</span> ClassDesc cd -&gt; <span class="hljs-string">"You're a ClassDesc"</span>;
    <span class="hljs-keyword">case</span> DynamicConstantDesc dcd -&gt; <span class="hljs-string">"You're a DCD"</span>;
    <span class="hljs-keyword">case</span> MethodHandleDesc mhd -&gt; <span class="hljs-string">"You're a MethodHandleDesc"</span>;
    <span class="hljs-keyword">case</span> MethodTypeDesc mtd -&gt; <span class="hljs-string">"You're a MethodTypeDesc"</span>;
  };
}
</code></pre>
    <p class="normal">This code compiles! There is no <code class="inlineCode">default</code> label and no total pattern but the <code class="inlineCode">switch</code> expression covers all possible <a id="_idIndexMarker361"/>values. How so?! This interface is declared as sealed via the <code class="inlineCode">sealed</code> modifier:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="code-highlight"><strong class="hljs-keyword-slc">sealed</strong></span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ClassDesc</span>
<span class="hljs-keyword">  extends</span> <span class="hljs-title">ConstantDesc</span>, TypeDescriptor.OfField&lt;ClassDesc&gt;
</code></pre>
    <p class="normal">Sealed interfaces/classes were introduced in JDK 17 (JEP 409) and we will cover this topic in <em class="italic">Chapter 8</em>. However, for now, it is enough to know that sealing allows us to have fine-grained control of inheritance so classes and interfaces define their permitted subtypes. This means that the compiler can determine all possible values in a <code class="inlineCode">switch</code> expression. Let’s consider a simpler example that starts as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Player</span> {}
<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Tennis</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Player</span> {}
<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Football</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Player</span> {}
<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Snooker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Player</span> {}
</code></pre>
    <p class="normal">And, let’s have a <code class="inlineCode">switch</code> expression covering all possible values for <code class="inlineCode">Player</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">trainPlayer</span><span class="hljs-params">(Player p)</span> { 
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (p) {
    <span class="hljs-keyword">case</span> Tennis t -&gt; <span class="hljs-string">"Training the tennis player ..."</span> + t;
    <span class="hljs-keyword">case</span> Football f -&gt; <span class="hljs-string">"Training the football player ..."</span> + f;
    <span class="hljs-keyword">case</span> Snooker s -&gt; <span class="hljs-string">"Training the snooker player ..."</span> + s;
  };
}
</code></pre>
    <p class="normal">The compiler is aware that the <code class="inlineCode">Player</code> interface has only three implementations and all of them are covered via pattern labels. We can add a <code class="inlineCode">default</code> label or the total pattern <code class="inlineCode">case Player player</code>, but you most probably don’t want to do that. Imagine that we add a new implementation of the sealed <code class="inlineCode">Player</code> interface named <code class="inlineCode">Golf</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Golf</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Player</span> {}
</code></pre>
    <p class="normal">If the <code class="inlineCode">switch</code> expression has a <code class="inlineCode">default</code> label, then <code class="inlineCode">Golf</code> values will be handled by this <code class="inlineCode">default</code> branch. If we have the total pattern <code class="inlineCode">Player player</code>, then this pattern will handle the <code class="inlineCode">Golf</code> values. On the other hand, if none of the <code class="inlineCode">default</code> labels or total patterns are present, the compiler <a id="_idIndexMarker362"/>will immediately complain that the <code class="inlineCode">switch</code> expression doesn’t cover all possible values. So, we are immediately informed, and once we add a <code class="inlineCode">case Golf g</code>, the error disappears. This way, we can easily maintain our code and have a guarantee that our <code class="inlineCode">switch</code> expressions are always up to date and cover all possible values. The compiler will never miss the chance to inform us when a new implementation of <code class="inlineCode">Player</code> is available.</p>
    <p class="normal">A similar logic applies to Java enums. Consider the following <code class="inlineCode">enum</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> <span class="hljs-title">PlayerTypes </span>{ TENNIS, FOOTBALL, SNOOKER }
</code></pre>
    <p class="normal">The compiler is aware of all the possible values for <code class="inlineCode">PlayerTypes</code>, so the following <code class="inlineCode">switch</code> expression compiles successfully:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">createPlayer</span><span class="hljs-params">(PlayerTypes p)</span> { 
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (p) {
    <span class="hljs-keyword">case</span> TENNIS -&gt; <span class="hljs-string">"Creating a tennis player ..."</span>;
    <span class="hljs-keyword">case</span> FOOTBALL -&gt; <span class="hljs-string">"Creating a football player ..."</span>;
    <span class="hljs-keyword">case</span> SNOOKER -&gt; <span class="hljs-string">"Creating a snooker player ..."</span>;
  };
}
</code></pre>
    <p class="normal">Again, we can add a <code class="inlineCode">default</code> label or the total pattern, <code class="inlineCode">case PlayerTypes pt</code>. But, if we add a new value in the <code class="inlineCode">enum</code> (for instance, <code class="inlineCode">GOLF</code>), the compiler will delegate the <code class="inlineCode">default</code> label or the total pattern to handle it. On the other hand, if none of these are available, the compiler will immediately complain that the <code class="inlineCode">GOLF</code> value is not covered, so we can add it (<code class="inlineCode">case GOLF g</code>) and create a golf player whenever required.</p>
    <p class="normal">So far, so good! Now, let’s consider the following context:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerClub</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Sport</span> {};
<span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> <span class="hljs-title">PlayerTypes</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Sport</span>
  { TENNIS, FOOTBALL, SNOOKER }
<span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Sport</span> permits PlayerTypes, PlayerClub {};
</code></pre>
    <p class="normal">The sealed interface <code class="inlineCode">Sport</code> allows only two subtypes: <code class="inlineCode">PlayerClub</code> (a class) and <code class="inlineCode">PlayerTypes</code> (an enum). If we<a id="_idIndexMarker363"/> write a <code class="inlineCode">switch</code> that covers all possible values for <code class="inlineCode">Sport</code>, then it will look as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">createPlayerOrClub</span><span class="hljs-params">(Sport s)</span> { 
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (s) {
    <span class="hljs-keyword">case</span> PlayerTypes p when p == PlayerTypes.TENNIS
      -&gt; <span class="hljs-string">"Creating a tennis player ..."</span>;
    <span class="hljs-keyword">case</span> PlayerTypes p when p == PlayerTypes.FOOTBALL
      -&gt; <span class="hljs-string">"Creating a football player ..."</span>;
    <span class="hljs-keyword">case</span> PlayerTypes p -&gt; <span class="hljs-string">"Creating a snooker player ..."</span>;
    <span class="hljs-keyword">case</span> PlayerClub p -&gt; <span class="hljs-string">"Creating a sport club ..."</span>;
  };
}
</code></pre>
    <p class="normal">We immediately observe that writing case <code class="inlineCode">PlayerTypes p when p == PlayerTypes.TENNIS</code> is not quite neat. What we actually want is <code class="inlineCode">case PlayerTypes.TENNIS</code> but, until JDK 21, this is not possible since qualified enum constants cannot be used in <code class="inlineCode">case</code> labels. However, starting with JDK 21, we can use qualified names of enum constants as labels, so we can write this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">createPlayerOrClub</span><span class="hljs-params">(Sport s)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (s) {
    <span class="hljs-keyword">case</span> PlayerTypes.TENNIS
      -&gt; <span class="hljs-string">"Creating a tennis player ..."</span>;
    <span class="hljs-keyword">case</span> PlayerTypes.FOOTBALL
      -&gt; <span class="hljs-string">"Creating a football player ..."</span>;
    <span class="hljs-keyword">case</span> PlayerTypes.SNOOKER
      -&gt; <span class="hljs-string">"Creating a snooker player ..."</span>;
    <span class="hljs-keyword">case</span> PlayerClub p 
      -&gt; <span class="hljs-string">"Creating a sport club ..."</span>;
  };
}
</code></pre>
    <p class="normal">Done! Now you know how to deal with type coverage in <code class="inlineCode">switch</code> expressions.</p>
    <h1 id="_idParaDest-136" class="heading-1">67. Understanding the unconditional patterns and nulls in switch expressions</h1>
    <p class="normal">Let’s imagine that we use JDK 17 and<a id="_idIndexMarker364"/> we have the <a id="_idIndexMarker365"/>following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">drive</span><span class="hljs-params">(Vehicle v)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (v) {
    <span class="hljs-keyword">case</span> Truck truck -&gt; <span class="hljs-string">"truck: "</span> + truck;
    <span class="hljs-keyword">case</span> Van van -&gt; <span class="hljs-string">"van: "</span> + van;
    <span class="hljs-keyword">case</span> Vehicle vehicle -&gt; <span class="hljs-string">"vehicle: "</span> + vehicle.start();
  };
}
drive(<span class="hljs-literal">null</span>);
</code></pre>
    <p class="normal">Notice the call, <code class="inlineCode">drive(null)</code>. This call will hit the <code class="inlineCode">Vehicle vehicle</code> total pattern, so even <code class="inlineCode">null</code> values match total patterns. But, this means that the binding variable <code class="inlineCode">vehicle</code> will also be <code class="inlineCode">null</code>, which means that this branch is prone to <code class="inlineCode">NullPointerException</code> (for instance, if we call a hypothetical method, <code class="inlineCode">vehicle.start()</code>):</p>
    <pre class="programlisting con"><code class="hljs-con">Exception in thread "main" java.lang.NullPointerException: Cannot invoke "modern.challenge.Vehicle.start()" because "vehicle" is null
</code></pre>
    <p class="normal">Because <code class="inlineCode">Vehicle vehicle</code> matches all possible values, it is known as a total pattern but also as an <em class="italic">unconditional pattern</em> since it matches everything unconditionally.</p>
    <p class="normal">But, as we know from <em class="italic">Problem 54</em>, starting with JDK 17+ (JEP 427), we can have a pattern label for <code class="inlineCode">null</code> itself, so we can handle the previous shortcoming as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (v) {
    <span class="hljs-keyword">case</span> Truck truck -&gt; <span class="hljs-string">"truck: "</span> + truck;
    <span class="hljs-keyword">case</span> Van van -&gt; <span class="hljs-string">"van: "</span> + van;
    <span class="code-highlight"><strong class="hljs-keyword-slc">case</strong><strong class="hljs-slc"> </strong><strong class="hljs-literal-slc">null</strong><strong class="hljs-slc"> -&gt; </strong><strong class="hljs-string-slc">"so, you don't have a vehicle?"</strong><strong class="hljs-slc">;</strong></span>
    <span class="hljs-keyword">case</span> Vehicle vehicle -&gt; <span class="hljs-string">"vehicle: "</span> + vehicle.start();
  };
</code></pre>
    <p class="normal">Yes, everybody agrees that adding a <code class="inlineCode">case null</code> between vehicles looks awkward. Adding it at the end is not an option since will raise a dominance issue. So, starting with JDK 19+, adding this <code class="inlineCode">case null</code> is no longer needed in this kind of scenario. Basically, the idea remains the same meaning that the unconditional pattern still only matches <code class="inlineCode">null</code> values so it will not allow the execution of that branch. Actually, when a <code class="inlineCode">null</code> value occurs, the <code class="inlineCode">switch</code> expressions will throw a <code class="inlineCode">NullPointerException</code> without even looking at the patterns. So, in JDK 19+, this code will throw an NPE right away:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (v) {
  <span class="hljs-keyword">case</span> Truck truck -&gt; <span class="hljs-string">"truck: "</span> + truck;
<span class="hljs-keyword">  case</span> Van van -&gt; <span class="hljs-string">"van: "</span> + van;
<span class="hljs-comment">  // we can still use a null check</span>
  <span class="hljs-comment">// case null -&gt; "so, you don't have a vehicle?";</span>
  <span class="hljs-comment">// total/unconditional pattern throw NPE immediately</span>
  <span class="hljs-keyword">case</span> Vehicle vehicle -&gt; <span class="hljs-string">"vehicle: "</span> + vehicle.start();
};
</code></pre>
    <p class="normal">The NPE message reveals <a id="_idIndexMarker366"/>that <code class="inlineCode">vehicle.start()</code> was never called. The NPE <a id="_idIndexMarker367"/>occurred much earlier:</p>
    <pre class="programlisting con"><code class="hljs-con">Exception in thread "main" java.lang.NullPointerExceptionatjava.base/java.util.Objects.requireNonNull(Objects.java:233)
</code></pre>
    <p class="normal">We will expand on this topic later when we will talk about Java records.</p>
    <h1 id="_idParaDest-137" class="heading-1">Summary</h1>
    <p class="normal">That’s all folks! This was a comprehensive chapter that covered four main topics, among others: <code class="inlineCode">java.util.Objects</code>, immutability, <code class="inlineCode">switch</code> expressions, and pattern matching for <code class="inlineCode">instanceof</code> and <code class="inlineCode">switch</code> expressions.</p>
    <h1 class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
    <p class="normal"><a href="https://discord.gg/8mgytp5DGQ "><span class="url">https://discord.gg/8mgytp5DGQ</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1139613064111216156.png" alt="" role="presentation"/></p>
  </div>
</body></html>