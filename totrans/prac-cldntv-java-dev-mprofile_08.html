<html><head></head><body>
		<div id="_idContainer036">
			<h1 id="_idParaDest-116"><em class="italic"><a id="_idTextAnchor123"/>Chapter 6</em>: Observing and Monitoring Cloud-Native Applications</h1>
			<p>In the previous two chapters, we discussed and explained the varying capabilities of the MicroProfile 4.1 platform for building and enhancing your cloud-native application. At this point, your cloud-native application is built on a strong fundamental core with much credit due to the tried and true components of the Jakarta EE platform. On top of that, you've added a few bells and whistles to make your application more resilient, secure, configurable, and documentable. For all intents and purposes, you have yourself a fully capable cloud-native application that's ready for deployment. But as the savvy developer that you are, you know that the story of your cloud-native application is not complete once you deploy it. Nothing is truly perfect and, depending on the complexity of your application ecosystem, letting your applications run wild can be disastrous.</p>
			<p>This brings forth the important task of monitoring your applications. You, your team, or your operations team will need to be able to monitor the activity and performance of your applications to identify any potential problems. Effective monitoring can be used as an early warning for impending trouble, shedding light on areas that may need optimizing, or aiding in the post-mortem analysis to see what might have gone wrong. Alternatively, from a more optimistic perspective, effective monitoring can simply provide beautiful data on the performance of your application. </p>
			<p>This leads us to this chapter, where we will cover the last three specifications that are included in the MicroProfile platform's release scope. For observing and monitoring your cloud-native applications, the MicroProfile platform provides the <strong class="bold">MicroProfile Health</strong>, <strong class="bold">MicroProfile Metrics</strong>, and <strong class="bold">MicroProfile OpenTracing</strong> technologies.</p>
			<p>In particular, we will cover the following topics:</p>
			<ul>
				<li>Determining the health of your cloud-native application using MicroProfile Health</li>
				<li>Instrumenting and using metrics on your cloud-native application using MicroProfile Metrics</li>
				<li>Tracing your cloud-native application using MicroProfile OpenTracing</li>
			</ul>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor124"/>Technical requirements</h1>
			<p>To build and run the samples mentioned in this chapter, you will need a Mac or PC (Windows or Linux) with the following software:</p>
			<ul>
				<li>Java Development Kit, version 8 or higher: <a href="https://adoptium.net/">https://adoptium.net/</a><a href="https://adoptopenjdk.net/ "/></li>
				<li>Apache Maven: <a href="https://maven.apache.org/ ">https://maven.apache.org/</a></li>
				<li>A Git client: <a href="https://git-scm.com/">https://git-scm.com/</a> </li>
			</ul>
			<p>All the source code used in this chapter is available on GitHub at</p>
			<p>Once you have cloned the GitHub repository, you can start the Open Liberty server that these code samples will execute in, by entering the <strong class="source-inline">ch6</strong> directory and entering the following command from the command line: </p>
			<p class="source-code">mvn clean package liberty:run</p>
			<p>You can then stop the server in the same command window by pressing <em class="italic">Ctrl</em> + <em class="italic">C</em>.</p>
			<p>The application that's deployed to the Open Liberty server will be given a context root of <strong class="source-inline">ch6</strong>. For example, the full URL to a JAX-RS resource would be <strong class="source-inline">http://localhost:9080/ch6/path/to/resource</strong>. This will be reflected in the code samples in this chapter that illustrate sending requests to an endpoint.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor125"/>Determining the health of your cloud-native application using MicroProfile Health</h1>
			<p>To begin <a id="_idIndexMarker569"/>our<a id="_idIndexMarker570"/> three-part journey of looking at the MicroProfile observability toolkit, we'll examine the MicroProfile Health technology. We chose to examine this technology first as its benefits and use cases are much broader in scope compared to the other two technologies in this chapter. The MicroProfile Health technology reports information regarding <a id="_idIndexMarker571"/>the health, or <a id="_idIndexMarker572"/>status, of your microservice. The expected health status is either <em class="italic">UP</em> or <em class="italic">DOWN</em>.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor126"/>The importance of MicroProfile Health in a cloud-native application</h2>
			<p>We<a id="_idIndexMarker573"/> now know what the MicroProfile<a id="_idIndexMarker574"/> Health technology can do. But what purpose does it serve? To find out, we must take a step back. The driving force for developing applications with the MicroProfile technologies is that they will be cloud native. And if you recall <a href="B17377_01_Final_SB_epub.xhtml#_idTextAnchor021"><em class="italic">Chapter 1</em></a>, <em class="italic">Cloud-Native Application</em>, the important distinction between a cloud-native application and a non-cloud-native application is its ability to take advantage of the capabilities provided by the cloud. The MicroProfile Health technology is a perfect example of this. </p>
			<p>At its very core, the MicroProfile Health technology strives to report the health of your application to some external observer. Since we are developing a cloud-native application, the application will live its life in a container that's been deployed on your cloud platform. Whether its tenure is short-lived or not is what the health statuses serve to dictate. In effect, these health statuses report the health of your container to your cloud platform. Using the status report of the container, the cloud platform's monitor service can use that data to make decisions to terminate and replace any troublesome containers. The circumstances of when your containers are terminated and restarted ultimately dependent on you, the developer. Your cloud platform may have rules on what to do, given the health of a container, but the context of how these health statuses are reported depends on how the MicroProfile Health technology is used throughout your application.</p>
			<p>Later in this chapter, we will examine a sample scenario of using the health status of your application/container with <strong class="bold">Kubernetes</strong>. Kubernetes is an open source project that provides a container orchestration solution for deploying, scaling, and managing your containers. As one of the more well-known container orchestration platforms, it will provide an excellent vehicle for demonstrating the benefits of using the MicroProfile Health technology. Kubernetes, along with other cloud infrastructure topics, will be covered in more detail in <a href="B17377_07_Final_SB_epub.xhtml#_idTextAnchor146"><em class="italic">Chapter 7</em></a><em class="italic">,</em> <em class="italic">MicroProfile Ecosystem with Open Liberty, Docker, and Kubernetes</em>.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor127"/>MicroProfile Health technology overview</h2>
			<p>MicroProfile <a id="_idIndexMarker575"/>Health provides three types of health, or status, checks. They are the <strong class="bold">liveness</strong>, <strong class="bold">readiness</strong>, and <strong class="bold">startup</strong> health checks. We will explain these health checks in detail shortly, but for now, know that their purpose is to report whether an application is alive, ready, or if it has even completed starting up. The instrumentation and existence of a health check in an application is <a id="_idIndexMarker576"/>defined as a <strong class="bold">procedure</strong>. This procedure is called upon to check if the application has started, as well as its liveness or readiness for the instrumented components of the application. Moving forward, we will refer to health checks as either a health check, a procedure, or a combination of both.</p>
			<p>Health check procedures can be instrumented throughout your microservice and will return an <em class="italic">UP</em> or <em class="italic">DOWN</em> status to indicate the liveness or readiness of the various components of your application, as well as if the application has completed initialization. The liveness, readiness, and startup health checks will be reported through the <strong class="source-inline">http://host:port/health/live</strong>, <strong class="source-inline">http://host:port/health/ready</strong>, and <strong class="source-inline">http://host:port/health/started</strong> endpoints, respectively. An overall status is provided for each endpoint and is the logical conjunction of all procedures. If there are five readiness procedures instrumented in your application and all but one procedure returns <em class="italic">UP</em>, then the overall readiness of your application is <em class="italic">DOWN</em>. There is also the <strong class="source-inline">http://host:port/health</strong> endpoint, which provides an overall status of the whole application from the conjunction of the health check procedures for the liveness, readiness, and startup health checks. When using the <strong class="source-inline">http://host:port/health</strong> endpoint, there is no distinction between liveness, readiness, or startup health checks. All health check procedures, regardless of their type, must return <em class="italic">UP</em> for the <strong class="source-inline">http://host:port/health</strong> endpoint to return <em class="italic">UP</em>. It should be noted that the order in which procedures are invoked is arbitrary, so they can be invoked in any order. Moving forward, when referring to the health endpoints, we will omit <strong class="source-inline">http://host:port</strong> for brevity. </p>
			<p>Before we move on, let's learn a little bit more about these three types of health checks.</p>
			<h3>Liveness health check</h3>
			<p>The purpose <a id="_idIndexMarker577"/>of the liveness health check <a id="_idIndexMarker578"/>procedure, as its name suggests, is to report whether the application is alive. In a cloud environment, this status can be used by the monitoring service to determine if the application is running as expected. Failing this health check may prompt your cloud platform's monitoring service to terminate the application's container. Depending on the policy that you've configured, this may cause the application's container to be restarted.</p>
			<p>Note that a failing liveness procedure does not mean that the application is no longer running. Instead, it means that the strategy that's been employed for instrumenting the check has deemed that the application has suffered or is suffering from a deterioration of service and can no longer be considered operationally effective. For example, a liveness procedure can be used to detect a memory leak in the JVM and at the rate of memory loss, so it would be prudent to terminate this container now instead of later. As a result, a <em class="italic">DOWN</em> status will be returned.</p>
			<h3>Startup health check</h3>
			<p>The purpose <a id="_idIndexMarker579"/>of the startup health<a id="_idIndexMarker580"/> check is to provide an intermediary check that is a precursor to the liveness health check. In a container environment, not all containers are made equal. Understandably, certain containers may be slow to start and initialize due to the complexity of the application that is running within them. In a compatible cloud environment, the startup check can be carried out for an <em class="italic">UP</em> before liveness checks are carried out.</p>
			<h3>Readiness health check </h3>
			<p>The <a id="_idIndexMarker581"/>purpose of a readiness <a id="_idIndexMarker582"/>health check procedure is to allow external observers (for example, the cloud monitoring service) to identify if the application is ready to receive and conduct business logic. The application may have effectively started and be alive and running with no issues, as indicated by the liveness checks, but it isn't quite ready to receive traffic yet. This could be because the application is still attempting to initialize a resource or connect to another application that it depends on. The readiness check will report <em class="italic">DOWN</em> as it continues its attempt to secure a connection.</p>
			<p class="callout-heading">Special Note About Default Health Checks</p>
			<p class="callout">Depending on your underlying MicroProfile runtime, your runtime may provide <strong class="bold">default health check procedures</strong>. For <a id="_idIndexMarker583"/>example, a default liveness procedure may be provided to indicate that the MicroProfile Health component of the runtime is running and <em class="italic">alive</em>. This may have been a very contrived example, but any default procedure, whether it's useful or not, can be disabled. You can disable default procedures by using the MicroProfile <strong class="source-inline">mp.health.disable-default-procedures</strong> Config element and <a id="_idIndexMarker584"/>setting<a id="_idIndexMarker585"/> its value to <strong class="source-inline">true</strong>. </p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor128"/>Instrumenting health check procedures</h2>
			<p>A health <a id="_idIndexMarker586"/>check procedure is called upon by the MicroProfile runtime to find out the health of a particular component of an application, whether it be a liveness, readiness, or startup procedure. But it can also be the case that the health check reports on the liveness, readiness, and startup procedures simultaneously. This is due to how the MicroProfile Health runtime operates under the hood. Like the other MicroProfile technologies, MicroProfile Health is intrinsically integrated with <strong class="bold">Context Dependency Injection</strong> (<strong class="bold">CDI</strong>), a<a id="_idIndexMarker587"/> technology we covered in <a href="B17377_04_Final_SB_epub.xhtml#_idTextAnchor068"><em class="italic">Chapter 4</em></a>, <em class="italic">Developing Cloud-Native Applications</em>. To identify what type of health checks a procedure reports on, we must use the <strong class="source-inline">@Liveness</strong>, <strong class="source-inline">@Readiness</strong>, and <strong class="source-inline">@Startup</strong> qualifier annotations. Using any of these annotations lets the MicroProfile Health runtime know what health statuses are being reported. But before we get too ahead of ourselves, what exactly is a health check in the application code?</p>
			<p>The basis for every health check procedure is the functional interface, called <strong class="source-inline">HealthCheck</strong>. This consists of a single function, <strong class="source-inline">call()</strong>, that returns a <strong class="source-inline">HealthCheckResponse</strong>. In an application, the <strong class="source-inline">HealthCheck</strong> implementation is annotated with at least one of the <strong class="source-inline">@Liveness</strong>, <strong class="source-inline">@Readiness</strong>, or <strong class="source-inline">@Startup</strong> annotations. Remember that MicroProfile Health's integration with CDI means that every health check procedure (that is, the <strong class="source-inline">HealthCheck</strong> implementation) is a CDI bean and has a place in the application's life cycle context. It would be prudent to also define a CDI scope for your health check procedure. We will be using <strong class="source-inline">@ApplicationScoped</strong> in our examples. </p>
			<p>The following code snippet demonstrates how to instrument the liveness, readiness, and startup health checks in the same procedure. You can instrument a singular health check by <a id="_idIndexMarker588"/>using one annotation instead:</p>
			<p class="source-code">@ApplicationScoped</p>
			<p class="source-code">@Liveness</p>
			<p class="source-code">@Readiness</p>
			<p class="source-code">@Startup</p>
			<p class="source-code">public class LivenessCheck implements HealthCheck {</p>
			<p class="source-code">    public HealthCheckResponse call() {</p>
			<p class="source-code">        [...]</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>So, now that we know how to create and define the different types of health checks, we can learn how to build the health check response, whose data will be consumed by an external observer through one of the <strong class="source-inline">/health/*</strong> endpoints.</p>
			<p>As we mentioned earlier, we will be returning a <strong class="source-inline">HealthCheckResponse</strong> object. This data object contains all the information we need for uniquely identifying the health check and, most importantly, the health of your cloud-native application. </p>
			<p><strong class="source-inline">HealthCheckResponse</strong> consists of three fields:</p>
			<ul>
				<li><strong class="bold">Name</strong>: This is a <strong class="source-inline">String</strong> field that distinguishes this health check procedure from other health check procedures. </li>
				<li><strong class="bold">Status</strong>: This is an <strong class="source-inline">enum</strong> field with either an <em class="italic">UP</em> or <em class="italic">DOWN</em> value.</li>
				<li><strong class="bold">Data</strong>: This is an optional field and holds a <strong class="source-inline">Map&lt;String, Object&gt;</strong>. When <strong class="bold">instrumenting</strong> a procedure, you can choose to provide additional information in key-value format. This map serves to provide additional contextual information about the procedure. The map holds a <strong class="source-inline">String</strong> key and its value can be either <strong class="source-inline">String</strong>, <strong class="source-inline">long</strong>, or <strong class="source-inline">boolean</strong>.</li>
			</ul>
			<p>Now, let's look at the different ways of constructing health check procedures. </p>
			<h3>Using HealthCheckResponseBuilder</h3>
			<p>To<a id="_idIndexMarker589"/> create a <strong class="source-inline">HealthCheckResponse</strong>, you<a id="_idIndexMarker590"/> can call one of two static methods in <strong class="source-inline">HealthCheckResponse</strong> that will return a <strong class="source-inline">HealthCheckResponseBuilder</strong>. These two methods are <strong class="source-inline">builder()</strong> and <strong class="source-inline">named(String name)</strong>. The latter creates a <strong class="source-inline">HealthCheckResponseBuilder</strong> with a name that's already specified, whereas the former provides a <em class="italic">clean</em> instance.</p>
			<p><strong class="source-inline">HealthCheckResponseBuilder</strong> provides a builder pattern for constructing a <strong class="source-inline">HealthCheckResponse</strong> containing the required and optional fields. This is the preferred method if you intend to provide optional data. </p>
			<p>The following code example shows a scenario where we are performing a liveness health check based on the heap memory usage of the JVM. </p>
			<p>The full source code for <strong class="source-inline">LivenessCheck</strong> can be found at <a href="https://bit.ly/2WbiVyV">https://bit.ly/2WbiVyV</a>:</p>
			<p class="source-code">@ApplicationScoped</p>
			<p class="source-code">@Liveness</p>
			<p class="source-code">public class LivenessCheck implements HealthCheck {</p>
			<p class="source-code">    public HealthCheckResponse call() {</p>
			<p class="source-code">    //Percentage value from 0.0-1.0</p>
			<p class="source-code">        Double memoryUsage = getMemUsage();</p>
			<p class="source-code">    HealthCheckResponseBuilder builder =       HealthCheckResponse.named("LivenessCheck");</p>
			<p class="source-code">    if (memoryUsage &lt; 0.9) {</p>
			<p class="source-code">        builder.up();</p>
			<p class="source-code">    } else {</p>
			<p class="source-code">        builder.down();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    builder = builder.withData("MemoryUsage",       memoryUsage.toString());</p>
			<p class="source-code">    return builder.build();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this<a id="_idIndexMarker591"/> example, we<a id="_idIndexMarker592"/> used the <strong class="source-inline">named(String name)</strong> static method to provide the health check with a name. We then used the <strong class="source-inline">HealthCheckResponseBuilder</strong> class's <strong class="source-inline">up()</strong>, <strong class="source-inline">down()</strong>, and <strong class="source-inline">withData(String key, String value)</strong> methods to specify the status of the health check and to provide any additional contextual data. The <strong class="source-inline">withData(…)</strong> method is an overloaded method and can accept <strong class="source-inline">String</strong>, <strong class="source-inline">long</strong>, and <strong class="source-inline">boolean</strong> values. In this example, if the memory usage is less than 90% (that is, a value less than <strong class="source-inline">0.9</strong> is returned by the <strong class="source-inline">getMemUsage()</strong> method), we will return an <em class="italic">UP</em> status. Otherwise, we will return a <em class="italic">DOWN</em> status.</p>
			<p>Alternatively, if you're using <strong class="source-inline">HealthCheckResponse.builder()</strong> instead, you will need to use the <strong class="source-inline">HealthCheckResponseBuilder</strong> class's <strong class="source-inline">name(String name)</strong> to provide a name for the health check.</p>
			<p>Now, instead of having a bulky <strong class="source-inline">if</strong>-<strong class="source-inline">else</strong> block, we can use <strong class="source-inline">HealthCheckResponseBuilder.status(boolean status)</strong> in one line:</p>
			<p class="source-code">    return HealthCheckResponse.builder()</p>
			<p class="source-code">      .name("LivenessCheck")</p>
			<p class="source-code">      .status(memoryUsage &lt; 0.9)</p>
			<p class="source-code">      .withData("MemoryUsage", memoryUsage</p>
			<p class="source-code">      .toString()).build()</p>
			<p>As you can see, we've reduced eight lines of code to one line!</p>
			<h3>Using HealthCheckResponse</h3>
			<p>Instead <a id="_idIndexMarker593"/>of using <strong class="source-inline">HealthCheckResponseBuilder</strong>, we<a id="_idIndexMarker594"/> can also use the <strong class="source-inline">HealthCheckResponse</strong> class's two static methods, which conveniently create an <em class="italic">UP</em> or <em class="italic">DOWN</em> <strong class="source-inline">HealthCheckResponse</strong>, as illustrated in the following example.</p>
			<p>The full source code for <strong class="source-inline">ReadinessCheck</strong> can be found at <a href="https://bit.ly/3iV3WBP">https://bit.ly/3iV3WBP</a>:</p>
			<p class="source-code">@ApplicationScoped</p>
			<p class="source-code">@Readiness</p>
			<p class="source-code">public class ReadinessCheck implements HealthCheck { </p>
			<p class="source-code">    public final String NAME = "evenNumberPhobic";</p>
			<p class="source-code">    public HealthCheckResponse call() {</p>
			<p class="source-code">        long time = System.currentTimeMillis();</p>
			<p class="source-code">        if (time % 2 == 0) </p>
			<p class="source-code">            return HealthCheckResponse.down(NAME);</p>
			<p class="source-code">        else</p>
			<p class="source-code">            return HealthCheckResponse.up(NAME);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The methods that are being used here are aptly named <strong class="source-inline">up(String name)</strong> and <strong class="source-inline">down(String name)</strong> and accept a <strong class="source-inline">String</strong> parameter that defines the name of the health check. This approach assumes that there is no additional optional data to be incorporated with this health check procedure. In the following example, we will retrieve the current system time and if it is an even number, we will return a <em class="italic">DOWN</em> status (otherwise, it will be an <em class="italic">UP</em> status).</p>
			<h3>CDI producers</h3>
			<p>With <a id="_idIndexMarker595"/>MicroProfile<a id="_idIndexMarker596"/> Health's implicit reliance on CDI, health checks procedures can also be instrumented using a CDI method producer. You can instrument multiple health check procedures in one class by using CDI method producers. The following example shows the liveness, readiness, and startup health check procedures being instrumented as CDI method producers. </p>
			<p>The full source code for <strong class="source-inline">CDIMethodProducerCheck</strong> can be found at <a href="https://bit.ly/3k9GrUT">https://bit.ly/3k9GrUT</a>:</p>
			<p class="source-code">@ApplicationScoped</p>
			<p class="source-code">public class CDIMethodProducerChecks {</p>
			<p class="source-code">  @Produces</p>
			<p class="source-code">  @Liveness</p>
			<p class="source-code">  HealthCheck livenessCDIMethodProducer() {</p>
			<p class="source-code">    return () -&gt; HealthCheckResponse.named("cdiMemUsage")      .status(getMemUsage() &lt; 0.9).build();</p>
			<p class="source-code">  }</p>
			<p class="source-code">  @Produces</p>
			<p class="source-code">  @Readiness</p>
			<p class="source-code">  HealthCheck readinessCDIMethodProducer() {</p>
			<p class="source-code">    return () -&gt; HealthCheckResponse.named("cdiCpuUsage")      .status(getCpuUsage() &lt; 0.9).build();</p>
			<p class="source-code">  }</p>
			<p class="source-code">  @Produces</p>
			<p class="source-code">  @Startup</p>
			<p class="source-code">  HealthCheck startupCDIMethodProducer() {</p>
			<p class="source-code">    return () -&gt; HealthCheckResponse.named       ("cdiStartStatus").status(getStatus()).build();</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The liveness procedure that's encapsulated by the <strong class="source-inline">livenessCDIMethodProducer</strong> method<a id="_idIndexMarker597"/> will return <em class="italic">UP</em> if the memory usage <a id="_idIndexMarker598"/>is below 90% (that is, a value less than 0.9 is returned by the <strong class="source-inline">getMemUsage()</strong> method). The readiness procedure that's encapsulated by the <strong class="source-inline">readinessCDIMethodProducer</strong> method will return <em class="italic">UP</em> if the CPU usage is below 90% (that is, a value less than 0.9 is returned by the <strong class="source-inline">getCpuUsage()</strong> method). The startup procedure that's encapsulated by the <strong class="source-inline">startupCDIMethodProducer</strong> method will execute the <strong class="source-inline">getStatus()</strong> business method to evaluate the condition of the application's startup state, and will return either <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> to invoke an <em class="italic">UP</em> or <em class="italic">DOWN</em> status, respectively.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor129"/>Retrieving health check data</h2>
			<p>As we <a id="_idIndexMarker599"/>mentioned previously, we can view the data through the <strong class="source-inline">/health</strong>, <strong class="source-inline">/health/liveness</strong>, <strong class="source-inline">/health/readiness</strong>, and <strong class="source-inline">/health/started</strong> endpoints. Due to this, these health checks can be consumed by requests over HTTP/REST. Through an HTTP/REST call, the health check procedures are presented in JSON format. The root level contains the overall health status with a <strong class="source-inline">status</strong> field, and it is calculated from the conjunction of all health check procedures defined in the <strong class="source-inline">checks</strong> JSON list. </p>
			<p>The overall status dictates the HTTP response code. An <em class="italic">UP</em> status returns HTTP 200, while a <em class="italic">DOWN</em> status returns HTTP 500. Any failures or errors that are encountered by the health check procedure will result in an HTTP 503 return code, which equates to a <em class="italic">DOWN</em> status. Remember that if any health check reports are down, then the overall status is <em class="italic">DOWN</em>. Each health check JSON object in the list displays the contents of <strong class="source-inline">HealthCheckReponse</strong> (that is, its name, status, and optional key-value map). If there a no health check procedures, then an automatic <em class="italic">UP</em> (that is, HTTP 200) is returned. The formatting structure and behaviors listed previously apply to all four endpoints. The use of response codes is important as this may be the method in which the external observer is determining the health of your application (that is, the cloud platform).</p>
			<p>The following example output can be applied to any of the four health endpoints, so we will not define <a id="_idIndexMarker600"/>which endpoint it is from:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "status": "DOWN",</p>
			<p class="source-code">  "checks": [</p>
			<p class="source-code">    {</p>
			<p class="source-code">      "name": "goodCheck",</p>
			<p class="source-code">      "status": "UP"</p>
			<p class="source-code">    },</p>
			<p class="source-code">    {</p>
			<p class="source-code">      "name": "questionableCheck",</p>
			<p class="source-code">      "status": "DOWN",</p>
			<p class="source-code">      "data": {</p>
			<p class="source-code">        "application": "backend",</p>
			<p class="source-code">        "locale": "en"</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  ]</p>
			<p class="source-code">}</p>
			<p>The output reports that we have a health check procedure named <strong class="source-inline">"goodCheck"</strong> that reports <em class="italic">UP</em>. We also have a procedure named <strong class="source-inline">"questionableCheck"</strong> that is reporting <em class="italic">DOWN</em>. This causes the overall status to report <em class="italic">DOWN</em> and will result in an HTTP 500 error being returned. As shown in the output, the <strong class="source-inline">"questionableCheck"</strong> procedure has incorporated the additional contextual map data; that is, <strong class="source-inline">"application": "backend"</strong> and <strong class="source-inline">"locale": "en"</strong>.</p>
			<p class="callout-heading">Special Note About Default Readiness and Startup Procedures</p>
			<p class="callout">The MicroProfile Health runtime provides a configuration value (through MicroProfile Config) called <strong class="source-inline">mp.health.default.readiness.empty.response</strong>. Its value can be either <em class="italic">UP</em> or <em class="italic">DOWN</em>. The default value is <em class="italic">DOWN</em>. This value is used to report the readiness of your microservice if the application is still starting up and the readiness procedures cannot be called yet. This is not applicable if no readiness health check procedures have been defined in the application code. If that is the case, then the default behavior for no health check procedures is to return an HTTP 200 response with an <em class="italic">UP</em> status on the <strong class="source-inline">/health/readiness</strong> endpoint.</p>
			<p class="callout">There is also a <a id="_idIndexMarker601"/>configuration value that exists for the startup health check called <strong class="source-inline">mp.health.default.startup.empty.response</strong>. If there are no startup health checks at all, then the default <em class="italic">UP</em> status is returned on the <strong class="source-inline">/health/started</strong> endpoint.</p>
			<p class="callout">Liveness checks, on the other hand, do not have configurable values. They follow the simple rule of returning an HTTP 200 response with an <em class="italic">UP</em> status if the application is still starting, and the liveness checks are not ready to be invoked yet. </p>
			<h3>Other connections and payload formats</h3>
			<p>Depending<a id="_idIndexMarker602"/> on<a id="_idIndexMarker603"/> the runtime you chose, it may be the case that the results of the health check procedures can be obtained through additional means (for example, TCP or JMX). We're using the word <em class="italic">additional</em> here because, at the very minimum, a MicroProfile Health runtime must support an HTTP/REST request. However, as a cloud-native technology, MicroProfile Health understands that other strategies for obtaining the data may be preferred. The MicroProfile Health specification defines a set of protocols and wire format rules for how the data can be consumed and presented. Health check data should be presented in JSON format whenever possible. But failing that, the same payload of data must be made available. </p>
			<p>This book will not discuss the intricacies of the protocol and the wire format semantics defined in the MicroProfile Health specification. You can review the MicroProfile Health specification for such information at <a href="https://bit.ly/3ecI6Gz">https://bit.ly/3ecI6Gz</a>.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor130"/>MicroProfile health checks with Kubernetes' liveness, readiness, and startup probes</h2>
			<p>We <a id="_idIndexMarker604"/>will<a id="_idIndexMarker605"/> now<a id="_idIndexMarker606"/> look<a id="_idIndexMarker607"/> at<a id="_idIndexMarker608"/> how the health<a id="_idIndexMarker609"/> check data that's reported by health check procedures can be consumed in a real-life scenario. To do this, we will be using Kubernetes. As this is one of the more well-known cloud container orchestration platforms, this will serve as an excellent vehicle of demonstration. We will be using Kubernetes terminology and will try our best to describe these terms in this section. We will explore Kubernetes and the cloud infrastructure in more depth in <a href="B17377_07_Final_SB_epub.xhtml#_idTextAnchor146"><em class="italic">Chapter 7</em></a>, <em class="italic">MicroProfile Ecosystem with Docker, Kubernetes, and Istio</em>.</p>
			<p>In a cloud environment, the containers you deploy exist on an interconnected web of physical or virtual machines. Kubernetes serves to seamlessly manage and integrate your container deployments that reside in Kubernetes' <strong class="bold">Pods</strong>. Pods can contain one or more containers. To get a pulse on the activity of the Pods in this network (that is, your cloud), a <strong class="bold">kubelet</strong> is present on each machine. This acts as a node agent that manages the Pods on the machine and communicates with the central Kubernetes management facilities. As part of its duties, it can determine when the containers within these Pods are stale or broken, and it has the power to stop and restart them if the need arises. Kubelets are also given the task of evaluating when a container is ready to receive traffic or not. And, most fundamentally, they can check if the container has completed initializing. They accomplish these tasks by checking the liveness, readiness, and startup statuses of the containers within the Pods using liveness, readiness, and startup probes.</p>
			<p>This behavior is container-specific in that it must be enabled on a per-container basis. This is achieved when configuring the container in the Pod's configuration YAML file. The following example uses a snippet from the <strong class="source-inline">broker.yaml</strong> file, which configures the Broker microservice from the StockTrader application that we introduced in <a href="B17377_03_Final_SB_epub.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>, <em class="italic">Introducing the IBM Stock Trader Cloud-Native Application</em>, and will look at again in <a href="B17377_08_Final_SB_epub.xhtml#_idTextAnchor159"><em class="italic">Chapter 8</em></a>, <em class="italic">Step-by-Step Stock Trader Development</em>. The YAML file contains a Kubernetes <strong class="source-inline">Deployment</strong> definition, which provides the configuration needed to deploy the container(s) onto a Pod, including the container image to use, environment variables, and, of course, the liveness, readiness, and startup probes, which can be configured for each container that is defined. We've omitted the other parts of the file to only show the configuration of the liveness, readiness, and startup probes.</p>
			<p>The<a id="_idIndexMarker610"/> full<a id="_idIndexMarker611"/> source <a id="_idIndexMarker612"/>code <a id="_idIndexMarker613"/>for <strong class="source-inline">broker.yaml</strong> can <a id="_idIndexMarker614"/>be<a id="_idIndexMarker615"/> found at <a href="https://bit.ly/3sEvHAa">https://bit.ly/3sEvHAa</a>:</p>
			<p class="source-code">apiVersion: apps/v1</p>
			<p class="source-code">kind: Deployment</p>
			<p class="source-code">[...]</p>
			<p class="source-code">spec:</p>
			<p class="source-code">  [...]</p>
			<p class="source-code">  readinessProbe:</p>
			<p class="source-code">    httpGet:</p>
			<p class="source-code">      path: /health/ready</p>
			<p class="source-code">      port: 9080</p>
			<p class="source-code">    initialDelaySeconds: 60</p>
			<p class="source-code">    periodSeconds: 15</p>
			<p class="source-code">    failureThreshold: 2</p>
			<p class="source-code">  livenessProbe:</p>
			<p class="source-code">    httpGet:</p>
			<p class="source-code">      path: /health/live</p>
			<p class="source-code">      port: 9080</p>
			<p class="source-code">    periodSeconds: 15</p>
			<p class="source-code">    failureThreshold: 3</p>
			<p class="source-code">  startupProbe:</p>
			<p class="source-code">    httpGet:</p>
			<p class="source-code">      path: /health/started</p>
			<p class="source-code">      port: 9080</p>
			<p class="source-code">    periodSeconds: 30</p>
			<p class="source-code">    failureThreshold: 4</p>
			<p class="source-code">[...]</p>
			<p>The liveness, readiness, and startup endpoints are defined in the <strong class="source-inline">livenessProbe</strong>, <strong class="source-inline">readinessProbe</strong>, and <strong class="source-inline">startupProbe</strong> sections, respectively. The probes are configured to use HTTP/S with <strong class="source-inline">httpGet</strong>. In our example, we will be using <a id="_idIndexMarker616"/>an <a id="_idIndexMarker617"/>unsecured HTTP endpoint. You<a id="_idIndexMarker618"/> will need to <a id="_idIndexMarker619"/>add<a id="_idIndexMarker620"/> a<a id="_idIndexMarker621"/> new field under <strong class="source-inline">httpGet</strong> named <strong class="source-inline">scheme</strong> and set the value to <strong class="source-inline">HTTPS</strong> if you want a secure connection. We specify <strong class="source-inline">/health/live</strong>, <strong class="source-inline">/health/ready</strong>, and <strong class="source-inline">/health/started</strong> with the <strong class="source-inline">path</strong> field and the port to reach it on with <strong class="source-inline">port</strong>. An initial delay of 60 seconds is configured with the <strong class="source-inline">initialDelaySeconds</strong> field for the readiness probe. This prevents the readiness probe from firing until this time has elapsed, to allow the container and its application to start up. When the probes are firing, requests will be sent every 15 seconds for the readiness and liveness probes and 30 seconds for the startup probe, as configured through <strong class="source-inline">periodSeconds</strong>. However, what's not defined in this example is the <strong class="source-inline">timeoutSeconds</strong> field. By default, the value is 1 second and it defines the period in which the kubelet should wait before it times out. <strong class="source-inline">failureThreshold</strong> defines how many times the probes will retry before it is considered a failure. </p>
			<p>You may notice that the liveness probe does not specify the <strong class="source-inline">initialDelaySeconds</strong> field. You can do so, but this is unnecessary as we are using <strong class="source-inline">startUpProbe</strong>. Remember that (if defined) the startup probe will be queried first until it provides the <em class="italic">UP</em> status, and then the liveness probe will be checked. This is the behavior that Kubernetes provides.</p>
			<p>If any of the probes fail completely, as in all attempts have transpired, then the container is subject to being restarted.</p>
			<p>It should be of no surprise now that the MicroProfile Health technology had the Kubernetes platform in mind with its availability of liveness, readiness, and startup endpoints, all of which match the specific Kubernetes liveness, readiness, and startup probes. However, the existence of the simple <strong class="source-inline">/health</strong> endpoint allows it to be used by other platforms that only care about a single health endpoint. But remember that when using the <strong class="source-inline">/health</strong> endpoint, the concept of liveness, readiness, and startup maybe no longer be applicable. On top of that, MicroProfile Health's straightforward protocol and wire format rules allow its health check data to be easily consumed by any external observer, sentient or not.</p>
			<p>We've now come to the end of the MicroProfile Health section. As we mentioned earlier, in the introduction to MicroProfile Health, this technology serves to satisfy a broad <a id="_idIndexMarker622"/>monitoring scope. In the next<a id="_idIndexMarker623"/> section, we'll start <a id="_idIndexMarker624"/>to<a id="_idIndexMarker625"/> cover a more detailed <a id="_idIndexMarker626"/>monitoring<a id="_idIndexMarker627"/> scope with MicroProfile Metrics.</p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor131"/>Instrumenting metrics on your cloud-native application using MicroProfile Metrics</h1>
			<p>This<a id="_idIndexMarker628"/> is <a id="_idIndexMarker629"/>the<a id="_idIndexMarker630"/> second part of our MicroProfile observability trilogy, where we find ourselves in the thick of things with MicroProfile Metrics. The previous technology we discussed – MicroProfile Health – strived to report on the overall health of your cloud-native application by allowing you, the developer, to strategically place health checks throughout your application. MicroProfile Metrics, on the other hand, strives to report on the performance and inner workings of the application and its environment using metrics instrumented in the application by you, as well as metrics provided by the MicroProfile Metrics runtime. This provides real-time statistics that can be recorded and/or aggregated to be analyzed with specialized monitoring tools. To accomplish this, the MicroProfile Metrics technology comes well-equipped with seven types <a id="_idIndexMarker631"/>of <a id="_idIndexMarker632"/>metrics <a id="_idIndexMarker633"/>that range in complexity and functionality. As we progress through this section of this chapter, we will come to know them very well.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor132"/>The importance of MicroProfile Metrics in a cloud-native application</h2>
			<p>Being <a id="_idIndexMarker634"/>able<a id="_idIndexMarker635"/> to monitor the statistics and performance data of specific components throughout your application is not a cloud-native, development-specific idea. This should be a healthy practice, regardless of whether your endeavors are on the cloud. However, being able to monitor your microservices is critical when we're talking about a topology of highly scalable and diverse applications. Even if you don't command a sprawl of applications, but rather a few applications, the benefits of gathering metrics are indisputably invaluable. This is a way for your microservice to talk to you and tell you how it's feeling. This provides you with the opportunity to identify any patterns of concern before your application's liveness health checks unexpectedly decrees that it is <em class="italic">DOWN</em>. For example, in the previous section, we demonstrated a scenario where the liveness health check procedure was dependent on how much memory was being used. After it surpassed a certain threshold, it would fail and report <em class="italic">DOWN</em>. By just using MicroProfile Health, we wouldn't know anything was wrong until it was too late and by then, your cloud platform would have already restarted the container. And perhaps you may be blissfully unaware that anything has happened at all.</p>
			<p>Having MicroProfile Metrics report on such statistics allows you to anticipate such disasters ahead of time and to understand the performance of your application. As another example, we can have metrics reporting on the number of requests that have been made to the REST endpoints in your microservice and how long it took, on average, for the requests to be fulfilled. This metric information can shed light on how popular your microservice is and how well – or how poorly – your microservice is performing. This can then prompt the necessary steps for revising and modifying the deployment environment or even the application itself. </p>
			<p>However, MicroProfile Metrics can only report on the instantaneous value of the metrics. To properly harness this stream of information, we need to aggregate the metric data over time <a id="_idIndexMarker636"/>and, in effect, transform it into a <strong class="bold">time series metric</strong>. Neither MicroProfile Metrics itself, nor any other MicroProfile technology, serves to accomplish this task. MicroProfile Metrics is only here to provide a seamless and effective way of instrumenting metrics into your microservices. There is already an established ecosystem of tools and platforms that specializes in aggregating metrics and visualizing them. A popular <a id="_idIndexMarker637"/>monitoring<a id="_idIndexMarker638"/> stack to use is one that utilizes <strong class="bold">Prometheus</strong> and <strong class="bold">Grafana</strong>.</p>
			<p>Prometheus is an open source monitoring solution for gathering, storing, and querying time series metrics. Prometheus is often combined with the use of another tool, called Grafana. Grafana is another open source monitoring solution that serves to display and visualize time series metrics through graphs, tables, and other types of visualizations by using customized <a id="_idIndexMarker639"/>queries that <a id="_idIndexMarker640"/>have been made to the time series database (for example, Prometheus). This can provide you or your operations team with the ability to monitor the performance of your microservices through meaningful visualizations in a human-friendly way.</p>
			<p>At the end of this section, we will demonstrate how to use Grafana to visualize the metric data that's been gathered by the MicroProfile Metrics runtime. Being able to strategically instrument metrics to provide meaningful information is half the battle; effectively using that information is how the battle is won.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor133"/>MicroProfile Metrics technology overview</h2>
			<p>You may<a id="_idIndexMarker641"/> have noticed that, in the introduction to this section, we mentioned that metrics can come from the application or the runtime itself. Just like MicroProfile Health, where default health checks may be provided, the MicroProfile Metrics runtime can provide default out-of-the-box metrics as well. The runtime must provide, for the most part, a certain set of metrics on top of any optional metrics that it wishes to provide. These metrics are referred to as <strong class="bold">base metrics</strong> and <strong class="bold">vendor metrics</strong>, respectively. However, not all base metrics are strictly required, and we will explain this shortly. The metrics that are instrumented in the application by the developer are referred to as <strong class="bold">application metrics</strong>. All these different sets of metrics live separately, agnostic of each other, under different <strong class="bold">metric registries</strong>. The metric registry is the control center and the heart of the MicroProfile Metrics technology. The metric registry is where metrics are registered, stored, retrieved, and deleted. This logical grouping of the different types of metrics into their own unique metric registries simplifies handling different scopes of metrics and, most importantly, avoids any metric name collisions that could occur if they resided together in one single metric registry. </p>
			<p>To retrieve the metric data, the MicroProfile Metrics runtime provides four HTTP/REST endpoints. The first one is a general <strong class="source-inline">http://host:port/metrics</strong> endpoint, which displays all the metrics from all the scopes and registries. Metrics are prefixed with the name of their respective metric registries to avoid confusion. The other three endpoints are sub-resources of the <strong class="source-inline">http://host:port/metrics</strong> endpoint, and they report on the metrics in each specific registry. They are the <strong class="source-inline">http://host:port/metrics/base</strong>, <strong class="source-inline">http://host:port/metrics/vendor</strong>, and <strong class="source-inline">http://host:hort/metrics/application</strong> HTTP/REST endpoints. Metrics can be reported in either JSON or Prometheus exposition format. We will cover these two formats in detail later. Moving forward, when referring to the metrics<a id="_idIndexMarker642"/> endpoints, we will omit <strong class="source-inline">http://host:port</strong> for brevity.</p>
			<p>In summary, the following diagram illustrates the general flow of the metric life cycle. First, metrics are instrumented into your microservice (or provided by the runtime!). These metrics are reported on the <strong class="source-inline">/metrics</strong> endpoint. Some monitoring tool or platform (for example, Prometheus) is then used to retrieve the metric data and store it, thus transforming it into time series metrics. Another monitoring tool or platform (for example, Grafana) is then used to visualize that data:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B17377_06_01.jpg" alt="Figure 6.1 – Life cycle of a metric&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Life cycle of a metric</p>
			<p>We will now describe the three different metric scopes in more detail; that is, <strong class="bold">base metrics</strong>, <strong class="bold">vendor metrics</strong>, and <strong class="bold">application metrics</strong>.</p>
			<h3>Base metrics</h3>
			<p>Base <a id="_idIndexMarker643"/>metrics are a set of metrics that must be<a id="_idIndexMarker644"/> provided by all MicroProfile Metrics runtimes. There are, however, a few exceptions, where the metrics can be optionally implemented instead. This slight variability is due to what base metrics were meant to achieve. The list of base metrics was created in the hopes of capturing and reporting metrics that each runtime would have. Having base metrics defined and implemented by the runtime relieves the developer from the burden of having to instrument their own metrics to capture basic and/or common statistics. By providing these base metrics, they would always be available, regardless of whether they are needed.</p>
			<p>The obvious target for base metrics would be to encompass the <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>) statistics. Base<a id="_idIndexMarker645"/> metrics cover a long list of metrics that target memory statistics, garbage collection statistics, thread usage, thread pool statistics, class loading statistics, as well as operating system statistics. However, not every JVM is made equal, and a few of these metrics are optional as the JVM under the hood may not hold such statistics. Base metrics also include optional REST metrics that track the request count, unmapped exceptions count, and time spent on each REST/JAX-RS endpoint. We encourage you to review the list of base metrics and their definitions<a id="_idIndexMarker646"/> by looking at the MicroProfile Metrics specification at <a href="https://bit.ly/3mXpL42">https://bit.ly/3mXpL42</a>.</p>
			<p>The MicroProfile Metrics specification only defines the aforementioned JVM and REST metrics explicitly as base metrics, but the metrics generated by MicroProfile Fault Tolerance are classified as base metrics as well. We covered the MicroProfile Fault Tolerance metrics in the <em class="italic">Fault Tolerance metrics</em> section of the previous chapter. </p>
			<h3>Vendor metrics</h3>
			<p>Vendor<a id="_idIndexMarker647"/> metrics are metrics that are provided<a id="_idIndexMarker648"/> by the vendor for their implementation of MicroProfile Metrics. Different implementations of MicroProfile Metrics will contain different sets of vendor metrics. Vendor metrics are completely optional, and it can be the case that your chosen MicroProfile Metrics runtime does not supply any vendor metrics at all. The purpose of vendor metrics is to allow the vendor's implementation to provide any metrics that can enhance the monitoring capabilities of the end user for the specific MicroProfile Metrics runtime. For example, if the runtime you are using is also Jakarta EE compliant, then it may be possible for it to provide metrics related to components under that platform. The vendor <a id="_idIndexMarker649"/>metrics can then be exclusively accessed on the <strong class="source-inline">/metrics/vendor</strong> endpoint <a id="_idIndexMarker650"/>or combined with metrics from other scopes on the <strong class="source-inline">/metrics</strong> endpoint.</p>
			<h3>Application metrics</h3>
			<p>Application <a id="_idIndexMarker651"/>metrics are metrics<a id="_idIndexMarker652"/> that have been instrumented by you, the developer, in your application. These metrics report on statistics that interest you and your team for observing and monitoring the performance of the application. This is the metrics scope that you will be primarily interacting with when instrumenting metrics. The application metrics can then be exclusively accessed on the <strong class="source-inline">/metrics/application</strong> endpoint or combined with metrics from other scopes on the <strong class="source-inline">/metrics</strong> endpoint.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor134"/>The seven metric types</h2>
			<p>Now that we <a id="_idIndexMarker653"/>understand the different scopes of the available metrics, we can list the seven types of application metrics:</p>
			<ul>
				<li>Counter</li>
				<li>Gauge</li>
				<li>Concurrent Gauge</li>
				<li>Histogram</li>
				<li>Meter</li>
				<li>Timer</li>
				<li>Simple Timer</li>
			</ul>
			<p>Given the names, it's easy to deduce what the different types of metrics serve to achieve. If not, don't worry – we'll cover these metrics in detail when we cover how to instrument the different metrics later, in the <em class="italic">Instrumenting metrics</em> section.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor135"/>The metric model</h2>
			<p>Now that <a id="_idIndexMarker654"/>we know what type of metrics there are, and under what scopes they may live, it's time for us to understand the underlying metric model. This may sound like a dull topic, and you may be tempted to skip this, but understanding this is crucial if you wish to know how to instrument and handle metrics effectively. </p>
			<p>A metric, besides being one of the seven metric types, consists of a name, a set of optional key-value <strong class="bold">tags</strong>, and its <strong class="bold">metadata</strong>. These three items are used by the metric registry to identify and validate the uniqueness of any given metric. These identifying pieces of information are also made available to any observer on the <strong class="source-inline">/metrics/*</strong> endpoints.</p>
			<p>The purpose of the name is rather obvious: it is to uniquely identify the metric from others. However, that may not be sufficient in some cases because different metrics can share the same name. This is<a id="_idIndexMarker655"/> because MicroProfile Metrics supports <strong class="bold">multi-dimensional metrics</strong> with key-value tags.</p>
			<p>The combination of the metric's name and its tags is encapsulated in a <strong class="source-inline">MetricID</strong> object in the metric registry. <strong class="source-inline">MetricID</strong> is the primary identifier of a metric. It is tightly coupled with the metric instance itself in the metric registry. The use of tags for a metric is optional, and it can be the case that the metrics in your application all use distinct metric names with no tags. This results in a <strong class="source-inline">MetricID</strong> with just a name and no tags. However, you may find it useful to leverage the power of multi-dimensional metrics, if the need arises. Such a need may come if you are attempting to record the same type of data (for example, a counter to count something) from multiple similar sources. You can use the same metric name and provide a tag that uniquely identifies it from the other sources. An example of this would be if you are using metrics to count how many times the methods in a specific class are being invoked. You can name the metrics <strong class="source-inline">classMethodInvocations</strong> and provide each method with a tag, where the key is <strong class="source-inline">method</strong> and the value is the name of the method.</p>
			<p>This use of multi-dimensional metrics is best taken advantage of when using one of the available visualization monitoring tools, such as Grafana. You can quickly retrieve and display all metrics with the same name, regardless of what their tags are, in one simple query.</p>
			<p>The last item that is used to identify a metric is its metadata. The metadata consists of the metric's name, its type, the metric's unit of measurement (if applicable), an optional description, and an optional human-readable display name. For each unique metric name, there is only one piece of metadata. As a result, there can be multiple MetricID linked to one piece of metadata. Being able to reuse the metric's name in the metadata helps correlate the MetricIDs and the metadata as they are loosely coupled in the metric registry. The relationships described previously are illustrated in the following diagram. <strong class="bold">*</strong> denotes 0 to <a id="_idIndexMarker656"/>many:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/B17377_06_02.jpg" alt="Figure 6.2 – Metric registry metric model&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – Metric registry metric model</p>
			<p>Retrieving metric data</p>
			<p>Before we<a id="_idIndexMarker657"/> continue with the topic of instrumenting metrics, we will cover how metrics are made available. In the <em class="italic">Instrumenting metrics</em> section, we will be covering each metric individually and providing examples of its output, specifically its Prometheus output. Therefore, first, we must understand what we will be looking at.</p>
			<p>As we mentioned previously, metrics are available through HTTP/REST requests to either the <strong class="source-inline">/metrics</strong>, <strong class="source-inline">/metrics/base</strong>, <strong class="source-inline">/metrics/vendor</strong>, or <strong class="source-inline">/metrics/application</strong> endpoint in either JSON or Prometheus exposition format. The metric output for a specific metric name can be retrieved by sending a request to <strong class="source-inline">/metrics/&lt;scope&gt;/&lt;metric_name&gt;</strong>.</p>
			<h3>JSON format</h3>
			<p>The <a id="_idIndexMarker658"/>output<a id="_idIndexMarker659"/> of the metrics in JSON format comes in two parts. We can obtain the metric and its data by invoking a <strong class="source-inline">GET</strong> request with the <strong class="source-inline">Accept</strong> header by specifying <strong class="source-inline">application/json</strong>. If we issue an <strong class="source-inline">OPTION</strong> request instead, we will be able to retrieve the metadata associated with the metrics. </p>
			<p>Let's look at what sending a <strong class="source-inline">GET</strong> request to <strong class="source-inline">/metrics</strong> will return. Notice that the metrics from the different scopes are in their own JSON array lists. We will only show the base metrics and hide any vendor or application metrics in the sample output. We will also look at an example of multi-dimensional metrics by using the first two metrics listed in the base <a id="_idIndexMarker660"/>scope. There <a id="_idIndexMarker661"/>are two <strong class="source-inline">gc.total</strong> metrics whose key-value pairs are <strong class="source-inline">"name=scavenge"</strong> and <strong class="source-inline">"name=global"</strong>:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "base": {</p>
			<p class="source-code">    "gc.total;name=scavenge": 361,</p>
			<p class="source-code">    "gc.total;name=global": 9,</p>
			<p class="source-code">    "classloader.loadedClasses.count": 9448,</p>
			<p class="source-code">    "gc.time;name=global": 33,</p>
			<p class="source-code">    "gc.time;name=scavenge": 368,</p>
			<p class="source-code">    "cpu.systemLoadAverage": -1,</p>
			<p class="source-code">    "thread.count": 73,</p>
			<p class="source-code">    "classloader.unloadedClasses.total": 0,</p>
			<p class="source-code">    "jvm.uptime": 52938,</p>
			<p class="source-code">    "cpu.processCpuTime": 23359375000,</p>
			<p class="source-code">    "memory.committedHeap": 53805056,</p>
			<p class="source-code">    "thread.max.count": 89,</p>
			<p class="source-code">    "cpu.availableProcessors": 12,</p>
			<p class="source-code">    "classloader.loadedClasses.total": 9448,</p>
			<p class="source-code">    "thread.daemon.count": 69,</p>
			<p class="source-code">    "memory.maxHeap": 536870912,</p>
			<p class="source-code">    "cpu.processCpuLoad": 0.0023284173808607016,</p>
			<p class="source-code">    "memory.usedHeap": 41412992</p>
			<p class="source-code">  },</p>
			<p class="source-code">  "vendor": {</p>
			<p class="source-code">    [..]</p>
			<p class="source-code">  },</p>
			<p class="source-code">  "application": {</p>
			<p class="source-code">    [..]</p>
			<p class="source-code">  },</p>
			<p class="source-code">}</p>
			<p>To find out <a id="_idIndexMarker662"/>what<a id="_idIndexMarker663"/> the <strong class="source-inline">gc.total</strong> metric was meant for, we can obtain the metadata of the metrics by sending an <strong class="source-inline">OPTIONS</strong> request to <strong class="source-inline">/metrics</strong>. Since the output of this request will be lengthy, we will only show the <strong class="source-inline">gc.total</strong> metric and obfuscate the rest. Like the <strong class="source-inline">GET</strong> request, the metrics from each scope/registry are separated into their own JSON arrays:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "base": {</p>
			<p class="source-code">    "gc.total": {</p>
			<p class="source-code">      "unit": "none",</p>
			<p class="source-code">      "displayName": "Garbage Collection Count",</p>
			<p class="source-code">      "name": "gc.total",</p>
			<p class="source-code">      "description": "Displays the total number of        collections that have occurred. This attribute lists         -1 if the collection count is undefined for this </p>
			<p class="source-code">        collector.",</p>
			<p class="source-code">      "type": "counter",</p>
			<p class="source-code">      "tags": [</p>
			<p class="source-code">        [</p>
			<p class="source-code">          "name=global"</p>
			<p class="source-code">        ],</p>
			<p class="source-code">        [</p>
			<p class="source-code">          "name=scavenge"</p>
			<p class="source-code">        ]</p>
			<p class="source-code">      ]</p>
			<p class="source-code">    },</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">  },</p>
			<p class="source-code">  "vendor": {</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">  },</p>
			<p class="source-code">  "application": {</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>As we can <a id="_idIndexMarker664"/>see from<a id="_idIndexMarker665"/> the metadata, the <strong class="source-inline">gc.total</strong> metric is a counter that'sused to count the number of garbage collections that have occurred in this JVM. The tags are used to identify two different garbage collectors on the system that the two metrics monitor.</p>
			<p>A request was made to <strong class="source-inline">/metrics</strong> to demonstrate how the metrics are partitioned from different scopes. We could have also invoked <strong class="source-inline">/metrics/base/gc.total </strong>to specifically retrieve the metadata of the <strong class="source-inline">gc.total</strong> metric.</p>
			<h3>Prometheus exposition format</h3>
			<p>With <a id="_idIndexMarker666"/>the<a id="_idIndexMarker667"/> Prometheus exposition format, all metric data is provided together with a <strong class="source-inline">GET</strong> request to the <strong class="source-inline">/metrics/*</strong> endpoints. If <strong class="source-inline">application/json</strong> is not specified, the Prometheus format will be returned by default. As its name suggests, this format to be used directly by the Prometheus monitoring tool. </p>
			<p>A specific template must be followed for formatting the metrics. To describe this, we'll only take a look at the output from the <strong class="source-inline">gc.total</strong> metrics. We're only using a snippet here as the full output would be too lengthy:</p>
			<p class="source-code"># TYPE base_gc_total counter</p>
			<p class="source-code"># HELP base_gc_total Displays the total number of collections that have occurred. This attribute lists -1 if the collection count is undefined for this collector.</p>
			<p class="source-code">base_gc_total{name="global"} 9</p>
			<p class="source-code">base_gc_total{name="scavenge"} 372</p>
			<p class="source-code">[...]</p>
			<p>In Prometheus <a id="_idIndexMarker668"/>exposition format, metrics are <a id="_idIndexMarker669"/>organized by their metric name. The first grouping is for the <strong class="source-inline">base_gc_total</strong> metric. This corresponds to the <strong class="source-inline">gc.total</strong> metric we saw in the aforementioned JSON format examples. The true metric name is <strong class="source-inline">gc.total</strong>, but it must be transformed into <strong class="source-inline">gc_total</strong> as Prometheus formatted metrics are alphanumeric characters with underscores (<strong class="source-inline">_</strong>). The MicroProfile Metrics runtime also prepends the name of the registry scope that the metric belongs to. This is either <strong class="source-inline">base_</strong>, <strong class="source-inline">vendor_</strong>, or <strong class="source-inline">application_</strong>. Notice that the tags are appended to the end of the metric's name, within squiggly brackets.</p>
			<p>Each unique grouping of metrics by metric name is preceded by a <strong class="source-inline"># TYPE</strong> line and a <strong class="source-inline"># HELP</strong> line. These two lines define the metric's type and a description, if available. Remember that the description is an optional field in the metric's metadata. </p>
			<p>There are additional formatting rules for certain metrics. We will cover this in the next section.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor136"/>Instrumenting metrics</h2>
			<p>The <a id="_idIndexMarker670"/>MicroProfile Metrics technology provides a rich Java API for programmatically instrumenting metrics, as well as providing CDI annotations for easily instrumenting metrics for methods, fields, and even entire classes. We will not cover all the possible scenarios of using the Java API and its annotations, particularly regarding the usage of the <strong class="source-inline">MetricRegistry</strong> class. Instead, this section will explain the main uses of the API and its annotations to allow you to understand how to use the technology with confidence. We encourage you to review the Java documentation for MicroProfile Metrics if you wish to completely master everything.</p>
			<p>In this section, we'll cover how to instrument each metric programmatically and with annotations. This will be followed by an example of the output of the <strong class="source-inline">/metrics</strong> endpoint in Prometheus exposition format. Preceding that, we will cover the technical aspects of the metric registry, metadata, tags, and <strong class="source-inline">MetricID</strong>. They provide the fundamental knowledge needed to effectively instrument metrics.</p>
			<p>As you may <a id="_idIndexMarker671"/>recall from the <em class="italic">MicroProfile Metrics technology overview</em> section, the metric registry is the nexus of operation for the MicroProfile Metrics runtime. Unless you are strictly using annotations to instrument metrics in your microservice, you will need to obtain a <strong class="source-inline">MetricRegistry</strong> (CDI) bean. It is through this <strong class="source-inline">MetricRegistry</strong> that we can create, register, and retrieve metrics programmatically. Even if you are strictly using annotations to instrument metrics, you will be interacting with <strong class="source-inline">MetricRegistry</strong> under the covers.</p>
			<p>This section contains a large amount of content. The following is a summary of what we will be covering:</p>
			<ul>
				<li>Obtaining a metric registry</li>
				<li>Creating, registering, and retrieving metrics:<p>a) Metatadata, tags, and MetricIDs</p><p>b) Counter</p><p>c) Concurrent gauge</p><p>d) Meter</p><p>e) Timer and simple timer</p><p>f) Gauge</p></li>
				<li>The <strong class="source-inline">@Metric</strong> annotation</li>
			</ul>
			<p>Let's get started!</p>
			<h3>Obtaining a metric registry</h3>
			<p>To <a id="_idIndexMarker672"/>obtain <strong class="source-inline">MetricRegistry</strong>, we can use injection, as demonstrated in the following code sample:</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    MetricRegistry metricRegistry;</p>
			<p>Remember that there are three types of metric registry scopes: the base metric registry, the vendor metric registry, and the application metric registry. By default, when you inject a <strong class="source-inline">MetricRegistry</strong> into your application, the MicroProfile Metrics runtime will provide an application registry. You can inject the other types of registries if you wish. You will need to annotate your injection with a <strong class="source-inline">@RegistryType</strong> and with an annotation parameter specifying the type of registry to inject. The following example illustrates the usage of <strong class="source-inline">@RegistryType</strong>, where we specify the type as <strong class="source-inline">MetricRegistry.Type.Application</strong>:</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    @RegistryType(type=MetricRegistry.Type.APPLICATION)</p>
			<p class="source-code">    MetricRegistry metricRegistry;</p>
			<p>You can inject a base metric registry and a vendor metric registry if you specify a <strong class="source-inline">@RegistryType(type=MetricRegistry.Type.BASE)</strong> or  <strong class="source-inline">@RegistryType(type=MetricRegistry.Type.VENDOR)</strong> annotation, respectively. However, in your application, you should NOT be registering metrics or manipulating the base or vendor metrics. These two metric registries should only be used to retrieve the metrics so that you can view their data. </p>
			<p class="callout-heading">Note About <strong class="source-inline">MetricRegistry</strong> and Annotation Usage</p>
			<p class="callout">When using annotations to instrument metrics, you will only be interacting with the application metric registry. You will not be able to choose which <strong class="source-inline">MetricRegistry</strong> the metric<a id="_idIndexMarker673"/> annotations apply to.</p>
			<h3>Creating, registering, and retrieving metrics </h3>
			<p>Using <strong class="source-inline">MetricRegistry</strong>, you<a id="_idIndexMarker674"/> can<a id="_idIndexMarker675"/> create<a id="_idIndexMarker676"/> and register metrics using specific methods for each metric type. Each metric type, except for Gauge, will have the following method signatures. Invoking such methods from <strong class="source-inline">MetricRegistry</strong> will create, register, and return an instance of that metric if a metric with the given name, metadata, and tags does not already exist in the registry. If one does exist, then that existing metric is returned. It should be noted that using metric annotations, except for the gauge annotation, works similarly. We will demonstrate the method's signature pattern with the <strong class="source-inline">Counter</strong> metric type:</p>
			<p class="source-code">Counter counter(String name);</p>
			<p class="source-code">    </p>
			<p class="source-code">Counter counter (String name, Tag... tags);</p>
			<p class="source-code">    </p>
			<p class="source-code">Counter counter (MetricID metricID);</p>
			<p class="source-code">   </p>
			<p class="source-code">Counter counter (Metadata metadata);</p>
			<p class="source-code">    </p>
			<p class="source-code">Counter counter (Metadata metadata, Tag... tags);</p>
			<p>The method names for the other metric types are <strong class="source-inline">concurrentGauge</strong>, <strong class="source-inline">timer</strong>, <strong class="source-inline">simpleTimer</strong>, <strong class="source-inline">histogram</strong>, and <strong class="source-inline">meter</strong>. We will demonstrate the various usages of these methods in the metric-specific sections. Gauge also has its own set of methods that <strong class="source-inline">MetricRegistry</strong> provides, but we will cover those in the <em class="italic">Gauge</em> section.</p>
			<p class="callout-heading">Note on Metric Reusability</p>
			<p class="callout">Whether you're using <strong class="source-inline">MetricRegistry</strong> or the metric annotations to instrument your metrics, you can reuse an existing metric by specifying matching metadata or <strong class="source-inline">MetricID</strong> values.</p>
			<p>To only retrieve metrics, you can call one of the <strong class="source-inline">getMetrics()</strong>, <strong class="source-inline">getCounters()</strong>, <strong class="source-inline">getGauges()</strong>, <strong class="source-inline">getConcurrentGauges()</strong>, <strong class="source-inline">getHistograms()</strong>, <strong class="source-inline">getMeters()</strong>, <strong class="source-inline">getTimers()</strong>, or <strong class="source-inline">getSimpleTimers()</strong> methods from <strong class="source-inline">MetricRegistry</strong>. These calls will return a map of the desired metrics, with <strong class="source-inline">MetricID</strong> as the key.</p>
			<p>There are other methods for creating, registering, retrieving, and deleting metrics from the metric registry, some of which use a <strong class="source-inline">MetricFilter</strong>, as well as other methods concerning retrieving metadata and metric IDs. You can even create your own implementation of the metrics and register that over the instances provided by the MicroProfile <a id="_idIndexMarker677"/>Metrics<a id="_idIndexMarker678"/> runtime. However, these<a id="_idIndexMarker679"/> methods will not be covered as there a simply too many! We encourage you to review the Java documentation of the <strong class="source-inline">MetricRegistry</strong> class. The information we've provided so far regarding the use of <strong class="source-inline">MetricRegistry</strong> s is to help you understand the subsequent sections.</p>
			<h3>Metadata, tags, and MetricIDs</h3>
			<p>As you<a id="_idIndexMarker680"/> may <a id="_idIndexMarker681"/>have <a id="_idIndexMarker682"/>noticed in the previous section, metadata, tags, and MetricIDs can and will be used in your application code by the metric registry. However, we must understand how to create and use them before we can learn how to instrument and utilize the different metrics.</p>
			<p>Every metric must contain metadata information. As you may recall, metadata information consists of its name, metric type, unit of measurement, a description, and a display name. The required fields from this set are the name and the metric type. The other metadata fields are optional. All this information is encompassed in a <strong class="source-inline">Metadata</strong> object. Every field in the <strong class="source-inline">Metadata</strong> object is a <strong class="source-inline">String</strong>. For the metric type field, you will need to specify an <strong class="source-inline">enum</strong> value from a <strong class="source-inline">MetricType</strong> <strong class="source-inline">enum</strong>. For the unit field, you will need to specify one of the static fields in <strong class="source-inline">MetricUnits</strong>. </p>
			<p>If you are instrumenting multi-dimensional metrics, then you will also need to provide tags for your metrics. Every tag is a key-value pair of <strong class="source-inline">String</strong> values and is represented by a <strong class="source-inline">Tag</strong> object. The tag's name must match the <strong class="source-inline">[a-zA-Z_][a-zA-Z0-9_]*</strong> regex. The value of the tag can be anything. A metric can contain 0 or more tags. This <strong class="source-inline">Tag</strong> is then set into a <strong class="source-inline">MetricID</strong> that also contains the <strong class="source-inline">String</strong> name of the metric.</p>
			<p class="callout-heading">Note About Configurable Tags</p>
			<p class="callout">Using MicroProfile Config, we can define two config values for setting tag values to all the metrics in the MicroProfile Metrics runtime. <strong class="source-inline">mp.metrics.appName</strong> takes a single string value that is used to identify the application's name. This will be appended to all the metrics as a key-value tag in the form of <strong class="source-inline">_app=&lt;application_name&gt;.</strong> The <strong class="source-inline">mp.metrics.tags</strong> config allows a comma-separated list of key-value tags to be defined<a id="_idIndexMarker683"/> in <a id="_idIndexMarker684"/>the<a id="_idIndexMarker685"/> form of <strong class="source-inline">tag1=value1,tag2=value2</strong>. These tags will then be applied to all metrics.</p>
			<h4>Using metadata and tags programmatically</h4>
			<p>When <a id="_idIndexMarker686"/>instrumenting <a id="_idIndexMarker687"/>metrics programmatically, we need to create a <strong class="source-inline">Metadata</strong> object. To accomplish this, we need to retrieve <strong class="source-inline">MetadataBuilder</strong> by invoking the static <strong class="source-inline">Metadata.builder()</strong> method. Using this <strong class="source-inline">MetadataBuilder</strong>, we can construct a <strong class="source-inline">Metadata</strong> object using a builder pattern. At the very minimum, we will want to specify its name and metric type. In the following example, we won't be registering any metrics, so we will use the <strong class="source-inline">MetricType.INVALID</strong> metric type. When we demonstrate how to instrument each of the individual metrics in the rest of this section, we will use the appropriate <strong class="source-inline">MetricType</strong> there:</p>
			<p class="source-code">  @Inject</p>
			<p class="source-code">  MetricRegistry metricRegistry;</p>
			<p class="source-code">  public void metaDataExample() {</p>
			<p class="source-code">    Metadata metadata = Metadata.builder()</p>
			<p class="source-code">    .withName("testMetadata")</p>
			<p class="source-code">    .withType(MetricType.INVALID)</p>
			<p class="source-code">    .build();</p>
			<p class="source-code">    }</p>
			<p>To create a <strong class="source-inline">Metadata</strong> object with all the fields specified, you can do the following. Once again, as this example is for the sake of demonstration, we will use the <strong class="source-inline">MetricUnits.NONE</strong> value. Since the upcoming sections will not be using the unit field heavily, we encourage you to explore the available unit values available by reviewing the source file at <a href="https://bit.ly/3ds4IDK">https://bit.ly/3ds4IDK</a>. The following example also includes the use of tags and a <strong class="source-inline">MetricID</strong>. Creating a <strong class="source-inline">Tag</strong> is a simple process in that you invoke the <strong class="source-inline">Tag</strong> constructor with the <strong class="source-inline">String</strong> name and value parameters. You can then construct a <strong class="source-inline">MetricID</strong> by<a id="_idIndexMarker688"/> passing the metric name and a variable-length amount of <strong class="source-inline">Tag</strong> parameters<a id="_idIndexMarker689"/> into the <strong class="source-inline">MetricID</strong> constructor.</p>
			<p>The full source code for <strong class="source-inline">MetricsResource</strong> can be found at <a href="https://bit.ly/2UzoczI">https://bit.ly/2UzoczI</a>:</p>
			<p class="source-code">@ApplicationScoped</p>
			<p class="source-code">@Path("/metricsResource")</p>
			<p class="source-code">public class MetricsResource {</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    MetricRegistry metricRegistry;</p>
			<p class="source-code">    public void metadataTagMetricIDExample() {</p>
			<p class="source-code">        String metricName = "myMetric";</p>
			<p class="source-code">        Metadata metadata = Metadata.builder()</p>
			<p class="source-code">        .withName(metricName)</p>
			<p class="source-code">        .withType(MetricType.INVALID)</p>
			<p class="source-code">        .withDisplayName("Human readable display name")</p>
			<p class="source-code">        .withDescription("This metadata example"</p>
			<p class="source-code">                + " demonstrates how to create a"</p>
			<p class="source-code">                + " Metadata object")</p>
			<p class="source-code">        .withUnit(MetricUnits.NONE).build();</p>
			<p class="source-code">        Tag tag = new Tag("tagKey", "tagValue");</p>
			<p class="source-code">        Tag anotherTag = new Tag("anotherTag", "tagValue");</p>
			<p class="source-code">        MetricID metricID = new MetricID(metricName, tag,           anotherTag);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Using a <a id="_idIndexMarker690"/>combination of MetricIDs, tags, and<a id="_idIndexMarker691"/> metadata, you can create, register, and retrieve metrics from <strong class="source-inline">MetricRegistry</strong>. As you may recall from the previous section, which listed the different method signatures, <strong class="source-inline">MetricID</strong> and <strong class="source-inline">Metadata</strong> are never used together as arguments. However, we know that the metric registry uses both to classify and identify the registered metrics. This is because the metric registry will be able to infer the minimum necessary data to construct the other object, whether it be <strong class="source-inline">MetricID</strong> or metadata, during processing.</p>
			<h4>Using metadata and tags with annotations</h4>
			<p>When<a id="_idIndexMarker692"/> instrumenting metrics with annotations, the <a id="_idIndexMarker693"/>metadata and tags are provided through the annotation parameters. It is possible to not have to specify any parameters at all. The MicroProfile Metrics runtime, when using CDI, can infer the necessary information. This type of annotation already provides a metric type and if no name is provided, then a name is generated using the package name, class name, and method name. Alternatively, in a situation where the annotation is used on a constructor, it will be a combination of the package name, class name, and constructor name (that is, the class name again!). </p>
			<p>Even if a name is supplied, the full metric name is a combination of the class name and the metric name. However, this may prove undesirable. To address this, each metric annotation parameter contains an <strong class="source-inline">absolute</strong> parameter, which you can set to <strong class="source-inline">true</strong> so that the metric uses the provided metric name. </p>
			<p>To demonstrate<a id="_idIndexMarker694"/> how to provide the metadata information with annotations, the following <a id="_idIndexMarker695"/>code snippet will use the Counter class' <strong class="source-inline">@Counted</strong> annotation:</p>
			<p class="source-code">@ApplicationScoped</p>
			<p class="source-code">@Path("/metricsResource")</p>
			<p class="source-code">public class MetricsResource {</p>
			<p class="source-code">    @Counted(name="sample.metric", displayName="sample       metric", description="This sample counter metric         illustrates how to instrument a metric annotation",           unit=MetricUnits.NONE, absolute=true, tags=            {"tag1=value1", "tag2=value2")</p>
			<p class="source-code">    public void someMethod() {</p>
			<p class="source-code">        //logic</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As we can see, <strong class="source-inline">name</strong>, <strong class="source-inline">displayName</strong>, and <strong class="source-inline">description</strong> parameters exist that accept <strong class="source-inline">String</strong> values. The <strong class="source-inline">absolute</strong> parameter accepts a <strong class="source-inline">Boolean</strong> value. The unit accepts a static field from <strong class="source-inline">MetricUnits</strong>, and tags are accepted as a list of <strong class="source-inline">String</strong> values in <em class="italic">key-value</em> format.</p>
			<h3>Counter </h3>
			<p>We've finally <a id="_idIndexMarker696"/>arrived at<a id="_idIndexMarker697"/> our first metric: the counter. The counter metric, as its name suggests, is a metric that keeps count of the metrics. The counter can only monotonically increase. You can use this to keep track of how many times a method or block of business logic has been invoked, or the number of times a request was received or sent.</p>
			<h4>Instrumenting counters programmatically </h4>
			<p>The <a id="_idIndexMarker698"/>following <a id="_idIndexMarker699"/>code sample demonstrates how to create and retrieve a counter metric named <strong class="source-inline">counterMetric</strong> using two <strong class="source-inline">GET</strong> requests. In the first <strong class="source-inline">GET</strong> resource, the <strong class="source-inline">/counter1</strong> URI, we create <strong class="source-inline">counterMetric</strong> by invoking <strong class="source-inline">MetricRegistry.counter(Metadata metadata, Tags… tags)</strong>. This will return a new counter metric that we can increment by calling <strong class="source-inline">counter.inc()</strong>, which increments the counter by 1. In the second <strong class="source-inline">GET</strong> resource, the <strong class="source-inline">/counter2</strong> URI, we do something different and call <strong class="source-inline">MetricRegistry.counter(MetricID metricID)</strong>. Here, <strong class="source-inline">MetricID</strong> matches the <strong class="source-inline">MetricID</strong> property that was generated by the metric registry when we first created and registered <strong class="source-inline">counterMetric</strong>. Since it already exists, we are returned the existing <strong class="source-inline">counterMetric</strong> using the metric registry. We then increment it by calling the <strong class="source-inline">inc(long value</strong>) method to increment the counter by a specified amount. In our example, we increment it by 3. In both <strong class="source-inline">GET</strong> resources, we return a string that includes the current count of the counter by invoking <strong class="source-inline">getCount()</strong>.</p>
			<p>The full source code for <strong class="source-inline">CounterResource</strong> can be found at <a href="https://bit.ly/2XGDDXZ">https://bit.ly/2XGDDXZ</a>:</p>
			<p class="source-code">  @GET</p>
			<p class="source-code">  @Path("/counter1")</p>
			<p class="source-code">  public String getCounter1(){</p>
			<p class="source-code">      Metadata counterMetadata = Metadata.builder()</p>
			<p class="source-code">              .withName(COUNTER_METRIC_NAME)</p>
			<p class="source-code">              .withType(MetricType.COUNTER).build();</p>
			<p class="source-code">      </p>
			<p class="source-code">      Counter counter = metricRegistry</p>
			<p class="source-code">              .counter(counterMetadata, COUNTER_TAG);</p>
			<p class="source-code">      counter.inc(); //increments by one</p>
			<p class="source-code">      </p>
			<p class="source-code">      return "A counter metric has been created and         incremented" + "by 1, the total is now " +           counter.getCount();  }</p>
			<p class="source-code"> </p>
			<p class="source-code">  @GET</p>
			<p class="source-code">  @Path("/counter2")</p>
			<p class="source-code">  public String getCounter2(){</p>
			<p class="source-code">      MetricID counterMetricID = new </p>
			<p class="source-code">        MetricID(COUNTER_METRIC_NAME, </p>
			<p class="source-code">              COUNTER_TAG);</p>
			<p class="source-code">      Counter counter =         metricRegistry.counter(counterMetricID);</p>
			<p class="source-code">      </p>
			<p class="source-code">      counter.inc(3);</p>
			<p class="source-code">      return "A counter metric was retrieve and         incremented" + " by 3, the total is now " +           counter.getCount();</p>
			<p class="source-code">  }</p>
			<p>Now, let's<a id="_idIndexMarker700"/> see <a id="_idIndexMarker701"/>what happens when we send requests to both <strong class="source-inline">GET</strong> resources and then view the results through <strong class="source-inline">/metrics/application/counterMetric</strong> directly:</p>
			<p class="source-code">$ curl http://localhost:9080/ch6/counterResource/counter1</p>
			<p class="source-code">A counter metric has been created and incremented by 1, the total is now 1</p>
			<p class="source-code">$ curl http://localhost:9080/ch6/counterResource/counter2</p>
			<p class="source-code">A counter metric was retrieve and incremented by 3, the total  is now 4</p>
			<p class="source-code">$ curl http://localhost:9080/metrics/application/counterMetric</p>
			<p class="source-code"># TYPE application_counterMetric_total counter</p>
			<p class="source-code">application_counterMetric_total{metricType="counter"} 4</p>
			<p>In the <a id="_idIndexMarker702"/>output, we <a id="_idIndexMarker703"/>issue <strong class="source-inline">GET</strong> requests to the <strong class="source-inline">/ch6/counterResource/counter1</strong> and <strong class="source-inline">/ch6/counterResource/counter2</strong> endpoints and the counter metric is incremented by 1 and 3, respectively. We then issue a <strong class="source-inline">GET</strong> request to <strong class="source-inline">/metrics/application/counterMetric</strong> to view the Prometheus formatted output of our counter metric directly. <strong class="source-inline">application_counterMetric_total{metricType="counter"}</strong> is returned, which represents the counter metric with its tag of <strong class="source-inline">metricType="counter"</strong>. It holds a value of 4, as expected.</p>
			<p class="callout-heading">Note About Prometheus Formatting with Counters</p>
			<p class="callout">Counter metrics in Prometheus exposition format will have the <strong class="source-inline">_total</strong> suffix appended to the metric name.</p>
			<h4>Instrumenting counters with annotations</h4>
			<p>Using <a id="_idIndexMarker704"/>annotations <a id="_idIndexMarker705"/>is a much simpler affair. You can annotate the <strong class="source-inline">@Counted</strong> annotation on either a method, constructor, or even a whole class. When the annotated element is invoked, the counter is incremented by 1.</p>
			<p>In our example, we'll annotate the <strong class="source-inline">MetricsResource</strong> class with <strong class="source-inline">@Counted</strong>. When a metric annotation is annotated on a class, it will apply to all applicable targets in the class for that annotation. For <strong class="source-inline">@Counted</strong>, this means that all the constructors and methods will be instrumented. This example will also demonstrate the metric names that are generated. Note that since we are using annotations, we do not need to inject <strong class="source-inline">MetricRegistry</strong>.</p>
			<p>The full <a id="_idIndexMarker706"/>source<a id="_idIndexMarker707"/> code for <strong class="source-inline">CounterAnnotatedResource</strong> can be found at <a href="https://bit.ly/3iZiL6D">https://bit.ly/3iZiL6D</a>:</p>
			<p class="source-code">@ApplicationScoped</p>
			<p class="source-code">@Path("/counterResource")</p>
			<p class="source-code">@Counted</p>
			<p class="source-code">public class CounterAnnotatedResource {</p>
			<p class="source-code">    </p>
			<p class="source-code">  @GET</p>
			<p class="source-code">  @Path("/getResource")</p>
			<p class="source-code">  public String getResource() {</p>
			<p class="source-code">      return "Counting the class";</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Let's take the application for a drive. We'll omit showing the <strong class="source-inline">curl</strong> command to the application's REST endpoint and just show the output of querying <strong class="source-inline">/metrics/application</strong>:</p>
			<p class="source-code">$ curl http://localhost:9080/metrics/application</p>
			<p class="source-code"># TYPE application_metrics_demo_CounterAnnotatedResource</p>
			<p class="source-code">_getResource_total counter</p>
			<p class="source-code">application_metrics_demo_CounterAnnotatedResource_getResource_total 1</p>
			<p class="source-code"># TYPE application_metrics_demo_CounterAnnotatedResource</p>
			<p class="source-code">_CounterAnnotatedResource_total counter</p>
			<p class="source-code">application_metrics_demo_CounterAnnotatedResource_CounterAnnotatedResource_total 1</p>
			<p>After issuing a single <strong class="source-inline">GET</strong> request to <strong class="source-inline">/ch6/counterResource/getResource</strong>, we should see the aforementioned values when viewing the metric data on the <strong class="source-inline">/metrics/application</strong> endpoint. <strong class="source-inline">application_metrics_demo_CounterAnnotatedResource_getResource_total</strong> is the counter metric that was created for the <strong class="source-inline">getResource()</strong> method, while <strong class="source-inline">application_metrics_demo_CounterAnnotatedResource_CounterAnnotatedResource_total</strong> is the counter metric that was created for the constructor<a id="_idIndexMarker708"/> of the class. Both values are <em class="italic">1</em>, as <a id="_idIndexMarker709"/>expected. </p>
			<h3>Concurrent gauge</h3>
			<p>The <a id="_idIndexMarker710"/>concurrent <a id="_idIndexMarker711"/>gauge metric is a metric that's used to count the parallel invocation of the instrumented component. Its values can increase or decrease. This metric can be used to count the number of parallel invocations of a method, business logic, requests, and more. Besides counting parallel invocations, the concurrent gauge metric also keeps track of the highest and lowest count that's been recorded within the previously <strong class="bold">completed full minute</strong>. A completed full minute denotes the period from 0:00:00.9999999 to 0:00:59.99999999 on the clock. A completed full minute does not mean the last 60 seconds from the current instantaneous time.</p>
			<h4>Instrumenting concurrent gauges programmatically </h4>
			<p>In this<a id="_idIndexMarker712"/> section, we'll demonstrate <a id="_idIndexMarker713"/>how to use a concurrent gauge. They are typically invoked in parallel using a <strong class="source-inline">Runnable</strong> named <strong class="source-inline">sleeper</strong>. This creates – and subsequently retrieves – a concurrent gauge named <strong class="source-inline">concurrentGaugeMetric</strong>. In this example, we will use <strong class="source-inline">MetricRegistry.concurrentGauge(String name)</strong> in our interaction with the metric registry. This is the simplest creation or retrieval method provided by the metric registry as you only need to provide the name. This infers that there are no tags associated with this metric. The sleeper <strong class="source-inline">Runnable</strong> will then increment the concurrent gauge (for example, with <strong class="source-inline">inc()</strong>), sleep for 10 seconds, and then decrement it (for example, with <strong class="source-inline">dec()</strong>). You can only increment or decrement by 1. We'll make parallel invocations using a <strong class="source-inline">for</strong> loop and an <strong class="source-inline">ExecutorService</strong>. However, what's not shown in this code example are the getter methods for the three values; that is, <strong class="source-inline">getCount()</strong>, <strong class="source-inline">getMin()</strong>, and <strong class="source-inline">getMax()</strong>.</p>
			<p>The<a id="_idIndexMarker714"/> full <a id="_idIndexMarker715"/>source code for <strong class="source-inline">ConcurrentGaugeResource</strong> can be found at <a href="https://bit.ly/3ghFyZz">https://bit.ly/3ghFyZz</a>:</p>
			<p class="source-code">  @GET</p>
			<p class="source-code">  @Path("/concurrentGauge")</p>
			<p class="source-code">  public String getConcurrentGage(){</p>
			<p class="source-code">      ExecutorService executorService = </p>
			<p class="source-code">        Executors.newCachedThreadPool();</p>
			<p class="source-code">        Runnable sleeper = () -&gt; {</p>
			<p class="source-code">            ConcurrentGauge concurrentGauge =               metricRegistry.concurrentGauge</p>
			<p class="source-code">               (CONCURRENTGAUGE_METRIC_NAME);</p>
			<p class="source-code">            concurrentGauge.inc();</p>
			<p class="source-code">            try {</p>
			<p class="source-code">                Thread.sleep(10000);</p>
			<p class="source-code">            } catch (InterruptedException e) {</p>
			<p class="source-code">                e.printStackTrace();</p>
			<p class="source-code">            }</p>
			<p class="source-code">            concurrentGauge.dec();</p>
			<p class="source-code">        };</p>
			<p class="source-code">        for (int i = 0; i &lt; 10; i++) {</p>
			<p class="source-code">            executorService.submit(sleeper);</p>
			<p class="source-code">        }</p>
			<p class="source-code">      </p>
			<p class="source-code">      return "Concurrent Gauge created and invoked in         parallel";</p>
			<p class="source-code">  }</p>
			<p>For this example, we will send a <strong class="source-inline">GET</strong> request called <strong class="source-inline">/ch6/concurrentGaugeResource/concurrentGauge</strong>. Once the current minute has completed, we<a id="_idIndexMarker716"/> will view the <a id="_idIndexMarker717"/>output via <strong class="source-inline">/metrics/application</strong>:</p>
			<p class="source-code">$ curl http://localhost:9080/ch6/concurrentGaugeResource</p>
			<p class="source-code">/concurrentGauge</p>
			<p class="source-code">Concurrent Gauge created and invoked in parallel</p>
			<p class="source-code">$ curl http://localhost:9080/m<a href="http://etrics/application ">etrics/application</a></p>
			<p class="source-code"># TYPE application_concurrentGaugeMetric_current gauge</p>
			<p class="source-code">application_concurrentGaugeMetric_current 10</p>
			<p class="source-code"># TYPE application_concurrentGaugeMetric_min gauge</p>
			<p class="source-code">application_concurrentGaugeMetric_min 0</p>
			<p class="source-code"># TYPE application_concurrentGaugeMetric_max gauge</p>
			<p class="source-code">application_concurrentGaugeMetric_max 0</p>
			<p class="source-code">## after a complete full minute…</p>
			<p class="source-code">$ curl http://localhost:9080/<strong class="bold">m</strong><a href="http://etrics/application "><strong class="bold">etrics/application</strong></a></p>
			<p class="source-code"># TYPE application_concurrentGaugeMetric_current gauge</p>
			<p class="source-code">application_concurrentGaugeMetric_current 0</p>
			<p class="source-code"># TYPE application_concurrentGaugeMetric_min gauge</p>
			<p class="source-code">application_concurrentGaugeMetric_min 0</p>
			<p class="source-code"># TYPE application_concurrentGaugeMetric_max gauge</p>
			<p class="source-code">application_concurrentGaugeMetric_max 10</p>
			<p>In the preceding output, we issued a <strong class="source-inline">GET</strong> request to <strong class="source-inline">/ch6/concurentGaugeResource/concurrentGauge</strong>. We then followed up with a <strong class="source-inline">GET</strong> request, <strong class="source-inline">/metrics/application</strong>, to view the output. <strong class="source-inline">application_concurrentGaugeMetric_current</strong> shows the current value, which is <strong class="source-inline">10</strong>, as expected. <strong class="source-inline">application_concurrentGaugeMetric_max</strong> and <strong class="source-inline">application_concurrentGaugeMetric_min</strong>, which show the maximum and minimum <a id="_idIndexMarker718"/>recorded values of the <a id="_idIndexMarker719"/>previous full minute, are <strong class="source-inline">0</strong>, as expected. After the current full minute has completed, we view the results again and we see that the current, max, and min values are <strong class="source-inline">0</strong>, <strong class="source-inline">0</strong>, and <strong class="source-inline">10</strong>, as expected.</p>
			<p class="callout-heading">Note About Metrics with Multiple Values</p>
			<p class="callout">The concurrent gauge is our first metric with multiple output values. To display all the values with the same metric name, each value of the metric is given its own suffix. We will see this pattern in other complex metrics later.</p>
			<p>Immediately after our <strong class="source-inline">GET</strong> request to <strong class="source-inline">/ch6/concurrentGaugeResource/concurrentGaugeParallel</strong>, we will see that the current count for the concurrent gauge is <strong class="source-inline">10</strong>. When the 10 seconds have elapsed for each thread and a full minute has passed, we will see that the current value is <strong class="source-inline">0</strong> and that the maximum value is <strong class="source-inline">10</strong>. </p>
			<h4>Instrumenting concurrent gauges with annotations</h4>
			<p>To<a id="_idIndexMarker720"/> instrument a concurrent<a id="_idIndexMarker721"/> gauge with annotations, you must use the <strong class="source-inline">@ConcurrentGauge</strong> annotation. This applies to methods, constructors, and classes.The concurrent gauge annotation will increment when the target is invoked and decrement when it is finished.</p>
			<p>We'll demonstrate the usage of <strong class="source-inline">@ConcurrentGauge</strong> in a similar fashion to the programmatic example. The <strong class="source-inline">sleeper</strong> runnable will invoke the <strong class="source-inline">sleeper()</strong> method, which is annotated with the <strong class="source-inline">@ConcurrentGauge</strong> annotation. In this example, we will specify <strong class="source-inline">absolute=true</strong>, which will then cause the MicroProfile Metrics runtime to use the metric's name. The <strong class="source-inline">/metrics/*</strong> output will be the same as it was for the programmatic example, so it will not be shown here.</p>
			<p>The full<a id="_idIndexMarker722"/> source code for <strong class="source-inline">ConcurrentGaugeAnnotatedResource</strong> can be found at <a href="https://bit.ly/3xZZhD0">https://bit.ly/3xZZhD0</a>:</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    @Path("/concurrentGuage")</p>
			<p class="source-code">    public String getConcurrentGauge(){</p>
			<p class="source-code">        ExecutorService executorService =           Executors.newCachedThreadPool();</p>
			<p class="source-code">        Runnable sleeper = () -&gt; sleeper(); </p>
			<p class="source-code">        for (int i = 0; i &lt; 10; i++) {</p>
			<p class="source-code">            executorService.submit(sleeper);</p>
			<p class="source-code">        }</p>
			<p class="source-code">        return "Concurrent Gauge created and invoked in           parallel";</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @ConcurrentGauge(name = CONCURRENTGAUGE_METRIC_NAME,       absolute = true)</p>
			<p class="source-code">    public void sleeper() {</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            Thread.sleep(10000);</p>
			<p class="source-code">        } catch (InterruptedException e) {</p>
			<p class="source-code">            e.printStackTrace();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<h3>Histogram</h3>
			<p>The histogram<a id="_idIndexMarker723"/> metric, like a histogram graph, processes the <a id="_idIndexMarker724"/>data it has been provided with in a statistical distribution. A histogram metric outputs 12 values: count, sum, minimum value, maximum value, mean, standard deviation, and the 50th, 75th, 95th, 98th, 99th, and 99.9th percentiles. Unlike the other metrics, the histogram metric can only be instrumented programmatically. There is no annotation support. You might use a histogram metric to record and calculate the distribution of the sizes of data that your application receives for processing.</p>
			<p>For our demonstration, we'll generate 1,000 random numbers within the range <em class="italic">0-999</em> and feed them into our histogram. This time, we will use <strong class="source-inline">metricRegistry.histogram(Metadata metadata)</strong> to create our histogram. We won't be showing the <strong class="source-inline">getCount()</strong>, <strong class="source-inline">getSum()</strong>, and <strong class="source-inline">getSnapshot()</strong> getter methods here, which return <strong class="source-inline">Snapshot</strong> objects that contain the getter methods for the remaining statistical values. As this would be too lengthy to list, you can view the <strong class="source-inline">Snapshot</strong> class <a id="_idIndexMarker725"/>and its methods here: <a href="https://bit.ly/2QndNFf">https://bit.ly/2QndNFf</a>.</p>
			<p>The full source code for <strong class="source-inline">HistogramResource</strong> can be found at <a href="https://bit.ly/3y4AoWK">https://bit.ly/3y4AoWK</a>:</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    @Path("/histogram")</p>
			<p class="source-code">    public String getHistogram()  {</p>
			<p class="source-code">      Metadata histogramMetadata = Metadata.builder()</p>
			<p class="source-code">      .withName(HISTOGRAM_METRIC_NAME)</p>
			<p class="source-code">      .withUnit(MetricUnits.MILLISECONDS)</p>
			<p class="source-code">      .withDescription("This histogram tracks random </p>
			<p class="source-code">        millesconds")</p>
			<p class="source-code">      .withType(MetricType.HISTOGRAM).build();</p>
			<p class="source-code">      </p>
			<p class="source-code">      Histogram histogram =         metricRegistry.histogram(histogramMetadata);</p>
			<p class="source-code">      </p>
			<p class="source-code">      Random random = new Random();</p>
			<p class="source-code">      for (int i = 0; i &lt; 1000 ; i++) {</p>
			<p class="source-code">          int randomInt = random.nextInt(1000);</p>
			<p class="source-code">          histogram.update(randomInt);</p>
			<p class="source-code">      }</p>
			<p class="source-code">      int count = (int) histogram.getCount(); //returns         long value of count</p>
			<p class="source-code">      Snapshot snapshot = histogram.getSnapshot(); //rest         of the stats</p>
			<p class="source-code">      </p>
			<p class="source-code">       return "Histogram created/retrieved and is tracking          random milliseconds";</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Let's see <a id="_idIndexMarker726"/>what <a id="_idIndexMarker727"/>results we get:</p>
			<p class="source-code">$ curl http://localhost:9080/ch6/histogramResource</p>
			<p class="source-code">/histogram</p>
			<p class="source-code">Histogram created/retrieved and is tracking random milliseconds</p>
			<p class="source-code">$ curl http://localhost:9080/m<a href="http://etrics/application ">etrics/application</a></p>
			<p class="source-code"># TYPE application_histogramMetric_mean_seconds gauge</p>
			<p class="source-code">application_histogramMetric_mean_seconds 0.5048109999999999</p>
			<p class="source-code"># TYPE application_histogramMetric_max_seconds gauge</p>
			<p class="source-code">application_histogramMetric_max_seconds 0.998</p>
			<p class="source-code"># TYPE application_histogramMetric_min_seconds gauge</p>
			<p class="source-code">application_histogramMetric_min_seconds 0.0</p>
			<p class="source-code"># TYPE application_histogramMetric_stddev_seconds gauge</p>
			<p class="source-code">application_histogramMetric_stddev_seconds 0.2884925116515156</p>
			<p class="source-code"># TYPE application_histogramMetric_seconds summary</p>
			<p class="source-code"># HELP application_histogramMetric_seconds This histogram tracks random millesconds</p>
			<p class="source-code">application_histogramMetric_seconds_count 1000</p>
			<p class="source-code">application_histogramMetric_seconds_sum 504.81100000000004</p>
			<p class="source-code">application_histogramMetric_seconds{quantile="0.5"} 0.507</p>
			<p class="source-code">application_histogramMetric_seconds{quantile="0.75"} 0.755</p>
			<p class="source-code">application_histogramMetric_seconds{quantile="0.95"} 0.9510000000000001</p>
			<p class="source-code">application_histogramMetric_seconds{quantile="0.98"} 0.974</p>
			<p class="source-code">application_histogramMetric_seconds{quantile="0.99"} 0.981</p>
			<p class="source-code">application_histogramMetric_seconds{quantile="0.999"} 0.995</p>
			<p>In the<a id="_idIndexMarker728"/> preceding <a id="_idIndexMarker729"/>output, we issued a <strong class="source-inline">GET</strong> request to <strong class="source-inline">/ch6/histogramResource/histogram</strong> and we followed up with a <strong class="source-inline">GET</strong> request to <strong class="source-inline">/metrics/application</strong> to view the results. As expected, the count is 1,000, as reported by the <strong class="source-inline">application_histogramMetric_seconds_count</strong> value. The remaining metric values are the calculated values. As there are a large number of values, we will not be explicitly covering all of them. The names provided for the metric values are self-explanatory to indicate what values they represent.</p>
			<p class="callout-heading">Note About Prometheus Formatting with Histograms</p>
			<p class="callout">If a unit has been defined, the metric name is appended to the unit as <strong class="source-inline">_&lt;unit&gt;</strong>. Prometheus only accepts certain <strong class="bold">base units</strong>, so the MicroProfile Metrics runtime will scale the value to the appropriate base unit. For example, if milliseconds were specified as the unit, the values will be scaled to a base unit of seconds.</p>
			<p class="callout">Also, notice<a id="_idIndexMarker730"/> that the quantile metric values share the same name but use tags to identify which percentile it is representing.</p>
			<h3>Meter</h3>
			<p>The meter<a id="_idIndexMarker731"/> metric, like<a id="_idIndexMarker732"/> the histogram metric, aggregates input values and performs calculations to produce results. Instead of statistical distributions, the meter calculates rates in units per second. The unit that's specified for the metric will be ignored. This only applies to the Prometheus output. The meter outputs the mean rate and the 1, 5, and 15-minute exponentially weighted moving average rates. Meter can be useful for monitoring the traffic on a specific method <a id="_idIndexMarker733"/>or component in your microservice<a id="_idTextAnchor137"/>.</p>
			<h4>Instrumenting meters programmatically </h4>
			<p>In our <a id="_idIndexMarker734"/>example, we'll demonstrate <a id="_idIndexMarker735"/>using the meter metric to monitor the rate of requests to two <strong class="source-inline">GET</strong> resources: <strong class="source-inline">/meter</strong> and <strong class="source-inline">/meter2</strong>. With the first <strong class="source-inline">GET</strong> resource, we will use the last variant of the register/retrieve methods that we have yet to use with <strong class="source-inline">MetricRegistry.meter(String metricName, Tags… tags)</strong>. Once the metric has been created or retrieved, we will invoke the <strong class="source-inline">mark()</strong> method, which increases the meter's recorded hits by 1. With the second <strong class="source-inline">GET</strong> resource, we can pass a long parameter value so that we can invoke <strong class="source-inline">mark(long value)</strong>, which increments the number of hits to the meter by the specified value. Notice that we use <strong class="source-inline">MetricID</strong> in the <strong class="source-inline">/meter2</strong> <strong class="source-inline">GET</strong> resource to retrieve the metric we created and registered in the <strong class="source-inline">/meter</strong> resource.</p>
			<p>The full <a id="_idIndexMarker736"/>source code for <strong class="source-inline">MeterResource</strong> can be found at <a href="https://bit.ly/3ASCV8j">https://bit.ly/3ASCV8j</a>:</p>
			<p class="source-code">    private final Tag METER_TAG = new Tag("metricType",       "meter");</p>
			<p class="source-code">    </p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    @Path("/meter")</p>
			<p class="source-code">    public String getMeter(){     </p>
			<p class="source-code">     Meter meter = metricRegistry.meter(METER_METRIC_NAME,       METER_TAG);</p>
			<p class="source-code">        meter.mark();</p>
			<p class="source-code">        return "Meter created/retrieved and marked by 1";</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    @Path("/meter2")</p>
			<p class="source-code">    public String getMeter2(@QueryParam("value") </p>
			<p class="source-code">      @DefaultValue("1") int value){      </p>
			<p class="source-code">        MetricID meterMetricID = new           MetricID(METER_METRIC_NAME, METER_TAG); </p>
			<p class="source-code">        Meter meter = metricRegistry.meter(meterMetricID);</p>
			<p class="source-code">        meter.mark(value);</p>
			<p class="source-code">        return "Meter created/retrieved and marked by " +           value;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Not <a id="_idIndexMarker737"/>shown<a id="_idIndexMarker738"/> are the getter methods for the values; that is, <strong class="source-inline">getCount()</strong>, <strong class="source-inline">getMeanRate()</strong>, <strong class="source-inline">getOneMinuteRate()</strong>, <strong class="source-inline">getFiveMinuteRate()</strong>, and <strong class="source-inline">getFifteenMinuteRate()</strong>. Let's run through hitting both <strong class="source-inline">GET</strong> resources and view the result at <strong class="source-inline">/metrics/application</strong>:</p>
			<p class="source-code">$ curl http://localhost:9080/ch6/meterResource/meter</p>
			<p class="source-code">Meter created/retrieved and marked by 1</p>
			<p class="source-code">$ curl http://localhost:9080/ch6/meterResource/meter2?value=3</p>
			<p class="source-code">Meter created/retrieved and marked by 3</p>
			<p class="source-code">$ curl http://localhost:9080/m<a href="http://etrics/application ">etrics/application</a></p>
			<p class="source-code"># TYPE application_histogramMetric_total counter</p>
			<p class="source-code">application_histogramMetric_total{metricType="meter"} 4</p>
			<p class="source-code"># TYPE application_histogramMetric_rate_per_second gauge</p>
			<p class="source-code">application_histogramMetric_rate_per_second{metricType="meter"} 0.4348951236275281</p>
			<p class="source-code"># TYPE application_histogramMetric_one_min_rate_per_second gauge</p>
			<p class="source-code">application_histogramMetric_one_min_rate_per_second{metricType="meter"} 0.8</p>
			<p class="source-code"># TYPE application_histogramMetric_five_min_rate_per_second gauge</p>
			<p class="source-code">application_histogramMetric_five_min_rate_per_second{metricType="meter"} 0.8</p>
			<p class="source-code"># TYPE application_histogramMetric_fifteen_min_rate_per</p>
			<p class="source-code">_second gauge</p>
			<p class="source-code">application_histogramMetric_fifteen_min_rate_per_second{metricType="meter"} 0.8</p>
			<p>In the preceding output, we issued a <strong class="source-inline">GET</strong> request to <strong class="source-inline">/ch6/meterResource/</strong> meter, which increments the meter by 1, followed by a <strong class="source-inline">GET</strong> request to <strong class="source-inline">/ch6/meterResource/meter2</strong>, supplying it with a parameter value to increment the meter by 3. We then viewed the resulting output in <strong class="source-inline">/metrics/application</strong>. <strong class="source-inline">application_histogramMetric_total</strong> shows that the count is 4, as expected, and that the remaining values are the calculated values. Once again, the names associated<a id="_idIndexMarker739"/> with the remaining metric <a id="_idIndexMarker740"/>values are self-explanatory and will not be explicitly explained.</p>
			<h4>Instrumenting meters with annotations</h4>
			<p>To instrument<a id="_idIndexMarker741"/> a meter metric <a id="_idIndexMarker742"/>with annotations, you must use the <strong class="source-inline">@Metered</strong> annotation. This annotation applies to methods, constructors, and classes. Like other annotated metrics, only a single value is incremented by using the annotation. We'll demonstrate a sample that uses the <strong class="source-inline">@Metered</strong> annotation and omit showing the results.</p>
			<p>The full source code for <strong class="source-inline">MeterAnnotatedResource</strong> can be found at <a href="https://bit.ly/3mhnHpk">https://bit.ly/3mhnHpk</a>:</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    @Path("/meter")</p>
			<p class="source-code">    @Metered(name=METER_METRIC_NAME, tags={"metricType=meter"})</p>
			<p class="source-code">    public String getMeterWithAnnotations() {</p>
			<p class="source-code">        return "Meter created/retrieved and marked by 1           with annotations";</p>
			<p class="source-code">    }</p>
			<h3>Timer and simple timer</h3>
			<p>Since<a id="_idIndexMarker743"/> both the timer and simple timer metrics are very similar, we<a id="_idIndexMarker744"/> will demonstrate how to use both metrics together.</p>
			<p>The <strong class="bold">timer</strong> metric, as its name implies, records the time spent going through the instrumented component. At its core, it keeps track of the total elapsed time. Additionally, it provides the throughput/rate from the hits recorded, as well as the statistical distribution of the recorded times. These outputted values are the same as they are for the histogram and meter metrics. </p>
			<p>The <strong class="bold">simple timer</strong> metric, on the other hand, is a timer but with the extra bells and whistles stripped off. It only reports on the count, total elapsed time, and, like the concurrent gauge, the highest and lowest recorded time of the previous complete full minute. If<a id="_idIndexMarker745"/> you don't require all the extra values that the timer provides, or intend to calculate them yourself later, the simple timer should be your metric of choice.</p>
			<h4>Instrumenting timers and simple timers programmatically </h4>
			<p>In our <a id="_idIndexMarker746"/>example, we'll<a id="_idIndexMarker747"/> instrument a timer and a simple timer in their own <strong class="source-inline">GET</strong> resources. In both resources, we will provide an example of how to record time using the <strong class="source-inline">Context</strong> object. This allows us to explicitly mark the beginning and end of what we want to time by calling the <strong class="source-inline">time()</strong> method from either the timer or simple timer, to start timing, and then calling the <strong class="source-inline">Context</strong> object's <strong class="source-inline">close()</strong> method to stop timing. Note that the <strong class="source-inline">Context</strong> object is an inner interface of both the <strong class="source-inline">Timer</strong> and <strong class="source-inline">SimpleTimer</strong> classes, and that you will need to use the appropriate <strong class="source-inline">Context</strong> object. Both the timer and simple timer metrics can time the execution of a <strong class="source-inline">Runnable</strong> or <strong class="source-inline">Callable</strong> object or lambda expression. The following two code snippets are from the same <strong class="source-inline">TimersResource</strong> class, and the full source code can be found at <a href="https://bit.ly/37YaWYy">https://bit.ly/37YaWYy</a>.</p>
			<p>The following code snippet shows the <strong class="source-inline">GET</strong> resource known as <strong class="source-inline">/timer</strong>, which demonstrates timing with a <strong class="source-inline">Runnable</strong> object with the timer metric:</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    @Path("/timer")</p>
			<p class="source-code">    public String getTimer() {</p>
			<p class="source-code">        Timer timer = metricRegistry.timer(TIMER_METRIC_NAME);</p>
			<p class="source-code">        Timer.Context timerContext = timer.time();</p>
			<p class="source-code">        timerContext.close();</p>
			<p class="source-code">        Runnable runnableTimer = () -&gt; {</p>
			<p class="source-code">            try {</p>
			<p class="source-code">                Thread.sleep(2000);</p>
			<p class="source-code">            } catch (InterruptedException e) {</p>
			<p class="source-code">                e.printStackTrace();</p>
			<p class="source-code">            }</p>
			<p class="source-code">        };</p>
			<p class="source-code">        // Time a Runnable</p>
			<p class="source-code">        timer.time(runnableTimer);</p>
			<p class="source-code">        return "Timer created/retrieved and recorded total           elapsed time of " + timer.getElapsedTime();</p>
			<p class="source-code">    }</p>
			<p>The <a id="_idIndexMarker748"/>following code<a id="_idIndexMarker749"/> snippet shows the <strong class="source-inline">GET</strong> resource called <strong class="source-inline">/simpleTimer</strong>, which demonstrates timing with a <strong class="source-inline">Callable</strong> object with the simple timer metric:</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    @Path("/simpleTimer")</p>
			<p class="source-code">    public String getSimpleTimer(){</p>
			<p class="source-code">      SimpleTimer simpleTimer =        metricRegistry.simpleTimer(SIMPLETIMER_METRIC_NAME);</p>
			<p class="source-code">      SimpleTimer.Context simpleTimerContext =        simpleTimer.time();</p>
			<p class="source-code">        simpleTimerContext.close();</p>
			<p class="source-code">        // Time a Callable</p>
			<p class="source-code">        Callable&lt;String&gt; callable = () -&gt; {</p>
			<p class="source-code">            Thread.sleep(2000);</p>
			<p class="source-code">            return "Finished Callable";</p>
			<p class="source-code">        };</p>
			<p class="source-code">        simpleTimer.time(callable);</p>
			<p class="source-code">        return "SimpleTimer created/retrieved and recorded           total elapsed time of " + simpleTimer             .getElapsedTime();</p>
			<p class="source-code">    }</p>
			<p>Not <a id="_idIndexMarker750"/>shown are<a id="_idIndexMarker751"/> the getter methods for the metric values. For the timer, you can call <strong class="source-inline">getCount()</strong>, <strong class="source-inline">getElapsedTime()</strong>, <strong class="source-inline">getSnapshot()</strong>, <strong class="source-inline">getMeanRate()</strong>, <strong class="source-inline">getOneMinuteRate()</strong>, <strong class="source-inline">getFiveMinuteRate()</strong>, and <strong class="source-inline">getFifteenMinuteRate()</strong>. For the simple timer, you can call <strong class="source-inline">getCount()</strong>, <strong class="source-inline">getElapsedTime()</strong>, <strong class="source-inline">getMinTimeDuration()</strong>, and <strong class="source-inline">getMaxTimeDuration()</strong>. </p>
			<p>Let's call both <strong class="source-inline">GET</strong> resources and see the results:</p>
			<p class="source-code">$ curl http://localhost:9080/ch6/timersResource/timer</p>
			<p class="source-code">Timer created/retrieved and recorded total elapsed time of 2001 milliseconds</p>
			<p class="source-code">$ curl http://localhost:9080/ch6/timersResource/simpleTimer</p>
			<p class="source-code">SimpleTimer created/retrieved and recorded total elapsed time of 2000 milliseconds</p>
			<p class="source-code">$ curl http://localhost:9080/m<a href="http://etrics/application ">etrics/application</a></p>
			<p class="source-code"># TYPE application_simpleTimerMetric_total counter</p>
			<p class="source-code">application_simpleTimerMetric_total 1</p>
			<p class="source-code"># TYPE application_simpleTimerMetric_elapsedTime_seconds gauge</p>
			<p class="source-code">application_simpleTimerMetric_elapsedTime_seconds 2.0005379000000003</p>
			<p class="source-code"># TYPE application_simpleTimerMetric_maxTimeDuration</p>
			<p class="source-code">_seconds gauge</p>
			<p class="source-code">application_simpleTimerMetric_maxTimeDuration_seconds NaN</p>
			<p class="source-code"># TYPE application_simpleTimerMetric_minTimeDuration</p>
			<p class="source-code">_seconds gauge</p>
			<p class="source-code">application_simpleTimerMetric_minTimeDuration_seconds NaN</p>
			<p>First, we <a id="_idIndexMarker752"/>issue <strong class="source-inline">GET</strong> requests <a id="_idIndexMarker753"/>to <strong class="source-inline">/ch6/timersResource/timer</strong> and <strong class="source-inline">/ch6/timersResource/simpleTimer</strong> to invoke both of our timers. We then send a request to <strong class="source-inline">/metrics/application</strong> to view the results. As we have already demonstrated the similar max and min behavior of the concurrent gauge, we will not be demonstrating that behavior for the simple timer here. Additionally, as the timer metric outputs a statistical distribution of the recorded times (which includes the total recorded durations) and the throughput of requests, similar to the histogram and meter metrics, the timer metric's output will be omitted. What remains is the output for the simple timer. Notice that the values for <strong class="source-inline">application_simpleTimerMetric_maxTimeDuration_seconds</strong> and <strong class="source-inline">application_simpleTimerMetric_minTimeDuration_seconds</strong> report <strong class="source-inline">NaN</strong>. This is because there are no recorded values for the previously completed minute. If you would like to view the full output, we encourage you to try out the samples directly. Take a look at the <em class="italic">Technical requirements</em> section at the beginning of this chapter for instructions on how to run the samples.</p>
			<h4>Instrumenting timers and simple timers with annotations</h4>
			<p>To<a id="_idIndexMarker754"/> instrument <a id="_idIndexMarker755"/>the timer and simple timer metric, you will need to use <strong class="source-inline">@Timed</strong> and <strong class="source-inline">@SimplyTimed</strong>, respectively. These annotations apply to methods, constructors, and classes. They will both record how long it takes to execute the target annotated element.</p>
			<p>We will show a simple example demonstrating how to annotate <strong class="source-inline">@Timed</strong> and <strong class="source-inline">@SimplyTimed</strong> on a JAX-RS endpoint.</p>
			<p>The full source<a id="_idIndexMarker756"/> code for <strong class="source-inline">TimersAnnotatedResource</strong> can be found at <a href="https://bit.ly/3xVroDb">https://bit.ly/3xVroDb</a>:</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    @Path("/timers")</p>
			<p class="source-code">    @Timed(name=ANNOTATED_TIMER_METRIC_NAME)</p>
			<p class="source-code">    @SimplyTimed(name= ANNOTATED_SIMPLETIMER_METRIC_NAME)</p>
			<p class="source-code">    public String getTimerWithAnnotations() {</p>
			<p class="source-code">        //some business logic to time</p>
			<p class="source-code">        return "Timer with annotations";</p>
			<p class="source-code">    }</p>
			<h3>Gauges</h3>
			<p>A gauge<a id="_idIndexMarker757"/> metric <a id="_idIndexMarker758"/>serves to report on some value that is provided by the application. This can be any value, but it is highly recommended that the value is a number as Prometheus only supports numeric gauges. This is not a limitation of JSON output. Additionally, you can only create a numeric gauge using the metric registry's methods for creating a gauge.</p>
			<h4>Instrumenting gauges programmatically</h4>
			<p>As we <a id="_idIndexMarker759"/>mentioned <a id="_idIndexMarker760"/>earlier, the gauge metric does not follow the same pattern of the registration and retrieval method signatures like the other metrics do. This is due to the nature of what the gauge metric does. When registering or retrieving a gauge, you will need to specify a <strong class="source-inline">Supplier</strong> or <strong class="source-inline">Function</strong> object or lambda expression.</p>
			<p>The following are the method signatures for registering or retrieving a gauge metric:</p>
			<p class="source-code">&lt;T, R extends Number&gt; Gauge&lt;R&gt; gauge(String name, T object, Function&lt;T, R&gt; func, Tag... tags);</p>
			<p class="source-code">&lt;T, R extends Number&gt; Gauge&lt;R&gt; gauge(MetricID metricID, T object, Function&lt;T, R&gt; func);</p>
			<p class="source-code">&lt;T, R extends Number&gt; Gauge&lt;R&gt; gauge(Metadata metadata, T object, Function&lt;T, R&gt; func, Tag... tags);</p>
			<p class="source-code">&lt;T, R extends Number&gt; Gauge&lt;R&gt; gauge(Metadata metadata, T object, Function&lt;T, R&gt; func, Tag... tags);</p>
			<p class="source-code">&lt;T extends Number&gt; Gauge&lt;T&gt; gauge(MetricID metricID, Supplier&lt;T&gt; supplier);</p>
			<p class="source-code">&lt;T extends Number&gt; Gauge&lt;T&gt; gauge(Metadata metadata, Supplier&lt;T&gt; supplier, Tag... tags);</p>
			<p>The only<a id="_idIndexMarker761"/> notable <a id="_idIndexMarker762"/>method you can call with the gauge metric is <strong class="source-inline">getValue()</strong>. Since you should be familiar with the usage of the <strong class="source-inline">MetricID</strong> class, the <strong class="source-inline">Metadata</strong> class, how to create a metric, and Java functions (which we assume you are familiar with), we will not be providing any example code for instrumenting the gauge metric programmatically.</p>
			<h4>Instrumenting gauges with annotations</h4>
			<p>To<a id="_idIndexMarker763"/> instrument a gauge metric, you <a id="_idIndexMarker764"/>will need to use the <strong class="source-inline">@Gauge</strong> annotation. This annotation can only be applied to a method. With the gauge annotation, you must specify the unit parameter. We will show a simple example where the method, and therefore the gauge, will return the current millisecond since the last epoch.</p>
			<p>The full source code for <strong class="source-inline">GaugeResource</strong> can be found at <a href="https://bit.ly/3mfj6Ux">https://bit.ly/3mfj6Ux</a>:</p>
			<p class="source-code">@ApplicationScoped</p>
			<p class="source-code">@Path("/metricsResource")</p>
			<p class="source-code">public class MyMetricsResource {</p>
			<p class="source-code">    @Gauge(name="time.since.epoch", unit =       MetricUnits.MILLISECONDS)</p>
			<p class="source-code">    public long getGaugeWithAnnotations() {</p>
			<p class="source-code">        return System.currentTimeMillis();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We'll<a id="_idIndexMarker765"/> assume <a id="_idIndexMarker766"/>that a <strong class="source-inline">GET</strong> request invokes this method, so we'll just show the resulting <strong class="source-inline">/metrics/application</strong> output here:</p>
			<p class="source-code">$ curl http://localhost:9080/m<a href="http://etrics/application ">etrics/application</a></p>
			<p class="source-code"># TYPE application_metrics_demo_gaugeResource_time_since</p>
			<p class="source-code">_epoch_seconds gauge</p>
			<p class="source-code">application_metrics_demo_gaugeResource_time_since_epoch</p>
			<p class="source-code">_seconds 1.6181035765080001E9</p>
			<p class="callout-heading">Note About Prometheus Formatting with Gauges</p>
			<p class="callout">The unit that's defined for the gauge is appended as <strong class="source-inline">_&lt;unit&gt;</strong> and is scaled to the appropriate base unit.</p>
			<h3>The @Metric annotation</h3>
			<p>The <strong class="source-inline">@Metric</strong> annotation<a id="_idIndexMarker767"/> is a <a id="_idIndexMarker768"/>unique annotation that allows you to inject a metric that corresponds to the field or parameter type that it is being annotated on. The <strong class="source-inline">@Metric</strong> annotation contains the same annotation parameters as the other metric annotations. It will return a metric with the matching metadata, if it exists; otherwise, a new metric of the specified type will be created, registered, and injected. Let's look at an example of using both injection strategies.</p>
			<p>The full source code for <strong class="source-inline">MetricsResource</strong> can be found at <a href="https://bit.ly/3iBAz7E">https://bit.ly/3iBAz7E</a>:</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    @Metric(name="fieldInjectedCounter")</p>
			<p class="source-code">    Counter fieldInjectedCounter;</p>
			<p class="source-code">    </p>
			<p class="source-code">    Counter parameterInjectedCounter;</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    public void setCounterMetric(@Metric(name =       "parameterInjectedCounter") Counter         parameterInjectedCounter) {</p>
			<p class="source-code">        this.parameterInjectedCounter =           parameterInjectedCounter;</p>
			<p class="source-code">    }</p>
			<p>In the<a id="_idIndexMarker769"/> aforementioned<a id="_idIndexMarker770"/> example, <strong class="source-inline">fieldInjectedCounter</strong> is injected with field injection and <strong class="source-inline">parameterInjectedCounter</strong> is injected with parameter injection.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor138"/>Visualizing metric data with Prometheus and Grafana</h2>
			<p>The <a id="_idIndexMarker771"/>MicroProfile<a id="_idIndexMarker772"/> Metrics <a id="_idIndexMarker773"/>runtime <a id="_idIndexMarker774"/>can only report on instantaneous metric values. To effectively use this data for monitoring purposes, we need to aggregate that data with a tool such as Prometheus. Then, using a tool such as Grafana, we can create a wide variety of visualizations that present the metric data over a configurable time period. Prometheus can scrape data from multiple sources and Grafana will then pull the data from it by performing queries against Prometheus using the <strong class="bold">Prometheus Query Language</strong> (<strong class="bold">PromQL</strong>). This, of course, is not just limited to retrieving the metric data as-is – we can infer additional statistics by performing calculations on the data that we retrieve. This is made possible by a wide variety of functions provided by PromQL. In this subsection, we'll demonstrate the power of using Prometheus and Grafana to monitor your metric data using the optional base REST metric, known as <strong class="source-inline">REST.request</strong>, from the Broker microservice of the StockTrader application. </p>
			<p class="callout-heading">Understanding the <strong class="source-inline">REST.request</strong> Metric</p>
			<p class="callout">The <strong class="source-inline">REST.request</strong> metric is <a id="_idIndexMarker775"/>a simple timer that <a id="_idIndexMarker776"/>is <a id="_idIndexMarker777"/>automatically instrumented<a id="_idIndexMarker778"/> to all REST endpoints by the MicroProfile Metrics runtime. The instrumented <strong class="source-inline">REST.request</strong> metrics are differentiated from each other with tags related to the class name and the method signature.</p>
			<h3>The Broker microservice</h3>
			<p>The Broker <a id="_idIndexMarker779"/>service<a id="_idIndexMarker780"/> contains multiple JAX-RS/REST endpoints for creating, retrieving, and deleting Broker objects, as well as retrieving portfolio returns with <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, and <strong class="source-inline">DELETE</strong> requests. This all occurs in the <strong class="source-inline">AccountService</strong> class. The full source code can be found at <a href="https://bit.ly/3sBGvPE">https://bit.ly/3sBGvPE</a>.</p>
			<p>First, we'll look at the sample output of a <strong class="source-inline">REST.request</strong> metric so that we can understand the format of the metric name and its tags, before we demonstrate querying it with Grafana. We'll show the output of a <strong class="source-inline">GET</strong> endpoint that queries all accounts whose method is <strong class="source-inline">getAccounts()</strong>. The other base metrics – the max time and min time values and the metric description for <strong class="source-inline">REST.request</strong> – have been omitted from the output:</p>
			<p class="source-code">$ curl http://localhost:9080/metrics/base</p>
			<p class="source-code"># TYPE base_REST_request_total counter</p>
			<p class="source-code">base_REST_request_total{class="com.ibm.hybrid.cloud.sample.stocktrader.account.AccountService",method="getAccounts"} 45</p>
			<p class="source-code"># TYPE application_simpleTimerMetric_elapsedTime_seconds gauge</p>
			<p class="source-code">base_REST_request_elapsedTime_seconds{class="com.ibm.hybrid.cloud.sample.stocktrader.account.AccountService",method="getAccounts"} 1.7304427800000002</p>
			<h3>Visualizing with Grafana</h3>
			<p>In Grafana, we<a id="_idIndexMarker781"/> can <a id="_idIndexMarker782"/>create a visualization out of each metric by querying the metric name. For example, we can simply query <strong class="source-inline">base_REST_request_total</strong> and Grafana will display all instances of that metric, which counts the request invocations to a REST endpoint. Alternatively, if we want to see only the metrics from a single microservice, such as <strong class="source-inline">AccountService</strong>, we can issue the following query:</p>
			<p class="source-code">base_REST_request_total{class=" com.ibm.hybrid.cloud.sample.  stocktrader.account.AccountService"} </p>
			<p>However, just the total count of a counter doesn't tell us much. We would be more interested in knowing how many times the metrics have increased in the past 10 minutes instead. Here, we can perform the following query:</p>
			<p class="source-code">increase(base_REST_request_total[10m]).</p>
			<p>Or perhaps we want to know the rate at which requests have increased in the past 10 minutes:</p>
			<p class="source-code">rate(base_REST_request_total[10m])</p>
			<p>When using a simple timer, what we would be most interested in is the timing data. However, the elapsed time by itself is nothing significant, but we can calculate a new value that may prove more useful. Using the elapsed time and count, we can calculate the average duration per request with the following query:</p>
			<p class="source-code">rate(base_REST_request_elapsedTime_seconds[10m]) / rate(base_REST_request_total[10m]).</p>
			<p>The following is a graphical visualization of the aforementioned query. The details of the snapshot are not important; the snapshot serves to illustrate the layout of what you would expect to see when using Grafana. The query is entered at the top, with the visualization displayed in the middle, and a table or list of the queried metrics at the bottom: </p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B17377_06_03.jpg" alt="Figure 6.3 – A Grafana graph visualization&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – A Grafana graph visualization</p>
			<p>These<a id="_idIndexMarker783"/> examples<a id="_idIndexMarker784"/> only show a sliver of the potential of using Prometheus and Grafana. In the preceding figure, we only used a graph visualization. There are a wide variety of visualizations that exist that suit any specific visualization needs you may have. On top of that, there is a vast array of functions available to use with PromQL to calculate any specific values that you and your team may find useful. It should also be noted that the preceding figure only shows a direct view of a single visualization. Remember that you can build dashboards with multiple visualizations displayed all at once.</p>
			<p>We've now come to the end of the MicroProfile Metrics section. With the metrics instrumented in your microservice, you can monitor different parts of your application in detail. In the next section, we'll learn how to observe requests that span multiple microservices with MicroProfile OpenTracing.</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor139"/>Tracing your cloud-native application using MicroProfile OpenTracing</h1>
			<p>We will <a id="_idIndexMarker785"/>conclude our<a id="_idIndexMarker786"/> MicroProfile observability journey by looking at the MicroProfile OpenTracing technology. Unlike the other two technologies we've examined in this chapter, MicroProfile<a id="_idIndexMarker787"/> OpenTracing is<a id="_idIndexMarker788"/> much more lightweight in comparison. We'll cover the importance of this technology while overviewing it and jump straight into learning how to use MicroProfile OpenTracing.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor140"/>The importance of and an overview of MicroProfile OpenTracing in a cloud-native application</h2>
			<p>The<a id="_idIndexMarker789"/> MicroProfile OpenTracing<a id="_idIndexMarker790"/> technology <a id="_idIndexMarker791"/>ties in with the <a id="_idIndexMarker792"/>concept of <strong class="bold">distributed tracing</strong>. In a <a id="_idIndexMarker793"/>cloud environment, applications or microservices communicate and interact with one another, which, in turn, can interact with other microservices. This chain of interactions can be quite lengthy, depending on the nature and context of your application deployments. When something unexpectantly fails, it can be a difficult and troublesome task to diagnose where things have gone wrong in such a complex and distributed topology. </p>
			<p>This is where distributed tracing comes in. Distributed tracing allows us to track and monitor requests or processes as it navigates from one application to another. Throughout its journey, which is referred to as a <strong class="bold">trace</strong>, performance data (for example, time spent), contextual data in the form of tags, and any important logs are retrieved for a <strong class="bold">span</strong>. A span defines the individual hierarchal segments that make up a <strong class="bold">trace</strong>. Each span can be identified by name. </p>
			<p>For example, invocating a method creates a span named <em class="italic">method1</em>. This method can then invoke another method, which then creates a new <strong class="bold">child span</strong>, named <em class="italic">method2</em>, that is under the scope of the <strong class="bold">parent span</strong> from the first method. When the child span is complete (that is, the method finishes invoking), it returns to the first method and when the first method finishes, the trace is completed. There is no limit to how many child spans there can be. The resulting trace records are sent to an external tool or platform that gathers and stores these records, and can provide a way for us to view all the traces and the spans that it comprises. </p>
			<p>It is through this that we can analyze and understand the performance and latency of a request, and any additional contextual information from individual spans, as it navigates through multiple microservices. With distributed tracing, we can easily profile the performance and latency of a request and diagnose any errors or failures that occur.</p>
			<p>For distributed tracing to be effective in a system, all applications must use the same distributed tracing library. Now, you may be thinking that this is what MicroProfile OpenTracing serves to satisfy. This is not the case. The MicroProfile OpenTracing technology operates on top of the existing <strong class="bold">OpenTracing</strong> technology. The OpenTracing technology is a façade that defines a vendor-neutral API for instrumenting distributed tracing in an application. This OpenTracing technology is incorporated into the MicroProfile OpenTracing runtime. To be able to apply to trace instrumentation to your application, you will need to use a compatible <strong class="bold">tracer</strong> implementation. You can view the compatible tracers at <a href="https://opentracing.io/docs/supported-tracers/">https://opentracing.io/docs/supported-tracers/</a>. However, note that the different MicroProfile OpenTracing runtimes are compatible with different sets of tracer libraries. Consult the documentation of your chosen runtime for more details. It <a id="_idIndexMarker794"/>can <a id="_idIndexMarker795"/>even be the case that<a id="_idIndexMarker796"/> your<a id="_idIndexMarker797"/> chosen runtime may support a tracer that isn't on OpenTracing's list of officially supported tracers.</p>
			<p>Each application in the system will need to be configured to use the same tracer library. Different tracer libraries may differ in how they communicate the contextual identification data of a trace, which is <a id="_idIndexMarker798"/>called the <strong class="bold">span context</strong>. The span context contains stateful information that is accompanied by a request as it navigates through the network of microservices. This allows the OpenTracing technology to link spans together into a singular trace when they transcend application boundaries.</p>
			<p>MicroProfile OpenTracing amends the OpenTracing technology by defining an additional <strong class="source-inline">@Traced</strong> annotation that complements the use of the OpenTracing technology. However, the main benefit of MicroProfile OpenTracing is that you can automatically instrument traces on inbound and outbound JAX-RS requests. Any JAX-RS application will be traced without the developer having to deal with the MicroProfile OpenTracing API or the OpenTracing API. We will not cover how to use the OpenTracing API in this book, only the amendments that MicroProfile OpenTracing provides. We leave it up to you to explore the OpenTracing API and its documentation at <a href="https://bit.ly/3gEHLis">https://bit.ly/3gEHLis</a>. </p>
			<p>The producer of the implementation library may also provide a platform/server that aggregates the tracing records. We will demonstrate this with the Jaeger Tracing platform at the end of this section.</p>
			<p class="callout-heading">Special Note on OpenTracing</p>
			<p class="callout">At the time of writing, the OpenTracing project has combined with OpenCensus to form OpenTelemetry. OpenTelemetry is an all-in-one technology that will satisfy your monitoring needs for tracing, logging, and metrics. Future iterations of the MicroProfile platform<a id="_idIndexMarker799"/> may <a id="_idIndexMarker800"/>see the incorporation<a id="_idIndexMarker801"/> of OpenTelemetry<a id="_idIndexMarker802"/> and its subcomponents.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor141"/>Auto-instrumenting JAX-RS requests</h2>
			<p>MicroProfile <a id="_idIndexMarker803"/>OpenTracing allows you to automatically <a id="_idIndexMarker804"/> instrument tracing on JAX-RS requests on both the client and server side. When a request is sent through a JAX-RS client or using MicroProfile Rest Client, a span will be automatically created. If an active span already exists, then it will be a child span of the active span. This span begins when the request is sent by the client.</p>
			<p>Similarly, when an incoming JAX-RS request is received, a span will be created. If the request is part of a trace, the MicroProfile OpenTracing runtime will automatically determine that by attempting to extract span context information from the incoming request. If such data exists, then the new span is a child span of a preceding span in this trace. If there are no active spans or extractable span context information, then a new span and, subsequently, a new trace is created. This span begins when the request is received and correlates with the JAX-RS resource method. This default behavior of auto-instrumentation on the JAX-RS resource method can be overridden with the use of the <strong class="source-inline">@Traced</strong> annotation, which will be covered in the <em class="italic">Instrumenting the @Traced annotation and injecting a Tracer</em> section.</p>
			<p>There are some additional rules regarding names and tags that we will cover once we have described how to auto-instrument outbound and inbound JAX-RS requests.</p>
			<h3>Outbound JAX-RS requests</h3>
			<p>With<a id="_idIndexMarker805"/> outbound JAX-RS requests, the span that is created is given the name of the HTTP method to be invoked. For example, a <strong class="source-inline">GET</strong> request results in a span named <strong class="source-inline">GET</strong>. </p>
			<p class="callout-heading">Note on Using JAX-RS Clients</p>
			<p class="callout">If you are using a JAX-RS client to create outbound requests, you will need to pass the ClientBuilder you've created to <strong class="source-inline">ClientTracingRegistrar</strong> for the MicroProfile OpenTracing runtime to create a span for it. You can invoke either the <strong class="source-inline">configure(ClientBuilder clientBuilder)</strong> or <strong class="source-inline">configure(ClientBuilder clientBduilder, ExecutorService executorService)</strong> static methods, which will then return a <strong class="source-inline">ClientBuilder</strong> object that you can use. The implementation of the MicroProfile OpenTracing runtime may have been already configured so that any ClientBuilders used will create a span, thus not needing to invoke the <strong class="source-inline">configure(…)</strong> methods. Consult the documentation of your MicroProfile OpenTracing runtime for details.</p>
			<h3>Inbound JAX-RS requests</h3>
			<p>With inbound <a id="_idIndexMarker806"/>JAX-RS requests, the span that is created is given the name in the following format:</p>
			<p class="source-code"> &lt;HTTP method&gt;:&lt;package name&gt;.&lt;class name&gt;.&lt;method name&gt;</p>
			<p>This is referred to as the <strong class="bold">class-method</strong> naming format and is the default format. Alternatively, you can use the <strong class="bold">http-path</strong> naming format, which uses the following format:</p>
			<p class="source-code">&lt;HTTP method&gt;:&lt;@Path value of endpoint's class&gt;/&lt;@Path value of endpoint's method&gt;. </p>
			<p>To enable the http-path format, use the MicroProfile Config configuration element known as <strong class="source-inline">mp.opentracing.server.operation-name-provider</strong> and specify <strong class="source-inline">http-path</strong>.</p>
			<h3>Span tags</h3>
			<p>Spans <a id="_idIndexMarker807"/>that <a id="_idIndexMarker808"/>are created in both inbound and outbound requests use the following tags:</p>
			<ul>
				<li><strong class="bold">Tags.SPAN_KIND</strong>: This is an outgoing JAX-RS request with a value of <strong class="source-inline">"Tags.SPAN_KIND_CLIENT"</strong>. An inbound request has a value of<strong class="source-inline"> "Tags.SPAN_KIND_SERVER"</strong>.</li>
				<li><strong class="bold">Tags.HTTP_METHOD</strong>: The value of this is the HTTP method that has been invoked.</li>
				<li><strong class="bold">Tags.HTTP_URL</strong>: This is the value of the HTTP URL that the request has been sent to.</li>
				<li><strong class="bold">Tags.HTTP_STATUS</strong>: This is the status of the HTTP request. It specifies what response was received by the client or what response the server is returning.</li>
				<li><strong class="bold">Tags.COMPONENT</strong>: This value is always <strong class="source-inline">jaxrs.</strong></li>
				<li><strong class="bold">Tags.ERROR</strong>: This tag is only present if a failure (that is, return code 5xx) occurs during the scope of the span. If an exception object is thrown as well, two logs<a id="_idIndexMarker809"/> events<a id="_idIndexMarker810"/> will be added to the span. These are called <strong class="source-inline">event=error</strong> and <strong class="source-inline">error.object=&lt;error object instance&gt;</strong>.</li>
			</ul>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor142"/>Instrumenting the @Traced annotation and injecting a tracer</h2>
			<p>Provided <a id="_idIndexMarker811"/>with MicroProfile OpenTracing is the <strong class="source-inline">@Traced</strong> CDI annotation. This annotation<a id="_idIndexMarker812"/> can be applied to methods and classes. When applied to a class, every method in the class is annotated with <strong class="source-inline">@Traced</strong>. The <strong class="source-inline">@Traced</strong> annotation can be used to further fine-tune the spans that make up the trace. It can also be used to override the default auto-instrumentation of JAX-RS resource methods, such as disabling or renaming the span or to further specify spans on other methods in your application.</p>
			<p> The <strong class="source-inline">@Traced</strong> annotation contains two parameters: </p>
			<ul>
				<li><strong class="bold">value</strong>: This is <a id="_idIndexMarker813"/>a boolean parameter. It is true by default, which implies that the annotated method will be automatically instrumented for tracing. A false value disables automatic tracing for the method. This can be used to disable automatic instrumentation on JAX-RS endpoints. </li>
				<li><strong class="bold">operationName</strong>: This parameter accepts a <strong class="source-inline">String</strong> and defines the name of the span that <a id="_idIndexMarker814"/>would be created when the method is invoked.</li>
			</ul>
			<p>Note that when both a class and a method inside the class use the <strong class="source-inline">@Traced</strong> annotation, the method annotation and its parameters take priority.</p>
			<p>The MicroProfile OpenTracing runtime can also inject an optional <strong class="source-inline">io.opentracing.Tracer</strong> object. Using this OpenTracing object, you can programmatically create and manipulate spans using the OpenTracing API. You can add your own tags, logs, and baggage. We will not cover how to use the OpenTracing API in this boo<a id="_idTextAnchor143"/>k.</p>
			<p>The <a id="_idIndexMarker815"/>following<a id="_idIndexMarker816"/> example shows how to inject the OpenTracing's <strong class="source-inline">Tracer</strong> object, as well as how to use <strong class="source-inline">@Traced</strong> on both a JAX-RS endpoint and a normal business method.</p>
			<p>The full source code for <strong class="source-inline">TraceResource</strong> can be found at <a href="https://bit.ly/3AXmiIr">https://bit.ly/3AXmiIr</a>:</p>
			<p class="source-code">@Path("/traceResource")</p>
			<p class="source-code">public class TraceResource {</p>
			<p class="source-code">   </p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    io.opentracing.Tracer tracer;</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    @Path("automaticTracing")</p>
			<p class="source-code">    @Traced(value=false)</p>
			<p class="source-code">    public String doNotTraceMe(){</p>
			<p class="source-code">        return "Do NOT trace me!";</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Traced(operationName="traceMe")</p>
			<p class="source-code">    public void traceMe(){</p>
			<p class="source-code">       System.out.println("Trace me!");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In the <a id="_idIndexMarker817"/>aforementioned example, <strong class="source-inline">doNotTraceMe()</strong> is <a id="_idIndexMarker818"/>annotated with <strong class="source-inline">@Traced(value=false)</strong>, which alerts the OpenTracing runtime to not trace this JAX-RS endpoint. <strong class="source-inline">traceMe()</strong> is a normal business method and is annotated with <strong class="source-inline">@Traced(operationName="traceMe")</strong> to alert the OpenTracing runtime to trace this as a span if the code path travels to this method. The span is called <strong class="source-inline">"traceMe"</strong>.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor144"/>Visualizing traces with Jaeger</h2>
			<p>For this <a id="_idIndexMarker819"/>demonstration, we'll<a id="_idIndexMarker820"/> use a simple application consisting of two JAX-RS resources called <strong class="source-inline">OutboundRequestResource</strong> and <strong class="source-inline">InboundRequestResource</strong>. We'll issue a GET request to <strong class="source-inline">OutboundRequestResource</strong> at <a href="http://localhost:9080/outbound/tracing">http://localhost:9080/outbound/tracing</a>, which will then create a <strong class="source-inline">ClientBuilder</strong> to send a <strong class="source-inline">GET</strong> request to <strong class="source-inline">InboundRequestResource</strong>. This, in turn, will invoke the <strong class="source-inline">epoch()</strong> method in a <strong class="source-inline">TracedExample</strong> class that's been annotated with <strong class="source-inline">@Traced(operationName="epoch")</strong>. The resulting trace visualization can be seen here:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B17377_06_04.jpg" alt=" Figure 6.4 – Trace inspection in Jaeger&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> Figure 6.4 – Trace inspection in Jaeger</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You <a id="_idIndexMarker821"/>can<a id="_idIndexMarker822"/> find the full <a id="_idIndexMarker823"/>source for <strong class="source-inline">OutBoundTraceResource</strong> at <a href="https://bit.ly/3swFZEb">https://bit.ly/3swFZEb</a>.</p>
			<p class="callout">You can find the full<a id="_idIndexMarker824"/> source for <strong class="source-inline">InBoundTraceResource</strong> at <a href="https://bit.ly/3xZxrXz">https://bit.ly/3xZxrXz</a>.</p>
			<p class="callout">You can find<a id="_idIndexMarker825"/> the full source for <strong class="source-inline">TracedExample</strong> at <a href="https://bit.ly/3y6pHmM">https://bit.ly/3y6pHmM</a>.</p>
			<p>This is a snapshot of what you may expect when inspecting a trace on the Jaeger web client. The preceding figure may be hard to discern, so we will describe it. The top left shows the name of the trace. The trace is named <em class="italic">book: GET:com.packt.microprofile.book.ch6.opentracing.OutBoundTraceResource.tracing</em>. The trace is given the name of the first span in this trace, which is the <strong class="source-inline">GET</strong> request that we issued to the <strong class="source-inline">/tracing</strong> endpoint in <strong class="source-inline">OutBoundTraceResource</strong>. </p>
			<p>The rest of the interface consists of the sequential listing of the spans that make up the trace. When minimized, it will display the duration of each span and their active durations compared to the other spans as solid horizontal bars. When you click on a span entry, it will expand to show more details, such as its contextual data. In the aforementioned figure, the span that was created from the inbound JAX-RS request from <strong class="source-inline">InBoundTraceResource</strong>, as well as the span that was instrumented from the <strong class="source-inline">@Traced</strong> annotation on the <strong class="source-inline">epoch()</strong> method, have been expanded.</p>
			<p>Let's describe the first expanded span, which is the span that was created by the inbound request. It is called <em class="italic">GET:com.packt.microprofile.book.ch6.opentracing.InBoundTraceResource.waiting</em>. Included in the details are its tags, which we discussed earlier in this section; that is, <em class="italic">component</em>, <em class="italic">http.method</em>, <em class="italic">http.status_code</em>, <em class="italic">http.url</em>, and <em class="italic">span.kind</em>. A tag that's appended by Jaeger is in <em class="italic">internal.span.format</em>. The instrumented span does not contain any tags other than the ones provided by Jaeger. </p>
			<p>With the combination of a summary view of a trace and having the ability to view the individual spans that make up the trace, using distributed tracing to profile the paths that a <a id="_idIndexMarker826"/>request <a id="_idIndexMarker827"/>takes is very useful for analyzing performance and latency. In the aforementioned example, we demonstrated distributed tracing with the Jaeger platform. Another distributed tracing platform that provides an instrumentation library and the facilities to view and analyze the<a id="_idIndexMarker828"/> traces is <strong class="bold">Zipkin</strong>. Zipkin isn't included on the list of official tracers in the OpenTracing documentation, but you may find that the MicroProfile OpenTracing runtime you chose supports it. Consult the documentation of your runtime for their list of supported libraries and the necessary steps for configuring it.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor145"/>Summary</h1>
			<p>In this chapter, we explored the three observability technologies offered by the MicroProfile platform; that is, MicroProfile Health, MicroProfile Metrics, and MicroProfile OpenTracing. From reporting the overall health of your application with health checks to the detailed statistical data that metrics provide, to tracking and profiling requests as they travel through your microservices with distributed tracing, each technology has an invaluable purpose that satisfies the important task of monitoring and observing your cloud-native application. Your application has now harnessed all the features and capabilities that the MicroProfile release platform has to offer. There are additional technologies that come with MicroProfile's standalone releases. We will cover these in the final chapters of this book.</p>
			<p>In the next chapter, we will explore the topic of deploying your cloud-native application onto the cloud. We'll see how it interacts with cloud infrastructures such as Docker, Kubernetes, and Istio.</p>
		</div>
	</body></html>