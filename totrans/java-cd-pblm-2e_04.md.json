["```java\npublic class Melon {\n  private final String type;\n  private final float weight;\n  public Melon(String type, float weight) {\n    this.type = type;\n    this.weight = weight;\n  }\n  public String getType() {\n    return type;\n  }\n  public float getWeight() {\n    return weight;\n  }\n  // hashCode(), equals(), and to String()\n} \n```", "```java\npublic record MelonRecord(String type, float weight) {} \n```", "```java\nMelon melon = new Melon(\"Cantaloupe\", 2600);\nMelonRecord melonr = new MelonRecord(\"Cantaloupe\", 2600); \n```", "```java\nMelonRecord melonr = new MelonRecord(\"Cantaloupe\", 2600); \n```", "```java\npublic MelonRecord(String type, float weight) {\n  this.type = type;\n  this.weight = weight;\n} \n```", "```java\npublic MelonRecord {} \n```", "```java\npublic MelonRecord {}   // compact constructor\npublic MelonRecord() {} // constructor with no arguments \n```", "```java\npublic record MelonRecord(String type, float weight) {\n  // explicit canonical constructor for validations\n  public MelonRecord(String type, int weight) {\n    if (type == null) {\n      throw new IllegalArgumentException(\n        \"The melon's type cannot be null\");\n    }\n    if (weight < 1000 || weight > 10000) {\n      throw new IllegalArgumentException(\"The melon's weight \n         must be between 1000 and 10000 grams\");\n    }\n    this.type = type;\n    this.weight = weight;\n  }\n} \n```", "```java\npublic record MelonRecord(String type, float weight) {\n  // explicit compact constructor for validations\n  public MelonRecord {\n    if (type == null) {\n      throw new IllegalArgumentException(\n        \"The melon's type cannot be null\");\n    }\n    if (weight < 1000 || weight > 10000) { \n      throw new IllegalArgumentException(\"The melon's weight \n        must be between 1000 and 10000 grams\");\n    }  \n  }\n} \n```", "```java\n// explicit canonical constructor for reassigning components\npublic MelonRecord(String type, float weight) {\n  weight = weight/1_000; // overwriting the component 'weight'\n  this.type = type;\n  this.weight = weight; \n} \n```", "```java\npublic MelonRecord(String type, float weight) {\n  this.type = type;\n  this.weight = weight/1_000; \n} \n```", "```java\npublic MelonRecord(String type, float weight) {\n  this.type = type;\n  this.weight = weight; \n  weight = weight/1_000;\n} \n```", "```java\npublic record MelonRecord(String type, float weight) {\n  // explicit compact constructor for reassigning components\n  public MelonRecord {\n    weight = weight/1_000; // overwriting the component 'weight'\n  } \n} \n```", "```java\npublic record MarketRecord(Map<String, Integer> retails) {} \n```", "```java\npublic record MarketRecord(Map<String, Integer> retails) {\n  public MarketRecord {\n    retails = Map.copyOf(retails);\n  }\n} \n```", "```java\npublic Map<String, Integer> retails() {\n  return Map.copyOf(retails);\n}\n// or, getter in Java Bean style\npublic Map<String, Integer> getRetails() {\n  return Map.copyOf(retails);\n} \n```", "```java\npublic record MelonRecord(String type, float weight) {\n  public float weightToKg() {\n    return weight / 1_000;\n  }\n} \n```", "```java\nMelonRecord melon = new MelonRecord(\"Cantaloupe\", 2600);\n// 2600.0 g = 2.6 Kg\nSystem.out.println(melon.weight() + \" g = \" \n  + melon.weightToKg() + \" Kg\"); \n```", "```java\npublic record MelonRecord(String type, float weight) {\n  private static final String DEFAULT_MELON_TYPE = \"Crenshaw\";\n  private static final float DEFAULT_MELON_WEIGHT = 1000;\n  public static MelonRecord getDefaultMelon() {\n    return new MelonRecord(\n      DEFAULT_MELON_TYPE, DEFAULT_MELON_WEIGHT);\n  }\n} \n```", "```java\nMelonRecord defaultMelon = MelonRecord.getDefaultMelon(); \n```", "```java\npublic record MelonRecord(String type, float weight) {\n  public static class Slicer {\n    public void slice(MelonRecord mr, int n) {\n      start();\n      System.out.println(\"Slicing a \" + mr.type() + \" of \" \n        + mr.weightToKg() + \" kg in \" + n + \" slices ...\");\n      stop();\n    }\n    private static void start() {\n      System.out.println(\"Start slicer ...\");\n    }\n    private static void stop() {\n      System.out.println(\"Stop slicer ...\");\n    }\n  }\n} \n```", "```java\nMelonRecord.Slicer slicer = new MelonRecord.Slicer();\nslicer.slice(melon, 10);\nslicer.slice(defaultMelon, 14); \n```", "```java\npublic record MelonRecord(String type, float weight) \n  extends Cucurbitaceae {…} \n```", "```java\npublic class PumpkinClass extends MelonRecord {…} \n```", "```java\npublic record MelonRecord(String type, float weight) {\n  private String color;\n  private final String color;\n} \n```", "```java\npublic record MelonRecord(String type, float weight) {\n  private MelonRecord(String type, float weight) {\n    this.type = type;\n    this.weight = weight;\n  }\n  public static MelonRecord newInstance(\n      String type, float weight) {\n    return new MelonRecord(type, weight);\n  } \n} \npublic canonical constructors and private non-canonical constructors that first invoke one of the public canonical constructors.\n```", "```java\npublic record MelonRecord(String type, float weight) {\n   public void setType(String type) {\n     this.type = type;\n   }\n   public void setWeight(float weight) {\n      this.weight = weight;\n   }\n} \n these are the most common.\n```", "```java\npublic record MelonRecord(String type, float weight) {\n  private static final String DEFAULT_MELON_TYPE = \"Crenshaw\";\n  private static final float DEFAULT_MELON_WEIGHT = 1000;\n  MelonRecord() {\n    this(DEFAULT_MELON_TYPE, DEFAULT_MELON_WEIGHT);\n  } \n} \n```", "```java\npublic record MelonRecord(String type, float weight) {\n  private static final String DEFAULT_MELON_TYPE = \"Crenshaw\";\n  private static final float DEFAULT_MELON_WEIGHT = 1000;\n  MelonRecord(String type) {\n    this(type, DEFAULT_MELON_WEIGHT);\n  }\n  MelonRecord(float weight) {\n    this(DEFAULT_MELON_TYPE, weight);\n  } \n} \n```", "```java\npublic record MelonRecord(String type, float weight) {\n  private static Set<String> countries = new HashSet<>();\n  MelonRecord(String type, int weight, String country) {\n    this(type, weight);\n    MelonRecord.countries.add(country);\n  }  \n} \n```", "```java\npublic interface PestInspector {\n  public default boolean detectPest() {\n    return Math.random() > 0.5d;\n  }\n  public void exterminatePest();\n} \n```", "```java\npublic record MelonRecord(String type, float weight)   \n       implements PestInspector {\n  @Override\n  public void exterminatePest() {  \n    if (detectPest()) {\n      System.out.println(\"All pests have been exterminated\");\n    } else {\n      System.out.println(\n        \"This melon is clean, no pests have been found\");\n    }\n  }\n} \n```", "```java\npublic class Melon implements Serializable {\n  private final String type;\n  private final float weight;\n  public Melon(String type, float weight) {\n    this.type = type;\n    this.weight = weight;\n  }\n  // getters, hashCode(), equals(), and toString()\n} \n```", "```java\npublic class MelonContainer implements Serializable {\n  private final LocalDate expiration;\n  private final String batch;\n  private final Melon melon;\n  public MelonContainer(LocalDate expiration, \n      String batch, Melon melon) {\n    ...\n    if (!batch.startsWith(\"ML\")) {\n      throw new IllegalArgumentException(\n        \"The batch format should be: MLxxxxxxxx\");\n    }\n    ...\n    this.expiration = expiration;\n    this.batch = batch;\n    this.melon = melon;\n  }\n  // getters, hashCode(), equals(), and toString()\n} \n```", "```java\npublic record MelonRecord(String type, float weight) \n  implements Serializable {}\npublic record MelonContainerRecord(\n  LocalDate expiration, String batch, Melon melon) \n  implements Serializable {\n  public MelonContainerRecord {\n    ...\n    if (!batch.startsWith(\"ML\")) {\n      throw new IllegalArgumentException(\n        \"The batch format should be: MLxxxxxxxx\");\n    } \n    ...\n  }\n} \n```", "```java\nMelonContainer gacContainer = new MelonContainer(\n  LocalDate.now().plusDays(15), \"ML9000SQA0\", \n    new Melon(\"Gac\", 5000)); \n```", "```java\nMelonContainerRecord gacContainerR = new MelonContainerRecord(\n  LocalDate.now().plusDays(15), \"ML9000SQA0\", \n    new Melon(\"Gac\", 5000)); \n```", "```java\ntry ( ObjectOutputStream oos = new ObjectOutputStream(\n   new FileOutputStream(\"object.data\"))) {\n     oos.writeObject(gacContainer);\n}\ntry ( ObjectOutputStream oos = new ObjectOutputStream(\n   new FileOutputStream(\"object_record.data\"))) {\n     oos.writeObject(gacContainerR);\n} \n```", "```java\nMelonContainer desGacContainer;\ntry ( ObjectInputStream ios = new ObjectInputStream(\n  new FileInputStream(\"object.data\"))) {\n  desGacContainer = (MelonContainer) ios.readObject();\n}\nMelonContainerRecord desGacContainerR;\ntry ( ObjectInputStream ios = new ObjectInputStream(\n  new FileInputStream(\"object_record.data\"))) {\n  desGacContainerR = (MelonContainerRecord) ios.readObject();\n} \n```", "```java\nMelonContainer gacContainer = new MelonContainer(\n  LocalDate.now().plusDays(15), \"ML9000SQA0\", \n    new Melon(\"Gac\", 5000)); \n```", "```java\nMelonContainer{expiration=2023-02-26, \n   **batch=****0000000000**, melon=Melon{type=Gac, weight=5000.0}} \n```", "```java\nMelonContainerRecord gacContainerR = new MelonContainerRecord(\n  LocalDate.now().plusDays(15), \"ML9000SQA0\", \n    new Melon(\"Gac\", 5000)); \n```", "```java\n@Serial\nprivate Object writeReplace() throws ObjectStreamException {\n  return new MelonContainerRecord(expiration, batch, melon);\n} \n```", "```java\n@Serial\nprivate Object readResolve() throws ObjectStreamException {\n  return new MelonContainer(expiration, batch, melon);\n} \n```", "```java\n// this method is from the official documentation of JDK\n// https://docs.oracle.com/en/java/javase/19/docs/api/\n// java.base/java/lang/Class.html#getRecordComponents()\npublic static <T extends Record> Constructor<T>\n      getCanonicalConstructor(Class<T> cls)\n          throws NoSuchMethodException {\n  Class<?>[] paramTypes\n    = Arrays.stream(cls.getRecordComponents())\n            .map(RecordComponent::getType)\n            .toArray(Class<?>[]::new);\n  return cls.getDeclaredConstructor(paramTypes);\n} \n```", "```java\npublic record MelonRecord(String type, float weight) {}\npublic record MelonMarketRecord(\n  List<MelonRecord> melons, String country) {} \n```", "```java\nConstructor<MelonRecord> cmr = \n   Records.getCanonicalConstructor(MelonRecord.class);\nMelonRecord m1 = cmr.newInstance(\"Gac\", 5000f);\nMelonRecord m2 = cmr.newInstance(\"Hemi\", 1400f);\nConstructor<MelonMarketRecord> cmmr = \n   Records.getCanonicalConstructor(MelonMarketRecord.class);\n  MelonMarketRecord mm = cmmr.newInstance(\n     List.of(m1, m2), \"China\"); \n```", "```java\npublic record MelonRecord(String type, float weight) {} \n```", "```java\nList<MelonRecord> melons = Arrays.asList(\n  new MelonRecord(\"Crenshaw\", 1200),\n  new MelonRecord(\"Gac\", 3000), \n  new MelonRecord(\"Hemi\", 2600),\n  ...\n); \n```", "```java\npublic record WeightsAndTotalRecord(\n  double totalWeight, List<Float> weights) {} \n```", "```java\nWeightsAndTotalRecord weightsAndTotal = melons.stream()\n  .collect(Collectors.teeing(\n     summingDouble(MelonRecord::weight),\n     mapping(MelonRecord::weight, toList()),\n     WeightsAndTotalRecord::new\n)); \n```", "```java\nMap<Double, Long> elevations = DoubleStream.of(\n      22, -10, 100, -5, 100, 123, 22, 230, -1, 250, 22)\n  .filter(e -> e > 0)\n  .map(e -> e * 0.393701)   \n  .mapToObj(e -> (double) e)\n  .collect(Collectors.groupingBy(\n     Function.identity(), counting())); \n```", "```java\nrecord Elevation(double value) { \n  Elevation(double value) { \n    this.value = value * 0.393701;\n  } \n}\nrecord ElevationCount(long count) {} \n```", "```java\nMap<Elevation, ElevationCount> elevations = DoubleStream.of(\n      22, -10, 100, -5, 100, 123, 22, 230, -1, 250, 22)\n  .filter(e -> e > 0)                \n  .mapToObj(Elevation::new)\n  .collect(Collectors.groupingBy(Function.identity(), \n           Collectors.collectingAndThen(counting(), \n             ElevationCount::new))); \n```", "```java\npublic record Doctor(String name, String specialty) \n  implements Staff {} \n```", "```java\npublic static String cabinet(Staff staff) {\n  if (staff instanceof Doctor) {\n    Doctor dr = (Doctor) staff;\n    return \"Cabinet of \" + dr.specialty() \n      + \". Doctor: \" + dr.name();\n  }\n  ...\n} \n```", "```java\npublic static String cabinet(Staff staff) {\n  if (staff instanceof Doctor dr) { // type pattern matching\n    return \"Cabinet of \" + dr.specialty() \n       + \". Doctor: \" + dr.name();\n  }\n  ...\n} \n```", "```java\npublic static String cabinet(Staff staff) { \n  // record pattern matching\n  if (staff instanceof **Doctor****(String name, String specialty)**){ \n    return \"Cabinet of \" + name + \". Doctor: \" + specialty;\n  }\n  ...\n} \n```", "```java\npublic record Resident(String name, Doctor doctor) \n  implements Staff {} \n```", "```java\npublic static String cabinet(Staff staff) { \n  if (staff instanceof Resident(String rsname, \n      Doctor(String drname, String specialty))) { \n    return \"Cabinet of \" + specialty + \". Doctor: \" \n                         + drname + \", Resident: \" + rsname;\n  }  \n  ...\n} \n```", "```java\nif (staff instanceof Resident(String name, Doctor dr)) { \n  return \"Cabinet of \" + dr.specialty() + \". Doctor: \" \n                       + dr.name() + \", Resident: \" + name;\n} \n```", "```java\npublic record Appointment(LocalDate date, Doctor doctor) {}\npublic record Patient(\n  String name, int npi, Appointment appointment) {} \n```", "```java\npublic static String reception(Object o) {\n  if (o instanceof Patient(var ptname, var npi, \n                  Appointment(var date, \n                  Doctor (var drname, var specialty)))) {\n   return \"Patient \" + ptname + \" (NPI: \" + npi\n          + \") has an appointment at \"\n          + date + \" to the doctor \" + drname\n          + \" (\" + specialty + \").\";\n  }\n  ...\n} \n```", "```java\nif (o instanceof Patient(\n    var ptname, var npi, var ap)) {\n  return \"Patient \" + ptname + \" (NPI: \" + npi\n       + \") has an appointment at \"\n       + ap.date() + \" to the doctor \" + ap.doctor().name() \n       + \" (\" + ap.doctor().specialty() + \").\";\n} \n```", "```java\npublic record Doctor(String name, String specialty) \n  implements Staff {}\npublic record Resident(String name, Doctor doctor) \n  implements Staff {} \n```", "```java\npublic static String cabinet(Staff staff) {\n return switch(staff) {  \n  case Doctor(var name, var specialty) \n    -> \"Cabinet of \" + specialty + \". Doctor: \" + name;\n  case Resident(var rsname, Doctor(var drname, var specialty)) \n    -> \"Cabinet of \" + specialty + \". Doctor: \" \n                     + drname + \", Resident: \" + rsname;\n  default -> \"Cabinet closed\";\n }; \n} \n```", "```java\npublic record Appointment(LocalDate date, Doctor doctor) {}\npublic record Patient(\n  String name, int npi, Appointment appointment) {} \n```", "```java\npublic static String reception(Object o) {\n  return switch(o) {           \n    case Patient(String ptname, int npi, \n         Appointment(LocalDate date, \n         Doctor (String drname, String specialty))) ->\n           \"Patient \" + ptname + \" (NPI: \" + npi\n              + \") has an appointment at \"\n              + date + \" to the doctor \" + drname + \" (\" \n              + specialty + \").\";\n    default -> \"\";\n  };\n} \n```", "```java\nreturn switch(o) {\n  case Patient(var ptname, var npi, var ap) ->\n    \"Patient \" + ptname + \" (NPI: \" \n    + npi + \") has an appointment at \"\n    + ap.date() + \" to the doctor \" + ap.doctor().name() \n    + \" (\" + ap.doctor().specialty() + \").\";\n  default -> \"\";\n}; \n```", "```java\npublic static String cabinet(Staff staff) {\n  if (staff instanceof Doctor(String name, String specialty) \n       && (specialty.equals(\"Allergy\") \n       && (name.equals(\"Kyle Ulm\")))) { \n     return \"The cabinet of \" + specialty \n       + \" is closed. The doctor \" \n       + name + \" is on holiday.\";\n  }                \n  if (staff instanceof Doctor(String name, String specialty) \n      && (specialty.equals(\"Allergy\") \n      && (name.equals(\"John Hora\")))) { \n    return \"The cabinet of \" + specialty \n      + \" is open. The doctor \" \n      + name + \" is ready to receive patients.\";\n  }\n  return \"Cabinet closed\";\n} \n```", "```java\nif (staff instanceof Resident(String rsname, \n    Doctor(String drname, String specialty))\n       && (specialty.equals(\"Dermatology\") \n       && rsname.equals(\"Mark Oil\"))) { \n  return \"Cabinet of \" + specialty + \". Doctor \" \n    + drname + \" and resident \" + rsname\n    + \" are ready to receive patients.\";\n} \n```", "```java\npublic static String reception(Object o) {\n  if (o instanceof Patient(var ptname, var npi,\n                  Appointment(var date,\n                  Doctor (var drname, var specialty)))\n     && (ptname.equals(\"Alicia Goy\") && npi == 1234567890\n     && LocalDate.now().equals(date))) {\n    return \"The doctor \" + drname + \" from \" + specialty\n                         + \" is ready for you \" + ptname;\n  }\n  return \"\";\n} \n```", "```java\npublic static String cabinet(Staff staff) {\n  return switch(staff) {             \n    case Doctor(var name, var specialty) \n      when specialty.equals(\"Dermatology\") \n        -> \"The cabinet of \" + specialty \n              + \" is currently under renovation\";\n    case Doctor(var name, var specialty) \n      when (specialty.equals(\"Allergy\") \n      && (name.equals(\"Kyle Ulm\"))) \n        -> \"The cabinet of \" + specialty \n              + \" is closed. The doctor \" + name \n              + \" is on holiday.\";\n    case Doctor(var name, var specialty) \n      when (specialty.equals(\"Allergy\") \n      && (name.equals(\"John Hora\"))) \n        -> \"The cabinet of \" + specialty \n              + \" is open. The doctor \" + name \n              + \" is ready to receive patients.\";\n    case Resident(var rsname, \n        Doctor(var drname, var specialty)) \n      when (specialty.equals(\"Dermatology\") \n      && rsname.equals(\"Mark Oil\")) \n        -> \"Cabinet of \" + specialty + \". Doctor \" \n               + drname + \" and resident \" + rsname\n               + \" are ready to receive patients.\";\n    default -> \"Cabinet closed\";\n  };                \n} \n```", "```java\npublic static String reception(Object o) {\n  return switch(o) {\n    case Patient(String ptname, int npi, \n         Appointment(LocalDate date, \n         Doctor (String drname, String specialty)))\n      when (ptname.equals(\"Alicia Goy\") \n      && npi == 1234567890 && LocalDate.now().equals(date)) \n        -> \"The doctor \" + drname + \" from \" + specialty \n           + \" is ready for you \" + ptname;\n    default -> \"\";\n  };                \n} \n```", "```java\npublic record FruitRecord<T>(T t, String country) {} \n```", "```java\npublic record MelonRecord(String type, float weight) {} \n```", "```java\nFruitRecord<MelonRecord> fruit = \n  new FruitRecord<>(new MelonRecord(\"Hami\", 1000), \"China\"); \n```", "```java\nif (fruit instanceof FruitRecord<MelonRecord>(\n    MelonRecord melon, String country)) {\n  System.out.println(melon + \" from \" + country);\n} \n```", "```java\nswitch(fruit) {\n  case FruitRecord<MelonRecord>(\n       MelonRecord melon, String country) :\n    System.out.println(melon + \" from \" + country); break;\n  default : break; \n}; \n```", "```java\nif (fruit instanceof FruitRecord<MelonRecord>(\n    var melon, var country)) {\n  System.out.println(melon + \" from \" + country);\n} \n```", "```java\nif (fruit instanceof FruitRecord(var melon, var country)) {\n  System.out.println(melon + \" from \" + country);\n} \n```", "```java\nswitch (fruit) {\n  case FruitRecord<MelonRecord>(var melon, var country) :\n    System.out.println(melon + \" from \" + country); break;\n  default : break;\n}; \n```", "```java\nswitch (fruit) {\n  case FruitRecord(var melon, var country) :\n    System.out.println(melon + \" from \" + country); break;\n  default : break;\n}; \n```", "```java\npublic record EngineRecord<X, Y, Z>(X x, Y y, Z z) {} \n```", "```java\nEngineRecord<String, Integer, String> engine\n  = new EngineRecord(\"TV1\", 661, \"Water cooled\"); \n```", "```java\nif (engine instanceof EngineRecord<String, Integer, String>\n   (var type, var power, var cooling)) {\n  System.out.println(type + \" - \" + power + \" - \" + cooling);\n}\n// or, more concise\nif (engine instanceof EngineRecord(\n    var type, var power, var cooling)) {\n  System.out.println(type + \" - \" + power + \" - \" + cooling);\n} \n```", "```java\nswitch (engine) {\n  case EngineRecord<String, Integer, String>(\n      var type, var power, var cooling) :\n    System.out.println(type + \" - \"\n                                + power + \" - \" + cooling);\n  default : break;\n};\n// or, more concise\nswitch (engine) {\n  case EngineRecord(var type, var power, var cooling) :\n    System.out.println(type + \" - \"\n                            + power + \" - \" + cooling);\n  default : break;\n}; \n```", "```java\npublic record ContainerRecord<C>(C c) {} \n```", "```java\nContainerRecord<String> innerContainer\n  = new ContainerRecord(\"Inner container\");\nContainerRecord<ContainerRecord<String>> container\n  = new ContainerRecord(innerContainer); \n```", "```java\nif (container instanceof\n    ContainerRecord<ContainerRecord<String>>(\n      ContainerRecord(var c))) {\n  System.out.println(c);\n} \n```", "```java\nif (container instanceof ContainerRecord(\n    ContainerRecord(var c))) {\n      System.out.println(c);\n} \n```", "```java\nif (container instanceof\n    ContainerRecord<ContainerRecord<String>>(var c)) {\n  System.out.println(c);\n} \n```", "```java\ncase null -> throw new IllegalArgumentException(...); \nnull values only it will not allow the execution of that branch. The switch expressions will throw a NullPointerException without even looking at the patterns.\n```", "```java\npublic interface Fruit {}\npublic record SeedRecord(String type, String country) \n  implements Fruit {}\npublic record MelonRecord(SeedRecord seed, float weight) \n  implements Fruit {}\npublic record EggplantRecord(SeedRecord seed, float weight) \n  implements Fruit {} \n```", "```java\npublic static String buyFruit(Fruit fruit) {\n  return switch(fruit) {\n    case null -> \"Ops!\";\n    case SeedRecord(String type, String country) \n      -> \"This is a seed of \" + type + \" from \" + country;\n    case EggplantRecord(SeedRecord seed, float weight) \n      -> \"This is a \" + seed.type() + \" eggplant\";\n    case MelonRecord(SeedRecord seed, float weight) \n      -> \"This is a \" + seed.type() + \" melon\";\n    case Fruit v -> \"This is an unknown fruit\";\n  };\n} \n```", "```java\nSeedRecord seed = new SeedRecord(\"Fairytale\", \"India\");\nEggplantRecord eggplant = new EggplantRecord(seed, 300); \n```", "```java\nEggplantRecord badEggplant = new EggplantRecord(null, 300); \n```", "```java\ncase EggplantRecord(SeedRecord seed, float weight) \n     when seed == null -> \"Ops! What's this?!\"; \n```", "```java\npublic static String buyFruit(Fruit fruit) {\n  if (fruit instanceof SeedRecord(\n      String type, String country)) {\n     return \"This is a seed of \" + type + \" from \" + country;\n  }\n  if (fruit instanceof EggplantRecord(\n      SeedRecord seed, float weight)) {\n    return \"This is a \" + seed.type() + \" eggplant\";\n  } \n  if (fruit instanceof MelonRecord(\n      SeedRecord seed, float weight)) {\n    return \"This is a \" + seed.type() + \" melon\";\n  } \n  return \"This is an unknown fruit\";\n} \n```", "```java\nif (fruit instanceof EggplantRecord(null, float weight)) {\n  return \"Ops! What's this?!\";\n} \n```", "```java\nif (fruit instanceof EggplantRecord(\n    SeedRecord seed, float weight) && seed == null) {\n  return \"Ops! What's this?!\";\n} \n```", "```java\ninterface Str {}\nrecord Literal(String text) implements Str {}\nrecord Variable(String name) implements Str {}\nrecord Concat(Str first, Str second) implements Str {} \n```", "```java\npublic static Str shortener(Str str) {\n  if (str instanceof Concat s) {\n    if (s.first() instanceof Variable first \n       && s.second() instanceof Literal second \n       && second.text().isBlank()) {\n          return first;\n    } else if (s.first() instanceof Literal first \n       && s.second() instanceof Variable second \n       && first.text().isBlank()) {\n          return second;\n    } \n  }\n  return str;\n} \n```", "```java\npublic static Str shortener(Str str) {\n  return switch (str) { \n    case Concat(Variable(var name), Literal(var text)) \n      when text.isBlank() -> new Variable(name); \n    case Concat(Literal(var text), Variable(var name)) \n      when text.isBlank() -> new Variable(name);\n    default -> str;\n  }; \n} \n```", "```java\nif (staff instanceof Doctor(String name, String specialty)) {\n  return \"The cabinet of \" + specialty\n       + \" is currently under renovation\";\n} \n```", "```java\nif (staff instanceof Doctor(_, String specialty)) {\n  return \"The cabinet of \" + specialty\n        + \" is currently under renovation\";\n} \n```", "```java\nif (staff instanceof Resident(String name, Doctor dr)) {\n  return \"The resident of this cabinet is : \" + name;\n} \n```", "```java\nif (staff instanceof Resident(String name, _)) {\n  return \"The resident of this cabinet is : \" + name;\n} \n```", "```java\nif (staff instanceof Resident(String rsname,\n      Doctor(String drname, _))) {\n    return \"This is the cabinet of doctor \" + drname\n         + \" and resident \" + rsname;\n} \n```", "```java\nif (o instanceof Patient(var ptname, var npi,\n                    Appointment(var date,\n                    Doctor (var drname, var specialty)))) {\n  return \"Patient \" + ptname\n       + \" has an appointment for the date of \" + date;\n} \n```", "```java\nif (o instanceof Patient(var ptname, _,\n                    Appointment(var date, _))) {\n  return \"Patient \" + ptname\n       + \" has an appointment for the date of \" + date;\n} \n```", "```java\nif (o instanceof Patient(var ptname, _, _)) {\n  return \"Patient \" + ptname + \" has an appointment\";\n} \n```", "```java\nif (o instanceof Patient pt) {\n  return \"Patient \" + pt.name() + \" has an appointment\";\n} \n```", "```java\n// without unnamed patterns\nreturn switch(staff) {\n  case Doctor(String name, String specialty) ->\n      \"The cabinet of \" + specialty\n    + \" is currently under renovation\";\n  case Resident(String name, Doctor dr) ->\n      \"The resident of this cabinet is : \" + name;\n  default -> \"Cabinet closed\";\n};\n// with unnamed patterns\nreturn switch(staff) {\n  case Doctor(_, String specialty) ->\n      \"The cabinet of \" + specialty\n    + \" is currently under renovation\";\n  case Resident(String name, _) ->\n      \"The resident of this cabinet is : \" + name;\n  default -> \"Cabinet closed\";\n}; \n```", "```java\n// without unnamed patterns\nreturn switch(o) {\n  case Patient(String ptname, int npi,\n               Appointment(LocalDate date,\n               Doctor (String drname, String specialty))) ->\n      \"Patient \" + ptname + \" has an appointment\";\n  default -> \"\";\n};\n// with unnamed patterns\nreturn switch(o) {\n  case Patient(String ptname, _, _) ->\n      \"Patient \" + ptname + \" has an appointment\";\n  default -> \"\";\n}; \n```", "```java\npublic sealed abstract class EngineType\n  permits ESSEngine, DSLEngine, LPGEngine {}\npublic final class ESSEngine extends EngineType {}\npublic final class DSLEngine extends EngineType {}\npublic final class LPGEngine extends EngineType {}\npublic record Car<E extends EngineType>(E engineType) {} \n```", "```java\npublic static String addCarburetor(Car c) {\n  return switch(c) {\n    case Car(DSLEngine dsl), Car(ESSEngine ess)\n      -> \"Adding a carburetor to a ESS or DSL car\";\n    case Car(LPGEngine lpg)\n      -> \"Adding a carburetor to a LPG car\";\n  };\n} \n```", "```java\npublic static String addCarburetor(Car c) {\n  return switch(c) {\n    case Car(DSLEngine _), Car(ESSEngine _)\n      -> \"Adding a carburetor to a ESS or DSL car\";\n    case Car(LPGEngine lpg)\n      -> \"Adding a carburetor to a LPG car\";\n  };\n} \n```", "```java\npublic static String addCarburetor(Car c, int carburetorType){\n  return switch(c) {\n    case Car(DSLEngine _), Car(ESSEngine _)\n      when carburetorType == 1\n        -> \"Adding a carburetor of type 1 to a ESS or DSL car\";\n    case Car(DSLEngine _), Car(ESSEngine _)\n        -> \"Adding a carburetor of tpye \"\n           + carburetorType + \" to a ESS or DSL car\";\n    case Car(LPGEngine lpg) -> \"Adding a carburetor \"\n           + carburetorType + \" to a LPG car\";\n  };\n} \n```", "```java\nArithmeticException but we log a friendly message that doesn’t use the exception parameter:\n```", "```java\nint divisor = 0;\ntry {\n  int result = 1 / divisor;\n  // use result\n} catch (ArithmeticException _) {\n  System.out.println(\"Divisor \" + divisor + \" is not good\");\n} \n```", "```java\nlogLoopStart() but we don’t use the returned result:\n```", "```java\nint[] arr = new int[]{1, 2, 3};\nfor (int i = 0, _ = logLoopStart(i); i < arr.length; i++) {\n  // use i\n} \nfor loop but we don’t use the cards:\n```", "```java\nint score = 0;\nList<String> cards = List.of(\n  \"12 spade\", \"6 diamond\", \"14 diamond\");\nfor (String _ : cards) {\n  if (score < 10) {\n    score ++;\n  } else {\n    score --;\n  }\n} \n```", "```java\nFiles.deleteIfExists(Path.of(\"/file.txt\")); \n```", "```java\nboolean success = Files.deleteIfExists(Path.of(\"/file.txt\"));\nif (success) { ... } \n```", "```java\nboolean _ = Files.deleteIfExists(Path.of(\"/file.txt\"));\nvar _ = Files.deleteIfExists(Path.of(\"/file.txt\")); \n```", "```java\ntry (Arena _ = Arena.ofConfined()) {\n  // don't use arena\n} \n```", "```java\ntry (var _ = Arena.ofConfined()) {\n  // don't use arena\n} \n```", "```java\nList<Melon> melons = Arrays.asList(…);\nMap<String, Integer> resultToMap = melons.stream()\n  .collect(Collectors.toMap(Melon::getType, Melon::getWeight,\n    (oldValue, _) -> oldValue)); \n```", "```java\n@GetMapping(\"/authors\")\npublic List<Author> fetchAuthors() {\n  return bookstoreService.fetchAuthors();\n} \n```", "```java\npublic record Book(String title, String isbn) {}\npublic record Author(\n  String name,  String genre, List<Book> books) {} \n```", "```java\n@GetMapping(\"/bookstore\")\npublic String bookstorePage(Model model) {\n  model.addAttribute(\"authors\", \n    bookstoreService.fetchAuthors());\n  return \"bookstore\";\n} \n```", "```java\n…\n<ul th:each=\"author : ${authors}\">\n  <li th:text=\"${author.name} + ' (' \n             + ${author.genre} + ')'\" />\n  <ul th:each=\"book : ${author.books}\">\n    <li th:text=\"${book.title}\" />\n  </ul>\n</ul>\n… \n```", "```java\nbookstore.bestseller.author=Joana Nimar\nbookstore.bestseller.book=Prague history \n```", "```java\n@ConfigurationProperties(prefix = \"bookstore.bestseller\")\npublic record BestSellerConfig(String author, String book) {} \n```", "```java\n@Service\npublic class BookstoreService {\n  private final BestSellerConfig bestSeller;\n  public BookstoreService(BestSellerConfig bestSeller) {\n    this.bestSeller = bestSeller;\n  }\n  public String fetchBestSeller() {\n    return bestSeller.author() + \" | \" + bestSeller.book();\n  }\n} \n```", "```java\n@RestController\npublic class BookstoreController {\n  private final BookstoreService bookstoreService;\n  public BookstoreController(\n       BookstoreService bookstoreService) {\n    this.bookstoreService = bookstoreService;\n  }\n  @GetMapping(\"/authors\")\n  public List<Author> fetchAuthors() {\n    return bookstoreService.fetchAuthors();\n  }\n} \n```", "```java\n@RestController\npublic record BookstoreController(\n     BookstoreService bookstoreService) {\n  @GetMapping(\"/authors\")\n  public List<Author> fetchAuthors() {\n    return bookstoreService.fetchAuthors();\n  }\n} \n```", "```java\npublic record AuthorDto(String name, int age) {} \n```", "```java\n@Repository\npublic interface AuthorRepository\n   extends JpaRepository<Author, Long> {\n  @Transactional(readOnly = true)    \n  List<AuthorDto> findByGenre(String genre);\n} \n```", "```java\n@Repository\npublic interface AuthorRepository\n     extends JpaRepository<Author, Long> {\n  @Transactional(readOnly = true)\n  @Query(value = \"SELECT\n         new com.bookstore.dto.AuthorDto(a.name, a.age) \n         FROM Author a\")\n  List<AuthorDto> fetchAuthors();\n} \n```", "```java\npublic record BookDto(Long id, String title) {}\npublic record AuthorDto(Long id, String name, \n       int age, List<BookDto> books) {\n  public void addBook(BookDto book) {\n    books().add(book);\n  }\n} \n```", "```java\npublic class AuthorBookTransformer implements\n       TupleTransformer, ResultListTransformer {\n  private final Map<Long, AuthorDto>\n    authorsDtoMap = new HashMap<>();\n  @Override\n  public Object transformTuple(Object[] os, String[] strings){\n    Long authorId = ((Number) os[0]).longValue();\n    AuthorDto authorDto = authorsDtoMap.get(authorId);\n    if (authorDto == null) {\n      authorDto = new AuthorDto(((Number) os[0]).longValue(), \n             (String) os[1], (int) os[2], new ArrayList<>());\n    }\n    BookDto bookDto = new BookDto(\n      ((Number) os[3]).longValue(), (String) os[4]);\n    authorDto.addBook(bookDto);\n    authorsDtoMap.putIfAbsent(authorDto.id(), authorDto);\n    return authorDto;\n  }\n  @Override\n  public List<AuthorDto> transformList(List list) { \n    return new ArrayList<>(authorsDtoMap.values());\n  }\n} \n```", "```java\n@Repository\n@Transactional(readOnly = true)\npublic class AuthorExtractor {\n  private final JdbcTemplate jdbcTemplate;\n  public AuthorExtractor(JdbcTemplate jdbcTemplate) {\n    this.jdbcTemplate = jdbcTemplate;\n  }\n  public List<AuthorDto> extract() {\n    String sql = \"SELECT a.id, a.name, a.age, b.id, b.title \"\n    + \"FROM author a INNER JOIN book b ON a.id = b.author_id\";\n    List<AuthorDto> result = jdbcTemplate.query(sql, \n     (ResultSet rs) -> {\n      final Map<Long, AuthorDto> authorsMap = new HashMap<>();\n      while (rs.next()) {\n        Long authorId = (rs.getLong(\"id\"));\n        AuthorDto author = authorsMap.get(authorId);\n        if (author == null) {\n          author = new AuthorDto(rs.getLong(\"id\"),\n            rs.getString(\"name\"), \n              rs.getInt(\"age\"), new ArrayList()); \n        }\n        BookDto book = new BookDto(rs.getLong(\"id\"), \n          rs.getString(\"title\")); \n        author.addBook(book);\n        authorsMap.putIfAbsent(author.id(), author);\n      }\n      return new ArrayList<>(authorsMap.values());\n    });\n    return result;\n  }\n} \n```", "```java\n@Embeddable\npublic record Contact(\n  String email, String twitter, String phone) {} \n```", "```java\n@Entity\npublic class Author implements Serializable {\n  private static final long serialVersionUID = 1L;\n  @Id\n  @GeneratedValue(strategy = GenerationType.IDENTITY)\n  private Long id;\n  @Embedded\n  private Contact contact;\n  private int age;\n  private String name;\n  private String genre;\n  ...\n} \n```", "```java\npublic record AuthorDto(\n  String name, int age, Contact contact) {} \n```", "```java\n@Repository\npublic interface AuthorRepository\n   extends JpaRepository<Author, Long> {\n  @Transactional(readOnly = true)    \n  List<AuthorDto> findByGenre(String genre);\n} \n```", "```java\n[AuthorDto[name=Mark Janel, age=23, \n   contact=**Contact[email=mark.janel****@yahoo****.com,** \n                   **twitter=****@markjanel****, phone=+****40198503**]] \n```", "```java\npublic record RecordProduct(String productName, \n  String productVendor, Integer quantityInStock) {}\npublic record RecordProductLine(String productLine, \n  String textDescription, List<RecordProduct> products) {} \n```", "```java\nList<RecordProductLine> resultRecord = ctx.select(\n  PRODUCTLINE.PRODUCT_LINE, PRODUCTLINE.TEXT_DESCRIPTION,\n    multiset(\n      select(\n          PRODUCT.PRODUCT_NAME, PRODUCT.PRODUCT_VENDOR, \n          PRODUCT.QUANTITY_IN_STOCK)\n        .from(PRODUCT)\n        .where(PRODUCTLINE.PRODUCT_LINE.eq(\n               PRODUCT.PRODUCT_LINE))\n        ).as(\"products\").convertFrom(\n           r -> r.map(mapping(RecordProduct::new))))\n         .from(PRODUCTLINE)\n         .orderBy(PRODUCTLINE.PRODUCT_LINE)\n         .fetch(mapping(RecordProductLine::new)); \n```"]