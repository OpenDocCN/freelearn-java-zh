<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Assessments</h1>
                </header>
            
            <article>
                


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 1</h1>
                </header>
            
            <article>
                
<ol>
<li>Specify what you want to do without specifying how exactly to do it.</li>
<li>Don't Repeat Yourself.</li>
<li>Goto is a lower-level primitive used to construct higher-level logic. All the logic that can be done with goto is doable with loops and other control structures. Declaring that you want to have a chunk of code looped excludes the possibility of bugs you would have if you tried to implement that loop by yourself, via goto.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 2</h1>
                </header>
            
            <article>
                
<ol>
<li>As behaviors of their objects.</li>
<li>As mathematical functions. Computations of a value based on some input values without side effects.</li>
<li>Functions that accept other functions as their inputs.</li>
<li>One application is to write control structures.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 3</h1>
                </header>
            
            <article>
                
<ol>
<li>You specify what needs to be done algorithmically, with the help of the low-level operations defined in the imperative collections.</li>
<li>You specify your program as an expression, with the help of high-level operations defined in the functional collections.</li>
<li>All the algorithms you may need are already implemented in the framework. You only need to call them by name when you need them. All the programs you may want to write can be expressed as a combination of the high-level operations implemented in the framework.</li>
</ol>
<p> </p>
<ol start="4">
<li>Understand the program as a mathematical expression rather than an algorithm. An expression is a structure that consists of operands (data) bound together by operators (behavior).</li>
<li>Lesser mental load on the programmer's mind. Algebraic programs usually remove side effects such as errors or time from the equation. So you do not need to think about them. This is in contrast to imperative programs where side effects occur freely and you need to keep them all in mind.</li>
<li>They reify side effects. Reification means turning phenomena into data. For example, instead of throwing an exception (phenomenon), we can return a data structure with that exception object from a method.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 4</h1>
                </header>
            
            <article>
                
<ol>
<li><span>For this book, side effects are defined as modifications and interactions with the environment outside the scope of the current unit of logic (function).</span></li>
<li><span>It is a data that can be changed by the program.</span></li>
<li><span>They cause extra mental load on your mind, which may lead to bugs. There are much more things to keep in mind with side effects and mutable state. The scope of your attention must extend much further than the piece of logic that you are working on at the moment.</span></li>
<li><span>It is a function that does not produce any side effects.</span></li>
<li><span>The ability to substitute a call to a function with the result of that call in code without changing the semantics of that code.</span></li>
<li><span>Decrease the mental load you face. Hence decrease the possibility of bugs.</span></li>
<li><span>Errors, an absence of a result, delayed competition, logging, input-output operations.</span></li>
<li><span>Yes, it is. Programming in the purely functional style is just a matter of understanding the concepts of side effects, understanding how they are harmful, being able to see the side effects and their harm in code, and knowledge on how to abstract them away. It is possible to write abstractions for side effects in modern imperative programming languages.</span></li>
<li><span>It is the presence of the infrastructure to support you. Most of the abstractions you may need are already present in the language. Most of the libraries are functional. The community is also likely to be oriented to the functional style.</span></li>
</ol>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 5</h1>
                </header>
            
            <article>
                
<ol>
<li>The first order reality is the reality of their business domain. The reality of the business domain is the reality in which the programming is solving their business task. The second-order reality is the reality of writing and running a program.</li>
<li>It provides a set of techniques to abstract away the phenomena of the second-order reality.  First, you need to identify a repeating phenomenon. Then, you need to create a data structure to abstract away this phenomenon. The idea is to abstract away the phenomena by describing them, without actually making them happen.</li>
<li>The control over how the program runs and how its codebase is structured.  If left without control, the complexity of the second-order reality can overwhelm you and cause mental load.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 6</h1>
                </header>
            
            <article>
                
<ol>
<li>Asynchronous computations.</li>
<li>Try represents the erroneous case as an exception. Exceptions may not always be desirable in a functional context since they make sense only when we want to throw them. Functional programming discourages throwing exceptions since they are side effects. Hence, we have a more general type called Either that is capable of representing an alternative between any two values.</li>
<li>One way of representing dependency injection in functional programming is via the Reader type. It is an abstraction of the fact that a computation depends on some value and cannot be executed without it. Reader is basically a function. However, it has a more concise signature, and the concept of continuation with flatmap is applied to it the same way as to any other effect type.</li>
<li>Flatmap allows you to sequentially compose side-effecting computations that use effect types to represent side effects.</li>
</ol>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 7</h1>
                </header>
            
            <article>
                
<ol>
<li>In Scala, Rich Wrapper is a pattern that allows you to simulate method injection into classes.</li>
<li>The pattern is implemented in Scala using the implicit conversions mechanism. Whenever you are trying to call a method on a class that doesn't have this method, the compiler tries to convert the instance of that class into another class that has this method.</li>
<li>See the explanation in the Intuition section in Chapter 7.</li>
<li>The motivation behind the type class pattern is to separate the effect types from their behaviour so that it is possible to define new behaviours and inject them into existing type classes based on different scenarios that arise when performing functional programming.</li>
<li>Yes, imperative languages do have type classes. However, in general, they lack mechanisms for their convenient usage.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 8</h1>
                </header>
            
            <article>
                
<ol>
<li><span>The type classes repeat from project to project. Hence, it makes sense to unify them into libraries.</span></li>
<li><kbd>foldLeft</kbd>, <kbd>foldRight</kbd>, <kbd>traverse</kbd>.</li>
<li>Composition of a list of effectful computations.</li>
<li><kbd>flatMap</kbd>, <kbd>pure</kbd>, <kbd>tailRecM</kbd>.</li>
<li>Sequential composition of two computations, one of which depends on the result of another.</li>
<li>Core package with type classes, <kbd>syntax</kbd> package with rich wrappers to inject syntax into effect types, <kbd>instances</kbd> package with the type class implementations for some effect types, <kbd>data</kbd> package with effect types for functional programming. Also, Cats has some auxiliary packages for more specific tasks not discussed in the book. Consult Cats documentation to learn about these.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 9</h1>
                </header>
            
            <article>
                
<ol>
<li>Blocking computations block the thread they are using in case they need to wait for some event to happen. Non-blocking computations release the thread if they don't need it. Released threads can be reused by other tasks.</li>
<li>You need asynchronous programming so that the threads are utilized doing useful work and not waiting upon an event to happen.</li>
<li>You can separate the business logic from the strategy of concurrent execution.</li>
<li> <kbd>IO</kbd><span>  is an effect type which encapsulates the side effect of delayed computations. It uses the computation-as-a-value approach, and thus is a specification of the computation to be performed.</span></li>
<li><kbd>start</kbd> to start <kbd>IO</kbd> asynchronously from a monadic flow. <kbd>flatMap</kbd> to compose <kbd>IO</kbd> with other <kbd>IO</kbd>s sequentially. Please see API documentation of <kbd>IO</kbd> for the full list.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 10</h1>
                </header>
            
            <article>
                
<ol>
<li>Monad Transformers are used to combine two effect types into one.</li>
<li>Tagless Final allows to delay the choice of an effect type and compose the program in terms of the capabilities this effect type must have.</li>
<li>Type-level computations allow to identify more errors on compile time, hence increasing compile-time safety.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 11</h1>
                </header>
            
            <article>
                
<ol>
<li><span>Whenever a thread needs to access a non-thread-safe resource, it takes a monitor on this resource. Monitor guarantees that only the thread that owns this monitor can work with his resource.</span></li>
<li><span>A Deadlock is a situation when two threads depend on the progress of one another, and neither of them can't progress until the other thread does. So both threads stagnate. See chapter 11 for an example of how a deadlock can occur.</span></li>
<li><span><span>An actor is a concurrency primitive. It has a mailbox where it can accept messages from other actors. It can send messages to other actors. It is defined in terms of reactions to the messages of other actors. Only one message can be processed at a time by a given actor. It is guaranteed that if an actor owns a non-thread-safe resource, no other actor is allowed to own it.</span></span></li>
</ol>
<p> </p>
<ol start="4">
<li>Since only one actor controls a non-thread safe resource, there is no danger of race conditions or deadlocks. Whenever other actors need access to the resource in question, they do so by asking the owner actor. The operation is performed indirectly by the owner actor of the resource, and the resource itself is never exposed to the outer world.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 12</h1>
                </header>
            
            <article>
                
<ol>
<li>Encapsulation with Actors—mutable state is only accessible from one actor, one thread. Actors are organized in hierarchies, and parents supervise children to achieve fault tolerance.</li>
<li>We do so by extending the <kbd>Actor</kbd> class and implementing the <kbd>receive</kbd> method.</li>
<li>We do so by calling the <kbd>actorOf</kbd> method on <kbd>ActorSystem</kbd> or <kbd>ActorContext</kbd>.</li>
<li>Using the <kbd>!</kbd> operator on an <kbd>ActorRef</kbd>—<kbd>targetActor ! message</kbd>.</li>
<li>The <kbd>!</kbd> operator implements a <kbd>fire-and-forget</kbd> type of message sending. It sends a message and returns immediately. Ask pattern involves sending a message using <kbd>?</kbd> operator instead, which returns a <kbd>Future[Any]</kbd> which will complete once the target actor responds—<kbd>val futureMessage: Future[Any] = targetActor ? message</kbd>.</li>
<li>The Pipe pattern instructs a <kbd>Future</kbd> to send a message to an actor upon completion of the <kbd>Future</kbd>'s computation—<kbd>future pipeTo targetActor</kbd>.</li>
</ol>


            </article>

            
        </section>
    </body></html>