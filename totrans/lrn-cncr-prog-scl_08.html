<html><head></head><body><div id="book-columns"><div id="book-inner"><div class="chapter" title="Chapter 8.  Actors"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/><span class="koboSpan" id="kobo.1.1">Chapter 8.   Actors  </span></h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"><span class="koboSpan" id="kobo.2.1"> </span></td><td valign="top"><p><span class="emphasis"><em><span class="koboSpan" id="kobo.3.1">"A distributed system is one in which the failure of a computer you didn't even know existed can render your own computer unusable."</span></em></span></p></td><td valign="top"><span class="koboSpan" id="kobo.4.1"> </span></td></tr><tr><td valign="top"><span class="koboSpan" id="kobo.5.1"> </span></td><td colspan="2" align="right" valign="top" style="text-align: center"><span class="koboSpan" id="kobo.6.1">--</span><span class="attribution"><span class="emphasis"><em><span class="koboSpan" id="kobo.7.1">Leslie Lamport</span></em></span></span></td></tr></table></div><p><span class="koboSpan" id="kobo.8.1">Throughout this book, we have concentrated on many different abstractions for concurrent programming. </span><span class="koboSpan" id="kobo.8.2">Most of these abstractions assume the presence of shared memory. </span><span class="koboSpan" id="kobo.8.3">Futures and promises, concurrent data structures, and software transactional memory, are best suited to shared-memory systems. </span><span class="koboSpan" id="kobo.8.4">While the shared-memory assumption ensures that these facilities are efficient, it also limits them to applications running on a single computer. </span><span class="koboSpan" id="kobo.8.5">In this chapter, we consider a programming model that is equally applicable to a shared-memory machine or a distributed system, namely, the </span><span class="strong"><strong><span class="koboSpan" id="kobo.9.1">actor model</span></strong></span><span class="koboSpan" id="kobo.10.1">. </span><span class="koboSpan" id="kobo.10.2">In the actor model, the program is represented by a large number of entities that execute computations independently, and communicate by passing messages. </span><span class="koboSpan" id="kobo.10.3">These independent entities are called </span><span class="strong"><strong><span class="koboSpan" id="kobo.11.1">actors</span></strong></span><span class="koboSpan" id="kobo.12.1">.</span></p><p><span class="koboSpan" id="kobo.13.1">The actor model aims to resolve issues associated with using shared memory, such as data races or synchronization, by eliminating the need for shared memory altogether. </span><span class="emphasis"><em><span class="koboSpan" id="kobo.14.1">Mutable</span></em></span><span class="koboSpan" id="kobo.15.1"> state is confined within the boundaries of one actor, and is potentially modified when the actor receives a message. </span><span class="koboSpan" id="kobo.15.2">Messages received by the actor are handled serially, one after another. </span><span class="koboSpan" id="kobo.15.3">This ensures that the mutable state within the actor is never accessed concurrently. </span><span class="koboSpan" id="kobo.15.4">However, separate actors can process the received messages concurrently. </span><span class="koboSpan" id="kobo.15.5">In a typical actor-based program, the number of actors can be orders of magnitude greater than the number of processors. </span><span class="koboSpan" id="kobo.15.6">This is similar to the relationship between processors and threads in multi-threaded programs. </span><span class="koboSpan" id="kobo.15.7">The actor model implementation decides when to assign processor time to specific actors, to allow them to process messages.</span></p><p><span class="koboSpan" id="kobo.16.1">The true advantage of the actor model becomes apparent when we start distributing the application across multiple computers. </span><span class="koboSpan" id="kobo.16.2">Implementing programs that span across multiple machines and devices that communicate through a computer network is called </span><span class="strong"><strong><span class="koboSpan" id="kobo.17.1">distributed programming</span></strong></span><span class="koboSpan" id="kobo.18.1">. </span><span class="koboSpan" id="kobo.18.2">The actor model allows you to write programs that run inside a single process, multiple processes on the same machine, or on multiple machines that are connected to a computer network. </span><span class="koboSpan" id="kobo.18.3">Creating actors and sending messages is oblivious to, and independent of, the location of the actor. </span><span class="koboSpan" id="kobo.18.4">In distributed programming, this is called </span><span class="strong"><strong><span class="koboSpan" id="kobo.19.1">location transparency</span></strong></span><span class="koboSpan" id="kobo.20.1">. </span><span class="koboSpan" id="kobo.20.2">Location transparency allows you to design distributed systems without having the knowledge about the relationships in the computer network.</span></p><p><span class="koboSpan" id="kobo.21.1">In this chapter, we will use the Akka </span><code class="literal"><span class="koboSpan" id="kobo.22.1">actor</span></code><span class="koboSpan" id="kobo.23.1"> framework to learn about the actor concurrency model. </span><span class="koboSpan" id="kobo.23.2">Specifically, we cover the following topics:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.24.1">Declaring actor classes and creating actor instances</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.25.1">Modeling actor state and complex actor behaviors</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.26.1">Manipulating the actor hierarchy and the lifecycle of an actor</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.27.1">The different message-passing patterns used in actor communication</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.28.1">Error recovery using the built-in actor supervision mechanism</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.29.1">Using actors to transparently build concurrent and distributed programs</span></li></ul></div><p><span class="koboSpan" id="kobo.30.1">We will start by studying the important concepts and terminology in the actor model, and learning the basics of the actor model in Akka.</span></p><div class="section" title="Working with actors"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec53"/><span class="koboSpan" id="kobo.31.1">Working with actors</span></h1></div></div></div><p><span class="koboSpan" id="kobo.32.1">In the actor programming model, the program is run by a set of concurrently executing entities called actors. </span><span class="koboSpan" id="kobo.32.2">Actor systems resemble human organizations, such as companies, governments, or other large institutions. </span><span class="koboSpan" id="kobo.32.3">To understand this similarity, we consider the example of a large software company.</span></p><p><span class="koboSpan" id="kobo.33.1">In a software company such as Google, Microsoft, Amazon, or Typesafe, there are many goals that need to be achieved concurrently. </span><span class="koboSpan" id="kobo.33.2">Hundreds or thousands of employees work toward achieving these goals, and are usually organized in a hierarchical structure. </span><span class="koboSpan" id="kobo.33.3">Different employees work at different positions. </span><span class="koboSpan" id="kobo.33.4">A team leader makes important technical decisions for a specific project, a software engineer implements and maintains various parts of a software product, and a system administrator makes sure that the personal workstations, servers, and various equipment are functioning correctly. </span><span class="koboSpan" id="kobo.33.5">Many employees, such as the team leader, delegate their own tasks to other employees who are lower in the hierarchy than themselves. </span><span class="koboSpan" id="kobo.33.6">To be able to work and make decisions efficiently, employees use e-mails to communicate.</span></p><p><span class="koboSpan" id="kobo.34.1">When an employee comes to work in the morning, he inspects his e-mail client and responds to the important messages. </span><span class="koboSpan" id="kobo.34.2">Sometimes, these messages contain work tasks that come from his boss, or requests from other employees. </span><span class="koboSpan" id="kobo.34.3">When an e-mail is important, the employee must compose the answer right away. </span><span class="koboSpan" id="kobo.34.4">While the employee is busy answering one e-mail, additional e-mails can arrive, and these e-mails are enqueued in his e-mail client. </span><span class="koboSpan" id="kobo.34.5">Only once the employee is done with one e-mail is he able to proceed to the next one.</span></p><p><span class="koboSpan" id="kobo.35.1">In the preceding scenario, the workflow of the company is divided into a number of functional components. </span><span class="koboSpan" id="kobo.35.2">It turns out that these components closely correspond to different parts of an actor framework. </span><span class="koboSpan" id="kobo.35.3">We will now identify these similarities by defining the parts of an actor system, and relating them to their analogs in the software company.</span></p><p><span class="koboSpan" id="kobo.36.1">An </span><span class="strong"><strong><span class="koboSpan" id="kobo.37.1">actor system</span></strong></span><span class="koboSpan" id="kobo.38.1"> is a hierarchical group of actors that share common configuration options. </span><span class="koboSpan" id="kobo.38.2">An actor system is responsible for creating new actors, locating actors within the actor system, and logging important events. </span><span class="koboSpan" id="kobo.38.3">An actor system is an analog of the software company itself.</span></p><p><span class="koboSpan" id="kobo.39.1">An </span><span class="strong"><strong><span class="koboSpan" id="kobo.40.1">actor class</span></strong></span><span class="koboSpan" id="kobo.41.1"> is a template that describes a state internal to the actor, and how the actor processes the messages. </span><span class="koboSpan" id="kobo.41.2">Multiple actors can be created from the same actor class. </span><span class="koboSpan" id="kobo.41.3">An actor class is an analogy for a specific position within the company, such as a software engineer, a marketing manager, or a recruiter.</span></p><p><span class="koboSpan" id="kobo.42.1">An </span><span class="strong"><strong><span class="koboSpan" id="kobo.43.1">actor instance</span></strong></span><span class="koboSpan" id="kobo.44.1"> is an entity that exists at runtime and is capable of receiving messages. </span><span class="koboSpan" id="kobo.44.2">An actor instance might contain mutable state, and can send messages to other actor instances. </span><span class="koboSpan" id="kobo.44.3">The difference between an actor class and an actor instance directly corresponds to the relationship between a class and an object instance of that class in object-oriented programming. </span><span class="koboSpan" id="kobo.44.4">In the context of the software company example, an actor instance is analogous to a specific employee.</span></p><p><span class="koboSpan" id="kobo.45.1">A </span><span class="strong"><strong><span class="koboSpan" id="kobo.46.1">message</span></strong></span><span class="koboSpan" id="kobo.47.1"> is a unit of communication that actors use to communicate. </span><span class="koboSpan" id="kobo.47.2">In Akka, any object can be a message. </span><span class="koboSpan" id="kobo.47.3">Messages are analogous to e-mails sent within the company. </span><span class="koboSpan" id="kobo.47.4">When an actor sends a message, it does not wait until some other actor receives the message. </span><span class="koboSpan" id="kobo.47.5">Similarly, when an employee sends an e-mail, he does not wait until the e-mail is received or read by the other employees. </span><span class="koboSpan" id="kobo.47.6">Instead, he proceeds with his own work; an employee is too busy to wait. </span><span class="koboSpan" id="kobo.47.7">Multiple e-mails might be sent to the same person concurrently.</span></p><p><span class="koboSpan" id="kobo.48.1">The </span><span class="strong"><strong><span class="koboSpan" id="kobo.49.1">mailbox</span></strong></span><span class="koboSpan" id="kobo.50.1"> is a part of memory that is used to buffer messages, specific to each actor instance. </span><span class="koboSpan" id="kobo.50.2">This buffer is necessary, as an actor instance can process only a single message at a time. </span><span class="koboSpan" id="kobo.50.3">The mailbox corresponds to an e-mail client used by an employee. </span><span class="koboSpan" id="kobo.50.4">At any point, there might be multiple unread e-mails buffered in the e-mail client, but the employee can only read and respond to them one at a time.</span></p><p><span class="koboSpan" id="kobo.51.1">An </span><span class="strong"><strong><span class="koboSpan" id="kobo.52.1">actor reference</span></strong></span><span class="koboSpan" id="kobo.53.1"> is an object that allows you to send messages to a specific actor. </span><span class="koboSpan" id="kobo.53.2">This object hides information about the location of the actor from the programmer. </span><span class="koboSpan" id="kobo.53.3">An actor might run within separate processes or on different computers. </span><span class="koboSpan" id="kobo.53.4">The actor reference allows you to send a message to an actor irrespective of where the actor is running. </span><span class="koboSpan" id="kobo.53.5">From the software-company perspective, an actor reference corresponds to the e-mail address of a specific employee. </span><span class="koboSpan" id="kobo.53.6">The e-mail address allows us to send an e-mail to an employee, without knowing anything about the physical location of the employee. </span><span class="koboSpan" id="kobo.53.7">The employee might be in his office, on a business trip, or on vacation, but the e-mail will eventually reach him no matter where he goes.</span></p><p><span class="koboSpan" id="kobo.54.1">A </span><span class="strong"><strong><span class="koboSpan" id="kobo.55.1">dispatcher</span></strong></span><span class="koboSpan" id="kobo.56.1"> is a component that decides when actors are allowed to process messages, and lends them computational resources to do so. </span><span class="koboSpan" id="kobo.56.2">In Akka, every dispatcher is, at the same time, an execution context. </span><span class="koboSpan" id="kobo.56.3">The dispatcher ensures that actors with non-empty mailboxes eventually get run by a specific thread, and that these messages are handled serially. </span><span class="koboSpan" id="kobo.56.4">A dispatcher is best compared to the e-mail answering policy in the software company. </span><span class="koboSpan" id="kobo.56.5">Some employees, such as the technical support specialists, are expected to answer e-mails as soon as they arrive. </span><span class="koboSpan" id="kobo.56.6">Software engineers sometimes have more liberty-they can choose to fix several bugs before inspecting their e-mails. </span><span class="koboSpan" id="kobo.56.7">The janitor spends his day working around the office building, and only takes a look at his e-mail client in the morning.</span></p><p><span class="koboSpan" id="kobo.57.1">To make these concepts more concrete, we start by creating a simple actor application. </span><span class="koboSpan" id="kobo.57.2">This is the topic of the following section, in which we learn how to create actor systems and actor instances.</span></p><div class="section" title="Creating actor systems and actors"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec71"/><span class="koboSpan" id="kobo.58.1">Creating actor systems and actors</span></h2></div></div></div><p><span class="koboSpan" id="kobo.59.1">When creating an object instance in an object-oriented language, we start by declaring a class, which can be reused by multiple object instances. </span><span class="koboSpan" id="kobo.59.2">We then specify arguments for the constructor of the object. </span><span class="koboSpan" id="kobo.59.3">Finally, we instantiate an object using the </span><code class="literal"><span class="koboSpan" id="kobo.60.1">new</span></code><span class="koboSpan" id="kobo.61.1"> keyword and obtain a reference to the object.</span></p><p><span class="koboSpan" id="kobo.62.1">Creating an actor instance in Akka roughly follows the same steps as creating an object instance. </span><span class="koboSpan" id="kobo.62.2">First, we need to define an actor class, which defines the behavior of the actor. </span><span class="koboSpan" id="kobo.62.3">Then, we need to specify the configuration for a specific actor instance. </span><span class="koboSpan" id="kobo.62.4">Finally, we need to tell the actor system to instantiate the actor using the given configuration. </span><span class="koboSpan" id="kobo.62.5">The actor system then creates an actor instance and returns an actor reference to that instance. </span><span class="koboSpan" id="kobo.62.6">In this section, we will study these steps in more detail.</span></p><p><span class="koboSpan" id="kobo.63.1">An actor class is used to specify the behavior of an actor. </span><span class="koboSpan" id="kobo.63.2">It describes how the actor responds to messages and communicates with other actors, encapsulates actor state, and defines the actor's startup and shutdown sequences. </span><span class="koboSpan" id="kobo.63.3">We declare a new actor class by extending the </span><code class="literal"><span class="koboSpan" id="kobo.64.1">Actor</span></code><span class="koboSpan" id="kobo.65.1"> trait from the </span><code class="literal"><span class="koboSpan" id="kobo.66.1">akka.actor</span></code><span class="koboSpan" id="kobo.67.1"> package. </span><span class="koboSpan" id="kobo.67.2">This trait comes with a single abstract method, </span><code class="literal"><span class="koboSpan" id="kobo.68.1">receive</span></code><span class="koboSpan" id="kobo.69.1">. </span><span class="koboSpan" id="kobo.69.2">The </span><code class="literal"><span class="koboSpan" id="kobo.70.1">receive</span></code><span class="koboSpan" id="kobo.71.1"> method returns a partial function object of the type </span><code class="literal"><span class="koboSpan" id="kobo.72.1">PartialFunction[Any, Unit]</span></code><span class="koboSpan" id="kobo.73.1">. </span><span class="koboSpan" id="kobo.73.2">This partial function is used when an actor receives a message of the </span><code class="literal"><span class="koboSpan" id="kobo.74.1">Any</span></code><span class="koboSpan" id="kobo.75.1"> type. </span><span class="koboSpan" id="kobo.75.2">If the partial function is not defined for the message, the message is discarded.</span></p><p><span class="koboSpan" id="kobo.76.1">In addition to defining how an actor receives messages, the actor class encapsulates references to objects used by the actor. </span><span class="koboSpan" id="kobo.76.2">These objects comprise the actor's state. </span><span class="koboSpan" id="kobo.76.3">Throughout this chapter, we use Akka's </span><code class="literal"><span class="koboSpan" id="kobo.77.1">Logging</span></code><span class="koboSpan" id="kobo.78.1"> object to print to the standard output. </span><span class="koboSpan" id="kobo.78.2">In the following code, we declare a </span><code class="literal"><span class="koboSpan" id="kobo.79.1">HelloActor</span></code><span class="koboSpan" id="kobo.80.1"> actor class, which reacts to a </span><code class="literal"><span class="koboSpan" id="kobo.81.1">hello</span></code><span class="koboSpan" id="kobo.82.1"> message specified with the </span><code class="literal"><span class="koboSpan" id="kobo.83.1">hello</span></code><span class="koboSpan" id="kobo.84.1"> constructor argument. </span><span class="koboSpan" id="kobo.84.2">The </span><code class="literal"><span class="koboSpan" id="kobo.85.1">HelloActor</span></code><span class="koboSpan" id="kobo.86.1"> class contains a </span><code class="literal"><span class="koboSpan" id="kobo.87.1">Logging</span></code><span class="koboSpan" id="kobo.88.1"> object, </span><code class="literal"><span class="koboSpan" id="kobo.89.1">log</span></code><span class="koboSpan" id="kobo.90.1">, as part of its state. </span><span class="koboSpan" id="kobo.90.2">The </span><code class="literal"><span class="koboSpan" id="kobo.91.1">Logging</span></code><span class="koboSpan" id="kobo.92.1"> object is created using the </span><code class="literal"><span class="koboSpan" id="kobo.93.1">context.system</span></code><span class="koboSpan" id="kobo.94.1"> reference to the current actor system, and the </span><code class="literal"><span class="koboSpan" id="kobo.95.1">this</span></code><span class="koboSpan" id="kobo.96.1"> reference to the current actor. </span><span class="koboSpan" id="kobo.96.2">The </span><code class="literal"><span class="koboSpan" id="kobo.97.1">HelloActor</span></code><span class="koboSpan" id="kobo.98.1"> class defines a partial function in the </span><code class="literal"><span class="koboSpan" id="kobo.99.1">receive</span></code><span class="koboSpan" id="kobo.100.1"> method, which determines if the message is equal to the </span><code class="literal"><span class="koboSpan" id="kobo.101.1">hello</span></code><span class="koboSpan" id="kobo.102.1"> string argument, or to some other object called </span><code class="literal"><span class="koboSpan" id="kobo.103.1">msg</span></code><span class="koboSpan" id="kobo.104.1">.</span></p><p><span class="koboSpan" id="kobo.105.1">When an actor defined by the </span><code class="literal"><span class="koboSpan" id="kobo.106.1">HelloActor</span></code><span class="koboSpan" id="kobo.107.1"> class receives a </span><code class="literal"><span class="koboSpan" id="kobo.108.1">hello</span></code><span class="koboSpan" id="kobo.109.1"> string message, it prints the message using the </span><code class="literal"><span class="koboSpan" id="kobo.110.1">Logging</span></code><span class="koboSpan" id="kobo.111.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.112.1">log</span></code><span class="koboSpan" id="kobo.113.1">. </span><span class="koboSpan" id="kobo.113.2">Otherwise, it prints that it received an unexpected message, and stops by calling the </span><code class="literal"><span class="koboSpan" id="kobo.114.1">context.stop</span></code><span class="koboSpan" id="kobo.115.1"> method on the actor reference </span><code class="literal"><span class="koboSpan" id="kobo.116.1">self</span></code><span class="koboSpan" id="kobo.117.1">, which represents the current actor. </span><span class="koboSpan" id="kobo.117.2">This is shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.118.1">import akka.actor._ 
import akka.event.Logging 
class HelloActor(val hello: String) extends Actor { 
  val log = Logging(context.system, this) 
  def receive = { 
    case `hello` =&gt; 
      log.info(s"Received a '$hello'... </span><span class="koboSpan" id="kobo.118.2">$hello!") 
    case msg     =&gt; 
      log.info(s"Unexpected message '$msg'") 
      context.stop(self) 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.119.1">Declaring an actor class does not create a running actor instance. </span><span class="koboSpan" id="kobo.119.2">Instead, the actor class serves as a blueprint for creating actor instances. </span><span class="koboSpan" id="kobo.119.3">The same actor class can be shared by many actor instances. </span><span class="koboSpan" id="kobo.119.4">To create an actor instance in Akka, we need to pass information about the actor class to the actor system. </span><span class="koboSpan" id="kobo.119.5">However, an actor class such as </span><code class="literal"><span class="koboSpan" id="kobo.120.1">HelloActor</span></code><span class="koboSpan" id="kobo.121.1"> is not sufficient for creating an actor instance; we also need to specify the </span><code class="literal"><span class="koboSpan" id="kobo.122.1">hello</span></code><span class="koboSpan" id="kobo.123.1"> argument. </span><span class="koboSpan" id="kobo.123.2">To bundle the information required for creating an actor instance, Akka uses objects called </span><span class="strong"><strong><span class="koboSpan" id="kobo.124.1">actor configurations</span></strong></span><span class="koboSpan" id="kobo.125.1">.</span></p><p><span class="koboSpan" id="kobo.126.1">An actor configuration contains information about the actor class, its constructor arguments, mailbox, and dispatcher implementation. </span><span class="koboSpan" id="kobo.126.2">In Akka, an actor configuration is represented with the </span><code class="literal"><span class="koboSpan" id="kobo.127.1">Props</span></code><span class="koboSpan" id="kobo.128.1"> class. </span><span class="koboSpan" id="kobo.128.2">A </span><code class="literal"><span class="koboSpan" id="kobo.129.1">Props</span></code><span class="koboSpan" id="kobo.130.1"> object encapsulates all the information required to create an actor instance, and can be serialized or sent over the network.</span></p><p><span class="koboSpan" id="kobo.131.1">To create </span><code class="literal"><span class="koboSpan" id="kobo.132.1">Props</span></code><span class="koboSpan" id="kobo.133.1"> objects, it is recommended practice to declare Factory methods in the companion object of the actor class. </span><span class="koboSpan" id="kobo.133.2">In the following companion object, we declare two Factory methods, called </span><code class="literal"><span class="koboSpan" id="kobo.134.1">props</span></code><span class="koboSpan" id="kobo.135.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.136.1">propsAlt</span></code><span class="koboSpan" id="kobo.137.1">, which return </span><code class="literal"><span class="koboSpan" id="kobo.138.1">Props</span></code><span class="koboSpan" id="kobo.139.1"> objects for the </span><code class="literal"><span class="koboSpan" id="kobo.140.1">HelloActor</span></code><span class="koboSpan" id="kobo.141.1"> class, given the </span><code class="literal"><span class="koboSpan" id="kobo.142.1">hello</span></code><span class="koboSpan" id="kobo.143.1"> argument:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.144.1">object HelloActor { 
  def props(hello: String) = Props(new HelloActor(hello)) 
  def propsAlt(hello: String) = Props(classOf[HelloActor], hello) 
} 
</span></pre><p><span class="koboSpan" id="kobo.145.1">The </span><code class="literal"><span class="koboSpan" id="kobo.146.1">props</span></code><span class="koboSpan" id="kobo.147.1"> method uses an overload of the </span><code class="literal"><span class="koboSpan" id="kobo.148.1">Props.apply</span></code><span class="koboSpan" id="kobo.149.1"> factory method, which takes a block of code by creating the </span><code class="literal"><span class="koboSpan" id="kobo.150.1">HelloActor</span></code><span class="koboSpan" id="kobo.151.1"> class. </span><span class="koboSpan" id="kobo.151.2">This block of code is invoked every time an actor system needs to create an actor instance. </span><span class="koboSpan" id="kobo.151.3">The </span><code class="literal"><span class="koboSpan" id="kobo.152.1">propsAlt</span></code><span class="koboSpan" id="kobo.153.1"> method uses another </span><code class="literal"><span class="koboSpan" id="kobo.154.1">Props.apply</span></code><span class="koboSpan" id="kobo.155.1"> overload, which creates an actor instance from the </span><code class="literal"><span class="koboSpan" id="kobo.156.1">Class</span></code><span class="koboSpan" id="kobo.157.1"> object of the actor class, and a list of constructor arguments. </span><span class="koboSpan" id="kobo.157.2">The two declarations are semantically equivalent.</span></p><p><span class="koboSpan" id="kobo.158.1">The first </span><code class="literal"><span class="koboSpan" id="kobo.159.1">Props.apply</span></code><span class="koboSpan" id="kobo.160.1"> method overload takes a closure that calls the actor class constructor. </span><span class="koboSpan" id="kobo.160.2">If we are not careful, the closure can easily catch references to the enclosing scope. </span><span class="koboSpan" id="kobo.160.3">When this happens, these references become a part of the </span><code class="literal"><span class="koboSpan" id="kobo.161.1">Props</span></code><span class="koboSpan" id="kobo.162.1"> object. </span><span class="koboSpan" id="kobo.162.2">Consider the </span><code class="literal"><span class="koboSpan" id="kobo.163.1">defaultProps</span></code><span class="koboSpan" id="kobo.164.1"> method in the following utility class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.165.1">class HelloActorUtils { 
  val defaultHi = "Aloha!" 
  </span><span class="koboSpan" id="kobo.165.2">def defaultProps() = Props(new HelloActor(defaultHi)) 
} 
</span></pre><p><span class="koboSpan" id="kobo.166.1">Sending the </span><code class="literal"><span class="koboSpan" id="kobo.167.1">Props</span></code><span class="koboSpan" id="kobo.168.1"> object that is returned by the </span><code class="literal"><span class="koboSpan" id="kobo.169.1">defaultProps</span></code><span class="koboSpan" id="kobo.170.1"> method over the network requires sending the enclosing </span><code class="literal"><span class="koboSpan" id="kobo.171.1">HelloActorUtils</span></code><span class="koboSpan" id="kobo.172.1"> object captured by the closure, incurring additional network costs.</span></p><p><span class="koboSpan" id="kobo.173.1">Furthermore, it is particularly dangerous to declare a </span><code class="literal"><span class="koboSpan" id="kobo.174.1">Props</span></code><span class="koboSpan" id="kobo.175.1"> object within an actor class, as it can catch a </span><code class="literal"><span class="koboSpan" id="kobo.176.1">this</span></code><span class="koboSpan" id="kobo.177.1"> reference to the enclosing actor instance. </span><span class="koboSpan" id="kobo.177.2">It is safer to create the </span><code class="literal"><span class="koboSpan" id="kobo.178.1">Props</span></code><span class="koboSpan" id="kobo.179.1"> objects exactly as they were shown in the </span><code class="literal"><span class="koboSpan" id="kobo.180.1">propsAlt</span></code><span class="koboSpan" id="kobo.181.1"> method.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip88"/><span class="koboSpan" id="kobo.182.1">Tip</span></h3><p><span class="koboSpan" id="kobo.183.1">Avoid creating the </span><code class="literal"><span class="koboSpan" id="kobo.184.1">Props</span></code><span class="koboSpan" id="kobo.185.1"> objects within actor classes to prevent accidentally capturing the actor's </span><code class="literal"><span class="koboSpan" id="kobo.186.1">this</span></code><span class="koboSpan" id="kobo.187.1"> reference. </span><span class="koboSpan" id="kobo.187.2">Wherever possible, declare </span><code class="literal"><span class="koboSpan" id="kobo.188.1">Props</span></code><span class="koboSpan" id="kobo.189.1"> inside factory methods in top-level singleton objects.</span></p></div></div><p><span class="koboSpan" id="kobo.190.1">The third overload of the </span><code class="literal"><span class="koboSpan" id="kobo.191.1">Props.apply</span></code><span class="koboSpan" id="kobo.192.1"> method is a convenience method that can be used with actor classes with zero-argument constructors. </span><span class="koboSpan" id="kobo.192.2">If </span><code class="literal"><span class="koboSpan" id="kobo.193.1">HelloActor</span></code><span class="koboSpan" id="kobo.194.1"> defines no constructor arguments, we can write </span><code class="literal"><span class="koboSpan" id="kobo.195.1">Props[HelloActor]</span></code><span class="koboSpan" id="kobo.196.1"> to create a </span><code class="literal"><span class="koboSpan" id="kobo.197.1">Props</span></code><span class="koboSpan" id="kobo.198.1"> object.</span></p><p><span class="koboSpan" id="kobo.199.1">To instantiate an actor, we pass an actor configuration to the </span><code class="literal"><span class="koboSpan" id="kobo.200.1">actorOf</span></code><span class="koboSpan" id="kobo.201.1"> method of the actor system. </span><span class="koboSpan" id="kobo.201.2">Throughout this chapter, we will use our custom actor system instance called </span><code class="literal"><span class="koboSpan" id="kobo.202.1">ourSystem</span></code><span class="koboSpan" id="kobo.203.1">. </span><span class="koboSpan" id="kobo.203.2">We define the </span><code class="literal"><span class="koboSpan" id="kobo.204.1">ourSystem</span></code><span class="koboSpan" id="kobo.205.1"> variable using the </span><code class="literal"><span class="koboSpan" id="kobo.206.1">ActorSystem.apply</span></code><span class="koboSpan" id="kobo.207.1"> factory method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.208.1">lazy val ourSystem = ActorSystem("OurExampleSystem") 
</span></pre><p><span class="koboSpan" id="kobo.209.1">We can now create and run the </span><code class="literal"><span class="koboSpan" id="kobo.210.1">HelloActor</span></code><span class="koboSpan" id="kobo.211.1"> class by calling the </span><code class="literal"><span class="koboSpan" id="kobo.212.1">actorOf</span></code><span class="koboSpan" id="kobo.213.1"> method on the actor system. </span><span class="koboSpan" id="kobo.213.2">When creating a new actor, we can specify a unique name for the actor instance with the </span><code class="literal"><span class="koboSpan" id="kobo.214.1">name</span></code><span class="koboSpan" id="kobo.215.1"> argument. </span><span class="koboSpan" id="kobo.215.2">Without explicitly specifying the </span><code class="literal"><span class="koboSpan" id="kobo.216.1">name</span></code><span class="koboSpan" id="kobo.217.1"> argument, the actor system automatically assigns a unique name to the new actor instance. </span><span class="koboSpan" id="kobo.217.2">The </span><code class="literal"><span class="koboSpan" id="kobo.218.1">actorOf</span></code><span class="koboSpan" id="kobo.219.1"> method does not return an instance of the </span><code class="literal"><span class="koboSpan" id="kobo.220.1">HelloActor</span></code><span class="koboSpan" id="kobo.221.1"> class. </span><span class="koboSpan" id="kobo.221.2">Instead, it returns an actor reference object of the </span><code class="literal"><span class="koboSpan" id="kobo.222.1">ActorRef</span></code><span class="koboSpan" id="kobo.223.1"> type.</span></p><p><span class="koboSpan" id="kobo.224.1">After creating a </span><code class="literal"><span class="koboSpan" id="kobo.225.1">HelloActor</span></code><span class="koboSpan" id="kobo.226.1"> instance </span><code class="literal"><span class="koboSpan" id="kobo.227.1">hiActor</span></code><span class="koboSpan" id="kobo.228.1">, which recognizes the </span><code class="literal"><span class="koboSpan" id="kobo.229.1">hi</span></code><span class="koboSpan" id="kobo.230.1"> messages, we send it a message, </span><code class="literal"><span class="koboSpan" id="kobo.231.1">hi</span></code><span class="koboSpan" id="kobo.232.1">. </span><span class="koboSpan" id="kobo.232.2">To send a message to an Akka actor, we use the </span><code class="literal"><span class="koboSpan" id="kobo.233.1">!</span></code><span class="koboSpan" id="kobo.234.1"> operator (pronounced as </span><span class="emphasis"><em><span class="koboSpan" id="kobo.235.1">tell</span></em></span><span class="koboSpan" id="kobo.236.1"> or </span><span class="emphasis"><em><span class="koboSpan" id="kobo.237.1">bang</span></em></span><span class="koboSpan" id="kobo.238.1">). </span><span class="koboSpan" id="kobo.238.2">For clarity, we then pause the execution for one second by calling </span><code class="literal"><span class="koboSpan" id="kobo.239.1">sleep</span></code><span class="koboSpan" id="kobo.240.1">, and give the actor some time to process the message. </span><span class="koboSpan" id="kobo.240.2">We then send another message, </span><code class="literal"><span class="koboSpan" id="kobo.241.1">hola</span></code><span class="koboSpan" id="kobo.242.1">, and wait one more second. </span><span class="koboSpan" id="kobo.242.2">Finally, we terminate the actor system by calling its </span><code class="literal"><span class="koboSpan" id="kobo.243.1">shutdown</span></code><span class="koboSpan" id="kobo.244.1"> method. </span><span class="koboSpan" id="kobo.244.2">This is shown in the following program:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.245.1">object ActorsCreate extends App { 
  val hiActor: ActorRef = 
    ourSystem.actorOf(HelloActor.props("hi"), name = "greeter") 
  hiActor ! </span><span class="koboSpan" id="kobo.245.2">"hi" 
  Thread.sleep(1000) 
  hiActor ! </span><span class="koboSpan" id="kobo.245.3">"hola" 
  Thread.sleep(1000) 
  ourSystem.shutdown() 
} 
</span></pre><p><span class="koboSpan" id="kobo.246.1">Upon running this program, the </span><code class="literal"><span class="koboSpan" id="kobo.247.1">hiActor</span></code><span class="koboSpan" id="kobo.248.1"> instance first prints that it received a </span><code class="literal"><span class="koboSpan" id="kobo.249.1">hi</span></code><span class="koboSpan" id="kobo.250.1"> message. </span><span class="koboSpan" id="kobo.250.2">After one second, it prints that it received a </span><code class="literal"><span class="koboSpan" id="kobo.251.1">hola</span></code><span class="koboSpan" id="kobo.252.1"> string as a message, an unexpected message, and terminates.</span></p></div><div class="section" title="Managing unhandled messages"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec72"/><span class="koboSpan" id="kobo.253.1">Managing unhandled messages</span></h2></div></div></div><p><span class="koboSpan" id="kobo.254.1">The </span><code class="literal"><span class="koboSpan" id="kobo.255.1">receive</span></code><span class="koboSpan" id="kobo.256.1"> method in the </span><code class="literal"><span class="koboSpan" id="kobo.257.1">HelloActor</span></code><span class="koboSpan" id="kobo.258.1"> example was able to handle any kind of message. </span><span class="koboSpan" id="kobo.258.2">When the message was different from the pre-specified </span><code class="literal"><span class="koboSpan" id="kobo.259.1">hello</span></code><span class="koboSpan" id="kobo.260.1"> argument, such as </span><code class="literal"><span class="koboSpan" id="kobo.261.1">hi</span></code><span class="koboSpan" id="kobo.262.1">, used previously, the </span><code class="literal"><span class="koboSpan" id="kobo.263.1">HelloActor</span></code><span class="koboSpan" id="kobo.264.1"> actor reported this in the default case. </span><span class="koboSpan" id="kobo.264.2">Alternatively, we could have left the default case unhandled. </span><span class="koboSpan" id="kobo.264.3">When an actor receives a message that is not handled by its </span><code class="literal"><span class="koboSpan" id="kobo.265.1">receive</span></code><span class="koboSpan" id="kobo.266.1"> method, the message is wrapped into an </span><code class="literal"><span class="koboSpan" id="kobo.267.1">UnhandledMessage</span></code><span class="koboSpan" id="kobo.268.1"> object and forwarded to the actor system's event stream. </span><span class="koboSpan" id="kobo.268.2">Usually, the actor system's event stream is used for logging purposes.</span></p><p><span class="koboSpan" id="kobo.269.1">We can override this default behavior by overriding the </span><code class="literal"><span class="koboSpan" id="kobo.270.1">unhandled</span></code><span class="koboSpan" id="kobo.271.1"> method in the actor class. </span><span class="koboSpan" id="kobo.271.2">By default, this method publishes the unhandled messages on the actor system's event stream. </span><span class="koboSpan" id="kobo.271.3">In the following code, we declare a </span><code class="literal"><span class="koboSpan" id="kobo.272.1">DeafActor</span></code><span class="koboSpan" id="kobo.273.1"> actor class, whose </span><code class="literal"><span class="koboSpan" id="kobo.274.1">receive</span></code><span class="koboSpan" id="kobo.275.1"> method returns an empty partial function. </span><span class="koboSpan" id="kobo.275.2">An empty partial function is not defined for any type of message, so all the messages sent to this actor get passed to the </span><code class="literal"><span class="koboSpan" id="kobo.276.1">unhandled</span></code><span class="koboSpan" id="kobo.277.1"> method. </span><span class="koboSpan" id="kobo.277.2">We override it to output the </span><code class="literal"><span class="koboSpan" id="kobo.278.1">String</span></code><span class="koboSpan" id="kobo.279.1"> messages to the standard output. </span><span class="koboSpan" id="kobo.279.2">We pass all other types of message to the actor system's event stream by calling the </span><code class="literal"><span class="koboSpan" id="kobo.280.1">super.unhandled</span></code><span class="koboSpan" id="kobo.281.1"> method. </span><span class="koboSpan" id="kobo.281.2">The following code snippet shows the </span><code class="literal"><span class="koboSpan" id="kobo.282.1">DeafActor</span></code><span class="koboSpan" id="kobo.283.1"> implementation:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.284.1">class DeafActor extends Actor { 
  val log = Logging(context.system, this) 
  def receive = PartialFunction.empty 
  override def unhandled(msg: Any) = msg match { 
    case msg: String =&gt; log.info(s"I do not hear '$msg'") 
    case msg         =&gt; super.unhandled(msg) 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.285.1">Let's test a </span><code class="literal"><span class="koboSpan" id="kobo.286.1">DeafActor</span></code><span class="koboSpan" id="kobo.287.1"> class in an example. </span><span class="koboSpan" id="kobo.287.2">The following program creates a </span><code class="literal"><span class="koboSpan" id="kobo.288.1">DeafActor</span></code><span class="koboSpan" id="kobo.289.1"> instance named </span><code class="literal"><span class="koboSpan" id="kobo.290.1">deafy</span></code><span class="koboSpan" id="kobo.291.1">, and assigns its actor reference to the value </span><code class="literal"><span class="koboSpan" id="kobo.292.1">deafActor</span></code><span class="koboSpan" id="kobo.293.1">. </span><span class="koboSpan" id="kobo.293.2">It then sends the two messages, </span><code class="literal"><span class="koboSpan" id="kobo.294.1">deafy</span></code><span class="koboSpan" id="kobo.295.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.296.1">1234</span></code><span class="koboSpan" id="kobo.297.1">, to </span><code class="literal"><span class="koboSpan" id="kobo.298.1">deafActor</span></code><span class="koboSpan" id="kobo.299.1">, and shuts down the actor system:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.300.1">object ActorsUnhandled extends App { 
  val deafActor: ActorRef = 
    ourSystem.actorOf(Props[DeafActor], name = "deafy") 
  deafActor ! </span><span class="koboSpan" id="kobo.300.2">"hi" 
  Thread.sleep(1000) 
  deafActor ! </span><span class="koboSpan" id="kobo.300.3">1234 
  Thread.sleep(1000) 
  ourSystem.shutdown() 
} 
</span></pre><p><span class="koboSpan" id="kobo.301.1">Running this program shows that the first message, the </span><code class="literal"><span class="koboSpan" id="kobo.302.1">deafy</span></code><span class="koboSpan" id="kobo.303.1"> string, is caught and printed by the </span><code class="literal"><span class="koboSpan" id="kobo.304.1">unhandled</span></code><span class="koboSpan" id="kobo.305.1"> method. </span><span class="koboSpan" id="kobo.305.2">The </span><code class="literal"><span class="koboSpan" id="kobo.306.1">1234</span></code><span class="koboSpan" id="kobo.307.1"> message is forwarded to the actor system's event stream, and is never shown on the standard output.</span></p><p><span class="koboSpan" id="kobo.308.1">An attentive reader might have noticed that we could have avoided the </span><code class="literal"><span class="koboSpan" id="kobo.309.1">unhandled</span></code><span class="koboSpan" id="kobo.310.1"> call by moving the case into the </span><code class="literal"><span class="koboSpan" id="kobo.311.1">receive</span></code><span class="koboSpan" id="kobo.312.1"> method, as shown in the following </span><code class="literal"><span class="koboSpan" id="kobo.313.1">receive</span></code><span class="koboSpan" id="kobo.314.1"> implementation:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.315.1">def receive = { 
  case msg: String =&gt; log.info(s"I do not hear '$msg'") 
} 
</span></pre><p><span class="koboSpan" id="kobo.316.1">This definition of the </span><code class="literal"><span class="koboSpan" id="kobo.317.1">receive</span></code><span class="koboSpan" id="kobo.318.1"> method is more concise, but is inadequate for more complex actors. </span><span class="koboSpan" id="kobo.318.2">In the preceding example, we have fused the treatment of unhandled messages together with how the actor handles regular messages. </span><span class="koboSpan" id="kobo.318.3">Stateful actors often change the way they handle regular messages, and it is essential to separate the treatment of unhandled messages from the normal behavior of the actor. </span><span class="koboSpan" id="kobo.318.4">We will study how to change the actor behavior in the following section.</span></p></div><div class="section" title="Actor behavior and state"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec73"/><span class="koboSpan" id="kobo.319.1">Actor behavior and state</span></h2></div></div></div><p><span class="koboSpan" id="kobo.320.1">When an actor changes its state, it is often necessary to change the way it handles incoming messages. </span><span class="koboSpan" id="kobo.320.2">The way that the actor handles regular messages is called the </span><span class="strong"><strong><span class="koboSpan" id="kobo.321.1">behavior</span></strong></span><span class="koboSpan" id="kobo.322.1"> of the actor. </span><span class="koboSpan" id="kobo.322.2">In this section, we will study how to manipulate actor behavior.</span></p><p><span class="koboSpan" id="kobo.323.1">We have previously learned that we define the initial behavior of the actor by implementing the </span><code class="literal"><span class="koboSpan" id="kobo.324.1">receive</span></code><span class="koboSpan" id="kobo.325.1"> method. </span><span class="koboSpan" id="kobo.325.2">Note that the </span><code class="literal"><span class="koboSpan" id="kobo.326.1">receive</span></code><span class="koboSpan" id="kobo.327.1"> method must always return the same partial function. </span><span class="koboSpan" id="kobo.327.2">It is not correct to return different partial functions from the </span><code class="literal"><span class="koboSpan" id="kobo.328.1">receive</span></code><span class="koboSpan" id="kobo.329.1"> method depending on the current state of the actor. </span><span class="koboSpan" id="kobo.329.2">Let's assume we want to define a </span><code class="literal"><span class="koboSpan" id="kobo.330.1">CountdownActor</span></code><span class="koboSpan" id="kobo.331.1"> actor class, which decreases its </span><code class="literal"><span class="koboSpan" id="kobo.332.1">n</span></code><span class="koboSpan" id="kobo.333.1"> integer field every time it receives a </span><code class="literal"><span class="koboSpan" id="kobo.334.1">count</span></code><span class="koboSpan" id="kobo.335.1"> message, until it reaches zero. </span><span class="koboSpan" id="kobo.335.2">After the </span><code class="literal"><span class="koboSpan" id="kobo.336.1">CountdownActor</span></code><span class="koboSpan" id="kobo.337.1"> class reaches zero, it should ignore all subsequent messages. </span><span class="koboSpan" id="kobo.337.2">The following definition of the </span><code class="literal"><span class="koboSpan" id="kobo.338.1">receive</span></code><span class="koboSpan" id="kobo.339.1"> method is not allowed in Akka:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.340.1">class CountdownActor extends Actor { 
  var n = 10 
  def receive = if (n &gt; 0) { // never do this 
    case "count" =&gt; 
      log(s"n = $n") 
      n -= 1 
  } else PartialFunction.empty 
} 
</span></pre><p><span class="koboSpan" id="kobo.341.1">To correctly change the behavior of the </span><code class="literal"><span class="koboSpan" id="kobo.342.1">CountdownActor</span></code><span class="koboSpan" id="kobo.343.1"> class after it reaches zero, we use the </span><code class="literal"><span class="koboSpan" id="kobo.344.1">become</span></code><span class="koboSpan" id="kobo.345.1"> method on the actor's </span><code class="literal"><span class="koboSpan" id="kobo.346.1">context</span></code><span class="koboSpan" id="kobo.347.1"> object. </span><span class="koboSpan" id="kobo.347.2">In the correct definition of the </span><code class="literal"><span class="koboSpan" id="kobo.348.1">CountdownActor</span></code><span class="koboSpan" id="kobo.349.1"> class, we define two methods, </span><code class="literal"><span class="koboSpan" id="kobo.350.1">counting</span></code><span class="koboSpan" id="kobo.351.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.352.1">done</span></code><span class="koboSpan" id="kobo.353.1">, which return two different behaviors. </span><span class="koboSpan" id="kobo.353.2">The </span><code class="literal"><span class="koboSpan" id="kobo.354.1">counting</span></code><span class="koboSpan" id="kobo.355.1"> behavior reacts to the </span><code class="literal"><span class="koboSpan" id="kobo.356.1">count</span></code><span class="koboSpan" id="kobo.357.1"> messages and calls </span><code class="literal"><span class="koboSpan" id="kobo.358.1">become</span></code><span class="koboSpan" id="kobo.359.1"> to change to the </span><code class="literal"><span class="koboSpan" id="kobo.360.1">done</span></code><span class="koboSpan" id="kobo.361.1"> behavior once the </span><code class="literal"><span class="koboSpan" id="kobo.362.1">n</span></code><span class="koboSpan" id="kobo.363.1"> field is zero. </span><span class="koboSpan" id="kobo.363.2">The </span><code class="literal"><span class="koboSpan" id="kobo.364.1">done</span></code><span class="koboSpan" id="kobo.365.1"> behavior is just an empty partial function, which ignores all the messages.</span></p><p><span class="koboSpan" id="kobo.366.1">This is shown in the following implementation of the </span><code class="literal"><span class="koboSpan" id="kobo.367.1">CountdownActor</span></code><span class="koboSpan" id="kobo.368.1"> class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.369.1">class CountdownActor extends Actor { 
  val log = Logging(context.system, this) 
  var n = 10 
  def counting: Actor.Receive = { 
    case "count" =&gt; 
      n -= 1 
      log.info(s"n = $n") 
      if (n == 0) context.become(done) 
  } 
  def done = PartialFunction.empty 
  def receive = counting 
} 
</span></pre><p><span class="koboSpan" id="kobo.370.1">The </span><code class="literal"><span class="koboSpan" id="kobo.371.1">receive</span></code><span class="koboSpan" id="kobo.372.1"> method defines the initial behavior of the actor, which must be the </span><code class="literal"><span class="koboSpan" id="kobo.373.1">counting</span></code><span class="koboSpan" id="kobo.374.1"> behavior. Note that we are using the type alias </span><code class="literal"><span class="koboSpan" id="kobo.375.1">Receive</span></code><span class="koboSpan" id="kobo.376.1"> from the Actor companion object, which is just a shorthand for the </span><code class="literal"><span class="koboSpan" id="kobo.377.1">PartialFunction[Any, Unit] type</span></code><span class="koboSpan" id="kobo.378.1">.</span></p><p><span class="koboSpan" id="kobo.379.1">When modeling complex actors, it is helpful to think of them as </span><span class="strong"><strong><span class="koboSpan" id="kobo.380.1">state machines</span></strong></span><span class="koboSpan" id="kobo.381.1">. </span><span class="koboSpan" id="kobo.381.2">A state machine is a mathematical model that represents a system with some number of states and transitions between these states. </span><span class="koboSpan" id="kobo.381.3">In an actor, each behavior corresponds to a state in the state machine. </span><span class="koboSpan" id="kobo.381.4">A transition exists between two states if the actor potentially calls the </span><code class="literal"><span class="koboSpan" id="kobo.382.1">become</span></code><span class="koboSpan" id="kobo.383.1"> method when receiving a certain message. </span><span class="koboSpan" id="kobo.383.2">In the following figure, we illustrate the state machine corresponding to the </span><code class="literal"><span class="koboSpan" id="kobo.384.1">CountdownActor</span></code><span class="koboSpan" id="kobo.385.1"> class. </span><span class="koboSpan" id="kobo.385.2">The two circles represent the states corresponding to the behaviors </span><code class="literal"><span class="koboSpan" id="kobo.386.1">counting</span></code><span class="koboSpan" id="kobo.387.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.388.1">done</span></code><span class="koboSpan" id="kobo.389.1">. </span><span class="koboSpan" id="kobo.389.2">The initial behavior is </span><span class="strong"><strong><span class="koboSpan" id="kobo.390.1">counting</span></strong></span><span class="koboSpan" id="kobo.391.1">, so we draw an arrow pointing to the corresponding state. </span><span class="koboSpan" id="kobo.391.2">We represent the transitions between the states with arrows starting and ending at a state.</span></p><p><span class="koboSpan" id="kobo.392.1">When the actor receives the </span><span class="strong"><strong><span class="koboSpan" id="kobo.393.1">count</span></strong></span><span class="koboSpan" id="kobo.394.1"> message and the </span><span class="strong"><strong><span class="koboSpan" id="kobo.395.1">n</span></strong></span><span class="koboSpan" id="kobo.396.1"> field is larger than </span><span class="strong"><strong><span class="koboSpan" id="kobo.397.1">1</span></strong></span><span class="koboSpan" id="kobo.398.1">, the behavior does not change. </span><span class="koboSpan" id="kobo.398.2">However, when the actor receives the </span><span class="strong"><strong><span class="koboSpan" id="kobo.399.1">count</span></strong></span><span class="koboSpan" id="kobo.400.1"> message and the </span><span class="strong"><strong><span class="koboSpan" id="kobo.401.1">n</span></strong></span><span class="koboSpan" id="kobo.402.1"> field is decreased to </span><code class="literal"><span class="koboSpan" id="kobo.403.1">0</span></code><span class="koboSpan" id="kobo.404.1">, the actor changes its behavior to </span><span class="strong"><strong><span class="koboSpan" id="kobo.405.1">done</span></strong></span><span class="koboSpan" id="kobo.406.1">:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.407.1"><img src="graphics/image_08_001.jpg" alt="Actor behavior and state"/></span></div><p><span class="koboSpan" id="kobo.408.1">The following short program tests the correctness of our actor. </span><span class="koboSpan" id="kobo.408.2">We use the actor system to create a new </span><code class="literal"><span class="koboSpan" id="kobo.409.1">countdown</span></code><span class="koboSpan" id="kobo.410.1"> actor, and send it 20 </span><code class="literal"><span class="koboSpan" id="kobo.411.1">count</span></code><span class="koboSpan" id="kobo.412.1"> messages. </span><span class="koboSpan" id="kobo.412.2">The actor only reacts to the first 10 messages, before switching to the </span><code class="literal"><span class="koboSpan" id="kobo.413.1">done</span></code><span class="koboSpan" id="kobo.414.1"> behavior:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.415.1">object ActorsCountdown extends App { 
  val countdown = ourSystem.actorOf(Props[CountdownActor]) 
  for (i &lt;- 0 until 20) countdown ! </span><span class="koboSpan" id="kobo.415.2">"count" 
  Thread.sleep(1000) 
  ourSystem.shutdown() 
} 
</span></pre><p><span class="koboSpan" id="kobo.416.1">Whenever an actor responds to the incoming messages differently depending on its current state, you should decompose different states into partial functions and use the </span><code class="literal"><span class="koboSpan" id="kobo.417.1">become</span></code><span class="koboSpan" id="kobo.418.1"> method to switch between states. </span><span class="koboSpan" id="kobo.418.2">This is particularly important when actors get more complex, and ensures that the actor logic is easier to understand and maintain.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip89"/><span class="koboSpan" id="kobo.419.1">Tip</span></h3><p><span class="koboSpan" id="kobo.420.1">When a stateful actor needs to change its behavior, declare a separate partial function for each of its behaviors. </span><span class="koboSpan" id="kobo.420.2">Implement the </span><code class="literal"><span class="koboSpan" id="kobo.421.1">receive</span></code><span class="koboSpan" id="kobo.422.1"> method to return the method corresponding to the initial behavior.</span></p></div></div><p><span class="koboSpan" id="kobo.423.1">We now consider a more refined example, in which we define an actor that checks if a given word exists in a dictionary and prints it to the standard output. </span><span class="koboSpan" id="kobo.423.2">We want to be able to change the dictionary that the actor is using during runtime. </span><span class="koboSpan" id="kobo.423.3">To set the dictionary, we send the actor an </span><code class="literal"><span class="koboSpan" id="kobo.424.1">Init</span></code><span class="koboSpan" id="kobo.425.1"> message with the path to the dictionary. </span><span class="koboSpan" id="kobo.425.2">After that, we can check if a word is in the dictionary by sending the actor the </span><code class="literal"><span class="koboSpan" id="kobo.426.1">IsWord</span></code><span class="koboSpan" id="kobo.427.1"> message. </span><span class="koboSpan" id="kobo.427.2">Once we're done using the dictionary, we can ask the actor to unload the dictionary by sending it the </span><code class="literal"><span class="koboSpan" id="kobo.428.1">End</span></code><span class="koboSpan" id="kobo.429.1"> message. </span><span class="koboSpan" id="kobo.429.2">After that, we can initialize the actor with some other dictionary.</span></p><p><span class="koboSpan" id="kobo.430.1">The following state machine models this logic with two behaviors, called </span><code class="literal"><span class="koboSpan" id="kobo.431.1">uninitialized</span></code><span class="koboSpan" id="kobo.432.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.433.1">initialized</span></code><span class="koboSpan" id="kobo.434.1">:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.435.1"><img src="graphics/image_08_002.jpg" alt="Actor behavior and state"/></span></div><p><span class="koboSpan" id="kobo.436.1">It is a recommended practice to define the datatypes for the different messages in the companion object of the actor class. </span><span class="koboSpan" id="kobo.436.2">In this case, we add the case classes </span><code class="literal"><span class="koboSpan" id="kobo.437.1">Init</span></code><span class="koboSpan" id="kobo.438.1">, </span><code class="literal"><span class="koboSpan" id="kobo.439.1">IsWord</span></code><span class="koboSpan" id="kobo.440.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.441.1">End</span></code><span class="koboSpan" id="kobo.442.1"> to the companion object of the </span><code class="literal"><span class="koboSpan" id="kobo.443.1">DictionaryActor</span></code><span class="koboSpan" id="kobo.444.1"> class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.445.1">object DictionaryActor { 
  case class Init(path: String) 
  case class IsWord(w: String) 
  case object End 
} 
</span></pre><p><span class="koboSpan" id="kobo.446.1">We next define the </span><code class="literal"><span class="koboSpan" id="kobo.447.1">DictionaryActor</span></code><span class="koboSpan" id="kobo.448.1"> actor class. </span><span class="koboSpan" id="kobo.448.2">This class defines a private </span><code class="literal"><span class="koboSpan" id="kobo.449.1">Logging</span></code><span class="koboSpan" id="kobo.450.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.451.1">log</span></code><span class="koboSpan" id="kobo.452.1">, and a </span><code class="literal"><span class="koboSpan" id="kobo.453.1">dictionary</span></code><span class="koboSpan" id="kobo.454.1"> mutable set, which is initially empty and can be used to store words. </span><span class="koboSpan" id="kobo.454.2">The </span><code class="literal"><span class="koboSpan" id="kobo.455.1">receive</span></code><span class="koboSpan" id="kobo.456.1"> method returns the </span><code class="literal"><span class="koboSpan" id="kobo.457.1">uninitialized</span></code><span class="koboSpan" id="kobo.458.1"> behavior, which only accepts the </span><code class="literal"><span class="koboSpan" id="kobo.459.1">Init</span></code><span class="koboSpan" id="kobo.460.1"> message type. </span><span class="koboSpan" id="kobo.460.2">When an </span><code class="literal"><span class="koboSpan" id="kobo.461.1">Init</span></code><span class="koboSpan" id="kobo.462.1"> message arrives, the actor uses its </span><code class="literal"><span class="koboSpan" id="kobo.463.1">path</span></code><span class="koboSpan" id="kobo.464.1"> field to fetch the dictionary from a file, load the words, and call </span><code class="literal"><span class="koboSpan" id="kobo.465.1">become</span></code><span class="koboSpan" id="kobo.466.1"> to switch to the </span><code class="literal"><span class="koboSpan" id="kobo.467.1">initialized</span></code><span class="koboSpan" id="kobo.468.1"> behavior. </span><span class="koboSpan" id="kobo.468.2">When an </span><code class="literal"><span class="koboSpan" id="kobo.469.1">IsWord</span></code><span class="koboSpan" id="kobo.470.1"> message arrives, the actor checks if the word exists and prints it to the standard output. </span><span class="koboSpan" id="kobo.470.2">If an </span><code class="literal"><span class="koboSpan" id="kobo.471.1">End</span></code><span class="koboSpan" id="kobo.472.1"> message arrives, the actor clears the dictionary and switches back to the </span><code class="literal"><span class="koboSpan" id="kobo.473.1">uninitialized</span></code><span class="koboSpan" id="kobo.474.1"> behavior. </span><span class="koboSpan" id="kobo.474.2">This is shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.475.1">class DictionaryActor extends Actor { 
  private val log = Logging(context.system, this) 
  private val dictionary = mutable.Set[String]() 
  def receive = uninitialized 
  def uninitialized: PartialFunction[Any, Unit] = { 
    case DictionaryActor.Init(path) =&gt; 
      val stream = getClass.getResourceAsStream(path) 
      val words = Source.fromInputStream(stream) 
      for (w &lt;- words.getLines) dictionary += w 
      context.become(initialized) 
  } 
  def initialized: PartialFunction[Any, Unit] = { 
    case DictionaryActor.IsWord(w) =&gt; 
      log.info(s"word '$w' exists: ${dictionary(w)}") 
    case DictionaryActor.End =&gt; 
      dictionary.clear() 
      context.become(uninitialized) 
  } 
  override def unhandled(msg: Any) = { 
    log.info(s"cannot handle message $msg in this state.") 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.476.1">Note that we have overridden the </span><code class="literal"><span class="koboSpan" id="kobo.477.1">unhandled</span></code><span class="koboSpan" id="kobo.478.1"> method in the </span><code class="literal"><span class="koboSpan" id="kobo.479.1">DictionaryActor</span></code><span class="koboSpan" id="kobo.480.1"> class. </span><span class="koboSpan" id="kobo.480.2">In this case, using the </span><code class="literal"><span class="koboSpan" id="kobo.481.1">unhandled</span></code><span class="koboSpan" id="kobo.482.1"> method reduces code duplication, and makes the </span><code class="literal"><span class="koboSpan" id="kobo.483.1">DictionaryActor</span></code><span class="koboSpan" id="kobo.484.1"> class easier to maintain, as there is no need to list the </span><code class="literal"><span class="koboSpan" id="kobo.485.1">default</span></code><span class="koboSpan" id="kobo.486.1"> case twice in both the </span><code class="literal"><span class="koboSpan" id="kobo.487.1">initialized</span></code><span class="koboSpan" id="kobo.488.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.489.1">uninitialized</span></code><span class="koboSpan" id="kobo.490.1"> behaviors.</span></p><p><span class="koboSpan" id="kobo.491.1">If you are using a Unix system, you can load the list of words, separated by a newline character, from the file in the </span><code class="literal"><span class="koboSpan" id="kobo.492.1">/usr/share/dict/words</span></code><span class="koboSpan" id="kobo.493.1"> location. </span><span class="koboSpan" id="kobo.493.2">Alternatively, download the source code for this book and find the </span><code class="literal"><span class="koboSpan" id="kobo.494.1">words.txt</span></code><span class="koboSpan" id="kobo.495.1"> file, or create a dummy file with several words, and save it to the </span><code class="literal"><span class="koboSpan" id="kobo.496.1">src/main/resources/org/learningconcurrency/</span></code><span class="koboSpan" id="kobo.497.1"> directory. </span><span class="koboSpan" id="kobo.497.2">You can then test the correctness of the </span><code class="literal"><span class="koboSpan" id="kobo.498.1">DictionaryActor</span></code><span class="koboSpan" id="kobo.499.1"> class using the following program:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.500.1">val dict = ourSystem.actorOf(Props[DictionaryActor], "dictionary") 
 
dict ! </span><span class="koboSpan" id="kobo.500.2">DictionaryActor.IsWord("program") 
Thread.sleep(1000) 
 
dict ! </span><span class="koboSpan" id="kobo.500.3">DictionaryActor.Init("/org/learningconcurrency/words.txt") 
Thread.sleep(1000) 
</span></pre><p><span class="koboSpan" id="kobo.501.1">The first message sent to the actor results in an error message. </span><span class="koboSpan" id="kobo.501.2">We cannot send an </span><code class="literal"><span class="koboSpan" id="kobo.502.1">IsWord</span></code><span class="koboSpan" id="kobo.503.1"> message before initializing the actor. </span><span class="koboSpan" id="kobo.503.2">After sending the </span><code class="literal"><span class="koboSpan" id="kobo.504.1">Init</span></code><span class="koboSpan" id="kobo.505.1"> message, we can check if words are present in the dictionary. </span><span class="koboSpan" id="kobo.505.2">Finally, we send an </span><code class="literal"><span class="koboSpan" id="kobo.506.1">End</span></code><span class="koboSpan" id="kobo.507.1"> message and shut down the actor system, as shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.508.1">dict ! </span><span class="koboSpan" id="kobo.508.2">DictionaryActor.IsWord("program") 
Thread.sleep(1000) 
 
dict ! </span><span class="koboSpan" id="kobo.508.3">DictionaryActor.IsWord("balaban") 
Thread.sleep(1000) 
 
dict ! </span><span class="koboSpan" id="kobo.508.4">DictionaryActor.End 
Thread.sleep(1000) 
 
ourSystem.shutdown() 
</span></pre><p><span class="koboSpan" id="kobo.509.1">Having learned about actor behaviors, we will study how actors are organized into a hierarchy in the following section.</span></p></div><div class="section" title="Akka actor hierarchy"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec74"/><span class="koboSpan" id="kobo.510.1">Akka actor hierarchy</span></h2></div></div></div><p><span class="koboSpan" id="kobo.511.1">In large organizations, people are assigned roles and responsibilities for different tasks in order to reach a specific goal. </span><span class="koboSpan" id="kobo.511.2">The CEO of the company chooses a specific goal, such as launching a software product. </span><span class="koboSpan" id="kobo.511.3">He then delegates parts of the work tasks to various teams within the company-the marketing team investigates potential customers for the new product, the design team develops the user interface of the product, and the software engineering team implements the logic of the software product. </span><span class="koboSpan" id="kobo.511.4">Each of these teams can be further decomposed into sub-teams with different roles and responsibilities, depending on the size of the company. </span><span class="koboSpan" id="kobo.511.5">For example, the software engineering team can be composed into two developer sub-teams, responsible for implementing the backend of the software product, such as the server-side code, and the frontend, such as the website or a desktop UI.</span></p><p><span class="koboSpan" id="kobo.512.1">Similarly, sets of actors can form hierarchies in which actors that are closer to the root work on more general tasks and delegate work items to more specialized actors lower in the hierarchy. </span><span class="koboSpan" id="kobo.512.2">Organizing parts of the system into hierarchies is a natural and systematic way to decompose a complex program into its basic components. </span><span class="koboSpan" id="kobo.512.3">In the context of actors, a correctly chosen actor hierarchy can also guarantee better scalability of the application, depending on how the work is balanced between the actors. </span><span class="koboSpan" id="kobo.512.4">Importantly, a hierarchy between actors allows isolating and replacing parts of the system that fail more easily.</span></p><p><span class="koboSpan" id="kobo.513.1">In Akka, actors implicitly form a hierarchy. </span><span class="koboSpan" id="kobo.513.2">Every actor can have some number of child actors, and it can create or stop child actors using the </span><code class="literal"><span class="koboSpan" id="kobo.514.1">context</span></code><span class="koboSpan" id="kobo.515.1"> object. </span><span class="koboSpan" id="kobo.515.2">To test this relationship, we will define two actor classes to represent the parent and child actors. </span><span class="koboSpan" id="kobo.515.3">We start by defining the </span><code class="literal"><span class="koboSpan" id="kobo.516.1">ChildActor</span></code><span class="koboSpan" id="kobo.517.1"> actor class, which reacts to the </span><code class="literal"><span class="koboSpan" id="kobo.518.1">sayhi</span></code><span class="koboSpan" id="kobo.519.1"> messages by printing the reference to its parent actor. </span><span class="koboSpan" id="kobo.519.2">The reference to the parent is obtained by calling the </span><code class="literal"><span class="koboSpan" id="kobo.520.1">parent</span></code><span class="koboSpan" id="kobo.521.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.522.1">context</span></code><span class="koboSpan" id="kobo.523.1"> object. </span><span class="koboSpan" id="kobo.523.2">Additionally, we will override the </span><code class="literal"><span class="koboSpan" id="kobo.524.1">postStop</span></code><span class="koboSpan" id="kobo.525.1"> method of the </span><code class="literal"><span class="koboSpan" id="kobo.526.1">Actor</span></code><span class="koboSpan" id="kobo.527.1"> class, which is invoked after the actor stops. </span><span class="koboSpan" id="kobo.527.2">By doing this, we will be able to see precisely when a child actor is stopped. </span><span class="koboSpan" id="kobo.527.3">The </span><code class="literal"><span class="koboSpan" id="kobo.528.1">ChildActor</span></code><span class="koboSpan" id="kobo.529.1"> template is shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.530.1">class ChildActor extends Actor { 
  val log = Logging(context.system, this) 
  def receive = { 
    case "sayhi" =&gt; 
      val parent = context.parent 
      log.info(s"my parent $parent made me say hi!") 
  } 
  override def postStop() { 
    log.info("child stopped!") 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.531.1">We now define an actor class called </span><code class="literal"><span class="koboSpan" id="kobo.532.1">ParentActor</span></code><span class="koboSpan" id="kobo.533.1">, which can accept the messages </span><code class="literal"><span class="koboSpan" id="kobo.534.1">create</span></code><span class="koboSpan" id="kobo.535.1">, </span><code class="literal"><span class="koboSpan" id="kobo.536.1">sayhi</span></code><span class="koboSpan" id="kobo.537.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.538.1">stop</span></code><span class="koboSpan" id="kobo.539.1">. </span><span class="koboSpan" id="kobo.539.2">When </span><code class="literal"><span class="koboSpan" id="kobo.540.1">ParentActor</span></code><span class="koboSpan" id="kobo.541.1"> receives a </span><code class="literal"><span class="koboSpan" id="kobo.542.1">create</span></code><span class="koboSpan" id="kobo.543.1"> message, it creates a new child by calling </span><code class="literal"><span class="koboSpan" id="kobo.544.1">actorOf</span></code><span class="koboSpan" id="kobo.545.1"> on the </span><code class="literal"><span class="koboSpan" id="kobo.546.1">context</span></code><span class="koboSpan" id="kobo.547.1"> object. </span><span class="koboSpan" id="kobo.547.2">When the </span><code class="literal"><span class="koboSpan" id="kobo.548.1">ParentActor</span></code><span class="koboSpan" id="kobo.549.1"> class receives a </span><code class="literal"><span class="koboSpan" id="kobo.550.1">sayhi</span></code><span class="koboSpan" id="kobo.551.1"> message, it forwards the message to its children by traversing the </span><code class="literal"><span class="koboSpan" id="kobo.552.1">context.children</span></code><span class="koboSpan" id="kobo.553.1"> list, and resending the message to each child. </span><span class="koboSpan" id="kobo.553.2">Finally, when the </span><code class="literal"><span class="koboSpan" id="kobo.554.1">ParentActor</span></code><span class="koboSpan" id="kobo.555.1"> class receives a </span><code class="literal"><span class="koboSpan" id="kobo.556.1">stop</span></code><span class="koboSpan" id="kobo.557.1"> message, it stops itself:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.558.1">class ParentActor extends Actor { 
  val log = Logging(context.system, this) 
  def receive = { 
    case "create" =&gt; 
      context.actorOf(Props[ChildActor]) 
      log.info(s"created a kid; children = ${context.children}") 
    case "sayhi" =&gt; 
      log.info("Kids, say hi!") 
      for (c &lt;- context.children) c ! </span><span class="koboSpan" id="kobo.558.2">"sayhi" 
    case "stop" =&gt; 
      log.info("parent stopping") 
      context.stop(self) 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.559.1">We test the actor classes </span><code class="literal"><span class="koboSpan" id="kobo.560.1">ParentActor</span></code><span class="koboSpan" id="kobo.561.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.562.1">ChildActor</span></code><span class="koboSpan" id="kobo.563.1"> in the following program. </span><span class="koboSpan" id="kobo.563.2">We first create the </span><code class="literal"><span class="koboSpan" id="kobo.564.1">ParentActor</span></code><span class="koboSpan" id="kobo.565.1"> instance, </span><code class="literal"><span class="koboSpan" id="kobo.566.1">parent</span></code><span class="koboSpan" id="kobo.567.1">, and then send two </span><code class="literal"><span class="koboSpan" id="kobo.568.1">create</span></code><span class="koboSpan" id="kobo.569.1"> messages to </span><code class="literal"><span class="koboSpan" id="kobo.570.1">parent</span></code><span class="koboSpan" id="kobo.571.1">. </span><span class="koboSpan" id="kobo.571.2">The </span><code class="literal"><span class="koboSpan" id="kobo.572.1">parent</span></code><span class="koboSpan" id="kobo.573.1"> actor prints that it created a child actor twice. </span><span class="koboSpan" id="kobo.573.2">We then send a </span><code class="literal"><span class="koboSpan" id="kobo.574.1">sayhi</span></code><span class="koboSpan" id="kobo.575.1"> message to </span><code class="literal"><span class="koboSpan" id="kobo.576.1">parent</span></code><span class="koboSpan" id="kobo.577.1">, and witness how the child actors output a message after the parent forwards the </span><code class="literal"><span class="koboSpan" id="kobo.578.1">sayhi</span></code><span class="koboSpan" id="kobo.579.1"> message to them. </span><span class="koboSpan" id="kobo.579.2">Finally, we send a </span><code class="literal"><span class="koboSpan" id="kobo.580.1">stop</span></code><span class="koboSpan" id="kobo.581.1"> message to stop the </span><code class="literal"><span class="koboSpan" id="kobo.582.1">parent</span></code><span class="koboSpan" id="kobo.583.1"> actor. </span><span class="koboSpan" id="kobo.583.2">This is shown in the following program:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.584.1">object ActorsHierarchy extends App { 
  val parent = ourSystem.actorOf(Props[ParentActor], "parent") 
  parent ! </span><span class="koboSpan" id="kobo.584.2">"create" 
  parent ! </span><span class="koboSpan" id="kobo.584.3">"create" 
  Thread.sleep(1000) 
  parent ! </span><span class="koboSpan" id="kobo.584.4">"sayhi" 
  Thread.sleep(1000) 
  parent ! </span><span class="koboSpan" id="kobo.584.5">"stop" 
  Thread.sleep(1000) 
  ourSystem.shutdown() 
} 
</span></pre><p><span class="koboSpan" id="kobo.585.1">By studying the standard output, we find that each of the two child actors output a </span><code class="literal"><span class="koboSpan" id="kobo.586.1">sayhi</span></code><span class="koboSpan" id="kobo.587.1"> message immediately after the </span><code class="literal"><span class="koboSpan" id="kobo.588.1">parent</span></code><span class="koboSpan" id="kobo.589.1"> actor prints that it is about to stop. </span><span class="koboSpan" id="kobo.589.2">This is the normal behavior of Akka actors-a child actor cannot exist without its parent. </span><span class="koboSpan" id="kobo.589.3">As soon as the parent actor stops, its child actors are stopped by the actor system as well.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note90"/><span class="koboSpan" id="kobo.590.1">Note</span></h3><p><span class="koboSpan" id="kobo.591.1">When an actor is stopped, its child actors are also automatically stopped.</span></p></div></div><p><span class="koboSpan" id="kobo.592.1">If you ran the preceding example program, you might have noticed that printing an actor reference reflects the actor's position in the actor hierarchy. </span><span class="koboSpan" id="kobo.592.2">For example, printing the child actor reference shows the </span><code class="literal"><span class="koboSpan" id="kobo.593.1">akka://OurExampleSystem/user/parent/$a</span></code><span class="koboSpan" id="kobo.594.1"> string. </span><span class="koboSpan" id="kobo.594.2">The first part of this string, </span><code class="literal"><span class="koboSpan" id="kobo.595.1">akka://</span></code><span class="koboSpan" id="kobo.596.1">, denotes that this reference points to a local actor. </span><span class="koboSpan" id="kobo.596.2">The </span><code class="literal"><span class="koboSpan" id="kobo.597.1">OurExampleSystem</span></code><span class="koboSpan" id="kobo.598.1"> part is the name of the actor system that we are using in this example. </span><span class="koboSpan" id="kobo.598.2">The </span><code class="literal"><span class="koboSpan" id="kobo.599.1">parent/$a</span></code><span class="koboSpan" id="kobo.600.1"> part reflects the name of the parent actor and the automatically generated name </span><code class="literal"><span class="koboSpan" id="kobo.601.1">$a</span></code><span class="koboSpan" id="kobo.602.1"> of the child actor. </span><span class="koboSpan" id="kobo.602.2">Unexpectedly, the string representation of the actor reference also contains a reference to an intermediate actor, called </span><code class="literal"><span class="koboSpan" id="kobo.603.1">user</span></code><span class="koboSpan" id="kobo.604.1">.</span></p><p><span class="koboSpan" id="kobo.605.1">In Akka, an actor that resides at the top of the actor hierarchy is called the </span><span class="strong"><strong><span class="koboSpan" id="kobo.606.1">guardian actor</span></strong></span><span class="koboSpan" id="kobo.607.1">, which exists to perform various internal tasks, such as logging and restarting user actors. </span><span class="koboSpan" id="kobo.607.2">Every top-level actor created in the application is placed under the </span><code class="literal"><span class="koboSpan" id="kobo.608.1">user</span></code><span class="koboSpan" id="kobo.609.1"> predefined guardian actor. </span><span class="koboSpan" id="kobo.609.2">There are other guardian actors. </span><span class="koboSpan" id="kobo.609.3">For example, actors internally used by the actor system are placed under the </span><code class="literal"><span class="koboSpan" id="kobo.610.1">system</span></code><span class="koboSpan" id="kobo.611.1"> guardian actor. </span><span class="koboSpan" id="kobo.611.2">The actor hierarchy is shown in the following figure, where the guardian actors </span><code class="literal"><span class="koboSpan" id="kobo.612.1">user</span></code><span class="koboSpan" id="kobo.613.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.614.1">system</span></code><span class="koboSpan" id="kobo.615.1"> form two separate hierarchies in the actor system called </span><code class="literal"><span class="koboSpan" id="kobo.616.1">OurExampleSystem</span></code><span class="koboSpan" id="kobo.617.1">:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.618.1"><img src="graphics/image_08_003.jpg" alt="Akka actor hierarchy"/></span></div><p><span class="koboSpan" id="kobo.619.1">In this section, we saw that Akka actors form a hierarchy, and learned about the relationships between actors in this hierarchy. </span><span class="koboSpan" id="kobo.619.2">Importantly, we learned how to refer to immediate neighbors of an actor using the </span><code class="literal"><span class="koboSpan" id="kobo.620.1">parent</span></code><span class="koboSpan" id="kobo.621.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.622.1">children</span></code><span class="koboSpan" id="kobo.623.1"> methods of the </span><code class="literal"><span class="koboSpan" id="kobo.624.1">context</span></code><span class="koboSpan" id="kobo.625.1"> object. </span><span class="koboSpan" id="kobo.625.2">In the following section, we will see how to refer to an arbitrary actor within the same actor system.</span></p></div><div class="section" title="Identifying actors"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec75"/><span class="koboSpan" id="kobo.626.1">Identifying actors</span></h2></div></div></div><p><span class="koboSpan" id="kobo.627.1">In the previous section, we learned that actors are organized in a hierarchical tree, in which every actor has a parent and some number of children. </span><span class="koboSpan" id="kobo.627.2">Thus, every actor lies on a unique path from the root of this hierarchy, and can be assigned a unique sequence of actor names on this path. </span><span class="koboSpan" id="kobo.627.3">The </span><code class="literal"><span class="koboSpan" id="kobo.628.1">parent</span></code><span class="koboSpan" id="kobo.629.1"> actor was directly beneath the </span><code class="literal"><span class="koboSpan" id="kobo.630.1">user</span></code><span class="koboSpan" id="kobo.631.1"> guardian actor, so its unique sequence of actor names is </span><code class="literal"><span class="koboSpan" id="kobo.632.1">/user/parent</span></code><span class="koboSpan" id="kobo.633.1">. </span><span class="koboSpan" id="kobo.633.2">Similarly, the unique sequence of actor names for the </span><code class="literal"><span class="koboSpan" id="kobo.634.1">parent</span></code><span class="koboSpan" id="kobo.635.1"> actor's child actor is </span><code class="literal"><span class="koboSpan" id="kobo.636.1">$a</span></code><span class="koboSpan" id="kobo.637.1"> is </span><code class="literal"><span class="koboSpan" id="kobo.638.1">/user/parent/$a</span></code><span class="koboSpan" id="kobo.639.1">. </span><span class="koboSpan" id="kobo.639.2">An </span><span class="strong"><strong><span class="koboSpan" id="kobo.640.1">actor path</span></strong></span><span class="koboSpan" id="kobo.641.1"> is a concatenation of the protocol, the actor system name, and the actor names on the path from the top guardian actor to a specific actor. </span><span class="koboSpan" id="kobo.641.2">The actor path of the </span><code class="literal"><span class="koboSpan" id="kobo.642.1">parent</span></code><span class="koboSpan" id="kobo.643.1"> actor from the previous example is </span><code class="literal"><span class="koboSpan" id="kobo.644.1">akka://OurExampleSystem/user/parent</span></code><span class="koboSpan" id="kobo.645.1">.</span></p><p><span class="koboSpan" id="kobo.646.1">Actor paths closely correspond to file paths in a filesystem. </span><span class="koboSpan" id="kobo.646.2">Every file path uniquely designates a file location, just as an actor path uniquely designates the location of the actor in the hierarchy. </span><span class="koboSpan" id="kobo.646.3">Just as a file path in a filesystem does not mean that a file exists, an actor path does not imply that there is an actor on that file path in the actor system. </span><span class="koboSpan" id="kobo.646.4">Instead, an actor path is an identifier used to obtain an actor reference if one exists. </span><span class="koboSpan" id="kobo.646.5">Also, parts of the names in the actor path can be replaced with wildcards and the </span><code class="literal"><span class="koboSpan" id="kobo.647.1">..</span></code><span class="koboSpan" id="kobo.648.1"> symbol, similar to how parts of filenames can be replaced in a shell. </span><span class="koboSpan" id="kobo.648.2">In this case, we obtain a </span><span class="strong"><strong><span class="koboSpan" id="kobo.649.1">path selection</span></strong></span><span class="koboSpan" id="kobo.650.1">. </span><span class="koboSpan" id="kobo.650.2">For example, the path selection </span><code class="literal"><span class="koboSpan" id="kobo.651.1">..</span></code><span class="koboSpan" id="kobo.652.1"> references the parent of the current actor. </span><span class="koboSpan" id="kobo.652.2">The selection </span><code class="literal"><span class="koboSpan" id="kobo.653.1">../*</span></code><span class="koboSpan" id="kobo.654.1"> references the current actor and all its siblings.</span></p><p><span class="koboSpan" id="kobo.655.1">Actor paths are different from actor references; we cannot send a message to an actor using its actor path. </span><span class="koboSpan" id="kobo.655.2">Instead, we must first use the actor path to identify an actor on that actor path. </span><span class="koboSpan" id="kobo.655.3">If we successfully find an actor reference behind an actor path, we can send messages to it.</span></p><p><span class="koboSpan" id="kobo.656.1">To obtain an actor reference corresponding to an actor path, we call the </span><code class="literal"><span class="koboSpan" id="kobo.657.1">actorSelection</span></code><span class="koboSpan" id="kobo.658.1"> method on the context object of an actor. </span><span class="koboSpan" id="kobo.658.2">This method takes an actor path, or a path selection. </span><span class="koboSpan" id="kobo.658.3">Calling the </span><code class="literal"><span class="koboSpan" id="kobo.659.1">actorSelection</span></code><span class="koboSpan" id="kobo.660.1"> method might address zero actors if no actors correspond to the actor path. </span><span class="koboSpan" id="kobo.660.2">Similarly, it might address multiple actors if we use a path selection. </span><span class="koboSpan" id="kobo.660.3">Thus, instead of returning an </span><code class="literal"><span class="koboSpan" id="kobo.661.1">ActorRef</span></code><span class="koboSpan" id="kobo.662.1"> object, the </span><code class="literal"><span class="koboSpan" id="kobo.663.1">actorSelection</span></code><span class="koboSpan" id="kobo.664.1"> method returns an </span><code class="literal"><span class="koboSpan" id="kobo.665.1">ActorSelection</span></code><span class="koboSpan" id="kobo.666.1"> object, which might represent zero, one, or more actors. </span><span class="koboSpan" id="kobo.666.2">We can use the </span><code class="literal"><span class="koboSpan" id="kobo.667.1">ActorSelection</span></code><span class="koboSpan" id="kobo.668.1"> object to send messages to these actors.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip91"/><span class="koboSpan" id="kobo.669.1">Tip</span></h3><p><span class="koboSpan" id="kobo.670.1">Use the </span><code class="literal"><span class="koboSpan" id="kobo.671.1">actorSelection</span></code><span class="koboSpan" id="kobo.672.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.673.1">context</span></code><span class="koboSpan" id="kobo.674.1"> object to communicate with arbitrary actors in the actor system.</span></p></div></div><p><span class="koboSpan" id="kobo.675.1">If we compare the </span><code class="literal"><span class="koboSpan" id="kobo.676.1">ActorRef</span></code><span class="koboSpan" id="kobo.677.1"> object to a specific e-mail address, an </span><code class="literal"><span class="koboSpan" id="kobo.678.1">ActorSelection</span></code><span class="koboSpan" id="kobo.679.1"> object can be compared to a mailing list address. </span><span class="koboSpan" id="kobo.679.2">Sending an e-mail to a valid e-mail address ensures that the e-mail reaches a specific person. </span><span class="koboSpan" id="kobo.679.3">On the other hand, when we send an e-mail to a mailing list, the e-mail might reach zero, one, or more people, depending on the number of mailing list subscribers.</span></p><p><span class="koboSpan" id="kobo.680.1">An </span><code class="literal"><span class="koboSpan" id="kobo.681.1">ActorSelection</span></code><span class="koboSpan" id="kobo.682.1"> object does not tell us anything about the concrete paths of the actors, in a similar way to how a mailing list does not tell us anything about its subscribers. </span><span class="koboSpan" id="kobo.682.2">For this purpose, Akka defines a special type of message called </span><code class="literal"><span class="koboSpan" id="kobo.683.1">Identify</span></code><span class="koboSpan" id="kobo.684.1">. </span><span class="koboSpan" id="kobo.684.2">When an Akka actor receives an </span><code class="literal"><span class="koboSpan" id="kobo.685.1">Identify</span></code><span class="koboSpan" id="kobo.686.1"> message, it will automatically reply by sending back an </span><code class="literal"><span class="koboSpan" id="kobo.687.1">ActorIdentity</span></code><span class="koboSpan" id="kobo.688.1"> message with its </span><code class="literal"><span class="koboSpan" id="kobo.689.1">ActorRef</span></code><span class="koboSpan" id="kobo.690.1"> object. </span><span class="koboSpan" id="kobo.690.2">If there are no actors in the actor selection, the </span><code class="literal"><span class="koboSpan" id="kobo.691.1">ActorIdentity</span></code><span class="koboSpan" id="kobo.692.1"> message is sent back to the sender of </span><code class="literal"><span class="koboSpan" id="kobo.693.1">Identify</span></code><span class="koboSpan" id="kobo.694.1"> without an </span><code class="literal"><span class="koboSpan" id="kobo.695.1">ActorRef</span></code><span class="koboSpan" id="kobo.696.1"> object.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip92"/><span class="koboSpan" id="kobo.697.1">Tip</span></h3><p><span class="koboSpan" id="kobo.698.1">Send </span><code class="literal"><span class="koboSpan" id="kobo.699.1">Identify</span></code><span class="koboSpan" id="kobo.700.1"> messages to the </span><code class="literal"><span class="koboSpan" id="kobo.701.1">ActorSelection</span></code><span class="koboSpan" id="kobo.702.1"> objects to obtain actor references of arbitrary actors in the actor system.</span></p></div></div><p><span class="koboSpan" id="kobo.703.1">In the following example, we define a </span><code class="literal"><span class="koboSpan" id="kobo.704.1">CheckActor</span></code><span class="koboSpan" id="kobo.705.1"> actor class, which describes actors that check and print actor references whenever they receive a message with an actor path. </span><span class="koboSpan" id="kobo.705.2">When the actor of type </span><code class="literal"><span class="koboSpan" id="kobo.706.1">CheckActor</span></code><span class="koboSpan" id="kobo.707.1"> receives a string with an actor path or a path selection, it obtains an </span><code class="literal"><span class="koboSpan" id="kobo.708.1">ActorSelection</span></code><span class="koboSpan" id="kobo.709.1"> object and sends it an </span><code class="literal"><span class="koboSpan" id="kobo.710.1">Identify</span></code><span class="koboSpan" id="kobo.711.1"> message. </span><span class="koboSpan" id="kobo.711.2">This message is forwarded to all actors in the selection, which then respond with an </span><code class="literal"><span class="koboSpan" id="kobo.712.1">ActorIdentity</span></code><span class="koboSpan" id="kobo.713.1"> message. </span><span class="koboSpan" id="kobo.713.2">The </span><code class="literal"><span class="koboSpan" id="kobo.714.1">Identify</span></code><span class="koboSpan" id="kobo.715.1"> message also takes a </span><code class="literal"><span class="koboSpan" id="kobo.716.1">messageId</span></code><span class="koboSpan" id="kobo.717.1"> argument. </span><span class="koboSpan" id="kobo.717.2">If an actor sends out multiple </span><code class="literal"><span class="koboSpan" id="kobo.718.1">Identify</span></code><span class="koboSpan" id="kobo.719.1"> messages, the </span><code class="literal"><span class="koboSpan" id="kobo.720.1">messageId</span></code><span class="koboSpan" id="kobo.721.1"> argument allows disambiguating between the different </span><code class="literal"><span class="koboSpan" id="kobo.722.1">ActorIdentity</span></code><span class="koboSpan" id="kobo.723.1"> responses. </span><span class="koboSpan" id="kobo.723.2">In our example, we use the </span><code class="literal"><span class="koboSpan" id="kobo.724.1">path</span></code><span class="koboSpan" id="kobo.725.1"> string as the </span><code class="literal"><span class="koboSpan" id="kobo.726.1">messageId</span></code><span class="koboSpan" id="kobo.727.1"> argument. </span><span class="koboSpan" id="kobo.727.2">When </span><code class="literal"><span class="koboSpan" id="kobo.728.1">CheckActor</span></code><span class="koboSpan" id="kobo.729.1"> receives an </span><code class="literal"><span class="koboSpan" id="kobo.730.1">ActorIdentity</span></code><span class="koboSpan" id="kobo.731.1"> message, it either prints the actor reference or reports that there is no actor on the specified path. </span><span class="koboSpan" id="kobo.731.2">The </span><code class="literal"><span class="koboSpan" id="kobo.732.1">CheckActor</span></code><span class="koboSpan" id="kobo.733.1"> class is shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.734.1">class CheckActor extends Actor { 
  val log = Logging(context.system, this) 
  def receive = { 
    case path: String =&gt; 
      log.info(s"checking path $path") 
      context.actorSelection(path) ! </span><span class="koboSpan" id="kobo.734.2">Identify(path) 
    case ActorIdentity(path, Some(ref)) =&gt; 
      log.info(s"found actor $ref at $path") 
    case ActorIdentity(path, None) =&gt; 
      log.info(s"could not find an actor at $path") 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.735.1">Next, we instantiate a </span><code class="literal"><span class="koboSpan" id="kobo.736.1">checker</span></code><span class="koboSpan" id="kobo.737.1"> actor of the </span><code class="literal"><span class="koboSpan" id="kobo.738.1">CheckActor</span></code><span class="koboSpan" id="kobo.739.1"> class, and send it the path selection, </span><code class="literal"><span class="koboSpan" id="kobo.740.1">../*</span></code><span class="koboSpan" id="kobo.741.1">. </span><span class="koboSpan" id="kobo.741.2">This references all the child actors of the </span><code class="literal"><span class="koboSpan" id="kobo.742.1">checker</span></code><span class="koboSpan" id="kobo.743.1"> parent-the </span><code class="literal"><span class="koboSpan" id="kobo.744.1">checker</span></code><span class="koboSpan" id="kobo.745.1"> actor itself and its siblings:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.746.1">val checker = ourSystem.actorOf(Props[CheckActor], "checker") 
checker ! </span><span class="koboSpan" id="kobo.746.2">"../*" 
</span></pre><p><span class="koboSpan" id="kobo.747.1">We did not instantiate any top-level actors besides the </span><code class="literal"><span class="koboSpan" id="kobo.748.1">checker</span></code><span class="koboSpan" id="kobo.749.1"> actor, so checker receives only a single </span><code class="literal"><span class="koboSpan" id="kobo.750.1">ActorIdentity</span></code><span class="koboSpan" id="kobo.751.1"> message and prints its own actor path. </span><span class="koboSpan" id="kobo.751.2">Next, we try to identify all the actors one level above the </span><code class="literal"><span class="koboSpan" id="kobo.752.1">checker</span></code><span class="koboSpan" id="kobo.753.1"> actor. </span><span class="koboSpan" id="kobo.753.2">Recall the earlier figure. </span><span class="koboSpan" id="kobo.753.3">Since </span><code class="literal"><span class="koboSpan" id="kobo.754.1">checker</span></code><span class="koboSpan" id="kobo.755.1"> is a top-level actor, this should identify the guardian actors in the actor system:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.756.1">checker ! </span><span class="koboSpan" id="kobo.756.2">"../../*" 
</span></pre><p><span class="koboSpan" id="kobo.757.1">As expected, the </span><code class="literal"><span class="koboSpan" id="kobo.758.1">checker</span></code><span class="koboSpan" id="kobo.759.1"> actor prints the actor paths of the </span><code class="literal"><span class="koboSpan" id="kobo.760.1">user</span></code><span class="koboSpan" id="kobo.761.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.762.1">system</span></code><span class="koboSpan" id="kobo.763.1"> guardian actors. </span><span class="koboSpan" id="kobo.763.2">We are curious to learn more about the system-internal actors from the </span><code class="literal"><span class="koboSpan" id="kobo.764.1">system</span></code><span class="koboSpan" id="kobo.765.1"> guardian actor. </span><span class="koboSpan" id="kobo.765.2">This time, we send an absolute path selection to </span><code class="literal"><span class="koboSpan" id="kobo.766.1">checker</span></code><span class="koboSpan" id="kobo.767.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.768.1">checker ! </span><span class="koboSpan" id="kobo.768.2">"/system/*" 
</span></pre><p><span class="koboSpan" id="kobo.769.1">The </span><code class="literal"><span class="koboSpan" id="kobo.770.1">checker</span></code><span class="koboSpan" id="kobo.771.1"> actor prints the actor paths of the internal actors </span><code class="literal"><span class="koboSpan" id="kobo.772.1">log1-Logging</span></code><span class="koboSpan" id="kobo.773.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.774.1">deadLetterListener</span></code><span class="koboSpan" id="kobo.775.1">, which are used for logging and for processing unhandled messages, respectively. </span><span class="koboSpan" id="kobo.775.2">We next try identifying a non-existing actor:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.776.1">checker ! </span><span class="koboSpan" id="kobo.776.2">"/user/checker2" 
</span></pre><p><span class="koboSpan" id="kobo.777.1">There are no actors named </span><code class="literal"><span class="koboSpan" id="kobo.778.1">checker2</span></code><span class="koboSpan" id="kobo.779.1">, so </span><code class="literal"><span class="koboSpan" id="kobo.780.1">checker</span></code><span class="koboSpan" id="kobo.781.1"> receives an </span><code class="literal"><span class="koboSpan" id="kobo.782.1">ActorIdentity</span></code><span class="koboSpan" id="kobo.783.1"> message with the </span><code class="literal"><span class="koboSpan" id="kobo.784.1">ref</span></code><span class="koboSpan" id="kobo.785.1"> field set to </span><code class="literal"><span class="koboSpan" id="kobo.786.1">None</span></code><span class="koboSpan" id="kobo.787.1"> and prints that it cannot find an actor on that path.</span></p><p><span class="koboSpan" id="kobo.788.1">Using the </span><code class="literal"><span class="koboSpan" id="kobo.789.1">actorSelection</span></code><span class="koboSpan" id="kobo.790.1"> method and the </span><code class="literal"><span class="koboSpan" id="kobo.791.1">Identify</span></code><span class="koboSpan" id="kobo.792.1"> message is the fundamental method for discovering unknown actors in the same actor system. </span><span class="koboSpan" id="kobo.792.2">Note that we will always obtain an actor reference, and never obtain a pointer to the actor object directly. </span><span class="koboSpan" id="kobo.792.3">To better understand the reasons for this, we will study the lifecycle of actors in the next section.</span></p></div><div class="section" title="The actor lifecycle"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec76"/><span class="koboSpan" id="kobo.793.1">The actor lifecycle</span></h2></div></div></div><p><span class="koboSpan" id="kobo.794.1">Recall that the </span><code class="literal"><span class="koboSpan" id="kobo.795.1">ChildActor</span></code><span class="koboSpan" id="kobo.796.1"> class from the previous section overrode the </span><code class="literal"><span class="koboSpan" id="kobo.797.1">postStop</span></code><span class="koboSpan" id="kobo.798.1"> method to produce some logging output when the actor is stopped. </span><span class="koboSpan" id="kobo.798.2">In this section, we investigate when exactly the </span><code class="literal"><span class="koboSpan" id="kobo.799.1">postStop</span></code><span class="koboSpan" id="kobo.800.1"> method gets called, along with the other important events that comprise the lifecycle of the actor.</span></p><p><span class="koboSpan" id="kobo.801.1">To understand why the actor lifecycle is important, we consider what happens if an actor throws an exception while processing an incoming message. </span><span class="koboSpan" id="kobo.801.2">In Akka, such an exception is considered abnormal behavior, so top-level user actors that throw an exception are by default restarted. </span><span class="koboSpan" id="kobo.801.3">Restarting creates a fresh actor object, and effectively means that the actor state is reinitialized. </span><span class="koboSpan" id="kobo.801.4">When an actor is restarted, its actor reference and actor path remain the same. </span><span class="koboSpan" id="kobo.801.5">Thus, the same </span><code class="literal"><span class="koboSpan" id="kobo.802.1">ActorRef</span></code><span class="koboSpan" id="kobo.803.1"> object might refer to many different physical actor objects during the logical existence of the same actor. </span><span class="koboSpan" id="kobo.803.2">This is one of the reasons why an actor must never allow its </span><code class="literal"><span class="koboSpan" id="kobo.804.1">this</span></code><span class="koboSpan" id="kobo.805.1"> reference to leak. </span><span class="koboSpan" id="kobo.805.2">Doing so allows other parts of the program to refer to an old actor object, consequently invalidating the transparency of the actor reference. </span><span class="koboSpan" id="kobo.805.3">Additionally, revealing the </span><code class="literal"><span class="koboSpan" id="kobo.806.1">this</span></code><span class="koboSpan" id="kobo.807.1"> reference of the actor can reveal the internals of the actor implementation, or even cause data corruption.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip93"/><span class="koboSpan" id="kobo.808.1">Tip</span></h3><p><span class="koboSpan" id="kobo.809.1">Never pass an actor's </span><code class="literal"><span class="koboSpan" id="kobo.810.1">this</span></code><span class="koboSpan" id="kobo.811.1"> reference to other actors, as it breaks actor encapsulation.</span></p></div></div><p><span class="koboSpan" id="kobo.812.1">Let's examine the complete actor lifecycle. </span><span class="koboSpan" id="kobo.812.2">As we have learned, a logical actor instance is created when we call the </span><code class="literal"><span class="koboSpan" id="kobo.813.1">actorOf</span></code><span class="koboSpan" id="kobo.814.1"> method. </span><span class="koboSpan" id="kobo.814.2">The </span><code class="literal"><span class="koboSpan" id="kobo.815.1">Props</span></code><span class="koboSpan" id="kobo.816.1"> object is used to instantiate a physical actor object. </span><span class="koboSpan" id="kobo.816.2">This object is assigned a mailbox, and can start receiving input messages. </span><span class="koboSpan" id="kobo.816.3">The </span><code class="literal"><span class="koboSpan" id="kobo.817.1">actorOf</span></code><span class="koboSpan" id="kobo.818.1"> method returns an actor reference to the caller, and the actors can execute concurrently. </span><span class="koboSpan" id="kobo.818.2">Before the actor starts processing messages, its </span><code class="literal"><span class="koboSpan" id="kobo.819.1">preStart</span></code><span class="koboSpan" id="kobo.820.1"> method is called. </span><span class="koboSpan" id="kobo.820.2">The </span><code class="literal"><span class="koboSpan" id="kobo.821.1">preStart</span></code><span class="koboSpan" id="kobo.822.1"> method is used to initialize the logical actor instance.</span></p><p><span class="koboSpan" id="kobo.823.1">After creation, the actor starts processing messages. </span><span class="koboSpan" id="kobo.823.2">At some point, an actor might need to be restarted due to an exception. </span><span class="koboSpan" id="kobo.823.3">When this happens, the </span><code class="literal"><span class="koboSpan" id="kobo.824.1">preRestart</span></code><span class="koboSpan" id="kobo.825.1"> method is first called. </span><span class="koboSpan" id="kobo.825.2">All the child actors are then stopped. </span><span class="koboSpan" id="kobo.825.3">Then, the </span><code class="literal"><span class="koboSpan" id="kobo.826.1">Props</span></code><span class="koboSpan" id="kobo.827.1"> object, previously used in order to create the actor with the </span><code class="literal"><span class="koboSpan" id="kobo.828.1">actorOf</span></code><span class="koboSpan" id="kobo.829.1"> method, is reused to create a new actor object. </span><span class="koboSpan" id="kobo.829.2">The </span><code class="literal"><span class="koboSpan" id="kobo.830.1">postRestart</span></code><span class="koboSpan" id="kobo.831.1"> method is called on the newly created actor object. </span><span class="koboSpan" id="kobo.831.2">After </span><code class="literal"><span class="koboSpan" id="kobo.832.1">postRestart</span></code><span class="koboSpan" id="kobo.833.1"> returns, the new actor object is assigned the same mailbox as the old actor object, and it continues to process messages that were in the mailbox before the restart.</span></p><p><span class="koboSpan" id="kobo.834.1">By default, the </span><code class="literal"><span class="koboSpan" id="kobo.835.1">postRestart</span></code><span class="koboSpan" id="kobo.836.1"> method calls the </span><code class="literal"><span class="koboSpan" id="kobo.837.1">prestart</span></code><span class="koboSpan" id="kobo.838.1"> method. </span><span class="koboSpan" id="kobo.838.2">In some cases, we want to override this behavior. </span><span class="koboSpan" id="kobo.838.3">For example, a database connection might need to be opened only once during </span><code class="literal"><span class="koboSpan" id="kobo.839.1">preStart</span></code><span class="koboSpan" id="kobo.840.1">, and closed when the logical actor instance is terminated.</span></p><p><span class="koboSpan" id="kobo.841.1">Once the logical actor instance needs to stop, the </span><code class="literal"><span class="koboSpan" id="kobo.842.1">postStop</span></code><span class="koboSpan" id="kobo.843.1"> method gets called. </span><span class="koboSpan" id="kobo.843.2">The actor path associated with the actor is released, and returned to the actor system. </span><span class="koboSpan" id="kobo.843.3">By default, the </span><code class="literal"><span class="koboSpan" id="kobo.844.1">preRestart</span></code><span class="koboSpan" id="kobo.845.1"> method calls the </span><code class="literal"><span class="koboSpan" id="kobo.846.1">postStop</span></code><span class="koboSpan" id="kobo.847.1"> method. </span><span class="koboSpan" id="kobo.847.2">The complete actor lifecycle is illustrated in the following figure:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.848.1"><img src="graphics/image_08_004.jpg" alt="The actor lifecycle"/></span></div><p><span class="koboSpan" id="kobo.849.1">Note that, during the actor lifecycle, the rest of the actor system observes the same actor reference, regardless of how many times the actor restarts. </span><span class="koboSpan" id="kobo.849.2">Actor failures and restarts occur transparently for the rest of the system.</span></p><p><span class="koboSpan" id="kobo.850.1">To experiment with the lifecycle of an actor, we declare two actor classes, </span><code class="literal"><span class="koboSpan" id="kobo.851.1">StringPrinter</span></code><span class="koboSpan" id="kobo.852.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.853.1">LifecycleActor</span></code><span class="koboSpan" id="kobo.854.1">. </span><span class="koboSpan" id="kobo.854.2">The </span><code class="literal"><span class="koboSpan" id="kobo.855.1">StringPrinter</span></code><span class="koboSpan" id="kobo.856.1"> actor prints a logging statement for each message that it receives. </span><span class="koboSpan" id="kobo.856.2">We override its </span><code class="literal"><span class="koboSpan" id="kobo.857.1">preStart</span></code><span class="koboSpan" id="kobo.858.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.859.1">postStop</span></code><span class="koboSpan" id="kobo.860.1"> methods to precisely track when the actor has started and stopped, as shown in the following snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.861.1">class StringPrinter extends Actor { 
  val log = Logging(context.system, this) 
  def receive = { 
    case msg =&gt; log.info(s"printer got message '$msg'") 
  } 
  override def preStart(): Unit = log.info(s"printer preStart.") 
  override def postStop(): Unit = log.info(s"printer postStop.") 
} 
</span></pre><p><span class="koboSpan" id="kobo.862.1">The </span><code class="literal"><span class="koboSpan" id="kobo.863.1">LifecycleActor</span></code><span class="koboSpan" id="kobo.864.1"> class maintains a </span><code class="literal"><span class="koboSpan" id="kobo.865.1">child</span></code><span class="koboSpan" id="kobo.866.1"> actor reference to a </span><code class="literal"><span class="koboSpan" id="kobo.867.1">StringPrinter</span></code><span class="koboSpan" id="kobo.868.1"> actor. </span><span class="koboSpan" id="kobo.868.2">The </span><code class="literal"><span class="koboSpan" id="kobo.869.1">LifecycleActor</span></code><span class="koboSpan" id="kobo.870.1"> class reacts to the </span><code class="literal"><span class="koboSpan" id="kobo.871.1">Double</span></code><span class="koboSpan" id="kobo.872.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.873.1">Int</span></code><span class="koboSpan" id="kobo.874.1"> messages by printing them, and to the </span><code class="literal"><span class="koboSpan" id="kobo.875.1">List</span></code><span class="koboSpan" id="kobo.876.1"> messages by printing the first element of the list. </span><span class="koboSpan" id="kobo.876.2">When it receives a </span><code class="literal"><span class="koboSpan" id="kobo.877.1">String</span></code><span class="koboSpan" id="kobo.878.1"> message, the </span><code class="literal"><span class="koboSpan" id="kobo.879.1">LifecycleActor</span></code><span class="koboSpan" id="kobo.880.1"> instance forwards it to the </span><code class="literal"><span class="koboSpan" id="kobo.881.1">child</span></code><span class="koboSpan" id="kobo.882.1"> actor:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.883.1">class LifecycleActor extends Actor { 
  val log = Logging(context.system, this) 
  var child: ActorRef = _ 
  def receive = { 
    case num: Double  =&gt; log.info(s"got a double - $num") 
    case num: Int     =&gt; log.info(s"got an integer - $num") 
    case lst: List[_] =&gt; log.info(s"list - ${lst.head}, ...") 
    case txt: String  =&gt; child ! </span><span class="koboSpan" id="kobo.883.2">txt 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.884.1">We now override different lifecycle hooks. </span><span class="koboSpan" id="kobo.884.2">We start with the </span><code class="literal"><span class="koboSpan" id="kobo.885.1">preStart</span></code><span class="koboSpan" id="kobo.886.1"> method to output a logging statement and instantiate the </span><code class="literal"><span class="koboSpan" id="kobo.887.1">child</span></code><span class="koboSpan" id="kobo.888.1"> actor. </span><span class="koboSpan" id="kobo.888.2">This ensures that the </span><code class="literal"><span class="koboSpan" id="kobo.889.1">child</span></code><span class="koboSpan" id="kobo.890.1"> reference is initialized before the actor starts processing any messages:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.891.1">override def preStart(): Unit = { 
  log.info("about to start") 
  child = context.actorOf(Props[StringPrinter], "kiddo") 
} 
</span></pre><p><span class="koboSpan" id="kobo.892.1">Next, we override the </span><code class="literal"><span class="koboSpan" id="kobo.893.1">preRestart</span></code><span class="koboSpan" id="kobo.894.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.895.1">postRestart</span></code><span class="koboSpan" id="kobo.896.1"> methods. </span><span class="koboSpan" id="kobo.896.2">In the </span><code class="literal"><span class="koboSpan" id="kobo.897.1">preRestart</span></code><span class="koboSpan" id="kobo.898.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.899.1">postRestart</span></code><span class="koboSpan" id="kobo.900.1"> methods, we log the exception that caused the failure. </span><span class="koboSpan" id="kobo.900.2">The </span><code class="literal"><span class="koboSpan" id="kobo.901.1">postRestart</span></code><span class="koboSpan" id="kobo.902.1"> method calls the </span><code class="literal"><span class="koboSpan" id="kobo.903.1">preStart</span></code><span class="koboSpan" id="kobo.904.1"> method by default, so the new actor object gets initialized with a new </span><code class="literal"><span class="koboSpan" id="kobo.905.1">child</span></code><span class="koboSpan" id="kobo.906.1"> actor after a restart:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.907.1">override def preRestart(t: Throwable, msg: Option[Any]): Unit = { 
  log.info(s"about to restart because of $t, during message $msg") 
  super.preRestart(t, msg) 
} 
override def postRestart(t: Throwable): Unit = { 
  log.info(s"just restarted due to $t") 
  super.postRestart(t) 
} 
</span></pre><p><span class="koboSpan" id="kobo.908.1">Finally, we override the </span><code class="literal"><span class="koboSpan" id="kobo.909.1">postStop</span></code><span class="koboSpan" id="kobo.910.1"> method to track when the actor is stopped:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.911.1">override def postStop() = log.info("just stopped") 
</span></pre><p><span class="koboSpan" id="kobo.912.1">We now create an instance of the </span><code class="literal"><span class="koboSpan" id="kobo.913.1">LifecycleActor</span></code><span class="koboSpan" id="kobo.914.1"> class called </span><code class="literal"><span class="koboSpan" id="kobo.915.1">testy</span></code><span class="koboSpan" id="kobo.916.1">, and send a </span><code class="literal"><span class="koboSpan" id="kobo.917.1">math.Pi</span></code><span class="koboSpan" id="kobo.918.1"> message to it. </span><span class="koboSpan" id="kobo.918.2">The actor prints that it is about to start in its </span><code class="literal"><span class="koboSpan" id="kobo.919.1">preStart</span></code><span class="koboSpan" id="kobo.920.1"> method, and creates a new </span><code class="literal"><span class="koboSpan" id="kobo.921.1">child</span></code><span class="koboSpan" id="kobo.922.1"> actor. </span><span class="koboSpan" id="kobo.922.2">It then prints that it received the value </span><code class="literal"><span class="koboSpan" id="kobo.923.1">math.Pi</span></code><span class="koboSpan" id="kobo.924.1">. </span><span class="koboSpan" id="kobo.924.2">Importantly, the </span><code class="literal"><span class="koboSpan" id="kobo.925.1">child about to start</span></code><span class="koboSpan" id="kobo.926.1"> logging statement is printed after the </span><code class="literal"><span class="koboSpan" id="kobo.927.1">math.Pi</span></code><span class="koboSpan" id="kobo.928.1"> message is received. </span><span class="koboSpan" id="kobo.928.2">This shows that actor creation is an asynchronous operation-when we call </span><code class="literal"><span class="koboSpan" id="kobo.929.1">actorOf</span></code><span class="koboSpan" id="kobo.930.1">, creating the actor is delegated to the actor system, and the program immediately proceeds:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.931.1">val testy = ourSystem.actorOf(Props[LifecycleActor], "testy") 
testy ! </span><span class="koboSpan" id="kobo.931.2">math.Pi 
</span></pre><p><span class="koboSpan" id="kobo.932.1">We then send a string message to </span><code class="literal"><span class="koboSpan" id="kobo.933.1">testy</span></code><span class="koboSpan" id="kobo.934.1">. </span><span class="koboSpan" id="kobo.934.2">The message is forwarded to the </span><code class="literal"><span class="koboSpan" id="kobo.935.1">child</span></code><span class="koboSpan" id="kobo.936.1"> actor, which prints a logging statement, indicating that it received the message:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.937.1">testy ! </span><span class="koboSpan" id="kobo.937.2">"hi there!" 
</span></pre><p><span class="koboSpan" id="kobo.938.1">Finally, we send a </span><code class="literal"><span class="koboSpan" id="kobo.939.1">Nil</span></code><span class="koboSpan" id="kobo.940.1"> message to </span><code class="literal"><span class="koboSpan" id="kobo.941.1">testy</span></code><span class="koboSpan" id="kobo.942.1">. </span><span class="koboSpan" id="kobo.942.2">The </span><code class="literal"><span class="koboSpan" id="kobo.943.1">Nil</span></code><span class="koboSpan" id="kobo.944.1"> object represents an empty list, so </span><code class="literal"><span class="koboSpan" id="kobo.945.1">testy</span></code><span class="koboSpan" id="kobo.946.1"> throws an exception when attempting to fetch the </span><code class="literal"><span class="koboSpan" id="kobo.947.1">head</span></code><span class="koboSpan" id="kobo.948.1"> element. </span><span class="koboSpan" id="kobo.948.2">It reports that it needs to restart. </span><span class="koboSpan" id="kobo.948.3">After that, we witness that the </span><code class="literal"><span class="koboSpan" id="kobo.949.1">child</span></code><span class="koboSpan" id="kobo.950.1"> actor prints the message that it needs to stop; recall that the child actors are stopped when an actor is restarted. </span><span class="koboSpan" id="kobo.950.2">Finally, </span><code class="literal"><span class="koboSpan" id="kobo.951.1">testy</span></code><span class="koboSpan" id="kobo.952.1"> prints that it is about to restart, and the new </span><code class="literal"><span class="koboSpan" id="kobo.953.1">child</span></code><span class="koboSpan" id="kobo.954.1"> actor is instantiated. </span><span class="koboSpan" id="kobo.954.2">These events are caused by the following statement:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.955.1">testy ! </span><span class="koboSpan" id="kobo.955.2">Nil 
</span></pre><p><span class="koboSpan" id="kobo.956.1">Testing the actor lifecycle revealed an important property of the </span><code class="literal"><span class="koboSpan" id="kobo.957.1">actorOf</span></code><span class="koboSpan" id="kobo.958.1"> method. </span><span class="koboSpan" id="kobo.958.2">When we call the </span><code class="literal"><span class="koboSpan" id="kobo.959.1">actorOf</span></code><span class="koboSpan" id="kobo.960.1"> method, the execution proceeds without waiting for the actor to fully initialize itself. </span><span class="koboSpan" id="kobo.960.2">Similarly, sending a message does not block execution until the message is received or processed by another actor; we say that message sends are asynchronous. </span><span class="koboSpan" id="kobo.960.3">In the following section, we will examine various communication patterns that address this asynchronous behavior.</span></p></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Communication between actors"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec54"/><span class="koboSpan" id="kobo.1.1">Communication between actors</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">We have learned that actors communicate by sending messages. </span><span class="koboSpan" id="kobo.2.2">While actors running on the same machine can access shared parts of memory in the presence of proper synchronization, sending messages allows isolating the actor from the rest of the system and ensures location transparency. </span><span class="koboSpan" id="kobo.2.3">The fundamental operation that allows you to send a message to an actor is the </span><code class="literal"><span class="koboSpan" id="kobo.3.1">!</span></code><span class="koboSpan" id="kobo.4.1"> operator.</span></p><p><span class="koboSpan" id="kobo.5.1">We have learned that the </span><code class="literal"><span class="koboSpan" id="kobo.6.1">!</span></code><span class="koboSpan" id="kobo.7.1"> operator is a non-blocking operation-sending a message does not block the execution of the sender until the message is delivered. </span><span class="koboSpan" id="kobo.7.2">This way of sending messages is sometimes called the </span><span class="strong"><strong><span class="koboSpan" id="kobo.8.1">fire-and-forget</span></strong></span><span class="koboSpan" id="kobo.9.1"> pattern, because it does not wait for a reply from the message receiver, nor does it ensure that the message is delivered.</span></p><p><span class="koboSpan" id="kobo.10.1">Sending messages in this way improves the throughput of programs built using actors, but can be limiting in some situations. </span><span class="koboSpan" id="kobo.10.2">For example, we might want to send a message and wait for the response from the target. </span><span class="koboSpan" id="kobo.10.3">In this section, we learn about patterns used in actor communication that go beyond fire-and-forget.</span></p><p><span class="koboSpan" id="kobo.11.1">While the fire-and-forget pattern does not guarantee that the message is delivered, it guarantees that the message is delivered </span><span class="strong"><strong><span class="koboSpan" id="kobo.12.1">at most once</span></strong></span><span class="koboSpan" id="kobo.13.1">. </span><span class="koboSpan" id="kobo.13.2">The target actor never receives duplicate messages. </span><span class="koboSpan" id="kobo.13.3">Furthermore, the messages are guaranteed to be ordered for a given pair of sender and receiver actors. </span><span class="koboSpan" id="kobo.13.4">If an actor </span><span class="strong"><strong><span class="koboSpan" id="kobo.14.1">A</span></strong></span><span class="koboSpan" id="kobo.15.1"> sends messages </span><span class="strong"><strong><span class="koboSpan" id="kobo.16.1">X</span></strong></span><span class="koboSpan" id="kobo.17.1"> and </span><span class="strong"><strong><span class="koboSpan" id="kobo.18.1">Y</span></strong></span><span class="koboSpan" id="kobo.19.1"> in that order, the actor </span><span class="strong"><strong><span class="koboSpan" id="kobo.20.1">B</span></strong></span><span class="koboSpan" id="kobo.21.1"> will receive no duplicate messages, only the message </span><span class="strong"><strong><span class="koboSpan" id="kobo.22.1">X</span></strong></span><span class="koboSpan" id="kobo.23.1">, only the message </span><span class="strong"><strong><span class="koboSpan" id="kobo.24.1">Y</span></strong></span><span class="koboSpan" id="kobo.25.1">, or the message </span><span class="strong"><strong><span class="koboSpan" id="kobo.26.1">X</span></strong></span><span class="koboSpan" id="kobo.27.1">, followed by the message </span><span class="strong"><strong><span class="koboSpan" id="kobo.28.1">Y</span></strong></span><span class="koboSpan" id="kobo.29.1">.</span></p><p><span class="koboSpan" id="kobo.30.1">This is shown on the left in the following figure:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.31.1"><img src="graphics/image_08_005.jpg" alt="Communication between actors"/></span></div><p><span class="koboSpan" id="kobo.32.1">However, the delivery order is not ensured for a group of three or more actors. </span><span class="koboSpan" id="kobo.32.2">For example, as shown on the right in the preceding figure, actor </span><span class="strong"><strong><span class="koboSpan" id="kobo.33.1">A</span></strong></span><span class="koboSpan" id="kobo.34.1"> performs the following actions:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.35.1">Sends a message </span><span class="strong"><strong><span class="koboSpan" id="kobo.36.1">X</span></strong></span><span class="koboSpan" id="kobo.37.1"> to the actor </span><span class="strong"><strong><span class="koboSpan" id="kobo.38.1">B</span></strong></span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.39.1">Sends a message </span><span class="strong"><strong><span class="koboSpan" id="kobo.40.1">Y</span></strong></span><span class="koboSpan" id="kobo.41.1"> to another actor, </span><span class="strong"><strong><span class="koboSpan" id="kobo.42.1">C</span></strong></span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.43.1">Actor </span><span class="strong"><strong><span class="koboSpan" id="kobo.44.1">C</span></strong></span><span class="koboSpan" id="kobo.45.1"> sends a message </span><span class="strong"><strong><span class="koboSpan" id="kobo.46.1">Z</span></strong></span><span class="koboSpan" id="kobo.47.1"> to the actor </span><span class="strong"><strong><span class="koboSpan" id="kobo.48.1">B</span></strong></span><span class="koboSpan" id="kobo.49.1"> after having received </span><span class="strong"><strong><span class="koboSpan" id="kobo.50.1">Y</span></strong></span></li></ul></div><p><span class="koboSpan" id="kobo.51.1">In this situation, the delivery order between messages </span><span class="strong"><strong><span class="koboSpan" id="kobo.52.1">X</span></strong></span><span class="koboSpan" id="kobo.53.1"> and </span><span class="strong"><strong><span class="koboSpan" id="kobo.54.1">Z</span></strong></span><span class="koboSpan" id="kobo.55.1"> is not guaranteed. </span><span class="koboSpan" id="kobo.55.2">The actor </span><span class="strong"><strong><span class="koboSpan" id="kobo.56.1">B</span></strong></span><span class="koboSpan" id="kobo.57.1"> might receive the messages </span><span class="strong"><strong><span class="koboSpan" id="kobo.58.1">X</span></strong></span><span class="koboSpan" id="kobo.59.1"> and </span><span class="strong"><strong><span class="koboSpan" id="kobo.60.1">Z</span></strong></span><span class="koboSpan" id="kobo.61.1"> in any order. </span><span class="koboSpan" id="kobo.61.2">This property reflects the characteristics of most computer networks, and is adopted to allow actors to run transparently on network nodes that may be remote.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note94"/><span class="koboSpan" id="kobo.62.1">Note</span></h3><p><span class="koboSpan" id="kobo.63.1">The order in which an actor </span><span class="strong"><strong><span class="koboSpan" id="kobo.64.1">B</span></strong></span><span class="koboSpan" id="kobo.65.1"> receives messages from an actor </span><span class="strong"><strong><span class="koboSpan" id="kobo.66.1">A</span></strong></span><span class="koboSpan" id="kobo.67.1"> is the same as the order in which these messages are sent from the actor </span><span class="strong"><strong><span class="koboSpan" id="kobo.68.1">A</span></strong></span><span class="koboSpan" id="kobo.69.1">.</span></p></div></div><p><span class="koboSpan" id="kobo.70.1">Before we study various patterns of actor communication, note that the </span><code class="literal"><span class="koboSpan" id="kobo.71.1">!</span></code><span class="koboSpan" id="kobo.72.1"> operator was not the only non-blocking operation. </span><span class="koboSpan" id="kobo.72.2">The methods </span><code class="literal"><span class="koboSpan" id="kobo.73.1">actorOf</span></code><span class="koboSpan" id="kobo.74.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.75.1">actorSelection</span></code><span class="koboSpan" id="kobo.76.1"> are also non-blocking. </span><span class="koboSpan" id="kobo.76.2">These methods are often called while an actor is processing a message. </span><span class="koboSpan" id="kobo.76.3">Blocking the actor while the message is processed prevents the actor from processing subsequent messages in the mailbox and severely compromises the throughput of the system. </span><span class="koboSpan" id="kobo.76.4">For these reasons, most of the actor API is non-blocking. </span><span class="koboSpan" id="kobo.76.5">Additionally, we must never start blocking the operations from third-party libraries from within an actor.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip95"/><span class="koboSpan" id="kobo.77.1">Tip</span></h3><p><span class="koboSpan" id="kobo.78.1">Messages must be handled without blocking indefinitely. </span><span class="koboSpan" id="kobo.78.2">Never start an infinite loop and avoid long-running computations in the </span><code class="literal"><span class="koboSpan" id="kobo.79.1">receive</span></code><span class="koboSpan" id="kobo.80.1"> block, the </span><code class="literal"><span class="koboSpan" id="kobo.81.1">unhandled</span></code><span class="koboSpan" id="kobo.82.1"> method, and within actor lifecycle hooks.</span></p></div></div><div class="section" title="The ask pattern"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec77"/><span class="koboSpan" id="kobo.83.1">The ask pattern</span></h2></div></div></div><p><span class="koboSpan" id="kobo.84.1">Not being able to block from within an actor prevents the request-respond communication pattern. </span><span class="koboSpan" id="kobo.84.2">In this pattern, an actor interested in certain information sends a request message to another actor. </span><span class="koboSpan" id="kobo.84.3">It then needs to wait for a response message from the other actor. </span><span class="koboSpan" id="kobo.84.4">In Akka, this communication pattern is also known as the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.85.1">ask pattern</span></em></span><span class="koboSpan" id="kobo.86.1">.</span></p><p><span class="koboSpan" id="kobo.87.1">The </span><code class="literal"><span class="koboSpan" id="kobo.88.1">akka.pattern</span></code><span class="koboSpan" id="kobo.89.1"> package defines the use of convenience methods in actor communication. </span><span class="koboSpan" id="kobo.89.2">Importing its contents allows us to call the </span><code class="literal"><span class="koboSpan" id="kobo.90.1">?</span></code><span class="koboSpan" id="kobo.91.1"> operator (pronounced ask) on actor references. </span><span class="koboSpan" id="kobo.91.2">This operator sends a message to the target actor, such as the tell operator. </span><span class="koboSpan" id="kobo.91.3">Additionally, the ask operator returns a future object with the response from the target actor.</span></p><p><span class="koboSpan" id="kobo.92.1">To illustrate the usage of the ask pattern, we will define two actors that play ping pong with each other. </span><span class="koboSpan" id="kobo.92.2">A </span><code class="literal"><span class="koboSpan" id="kobo.93.1">Pingy</span></code><span class="koboSpan" id="kobo.94.1"> actor will send a </span><code class="literal"><span class="koboSpan" id="kobo.95.1">ping</span></code><span class="koboSpan" id="kobo.96.1"> request message to another actor, of type </span><code class="literal"><span class="koboSpan" id="kobo.97.1">Pongy</span></code><span class="koboSpan" id="kobo.98.1">. </span><span class="koboSpan" id="kobo.98.2">When the </span><code class="literal"><span class="koboSpan" id="kobo.99.1">Pongy</span></code><span class="koboSpan" id="kobo.100.1"> actor receives the </span><code class="literal"><span class="koboSpan" id="kobo.101.1">ping</span></code><span class="koboSpan" id="kobo.102.1"> message, it sends a </span><code class="literal"><span class="koboSpan" id="kobo.103.1">pong</span></code><span class="koboSpan" id="kobo.104.1"> response message to the sender. </span><span class="koboSpan" id="kobo.104.2">We start by importing the </span><code class="literal"><span class="koboSpan" id="kobo.105.1">akka.pattern</span></code><span class="koboSpan" id="kobo.106.1"> package:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.107.1">import akka.pattern._ 
</span></pre><p><span class="koboSpan" id="kobo.108.1">We first define the </span><code class="literal"><span class="koboSpan" id="kobo.109.1">Pongy</span></code><span class="koboSpan" id="kobo.110.1"> actor class. </span><span class="koboSpan" id="kobo.110.2">To respond to the </span><code class="literal"><span class="koboSpan" id="kobo.111.1">ping</span></code><span class="koboSpan" id="kobo.112.1"> incoming message, the </span><code class="literal"><span class="koboSpan" id="kobo.113.1">Pongy</span></code><span class="koboSpan" id="kobo.114.1"> actor needs an actor reference of the sender. </span><span class="koboSpan" id="kobo.114.2">While processing a message, every actor can call the </span><code class="literal"><span class="koboSpan" id="kobo.115.1">sender</span></code><span class="koboSpan" id="kobo.116.1"> method of the </span><code class="literal"><span class="koboSpan" id="kobo.117.1">Actor</span></code><span class="koboSpan" id="kobo.118.1"> class to obtain the actor reference of the sender of the current message. </span><span class="koboSpan" id="kobo.118.2">The </span><code class="literal"><span class="koboSpan" id="kobo.119.1">Pongy</span></code><span class="koboSpan" id="kobo.120.1"> actor uses the </span><code class="literal"><span class="koboSpan" id="kobo.121.1">sender</span></code><span class="koboSpan" id="kobo.122.1"> method to send </span><code class="literal"><span class="koboSpan" id="kobo.123.1">ping</span></code><span class="koboSpan" id="kobo.124.1"> back to the </span><code class="literal"><span class="koboSpan" id="kobo.125.1">Pingy</span></code><span class="koboSpan" id="kobo.126.1"> actor. </span><span class="koboSpan" id="kobo.126.2">The </span><code class="literal"><span class="koboSpan" id="kobo.127.1">Pongy</span></code><span class="koboSpan" id="kobo.128.1"> implementation is shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.129.1">class Pongy extends Actor { 
  val log = Logging(context.system, this) 
  def receive = { 
    case "ping" =&gt; 
      log.info("Got a ping -- ponging back!") 
      sender ! </span><span class="koboSpan" id="kobo.129.2">"pong" 
      context.stop(self) 
  } 
  override def postStop() = log.info("pongy going down") 
} 
</span></pre><p><span class="koboSpan" id="kobo.130.1">Next, we define the </span><code class="literal"><span class="koboSpan" id="kobo.131.1">Pingy</span></code><span class="koboSpan" id="kobo.132.1"> actor class, which uses the ask operator to send a request to the </span><code class="literal"><span class="koboSpan" id="kobo.133.1">Pongy</span></code><span class="koboSpan" id="kobo.134.1"> actor. </span><span class="koboSpan" id="kobo.134.2">When the </span><code class="literal"><span class="koboSpan" id="kobo.135.1">Pingy</span></code><span class="koboSpan" id="kobo.136.1"> class receives a </span><code class="literal"><span class="koboSpan" id="kobo.137.1">pongyRef</span></code><span class="koboSpan" id="kobo.138.1"> actor reference of </span><code class="literal"><span class="koboSpan" id="kobo.139.1">Pongy</span></code><span class="koboSpan" id="kobo.140.1">, it creates an implicit </span><code class="literal"><span class="koboSpan" id="kobo.141.1">Timeout</span></code><span class="koboSpan" id="kobo.142.1"> object set to two seconds. </span><span class="koboSpan" id="kobo.142.2">Using the ask operator requires an implicit </span><code class="literal"><span class="koboSpan" id="kobo.143.1">Timeout</span></code><span class="koboSpan" id="kobo.144.1"> object in scope; the future is failed with an </span><code class="literal"><span class="koboSpan" id="kobo.145.1">AskTimeoutException</span></code><span class="koboSpan" id="kobo.146.1"> exception if the response message does not arrive within the given timeframe. </span><span class="koboSpan" id="kobo.146.2">Once </span><code class="literal"><span class="koboSpan" id="kobo.147.1">Pingy</span></code><span class="koboSpan" id="kobo.148.1"> class sends the </span><code class="literal"><span class="koboSpan" id="kobo.149.1">ping</span></code><span class="koboSpan" id="kobo.150.1"> message, it is left with an </span><code class="literal"><span class="koboSpan" id="kobo.151.1">f</span></code><span class="koboSpan" id="kobo.152.1"> future object. </span><span class="koboSpan" id="kobo.152.2">The </span><code class="literal"><span class="koboSpan" id="kobo.153.1">Pingy</span></code><span class="koboSpan" id="kobo.154.1"> actor uses the special </span><code class="literal"><span class="koboSpan" id="kobo.155.1">pipeTo</span></code><span class="koboSpan" id="kobo.156.1"> combinator that sends the value in the future to the sender of the </span><code class="literal"><span class="koboSpan" id="kobo.157.1">pongyRef</span></code><span class="koboSpan" id="kobo.158.1"> actor reference, as shown in the following code:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.159.1">import akka.util.Timeout 
import scala.concurrent.duration._ 
class Pingy extends Actor { 
  val log = Logging(context.system, this) 
  def receive = { 
    case pongyRef: ActorRef =&gt; 
      implicit val timeout = Timeout(2 seconds) 
      val f = pongyRef ? </span><span class="koboSpan" id="kobo.159.2">"ping" 
      f pipeTo sender 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.160.1">The message in the future object can be manipulated using the standard future combinators seen in </span><a class="link" href="ch04.html" title="Chapter 4.  Asynchronous Programming with Futures and Promises"><span class="koboSpan" id="kobo.161.1">Chapter 4</span></a><span class="koboSpan" id="kobo.162.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.163.1">Asynchronous Programming with Futures and Promises</span></em></span><span class="koboSpan" id="kobo.164.1">. </span><span class="koboSpan" id="kobo.164.2">However, the following definition of the </span><code class="literal"><span class="koboSpan" id="kobo.165.1">Pingy</span></code><span class="koboSpan" id="kobo.166.1"> actor would not be correct:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.167.1">class Pingy extends Actor { 
  val log = Logging(context.system, this) 
  def receive = { 
    case pongyRef: ActorRef =&gt; 
      implicit val timeout = Timeout(2 seconds) 
      val f = pongyRef ? </span><span class="koboSpan" id="kobo.167.2">"ping" 
      f onComplete { case v =&gt; log.info(s"Response: $v") } // bad! 
  </span><span class="koboSpan" id="kobo.167.3">} 
} 
</span></pre><p><span class="koboSpan" id="kobo.168.1">Although it is perfectly legal to call the </span><code class="literal"><span class="koboSpan" id="kobo.169.1">onComplete</span></code><span class="koboSpan" id="kobo.170.1"> on the </span><code class="literal"><span class="koboSpan" id="kobo.171.1">f</span></code><span class="koboSpan" id="kobo.172.1"> future, the subsequent asynchronous computation should not access any mutable actor state. </span><span class="koboSpan" id="kobo.172.2">Recall that the actor state should be visible only to the actor, so concurrently accessing it opens the possibility of data races and race conditions. </span><span class="koboSpan" id="kobo.172.3">The </span><code class="literal"><span class="koboSpan" id="kobo.173.1">log</span></code><span class="koboSpan" id="kobo.174.1"> object should only be accessed by the actor that owns it. </span><span class="koboSpan" id="kobo.174.2">Similarly, we should not call the </span><code class="literal"><span class="koboSpan" id="kobo.175.1">sender</span></code><span class="koboSpan" id="kobo.176.1"> method from within the </span><code class="literal"><span class="koboSpan" id="kobo.177.1">onComplete</span></code><span class="koboSpan" id="kobo.178.1"> handler. </span><span class="koboSpan" id="kobo.178.2">By the time the future is completed with the response message, the actor might be processing a different message with a different sender, so the </span><code class="literal"><span class="koboSpan" id="kobo.179.1">sender</span></code><span class="koboSpan" id="kobo.180.1"> method can return arbitrary values.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip96"/><span class="koboSpan" id="kobo.181.1">Tip</span></h3><p><span class="koboSpan" id="kobo.182.1">When starting an asynchronous computation from within the </span><code class="literal"><span class="koboSpan" id="kobo.183.1">receive</span></code><span class="koboSpan" id="kobo.184.1"> block, the </span><code class="literal"><span class="koboSpan" id="kobo.185.1">unhandled</span></code><span class="koboSpan" id="kobo.186.1"> method, or a lifecycle hook, never let the closure capture any mutable actor state.</span></p></div></div><p><span class="koboSpan" id="kobo.187.1">To test </span><code class="literal"><span class="koboSpan" id="kobo.188.1">Pingy</span></code><span class="koboSpan" id="kobo.189.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.190.1">Pongy</span></code><span class="koboSpan" id="kobo.191.1"> in action, we define the </span><code class="literal"><span class="koboSpan" id="kobo.192.1">Master</span></code><span class="koboSpan" id="kobo.193.1"> actor class that instantiates them. </span><span class="koboSpan" id="kobo.193.2">Upon receiving the </span><code class="literal"><span class="koboSpan" id="kobo.194.1">start</span></code><span class="koboSpan" id="kobo.195.1"> message, the </span><code class="literal"><span class="koboSpan" id="kobo.196.1">Master</span></code><span class="koboSpan" id="kobo.197.1"> actor passes the </span><code class="literal"><span class="koboSpan" id="kobo.198.1">pongy</span></code><span class="koboSpan" id="kobo.199.1"> reference to the </span><code class="literal"><span class="koboSpan" id="kobo.200.1">pingy</span></code><span class="koboSpan" id="kobo.201.1"> reference. </span><span class="koboSpan" id="kobo.201.2">Once the </span><code class="literal"><span class="koboSpan" id="kobo.202.1">pingy</span></code><span class="koboSpan" id="kobo.203.1"> actor returns a </span><code class="literal"><span class="koboSpan" id="kobo.204.1">pong</span></code><span class="koboSpan" id="kobo.205.1"> message from </span><code class="literal"><span class="koboSpan" id="kobo.206.1">pongy</span></code><span class="koboSpan" id="kobo.207.1">, the </span><code class="literal"><span class="koboSpan" id="kobo.208.1">Master</span></code><span class="koboSpan" id="kobo.209.1"> actor stops. </span><span class="koboSpan" id="kobo.209.2">This is shown in the following </span><code class="literal"><span class="koboSpan" id="kobo.210.1">Master</span></code><span class="koboSpan" id="kobo.211.1"> actor template:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.212.1">class Master extends Actor { 
  val pingy = ourSystem.actorOf(Props[Pingy], "pingy") 
  val pongy = ourSystem.actorOf(Props[Pongy], "pongy") 
  def receive = { 
    case "start" =&gt; 
      pingy ! </span><span class="koboSpan" id="kobo.212.2">pongy 
    case "pong" =&gt; 
      context.stop(self) 
  } 
  override def postStop() = log.info("master going down") 
} 
val masta = ourSystem.actorOf(Props[Master], "masta") 
masta ! </span><span class="koboSpan" id="kobo.212.3">"start" 
</span></pre><p><span class="koboSpan" id="kobo.213.1">The ask pattern is useful because it allows you to send requests to multiple actors and obtain futures with their responses. </span><span class="koboSpan" id="kobo.213.2">Values from multiple futures can be combined within </span><code class="literal"><span class="koboSpan" id="kobo.214.1">for</span></code><span class="koboSpan" id="kobo.215.1"> comprehensions to compute a value from several responses. </span><span class="koboSpan" id="kobo.215.2">Using the fire-and-forget pattern when communicating with multiple actors requires changing the actor behavior, and is a lot more cumbersome than the ask pattern.</span></p></div><div class="section" title="The forward pattern"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec78"/><span class="koboSpan" id="kobo.216.1">The forward pattern</span></h2></div></div></div><p><span class="koboSpan" id="kobo.217.1">Some actors exist solely to forward messages to other actors. </span><span class="koboSpan" id="kobo.217.2">For example, an actor might be responsible for load-balancing request messages between several worker actors, or it might forward the message to its mirror actor to ensure better availability. </span><span class="koboSpan" id="kobo.217.3">In such cases, it is useful to forward the message without changing the </span><code class="literal"><span class="koboSpan" id="kobo.218.1">sender</span></code><span class="koboSpan" id="kobo.219.1"> field of the message. </span><span class="koboSpan" id="kobo.219.2">The </span><code class="literal"><span class="koboSpan" id="kobo.220.1">forward</span></code><span class="koboSpan" id="kobo.221.1"> method on actor references serves this purpose.</span></p><p><span class="koboSpan" id="kobo.222.1">In the following code, we use the </span><code class="literal"><span class="koboSpan" id="kobo.223.1">StringPrinter</span></code><span class="koboSpan" id="kobo.224.1"> actor from the previous section to define a </span><code class="literal"><span class="koboSpan" id="kobo.225.1">Router</span></code><span class="koboSpan" id="kobo.226.1"> actor class. </span><span class="koboSpan" id="kobo.226.2">A </span><code class="literal"><span class="koboSpan" id="kobo.227.1">Router</span></code><span class="koboSpan" id="kobo.228.1"> actor instantiates four child </span><code class="literal"><span class="koboSpan" id="kobo.229.1">StringPrinter</span></code><span class="koboSpan" id="kobo.230.1"> actors and maintains an </span><code class="literal"><span class="koboSpan" id="kobo.231.1">i</span></code><span class="koboSpan" id="kobo.232.1"> field with the index of the list child it forwarded the message to. </span><span class="koboSpan" id="kobo.232.2">Whenever it receives a message, it forwards the message to a different </span><code class="literal"><span class="koboSpan" id="kobo.233.1">StringPrinter</span></code><span class="koboSpan" id="kobo.234.1"> child before incrementing the </span><code class="literal"><span class="koboSpan" id="kobo.235.1">i</span></code><span class="koboSpan" id="kobo.236.1"> field:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.237.1">class Router extends Actor { 
  var i = 0 
  val children = for (_ &lt;- 0 until 4) yield 
    context.actorOf(Props[StringPrinter]) 
  def receive = { 
    case msg =&gt; 
      children(i) forward msg 
      i = (i + 1) % 4 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.238.1">In the following code, we create a </span><code class="literal"><span class="koboSpan" id="kobo.239.1">Router</span></code><span class="koboSpan" id="kobo.240.1"> actor and test it by sending it two messages. </span><span class="koboSpan" id="kobo.240.2">We can observe that the messages are printed to the standard output by two different </span><code class="literal"><span class="koboSpan" id="kobo.241.1">StringPrinter</span></code><span class="koboSpan" id="kobo.242.1"> actors, denoted with actors on the actor paths </span><code class="literal"><span class="koboSpan" id="kobo.243.1">/user/router/$b</span></code><span class="koboSpan" id="kobo.244.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.245.1">/user/router/$a</span></code><span class="koboSpan" id="kobo.246.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.247.1">val router = ourSystem.actorOf(Props[Router], "router") 
router ! </span><span class="koboSpan" id="kobo.247.2">"Hola" 
router ! </span><span class="koboSpan" id="kobo.247.3">"Hey!" 
</span></pre><p><span class="koboSpan" id="kobo.248.1">The forward pattern is typically used in router actors, which use specific knowledge to decide about the destination of the message; replicator actors, which send the message to multiple destinations; or load balancers, which ensure that the workload is spread evenly between a set of worker actors.</span></p></div><div class="section" title="Stopping actors"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec79"/><span class="koboSpan" id="kobo.249.1">Stopping actors</span></h2></div></div></div><p><span class="koboSpan" id="kobo.250.1">So far, we have stopped different actors by making them call </span><code class="literal"><span class="koboSpan" id="kobo.251.1">context.stop</span></code><span class="koboSpan" id="kobo.252.1">. </span><span class="koboSpan" id="kobo.252.2">Calling the </span><code class="literal"><span class="koboSpan" id="kobo.253.1">stop</span></code><span class="koboSpan" id="kobo.254.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.255.1">context</span></code><span class="koboSpan" id="kobo.256.1"> object terminates the actor immediately after the current message is processed. </span><span class="koboSpan" id="kobo.256.2">In some cases, we want to have more control over how an actor gets terminated. </span><span class="koboSpan" id="kobo.256.3">For example, we might want to allow the actor to process its remaining messages or wait for the termination of some other actors. </span><span class="koboSpan" id="kobo.256.4">In Akka, there are several special message types that assist us in doing so, and we study them in this section.</span></p><p><span class="koboSpan" id="kobo.257.1">In many cases, we do not want to terminate an actor instance, but simply restart it. </span><span class="koboSpan" id="kobo.257.2">We have previously learned that an actor is automatically restarted when it throws an exception. </span><span class="koboSpan" id="kobo.257.3">An actor is also restarted when it receives the </span><code class="literal"><span class="koboSpan" id="kobo.258.1">Kill</span></code><span class="koboSpan" id="kobo.259.1"> message-when we send a </span><code class="literal"><span class="koboSpan" id="kobo.260.1">Kill</span></code><span class="koboSpan" id="kobo.261.1"> message to an actor, the actor automatically throws an </span><code class="literal"><span class="koboSpan" id="kobo.262.1">ActorKilledException</span></code><span class="koboSpan" id="kobo.263.1"> and fails.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip97"/><span class="koboSpan" id="kobo.264.1">Tip</span></h3><p><span class="koboSpan" id="kobo.265.1">Use the </span><code class="literal"><span class="koboSpan" id="kobo.266.1">Kill</span></code><span class="koboSpan" id="kobo.267.1"> message to restart the target actor without losing the messages in the mailbox.</span></p></div></div><p><span class="koboSpan" id="kobo.268.1">Unlike the </span><code class="literal"><span class="koboSpan" id="kobo.269.1">stop</span></code><span class="koboSpan" id="kobo.270.1"> method, the </span><code class="literal"><span class="koboSpan" id="kobo.271.1">Kill</span></code><span class="koboSpan" id="kobo.272.1"> message does not terminate the actor, but only restarts it. </span><span class="koboSpan" id="kobo.272.2">In some cases, we want to terminate the actor instance, but allow it to process the messages from its mailbox. </span><span class="koboSpan" id="kobo.272.3">Sending a </span><code class="literal"><span class="koboSpan" id="kobo.273.1">PoisonPill</span></code><span class="koboSpan" id="kobo.274.1"> message to an actor has the same effect as calling </span><code class="literal"><span class="koboSpan" id="kobo.275.1">stop</span></code><span class="koboSpan" id="kobo.276.1">, but allows the actor to process the messages that were in the mailbox before the </span><code class="literal"><span class="koboSpan" id="kobo.277.1">PoisonPill</span></code><span class="koboSpan" id="kobo.278.1"> message arrives.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip98"/><span class="koboSpan" id="kobo.279.1">Tip</span></h3><p><span class="koboSpan" id="kobo.280.1">Use the </span><code class="literal"><span class="koboSpan" id="kobo.281.1">PoisonPill</span></code><span class="koboSpan" id="kobo.282.1"> message to stop the actor, but allow it to process the messages received before the </span><code class="literal"><span class="koboSpan" id="kobo.283.1">PoisonPill</span></code><span class="koboSpan" id="kobo.284.1"> message.</span></p></div></div><p><span class="koboSpan" id="kobo.285.1">In some cases, allowing the actor to process its message using </span><code class="literal"><span class="koboSpan" id="kobo.286.1">PoisonPill</span></code><span class="koboSpan" id="kobo.287.1"> is not enough. </span><span class="koboSpan" id="kobo.287.2">An actor might have to wait for other actors to terminate before terminating itself. </span><span class="koboSpan" id="kobo.287.3">An orderly shutdown is important in some cases, as actors might be involved in sensitive operations, such as writing to a file on the disk. </span><span class="koboSpan" id="kobo.287.4">We do not want to forcefully stop them when we end the application. </span><span class="koboSpan" id="kobo.287.5">A facility that allows an actor to track the termination of other actors is called </span><span class="strong"><strong><span class="koboSpan" id="kobo.288.1">DeathWatch</span></strong></span><span class="koboSpan" id="kobo.289.1"> in Akka.</span></p><p><span class="koboSpan" id="kobo.290.1">Recall the earlier example with the </span><code class="literal"><span class="koboSpan" id="kobo.291.1">Pingy</span></code><span class="koboSpan" id="kobo.292.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.293.1">Pongy</span></code><span class="koboSpan" id="kobo.294.1"> actors. </span><span class="koboSpan" id="kobo.294.2">Let's say that we want to terminate the </span><code class="literal"><span class="koboSpan" id="kobo.295.1">Pingy</span></code><span class="koboSpan" id="kobo.296.1"> actor, but only after the </span><code class="literal"><span class="koboSpan" id="kobo.297.1">Pongy</span></code><span class="koboSpan" id="kobo.298.1"> actor has already been terminated. </span><span class="koboSpan" id="kobo.298.2">We define a new </span><code class="literal"><span class="koboSpan" id="kobo.299.1">GracefulPingy</span></code><span class="koboSpan" id="kobo.300.1"> actor class for this purpose. </span><span class="koboSpan" id="kobo.300.2">The </span><code class="literal"><span class="koboSpan" id="kobo.301.1">GracefulPingy</span></code><span class="koboSpan" id="kobo.302.1"> actor class calls the </span><code class="literal"><span class="koboSpan" id="kobo.303.1">watch</span></code><span class="koboSpan" id="kobo.304.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.305.1">context</span></code><span class="koboSpan" id="kobo.306.1"> object when it gets created. </span><span class="koboSpan" id="kobo.306.2">This ensures that, after </span><code class="literal"><span class="koboSpan" id="kobo.307.1">Pongy</span></code><span class="koboSpan" id="kobo.308.1"> actor terminates and its </span><code class="literal"><span class="koboSpan" id="kobo.309.1">postStop</span></code><span class="koboSpan" id="kobo.310.1"> method completes, </span><code class="literal"><span class="koboSpan" id="kobo.311.1">GracefulPingy</span></code><span class="koboSpan" id="kobo.312.1"> actor receives a </span><code class="literal"><span class="koboSpan" id="kobo.313.1">Terminated</span></code><span class="koboSpan" id="kobo.314.1"> message with the actor reference to </span><code class="literal"><span class="koboSpan" id="kobo.315.1">Pongy</span></code><span class="koboSpan" id="kobo.316.1"> actor.</span></p><p><span class="koboSpan" id="kobo.317.1">Upon receiving the </span><code class="literal"><span class="koboSpan" id="kobo.318.1">Terminated</span></code><span class="koboSpan" id="kobo.319.1"> message, </span><code class="literal"><span class="koboSpan" id="kobo.320.1">GracefulPingy</span></code><span class="koboSpan" id="kobo.321.1"> stops itself, as shown in the following </span><code class="literal"><span class="koboSpan" id="kobo.322.1">GracefulPingy</span></code><span class="koboSpan" id="kobo.323.1"> implementation:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.324.1">class GracefulPingy extends Actor { 
  val pongy = context.actorOf(Props[Pongy], "pongy") 
  context.watch(pongy) 
  def receive = { 
    case "Die, Pingy!" </span><span class="koboSpan" id="kobo.324.2">=&gt; 
      context.stop(pongy) 
    case Terminated(`pongy`) =&gt; 
      context.stop(self) 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.325.1">Whenever we want to track the termination of an actor from inside an actor, we use DeathWatch, as in the previous example. </span><span class="koboSpan" id="kobo.325.2">When we need to wait for the termination of an actor from outside an actor, we use the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.326.1">graceful stop pattern</span></em></span><span class="koboSpan" id="kobo.327.1">. </span><span class="koboSpan" id="kobo.327.2">The </span><code class="literal"><span class="koboSpan" id="kobo.328.1">gracefulStop</span></code><span class="koboSpan" id="kobo.329.1"> method from the </span><code class="literal"><span class="koboSpan" id="kobo.330.1">akka.pattern</span></code><span class="koboSpan" id="kobo.331.1"> package takes an actor reference, a timeout, and a shutdown message. </span><span class="koboSpan" id="kobo.331.2">It returns a future and asynchronously sends the shutdown message to the actor. </span><span class="koboSpan" id="kobo.331.3">If the actor terminates within the allotted timeout, the future is successfully completed. </span><span class="koboSpan" id="kobo.331.4">Otherwise, the future fails.</span></p><p><span class="koboSpan" id="kobo.332.1">In the following code, we create a </span><code class="literal"><span class="koboSpan" id="kobo.333.1">GracefulPingy</span></code><span class="koboSpan" id="kobo.334.1"> actor instance and call the </span><code class="literal"><span class="koboSpan" id="kobo.335.1">gracefulStop</span></code><span class="koboSpan" id="kobo.336.1"> method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.337.1">object CommunicatingGracefulStop extends App { 
  val grace = ourSystem.actorOf(Props[GracefulPingy], "grace") 
  val stopped = 
    gracefulStop(grace, 3.seconds, "Die, Pingy!") 
  stopped onComplete { 
    case Success(x) =&gt; 
      log("graceful shutdown successful") 
      ourSystem.shutdown() 
    case Failure(t) =&gt; 
      log("grace not stopped!") 
      ourSystem.shutdown() 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.338.1">We typically use DeathWatch inside the actors, and the graceful stop pattern in the main application thread. </span><span class="koboSpan" id="kobo.338.2">The graceful stop pattern can be used within actors as well, as long as we are careful that the callbacks on the future returned by the </span><code class="literal"><span class="koboSpan" id="kobo.339.1">gracefulStop</span></code><span class="koboSpan" id="kobo.340.1"> method do not capture actor state. </span><span class="koboSpan" id="kobo.340.2">Together, DeathWatch and the graceful stop pattern allow safely shutting down actor-based programs.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Actor supervision"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec55"/><span class="koboSpan" id="kobo.1.1">Actor supervision</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">When studying the actor lifecycle, we said that top-level user actors are by default restarted when an exception occurs. </span><span class="koboSpan" id="kobo.2.2">We now take a closer inspection at how this works. </span><span class="koboSpan" id="kobo.2.3">In Akka, every actor acts as a supervisor for its children. </span><span class="koboSpan" id="kobo.2.4">When a child fails, it suspends the processing messages, and sends a message to its parent to decide what to do about the failure. </span><span class="koboSpan" id="kobo.2.5">The policy that decides what happens to the parent and the child after the child fails is called the </span><span class="strong"><strong><span class="koboSpan" id="kobo.3.1">supervision strategy</span></strong></span><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">The parent might decide to do the following:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.5.1">Restart the actor, indicated with the </span><code class="literal"><span class="koboSpan" id="kobo.6.1">Restart</span></code><span class="koboSpan" id="kobo.7.1"> message</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.8.1">Resume the actor without a restart, indicated with the </span><code class="literal"><span class="koboSpan" id="kobo.9.1">Resume</span></code><span class="koboSpan" id="kobo.10.1"> message</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.11.1">Permanently stop the actor, indicated with the </span><code class="literal"><span class="koboSpan" id="kobo.12.1">Stop</span></code><span class="koboSpan" id="kobo.13.1"> message</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.14.1">Fail itself with the same exception, indicated with the </span><code class="literal"><span class="koboSpan" id="kobo.15.1">Escalate</span></code><span class="koboSpan" id="kobo.16.1"> message</span></li></ul></div><p><span class="koboSpan" id="kobo.17.1">By default, the </span><code class="literal"><span class="koboSpan" id="kobo.18.1">user</span></code><span class="koboSpan" id="kobo.19.1"> guardian actor comes with a supervision strategy that restarts the failed children actors. </span><span class="koboSpan" id="kobo.19.2">User actors stop their children by default. </span><span class="koboSpan" id="kobo.19.3">Both supervision strategies can be overridden.</span></p><p><span class="koboSpan" id="kobo.20.1">To override the default supervision strategy in user actors, we override the </span><code class="literal"><span class="koboSpan" id="kobo.21.1">supervisorStrategy</span></code><span class="koboSpan" id="kobo.22.1"> field of the </span><code class="literal"><span class="koboSpan" id="kobo.23.1">Actor</span></code><span class="koboSpan" id="kobo.24.1"> class. </span><span class="koboSpan" id="kobo.24.2">In the following code, we define a particularly troublesome actor class called </span><code class="literal"><span class="koboSpan" id="kobo.25.1">Naughty</span></code><span class="koboSpan" id="kobo.26.1">. </span><span class="koboSpan" id="kobo.26.2">When the </span><code class="literal"><span class="koboSpan" id="kobo.27.1">Naughty</span></code><span class="koboSpan" id="kobo.28.1"> class receives a </span><code class="literal"><span class="koboSpan" id="kobo.29.1">String</span></code><span class="koboSpan" id="kobo.30.1"> type message, it prints a logging statement. </span><span class="koboSpan" id="kobo.30.2">For all other message types, it throws the </span><code class="literal"><span class="koboSpan" id="kobo.31.1">RuntimeException</span></code><span class="koboSpan" id="kobo.32.1">, as shown in the following implementation:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.33.1">class Naughty extends Actor { 
  val log = Logging(context.system, this) 
  def receive = { 
    case s: String =&gt; log.info(s) 
    case msg =&gt; throw new RuntimeException 
  } 
  override def postRestart(t: Throwable) = 
    log.info("naughty restarted") 
} 
</span></pre><p><span class="koboSpan" id="kobo.34.1">Next, we declare a </span><code class="literal"><span class="koboSpan" id="kobo.35.1">Supervisor</span></code><span class="koboSpan" id="kobo.36.1"> actor class, which creates a child actor of the </span><code class="literal"><span class="koboSpan" id="kobo.37.1">Naughty</span></code><span class="koboSpan" id="kobo.38.1"> type. </span><span class="koboSpan" id="kobo.38.2">The </span><code class="literal"><span class="koboSpan" id="kobo.39.1">Supervisor</span></code><span class="koboSpan" id="kobo.40.1"> actor does not handle any messages, but overrides the default supervision strategy. </span><span class="koboSpan" id="kobo.40.2">If a </span><code class="literal"><span class="koboSpan" id="kobo.41.1">Supervisor</span></code><span class="koboSpan" id="kobo.42.1"> actor's child actor fails because of throwing an </span><code class="literal"><span class="koboSpan" id="kobo.43.1">ActorKilledException</span></code><span class="koboSpan" id="kobo.44.1">, it is restarted. </span><span class="koboSpan" id="kobo.44.2">However, if its child actor fails with any other exception type, the exception is escalated to the </span><code class="literal"><span class="koboSpan" id="kobo.45.1">Supervisor</span></code><span class="koboSpan" id="kobo.46.1"> actor. </span><span class="koboSpan" id="kobo.46.2">We override the </span><code class="literal"><span class="koboSpan" id="kobo.47.1">supervisorStrategy</span></code><span class="koboSpan" id="kobo.48.1"> field with the value </span><code class="literal"><span class="koboSpan" id="kobo.49.1">OneForOneStrategy</span></code><span class="koboSpan" id="kobo.50.1">, a supervision strategy that applies fault handling specifically to the actor that failed:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.51.1">class Supervisor extends Actor { 
  val child = context.actorOf(Props[StringPrinter], "naughty") 
  def receive = PartialFunction.empty 
  override val supervisorStrategy = 
    OneForOneStrategy() { 
      case ake: ActorKilledException =&gt; Restart 
      case _ =&gt; Escalate 
    } 
} 
</span></pre><p><span class="koboSpan" id="kobo.52.1">We test the new supervisor strategy by creating an actor instance, </span><code class="literal"><span class="koboSpan" id="kobo.53.1">super</span></code><span class="koboSpan" id="kobo.54.1">, of the </span><code class="literal"><span class="koboSpan" id="kobo.55.1">Supervisor</span></code><span class="koboSpan" id="kobo.56.1"> actor class. </span><span class="koboSpan" id="kobo.56.2">We then create an actor selection for all the children of </span><code class="literal"><span class="koboSpan" id="kobo.57.1">super</span></code><span class="koboSpan" id="kobo.58.1">, and send them a </span><code class="literal"><span class="koboSpan" id="kobo.59.1">Kill</span></code><span class="koboSpan" id="kobo.60.1"> message. </span><span class="koboSpan" id="kobo.60.2">This fails the </span><code class="literal"><span class="koboSpan" id="kobo.61.1">Naughty</span></code><span class="koboSpan" id="kobo.62.1"> actor, but </span><code class="literal"><span class="koboSpan" id="kobo.63.1">super</span></code><span class="koboSpan" id="kobo.64.1"> restarts it due to its supervision strategy. </span><span class="koboSpan" id="kobo.64.2">We then apologize to the </span><code class="literal"><span class="koboSpan" id="kobo.65.1">Naughty</span></code><span class="koboSpan" id="kobo.66.1"> actor by sending it a </span><code class="literal"><span class="koboSpan" id="kobo.67.1">String</span></code><span class="koboSpan" id="kobo.68.1"> message. </span><span class="koboSpan" id="kobo.68.2">Finally, we convert a </span><code class="literal"><span class="koboSpan" id="kobo.69.1">String</span></code><span class="koboSpan" id="kobo.70.1"> message to a list of characters, and send it to the </span><code class="literal"><span class="koboSpan" id="kobo.71.1">Naughty</span></code><span class="koboSpan" id="kobo.72.1"> actor, which then throws a </span><code class="literal"><span class="koboSpan" id="kobo.73.1">RuntimeException</span></code><span class="koboSpan" id="kobo.74.1">. </span><span class="koboSpan" id="kobo.74.2">This exception is escalated by </span><code class="literal"><span class="koboSpan" id="kobo.75.1">super</span></code><span class="koboSpan" id="kobo.76.1">, and both actors are terminated, as shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.77.1">ourSystem.actorOf(Props[Supervisor], "super") 
ourSystem.actorSelection("/user/super/*") ! </span><span class="koboSpan" id="kobo.77.2">Kill 
ourSystem.actorSelection("/user/super/*") ! </span><span class="koboSpan" id="kobo.77.3">"sorry about that" 
ourSystem.actorSelection("/user/super/*") ! </span><span class="koboSpan" id="kobo.77.4">"kaboom".toList 
</span></pre><p><span class="koboSpan" id="kobo.78.1">In this example, we saw how the </span><code class="literal"><span class="koboSpan" id="kobo.79.1">OneForOneStrategy</span></code><span class="koboSpan" id="kobo.80.1"> works. </span><span class="koboSpan" id="kobo.80.2">When an actor fails, that specific actor is resumed, restarted, or stopped, depending on the exception that caused it to fail. </span><span class="koboSpan" id="kobo.80.3">The alternative </span><code class="literal"><span class="koboSpan" id="kobo.81.1">AllForOneStrategy</span></code><span class="koboSpan" id="kobo.82.1"> applies the fault-handling decision to all the children. </span><span class="koboSpan" id="kobo.82.2">When one of the child actors stops, all the other children are resumed, restarted, or stopped.</span></p><p><span class="koboSpan" id="kobo.83.1">Recall our minimalistic web browser implementation from </span><a class="link" href="ch06.html" title="Chapter 6. Concurrent Programming with Reactive Extensions"><span class="koboSpan" id="kobo.84.1">Chapter 6</span></a><span class="koboSpan" id="kobo.85.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.86.1">Concurrent Programming with Reactive Extensions</span></em></span><span class="koboSpan" id="kobo.87.1">. </span><span class="koboSpan" id="kobo.87.2">A more advanced web browser requires a separate subsystem that handles concurrent file downloads. </span><span class="koboSpan" id="kobo.87.3">Usually, we refer to such a software component as a download manager. </span><span class="koboSpan" id="kobo.87.4">We now consider a larger example, in which we apply our knowledge of actors in order to implement the infrastructure for a simple download manager.</span></p><p><span class="koboSpan" id="kobo.88.1">The download manager will be implemented as an actor, represented by the </span><code class="literal"><span class="koboSpan" id="kobo.89.1">DownloadManager</span></code><span class="koboSpan" id="kobo.90.1"> actor class. </span><span class="koboSpan" id="kobo.90.2">The two most important tasks of every download manager are to download the resources at the requested URL, and to track the downloads that are currently in progress. </span><span class="koboSpan" id="kobo.90.3">To be able to react to download requests and download completion events, we define the message types </span><code class="literal"><span class="koboSpan" id="kobo.91.1">Download</span></code><span class="koboSpan" id="kobo.92.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.93.1">Finished</span></code><span class="koboSpan" id="kobo.94.1"> in the </span><code class="literal"><span class="koboSpan" id="kobo.95.1">DownloadManager</span></code><span class="koboSpan" id="kobo.96.1"> companion object. </span><span class="koboSpan" id="kobo.96.2">The </span><code class="literal"><span class="koboSpan" id="kobo.97.1">Download</span></code><span class="koboSpan" id="kobo.98.1"> message encapsulates the URL of the resource and the destination file for the resource, while the </span><code class="literal"><span class="koboSpan" id="kobo.99.1">Finished</span></code><span class="koboSpan" id="kobo.100.1"> message encodes the destination file where the resource is saved:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.101.1">object DownloadManager { 
  case class Download(url: String, dest: String) 
  case class Finished(dest: String) 
} 
</span></pre><p><span class="koboSpan" id="kobo.102.1">The </span><code class="literal"><span class="koboSpan" id="kobo.103.1">DownloadManager</span></code><span class="koboSpan" id="kobo.104.1"> actor will not execute the downloads itself. </span><span class="koboSpan" id="kobo.104.2">Doing so would prevent it from receiving any messages before the download completes. </span><span class="koboSpan" id="kobo.104.3">Furthermore, this will serialize different downloads and prevent them from executing concurrently. </span><span class="koboSpan" id="kobo.104.4">Thus, the </span><code class="literal"><span class="koboSpan" id="kobo.105.1">DownloadManager</span></code><span class="koboSpan" id="kobo.106.1"> actor must delegate the task of downloading the files to different actors. </span><span class="koboSpan" id="kobo.106.2">We represent these actors with the </span><code class="literal"><span class="koboSpan" id="kobo.107.1">Downloader</span></code><span class="koboSpan" id="kobo.108.1"> actor class. </span><span class="koboSpan" id="kobo.108.2">A </span><code class="literal"><span class="koboSpan" id="kobo.109.1">DownloadManager</span></code><span class="koboSpan" id="kobo.110.1"> actor maintains a set of </span><code class="literal"><span class="koboSpan" id="kobo.111.1">Downloader</span></code><span class="koboSpan" id="kobo.112.1"> children, and tracks which children are currently downloading a resource. </span><span class="koboSpan" id="kobo.112.2">When a </span><code class="literal"><span class="koboSpan" id="kobo.113.1">DownloadManager</span></code><span class="koboSpan" id="kobo.114.1"> actor receives a </span><code class="literal"><span class="koboSpan" id="kobo.115.1">Download</span></code><span class="koboSpan" id="kobo.116.1"> message, it picks one of the non-busy </span><code class="literal"><span class="koboSpan" id="kobo.117.1">Downloader</span></code><span class="koboSpan" id="kobo.118.1"> actors, and forwards the </span><code class="literal"><span class="koboSpan" id="kobo.119.1">Download</span></code><span class="koboSpan" id="kobo.120.1"> message to it.</span></p><p><span class="koboSpan" id="kobo.121.1">Once the download is complete, the </span><code class="literal"><span class="koboSpan" id="kobo.122.1">Downloader</span></code><span class="koboSpan" id="kobo.123.1"> actor sends a </span><code class="literal"><span class="koboSpan" id="kobo.124.1">Finished</span></code><span class="koboSpan" id="kobo.125.1"> message to its parent. </span><span class="koboSpan" id="kobo.125.2">This is illustrated in the following figure:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.126.1"><img src="graphics/image_08_006.jpg" alt="Actor supervision"/></span></div><p><span class="koboSpan" id="kobo.127.1">We first show the implementation of the </span><code class="literal"><span class="koboSpan" id="kobo.128.1">Downloader</span></code><span class="koboSpan" id="kobo.129.1"> actor class. </span><span class="koboSpan" id="kobo.129.2">When a </span><code class="literal"><span class="koboSpan" id="kobo.130.1">Downloader</span></code><span class="koboSpan" id="kobo.131.1"> actor receives a </span><code class="literal"><span class="koboSpan" id="kobo.132.1">Download</span></code><span class="koboSpan" id="kobo.133.1"> message, it downloads the contents of the specified URL and writes them to a destination file. </span><span class="koboSpan" id="kobo.133.2">It then sends the </span><code class="literal"><span class="koboSpan" id="kobo.134.1">Finished</span></code><span class="koboSpan" id="kobo.135.1"> message back to the sender of the </span><code class="literal"><span class="koboSpan" id="kobo.136.1">Download</span></code><span class="koboSpan" id="kobo.137.1"> message, as shown in the following implementation:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.138.1">class Downloader extends Actor { 
  def receive = { 
    case DownloadManager.Download(url, dest) =&gt; 
      val content = Source.fromURL(url) 
      FileUtils.write(new java.io.File(dest), content.mkString) 
      sender ! </span><span class="koboSpan" id="kobo.138.2">DownloadManager.Finished(dest) 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.139.1">The </span><code class="literal"><span class="koboSpan" id="kobo.140.1">DownloadManager</span></code><span class="koboSpan" id="kobo.141.1"> actor class needs to maintain state to track which of its </span><code class="literal"><span class="koboSpan" id="kobo.142.1">Downloader</span></code><span class="koboSpan" id="kobo.143.1"> actors is currently downloading a resource. </span><span class="koboSpan" id="kobo.143.2">If there are more download requests than there are available </span><code class="literal"><span class="koboSpan" id="kobo.144.1">Downloader</span></code><span class="koboSpan" id="kobo.145.1"> instances, the </span><code class="literal"><span class="koboSpan" id="kobo.146.1">DownloadManager</span></code><span class="koboSpan" id="kobo.147.1"> actor needs to enqueue the download requests until a </span><code class="literal"><span class="koboSpan" id="kobo.148.1">Downloader</span></code><span class="koboSpan" id="kobo.149.1"> actor becomes available. </span><span class="koboSpan" id="kobo.149.2">The </span><code class="literal"><span class="koboSpan" id="kobo.150.1">DownloadManager</span></code><span class="koboSpan" id="kobo.151.1"> actor maintains a </span><code class="literal"><span class="koboSpan" id="kobo.152.1">downloaders</span></code><span class="koboSpan" id="kobo.153.1"> queue with actor references to non-busy </span><code class="literal"><span class="koboSpan" id="kobo.154.1">Downloader</span></code><span class="koboSpan" id="kobo.155.1"> actors. </span><span class="koboSpan" id="kobo.155.2">It maintains another queue, the </span><code class="literal"><span class="koboSpan" id="kobo.156.1">pendingWork</span></code><span class="koboSpan" id="kobo.157.1"> queue, with </span><code class="literal"><span class="koboSpan" id="kobo.158.1">Download</span></code><span class="koboSpan" id="kobo.159.1"> requests that cannot be assigned to any </span><code class="literal"><span class="koboSpan" id="kobo.160.1">Downloader</span></code><span class="koboSpan" id="kobo.161.1"> instances.</span></p><p><span class="koboSpan" id="kobo.162.1">Finally, it maintains a map called </span><code class="literal"><span class="koboSpan" id="kobo.163.1">workItems</span></code><span class="koboSpan" id="kobo.164.1"> that associates actor references of the busy </span><code class="literal"><span class="koboSpan" id="kobo.165.1">Downloader</span></code><span class="koboSpan" id="kobo.166.1"> instances with their </span><code class="literal"><span class="koboSpan" id="kobo.167.1">Download</span></code><span class="koboSpan" id="kobo.168.1"> requests. </span><span class="koboSpan" id="kobo.168.2">This is shown in the following </span><code class="literal"><span class="koboSpan" id="kobo.169.1">DownloadManager</span></code><span class="koboSpan" id="kobo.170.1"> implementation:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.171.1">class DownloadManager(val downloadSlots: Int) extends Actor { 
  import DownloadManager._ 
  val log = Logging(context.system, this) 
  val downloaders = mutable.Queue[ActorRef]() 
  val pendingWork = mutable.Queue[Download]() 
  val workItems = mutable.Map[ActorRef, Download]() 
  private def checkDownloads(): Unit = { 
    if (pendingWork.nonEmpty &amp;&amp; downloaders.nonEmpty) { 
      val dl = downloaders.dequeue() 
      val item = pendingWork.dequeue() 
      log.info( 
        s"$item starts, ${downloaders.size} download slots left") 
      dl ! </span><span class="koboSpan" id="kobo.171.2">item 
      workItems(dl) = item 
    } 
  } 
  def receive = { 
    case msg @ DownloadManager.Download(url, dest) =&gt; 
      pendingWork.enqueue(msg) 
      checkDownloads() 
    case DownloadManager.Finished(dest) =&gt; 
      workItems.remove(sender) 
      downloaders.enqueue(sender) 
      log.info( 
        s"'$dest' done, ${downloaders.size} download slots left") 
      checkDownloads() 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.172.1">The </span><code class="literal"><span class="koboSpan" id="kobo.173.1">checkDownloads</span></code><span class="koboSpan" id="kobo.174.1"> private method maintains the </span><code class="literal"><span class="koboSpan" id="kobo.175.1">DownloadManager</span></code><span class="koboSpan" id="kobo.176.1"> actor's invariant-the </span><code class="literal"><span class="koboSpan" id="kobo.177.1">pendingWork</span></code><span class="koboSpan" id="kobo.178.1"> and the </span><code class="literal"><span class="koboSpan" id="kobo.179.1">downloaders</span></code><span class="koboSpan" id="kobo.180.1"> queue cannot be non-empty at the same time. </span><span class="koboSpan" id="kobo.180.2">As soon as both the queues become non-empty, a </span><code class="literal"><span class="koboSpan" id="kobo.181.1">Downloader</span></code><span class="koboSpan" id="kobo.182.1"> actor reference </span><code class="literal"><span class="koboSpan" id="kobo.183.1">dl</span></code><span class="koboSpan" id="kobo.184.1"> is dequeued from </span><code class="literal"><span class="koboSpan" id="kobo.185.1">downloaders</span></code><span class="koboSpan" id="kobo.186.1"> and a </span><code class="literal"><span class="koboSpan" id="kobo.187.1">Download</span></code><span class="koboSpan" id="kobo.188.1"> request item is dequeued from the </span><code class="literal"><span class="koboSpan" id="kobo.189.1">pendingWork</span></code><span class="koboSpan" id="kobo.190.1"> queue. </span><span class="koboSpan" id="kobo.190.2">The </span><code class="literal"><span class="koboSpan" id="kobo.191.1">item</span></code><span class="koboSpan" id="kobo.192.1"> value is then sent as a message to the </span><code class="literal"><span class="koboSpan" id="kobo.193.1">dl</span></code><span class="koboSpan" id="kobo.194.1"> actor, and the </span><code class="literal"><span class="koboSpan" id="kobo.195.1">workItems</span></code><span class="koboSpan" id="kobo.196.1"> map is updated.</span></p><p><span class="koboSpan" id="kobo.197.1">Whenever the </span><code class="literal"><span class="koboSpan" id="kobo.198.1">DownloadManager</span></code><span class="koboSpan" id="kobo.199.1"> actor receives a </span><code class="literal"><span class="koboSpan" id="kobo.200.1">Download</span></code><span class="koboSpan" id="kobo.201.1"> message, it adds it to the </span><code class="literal"><span class="koboSpan" id="kobo.202.1">pendingWork</span></code><span class="koboSpan" id="kobo.203.1"> queue and calls the </span><code class="literal"><span class="koboSpan" id="kobo.204.1">checkDownloads</span></code><span class="koboSpan" id="kobo.205.1"> method. </span><span class="koboSpan" id="kobo.205.2">Similarly, when the </span><code class="literal"><span class="koboSpan" id="kobo.206.1">Finished</span></code><span class="koboSpan" id="kobo.207.1"> message arrives, the </span><code class="literal"><span class="koboSpan" id="kobo.208.1">Downloader</span></code><span class="koboSpan" id="kobo.209.1"> actor is removed from the </span><code class="literal"><span class="koboSpan" id="kobo.210.1">workItems</span></code><span class="koboSpan" id="kobo.211.1"> queue and enqueued on the </span><code class="literal"><span class="koboSpan" id="kobo.212.1">downloaders</span></code><span class="koboSpan" id="kobo.213.1"> list.</span></p><p><span class="koboSpan" id="kobo.214.1">To ensure that the </span><code class="literal"><span class="koboSpan" id="kobo.215.1">DownloadManager</span></code><span class="koboSpan" id="kobo.216.1"> actor is created with the specified number of </span><code class="literal"><span class="koboSpan" id="kobo.217.1">Downloader</span></code><span class="koboSpan" id="kobo.218.1"> child actors, we override the </span><code class="literal"><span class="koboSpan" id="kobo.219.1">preStart</span></code><span class="koboSpan" id="kobo.220.1"> method to create the </span><code class="literal"><span class="koboSpan" id="kobo.221.1">Downloaders</span></code><span class="koboSpan" id="kobo.222.1"> list and add their actor references to the </span><code class="literal"><span class="koboSpan" id="kobo.223.1">downloaders</span></code><span class="koboSpan" id="kobo.224.1"> queue:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.225.1">override def preStart(): Unit = { 
  for (i &lt;- 0 until downloadSlots) { 
    val dl = context.actorOf(Props[Downloader], s"dl$i") 
    downloaders.enqueue() 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.226.1">Finally, we must override the </span><code class="literal"><span class="koboSpan" id="kobo.227.1">supervisorStrategy</span></code><span class="koboSpan" id="kobo.228.1"> field of the </span><code class="literal"><span class="koboSpan" id="kobo.229.1">DownloadManager</span></code><span class="koboSpan" id="kobo.230.1"> actor. </span><span class="koboSpan" id="kobo.230.2">We use the </span><code class="literal"><span class="koboSpan" id="kobo.231.1">OneForOneStrategy</span></code><span class="koboSpan" id="kobo.232.1"> field again, but specify that the actor can be restarted or resumed only up to 20 times within a two-second interval.</span></p><p><span class="koboSpan" id="kobo.233.1">We expect that some URLs might be invalid, in which case the actor fails with a </span><code class="literal"><span class="koboSpan" id="kobo.234.1">FileNotFoundException</span></code><span class="koboSpan" id="kobo.235.1">. </span><span class="koboSpan" id="kobo.235.2">We need to remove such an actor from the </span><code class="literal"><span class="koboSpan" id="kobo.236.1">workItems</span></code><span class="koboSpan" id="kobo.237.1"> collection and add it back to the </span><code class="literal"><span class="koboSpan" id="kobo.238.1">downloaders</span></code><span class="koboSpan" id="kobo.239.1"> queue. </span><span class="koboSpan" id="kobo.239.2">It does not make sense to restart the </span><code class="literal"><span class="koboSpan" id="kobo.240.1">Downloader</span></code><span class="koboSpan" id="kobo.241.1"> actors, because they do not contain any state. </span><span class="koboSpan" id="kobo.241.2">Instead of restarting, we simply resume a </span><code class="literal"><span class="koboSpan" id="kobo.242.1">Downloader</span></code><span class="koboSpan" id="kobo.243.1"> actor that cannot resolve a URL. </span><span class="koboSpan" id="kobo.243.2">If the </span><code class="literal"><span class="koboSpan" id="kobo.244.1">Downloader</span></code><span class="koboSpan" id="kobo.245.1"> instances fail due to any other messages, we escalate the exception and fail the </span><code class="literal"><span class="koboSpan" id="kobo.246.1">DownloadManager</span></code><span class="koboSpan" id="kobo.247.1"> actor, as shown in the following </span><code class="literal"><span class="koboSpan" id="kobo.248.1">supervisorStrategy</span></code><span class="koboSpan" id="kobo.249.1"> implementation:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.250.1">override val supervisorStrategy = 
  OneForOneStrategy( 
    maxNrOfRetries = 20, withinTimeRange = 2 seconds 
  ) { 
    case fnf: java.io.FileNotFoundException =&gt; 
      log.info(s"Resource could not be found: $fnf") 
      workItems.remove(sender) 
      downloaders.enqueue(sender) 
      Resume // ignores the exception and resumes the actor 
    case _ =&gt; 
      Escalate 
  } 
</span></pre><p><span class="koboSpan" id="kobo.251.1">To test the download manager, we create a </span><code class="literal"><span class="koboSpan" id="kobo.252.1">DownloadManager</span></code><span class="koboSpan" id="kobo.253.1"> actor with four download slots, and send it several </span><code class="literal"><span class="koboSpan" id="kobo.254.1">Download</span></code><span class="koboSpan" id="kobo.255.1"> messages:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.256.1">  val downloadManager = 
    ourSystem.actorOf(Props(classOf[DownloadManager], 4), "man") 
  downloadManager ! </span><span class="koboSpan" id="kobo.256.2">Download( 
    "http://www.w3.org/Addressing/URL/url-spec.txt", 
    "url-spec.txt")   
</span></pre><p><span class="koboSpan" id="kobo.257.1">An extra copy of the URL specification cannot hurt, so we download it to our computer. </span><span class="koboSpan" id="kobo.257.2">The download manager logs that there are only three download slots left. </span><span class="koboSpan" id="kobo.257.3">Once the download completes, the download manager logs that there are four remaining download slots again. </span><span class="koboSpan" id="kobo.257.4">We then decide that we would like to contribute to the Scala programming language, so we download the </span><code class="literal"><span class="koboSpan" id="kobo.258.1">README</span></code><span class="koboSpan" id="kobo.259.1"> file from the official Scala repository. </span><span class="koboSpan" id="kobo.259.2">Unfortunately, we enter an invalid URL, and observe a warning from the download manager saying that the resource cannot be found:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.260.1">downloadManager ! </span><span class="koboSpan" id="kobo.260.2">Download( 
  "https://github.com/scala/scala/blob/master/README.md", 
  "README.md") 
</span></pre><p><span class="koboSpan" id="kobo.261.1">The simple implementation of the basic actor-based download manager illustrates both how to achieve concurrency by delegating work to child actors, and how to treat failures in child actors. </span><span class="koboSpan" id="kobo.261.2">Delegating work is important, both for decomposing the program into smaller, isolated components, and to achieve better throughput and scalability. </span><span class="koboSpan" id="kobo.261.3">Actor supervision is the fundamental mechanism for handling failures in isolated components implemented in separate actors.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Remote actors"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec56"/><span class="koboSpan" id="kobo.1.1">Remote actors</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">So far in this book, we have mostly concentrated on writing programs on a single computer. </span><span class="koboSpan" id="kobo.2.2">Concurrent programs are executed within a single process on one computer, and they communicate using shared memory. </span><span class="koboSpan" id="kobo.2.3">Seemingly, actors described in this chapter communicate by passing messages. </span><span class="koboSpan" id="kobo.2.4">However, the message passing used throughout this chapter is implemented by reading and writing to shared memory under the hood.</span></p><p><span class="koboSpan" id="kobo.3.1">In this section, we study how the actor model ensures location transparency by taking existing actors and deploying them in a distributed program. </span><span class="koboSpan" id="kobo.3.2">We take two existing actor implementations, namely, </span><code class="literal"><span class="koboSpan" id="kobo.4.1">Pingy</span></code><span class="koboSpan" id="kobo.5.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.6.1">Pongy</span></code><span class="koboSpan" id="kobo.7.1">, and deploy them inside different processes. </span><span class="koboSpan" id="kobo.7.2">We will then instruct the </span><code class="literal"><span class="koboSpan" id="kobo.8.1">Pingy</span></code><span class="koboSpan" id="kobo.9.1"> actor to send a message to the </span><code class="literal"><span class="koboSpan" id="kobo.10.1">Pongy</span></code><span class="koboSpan" id="kobo.11.1"> actor, as before, and wait until the </span><code class="literal"><span class="koboSpan" id="kobo.12.1">Pingy</span></code><span class="koboSpan" id="kobo.13.1"> actor returns the </span><code class="literal"><span class="koboSpan" id="kobo.14.1">Pongy</span></code><span class="koboSpan" id="kobo.15.1"> actor's message. </span><span class="koboSpan" id="kobo.15.2">The message exchange will occur transparently, although the </span><code class="literal"><span class="koboSpan" id="kobo.16.1">Pingy</span></code><span class="koboSpan" id="kobo.17.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.18.1">Pongy</span></code><span class="koboSpan" id="kobo.19.1"> actor's were previously implemented without knowing that they might exist inside separate processes, or even different computers.</span></p><p><span class="koboSpan" id="kobo.20.1">The Akka actor framework is organized into several modules. </span><span class="koboSpan" id="kobo.20.2">To use the part of Akka that allows communicating with actors in remote actor systems, we need to add the following dependency to our build definition file:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.21.1">libraryDependencies += "com.typesafe.akka" %% "akka-remote" % "2.3.2" 
</span></pre><p><span class="koboSpan" id="kobo.22.1">Before creating our ping-pong actors inside two different processes, we need to create an actor system that is capable of communicating with remote actors. </span><span class="koboSpan" id="kobo.22.2">To do this, we create a custom actor system configuration string. </span><span class="koboSpan" id="kobo.22.3">The actor system configuration string can be used to configure a range of different actor system properties; we are interested in using a custom </span><code class="literal"><span class="koboSpan" id="kobo.23.1">ActorRef</span></code><span class="koboSpan" id="kobo.24.1"> factory object called </span><code class="literal"><span class="koboSpan" id="kobo.25.1">RemoteActorRefProvider</span></code><span class="koboSpan" id="kobo.26.1">. </span><span class="koboSpan" id="kobo.26.2">The </span><code class="literal"><span class="koboSpan" id="kobo.27.1">ActorRef</span></code><span class="koboSpan" id="kobo.28.1"> factory object allows the actor system to create actor references that can be used to communicate over the network. </span><span class="koboSpan" id="kobo.28.2">Furthermore, we configure the actor system to use the </span><span class="strong"><strong><span class="koboSpan" id="kobo.29.1">Netty</span></strong></span><span class="koboSpan" id="kobo.30.1"> networking library with the TCP network layer and the desired TCP port number. </span><span class="koboSpan" id="kobo.30.2">We declare the </span><code class="literal"><span class="koboSpan" id="kobo.31.1">remotingConfig</span></code><span class="koboSpan" id="kobo.32.1"> method for this task:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.33.1">import com.typesafe.config._ 
def remotingConfig(port: Int) = ConfigFactory.parseString(s""" 
akka { 
  actor.provider = "akka.remote.RemoteActorRefProvider" 
  remote { 
    enabled-transports = ["akka.remote.netty.tcp"] 
    netty.tcp { 
      hostname = "127.0.0.1" 
      port = $port 
    } 
  } 
} 
""") 
</span></pre><p><span class="koboSpan" id="kobo.34.1">We then define a </span><code class="literal"><span class="koboSpan" id="kobo.35.1">remotingSystem</span></code><span class="koboSpan" id="kobo.36.1"> factory method that creates an actor system object using the given name and port. </span><span class="koboSpan" id="kobo.36.2">We use the </span><code class="literal"><span class="koboSpan" id="kobo.37.1">remotingConfig</span></code><span class="koboSpan" id="kobo.38.1"> method, defined earlier, to produce the configuration object for the specified network port:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.39.1">def remotingSystem(name: String, port: Int): ActorSystem = 
  ActorSystem(name, remotingConfig(port)) 
</span></pre><p><span class="koboSpan" id="kobo.40.1">Now we are ready to create the </span><code class="literal"><span class="koboSpan" id="kobo.41.1">Pongy</span></code><span class="koboSpan" id="kobo.42.1"> actor system. </span><span class="koboSpan" id="kobo.42.2">We declare an application called </span><code class="literal"><span class="koboSpan" id="kobo.43.1">RemotingPongySystem</span></code><span class="koboSpan" id="kobo.44.1">, which instantiates an actor system called </span><code class="literal"><span class="koboSpan" id="kobo.45.1">PongyDimension</span></code><span class="koboSpan" id="kobo.46.1"> using the network port </span><code class="literal"><span class="koboSpan" id="kobo.47.1">24321</span></code><span class="koboSpan" id="kobo.48.1">. </span><span class="koboSpan" id="kobo.48.2">We arbitrarily picked a network port that was free on our machine. </span><span class="koboSpan" id="kobo.48.3">If the creation of the actor system fails because the port is not available, you can pick a different port in the range </span><code class="literal"><span class="koboSpan" id="kobo.49.1">1024</span></code><span class="koboSpan" id="kobo.50.1"> to </span><code class="literal"><span class="koboSpan" id="kobo.51.1">65535</span></code><span class="koboSpan" id="kobo.52.1">. </span><span class="koboSpan" id="kobo.52.2">Make sure that you don't have a firewall running, as it can block the network traffic for arbitrary applications.</span></p><p><span class="koboSpan" id="kobo.53.1">The </span><code class="literal"><span class="koboSpan" id="kobo.54.1">RemotingPongySystem</span></code><span class="koboSpan" id="kobo.55.1"> application is shown in the following example:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.56.1">object RemotingPongySystem extends App { 
  val system = remotingSystem("PongyDimension", 24321) 
  val pongy = system.actorOf(Props[Pongy], "pongy") 
  Thread.sleep(15000) 
  system.shutdown() 
} 
</span></pre><p><span class="koboSpan" id="kobo.57.1">The </span><code class="literal"><span class="koboSpan" id="kobo.58.1">RemotingPongySystem</span></code><span class="koboSpan" id="kobo.59.1"> application creates a </span><code class="literal"><span class="koboSpan" id="kobo.60.1">Pongy</span></code><span class="koboSpan" id="kobo.61.1"> actor and shuts down after 15 seconds. </span><span class="koboSpan" id="kobo.61.2">After we start it, we will only have a short time to start another application running the </span><code class="literal"><span class="koboSpan" id="kobo.62.1">Pingy</span></code><span class="koboSpan" id="kobo.63.1"> actor. </span><span class="koboSpan" id="kobo.63.2">We will call this second application </span><code class="literal"><span class="koboSpan" id="kobo.64.1">RemotingPingySystem</span></code><span class="koboSpan" id="kobo.65.1">. </span><span class="koboSpan" id="kobo.65.2">Before we implement it, we create another actor called </span><code class="literal"><span class="koboSpan" id="kobo.66.1">Runner</span></code><span class="koboSpan" id="kobo.67.1">, which will instantiate </span><code class="literal"><span class="koboSpan" id="kobo.68.1">Pingy</span></code><span class="koboSpan" id="kobo.69.1">, obtain the </span><code class="literal"><span class="koboSpan" id="kobo.70.1">Pongy</span></code><span class="koboSpan" id="kobo.71.1"> actor's reference, and give it to the </span><code class="literal"><span class="koboSpan" id="kobo.72.1">Pingy</span></code><span class="koboSpan" id="kobo.73.1"> actor; recall that the ping-pong game from the earlier section starts when the </span><code class="literal"><span class="koboSpan" id="kobo.74.1">Pingy</span></code><span class="koboSpan" id="kobo.75.1"> actor obtains the </span><code class="literal"><span class="koboSpan" id="kobo.76.1">Pongy</span></code><span class="koboSpan" id="kobo.77.1"> actor's reference.</span></p><p><span class="koboSpan" id="kobo.78.1">When the </span><code class="literal"><span class="koboSpan" id="kobo.79.1">Runner</span></code><span class="koboSpan" id="kobo.80.1"> actor receives a </span><code class="literal"><span class="koboSpan" id="kobo.81.1">start</span></code><span class="koboSpan" id="kobo.82.1"> message, it constructs the actor path for the </span><code class="literal"><span class="koboSpan" id="kobo.83.1">Pongy</span></code><span class="koboSpan" id="kobo.84.1"> actor. </span><span class="koboSpan" id="kobo.84.2">We use the </span><code class="literal"><span class="koboSpan" id="kobo.85.1">akka.tcp</span></code><span class="koboSpan" id="kobo.86.1"> protocol and the name of the remote actor system, along with its IP address and port number. </span><span class="koboSpan" id="kobo.86.2">The </span><code class="literal"><span class="koboSpan" id="kobo.87.1">Runner</span></code><span class="koboSpan" id="kobo.88.1"> actor sends an </span><code class="literal"><span class="koboSpan" id="kobo.89.1">Identify</span></code><span class="koboSpan" id="kobo.90.1"> message to the actor selection in order to obtain the actor reference to the remote </span><code class="literal"><span class="koboSpan" id="kobo.91.1">Pongy</span></code><span class="koboSpan" id="kobo.92.1"> instance. </span><span class="koboSpan" id="kobo.92.2">The complete </span><code class="literal"><span class="koboSpan" id="kobo.93.1">Runner</span></code><span class="koboSpan" id="kobo.94.1"> implementation is shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.95.1">class Runner extends Actor { 
  val log = Logging(context.system, this) 
  val pingy = context.actorOf(Props[Pingy], "pingy") 
  def receive = { 
    case "start" =&gt; 
      val pongySys = "akka.tcp://PongyDimension@127.0.0.1:24321" 
      val pongyPath = "/user/pongy" 
      val url = pongySys + pongyPath 
      val selection = context.actorSelection(url) 
      selection ! </span><span class="koboSpan" id="kobo.95.2">Identify(0) 
    case ActorIdentity(0, Some(ref)) =&gt; 
      pingy ! </span><span class="koboSpan" id="kobo.95.3">ref 
    case ActorIdentity(0, None) =&gt; 
      log.info("Something's wrong - ain't no pongy anywhere!") 
      context.stop(self) 
    case "pong" =&gt; 
      log.info("got a pong from another dimension.") 
      context.stop(self) 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.96.1">Once the </span><code class="literal"><span class="koboSpan" id="kobo.97.1">Runner</span></code><span class="koboSpan" id="kobo.98.1"> actor sends the </span><code class="literal"><span class="koboSpan" id="kobo.99.1">Pongy</span></code><span class="koboSpan" id="kobo.100.1"> actor reference to </span><code class="literal"><span class="koboSpan" id="kobo.101.1">Pingy</span></code><span class="koboSpan" id="kobo.102.1">, the game of remote ping pong can begin. </span><span class="koboSpan" id="kobo.102.2">To test it, we declare the </span><code class="literal"><span class="koboSpan" id="kobo.103.1">RemotingPingySystem</span></code><span class="koboSpan" id="kobo.104.1"> application, which starts the </span><code class="literal"><span class="koboSpan" id="kobo.105.1">Runner</span></code><span class="koboSpan" id="kobo.106.1"> actor and sends it a </span><code class="literal"><span class="koboSpan" id="kobo.107.1">start</span></code><span class="koboSpan" id="kobo.108.1"> message:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.109.1">object RemotingPingySystem extends App { 
  val system = remotingSystem("PingyDimension", 24567) 
  val runner = system.actorOf(Props[Runner], "runner") 
  runner ! </span><span class="koboSpan" id="kobo.109.2">"start" 
  Thread.sleep(5000) 
  system.shutdown() 
} 
</span></pre><p><span class="koboSpan" id="kobo.110.1">We now need to start the </span><code class="literal"><span class="koboSpan" id="kobo.111.1">RemotingPongySystem</span></code><span class="koboSpan" id="kobo.112.1"> application, and the </span><code class="literal"><span class="koboSpan" id="kobo.113.1">RemotingPingySystem</span></code><span class="koboSpan" id="kobo.114.1"> application after that; we only have 15 seconds until the </span><code class="literal"><span class="koboSpan" id="kobo.115.1">RemotingPongySystem</span></code><span class="koboSpan" id="kobo.116.1"> application shuts itself down. </span><span class="koboSpan" id="kobo.116.2">The easiest way to do this is to start two SBT instances in your project folder and run the two applications at the same time. </span><span class="koboSpan" id="kobo.116.3">After the </span><code class="literal"><span class="koboSpan" id="kobo.117.1">RemotingPingySystem</span></code><span class="koboSpan" id="kobo.118.1"> application starts, we soon observe a </span><code class="literal"><span class="koboSpan" id="kobo.119.1">pong</span></code><span class="koboSpan" id="kobo.120.1"> message from another dimension.</span></p><p><span class="koboSpan" id="kobo.121.1">In the previous example, the actor system configuration and the </span><code class="literal"><span class="koboSpan" id="kobo.122.1">Runner</span></code><span class="koboSpan" id="kobo.123.1"> actor were responsible for setting up the network communication, and were not location-transparent. </span><span class="koboSpan" id="kobo.123.2">This is typically the case with distributed programs; a part of the program is responsible for initializing and discovering actors within remote actor systems, while the application-specific logic is confined within separate actors.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip99"/><span class="koboSpan" id="kobo.124.1">Tip</span></h3><p><span class="koboSpan" id="kobo.125.1">In larger actor programs, separate deployment logic from application logic.</span></p></div></div><p><span class="koboSpan" id="kobo.126.1">To summarize, remote actor communication requires the following steps:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.127.1">Declaring an actor system with an appropriate remoting configuration</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.128.1">Starting two actor systems in separate processes or on separate machines</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.129.1">Using actor path selection to obtain actor references</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.130.1">Using actor references to transparently send messages</span></li></ul></div><p><span class="koboSpan" id="kobo.131.1">While the first three steps are not location-transparent, the application logic is usually confined within the fourth step, as we saw in this section. </span><span class="koboSpan" id="kobo.131.2">This is important, as it allows separating the deployment logic from the application semantics and building distributed systems that can be deployed transparently to different network configurations.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec57"/><span class="koboSpan" id="kobo.1.1">Summary</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In this chapter, we learned what actors are and how to use them to build concurrent programs. </span><span class="koboSpan" id="kobo.2.2">Using the Akka actor framework, we studied how to create actors, organize them into hierarchies, manage their lifecycle, and recover them from errors. </span><span class="koboSpan" id="kobo.2.3">We examined important patterns in actor communication and learned how to model actor behavior. </span><span class="koboSpan" id="kobo.2.4">Finally, we saw how the actor model can ensure location transparency, and serve as a powerful tool to seamlessly build distributed systems.</span></p><p><span class="koboSpan" id="kobo.3.1">Still, there are many Akka features that we omitted in this chapter. </span><span class="koboSpan" id="kobo.3.2">Akka comes with detailed online documentation, which is one of the best sources of information on Akka. </span><span class="koboSpan" id="kobo.3.3">To obtain an in-depth understanding of distributed programming, we recommend the books </span><span class="emphasis"><em><span class="koboSpan" id="kobo.4.1">Distributed Algorithms</span></em></span><span class="koboSpan" id="kobo.5.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.6.1">Nancy A. </span><span class="koboSpan" id="kobo.6.2">Lynch</span></em></span><span class="koboSpan" id="kobo.7.1">, published by Elsevier and </span><span class="emphasis"><em><span class="koboSpan" id="kobo.8.1">Introduction to Reliable and Secure Distributed Programming</span></em></span><span class="koboSpan" id="kobo.9.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.10.1">Christian Cachin</span></em></span><span class="koboSpan" id="kobo.11.1">,</span><span class="emphasis"><em><span class="koboSpan" id="kobo.12.1"> Rachid Guerraoui, Luis Rodrigues</span></em></span><span class="koboSpan" id="kobo.13.1">, published by Springer.</span></p><p><span class="koboSpan" id="kobo.14.1">In the following chapter, we will summarize the different concurrency libraries we learned about in this book, examine the typical use cases for each of them, and see how they work together in larger applications.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec58"/><span class="koboSpan" id="kobo.1.1">Exercises</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">The following exercises test your understanding of the actor programming model, and distributed programming in general. </span><span class="koboSpan" id="kobo.2.2">The first few exercises are straightforward, and deal with the basics of the actor API in Akka. </span><span class="koboSpan" id="kobo.2.3">Subsequent exercises are more involved, and go deeper into the territory of fault-tolerant distributed programming. </span><span class="koboSpan" id="kobo.2.4">Try to solve these exercises by first assuming that no machines fail, and then consider what happens if some of the machines fail during the execution of the program:</span></p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="koboSpan" id="kobo.3.1">Implement the timer actor with the </span><code class="literal"><span class="koboSpan" id="kobo.4.1">TimerActor</span></code><span class="koboSpan" id="kobo.5.1"> class. </span><span class="koboSpan" id="kobo.5.2">After receiving a </span><code class="literal"><span class="koboSpan" id="kobo.6.1">Register</span></code><span class="koboSpan" id="kobo.7.1"> message containing the </span><code class="literal"><span class="koboSpan" id="kobo.8.1">t</span></code><span class="koboSpan" id="kobo.9.1"> timeout in milliseconds, the timer actor sends a </span><code class="literal"><span class="koboSpan" id="kobo.10.1">Timeout</span></code><span class="koboSpan" id="kobo.11.1"> message back after </span><code class="literal"><span class="koboSpan" id="kobo.12.1">t</span></code><span class="koboSpan" id="kobo.13.1"> milliseconds. </span><span class="koboSpan" id="kobo.13.2">The timer must accept multiple </span><code class="literal"><span class="koboSpan" id="kobo.14.1">Register</span></code><span class="koboSpan" id="kobo.15.1"> messages.</span></li><li class="listitem"><span class="koboSpan" id="kobo.16.1">Recall the bank account example from </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.17.1">Chapter 2</span></a><span class="koboSpan" id="kobo.18.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.19.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.20.1">. </span><span class="koboSpan" id="kobo.20.2">Implement different bank accounts as separate actors, represented by the </span><code class="literal"><span class="koboSpan" id="kobo.21.1">AccountActor</span></code><span class="koboSpan" id="kobo.22.1"> class. </span><span class="koboSpan" id="kobo.22.2">When an </span><code class="literal"><span class="koboSpan" id="kobo.23.1">AccountActor</span></code><span class="koboSpan" id="kobo.24.1"> class receives a </span><code class="literal"><span class="koboSpan" id="kobo.25.1">Send</span></code><span class="koboSpan" id="kobo.26.1"> message, it must transfer the specified amount of money to the target actor. </span><span class="koboSpan" id="kobo.26.2">What will happen if either of the actors receives a </span><code class="literal"><span class="koboSpan" id="kobo.27.1">Kill</span></code><span class="koboSpan" id="kobo.28.1"> message at any point during the money transaction?</span></li><li class="listitem"><span class="koboSpan" id="kobo.29.1">Implement the </span><code class="literal"><span class="koboSpan" id="kobo.30.1">SessionActor</span></code><span class="koboSpan" id="kobo.31.1"> class for actors that control access to other actors:</span><pre class="programlisting"><span class="koboSpan" id="kobo.32.1">        class SessionActor(password: String, r: ActorRef) 
        extends Actor { 
          def receive = ??? 
        </span><span class="koboSpan" id="kobo.32.2">} 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.33.1">After the </span><code class="literal"><span class="koboSpan" id="kobo.34.1">SessionActor</span></code><span class="koboSpan" id="kobo.35.1"> instance receives the </span><code class="literal"><span class="koboSpan" id="kobo.36.1">StartSession</span></code><span class="koboSpan" id="kobo.37.1"> message with the correct password, it forwards all the messages to the actor reference </span><code class="literal"><span class="koboSpan" id="kobo.38.1">r</span></code><span class="koboSpan" id="kobo.39.1">, until it receives the </span><code class="literal"><span class="koboSpan" id="kobo.40.1">EndSession</span></code><span class="koboSpan" id="kobo.41.1"> message. </span><span class="koboSpan" id="kobo.41.2">Use behaviors to model this actor.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.42.1">Use actors to implement the </span><code class="literal"><span class="koboSpan" id="kobo.43.1">ExecutionContext</span></code><span class="koboSpan" id="kobo.44.1"> interface, described in </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.45.1">Chapter 3</span></a><span class="koboSpan" id="kobo.46.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.47.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.48.1">.</span></li><li class="listitem"><span class="koboSpan" id="kobo.49.1">Implement the </span><code class="literal"><span class="koboSpan" id="kobo.50.1">FailureDetector</span></code><span class="koboSpan" id="kobo.51.1"> actor, which sends </span><code class="literal"><span class="koboSpan" id="kobo.52.1">Identify</span></code><span class="koboSpan" id="kobo.53.1"> messages to the specified actors every </span><code class="literal"><span class="koboSpan" id="kobo.54.1">interval</span></code><span class="koboSpan" id="kobo.55.1"> seconds. </span><span class="koboSpan" id="kobo.55.2">If an actor does not reply with any </span><code class="literal"><span class="koboSpan" id="kobo.56.1">ActorIdentity</span></code><span class="koboSpan" id="kobo.57.1"> messages within </span><code class="literal"><span class="koboSpan" id="kobo.58.1">threshold</span></code><span class="koboSpan" id="kobo.59.1"> seconds, the </span><code class="literal"><span class="koboSpan" id="kobo.60.1">FailureDetector</span></code><span class="koboSpan" id="kobo.61.1"> actor sends a </span><code class="literal"><span class="koboSpan" id="kobo.62.1">Failed</span></code><span class="koboSpan" id="kobo.63.1"> message to its parent actor, which contains the actor reference of the failed actor.</span></li><li class="listitem"><span class="koboSpan" id="kobo.64.1">A distributed hash map is a collection distributed across multiple computers, each of which contains part of the data, called a </span><span class="strong"><strong><span class="koboSpan" id="kobo.65.1">shard</span></strong></span><span class="koboSpan" id="kobo.66.1">. </span><span class="koboSpan" id="kobo.66.2">When there are </span><code class="literal"><span class="koboSpan" id="kobo.67.1">2^n</span></code><span class="koboSpan" id="kobo.68.1"> shards, the first </span><code class="literal"><span class="koboSpan" id="kobo.69.1">n</span></code><span class="koboSpan" id="kobo.70.1"> bits of the hash code of the key are used to decide which shard a key-value pair should go to. </span><span class="koboSpan" id="kobo.70.2">Implement the distributed hash map with the </span><code class="literal"><span class="koboSpan" id="kobo.71.1">DistributedMap</span></code><span class="koboSpan" id="kobo.72.1"> class:</span><pre class="programlisting"><span class="koboSpan" id="kobo.73.1">        class DistributedMap[K, V](shards: ActorRef*) { 
          def update(key: K, value: V): Future[Unit] = ??? 
          </span><span class="koboSpan" id="kobo.73.2">def get(key: K): Future[Option[V]] = ??? 
        </span><span class="koboSpan" id="kobo.73.3">} 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.74.1">The </span><code class="literal"><span class="koboSpan" id="kobo.75.1">DistributedMap</span></code><span class="koboSpan" id="kobo.76.1"> class takes a list of actor references to the </span><code class="literal"><span class="koboSpan" id="kobo.77.1">ShardActor</span></code><span class="koboSpan" id="kobo.78.1"> instances, whose actor template you also need to implement. </span><span class="koboSpan" id="kobo.78.2">You might assume that the length of the </span><code class="literal"><span class="koboSpan" id="kobo.79.1">shards</span></code><span class="koboSpan" id="kobo.80.1"> list is a power of two. </span><span class="koboSpan" id="kobo.80.2">The </span><code class="literal"><span class="koboSpan" id="kobo.81.1">update</span></code><span class="koboSpan" id="kobo.82.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.83.1">get</span></code><span class="koboSpan" id="kobo.84.1"> methods are asynchronous, and return the result in a future object.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.85.1">Implement an abstract </span><code class="literal"><span class="koboSpan" id="kobo.86.1">BroadcastActor</span></code><span class="koboSpan" id="kobo.87.1"> class, which defines the </span><code class="literal"><span class="koboSpan" id="kobo.88.1">broadcast</span></code><span class="koboSpan" id="kobo.89.1"> method:</span><pre class="programlisting"><span class="koboSpan" id="kobo.90.1">        def broadcast(refs: ActorRef*)(msg: Any): Unit = ??? 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.91.1">The </span><code class="literal"><span class="koboSpan" id="kobo.92.1">broadcast</span></code><span class="koboSpan" id="kobo.93.1"> method sends the </span><code class="literal"><span class="koboSpan" id="kobo.94.1">msg</span></code><span class="koboSpan" id="kobo.95.1"> message to all the actors specified in the </span><code class="literal"><span class="koboSpan" id="kobo.96.1">refs</span></code><span class="koboSpan" id="kobo.97.1"> list. </span><span class="koboSpan" id="kobo.97.2">The actor invoking the </span><code class="literal"><span class="koboSpan" id="kobo.98.1">broadcast</span></code><span class="koboSpan" id="kobo.99.1"> method might, for reasons such as power loss, fail at any point during the execution of the </span><code class="literal"><span class="koboSpan" id="kobo.100.1">broadcast</span></code><span class="koboSpan" id="kobo.101.1"> method. </span><span class="koboSpan" id="kobo.101.2">Nevertheless, the </span><code class="literal"><span class="koboSpan" id="kobo.102.1">broadcast</span></code><span class="koboSpan" id="kobo.103.1"> method must have </span><span class="strong"><strong><span class="koboSpan" id="kobo.104.1">reliable delivery</span></strong></span><span class="koboSpan" id="kobo.105.1">: if at least one actor from the </span><code class="literal"><span class="koboSpan" id="kobo.106.1">refs</span></code><span class="koboSpan" id="kobo.107.1"> list receives the </span><code class="literal"><span class="koboSpan" id="kobo.108.1">msg</span></code><span class="koboSpan" id="kobo.109.1"> message, then all the actors from the </span><code class="literal"><span class="koboSpan" id="kobo.110.1">refs</span></code><span class="koboSpan" id="kobo.111.1"> list must eventually receive </span><code class="literal"><span class="koboSpan" id="kobo.112.1">msg</span></code><span class="koboSpan" id="kobo.113.1">.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.114.1">Implement a </span><code class="literal"><span class="koboSpan" id="kobo.115.1">FlowRateActor</span></code><span class="koboSpan" id="kobo.116.1"> class for an actor that forwards incoming messages to a target actor. </span><span class="koboSpan" id="kobo.116.2">This actor must ensure that the number of messages forwarded per second does not exceed a rate specified in its constructor.</span></li><li class="listitem"><span class="koboSpan" id="kobo.117.1">Implement a </span><code class="literal"><span class="koboSpan" id="kobo.118.1">Sequencer</span></code><span class="koboSpan" id="kobo.119.1"> actor, which forwards messages to the target actor. </span><span class="koboSpan" id="kobo.119.2">If the message is a two-element tuple where the first element is a </span><code class="literal"><span class="koboSpan" id="kobo.120.1">Long</span></code><span class="koboSpan" id="kobo.121.1"> value, then the </span><code class="literal"><span class="koboSpan" id="kobo.122.1">Long</span></code><span class="koboSpan" id="kobo.123.1"> value is interpreted as a sequence number. </span><span class="koboSpan" id="kobo.123.2">All such messages must be forwarded in the proper sequence number order, starting from number </span><code class="literal"><span class="koboSpan" id="kobo.124.1">0</span></code><span class="koboSpan" id="kobo.125.1">.</span></li><li class="listitem"><span class="koboSpan" id="kobo.126.1">Implement a </span><code class="literal"><span class="koboSpan" id="kobo.127.1">MasterWorker[T]</span></code><span class="koboSpan" id="kobo.128.1"> actor that, given a number of worker parameters, creates a set of worker actors and forwards task messages of type </span><code class="literal"><span class="koboSpan" id="kobo.129.1">() =&gt; T</span></code><span class="koboSpan" id="kobo.130.1"> to those workers. </span><span class="koboSpan" id="kobo.130.2">When the worker actors complete a task, they send the result back to the </span><code class="literal"><span class="koboSpan" id="kobo.131.1">MasterWorker</span></code><span class="koboSpan" id="kobo.132.1"> actor, which sends the reply back to the client actor that originally sent the task.</span></li></ol></div></div></div></div></body></html>