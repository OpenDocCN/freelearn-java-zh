<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>A Three-Tier Web Application Pattern with GraphQL</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A Three-Tier Web Application Pattern with GraphQL</h1>
                </header>
            
            <article>
                
<p>In <a href="svrls-dsnptn-bstprac_ch02.html" target="_blank">Chapter 2</a>, <em>A</em>&#160;<em>Three</em><span><em>-Tier Web Application Using REST</em>,</span> &#160;we walked through the entire process of authoring a REST API on top of a serverless system with accompanying hosted services for the data and presentation layers. Our serverless logic layer was implemented with AWS Lambda and API Gateway, which provide many advantages regarding deployment, iteration speed, and scalability. REST APIs are well understood among the web development community and a safe choice when building a new web-based API. However, emerging tools and protocols are taking shape and providing us with alternatives to REST. GraphQL is arguably one of the most popular alternatives to REST APIs lately, evidenced by AWS and other platforms releasing hosted GraphQL services. You don't need to look very deep to find the uptick in GraphQL's popularity.&#160;</p>
<p>In this chapter, we'll walk through the process of updating the three-tier example API to use a GraphQL interface rather than a REST interface. These changes will focus on only the logic layer, as the data layer will not change at all. We will learn how to set up and author a single GraphQL serverless endpoint as opposed to multiple endpoints as in the REST-based design.</p>
<p>In this chapter, we will look into and discuss the following:</p>
<ul>
<li>How to author a GraphQL API using AWS Lambda and Python</li>
<li>The differences in function layout between GraphQL and REST serverless applications</li>
<li>How to query our GraphQL endpoint as a client</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction to GraphQL</h1>
                </header>
            
            <article>
                
<p>REST has been around for nearly 20 years and remains a popular choice for web APIs, both internal and public. As popular as REST is, it does have its flaws and is more of an idea as opposed to a specification. Anyone who has designed or worked with third-party APIs knows that there is often little overlap in implementation and design choices from one API to another. At best, this makes using or designing REST APIs challenging. When approaching a new REST API, there is always the work of exploring the various API endpoints, hunting for the data you'll need, understanding the different resource types and how they relate, and so on. Of course, when working with a new API, there will always be some level of investment and discovery to learn the data with which you'll be working. &#160;</p>
<p>Facebook designed GraphQL internally in 2012 and released it to the public in 2015. GraphQL is the new kid on the block and is picking up substantial traction as an alternative to REST. While the end goal is the same as REST&#160;<span>(to get data from a client to the server), the implementation and mechanisms for doing so are drastically different. Perhaps most different from REST, GraphQL is an actual specification that client and server implementations can reference and agree on. In contrast, REST is a set of principles and ideas that are subject to interpretation. GraphQL defines a&#160;new query language and allows clients to ask for the data they need consistently. With REST, the addition, removal, or permutation of return values usually requires server-side code changes. With GraphQL, clients are able to define the structure of the return payload in an ad hoc fashion on a query-by-query basis. For clients, the boundaries in a REST API are the endpoints provided at a given point in time and their return values, whereas the limits&#160;in a GraphQL API are the full domain of the API.</span></p>
<div class="packt_tip">GraphQL <span>is a big and complex topic. It's still relatively new, especially when comparing it to REST and other web technologies. Because GraphQL digests so many of the complexities of a web API, any conversation&#160;about GraphQL quickly becomes a discussion about the intricacies of GraphQL itself. In this chapter, I attempt to give just the right amount of detail on GraphQL to demonstrate the underlying serverless pattern. If you find yourself wanting a deeper understanding of GraphQL during reading or at the end of this chapter, I encourage you to read the many articles and blog posts that exist on this topic.&#160;</span><span>The following introduction from Facebook is a great place to start:&#160;</span><a href="https://reactjs.org/blog/2015/05/01/graphql-introduction.html">https://reactjs.org/blog/2015/05/01/graphql-introduction.html</a>.<a href="https://reactjs.org/blog/2015/05/01/graphql-introduction.html"></a></div>
<p><span>In short, clients working with a GraphQL API can fetch precisely the data they need, no more, no less. Over-fetching (getting more data than the client needs) and under-fetching (needing to make multiple API calls to get the data the client needs) issues disappear when working with GraphQL, which arguably was a significant driver in Facebook's design of GraphQL and provides many benefits for clients. Another exciting and powerful attribute of GraphQL is that it isn't an HTTP-only specification. While HTTP is currently the primary use case, GraphQL isn't tied directly to HTTP and may be used with other transport protocols.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">System architecture</h1>
                </header>
            
            <article>
                
<p>Our system architecture, at a high level, will be the same as in the REST API version of our sample application. Requests from the web will hit the CloudFront CDN, which is backed by S3. Our JavaScript code from the served-up HTML files will query the serverless API, which itself will communicate with the RDS-backed data layer:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/7738859c-3d36-405c-8272-da1f262788bd.jpg" style="width:32.42em;height:23.25em;"/></div>
<p>Thinking through this application from a top-down approach, the steps in fetching data will be the same regardless of how the logic layer is implemented:</p>
<ul>
<li>End-user&#160;requests a website</li>
<li>Static assets are served to the user from CloudFront and S3</li>
<li>Static assets request data via logic layer/web APIs (GraphQL in this case)</li>
<li>Logic layer fetches/writes data from/to Postgres database in the data layer</li>
</ul>
<p>Moving our example web application from a REST design to GraphQL means focusing on the <strong>logic layer</strong>, as the presentation and data layers won't change much, if at all. Of course, any changes to our API mean that our presentation layer (that is, the client) will need to change; however, as that is not our primary area of focus, we won't delve too deeply into the client-side changes.</p>
<p>You can find all of the code in this chapter in the following repository:</p>
<p class="mce-root"><a href="https://github.com/brianz/serverless-design-patterns/tree/master/ch3">https://github.com/brianz/serverless-design-patterns/tree/master/ch3</a></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Logic layer</h1>
                </header>
            
            <article>
                
<p>GraphQL simplifies life for clients because there is a single HTTP endpoint. In some ways, this makes the pattern for a serverless GraphQL API extremely simple and in some ways quite dull.</p>
<p><span>If we were starting this GraphQL web application from scratch, there would be plenty of decisions to make and material to cover to make our application code modular, easy to test, and well designed. Since we're porting the example REST web application, we have already implemented the vast majority of the needed functionality and software layers. These sections may seem terser than expected, especially if you have skipped <a href="svrls-dsnptn-bstprac_ch02.html" target="_blank">Chapter 2</a></span>, <span><em>A&#160;Three-Tier Web Application using REST</em>. Any gaps in code organization or layout, configuration strategy, deployments, and so on can be filled by reviewing <a href="svrls-dsnptn-bstprac_ch02.html" target="_blank">Chapter 2</a></span>, <span><em>A&#160;</em></span><span><em>Three-Tier Web Application using REST</em>.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Organization of the Lambda functions</h1>
                </header>
            
            <article>
                
<p>REST APIs are built around resources that&#160;each own their own URI, in part to give clients a well-known or predictable way to interact. GraphQL takes a different approach. Note that the <em>QL</em> in GraphQL stands for&#160;<em>query language</em>. Data-fetching logic is moved into the query language itself, rather than being distributed among different API endpoints as in the case of REST. Clients no longer need to work through the process of the following:</p>
<ul>
<li>Determining what resource they need and where it lives on the list of URLs</li>
<li>Looking up documentation to determine the input parameters and output data</li>
<li>If applicable, reading the documentation on pagination or limiting of returned data</li>
</ul>
<p>A formal specification currently found at <a href="http://facebook.github.io/graphql/October2016/">http://facebook.github.io/graphql/October2016/</a> defines GraphQL in absolute terms. As with any specification, any framework or library that aims at providing GraphQL functionality to users must abide by this formal contract. Both clients and servers work within the bounds of this specification so that there is a single way to handle common bits of functionality. To keep these points in context, the logic for this functionality is implemented in a single endpoint and hence Lambda function, regardless of the resource or any other data being requested.</p>
<p>The following diagram shows what the move from a REST API to GraphQL looks like regarding supported URLs and backing functions:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/fdc3b768-7432-47ac-8f03-d5e3153d9b70.jpg" style="width:51.75em;height:26.50em;"/></div>
<p>As we saw in <span>&#160;<a href="svrls-dsnptn-bstprac_ch02.html" target="_blank">Chapter 2</a>, <em>A&#160;</em></span><span><em>Three-Tier Web Application using REST</em>,</span> a REST API in a serverless system is or may be composed of a serverless function (AWS Lambda or the like) for one or more API endpoints. As the API grows, so too does the number of serverless functions.</p>
<p>GraphQL, on the other hand, contains all of the logic for an entire API, including creation, reading, and updating of data. It should be clear from the preceding diagram that regardless of how a system changes, there are no changes required to the serverless functions backing the GraphQL API. Any changes in business logic or application logic are wrapped up in application code, in contrast to requiring&#160;changes in URL structure and hence serverless functions or layout.</p>
<p>For this chapter, we will be working on a single AWS Lambda function and HTTP endpoint that will handle all GraphQL requests. Do note, however, that GraphQL clients may make requests over both <kbd>GET</kbd> and <kbd>POST</kbd>, so our Lambda function will be set up to handle both request types.</p>
<div class="packt_tip">You can find more details on serving GraphQL over HTTP in the official documentation at&#160;<a href="http://graphql.org/learn/serving-over-http/">http://graphql.org/learn/serving-over-http/</a>.<a href="http://graphql.org/learn/serving-over-http/"></a></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Organization of the application code</h1>
                </header>
            
            <article>
                
<p>As noted previously, organizing serverless functions and application code is not exactly the same thing. With a GraphQL system, our lives as developers are slightly more comfortable since there is only a single endpoint to support. &#160;The overall organization of application code isn't changing at all from our REST API. The only real changes are that there will be much <em>less</em> application code to manage, but the overall layout, structure, and routing strategy will not change in any way. For details, readers may review <span><a href="svrls-dsnptn-bstprac_ch02.html" target="_blank">Chapter 2</a>, <em>A&#160;</em></span><span><em>Three-Tier Web Application using REST</em>.</span></p>
<p>Other parts of our API that will remain constant in the GraphQL implementation are the following:</p>
<ul>
<li>Configuration strategy via environment variables</li>
<li>Overall code structure and layout</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Function layout</h1>
                </header>
            
            <article>
                
<p>Our GraphQL endpoint will be handled by a single AWS Lambda function, via either the <kbd>GET</kbd> or <kbd>POST</kbd> HTTP method. For completeness, the diagram of the AWS API Gateway request to the AWS Lambda function looks like the following:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="images/304a0f02-d5d0-4c95-b8a4-4cfc93ee9171.png" style="width:15.25em;height:18.50em;"/></div>
<p>While it may seem a bit pedantic to review this, I think it's important to stress the simplicity of this pattern and the advantages gained by adopting GraphQL. Of course, there are always trade-offs, and GraphQL is no different. Since so much functionality is pushed down into the logic layers, most of your time will likely be spent in application code, ensuring your API provides the same functionality as before and learning the details of GraphQL itself. Not being a GraphQL expert myself, and because GraphQL isn't the&#160;<span>main</span><span>&#160;topic of this book, we won't be covering all of the possible scenarios and functionality of a GraphQL API.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Presentation layer</h1>
                </header>
            
            <article>
                
<p>In <span>&#160;<a href="https://cdp.packtpub.com/serverless_design_patterns_and_best_practices/wp-admin/post.php?post=50&amp;action=edit#post_27" target="_blank">Chapter 2</a>, <em>A</em>&#160;</span><span><em>Three-Tier Web Application using REST</em></span>, our React application was making API calls to our REST endpoints. This REST API that we built returns JSON, which our frontend code easily digests and feeds into our React code for rendering UI elements.</p>
<p>With a change to a GraphQL-based API, our frontend code will need to change somewhat drastically for the data-fetching sections. GraphQL behaves very differently than REST, and there is no corollary between a REST endpoint, which returns a known set of data, and GraphQL. Each GraphQL query is unique in that the client is responsible for asking for a specific set of data.</p>
<p>We won't review the changes to the frontend code. At the time of writing, popular choices for GraphQL for the frontend are Apollo and Relay. Apollo comes out of the Meteor Development Group and Facebook is behind Relay. Both are open source and popular in the GraphQL community. There are many resources on both topics all over the internet and readers are encouraged to learn more on their own. For this chapter, we'll interact with our GraphQL backend using an API client.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing the logic layer</h1>
                </header>
            
            <article>
                
<p>Adding this GraphQL endpoint will consist of the following:</p>
<ul>
<li>Adding a new entry point to handle the new Lambda function</li>
<li>Passing the HTTP payload (which is a GraphQL query or mutation) to a function that will execute GraphQL code</li>
</ul>
<p>Admittedly, GraphQL is new enough that libraries and the ecosystem are not entirely polished or rich with documentation, at least in my experience. Still, it's possible to make quick progress, and once the basics are solved, GraphQL by its nature enables a vast range of functionality.</p>
<p>Since the coffee cupping example application is implemented using Python, we will continue down that path and augment it with some additional libraries for GraphQL. At the time of writing, Graphene is the de facto library for working with GraphQL from Python. Along with the base library, there are several other libraries that make working with various data stores easier. Luckily for us, one of the add-on libraries is Graphene-SQLAlchemy, which will work with our own SQLAlchemy code.</p>
<div class="packt_infobox">You can learn more about Graphene and its related integrations at <a href="http://graphene-python.org">http://graphene-python.org</a>.<a href="http://graphene-python.org"></a></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing the entry point</h1>
                </header>
            
            <article>
                
<p>With the addition of a new Lambda function that will respond to requests at the <kbd>/graphql</kbd> endpoint, we need one new entry in our existing <kbd>handler.py</kbd> file. For consistency with the other handlers in this file, the function will do the following:</p>
<ul>
<li>Extract the HTTP method and payload from the request</li>
<li>Hand the HTTP method and payload to another function for processing</li>
<li>Construct and return the final response to API Gateway:</li>
</ul>
<pre>        def graphql(event, context):<br/>        http_method = event['httpMethod']<br/><br/>        response = handle_graphql(http_method, event)<br/>        status_code = 200<br/><br/>        response = {<br/>          'statusCode': status_code,<br/>          'body': json.dumps(response),<br/>          'headers': CORS_HEADERS,<br/>        }<br/><br/>        return response</pre>
<p>There isn't much to&#160;do&#160;in this function and one can see that the bulk of the logic is in the <kbd>handle_graphql</kbd> function, which we import at the top of the file and that lives in <kbd>cupping/handlers/graphql.py</kbd>. Using this pattern is extremely helpful since all of our path setups has already been completed and other standard code, such as the&#160;<kbd>cors</kbd> headers, is complete.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing GraphQL queries</h1>
                </header>
            
            <article>
                
<p>With the boilerplate out of the way, it's time to focus on our actual GraphQL implementation. Many software layers that powered the REST API will also power the GraphQL API, specifically the model/validation layer and persistence/SQLAlchemy layer.</p>
<p>If you are new to GraphQL, know there are two types of operations,&#160;which <span>GraphQL treats&#160;</span>differently and which require slightly different code, at least when using Python and Graphene. Those two actions are queries and mutations, or reads and writes, respectively. In this section, we will cover queries. This code provides all of the functionality for every query interaction in our example API. Details of each part of this code will be discussed in later. The main entry point is this handler code is the <kbd>handle_graphql</kbd> function:</p>
<pre style="padding-left: 30px">import json<br/>import graphene<br/><br/>from graphene_sqlalchemy import SQLAlchemyObjectType<br/><br/>from .decorators import decode_json<br/><br/>from ..models import SessionModel<br/>from ..persistence.cupping import Cupping<br/>from ..persistence.session import Session<br/>from ..persistence.queries import (<br/>        get_cuppings,<br/>        get_sessions,<br/>)<br/><br/><br/>class CuppingObject(SQLAlchemyObjectType):<br/>    class Meta:<br/>        model = Cupping<br/><br/><br/>class SessionObject(SQLAlchemyObjectType):<br/>    class Meta:<br/>        model = Session<br/><br/><br/>class Query(graphene.ObjectType):<br/>    sessions = graphene.List(SessionObject, id=graphene.Int(), <br/>    account_id=graphene.Int())<br/>    cuppings = graphene.List(CuppingObject, session_id=graphene.Int())<br/><br/>    def resolve_cuppings(self, info, **filters):<br/>        return get_cuppings(**filters)<br/><br/>    def resolve_sessions(self, info, **filters):<br/>        return get_sessions(**filters)<br/><br/><br/># Global schema which will handle queries and mutations<br/>schema = graphene.Schema(<br/>        query=Query,<br/>        types=[CuppingObject, SessionObject],<br/>)<br/><br/><br/>@decode_json<br/>def _handle_graphql(payload):<br/>    query = payload['query']<br/>    variables = payload.get('variables', {})<br/>    result = schema.execute(query, variable_values=variables)<br/>    success = True if not result.errors else False<br/>    return success, result<br/><br/><br/>def handle_graphql(http_method, payload):<br/>    success, result = _handle_graphql(payload)<br/>    if not success:<br/>        errors = []<br/>        for e in result.errors:<br/>            try:<br/>                e = json.loads(e.message)<br/>            except:<br/>                e = str(e)<br/>            errors.append(e)<br/>        return {'errors': errors}<br/>    return result.data</pre>
<p>The preceding code implements the same functionality as our REST API's <kbd>GET</kbd> endpoints, getting a listing of all cupping sessions and individual cupping sessions. Following on from the top-level <kbd>handler.py</kbd>, the <kbd>handle_graphql</kbd> function accepts an HTTP method, which isn't even used, along with a JSON-encoded payload from the request. From there, it's handed off to a small helper function that decodes the JSON payload via a decorator we authored earlier. Some light error handling ensures that errors come back in the right format. This function ultimately returns a Python dictionary with either errors or the result of the GraphQL execution. &#160;Ultimately, this dictionary is JSON-encoded and returned to the client, as we saw in <kbd>handler.py</kbd>.</p>
<p>The <kbd>Query</kbd> class is the central place where most, if not all, of the functionality, will occur for fetching data from our backend. Our API has two main resources, <kbd>Session</kbd> and <kbd>Cupping</kbd>. &#160;Since we are making this API have functional parity with our REST API, two class attributes will give us the ability to respond to queries for either <kbd>cuppings</kbd> or <kbd>sessions</kbd>:</p>
<pre>    class Query(graphene.ObjectType):<br/>      sessions = graphene.List(SessionObject,<br/>         id=graphene.Int(), account_id=graphene.Int())<br/>      cuppings = graphene.List(CuppingObject, <br/>         session_id=graphene.Int())<br/><br/>      def resolve_cuppings(self, info, **filters):<br/>          return get_cuppings(**filters)<br/><br/>      def resolve_sessions(self, info, **filters):<br/>          return get_sessions(**filters)</pre>
<p>Taking <kbd>sessions</kbd> as an example, we define the <kbd>sessions</kbd> attribute to be a list of GraphQL objects, where each item in the list is a <kbd>SessionObject</kbd>. Fortunately, <kbd>SessionObject</kbd> is trivial to implement since we can take advantage of Graphene-SQLAlchemy and map the Session SQLAlchemy model to a Graphene-compatible object type. In reality, we could have performed this entirely on our own, but it would have required manually constructing an object that maps SQLAlchemy fields to Graphene fields and writing more code. <span>Graphene-SQLAlchemy handles all of this work automatically.</span></p>
<p>Two additional keyword arguments are passed into <kbd>graphene.List</kbd>,&#160;<kbd>id</kbd>, and <kbd>account_id</kbd>. Attributes that we want to use to query need to be explicitly defined when building <kbd>Query</kbd> items. The addition of <kbd>id</kbd> and <kbd>account_id</kbd> mean the API can now accept either or both fields from clients and use them to filter results. &#160;Do note that we have surpassed the REST API in functionality, albeit only slightly. By adding <kbd>account_id</kbd> as a query field, we've given our API new functionality that didn't exist in the REST version. &#160;Also, this GraphQL API can return a list of cupping resources, which wasn't possible in the REST API. If you think through the steps of adding this functionality to the REST API, we'd need to add a new endpoint to return the new cupping resources by themselves and either come up with an entirely new API endpoint or shoehorn in some query parameters as <kbd>GET</kbd> arguments to filter <kbd>Sessions</kbd> by account. While either approach can work, it should be clear that this speaks to some of the inconsistencies and areas for interpretation with REST APIs. Here, there is one, and only one, way to add query parameters to a GraphQL query.</p>
<p>Now that we have defined the return values, there is still the work of actually fetching the data. Graphene makes this quite simple by requiring a method prepended with <kbd>resolve_</kbd> in order to fetch whichever resource we've implemented. The preceding code for both resolve functions, <kbd>resolve_sessions</kbd>, and <kbd>resolve_cuppings</kbd>, makes calls to our SQLAlchemy query functions and also passes through any filters that arrive via the extra keyword arguments defined on the <kbd>graphene.List</kbd> attributes previously described. Both resolve functions will return lists of SQLAlchemy objects; however, because the attributes that are requesting the data are themselves defined as &#160;<kbd>SQLAlchemyObjectType</kbd>, the SQLAlchemy return values are transformed to the correct data types to fulfill the GraphQL queries.</p>
<p>A couple of example queries later in this chapter&#160;may help solidify the flow of data and the code.&#160;</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing GraphQL mutations</h1>
                </header>
            
            <article>
                
<p>After querying comes mutation, which is an operation which writes&#160;or otherwise transforms data. In our API, we'll be implementing a single mutation that will create&#160;new <kbd>Session</kbd> records, which themselves have accompanying cupping records. Again, we're able to reuse helper functions and code to perform some of this work and can focus on the GraphQL code. The following additions to the <kbd>handlers/graphql.py</kbd> code implements creating new <kbd>Session</kbd> records. There is a slight change to the creation of the <kbd>schema</kbd> object, where we pass in a reference to our <kbd>Mutation</kbd> class:</p>
<pre style="padding-left: 30px">class CuppingInput(graphene.InputObjectType):<br/>    name = graphene.String(required=True)<br/>    scores = graphene.types.json.JSONString()<br/>    overall_score = graphene.Float(required=True)<br/>    notes = graphene.String()<br/>    descriptors = graphene.List(graphene.String)<br/>    defects = graphene.List(graphene.String)<br/>    is_sample = graphene.Boolean()<br/><br/><br/>class CreateSessionMutation(graphene.Mutation):<br/><br/>    class Arguments:<br/>        name = graphene.String()<br/>        form_name = graphene.String()<br/>        account_id = graphene.Int()<br/>        user_id = graphene.Int()<br/>        cuppings = graphene.List(CuppingInput)<br/><br/>    ok = graphene.Boolean()<br/>    session = graphene.Field(SessionObject)<br/><br/>    def mutate(self, info, *args, **kwargs):<br/>        session = create_session_from_kwargs(kwargs)<br/>        return CreateSessionMutation(session=session, ok=True)<br/><br/><br/>class Mutation(graphene.ObjectType):<br/>    create_session = CreateSessionMutation.Field()<br/><br/><br/># Global schema which will handle queries and mutations<br/>schema = graphene.Schema(<br/>        query=Query,<br/>        mutation=Mutation,<br/>        types=[CuppingObject, SessionObject],<br/>)</pre>
<p>First, notice that the <kbd>Mutation</kbd> class is the wrapper around all mutations that need to be defined and passed into our <kbd>Schema</kbd>. Just like the <kbd>Query</kbd> class, the <kbd>Mutation</kbd> class will specify one or more mutation types, which themselves subclass <kbd>graphene.Mutation</kbd>. The entry point for a <kbd>Mutation</kbd> class is the <kbd>mutate</kbd> method.</p>
<p>Before the <kbd>mutate</kbd> method can be invoked, the class needs to define a set of input attributes that will accept the actual input data used to create new data. In this case, we need to identify the input data types manually using the raw <kbd>graphene</kbd> type. Look at the&#160;<kbd>Arguments</kbd> class and you should be able to see the one-to-one correspondence with the SQLAlchemy models. GraphQL objects can be nested arbitrarily deep, that can be seen previously, where the <kbd>cuppings</kbd> attribute is a list of <kbd>CuppingInput</kbd> objects, itself a custom input type specific to our API.</p>
<p>As in the <kbd>resolve_</kbd> functions in a <kbd>Query</kbd> attribute, the <kbd>mutate</kbd> method delegates the creation of records to an existing SQLAlchemy function ultimately. All of the input data from a client's GraphQL mutation arrive as <kbd>kwargs</kbd> to <kbd>mutate</kbd>. Those key-value pairs in the form of a Python dictionary are used to create a model, validate, and finally write a new record to the database. At this point, any validation errors are handled by our model layer and error bubble up to the client.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Deployment</h1>
                </header>
            
            <article>
                
<p>With a new Lambda function comes the need to deploy our code, which requires a full deployment via <kbd>sls deploy</kbd>. As a reminder, any time you add, remove, or otherwise update an AWS resource, a complete <kbd>CloudFormation</kbd> update is needed. We need to add a couple of new entries in the <kbd>serverless.yml</kbd> file, which will call the new <kbd>graphql</kbd> handler functions:</p>
<pre>    functions:<br/>     GraphQL:<br/>       handler: handler.graphql<br/>       events:<br/>         - http:<br/>             path: graphql<br/>             method: get<br/>             cors: true<br/>         - http:<br/>             path: graphql<br/>             method: post<br/>             cors: true</pre>
<p>GraphQL will accept both <kbd>GET</kbd> and <kbd>POST</kbd> requests, so we'll wire methods to the same <kbd>/graphql</kbd> endpoint and make sure we enable CORS.</p>
<p>Since we're using new libraries, Graphene and Graphene-SQLAlchemy, we'll need to update our requirements file and rebuild our supporting libraries. I've added the following library to a specific commit to the <kbd>requirements.txt</kbd> file:</p>
<pre><strong>git+https://github.com/graphql-python/graphene-sqlalchemy.git@08a0072</strong></pre>
<p>Graphene is a requirement for Graphene-SQLAlchemy, so we get both libraries with this single requirement.</p>
<p>We use our Docker container as a build tool:</p>
<pre><strong>brianz@gold(graphql=)$ ENV=dev make shell</strong><br/><strong>root@7466ff009753:/code#</strong><br/><strong>root@7466ff009753:/code# make libs </strong><br/><strong>pip install -t serverless/lib -r requirements.txt </strong><br/><strong>Collecting git+https://github.com/graphql-python/</strong><br/><strong>  graphene-sqlalchemy.git@08a0072 (from -r requirements.txt</strong><br/><strong>  (line 8)) </strong><br/><strong>   Cloning https://github.com/graphql-python/</strong><br/><strong>   graphene-sqlalchemy.git (to 08a0072) to /tmp/pip-3tnr1e2k-build </strong><br/><strong>   Could not find a tag or branch '08a0072', assuming commit.</strong></pre>
<p>Now, it's safe to do the full deployment, as follows:</p>
<pre><strong>root@a2484038a502:/code# make deploy</strong><br/><strong>cd serverless &amp;&amp; sls deploy -s dev</strong><br/><strong>Serverless: Packaging service...</strong><br/><strong>Serverless: Excluding development dependencies...</strong><br/><strong>Serverless: Uploading CloudFormation file to S3...</strong><br/><strong>Serverless: Uploading artifacts...</strong><br/><strong>Serverless: Uploading service .zip file to S3 (5.55 MB)...</strong><br/><strong>Serverless: Validating template...</strong><br/><strong>Serverless: Updating Stack...</strong><br/><strong>Serverless: Checking Stack update progress...</strong><br/><strong>..........................</strong><br/><strong>Serverless: Stack update finished... </strong><br/><strong>Service Information </strong><br/><strong>service: coffee-cupping </strong><br/><strong>stage: dev </strong><br/><strong>region: us-west-2 </strong><br/><strong>api keys: </strong><br/><strong>None </strong><br/><strong>endpoints: </strong><br/><strong>GET - https://4mvnd1tewe.execute-api.us-west-</strong><br/><strong>     2.amazonaws.com/dev/graphql </strong><br/><strong>POST - https://4mvnd1tewe.execute-api.us-west-</strong><br/><strong>     2.amazonaws.com/dev/graphql <br/></strong><strong>GET - https://4mvnd1tewe.execute-api.us-west-</strong><br/><strong>     2.amazonaws.com/dev/session </strong><br/><strong>POST - https://4mvnd1tewe.execute-api.us-west-</strong><br/><strong>     2.amazonaws.com/dev/session </strong><br/><strong>GET - https://4mvnd1tewe.execute-api.us-west-</strong><br/><strong>     2.amazonaws.com/dev/session/{id} </strong><br/><strong>DELETE - https://4mvnd1tewe.execute-api.us-west-</strong><br/><strong>     2.amazonaws.com/dev/session/{id} </strong><br/><strong>functions: </strong><br/><strong>GraphQL: coffee-cupping-dev-GraphQL </strong><br/><strong>HandleSession: coffee-cupping-dev-HandleSession </strong><br/><strong>HandleSessionDetail: coffee-cupping-dev-HandleSessionDetail</strong> </pre>
<p>With that, we have a new <kbd>/graphql</kbd> endpoint, which accepts both <kbd>GET</kbd> and <kbd>POST</kbd> requests. Next, it's time to test out some GraphQL queries on our serverless endpoint.</p>
<div class="packt_infobox">Astute readers may notice the root URL changing between example deployments. During development, this is a frequent occurrence, as you'll often be deploying new stacks and then tearing them down when no longer needed. For each deployment, a unique base URL will be created by API Gateway via CloudFormation. Of course, if this were a production API, you wouldn't be tearing down your serverless stack every evening and rebuilding it in the morning.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Viewing the deployed application</h1>
                </header>
            
            <article>
                
<p>Learning the GraphQL language is a topic in and of itself. In this section, I'll show some queries and mutations using the Insomnia client on macOS. Insomnia is a client application that can be used to make standard REST API requests and also has a lovely GraphQL interface when working with GraphQL endpoints.</p>
<p>A simple query to get a list of cupping sessions, returning only the ID and name of the <kbd>Sessions</kbd>, looks like the following:</p>
<pre>    query allSessions { <br/>      sessions {<br/>        id<br/>        name<br/>      }<br/>    }</pre>
<p>When you think back to the implementation of the <kbd>Query</kbd> class, you might recall the following:</p>
<pre>    class Query(graphene.ObjectType):<br/>      sessions = graphene.List(SessionObject, id=graphene.Int(),    <br/>         account_id=graphene.Int())</pre>
<p>Hopefully, things are becoming clearer now. The preceding query is named <kbd>allSessions</kbd>, and inside it's explicitly asking for <kbd>sessions</kbd>. Our GraphQL code responds in kind by noticing that the query is for sessions and invoking the <kbd>resolve_sessions</kbd> function. The following screenshot shows an <kbd>allSessions</kbd> query using the <span class="packt_screen">Insomnia</span> client:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/2707983c-782c-49bb-98b3-1a5b9e989d46.png"/></div>
<p>This is great, and the return data may suffice for a client who has a listing of all <kbd>Sessions</kbd>. But what happens when we want more data? In GraphQL, we merely ask for the data we need. Assume our client application now wants a listing of <kbd>Sessions</kbd>, but with a few more fields present, including the related <kbd>cupping</kbd> objects for each <kbd>Session.</kbd>&#160;To accomplish this, we update the query schema that we'll send to the <kbd>/graphql</kbd> endpoint. Rather than just asking for <kbd>id</kbd> and <kbd>name</kbd>, I'll add in <kbd>formName</kbd>, along with two attributes of the related <kbd>cuppings</kbd> items:</p>
<pre>    query allSessions { <br/>      sessions {<br/>          id<br/>          name<br/>          formName<br/>            cuppings {<br/>                name<br/>                notes<br/>            }<br/>      }<br/>    }</pre>
<p>The following screenshot shows this query along with the response in the <span class="packt_screen">Insomnia</span> client:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/eeb5cf2c-4dfb-4bc7-a072-344055faf230.png"/></div>
<p>I have to admit, I was quite excited to see how easy it is to control the output when I got this working. So what if we need to filter some data? Remember the API that didn't exist in our REST API but now does? Let's fetch all of the <kbd>cupping</kbd> objects that are related to a single <kbd>Session</kbd>:</p>
<pre>    query Cuppings($sessionId: Int!) { <br/>      cuppings(sessionId: $sessionId) {<br/>         id<br/>         name<br/>         overallScore<br/>         scores<br/>      }<br/>    }</pre>
<p>Again, let's tie this back to our application code and remember what the <kbd>cuppings</kbd> attribute was in our <kbd>Query</kbd>, class. &#160;Inside <kbd>Query</kbd> we have the following:</p>
<pre>    cuppings = graphene.List(CuppingObject, <br/>       session_id=graphene.Int())</pre>
<p>Graphene does include some magic for auto <em>CamelCase</em> input and output data. Even though the <kbd>cuppings</kbd> attribute specifies <kbd>session_id</kbd> as an input filter, the client uses <kbd>SessionId</kbd>. The end result is that the Python code receives <kbd>session_id</kbd> as a keyword argument that is passed to the SQLAlchemy query. The end result is that SQLAlchemy performs a query analogous to the following SQL statement:</p>
<pre>     select * from cuppings where session_id = 1</pre>
<p>The following screenshot shows a GraphQL query that will fetch a single <kbd>Session</kbd> based on a numeric ID from our GraphQL API:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/168b60ec-30bf-4fe4-9bbe-b0976ae6d17e.png"/></div>
<p>Finally, let's take a look at the mutation portion of our code and create some new data. You might expect this to be fairly simple, and it is for the most part. One slight complication is that the cupping scores field in the database is a PostgreSQL JSONB type, which allows for maximum flexibility. Inputting JSON requires escaping this field, which is the reason for all of the backslashes in the mutation request. The following code snippet is a GraphQL mutation that creates a new <kbd>Session</kbd> record:</p>
<pre>    mutation CreateSession { <br/>      createSession (<br/>        name: "Noon Friday session"<br/>        formName: "Roastery custom"<br/>        accountId: 234<br/>        cuppings: [<br/>        {<br/>          name: "Ethiopia Cochere"<br/>          overallScore: 91<br/>          scores: "{\"Aroma\": 10, \"Flavor\": 9, \"Body\": 8, <br/>                \"Clean Cup\": 6}"<br/>          descriptors: ["port-wine" "chocolate"]<br/>          notes: "deep and dark"<br/>        }<br/>        ]<br/>      ) <br/>       {<br/>         ok<br/>         session {<br/>           id<br/>           name<br/>           formName<br/>           cuppings {<br/>             sessionId<br/>             name<br/>             overallScore<br/>             scores<br/>             defects<br/>             descriptors<br/>             notes<br/>           }<br/>         }<br/>       }<br/>    }</pre>
<p>I won't go through all of the application code, but at a high level, our request sends in a <kbd>createSession</kbd> mutation to the application. This input payload maps directly to our <kbd>create_session</kbd> attribute on the <kbd>Mutation</kbd> class thanks to the auto <em>CamelCasing</em> from Graphene:</p>
<pre>    class Mutation(graphene.ObjectType):<br/>       create_session = CreateSessionMutation.Field()</pre>
<p>The input data in the preceding mutation is reasonably small. What is more verbose is the section for the return values. Our mutation returns an <kbd>ok</kbd>&#160;attribute, which is a&#160;Boolean, along with the newly created <kbd>Session</kbd> resource. Because of that, our mutation can request precisely what it needs from the newly created resource.</p>
<p>The following screenshot shows the input and output when creating a new <kbd>Session</kbd> record in the Insomnia client:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/3bebb18e-c720-4159-8023-071114ad13d8.png"/></div>
<p>GraphQL has much more to offer, and I only wish there was more time to cover it.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Iteration and deployment</h1>
                </header>
            
            <article>
                
<p>While developing this code using the existing repository, I repeatedly needed to update just the GraphQL portion of the stack. Using the Serverless Framework and its ability to update a single Lambda function made this very easy. With the shortcut in the <kbd>Makefile</kbd>, deploying a single function looks like the following:</p>
<pre><strong>root@7466ff009753:/code# make deploy function=GraphQL </strong><br/><strong>cd serverless &amp;&amp; sls deploy function -s dev -f GraphQL </strong><br/><strong>Serverless: Packaging function: GraphQL... </strong><br/><strong>Serverless: Excluding development dependencies... </strong><br/><strong>Serverless: Uploading function: GraphQL (5.74 MB)... </strong><br/><strong>Serverless: Successfully deployed function: GraphQL </strong><br/><strong>root@7466ff009753:/code# make deploy</strong></pre>
<p>It's hard to give exact numbers, but deployments like this after iteration on code take in the order of two-five seconds. Deployment speed will mostly depend on your upload speeds and the final size of the application package.</p>
<p>Of course, iterating and adding new code means writing more tests. Serverless applications can be slightly tricky since it's possible to write a rich set of unit tests, only to see the deployed application fail due to missing or presumptuous tests higher up in the stack. My advice is to write the right mix of unit tests, without being academic about it, along with a very rich set of integration tests as the highest level of code that is practical.</p>
<p>Using a concrete example, this GraphQL query and mutation code above is 100% tested, as is the&#160;<kbd><span>cupping.handlers.graphql.</span><span>handle_graphql</span></kbd><span>&#160;</span>function. This&#160;strategy ensures that all of the error handling, JSON decoding of the payload, and other utility code is behaving as expected, in addition to testing the GraphQL business logic.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we walked through the entire process of creating a three-tier web application with a serverless architecture using a GraphQL interface. The vast majority of this application is similar to the REST version of the same application. We learned the changes needed to migrate from a REST interface and design to a GraphQL design, both from the perspective of application code and serverless functions.</p>
<p>Readers should now have a high-level understanding of the advantages of employing a GraphQL interface in a serverless architecture and have enough knowledge&#160;to begin implementation of their own serverless GraphQL application.</p>
<p>In <a href="svrls-dsnptn-bstprac_ch04.html" target="_blank">Chapter 4</a>,&#160;<span><em>Integrating Legacy APIs with the Proxy Pattern</em>,</span> we will work through yet another web application pattern for proxying API requests from clients through a serverless application to a legacy API.</p>
<div class="grammarly-disable-indicator"></div>


            </article>

            
        </section>
    </div>
</body>
</html>