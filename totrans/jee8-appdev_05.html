<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Contexts and Dependency Injection</h1>
                </header>
            
            <article>
                
<p><strong>Contexts</strong> <strong>and</strong> <strong>Dependency</strong> <strong>Injection</strong> (<strong>CDI</strong>) was added to the Java EE specification in Java EE 6. Java EE 8 includes a new version of CDI, which adds new features such as asynchronous events and event ordering. CDI provides several advantages that were previously unavailable to Java EE developers, such as allowing any JavaBean to be used as a JSF managed bean, including stateless and stateful session beans. As its name implies, CDI simplifies dependency injection in Java EE applications.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Named beans</li>
<li>Dependency injection</li>
<li>Scopes</li>
<li>Qualifiers</li>
<li>CDI events</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Named beans</h1>
                </header>
            
            <article>
                
<p>CDI provides us with the ability to name our beans via the <kbd>@Named</kbd> annotation. Named beans allow us to easily inject our beans into other classes that depend on them (see the next section), and to easily refer to them from JSF pages via the unified expression language.</p>
<p>The following example shows the <kbd>@Named</kbd> annotation in action:</p>
<pre style="padding-left: 60px">package <a>n</a>et.ensode.javaee8book.cdidependencyinjection.beans; 
 
import javax.enterprise.context.RequestScoped; 
import javax.inject.Named; 
 
<strong>@Named</strong> 
@RequestScoped 
public class Customer { 
 
  private String firstName; 
  private String lastName; 
 
  public String getFirstName() { 
    return firstName; 
  } 
 
  public void setFirstName(String firstName) { 
    this.firstName = firstName; 
  } 
 
  public String getLastName() { 
    return lastName; 
  } 
 
  public void setLastName(String lastName) { 
    this.lastName = lastName; 
  } 
} </pre>
<p>As we can see, all we need to do to name our class is to decorate it with the <kbd>@Named</kbd> annotation. By default, the name of the bean will be the class name with its first letter switched to lowercase; in our example, the name of the bean would be <kbd>customer</kbd>. If we wish to use a different name, we can do so by setting the <kbd>value</kbd> attribute of the <kbd>@Named</kbd> annotation. For example, if we had wanted to use the name <kbd>customerBean</kbd> for the bean above, we could have done so by modifying the <kbd>@Named</kbd> annotation as follows:</p>
<pre style="padding-left: 60px">@Named(value="customerBean") </pre>
<p>Or simply:</p>
<pre style="padding-left: 60px">@Named("customerBean") </pre>
<p>Since the <kbd>value</kbd> attribute name does not need to be specified, if we don't use an attribute name, then <kbd>value</kbd> is implied.</p>
<p>This name can be used to access our bean from JSF pages using the unified expression language:</p>
<pre style="padding-left: 60px">&lt;?xml version='1.0' encoding='UTF-8' ?&gt; 
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; 
&lt;html  
      &gt; 
  &lt;h:head&gt; 
    &lt;title&gt;Enter Customer Information&lt;/title&gt; 
  &lt;/h:head&gt; 
  &lt;h:body&gt; 
    &lt;h:form&gt; 
      &lt;h:panelGrid columns="2"&gt; 
        &lt;h:outputLabel for="firstName" value="First  <br/>         Name"/&gt; 
        &lt;h:inputText id="firstName" 
        <strong> value="#{customer.firstName}"/&gt;</strong> 
        &lt;h:outputLabel for="lastName" value="Last  <br/>         Name"/&gt; 
        &lt;h:inputText id="lastName" 
        <strong> value="#{customer.lastName}"/&gt;</strong>         
        &lt;h:panelGroup/&gt;        
      &lt;/h:panelGrid&gt; 
    &lt;/h:form&gt; 
  &lt;/h:body&gt; 
&lt;/html&gt; </pre>
<p>As we can see, named beans are accessed from JSF pages exactly as standard JSF managed beans are. This allows JSF to access any named bean, decoupling the Java code from the JSF API.</p>
<p>When deployed and executed, our simple application looks like this:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/71173338-a1f7-4e86-b055-90fda1e1e4a8.png" style="width:16.25em;height:14.17em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependency injection</h1>
                </header>
            
            <article>
                
<p><strong>Dependency injection</strong> is a technique for supplying external dependencies to a Java class. Java EE 5 introduced dependency injection via the <kbd>@Resource</kbd> annotation, however, this annotation is limited to injecting resources such as database connections, JMS resources, and so on. CDI includes the <kbd>@Inject</kbd> annotation, which can be used to inject instances of Java classes into any dependent objects.</p>
<p>JSF applications typically follow the <strong>Model-View-Controller</strong> (<strong>MVC</strong>) design pattern. As such, often some JSF managed beans take the role of controllers in the pattern, while others take the role of the model. This approach typically requires the controller managed bean to have access to one or more of the model-managed beans. CDI's dependency injection capabilities make injecting beans into one another very simple, as illustrated in the following example:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.cdidependencyinjection.ejb; 
 
import java.util.logging.Logger; 
import javax.inject.Inject; 
import javax.inject.Named; 
 
@Named 
@RequestScoped 
public class CustomerController { 
 
  private static final Logger logger = Logger.getLogger( 
      CustomerController.class.getName()); 
  <strong>@Inject 
  private Customer customer;</strong> 
 
  public String saveCustomer() { 
 
    logger.info("Saving the following information \n" + customer. 
        toString()); 
 
    //If this was a real application, we would have code to save 
    //customer data to the database here. 
 
    return "confirmation"; 
  } 
} </pre>
<p>Notice that all we had to do to initialize our <kbd>Customer</kbd> instance was to decorate it with the <kbd>@Inject</kbd> annotation. When the bean is constructed by the application server, an instance of the <kbd>Customer</kbd> bean is automatically injected into this field. Notice that the injected bean is used in the <kbd>saveCustomer()</kbd> method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Qualifiers</h1>
                </header>
            
            <article>
                
<p>In some instances, the type of bean we wish to inject into our code may be an interface or a Java superclass, but we may be interested in injecting a specific subclass or a class implementing the interface. For cases like this, CDI provides qualifiers we can use to indicate the specific type we wish to inject into our code.</p>
<p>A CDI qualifier is an annotation that must be decorated with the <kbd>@Qualifier</kbd> annotation. This annotation can then be used to decorate the specific subclass or interface implementation we wish to qualify. Additionally, the injected field in the client code needs to be decorated with the qualifier as well.</p>
<p>Suppose our application could have a special kind of customer; for example, frequent customers could be given the status of premium customers. To handle those premium customers, we could extend our <kbd>Customer</kbd> named bean and decorate it with the following qualifier:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.cdidependencyinjection.qualifiers; 
 
import static java.lang.annotation.ElementType.TYPE; 
import static java.lang.annotation.ElementType.FIELD; 
import static java.lang.annotation.ElementType.PARAMETER; 
import static java.lang.annotation.ElementType.METHOD; 
import static java.lang.annotation.RetentionPolicy.RUNTIME; 
import java.lang.annotation.Retention; 
import java.lang.annotation.Target; 
import javax.inject.Qualifier; 
 
@Qualifier 
@Retention(RUNTIME) 
@Target({METHOD, FIELD, PARAMETER, TYPE}) 
public @interface Premium { 
} </pre>
<p>As we mentioned before, qualifiers are standard annotations; they typically have retention of runtime and can target methods, fields, parameters, or types, as illustrated in the above example. The only difference between a qualifier and a standard annotation is that qualifiers are decorated with the <kbd>@Qualifier</kbd> annotation.</p>
<p>Once we have our qualifier in place, we need to use it to decorate the specific subclass or interface implementation:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.cdidependencyinjection.beans; 
 
import javax.enterprise.context.RequestScoped; 
import javax.inject.Named; 
import net.ensode.javaee8book.cdidependencyinjection.qualifiers.Premium; 
 
@Named 
@RequestScoped 
<strong>@Premium</strong> 
public class PremiumCustomer extends Customer { 
 
  private Integer discountCode; 
 
  public Integer getDiscountCode() { 
    return discountCode; 
  } 
 
  public void setDiscountCode(Integer discountCode) { 
    this.discountCode = discountCode; 
  } 
} </pre>
<p>Once we have decorated the specific instance we need to qualify, we can use our qualifiers in the <kbd>client</kbd> code to specify the exact type of dependency we need:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.cdidependencyinjection.beans; 
 
import java.util.Random; 
import java.util.logging.Logger; 
import javax.enterprise.context.RequestScoped; 
import javax.inject.Inject; 
import javax.inject.Named; 
import net.ensode.javaee8book.cdidependencyinjection.qualifiers.Premium; 
 
@Named 
@RequestScoped 
public class CustomerController { 
 
  private static final Logger logger = Logger.getLogger( 
      CustomerController.class.getName()); 
 <strong> @Inject  
  @Premium 
  private Customer customer;</strong> 
 
  public String saveCustomer() { 
 
    PremiumCustomer premiumCustomer = (PremiumCustomer) customer; 
 
    premiumCustomer.setDiscountCode(generateDiscountCode()); 
 
    logger.info("Saving the following information \n" 
        + premiumCustomer.getFirstName() + " " 
        + premiumCustomer.getLastName() 
        + ", discount code = " 
        + premiumCustomer.getDiscountCode()); 
 
    //If this was a real application, we would have code to save 
    //customer data to the database here. 
     
    return "confirmation"; 
  } 
 
  public Integer generateDiscountCode() { 
    return new Random().nextInt(100000); 
  } 
} </pre>
<p>Since we used our <kbd>@Premium</kbd> qualifier to decorate the customer field, an instance of <kbd>PremiumCustomer</kbd> is injected into that field, as this class is also decorated with the <kbd>@Premium</kbd> qualifier.</p>
<p>As far as our JSF pages go, we simply access our named bean as usual, using its name:</p>
<pre style="padding-left: 60px">&lt;?xml version='1.0' encoding='UTF-8' ?&gt; 
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; 
&lt;html  
      &gt; 
    &lt;h:head&gt; 
        &lt;title&gt;Enter Customer Information&lt;/title&gt; 
    &lt;/h:head&gt; 
    &lt;h:body&gt; 
        &lt;h:form&gt; 
            &lt;h:panelGrid columns="2"&gt; 
                &lt;h:outputLabel for="firstName" value="First Name"/&gt; 
                &lt;h:inputText id="firstName" 
                   value="#{premiumCustomer.firstName}"/&gt; 
                &lt;h:outputLabel for="lastName" value="Last Name"/&gt; 
                &lt;h:inputText id="lastName"           
                   value="#{premiumCustomer.lastName}"/&gt; 
                &lt;h:outputLabel for="discountCode" value="Discount     <br/>                 Code"/&gt; 
                &lt;h:inputText id="discountCode" 
                   value="#{premiumCustomer.discountCode}"/&gt; 
                &lt;h:panelGroup/&gt; 
                &lt;h:commandButton value="Submit" 
                  action="#{customerController.saveCustomer}"/&gt; 
            &lt;/h:panelGrid&gt; 
        &lt;/h:form&gt; 
    &lt;/h:body&gt; 
&lt;/html&gt; </pre>
<p>In this example, we are using the default name for our bean, which is the class name with the first letter switched to lowercase.</p>
<p>Our simple application renders and acts just like a "plain" JSF application, as far as the user is concerned:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/fcb8f159-b667-4101-9b0a-4d8d42b453ff.png" style="width:17.83em;height:14.50em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Named bean scopes</h1>
                </header>
            
            <article>
                
<p>Just like JSF managed beans, CDI named beans are scoped. This means that CDI beans are contextual objects. When a named bean is needed, either because of injection or because it is referred from a JSF page, CDI looks for an instance of the bean in the scope it belongs to and injects it into the dependent code. If no instance is found, one is created and stored in the appropriate scope for future use. The different scopes are the context in which the bean exists.</p>
<p>The following table lists the different valid CDI scopes:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Scope</strong></p>
</td>
<td>
<p><strong>Annotation</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p>Request</p>
</td>
<td>
<p><kbd>@RequestScoped</kbd></p>
</td>
<td>
<p>request-scoped beans are shared through the duration of a single request. A single request could refer to an HTTP request, an invocation to a method in an EJB, a web service invocation, or sending a JMS message to a message-driven bean.</p>
</td>
</tr>
<tr>
<td>
<p>Conversation</p>
</td>
<td>
<p><kbd>@ConversationScoped</kbd></p>
</td>
<td>
<p>The conversation scope can span multiple requests but is typically shorter than the session scope.</p>
</td>
</tr>
<tr>
<td>
<p>Session</p>
</td>
<td>
<p><kbd>@SessionScoped</kbd></p>
</td>
<td>
<p>session-scoped beans <span>are shared across</span> all requests in an HTTP session. Each user of an application gets their own instance of a session scoped bean.</p>
</td>
</tr>
<tr>
<td>
<p>Application</p>
</td>
<td>
<p><kbd>@ApplicationScoped</kbd></p>
</td>
<td>
<p>application-scoped beans live through the whole application lifetime. Beans in this scope are shared across user sessions.</p>
</td>
</tr>
<tr>
<td>
<p>Dependent</p>
</td>
<td>
<p><kbd>@Dependent</kbd></p>
</td>
<td>
<p>dependent-scoped beans are not shared; any time a dependent scoped bean is injected, a new instance is created.</p>
</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>As we can see, CDI includes most scopes supported by JSF, and also adds a couple of its own. CDI's <strong>request scope</strong> differs from JSF's request scope, in which a request does not necessarily refer to an HTTP request; it could simply be an invocation on an EJB method, a web service invocation, or sending a JMS message to a message-driven bean.</p>
<p>The <strong>conversation scope</strong> does not exist in JSF. This scope is similar to JSF's flow scope, since it is longer than the request scope but shorter than the session scope, and typically spans three or more pages. Classes wishing to access a conversation-scoped bean must have an instance of <kbd>javax.enterprise.context.Conversation</kbd> injected. At the point where we want to start the conversation, the <kbd>begin()</kbd> method must be invoked on this object. At the point where we want to end the conversation, the <kbd>end()</kbd> method must be invoked on it.</p>
<p>CDI's <strong>session scope</strong> behaves just like its JSF counterpart. The lifecycle of session-scoped beans are tied to the life of an HTTP session.</p>
<p>CDI's <strong>application scope</strong> also behaves just like the equivalent scope in JSF. Application-scoped beans are tied to the life of an application. A single instance of each application-scoped bean exists per application, which means that the same instance is accessible to all HTTP sessions.</p>
<p>Just like the conversation scope, CDI's <strong>dependent scope</strong> does not exist in JSF. New dependent scope beans are instantiated every time it is needed; usually when it is injected into a class that depends on it.</p>
<p>Suppose we wanted to have a user enter some data that would be stored in a single named bean, but that bean has several fields. Therefore, we would like to split the data entry into several pages. This is a fairly common situation and one that was not easy to handle using previous versions of Java EE (JSF 2.2 added Faces Flows to solve this problem; refer to <a href="9059bc2f-04fb-43df-a5c5-8b2cce80792e.xhtml" target="_blank">Chapter 2</a>, <em>JavaServer Faces</em> ), or the servlet API for that matter. The reason this situation was not easy to manage using those technologies is that you could either put a class in the request scope, in which case the class would be destroyed after every single request, losing its data in the process, or in the session scope, in which the class would stick around in memory long after it was needed. For cases like this, CDI's conversation scope is a good solution:</p>
<pre style="padding-left: 60px">package net.ensode..javaee8book.conversationscope.model; 
 
import java.io.Serializable; 
import javax.enterprise.context.ConversationScoped; 
import javax.inject.Named; 
import org.apache.commons.lang3.builder.ReflectionToStringBuilder; 
 
@Named 
<strong>@ConversationScoped</strong> 
public class Customer implements Serializable { 
 
    private String firstName; 
    private String middleName; 
    private String lastName; 
    private String addrLine1; 
    private String addrLine2; 
    private String addrCity; 
    private String state; 
    private String zip; 
    private String phoneHome; 
    private String phoneWork; 
    private String phoneMobile; 
 
    public String getAddrCity() { 
        return addrCity; 
    } 
 
    public void setAddrCity(String addrCity) { 
        this.addrCity = addrCity; 
    } 
 
    public String getAddrLine1() { 
        return addrLine1; 
    } 
 
    public void setAddrLine1(String addrLine1) { 
        this.addrLine1 = addrLine1; 
    } 
 
    public String getAddrLine2() { 
        return addrLine2; 
    } 
 
    public void setAddrLine2(String addrLine2) { 
        this.addrLine2 = addrLine2; 
    } 
 
    public String getFirstName() { 
        return firstName; 
    } 
 
    public void setFirstName(String firstName) { 
        this.firstName = firstName; 
    } 
 
    public String getLastName() { 
        return lastName; 
    } 
 
    public void setLastName(String lastName) { 
        this.lastName = lastName; 
    } 
 
    public String getMiddleName() { 
        return middleName; 
    } 
 
    public void setMiddleName(String middleName) { 
        this.middleName = middleName; 
    } 
 
    public String getPhoneHome() { 
        return phoneHome; 
    } 
 
    public void setPhoneHome(String phoneHome) { 
        this.phoneHome = phoneHome; 
    } 
 
    public String getPhoneMobile() { 
        return phoneMobile; 
    } 
 
    public void setPhoneMobile(String phoneMobile) { 
        this.phoneMobile = phoneMobile; 
    } 
 
    public String getPhoneWork() { 
        return phoneWork; 
    } 
 
    public void setPhoneWork(String phoneWork) { 
        this.phoneWork = phoneWork; 
    } 
 
    public String getState() { 
        return state; 
    } 
 
    public void setState(String state) { 
        this.state = state; 
    } 
 
    public String getZip() { 
        return zip; 
    } 
 
    public void setZip(String zip) { 
        this.zip = zip; 
    } 
 
    @Override 
    public String toString() { 
        return ReflectionToStringBuilder.reflectionToString(this); 
    } 
}  </pre>
<p>We declare that our bean is conversation scoped by decorating it with the <kbd>@ConversationScoped</kbd> annotation. Conversation-scoped beans also need to implement <kbd>java.io.Serializable</kbd>. Other than those two requirements, there is nothing special about our code; it is a simple JavaBean with private properties and corresponding <kbd>getter</kbd> and <kbd>setter</kbd> methods.</p>
<div class="packt_infobox">We are using the Apache <kbd>commons-lang</kbd> library in our code to easily implement a <kbd>toString()</kbd> method for our bean. <kbd>commons-lang</kbd> has several <kbd>utility</kbd> methods like this that implement frequently needed, tedious to code functionality. <kbd>commons-lang</kbd> is available in the central <kbd>Maven</kbd> repositories and at <a href="http://commons.apache.org/lang"><span class="URLPACKT">http://commons.apache.org/lang</span></a>.</div>
<p>In addition to having our conversation-scoped bean injected, our client code must also have an instance of <kbd>javax.enterprise.context.Conversation</kbd> injected, as illustrated in the following example:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.conversationscope.controller; 
 
import java.io.Serializable; 
import javax.enterprise.context.Conversation; 
import javax.enterprise.context.RequestScoped; 
import javax.inject.Inject; 
import javax.inject.Named; 
import net.ensode.javaee8book.conversationscope.model.Customer; 
 
@Named 
@RequestScoped 
public class CustomerInfoController implements Serializable { 
 
   <strong> @Inject 
    private Conversation conversation;</strong> 
    @Inject 
    private Customer customer; 
 
    public String customerInfoEntry() { 
        <strong>conversation.begin();</strong> 
        System.out.println(customer); 
        return "page1"; 
    } 
 
    public String navigateToPage1() { 
        System.out.println(customer); 
        return "page1"; 
    } 
 
    public String navigateToPage2() { 
        System.out.println(customer); 
        return "page2"; 
    } 
 
    public String navigateToPage3() { 
        System.out.println(customer); 
        return "page3"; 
    } 
 
    public String navigateToConfirmationPage() { 
        System.out.println(customer); 
      <strong>  conversation.end();</strong> 
        return "confirmation"; 
    } 
} </pre>
<p>Conversations can be either <strong>long-running</strong> or <strong>transient</strong>. Transient conversations end at the end of a request, while long-running conversations span multiple requests. In most cases, we use long-running conversations to hold a reference to a conversation-scoped bean across multiple HTTP requests in a web application.</p>
<p>A long-running conversation starts when the <kbd>begin()</kbd> method is invoked in the injected <kbd>Conversation</kbd> instance, and it ends when we invoke the <kbd>end()</kbd> method on the same object.</p>
<p>JSF pages simply access our CDI beans as usual:</p>
<pre style="padding-left: 60px">&lt;?xml version='1.0' encoding='UTF-8' ?&gt; 
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; 
&lt;html  
      &gt; 
    &lt;h:head&gt; 
        &lt;title&gt;Customer Information&lt;/title&gt; 
    &lt;/h:head&gt; 
    &lt;h:body&gt; 
        &lt;h3&gt;Enter Customer Information (Page 1 of 3)&lt;/h3&gt; 
        &lt;h:form&gt; 
            &lt;h:panelGrid columns="2"&gt; 
                &lt;h:outputLabel for="firstName" value="First Name"/&gt; 
                &lt;h:inputText id="firstName" value="#<br/>                 {customer.firstName}"/&gt; 
                &lt;h:outputLabel for="middleName" value="Middle  <br/>                 Name"/&gt; 
                &lt;h:inputText id="middleName" value="#  <br/>                 {customer.middleName}"/&gt; 
                &lt;h:outputLabel for="lastName" value="Last Name"/&gt; 
                &lt;h:inputText id="lastName" value="# <br/>                 {customer.lastName}"/&gt; 
                &lt;h:panelGroup/&gt; 
                &lt;h:commandButton value="Next"  
                action="#<br/>                {customerInfoController.navigateToPage2}"/&gt; 
            &lt;/h:panelGrid&gt; 
        &lt;/h:form&gt; 
    &lt;/h:body&gt; 
&lt;/html&gt; </pre>
<p>As we navigate from one page to the next, we keep the same instance of our conversation-scoped bean; therefore, all user entered data remains. When the <kbd>end()</kbd> method is called on our conversation bean, the conversation ends and our conversation-scoped bean is destroyed.</p>
<p>Keeping our bean in the conversation scope simplifies the task of implementing <em>wizard-style</em> user interfaces, where data can be entered across several pages:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/f71e195a-79d1-4843-936e-68d055e382bb.png" style="width:29.25em;height:19.33em;"/></div>
<p>In our example, after clicking the <span class="packt_screen">Next</span> button on the first page, we can see our partially populated bean in the application server log:</p>
<pre style="padding-left: 60px">INFO: net.ensode..javaee8book.conversationscope.model.Customer@6e1c51b4[firstName=Daniel,middleName=,lastName=Jones,addrLine1=,addrLine2=,addrCity=,state=AL,zip=&lt;null&gt;,phoneHome=&lt;null&gt;,phoneWork=&lt;null&gt;,phoneMobile=&lt;null&gt;] </pre>
<p>At this point, the second page in our simple wizard is displayed:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5af93b45-060c-46d6-933e-8ab3f3a15e55.png" style="width:24.83em;height:20.42em;"/></div>
<p>When we click <span class="packt_screen">Next</span>, we can see that additional fields are populated in our conversation-scoped bean:</p>
<pre style="padding-left: 60px">INFO: net.ensode.javaee8book.conversationscope.model.Customer@6e1c51b4[firstName=Daniel,middleName=,lastName=Jones,addrLine1=123 Basketball Ct,addrLine2=,addrCity=Montgomery,state=AL,zip=36101,phoneHome=&lt;null&gt;,phoneWork=&lt;null&gt;,phoneMobile=&lt;null&gt;] </pre>
<p>When we submit the third page in our wizard (not shown), additional bean properties corresponding to the fields on that page are populated.</p>
<p>When we are at the point where we don't need to keep the customer information in memory anymore, we need to call the <kbd>end()</kbd> method on the <kbd>Conversation</kbd> bean that was injected into our code. This is exactly what we do in our code before displaying the confirmation page:</p>
<pre style="padding-left: 60px">public String navigateToConfirmationPage() { 
        System.out.println(customer); 
       <strong> conversation.end();</strong> 
        return "confirmation"; 
    } </pre>
<p>After the request to show the confirmation page is completed, our conversation-scoped bean is destroyed, since we invoked the <kbd>end()</kbd> method in our injected <kbd>Conversation</kbd> class.</p>
<p>We should note that, since the conversation, scope requires an instance of <kbd>javax.enterprise.context.Conversation</kbd> to be injected, this scope requires that the action in the command button or link used to navigate between pages be an expression resolving to a named bean method. Using static navigation won't work, since the <kbd>Conversation</kbd> instance won't be injected anywhere.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CDI events</h1>
                </header>
            
            <article>
                
<p>CDI provides event handling facilities. Events allow loosely-coupled communication between different CDI beans. A CDI bean can fire an event, then one or more event listeners handle the event.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Firing CDI events</h1>
                </header>
            
            <article>
                
<p>The following example is a new version of the <kbd>CustomerInfoController</kbd> class we discussed in the previous section. The class has been modified to fire an event every time the user navigates to a new page:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.cdievents.controller; 
 
import java.io.Serializable; 
import javax.enterprise.context.Conversation; 
import javax.enterprise.context.RequestScoped; 
import <a>javax.enterprise.event.Event;</a> 
import javax.inject.Inject; 
import javax.inject.Named; 
import net.ensode.javaee8book.cdievents.event.NavigationInfo; 
import net.ensode.javaee8book.cdievents.model.Customer; 
 
@Named 
@RequestScoped 
public class CustomerInfoController implements Serializable { 
 
    @Inject 
    private Conversation conversation; 
    @Inject 
    private Customer customer; 
   <strong> @Inject 
    private Event&lt;NavigationInfo&gt; navigationInfoEvent;</strong> 
 
    public String customerInfoEntry() { 
        conversation.begin(); 
        NavigationInfo navigationInfo = new NavigationInfo(); 
        navigationInfo.setPage("1"); 
        navigationInfo.setCustomer(customer); 
 
       <strong> navigationInfoEvent.fire(navigationInfo);</strong> 
        return "page1"; 
    } 
 
    public String navigateToPage1() { 
        NavigationInfo navigationInfo = new NavigationInfo(); 
        navigationInfo.setPage("1"); 
        navigationInfo.setCustomer(customer); 
 
      <strong>  navigationInfoEvent.fire(navigationInfo);</strong> 
 
        return "page1"; 
    } 
 
    public String navigateToPage2() { 
        NavigationInfo navigationInfo = new NavigationInfo(); 
        navigationInfo.setPage("2"); 
        navigationInfo.setCustomer(customer); 
 
       <strong> navigationInfoEvent.fire(navigationInfo);</strong> 
        return "page2"; 
    } 
 
    public String navigateToPage3() { 
        NavigationInfo navigationInfo = new NavigationInfo(); 
        navigationInfo.setPage("3"); 
        navigationInfo.setCustomer(customer); 
 
      <strong>  navigationInfoEvent.fire(navigationInfo);</strong> 
        return "page3"; 
    } 
 
    public String navigateToConfirmationPage() { 
        NavigationInfo navigationInfo = new NavigationInfo(); 
        navigationInfo.setPage("confirmation"); 
        navigationInfo.setCustomer(customer); 
 <strong>
        navigationInfoEvent.fire(navigationInfo);</strong> 
        conversation.end(); 
        return "confirmation"; 
    } 
} </pre>
<p>As we can see, to create an event, we inject an instance of <kbd>javax.enterprise.event.Event</kbd>. This class uses generics, therefore, we need to specify its type; the type of the <kbd>Event</kbd> class can be any class implementing <kbd>java.io.Serializable</kbd>. In our case, we are passing an instance of a simple POJO we wrote as the type parameter. Our POJO is called <kbd>NavigationInfo</kbd> and has two properties: one <kbd>Customer</kbd>type, and a <kbd>String</kbd> containing the page the user is navigating to. Recall from the previous sections that each of the methods on our <kbd>CustomerInfoController</kbd> class triggers navigation from one page in the application to another. In this version of the controller, a CDI event is fired every time we navigate to a new page. In each case, we create a new instance of <kbd>NavigationInfo</kbd>, populate it, then fire the event by invoking the <kbd>fire()</kbd> method on our instance of <kbd>javax.enterprise.event.Event</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling CDI events</h1>
                </header>
            
            <article>
                
<p>To handle CDI events, the CDI bean handling the event needs to implement an <kbd>observer</kbd> method. The <kbd>observer</kbd> method accepts a parameter of the type that was used to fire the event, that is, the generic type used to create the event that was fired. In our example, the generic type of our event is an instance of a class named <kbd>NavigationInfo</kbd>, as can be seen in the declaration of our event in the preceding section. To handle the event, the observer method needs to annotate the corresponding parameter with the <kbd>@Observes</kbd> annotation, as illustrated in the following example:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.cdievents.eventlistener; 
 
import java.io.Serializable; 
import javax.enterprise.context.SessionScoped; 
import javax.enterprise.event.Observes; 
import net.ensode.javaee8book.cdievents.event.NavigationInfo; 
 
@SessionScoped 
public class NavigationEventListener implements Serializable { 
 
    public void handleNavigationEvent(<br/>         <strong>@Observes NavigationInfo navigationInfo) {</strong> 
        System.out.println("Navigation event fired"); 
        System.out.println("Page: " + navigationInfo.getPage()); 
        System.out.println("Customer: " +                     <br/>         navigationInfo.getCustomer()); 
    } 
} </pre>
<p>In this example event handler, the <kbd>handleNavigationEvent()</kbd> method takes an instance of <kbd>NavigationInfo</kbd> as a parameter. Notice that this parameter is annotated with <kbd>@Observes</kbd>; this causes the method to be invoked automatically by CDI every time a <kbd>NavigationInfo</kbd> type event is fired.</p>
<div class="packt_infobox">In our example, we have only one event listener, but in practice, we can have as many event listeners as we need.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asynchronous events</h1>
                </header>
            
            <article>
                
<p>CDI 2.0 introduced the ability to fire events asynchronously. Firing events asynchronously can help with performance, since various observer methods can be invoked concurrently. Firing an event asynchronously is very similar to firing an event synchronously, the only difference is that, instead of invoking the <kbd>fire()</kbd> method in our <kbd>Event</kbd> instance, we invoke its <kbd>fireAsync()</kbd> method. The following example illustrates how to do this:</p>
<pre style="padding-left: 60px">public class EventSource{ 
  @Inject Event&lt;MyEvent&gt; myEvent; 
  public void fireEvent(){ 
   <strong> myEvent.fireAsync(myEvent); </strong>
  } 
} </pre>
<p>Observer methods to handle asynchronous events are identical to their synchronous counterparts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Event ordering</h1>
                </header>
            
            <article>
                
<p>Another new feature introduced in CDI 2.0 is the ability to specify in which order our <kbd>observer</kbd> methods handle CDI events. This can be accomplished via the <kbd>@Priority</kbd> annotation, as illustrated in the following example:</p>
<pre style="padding-left: 60px">import javax.annotation.Priority; 
import javax.enterprise.context.SessionScoped; 
import javax.enterprise.event.Observes; 
import javax.interceptor.Interceptor; 
 
@SessionScoped 
public class EventHandler{ 
    void handleIt (<br/>      <strong>@Observes @Priority(Interceptor.Priority.APPLICATION)<br/>       MyEvent me){</strong> 
    //handle the event 
  } 
} </pre>
<p>The <kbd>@Priority</kbd> annotation takes an argument of type <kbd>int</kbd>. This argument specifies the priority for the <kbd>observer</kbd> method. The highest priority is defined by the <kbd>APPLICATION</kbd> constant defined in the <kbd>Interceptor.Priority</kbd> class. This is the priority we gave to the <kbd>observer</kbd> method in our example. Lower priority values take precedence; the default priority is <kbd>Interceptor.Priority.APPLICATION + 100</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we provided an introduction to Contexts and Dependency Injection (CDI). We covered how JSF pages can access CDI named beans as if they were JSF managed beans. We also covered how CDI makes it easy to inject dependencies into our code via the <kbd>@Inject</kbd> annotation. Additionally, we explained how we can use qualifiers to determine which specific implementation of a dependency to inject into our code. Finally, we covered all the scopes that a CDI bean can be placed into, which include equivalents to all the JSF scopes, plus an additional two not included in JSF, namely, the conversation scope and the dependent scope.</p>


            </article>

            
        </section>
    </body></html>