["```java\ntrait Semigroup[S] {\n def op(l: S, r: S): S\n}\n```", "```java\nimport org.scalacheck._\nimport org.scalacheck.Prop._\ndef associativity[S : Semigroup : Arbitrary]: Prop =\n  forAll((a: S, b: S, c: S) => {\n    val sg = implicitly[Semigroup[S]]\n    sg.op(sg.op(a, b), c) == sg.op(a, sg.op(b, c))\n  })\n```", "```java\nfinal case class Fish(volume: Int, size: Int, teeth: Int, poisonousness: Int)\n```", "```java\nimplicit val volumeSemigroup: Semigroup[Fish] = (l: Fish, r: Fish) => {\n  val result = if (l.volume >= r.volume) l else r\n  result.copy(volume = r.volume + l.volume)\n}\n```", "```java\nval fishGen: Gen[Fish] = for {\n  weight <- Gen.posNum[Int]\n  volume <- Gen.posNum[Int]\n  poisonousness <- Gen.posNum[Int]\n  teeth <- Gen.posNum[Int]\n} yield Fish(volume, weight, teeth, poisonousness)\n\nimplicit val arbFish: Arbitrary[Fish] = Arbitrary(fishGen)\n```", "```java\nproperty(\"associativity for fish semigroup under 'big eats little'\") = {\n  associativity[Fish]\n}\n```", "```java\nscala> associativity[Fish]\nres1: org.scalacheck.Prop = Prop\nscala> .check\n! Falsified after 3 passed tests.\n> ARG_0: Fish(2,3,2,1)\n> ARG_1: Fish(2,3,3,3)\n> ARG_2: Fish(3,2,3,2)\n```", "```java\nfinal case class Fish(volume: Int, weight: Int, teeth: Int, poisonousness: Int) {\n  def eat(f: Fish): Fish = Fish(volume + f.volume, weight + f.weight, teeth + f.teeth, poisonousness + f.poisonousness)\n}\n```", "```java\nimplicit val volumeSemigroup: Semigroup[Fish] = (l: Fish, r: Fish) =>\n  if (l.volume > r.volume) l.eat(r) else r.eat(l)\n```", "```java\nscala> associativity[Fish]\nres10: org.scalacheck.Prop = Prop\nscala> .check\n+ OK, passed 100 tests.\n```", "```java\nimplicit val weightSemigroup: Semigroup[Fish] = (l: Fish, r: Fish) =>\n  if (l.weight > r.weight) l.eat(r) else r.eat(l)\n\nimplicit val poisonSemigroup: Semigroup[Fish] = (l: Fish, r: Fish) =>\n if (l.poisonousness > r.poisonousness) l else r\n\nimplicit val teethSemigroup: Semigroup[Fish] = (l: Fish, r: Fish) =>\n if (l.teeth > r.teeth) l else r\n```", "```java\nimplicit val intAddition: Semigroup[Int] = (l: Int, r: Int) => l + r\nimplicit val intMultiplication: Semigroup[Int] = (l: Int, r: Int) => l * r\n\nproperty(\"associativity for int under addition\") = {\n  import Semigroup.intAddition\n  associativity[Int]\n}\nproperty(\"associativity for int under multiplication\") = {\n  import Semigroup.intMultiplication\n  associativity[Int]\n}\n```", "```java\n+ Semigroup.associativity for int under addition: OK, passed 100 tests.\n+ Semigroup.associativity for int under multiplication: OK, passed 100 tests.\n```", "```java\nimplicit val stringConcatenation: Semigroup[String] = \n  (l: String, r: String) => l + r\n\nproperty(\"associativity for strings under concatenation\") = {\n  import Semigroup.stringConcatenation\n  associativity[String]\n}\n```", "```java\ntrait Monoid[S] extends Semigroup[S] {\n  def identity: S\n}\n```", "```java\ndef identity[S : Monoid : Arbitrary]: Prop =\n  forAll((a: S) => {\n    val m = implicitly[Monoid[S]]\n    m.op(a, m.identity) == a && m.op(m.identity, a) == a\n  })\n\ndef monoidProp[S : Monoid : Arbitrary]: Prop = associativity[S] && identity[S]\n```", "```java\ntype Bucket[S] = List[S]\n\nimplicit val mergeBuckets: Monoid[Bucket[Fish]] = new Monoid[Bucket[Fish]] {\n  override def identity: Bucket[Fish] = List.empty[Fish]\n  override def op(l: Bucket[Fish], r: Bucket[Fish]): Bucket[Fish] = l ++ r\n}\n```", "```java\nimplicit val arbBucketOfFish: Arbitrary[Bucket[Fish]] = Arbitrary(Gen.listOf(fishGen))\n\nproperty(\"bucket of fish monoid\") = {\n  import Monoid.mergeBuckets\n  monoidProp[Bucket[Fish]]\n}\n```", "```java\nscala> implicit val arbBucketOfFish: Arbitrary[Bucket[Fish]] = Arbitrary(Gen.listOf(fishGen))\narbBucketOfFish: org.scalacheck.Arbitrary[Monoid.Bucket[Fish]] = org.scalacheck.ArbitraryLowPriority$$anon$1@3dd73a3d\nscala> monoidProp[Bucket[Fish]]\nres13: org.scalacheck.Prop = Prop\nscala> .check\n+ OK, passed 100 tests.\n```", "```java\nimplicit val intAddition: Monoid[Int] = new Monoid[Int] {\n  override def identity: Int = 0\n  override def op(l: Int, r: Int): Int = l + r\n}\n\nimplicit val intMultiplication: Monoid[Int] = new Monoid[Int] {\n  override def identity: Int = 1\n  override def op(l: Int, r: Int): Int = l * r\n}\n```", "```java\nimplicit val stringConcatenation: Monoid[String] = new Monoid[String] {\n  override def identity: String = \"\"\n  override def op(l: String, r: String): String = l + r\n}\n```", "```java\nval ZeroFish = Fish(0,0,0,0)\n\nimplicit val weightMonoid: Monoid[Fish] = new Monoid[Fish] {\n  override def identity: Fish = ZeroFish\n  override def op(l: Fish, r: Fish): Fish =\n    if (l.weight > r.weight) l.eat(r) else r.eat(l)\n}\n```", "```java\nimplicit def surviveInTheBucket(implicit m: Monoid[Fish]): Monoid[Bucket[Fish]] =\n  new Monoid[Bucket[Fish]] {\n    override def identity: Bucket[Fish] = List.fill(100)(ZeroFish)\n    override def op(l: Bucket[Fish], r: Bucket[Fish]): Bucket[Fish] = {\n      val operation = (m.op _).tupled\n      l zip r map operation\n    }\n  }\n```", "```java\nproperty(\"props for survival in the bucket for most poisonousness\") = {\n  import Monoid.poisonMonoid\n  import Monoid.surviveInTheBucket\n  monoidProps[Bucket[Fish]]\n}\n```", "```java\nscala> {\n     | import ch07.Monoid.weightMonoid\n     | import ch07.Monoid.surviveInTheBucket\n     | monoidProp[Bucket[Fish]]\n     | }\nres3: org.scalacheck.Prop = Prop\n\nscala> .check\n+ OK, passed 100 tests.\n```", "```java\ndef reduce[B >: A](op: (B, B) => B): B\n```", "```java\nscala> val bucketOfFishGen: Gen[List[Fish]] = Gen.listOf(fishGen)\nbucketOfFishGen: org.scalacheck.Gen[List[Fish]] = org.scalacheck.Gen$$anon$1@34d69633\n\nscala> val bucket = bucketOfFishGen.sample.get\nbucket: List[Fish] = List(Fish(98,44,11,22), Fish(69,15,57,18), ...\n\nscala> bucket.reduce(poisonSemigroup.op)\nres7: Fish = Fish(25,6,29,99)\n```", "```java\nscala> List.empty[Fish].reduce(poisonSemigroup.op)\njava.lang.UnsupportedOperationException: empty.reduceLeft\n  at scala.collection.IterableOnceOps.reduceLeft(IterableOnce.scala:527)\n  at scala.collection.IterableOnceOps.reduceLeft$(IterableOnce.scala:524)\n  at scala.collection.AbstractIterable.reduceLeft(Iterable.scala:759)\n  at scala.collection.IterableOnceOps.reduce(IterableOnce.scala:496)\n  at scala.collection.IterableOnceOps.reduce$(IterableOnce.scala:496)\n  at scala.collection.AbstractIterable.reduce(Iterable.scala:759)\n  ... 40 elided\n```", "```java\ntrait Reducible[A] {\n\n  @throws(\"UnsupportedOperationException \")\n  def reduceLeft(op: (A, A) => A): A\n\n  @throws(\"UnsupportedOperationException \")\n  def reduceRight(op: (A, A) => A): A\n\n  @throws(\"UnsupportedOperationException \")\n  def reduce(op: (A, A) => A): A = reduceLeft(op)\n\n  def reduceLeftOption(op: (A, A) => A): Option[A]\n\n  def reduceRightOption(op: (A, A) => A): Option[A]\n\n  def reduceOption(op: (A, A) => A): Option[A] = reduceLeftOption(op)\n\n}\n```", "```java\n  def reduceLeft(op: (A, A) => A): A\n\n```", "```java\n  def foldLeft(identity: A)(op: (A, A) => A): A\n\n```", "```java\nop(op(op(op(identity, a1), a2), a3), a4), ...\n```", "```java\n(((identity op a1) op a2) op a3) ...\n```", "```java\n(a1 op (a2 op (a3 op identity))) ...\n```", "```java\n def foldRight(identity: A)(op: (A, A) => A): A\n```", "```java\n(a1 op (a2 op identity)) op ((a3 op identity) op a4)\n```", "```java\n\ntrait MonoidFoldable[A, F[_]] {\n  def foldRight(as: F[A])(i: A, op: (A,A) => A): A\n  def foldLeft(as: F[A])(i: A, op: (A,A) => A): A\n  def foldBalanced(as: F[A])(i: A, op: (A,A) => A): A\n}\n```", "```java\nimplicit def listMonoidFoldable[A : Monoid]: MonoidFoldable[A, List] = new MonoidFoldable[A, List] {\n  private val m = implicitly[Monoid[A]]\n  override def foldRight(as: List[A])(i: A, op: (A, A) => A): A = as.foldRight(m.identity)(m.op)\n\n  override def foldLeft(as: List[A])(i: A, op: (A, A) => A): A = as.foldLeft(m.identity)(m.op)\n\n  override def foldBalanced(as: List[A])(i: A, op: (A, A) => A): A = as match {\n    case Nil => m.identity\n    case List(one) => one\n    case _ => val (l, r) = as.splitAt(as.length/2)\n      m.op(foldBalanced(l)(m.identity, m.op), foldBalanced(r)(m.identity, m.op))\n  }\n}\n```", "```java\ndef foldPar(as: F[A])(i: A, op: (A,A) => A)(implicit ec: ExecutionContext): A\n```", "```java\nprivate val parallelLimit = 8\noverride def foldPar(as: List[A])(i: A, op: (A, A) => A)(implicit ec: ExecutionContext): Future[A] = {\n  if (as.length < parallelLimit) Future(foldBalanced(as)(i, op))\n  else {\n    val (l, r) = as.splitAt(as.length/2)\n    Future.reduceLeft(List(foldPar(l)(m.identity, m.op), foldPar(r)(m.identity, m.op)))(m.op)\n  }\n}\n```", "```java\nimplicit val slowPoisonMonoid: Monoid[Fish] = new Monoid[Fish] {\n  override def identity: Fish = ZeroFish\n  override def op(l: Fish, r: Fish): Fish = {\n    Thread.sleep(1)\n    if (l.poisonousness > r.poisonousness) l else r\n  }\n}\n```", "```java\nval bucketOfFishGen: Gen[List[Fish]] = for {\n  n <- Gen.choose(100, 1000)\n  gen <- Gen.listOfN(n, fishGen)\n} yield gen\n\nimplicit val arbBucketOfFish: Arbitrary[Bucket[Fish]] = Arbitrary(bucketOfFishGen)\n```", "```java\ndef withTime(block: => Fish): (Fish, Long) = {\n  val start = System.nanoTime()\n  val result = block\n  (result, (System.nanoTime() - start) / 1000000)\n}\n```", "```java\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n```", "```java\nproperty(\"foldPar is the quickest way to fold a list\") = {\n  import Monoid.slowPoisonMonoid\n  val foldable = MonoidFoldable.listMonoidFoldable[Fish]\n\n  forAllNoShrink((as: Bucket[Fish]) => {\n       ...\n    })\n  }\n```", "```java\nval (left, leftRuntime) = withTime(foldable.foldLeft(as))\nval (right, rightRuntime) = withTime(foldable.foldRight(as))\nval (balanced, balancedRuntime) = withTime(foldable.foldBalanced(as))\nval (parallel, parallelRuntime) = withTime(Await.result(foldable.foldPar(as), 5.seconds))\n```", "```java\n  s\"${as.size} fishes: $leftRuntime, $rightRuntime, $balancedRuntime, $parallelRuntime millis\" |: all(\n    \"all results are equal\" |: all(left == right, left == balanced, left == parallel),\n    \"parallel is quickest\" |: parallelRuntime <= List(leftRuntime, rightRuntime, balancedRuntime).min\n  )\n})\n```", "```java\n+ MonoidFoldable.foldPar is the quickest way to fold a list: OK, passed 100 tests.\n```", "```java\n(((identity op a1) op a2) op a3) ...\n```", "```java\ntrait Foldable[F[_]] {\n  def foldLeft[A,B](as: F[A])(z: B)(f: (B, A) => B): B\n  def foldRight[A,B](as: F[A])(z: B)(f: (A, B) => B): B\n}\n```", "```java\n  def foldMap[A,B : Monoid](as: F[A])(f: A => B): B = {\n    val m = implicitly[Monoid[B]]\n    foldLeft(as)(m.identity)((b, a) => m.op(f(a), b))\n  }\n```", "```java\ntrait Group[S] extends Monoid[S] {\n  def inverse(a: S): S\n}\n```", "```java\ndef invertibility[S : Group : Arbitrary]: Prop =\n  forAll((a: S) => {\n    val m = implicitly[Group[S]]\n    m.op(a, m.inverse(a)) == m.identity && m.op(m.inverse(a), a) == m.identity\n  })\n```", "```java\ndef groupProp[S : Group: Arbitrary]: Prop = monoidProp[S] && invertibility[S]\n```", "```java\ndef commutativity[S : Group : Arbitrary]: Prop =\n  forAll((a: S, b: S) => {\n    val m = implicitly[Group[S]]\n    m.op(a, b) == m.op(b, a)\n  })\n\ndef abelianGroupProp[S : Group: Arbitrary]: Prop = \n  groupProp[S] && commutativity[S]\n```", "```java\nimplicit val intAddition: Group[Int] = new Group[Int] {\n override def identity: Int = 0\n override def op(l: Int, r: Int): Int = l + r\n override def inverse(a: Int): Int = identity - a\n}\n```", "```java\nproperty(\"ints under addition form a group\") = {\n  import Group.intAddition\n  groupProp[Int]\n}\n\nproperty(\"ints under addition form an abelian group\") = {\n  import Group.intAddition\n  groupProp[Int]\n}\n```"]