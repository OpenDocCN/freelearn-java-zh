- en: Building a Reactive Web Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建响应式 Web 应用程序
- en: 'We began our journey by exploring some of the basics of the Spring Framework
    and its module system in [Chapter 1](87add83e-e65b-4b58-9ef1-113ad157a51a.xhtml), *Creating
    an Application to List World Countries with their GDP*. Let''s leave all the new
    and advanced topics of Spring Framework for now and, in this chapter, look at
    one of the most popular topics: how to make highly scalable and responsive applications
    by adopting a reactive paradigm.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一章中通过探索 Spring 框架及其模块系统的一些基础知识开始了我们的旅程，[第一章](87add83e-e65b-4b58-9ef1-113ad157a51a.xhtml)，“创建一个列出世界国家和其
    GDP 的应用程序”。现在，让我们暂时放下 Spring 框架的所有新和高级主题，在本章中，我们将探讨最受欢迎的主题之一：通过采用响应式范式来创建高度可扩展和响应式的应用程序。
- en: The world of technology is migrating from blocking, synchronous, and thread-driven
    implementation to non-blocking, asynchronous, and event-based systems, which are resilient
    and capable of managing a very large volume of data with a consistent response
    time. This is the core concern addressed by a reactive system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 技术世界正在从阻塞、同步和线程驱动实现迁移到非阻塞、异步和基于事件的系统，这些系统具有弹性，能够以一致的反应时间管理非常大的数据量。这是响应式系统解决的核心问题。
- en: From the perspective of the programming model, Reactive Programming has influenced
    the paradigm shift from an imperative style to a declarative composition of asynchronous
    logic. Spring Framework did this by incorporating Reactive Streams capabilities
    into its core framework from version 5.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从编程模型的角度来看，响应式编程影响了从命令式风格到异步逻辑声明式组合的范式转变。Spring 框架通过从版本 5 开始将响应式流的能力纳入其核心框架来实现这一点。
- en: 'In this chapter, we will discuss and explore Reactive Programming from various
    dimensions and angles with the following exciting topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从以下令人兴奋的维度和角度讨论和探索响应式编程：
- en: What is a reactive system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是响应式系统
- en: Introduction to Reactive programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程简介
- en: Reactive Programming basics, benefits, and features
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程的基本知识、优势和特性
- en: Reactive Programming in Java
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 中的响应式编程
- en: Introduction to WebFlux
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebFlux 简介
- en: Spring supports for Reactive Programming
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 对响应式编程的支持
- en: A functional way of working in Reactive Programming with WebFlux
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 WebFlux 在响应式编程中的函数式工作方式
- en: WebSocket support in a reactive paradigm
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式范式中的 WebSocket 支持
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter02](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter02).
    The code can be executed on any operating system, although it has only been tested
    on Windows.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有代码都可以从以下 GitHub 链接下载：[https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter02](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter02)。代码可以在任何操作系统上执行，尽管它只在
    Windows 上进行了测试。
- en: Reactive system
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式系统
- en: The word reactive has become popular today and has different meanings for different
    people, such as lightweight, real time, asynchronous, streaming, and so on. **Reactive**,
    in broader terms, refers to a set of design techniques or principles, and is a
    way to consider the system architecture in a distributed environment. It comprises
    tooling, design methodologies, and implementation procedures.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: “响应式”这个词今天很流行，对不同的人有不同的含义，如轻量级、实时、异步、流式等。在更广泛的意义上，“响应式”指的是一系列设计技术或原则，是一种在分布式环境中考虑系统架构的方式。它包括工具、设计方法和实施程序。
- en: 'The analogy of a team can be used to describe a reactive system: individual
    players working with each other to achieve a desired goal. The interaction between
    the components is the main quality that differentiates a Reactive System from
    other systems. Components can operate individually or still work in harmony with
    others to achieve the intended result as a whole system. In other words, it is
    the system design that allows individual sub-applications to form a single logical
    system, perform specific tasks, and remain aware of each other. This enables decision-making,
    like load balancing, scaling up and down, failover mitigation, and so on.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用团队的类比来描述响应式系统：个人球员相互协作以实现一个期望的目标。组件之间的交互是区分响应式系统与其他系统的主要质量。组件可以单独操作，或者仍然与其他组件和谐工作，作为一个整体系统实现预期的结果。换句话说，这是系统设计允许单个子应用程序形成一个单一逻辑系统，执行特定任务，并相互保持意识。这使得决策成为可能，如负载均衡、扩展和缩减、故障转移缓解等。
- en: While talking about reactive topics, mainly in the context of software design
    and development, people generally use the terms **Reactive System** and **Reactive
    Programming** interchangeably, although they are not exactly the same. A reactive
    system is message-driven and associated with distributed process communication
    over the network, whereas Reactive Programming is generally event driven and handled
    locally.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论反应式主题时，主要在软件设计和开发的背景下，人们通常将术语**反应式系统**和**反应式编程**互换使用，尽管它们并不完全相同。反应式系统是消息驱动的，与网络上的分布式进程通信相关联，而反应式编程通常是事件驱动的，并在本地处理。
- en: 'A Reactive System is considered to be the same as an asynchronous message-based
    system by many software engineers. But as per the reactive manifesto, the Reactive
    System is an architectural way of developing a distributed system in a responsive
    style. It has the following essential characteristics:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件工程师认为反应式系统与基于异步消息的系统相同。但根据反应式宣言，反应式系统是一种以响应式风格开发分布式系统的架构方式。它具有以下基本特性：
- en: '**Responsive:** It suggests a system should process and respond to a request
    in a reasonable time.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应性**：它表明系统应在合理的时间内处理和响应用户请求。'
- en: '**Resilient:** It suggests that even in case of failure, the system should
    remain responsive. In short, any kind of error should not put a system in a non-responsive
    state. All possible factors that may cause a system error must be well handled
    without causing a system halt.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：它表明即使在出现故障的情况下，系统也应保持响应。简而言之，任何类型的错误都不应使系统进入非响应状态。所有可能引起系统错误的所有因素都必须得到妥善处理，而不会导致系统停止。'
- en: '**Elastic:** A system should stay responsive even with a variable load. It
    should be flexible to scale up and down based on the load, and handle it with
    reasonable resource usage. To achieve this, the application must be designed in
    a way to avoid any central bottleneck.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：系统即使在可变负载下也应保持响应。它应根据负载灵活地扩展和缩减，并以合理的资源使用来处理它。为了实现这一点，应用程序必须设计成避免任何中央瓶颈。'
- en: '**Message-driven:** Components within a Reactive System should interact with
    each other with asynchronous message passing. This brings a loose coupling between
    components, isolation in responsibility, and transparency in location.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息驱动**：反应式系统内的组件应通过异步消息传递相互交互。这带来了组件之间的松散耦合、责任隔离和位置透明性。'
- en: Among these characteristics, responsiveness, resilience, and elasticity are
    the standard requirements for almost every real-world application today. They
    look simple and straightforward, but are tricky to implement. It is the message-driven
    requirement that distinguishes a responsive system from others.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些特性中，响应性、弹性和可伸缩性是今天几乎所有现实世界应用的标准要求。它们看起来简单直接，但实现起来却很棘手。正是消息驱动的需求将响应式系统与其他系统区分开来。
- en: A Reactive System uses an asynchronous message-passing mechanism to interact
    among components. It also furnishes a non-blocking mechanism to control the data
    flow. While building a Reactive System, at all relevant points, the data processing
    operations are composed as stream flows. In short, a Reactive System is focused
    on stream processing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式系统使用异步消息传递机制在组件之间进行交互。它还提供了一种非阻塞机制来控制数据流。在构建反应式系统时，在所有相关点上，数据处理操作都作为流流程组成。简而言之，反应式系统专注于流处理。
- en: Reactive Programming
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式编程
- en: Reactive Programming can be used to build a Reactive System. By definition,
    **Reactive Programming** is a programming practice or pattern that is aligned
    around the data flow and the propagation of the changes. The changes in data are
    automatically propagated by the underlying execution model through the data flow.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程可用于构建反应式系统。根据定义，**反应式编程**是一种围绕数据流和变化传播对齐的编程实践或模式。数据的变化通过底层执行模型自动通过数据流传播。
- en: To make it simple, Reactive Programming is a way to handle asynchronous data
    streams in a more effective manner. In other words, it is programming dealing
    with an asynchronous data stream, or it can be called the subset of asynchronous
    programming. Reactive Programming is a way of execution where new information
    will push the flow forward, rather than having the flow controlled by an execution
    thread.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，反应式编程是一种更有效地处理异步数据流的方法。换句话说，它是一种处理异步数据流的编程方式，或者也可以称为异步编程的一个子集。反应式编程是一种执行方式，其中新信息将推动流程前进，而不是由执行线程控制流程。
- en: The data stream is a series of business events that happen during the system
    execution, such as various keyboard or mouse events, HTML field changes, HTTP
    requests, notification, REST API data fetch, triggering validations, changing
    of web component state, data updates, or anything else that can cause a change
    in the data stream or alter a program behavior.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流是一系列在系统执行过程中发生的业务事件，例如各种键盘或鼠标事件、HTML字段更改、HTTP请求、通知、REST API数据获取、触发验证、更改Web组件状态、数据更新，或任何其他可能引起数据流变化或改变程序行为的事情。
- en: In short, Reactive Programming covers a dynamic reaction in the stream that
    is caused by the asynchronous data flow. When the changes happen in one component,
    a reactive library or framework will automatically propagate those changes to
    other components. It is quite possible to define a static order in which the changes
    are propagated.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，响应式编程涵盖了由异步数据流引起的流中的动态反应。当一个组件发生变化时，响应式库或框架会自动将这些变化传播到其他组件。定义一个静态的传播顺序是完全可能的。
- en: 'The following diagram shows how Reactive Programming is different to imperative
    programming:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了响应式编程与命令式编程的不同之处：
- en: '![](img/0706314d-9be6-4982-bbcf-c07d4b00c25e.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0706314d-9be6-4982-bbcf-c07d4b00c25e.png)'
- en: In **imperative programming**, the threads talk to each other in a synchronous
    way that results in blocking communication. A thread has to wait until the dependent
    thread of a resource is free, which can cause inefficient utilization and an easy
    bottleneck situation in the system. On the other hand, Reactive Programming doesn't
    need to wait; in fact, it is informed once the resource is available so that it
    can do other work in the meantime. This reduces the risk of the system hanging
    and makes it responsive. This effectively maintains smooth resource usage.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在**命令式编程**中，线程以同步方式相互通信，导致阻塞通信。一个线程必须等待依赖资源的线程空闲，这可能导致系统效率低下，并容易形成瓶颈。另一方面，响应式编程不需要等待；事实上，一旦资源可用，它就会得到通知，这样它就可以在同时做其他工作。这减少了系统挂起的可能性，并使其响应。这有效地保持了资源的平稳使用。
- en: Reactive Programming suggests breaking down the given requirements into separate
    and individual steps that can be accomplished in an asynchronous, non-blocking
    style, and later on, combined to form a final output. In the Reactive Programming
    context, asynchronous means that the processing of a message or event occurs at
    some arbitrary time, most probably in the future.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程建议将给定的需求分解成单独的步骤，这些步骤可以以异步、非阻塞的方式完成，并在之后组合成最终输出。在响应式编程的上下文中，异步意味着消息或事件的处理发生在某个任意时间，最可能是在未来。
- en: The asynchronous and non-blocking nature of Reactive Programming is particularly
    useful in application environments where resources are shared; there is no need
    to halt the thread of execution while a resource is elsewhere engaged.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程的异步和非阻塞特性在资源共享的应用环境中特别有用；在资源被其他地方占用时，无需停止执行线程。
- en: Basics of Reactive Programming
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程的基本概念
- en: In a procedural programming model, a task is described as a series of actions
    executed in a sequential order. On the other hand, the Reactive Programming model
    facilitates the necessary arrangement to propagate the changes, which help in
    deciding what to do instead of how to do it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程式编程模型中，任务被描述为一系列按顺序执行的操作。另一方面，响应式编程模型促进了必要的安排来传播变化，这有助于决定做什么而不是如何做。
- en: 'Let''s understand the concept with a very basic example, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个非常基础的例子来理解这个概念，如下所示：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is what we generally do in a procedural programming style. In this code,
    we are simply doing a summation of two numbers assigned to the third number and
    then printing it. In the next line, we are changing the value of the initial two
    numbers, but it doesn''t update the third number. This is because `num1 + num2`
    is evaluated and assigned to `num3` on that line only. Now consider the same equation
    in an Excel sheet as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们通常在过程式编程风格中做的事情。在这段代码中，我们只是将两个分配给第三个数的数字相加，然后打印出来。在下一行，我们改变了初始两个数的值，但它并没有更新第三个数。这是因为
    `num1 + num2` 在那一行被评估并赋值给 `num3`。现在考虑以下Excel表中的相同方程：
- en: '![](img/e8c00769-ab38-455b-98c9-8dcdc5d03102.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8c00769-ab38-455b-98c9-8dcdc5d03102.png)'
- en: In this case, the changes of the **E** and **F** columns always listen to the **G** column.
    This is what Reactive Programming does. It propagates the changes to the one interested
    in those changes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，E列和F列的变化总是监听G列的变化。这就是响应式编程所做的事情。它将变化传播给对那些变化感兴趣的部分。
- en: You might have used Reactive Programming unknowingly in your day-to-day coding
    practice. For example, if you have created a user registration screen where you
    validate the username entered by a user who is already present in the system,
    makes an Ajax call and shows an appropriate message saying This username is already
    used.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在日常编码实践中无意中使用了响应式编程。例如，如果你创建了一个用户注册界面，其中验证用户输入的用户名是否已在系统中存在，进行Ajax调用并显示一条适当的消息说“此用户名已被使用”。
- en: Another example is the listener or callback function that you define with a
    mouse click or keystroke on the web page. In these cases, mouse click and focus
    out events (for username validation) can be considered as a stream of events that
    you can listen to and execute appropriate action or functions on.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是你在网页上通过鼠标点击或按键定义的监听器或回调函数。在这些情况下，鼠标点击和焦点消失事件（用于用户名验证）可以被视为你可以监听并执行适当动作或函数的事件流。
- en: This is just one usage of the event stream. Reactive programming allows you
    to observe and react to any changes caused by the stream of events, like changes
    in a database, user input, property updates, data from external resources, and
    so on. Let's understand it by taking a real-life example.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是事件流的一个用途。响应式编程允许你观察并对事件流引起的任何变化做出反应，如数据库中的变化、用户输入、属性更新、外部资源的数据等。让我们通过一个现实生活中的例子来理解它。
- en: Let's say you want to invest in mutual funds and there are many companies who
    provide facilities to invest on your behalf. They also produce statistics about
    the performance of various funds along with their history, market share, capital
    investment ratio, and so on. Based on this, they give some categories like moderate
    risk, low risk, moderately high risk, high risk, and so on. They also give a rating
    based on the performance of each fund.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想投资共同基金，并且有许多公司提供代为投资的设施。它们还会提供各种基金的表现统计数据，包括其历史、市场份额、资本投资比率等等。基于这些数据，它们会给出一些分类，如中等风险、低风险、中等高风险、高风险等等。它们还会根据每个基金的表现给出评级。
- en: The rating and the category will suggest that users choose a particular fund
    based on their requirement (short term, long term, and so on) and the type of
    risk they can afford. The changes happen in the rating and the category can be
    considered as an event (or data) stream that will cause a system to change the
    suggestion to the user. Another practical example of a data stream would be a
    social media feed, such as Facebook, Twitter, and so on.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 评级和分类将建议用户根据他们的需求（短期、长期等）和能够承担的风险类型选择特定的基金。评级和分类的变化可以被视为一个事件（或数据）流，这将导致系统更改对用户的建议。另一个数据流的实际例子是社交媒体动态，如Facebook、Twitter等。
- en: '**Function reactive** is a paradigm of reacting to the data stream in a functional
    way, providing additional features such as filters, combine, buffers, maps, and
    lot others. Using them, you can perform certain operations on a data stream, which
    help it to react in a better way. Taking the previous example of a mutual fund,
    the filter function can be used to suggest only those funds that are safe for
    investment in a real-time manner.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数响应式**是一种以函数方式对数据流做出反应的范例，提供了额外的功能，如过滤器、组合、缓冲区、映射等。使用它们，你可以在数据流上执行某些操作，这有助于它更好地做出反应。以之前的共同基金例子，过滤器函数可以用来实时建议那些安全的投资基金。'
- en: Reactive Programming is mainly used to build an interactive user interface and
    other systems that need time interaction, such as graphical applications, animations,
    simulations, chatbots, and so on.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程主要用于构建交互式用户界面和其他需要时间交互的系统，如图形应用程序、动画、模拟、聊天机器人等。
- en: Backpressure
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反压
- en: One of the important concepts that you should know about in Reactive Programming
    is backpressure. It significantly improves Reactive Programming over the traditional
    code. What exactly is it? It is considered as one of the non-blocking regulatory
    mechanisms used to send asynchronous messages or feedback to the source of a stream
    for load regulation. Communication back to the stream sender could possibly be
    a request or alert to stop. However, it could also be about the receiver's intent
    to process more messages. The communication back to the sender has to be non-blocking.
    This is important.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式编程中，你应该了解的一个重要概念是背压。它显著提高了响应式编程相对于传统代码的性能。它究竟是什么呢？它被认为是一种非阻塞的监管机制，用于发送异步消息或反馈到流源以进行负载调节。向流发送者的通信可能是停止请求或警报。然而，它也可能是关于接收者处理更多消息的意图。向发送者的通信必须是非阻塞的。这很重要。
- en: Consider the situation where observables (source of an event) send out the data
    at a higher rate than the subscribers can actually handle. In this case, the subscribers
    would be in a stress condition, unable to handle the flow properly, and there
    is a high chance the system would behave unexpectedly. To avoid this situation,
    there must be some arrangement for conveying the speed at which the subscribers
    can consume the data, back to the observables.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到可观察者（事件的来源）发送数据的速度高于订阅者实际处理的速度的情况。在这种情况下，订阅者会处于压力状态，无法正确处理流量，系统出现意外行为的高概率很高。为了避免这种情况，必须有一些安排来传达订阅者可以消耗数据的速度，并将其反馈给可观察者。
- en: The mechanism for notifying the source of the event saying, *Hey, I am under
    pressure,* *so don't send a further message as I can consume X amount of messages
    at a particular time*, is called **backpressure**. In the absence of this, the
    system may keep increasing the buffer size until it runs out of memory error. Backpressure
    is required when emission happens at a faster rate than consumption. It will make
    sure the system remains resilient under the load and will provide information
    that is used to make the decision, whether the system needs additional resources
    or not.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通知事件源机制，表示“嘿，我现在压力很大，所以不要发送更多消息，因为我可以在特定时间内消耗X条消息”，这种机制被称为**背压**。如果没有这种机制，系统可能会不断增大缓冲区大小，直到耗尽内存错误。当发射速度超过消费速度时，就需要背压。它将确保系统在负载下保持弹性，并提供用于做出决策的信息，即系统是否需要额外的资源。
- en: Benefits of Reactive Programming
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程的好处
- en: A few years ago, the user interaction was limited to just filling in the form
    on a web page and submitting it to the server. It was just enough for self-sufficient
    applications at the time. Today, in the era of the mobile and responsive requirement,
    a rich user interface showing real-time information is expected to provide wide
    interactive possibilities.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，用户交互仅限于在网页上填写表单并将其提交给服务器。在当时，这对于自给自足的应用程序来说已经足够了。今天，在移动和响应式需求的时代，一个展示实时信息的丰富用户界面预计将提供广泛的交互可能性。
- en: 'Also, different types of apps like cloud environments, distributed apps, IoT,
    and real-time applications need lots of user interaction. This can be achieved
    by Reactive Programming. It is used to build loosely coupled, responsive, and
    scalable applications that are more tolerant of failure. There are many advantages
    of using Reactive Programming, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，像云环境、分布式应用程序、物联网和实时应用程序等不同类型的应用程序需要大量的用户交互。这可以通过响应式编程来实现。它用于构建松散耦合、响应式和可扩展的应用程序，这些应用程序对失败的容忍度更高。使用响应式编程有许多优点，如下所述：
- en: '**Resource utilization:** One of the essential benefits of Reactive Programming
    is optimizing hardware resource utilization, like the processor, memory, network,
    and so on. It also improves the performance by reducing serialization.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源利用**：响应式编程的一个基本好处是优化硬件资源利用，如处理器、内存、网络等。它还通过减少序列化来提高性能。'
- en: '**Enhanced user experience:** Reactive Programming provides better and improved
    user experience by using an asynchronous mechanism that makes the application
    smoother and responsive and easy to interact with.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强用户体验**：响应式编程通过使用异步机制来提供更好的用户体验，使应用程序更加流畅、响应迅速，并且易于交互。'
- en: '**Consistency:** You can design the API with lots more consistency for everything,
    including database call, frontend, network, computation, or anything else you
    may need with Reactive Programming.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性：**你可以设计API，使其在包括数据库调用、前端、网络、计算或任何其他你需要与响应式编程一起使用的东西在内的各个方面都具有更多的一致性。'
- en: '**Handle with ease:** Reactive Programming has first-class support and obvious
    mechanisms for asynchronous operations out of the box. Also, it makes handling
    UI interaction and event management easier.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻松处理：**响应式编程提供了对异步操作的一等支持和明显的机制，无需额外操作。此外，它还使处理UI交互和事件管理变得更加容易。'
- en: '**Simple thread management:** Reactive Programming makes it simpler than regular
    threading mechanisms. Complex threading implementations, making the parallel work
    in a synchronous manner, and executing the callbacks when the function is done
    is easier to achieve with Reactive Programming.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单的线程管理：**响应式编程使得它比常规的线程机制更简单。使用响应式编程来实现复杂的线程实现，使并行工作以同步方式进行，并在函数完成后执行回调，这些操作都更容易实现。'
- en: '**Increased developer productivity:** In a typical imperative programming model,
    the developer has to do lots of work to maintain a straightforward approach to
    achieve an asynchronous and non-blocking computation. Reactive Programming, on
    the other hand, addresses the challenge by providing these features out of the
    box so the developer does not need explicit coordination between elements.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高开发者生产力：**在典型的命令式编程模型中，开发者必须做大量工作以保持一种简单直接的方法来实现异步和非阻塞计算。另一方面，响应式编程通过提供这些功能来应对这一挑战，因此开发者不需要在元素之间进行显式协调。'
- en: Reactive Programming techniques
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程技术
- en: 'Reactive Programming is event-based in most cases. In Reactive Programming,
    the APIs are exposed in the following two flavors:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，响应式编程是基于事件的。在响应式编程中，API以以下两种风味公开：
- en: '**Callback:** In this type, the anonymous routines are registered to event
    sources as callback functions. They will be invoked when the event is triggered
    by the data flow.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回调：**在这种类型中，匿名例程被注册为事件源作为回调函数。当数据流触发事件时，它们将被调用。'
- en: '**Declarative:** The events are observed through well-defined functional compositions,
    like a filter, map, and other stream-based operations, like count, trigger, and
    so on.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式：**事件通过定义良好的函数组合被观察，如过滤器、映射以及其他基于流的操作，如计数、触发等。'
- en: 'Reactive Programming puts the importance on data flow rather than the flow
    of control, so it is not uncommon to consider it as a data flow programming. There
    are various techniques that are used to achieve Reactive Programming as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程重视数据流而非控制流，因此将其视为数据流编程并不罕见。以下是一些用于实现响应式编程的技术：
- en: '**Futures and promise:** It is referred to as a technique to define the variable
    and assign its value. Though futures and promise are used interchangeably, they
    are not exactly the same. The future is used to describe a read-only view of a
    variable (or, say, define the variable), while the promise is a writable, single
    assignment container that is used to set the value of a variable in future.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未来和承诺：**它被定义为定义变量并为其赋值的技术。尽管未来和承诺可以互换使用，但它们并不完全相同。未来用于描述变量的只读视图（或者说，定义变量），而承诺是一个可写、单次赋值的容器，用于在将来设置变量的值。'
- en: '**Reactive Streams:** It is defined as a standard for the processing of asynchronous
    streams that enables non-blocking, backpressure transmutations between sources
    from where the events are initiated and the destination where they are observed.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式流：**它被定义为处理异步流的标准化，它使得从事件发起的源到观察它们的目标的非阻塞、背压转换变得可能。'
- en: '**Data flow variables:** It is a variable whose value depends on a given input,
    operations, and other cells, and is updated automatically when changes happen
    to source entities. You can think of a data flow variable as a spreadsheet cell,
    where a change in the value of one cell causes a ripple effect to others based
    on the assigned formula.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据流变量：**它是一个其值依赖于给定输入、操作和其他单元格的变量，并在源实体发生变化时自动更新。你可以将数据流变量想象成一个电子表格单元格，其中一个单元格的值变化会导致基于分配公式的连锁反应影响其他单元格。'
- en: In addition to this, there are various frontend libraries available, like React.js,
    AngularJS, Ractive.js, Node.js, and so on, which are used to develop reactive
    frontend applications. Other programming languages and frameworks providing native
    support for reactive applications are Scala, Clojure, and GoLang, along with Java
    9 and Spring 5\. We will see reactive features of Spring 5 later in this chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有各种前端库可用，如React.js、AngularJS、Ractive.js、Node.js等，它们用于开发响应式前端应用程序。其他提供对响应式应用程序原生支持的编程语言和框架包括Scala、Clojure、GoLang，以及Java
    9和Spring 5。我们将在本章后面看到Spring 5的响应式特性。
- en: Reactive Programming in Java
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java中的响应式编程
- en: An asynchronous processing approach is a perfect fit while dealing with a huge
    volume of data or a large set of users. It will make the system responsive and
    improve the overall user experience. Implementing asynchronous processing in Java
    with the custom code would be cumbersome and harder to implement. Reactive Programming
    would be beneficial in this scenario.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 异步处理方法在处理大量数据或大量用户时是一个完美的选择。这将使系统响应更快，并提高整体用户体验。在Java中使用自定义代码实现异步处理将会很繁琐，并且更难实现。在这种情况下，响应式编程将是有益的。
- en: Java doesn't provide native support for Reactive Programming like other JVM-based
    programming languages such as Scala or Clojure do. However, from version 9, Java
    has started supporting Reactive Programming natively. Apart from native support
    in Java 9, there are other implementation layers that help to achieve Reactive
    Programming with an older version of Java (such as Java 8). We will see a few
    of them, as follows.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Java不像Scala或Clojure等其他基于JVM的编程语言那样提供对响应式编程的原生支持。然而，从版本9开始，Java已经开始原生支持响应式编程。除了Java
    9中的原生支持之外，还有其他实现层可以帮助使用较旧版本的Java（如Java 8）实现响应式编程。我们将看到其中的一些，如下所述。
- en: Reactive Streams
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式流
- en: Reactive Streams is described simply as an initiative to provide a standard
    for asynchronous stream processing with non-blocking backpressure. It is a small
    and straightforward statement. However, it is essential to note that the first
    focus here is on the asynchronous stream processing and not just on the asynchronous
    programming. As discussed earlier, asynchronous systems have been around for a
    long time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式流被简单地描述为一个提供异步流处理标准，具有非阻塞背压的倡议。这是一个简单直接的说法。然而，重要的是要注意，这里的第一个重点是异步流处理，而不仅仅是异步编程。如前所述，异步系统已经存在很长时间了。
- en: Before processing a stream, comes receiving the stream data. Asynchronously,
    this would mean managing the risk of uncertainties in the world of streams. For
    example, how much more data or messages could there be? Another challenge might
    be how to know when the stream has finished sending data. There could be a lot
    of questions, and we will see all of them in a little while*.*
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理流之前，首先是接收流数据。异步地，这意味着在流的领域中管理不确定性的风险。例如，可能会有多少更多的数据或消息？另一个挑战可能是如何知道流何时完成发送数据。可能会有很多问题，我们将在稍后看到所有这些问题*.*
- en: Reactive Streams is used to perform Reactive Programming in Java. It is an API
    specification or, say, low-level contract given by the collaborations of various
    companies like Pivotal, Netflix, Red Hat, Twitter, Lightbend (previously known
    as Typesafe), Kaazing, Oracle, and many more. You can consider the Reactive Streams
    API to be just like JPA or JDBC. The actual implementations are provided by various
    vendors.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，响应式编程是通过使用响应式流（Reactive Streams）来实现的。它是一个由Pivotal、Netflix、Red Hat、Twitter、Lightbend（之前称为Typesafe）、Kaazing、Oracle等公司合作制定的API规范，或者说是一个由多个公司提供的低级合同。你可以将响应式流API视为类似于JPA或JDBC。实际的实现由各个供应商提供。
- en: For example, JPA specifications have various vendors like Hibernate, TopLink,
    Apache OpenJPA that provide actual implementation. Similarly, there are many popular
    JVM-based libraries that support Reactive Programming like Reactor, Akka stream,
    Ratpack, Vert.x, and so on. They all provide an implementation of the Reactive
    Streams specifications, which bring interchangeability.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，JPA规范有Hibernate、TopLink、Apache OpenJPA等供应商提供实际实现。同样，有许多流行的基于JVM的库支持响应式编程，如Reactor、Akka
    stream、Ratpack、Vert.x等。它们都提供了响应式流规范的实现，这带来了互操作性。
- en: Reactive Streams specifications
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式流规范
- en: 'Let''s try to understand in more detail, what the specifications for Reactive
    Streams are. It is dealing with the asynchronous processing of a stream. Let’s
    look at the specification available at [https://github.com/reactive-streams/reactive-streams-jvm](https://github.com/reactive-streams/reactive-streams-jvm) .
    It comprises the following two parts:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解反应式流的规范。它处理流的异步处理。让我们看看在[https://github.com/reactive-streams/reactive-streams-jvm](https://github.com/reactive-streams/reactive-streams-jvm)上可用的规范。它包括以下两个部分：
- en: '**API**: This describes the specification.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API**：这描述了规范。'
- en: '**Technology Compatibility Kit** (**TCK**): This is a criteria or standard
    test suite for compliance testing of implementations. In short, it will make sure
    the given implementation conforms to the declared specification.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术兼容性套件**（**TCK**）：这是一个用于实现兼容性测试的标准测试套件或标准。简而言之，它将确保给定的实现符合声明的规范。'
- en: 'Taking a closer look at the API, we find that it is rather simple and comprises
    just four interfaces as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看API，我们发现它相当简单，只包含以下四个接口：
- en: '**Publisher**: This interface represents an entity that acts as a supplier
    of an unbounded number of sequenced events or elements. It will publish the elements
    as per the requirement of the subscriber.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布者**：此接口代表一个实体，它作为无界序列事件或元素的提供者。它将根据订阅者的需求发布元素。'
- en: '**Subscriber:** It represents a consumer of an event from a publisher. For
    that, it will subscribe to the publisher.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订阅者**：它代表了一个从发布者那里消费事件的消费者。为此，它将订阅发布者。'
- en: '**Subscription:** This interface illustrates the process of subscribing or
    registering of a subscriber to a publisher.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订阅**：此接口说明了订阅者向发布者订阅或注册的过程。'
- en: '**Processor:** It is a composition of both the publisher and subscriber. It
    represents a processing stage that implements the contract of both.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理器**：它是发布者和订阅者的组合。它代表一个实现双方合同的加工阶段。'
- en: 'Java 9 has started providing native support for Reactive Streams. The implementation
    of these interfaces is part of the Flow API in Java 9\. Looking at the structure
    of JAR containing the Reactive Streams, we find the following structure:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9开始为反应式流提供原生支持。这些接口的实现是Java 9中Flow API的一部分。查看包含反应式流的JAR文件的结构，我们发现以下结构：
- en: '![](img/946a8436-aacd-43e4-9a11-d8b1498daa00.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/946a8436-aacd-43e4-9a11-d8b1498daa00.png)'
- en: This seems rather straightforward, and implementing a set of a few interfaces
    shouldn’t be a challenge for any developer in Java. Are we able to go to production
    with the implementation of these interfaces, and will it give us a stable system?
    Are we ready to get started with the reactive development? The answers are, *not
    quite yet*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当直接，实现一组接口对于任何Java开发者来说都不应该是一个挑战。我们能否用这些接口的实现进入生产环境，并且它是否会给我们一个稳定的系统？我们是否准备好开始反应式开发？答案是，*还不太行*。
- en: Passing the messages in an asynchronous way is the key area of focus for Reactive
    Streams. It ensures that it is not just the consumer that is protected from being
    overwhelmed by all the distributed systems. The Publisher is also safeguarded
    in case one or more subscribers is slow to process the messages. It primarily
    says that this is the way you should pass a message from thread *A* to thread
    *B* in a protected manner, to ensure both the publisher and the subscriber are
    protected.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以异步方式传递消息是反应式流的关键关注领域。它确保不仅消费者不会因所有分布式系统而超负荷，发布者也会在有一个或多个订阅者处理消息较慢的情况下得到保护。它主要说明这是您应该以受保护的方式从线程*A*传递消息到线程*B*的方式，以确保发布者和订阅者都得到保护。
- en: Let’s dig further into the specifications, (we will come to the TCK a little
    later) and see how they correspond with the original statement of the Reactive
    Streams manifesto. Starting with the publisher, we see that the specifications
    also define a set of rules that must be adhered to by the implementer of the specifications.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步挖掘规范，(我们稍后会提到TCK)并看看它们如何与反应式流宣言的原始声明相对应。从发布者开始，我们看到规范还定义了一套必须由规范的实现者遵守的规则。
- en: 'The rules are defined for all the four interfaces: publisher, subscriber, subscription,
    and processor. It won’t be possible to go through all the rules here, and neither
    it is required, as the rules are available at: [https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.2/README.md](https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.2/README.md) .'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 规则为所有四个接口：发布者、订阅者、订阅和处理器定义。在这里不可能列出所有规则，也不需要这样做，因为规则可在以下位置找到：[https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.2/README.md](https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.2/README.md)。
- en: However, in order to draw some relevance from the Reactive Streams manifesto,
    let’s look at some of the important rules. We will analyze one or two rules each
    from all four interfaces to help you understand how they are laid out. Do have
    a look at the glossary table before reading these rules and specifications.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了从响应式流宣言中提取一些相关性，让我们看看一些重要的规则。我们将从所有四个接口中各分析一两条规则，以帮助你了解它们的布局。在阅读这些规则和规范之前，请先查看术语表。
- en: You should have a look at the rest of the rules, as going through them will
    give you a good idea about how detailed the rules are. By the time you finish
    reading all the rules, you will have a very good grasp of what to expect from
    the implementation of Reactive Streams.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看看其余的规则，因为通过阅读它们，你会对规则的详细程度有一个很好的了解。在你读完所有规则之后，你将对响应式流的实现预期有非常清晰的认识。
- en: Publisher rules
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布者规则
- en: '`Publisher` has the following interface definition:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Publisher`具有以下接口定义：'
- en: '[PRE1]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Rule number 1.1 says, the total number of `onNext`signaled by a `Publisher`
    to `Subscriber` must be less than, or equal to, the total number of elements requested
    by that `Subscriber`Subscription at all times*.* There are multiple facets to
    this definition here. Let’s try to analyze them one by one:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 规则1.1指出，`Publisher`向`Subscriber`发出的`onNext`信号总数必须始终小于或等于该`Subscriber`订阅请求的总元素数*.*
    这里有多重含义。让我们逐一分析它们：
- en: First and foremost, there has to be a request for a message from `Subscriber` (total
    number → 1 - N) to `Publisher`. Therefore, `Publisher`cannot start sending messages
    to unsuspecting subscribers on its own as these subscribers might still be deciding
    when to start receiving messages. Furthermore, some might still be performing
    some initial tasks in order to start receiving the message.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首要的是，必须由`Subscriber`（总数→1 - N）向`Publisher`发起消息请求。因此，`Publisher`不能自行开始向未察觉的订阅者发送消息，因为这些订阅者可能还在决定何时开始接收消息。此外，有些人可能仍在执行一些初始任务以开始接收消息。
- en: Secondly, only after the request is received by `Publisher` can it begin transmitting
    the messages to `Subscriber`. In response to the request for messages from `Publisher`,
    Subscriber receives `Subscription`. Now `Subscriber`can use `Subscription` to
    interact with `Publisher` and vice versa. How many messages `Publisher` should
    send is mentioned in `Subscription` so the requested messages by `Subscribers`
    should be less than or equal to that number `[message count <= total number]`.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，只有当`Publisher`收到请求后，它才能开始向`Subscriber`传输消息。作为对`Publisher`消息请求的响应，`Subscriber`接收`Subscription`。现在`Subscriber`可以使用`Subscription`与`Publisher`交互，反之亦然。`Subscription`中说明了`Publisher`应该发送多少消息，因此`Subscribers`请求的消息数应该小于或等于该数字`[message
    count <= total number]`。
- en: Thirdly, `Publisher` cannot send more messages to `Subscriber` than requested
    by `Subscriber`.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，`Publisher`不能向`Subscriber`发送比`Subscriber`请求的更多的消息。
- en: These three points together form a part of the backpressure we mentioned when
    we began with Reactive Streams.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这三点共同构成了我们在开始介绍响应式流时提到的背压的一部分。
- en: And yes, the count requested by  `Subscriber` from `Publisher` is not binding
    on `Publisher` as per the other rule, not binding with respect to the count of
    messages. `Publisher` is allowed to send less than the requested count of messages
    from `Subscriber`. This can be described with the following.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 并且是的，根据其他规则，`Subscriber`从`Publisher`请求的计数对`Publisher`不具有约束力，即与消息计数无关。`Publisher`允许发送少于`Subscriber`请求的消息数。这可以用以下方式描述。
- en: Subscriber rules
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅者规则
- en: '`Subscriber` has the following interface definition:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subscriber`具有以下接口定义：'
- en: '[PRE2]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Rule number 2.1 says, A `Subscriber` must signal demand via Subscription.request(long
    n) to receive `onNext` signals.This rule is in line with `Publisher` rule number
    1.1 in the sense that it  establishes the responsibility of `Subscriber` to inform
    when and how many messages it is able and willing to receive.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 规则2.1指出，`Subscriber`必须通过`Subscription.request(long n)`来表示需求，以接收`onNext`信号。这条规则与`Publisher`规则1.1相一致，因为它确立了`Subscriber`的责任，即告知何时以及愿意接收多少消息。
- en: Rule number 2.4 says, `.onComplete()` and `Subscriber.onError(Throwable t)`
    must consider the `Subscription` cancelled after having received the signal*.* Here
    again, the design intention at play is highlighted. The design sequence of sending
    ensures that the process of the message being sent from `Publisher` to `Subscriber`
    is completely decoupled. Therefore, `Publisher` is not bound by the `Subscriber` intent
    to keep listening, hence ensuring a non-blocking arrangement.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 规则2.4指出，`.onComplete()`和`Subscriber.onError(Throwable t)`在接收到信号后必须考虑`Subscription`已被取消。在这里，再次突出了设计意图。发送消息的设计顺序确保了从`Publisher`到`Subscriber`的消息发送过程完全解耦。因此，`Publisher`不受`Subscriber`保持监听意图的约束，从而确保了非阻塞的安排。
- en: As soon as `Publisher` sends out a message, it has no messages to be sent with `Subscriber.onComplete()` and the
    `Subscription` object is no longer valid/available. This is similar to when an
    exception is thrown back with `Subscriber.onError(Throwable t)`*.* The `Subscription`
    object can no longer be utilized by  `Subscriber` to request more messages.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`Publisher`发送了一条消息，它就没有其他消息需要通过`Subscriber.onComplete()`发送，并且`Subscription`对象就不再有效/可用。这类似于当通过`Subscriber.onError(Throwable
    t)`抛出异常时。`Subscription`对象不能再被`Subscriber`用来请求更多消息。
- en: It is worthwhile mentioning another couple of rules around the same design.
    These are rules number 2.9 and 2.10 concerning `Subscription.request(long n)`.
    The rule says that a `Subscriber` can get the `onError` signal or the `onComplete`
    signal with or without a preceding call to `Subscription.request(long n)`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，关于相同设计的一些其他规则。这些是规则2.9和2.10，它们关注`Subscription.request(long n)`。规则指出，`Subscriber`可以在没有或有一个先前的`Subscription.request(long
    n)`调用的情况下，通过`onError`信号或`onComplete`信号获得。
- en: Subscription rules
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅规则
- en: 'The following interface describes the `Subscription` notation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下接口描述了`Subscription`的表示法：
- en: '[PRE3]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The rule number 3.2 says, `Subscription` must allow the `Subscriber` to call
    `Subscription.request` synchronously from within `onNext` or `onSubscribe`*.* It
    talks about preventing both `Publisher` and `Subscriber` by restricting posting
    of the message only when  `Publisher` gets the signal for a further request from
    `Subscriber`. This happens in a synchronous manner to avoid a stack overflow.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 规则3.2指出，`Subscription`必须允许`Subscriber`在`onNext`或`onSubscribe`内部同步调用`Subscription.request`。它讨论了通过限制只有在`Publisher`从`Subscriber`那里收到进一步请求信号时才发布消息来防止`Publisher`和`Subscriber`。这是以同步方式进行，以避免栈溢出。
- en: In a similar context, another rule, number 3.3, states, `Subscription.request()` must
    place an upper bound on possible synchronous recursion between `Publisher` and
    `Subscriber`*.* It complements rule 3.2 in a sense by deciding an upper limit
    in the recursive interaction between `Publisher` and `Subscriber` in the form
    of the `onNext()` and `request()` call. Setting the upper limit will avoid blowing
    out when calling a thread stack. The rules starting from number 3.5 to 3.15 describe
    the behavior of cancelling and completing the request.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似的情况下，另一条规则，编号3.3，指出，`Subscription.request()`必须在`Publisher`和`Subscriber`之间可能的同步递归上设置一个上限。它在某种程度上补充了规则3.2，通过在递归交互中确定`onNext()`和`request()`调用的上限来做出决定。设置上限将避免在调用线程栈时崩溃。从编号3.5到3.15的规则描述了请求的取消和完成的行为。
- en: Processor rules
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器规则
- en: '`Processor` is described with the following interface definition:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`处理器`的接口定义如下：'
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It has just two rules. The first rule talks about the contract that must be
    followed by both `Subscriber` and `Publisher` , while the second rule is intended
    to handle the error situation, either recover or propagate to `Subscriber`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 它只有两条规则。第一条规则讨论了`Subscriber`和`Publisher`都必须遵守的合同，而第二条规则旨在处理错误情况，要么恢复，要么传播给`Subscriber`。
- en: Reactive Streams TCK
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式流TCK
- en: Implementing the interfaces defined in Reactive Streams specification is not
    just suffice to build Reactive Streams. The specification comprises a set of components
    and rules. The components part is taken care of with four interfaces we discussed,
    while the rules are defined by Reactive Streams **Technology Compatibility Kit** (**TCK**).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 仅实现Reactive Streams规范中定义的接口并不足以构建Reactive Streams。该规范包括一系列组件和规则。组件部分由我们讨论的四个接口负责，而规则则由Reactive
    Streams的**技术兼容性工具包**（**TCK**）定义。
- en: The Reactive Streams TCK is a guideline to Reactive Streams implementors to
    verify their implementations against the rules defined in the specifications.
    The TCK is developed with a testing framework in Java called **TestNG** and can
    be used in other JVM-based programming languages, like Kotlin and Scala.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Reactive Streams TCK是响应式Streams实现者的指南，用于验证其实现是否符合规范中定义的规则。TCK是用Java中名为**TestNG**的测试框架开发的，并且可以在其他基于JVM的编程语言中使用，如Kotlin和Scala。
- en: TCK covers most of the rules, but not all, defined in the specification because
    for some of the rules, it is not possible to construct automated test cases. So
    theoretically, it can't be verified fully against the specification; however,
    it is helpful to validate most of the important rules.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: TCK涵盖了规范中定义的大部分规则，但不是全部，因为对于某些规则，无法构建自动化的测试用例。因此，从理论上讲，它不能完全符合规范；然而，它对于验证大多数重要规则是有帮助的。
- en: TCK comprises four TestNG test classes and contains test cases, which can be
    extended by implementers and provide their implementation of `Publisher`, `Subscriber`,
    `Subscription`, and `Processor` to validate against the specification rules. You
    can get it in further detail from the link: [https://github.com/reactive-streams/reactive-streams-jvm/tree/master/tck](https://github.com/reactive-streams/reactive-streams-jvm/tree/master/tck).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: TCK包含四个TestNG测试类，包含测试用例，实施者可以扩展它们并提供自己的`Publisher`、`Subscriber`、`Subscription`和`Processor`实现，以验证规范规则。您可以从以下链接获取更多详细信息：[https://github.com/reactive-streams/reactive-streams-jvm/tree/master/tck](https://github.com/reactive-streams/reactive-streams-jvm/tree/master/tck)。
- en: RxJava
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJava
- en: Starting with version 8, Java began supporting reactivity features as inbuilt
    capability, yet they were not used widely and didn't become popular among developers.
    However, some third party implementations of Reactive Programming in Java showed
    its advantages and it grew in popularity in the Java community.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本8开始，Java开始支持作为内置功能的响应式特性，但它们并没有被广泛使用，也没有在开发者中流行起来。然而，一些第三方在Java中的响应式编程实现展示了其优势，并在Java社区中越来越受欢迎。
- en: There is nothing but the set of tools called **Reactive Extension** (or simply
    ReactiveX) allowing implementation of Reactive Programming for composing asynchronous
    and event-based programs using observable sequences. It is a Java VM (Virtual
    Machine) implementation of Reactive Extension. Initially written on Microsoft
    platforms, Reactive Extension offers reactive capabilities to various other programming
    languages, and one of the most popular among them is RxJava for the Java programming
    language.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 除了被称为**Reactive Extension**（或简称ReactiveX）的工具集之外，没有其他任何东西可以用来实现用于组合异步和基于事件的程序的可观察序列的响应式编程。这是一个Java
    VM（虚拟机）的Reactive Extension实现。最初在Microsoft平台上编写，Reactive Extension为各种其他编程语言提供了响应式能力，其中最流行的是Java编程语言的RxJava。
- en: It was the first Reactive Extension API specific to the Java platform*. *RxJava
    is compatible with older versions of Java and provides a facility to write asynchronous,
    event-based programs for both Java and Android platforms, which is very convenient. ReactiveX
    also covers other programming languages with Reactive Extension, like RxJs, Rx.Net,
    UnixRx, RxScala, RxCloujure, RxCPP, Rx.rb, and RxKotlin, along with other platforms
    and frameworks like RxCocoa, RxAndroid, and RxNetty.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个针对Java平台的特定Reactive Extension API**。**RxJava与较旧的Java版本兼容，并提供了一个方便的设施来为Java和Android平台编写异步、基于事件的程序。ReactiveX还涵盖了其他编程语言，如RxJs、Rx.Net、UnixRx、RxScala、RxCloujure、RxCPP、Rx.rb和RxKotlin，以及其他平台和框架，如RxCocoa、RxAndroid和RxNetty。
- en: Anatomy of RxJava
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJava的解剖结构
- en: RxJava basically extends the observer pattern to support iteration on the sequence
    of event/data and allows the forming of sequences at the same time as abstracting
    away the low-level details, like threading, synchronization, concurrency, and
    thread safety.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava基本上扩展了观察者模式以支持对事件/数据序列的迭代，并允许在同时抽象出低级细节，如线程、同步、并发和线程安全的同时形成序列。
- en: 'At the time of writing, the current version of RxJava-2.6 has a single dependency
    on Reactive Streams API and provides support for Java 6 and the later versions, along
    with Android 2.3+. Before going deep into RxJava, let''s look at the basic building
    blocks of ReactiveX as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，RxJava-2.6的当前版本仅依赖于Reactive Streams API，并为Java 6及其后续版本以及Android 2.3+提供支持。在深入探讨RxJava之前，让我们看看ReactiveX的基本构建块如下：
- en: '`Observable`: It is  basically a data stream or in other words a source of
    data. It can emit the data just one time or periodically in a continuous manner,
    based on the configuration. `Observable` can send out specific data on particular
    events based on the operators used with `Observable`.  In short, `Observable`
    is the supplier of data to other components.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable`：它基本上是一个数据流，换句话说，是一个数据源。它可以根据配置一次性或连续地定期发出数据。`Observable`可以根据与`Observable`一起使用的操作符在特定事件上发送特定数据。简而言之，`Observable`是向其他组件提供数据的数据提供者。'
- en: '`Observer`: The data stream emitted by `Observable` is consumed by Observers.
    For that, they need to subscribe to  `Observable` using the `subscribeOn()` method.
    One ore more observers can be subscribed to `Observable`. When  `Observable` sends
    the data, all registered observers receive the data with the `onNext()` callback
    method. Once the data is received, you can perform any operation on that. In case
    any error occurred during the transmission, observers will get the error data
    with the `onError()` callback.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observer`：`Observable`发出的数据流由观察者消费。为此，它们需要使用`subscribeOn()`方法订阅`Observable`。一个或多个观察者可以订阅`Observable`。当`Observable`发送数据时，所有注册的观察者都会通过`onNext()`回调方法接收数据。一旦接收到数据，就可以对它执行任何操作。如果在传输过程中发生任何错误，观察者将通过`onError()`回调接收错误数据。'
- en: '`Scheduler`:They are used for thread management to achieve asynchronous programming
    in ReactiveX. They will instruct `Observable` and `Observer` to choose particular
    thread on which they can execute the operations. For that, `Scheduler` provide
    the `observerOn()` and `scheduleOn()` methods for the `Observer` and `Observable`
    respectively.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scheduler`：它们用于线程管理，以在ReactiveX中实现异步编程。它们将指导`Observable`和`Observer`选择特定的线程来执行操作。为此，`Scheduler`为`Observer`和`Observable`分别提供了`observerOn()`和`scheduleOn()`方法。'
- en: 'Let''s understand these concepts with a practical example. We will create a
    Maven project in Eclipse with settings as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个实际例子来理解这些概念。我们将在Eclipse中创建一个Maven项目，其设置如下：
- en: '![](img/a177cf08-19f9-42db-af13-7b18e75118aa.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a177cf08-19f9-42db-af13-7b18e75118aa.png)'
- en: 'We need to give RxJava specific dependency. The current version at this moment
    is 2.2.6\. After adding the dependency,  `pom.xml` should look as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供RxJava特定的依赖。当前版本是2.2.6。添加依赖后，`pom.xml`应如下所示：
- en: '[PRE5]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a new Java class with an appropriate package and add the following code
    to it:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的Java类，并添加以下代码到该类中：
- en: '[PRE6]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `adminUsers` instance is of type `Observable<String>` that pushes five strings literals
    (name of admin users), which is essentially a data stream or the source of data.
    For simplicity, we have taken String Literals, but `Observable` can push the data
    or events from any source, such as a database query result, social media feed,
    REST API response, or anything similar.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`adminUsers`实例是类型为`Observable<String>`的实例，它推送五个字符串字面量（管理员用户的名称），这本质上是一个数据流或数据源。为了简单起见，我们使用了字符串字面量，但`Observable`可以从任何来源推送数据或事件，例如数据库查询结果、社交媒体动态、REST
    API响应或任何类似的东西。'
- en: 'The `Observable.just()` method is used to emit a fixed set of string literals.
    The last line of the code describes how the `Observer` can subscribe to `Observable`
    with the `subscribe()` method. It is defined as a lambda expression that specifies
    what to do with the string it receives from `Observable`. This relation can be
    described in the following diagram:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.just()`方法用于发出一组固定的字符串字面量。代码的最后一行描述了`Observer`如何使用`subscribe()`方法订阅`Observable`。它被定义为lambda表达式，指定了对从`Observable`接收到的字符串进行什么操作。这种关系可以用以下图示来描述：'
- en: '![](img/cd64d3e2-a436-40b8-bf0c-6115074fbd17.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cd64d3e2-a436-40b8-bf0c-6115074fbd17.png)'
- en: 'In this code, `Observer` is simply printing the string literal. RxJava provides
    several operators that can be used in between `Observable` and `Observer`*.* These
    operators are used to transform or manipulate each pushed data passed in between.
    Each operator processes the data coming from previous `Observable` and returns
    new `Observable`. Let''s use one of the operators called `map` and update the
    code as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`Observer`只是打印字符串字面量。RxJava提供了几个可以在`Observable`和`Observer`之间使用的操作符。这些操作符用于转换或操作传递之间的每个推送数据。每个操作符处理来自先前`Observable`的数据，并返回新的`Observable`。让我们使用一个名为`map`的操作符，并按如下方式更新代码：
- en: '[PRE7]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this code, the data emitted by the `adminUsers` observable is passed through
    a map operator before being sent to `Observer`. The `map` operator here provides
    a lambda expression, which is used to process the submitted data from `adminUsers`.
    It basically prints the return string if it starts with `D` or else simply returns
    a string with an asterisk mark (`*`). The  `map` operator returns new `Observable`
    that returns the data processed by the `map` operator and finally sends it to
    `Observer`. You will see the output, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`adminUsers`可观察发射的数据在发送到`Observer`之前通过一个`map`操作符。这里的`map`操作符提供了一个lambda表达式，用于处理从`adminUsers`提交的数据。它基本上如果返回字符串以`D`开头则打印返回的字符串，否则简单地返回一个带星号标记（`*`）的字符串。`map`操作符返回一个新的`Observable`，该`Observable`返回由`map`操作符处理的数据，并将其最终发送到`Observer`。您将看到以下输出：
- en: '![](img/5d72c518-2035-4803-a37e-fd3542deda26.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d72c518-2035-4803-a37e-fd3542deda26.png)'
- en: Observer event calls
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者事件调用
- en: What we discussed so far is very high-level information about how we can use
    `Observable` in RxJava. It basically pushes (emits) the items (data or events)
    of a given type through a series of operators (if defined) until it reaches  `Observer`.
    Let's dig into more details to understand which mechanism works under the hood
    between this interaction and how RxJava complies with Reactive Streams specifications.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止讨论的是关于如何在RxJava中使用`Observable`的非常高级的信息。它基本上通过一系列操作符（如果定义）将给定类型的项（数据或事件）推送到`Observer`。让我们深入了解更多细节，以了解在交互过程中底层工作的机制以及RxJava如何遵守响应式流规范。
- en: '`Observable` interacts with `Observers` through the following event calls:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable`通过以下事件调用与`Observers`交互：'
- en: '`onNext`: This is the call from where data/events are being sent, one at a
    time, down to all registered `Observers`.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onNext`：这是数据/事件逐个发送到所有已注册`Observers`的调用。'
- en: '`onComplete`: This event is used to signal completion of communication to all.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onComplete`：此事件用于向所有人发出通信完成的信号。'
- en: '`Observers`: It simply denotes no more `onNext` calls happen.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observers`：它简单地表示不再发生`onNext`调用。'
- en: '`onError`: In case any error occurs before an `onComplete()` call, an `onError()`
    event is used to signal the error from `Observable` to `Observers`. `Observable`
    will stop emitting the data and `Observers` will handle the error.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError`：在`onComplete()`调用之前发生任何错误时，使用`onError()`事件从`Observable`向`Observers`发出错误信号。`Observable`将停止发射数据，而`Observers`将处理错误。'
- en: 'These events are defined as an `abstract` method in the `Observer` type, and
    we will see the implementation type later in this chapter. First let''s see how
    these event calls happen during the interaction with the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件被定义为`Observer`类型的`抽象`方法，我们将在本章后面看到其实际实现类型。首先，让我们看看在以下代码与交互过程中这些事件调用是如何发生的：
- en: '[PRE8]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`Observable.create()` is a factory method and used to create `Observable` with
    the emitter. The `onNext()` method of the emitter is used to emit (send) the data/events
    (one at a time) to the `Observable` chain (and finally to registered `Observers`).
    The `onComplete()` method is used to terminate further communication.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.create()`是一个工厂方法，用于使用发射器创建`Observable`。发射器的`onNext()`方法用于向`Observable`链（最终到已注册的`Observers`）发射（发送）数据/事件（逐个）。`onComplete()`方法用于终止进一步的通信。'
- en: If you try to make an `onNext()` call after `onComplete()`, the data will not
    be transmitted. In case any error occurs, the `onError()` method is called. It
    is used to push up the error to the `Observable` chain where it is handled by
    `Observer`. In this code, there is no chance of any exception, but you can handle
    any error with `onError()`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`onComplete()`之后尝试进行`onNext()`调用，则数据将不会传输。如果发生任何错误，将调用`onError()`方法。它用于将错误推送到由`Observer`处理的`Observable`链。在此代码中，没有异常发生的可能性，但您可以使用`onError()`处理任何错误。
- en: We have used the `map` and `filter` operators to refine the data to uppercase
    and starting with `D` respectively. Finally, they are printed by `Observer`. The
    flow of data will happen from `onNext()` →`map`→`filter`→`Observer`.  Each operator
    will return new `Observable` class in the chain.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`map`和`filter`算子来将数据转换为大写并分别以`D`开头。最后，它们通过`Observer`打印出来。数据流将从`onNext()`
    → `map` → `filter` → `Observer`发生。每个算子将返回链中的新`Observable`类。
- en: You notice that in the first example we used the `Observable.just()` method
    to emit the data. It internally invokes the `onNext()` method for each of the
    values pushed. On getting the last value, it will call `onComplete()`. So `Observable.just()`
    is equivalent to `Observable.create()` calling `onNext()` on each data and `onComplete()`
    on last one. The `create()` method is generally used for sources that are not
    reactive in nature.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在第一个例子中，我们使用了`Observable.just()`方法来发射数据。它内部为每个推送的值调用`onNext()`方法。在获取最后一个值后，它将调用`onComplete()`。因此，`Observable.just()`相当于`Observable.create()`在每一个数据上调用`onNext()`，在最后一个数据上调用`onComplete()`。`create()`方法通常用于非反应式源。
- en: Observable for iterators
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察的迭代器
- en: '`Observable` provides support to emit the data from any iterable sources, for
    example, lists, maps, sets, and so on. It will call `onNext()` on each item of
    an iterable type, and once the iterator is over, it will call `onComplete()` automatically.
    Iterable in Java is commonly used in collection frameworks, so `Observable` with
    iterable can be used while fetching data from collection classes.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable`支持从任何可迭代源发射数据，例如列表、映射、集合等。它将为可迭代类型的每个项目调用`onNext()`，一旦迭代器结束，它将自动调用`onComplete()`。Java中的可迭代通常用于集合框架，因此带有可迭代的`Observable`可以在从集合类获取数据时使用。'
- en: 'Let''s see how to use it as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用它，如下所示：
- en: '[PRE9]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We are populating the list of `EmployeeRating` and creating `Observable` with
    the`fromIterable()` method by passing this list. The class `EmployeeRating` is
    a simple POJO containing the `name` and `rating` attributes as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`fromIterable()`方法通过传递这个列表来填充`EmployeeRating`列表并创建`Observable`。`EmployeeRating`类是一个简单的POJO，包含以下`name`和`rating`属性：
- en: '[PRE10]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: RxJava conforms to Reactive Streams specification by providing an implementation
    of interfaces. Let's recall that the `onNext()`, `onError()`, `onSubscribe()`,
    and `onComplete()` methods are part of the Observer interface. RxJava provides
    an implementation of these interfaces to handle respective events.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava通过提供接口的实现来符合反应式流规范。让我们回忆一下，`onNext()`、`onError()`、`onSubscribe()`和`onComplete()`方法是观察者接口的一部分。RxJava提供了这些接口的实现来处理相应的事件。
- en: Custom Observers
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义观察者
- en: We have seen how data emits from `Observable`, passes through a down stream
    of operators and eventually reaches `Observer`. Apparently, we can say that the
    data is transmitted from a series of `Observable` because each operator returns
    new `Observable` , which forms an `Observable` chain. The first `Observable` where
    the emission originates is called the `Observable` source. Therefore, we can say
    that `Observable.create()` and `Observable.just()` return the `Observable` source.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到数据是如何从`Observable`发射出来，通过算子流向下传递，最终到达`Observer`的。显然，我们可以这样说，数据是从一系列`Observable`传输的，因为每个算子返回新的`Observable`，形成一个`Observable`链。第一个发射源头的`Observable`被称为`Observable`源。因此，我们可以这样说，`Observable.create()`和`Observable.just()`返回`Observable`源。
- en: 'We can provide our custom implementation to handle the `Observer` events as
    follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供我们的自定义实现来处理`Observer`事件，如下所示：
- en: '[PRE11]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Like previous examples, we have defined the `Observable` with the list of months.
    We also defined custom `Observers` with an implementation of various methods that
    will be called on for a specific event. When we register the observer (`customObserver`
    in our case), `Observable` will call the `onSubscribe()` method on `Observer`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的例子一样，我们使用月份列表定义了`Observable`。我们还定义了自定义`Observers`，并实现了将在特定事件上被调用的各种方法。当我们注册观察者（在我们的例子中是`customObserver`）时，`Observable`将在`Observer`上调用`onSubscribe()`方法。
- en: Every time when `Observable` emits the data, it will call `onNext()` of registered
    observers, which will then be processed by observers. On sending the last data,
    `Observable` will call the `onComplete()` method on `Observer`. In case if any
    error occurs in between, `Observable` will call `onError()` method on `Observer`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 每次当`Observable`发射数据时，它将调用注册观察者的`onNext()`，然后由观察者处理。在发送最后一个数据时，`Observable`将在`Observer`上调用`onComplete()`方法。如果在中间发生任何错误，`Observable`将在`Observer`上调用`onError()`方法。
- en: Certainly, the data will be passed through the `Observable` chain. In the previous
    case, the data emitted from the `Observable` source (`months` in this case) will
    be forwarded downstream to the `filter` operator, which will then reach the Observer
    or endpoint where the data is consumed and processed. By processed, we mean the
    data can be saved to the database, sent as a server response, written to the external
    document management system, composed as a structure for UI rendering, or simply
    printed in the console.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，数据将通过`Observable`链传递。在前一个例子中，从`Observable`源（在这种情况下是`months`）发出的数据将被传递到下游的`filter`操作符，然后到达观察者或数据消费和处理的端点。通过处理，我们指的是数据可以被保存到数据库中，作为服务器响应发送，写入外部文档管理系统，组成用于UI渲染的结构，或者简单地打印到控制台。
- en: 'You will get an output as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '![](img/b47c535e-e710-4c86-a677-40b006a98446.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b47c535e-e710-4c86-a677-40b006a98446.png)'
- en: In this example, we have used an anonymous class to provide a custom implementation
    of Observer's methods. However, you can use a lambda expression for this purpose.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用匿名类来提供观察者方法的自定义实现。然而，你可以使用lambda表达式来完成这个目的。
- en: Observable types
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observable类型
- en: In the examples we have seen in previous subsections of the RxJava section,
    the data was created within Observable.  However, in the real scenario, that data
    comes from other sources like databases, REST APIs, and so on. The representation
    of any set of data/values is referred to as the producer. Observables are divided
    broadly into the following two categories based on where the procedure is cited.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前RxJava部分的子节中看到的示例中，数据是在Observable中创建的。然而，在实际场景中，这些数据来自数据库、REST API等其它来源。任何一组数据/值的表示被称为生产者。根据程序引用的位置，Observables大致分为以下两类。
- en: Cold Observable
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冷Observable
- en: When the `Observable` itself creates the procedure or, say, `Observable` produces
    the data stream itself, it is said to be cold `Observable`. Generally `Observable`
    is lazy in nature, meaning it only emits the data when any `Observer` subscribes
    to it. Cold `Observable` always starts a fresh execution for each subscriber.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Observable`本身创建程序或，比如说，`Observable`产生数据流本身时，它被称为冷`Observable`。一般来说，`Observable`是惰性的，这意味着它只有在任何观察者订阅它时才会发出数据。冷`Observable`总是为每个订阅者启动新的执行。
- en: In other words, cold `Observable` emits separate data/event streams for individual
    Observers. All examples we have seen so far were of a cold `Observable` type,
    where we have created a data stream with the `just()` or `create()` method. Let's
    see how cold `Observable` works for more than one Observer subscribed, with the
    following example.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，冷`Observable`为每个观察者发出单独的数据/事件流。我们迄今为止看到的所有示例都是冷`Observable`类型，其中我们使用`just()`或`create()`方法创建数据流。让我们看看以下示例，看看冷`Observable`在多个观察者订阅时的表现。
- en: '[PRE12]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this code, the data is created by `Observable` itself so it is called **cold
    Observable**.  We have subscribed two different Observers. When you run this code,
    you will get an output as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，数据是由`Observable`本身创建的，因此被称为**冷Observable**。我们订阅了两个不同的观察者。当你运行此代码时，你将得到以下输出：
- en: '![](img/e87f0f89-91c7-4f0c-9e0b-6b8fc87e0818.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e87f0f89-91c7-4f0c-9e0b-6b8fc87e0818.png)'
- en: Cold `Observable` provides a separate data stream for each `Observer` so when
    we applied the filter for first `Observer` there is no effect in the second `Observer`.
    Also if there are more than one `Observer`, then `Observable` will emit the sequence
    of data to all observers one by one.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 冷`Observable`为每个`Observer`提供单独的数据流，因此当我们为第一个`Observer`应用过滤器时，对第二个`Observer`没有影响。如果有多个`Observer`，那么`Observable`将依次向所有观察者发出数据序列。
- en: Hot Observable
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热Observable
- en: 'Hot `Observable`, on the other hand, has the producer created or activated
    outside of it. Hot `Observable` emits the stream that is shared by all observers.
    Let''s see the example, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，热`Observable`的生产者是在它外部创建或激活的。热`Observable`发出所有观察者共享的流。让我们看看以下示例：
- en: '[PRE13]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `observableInterval` observable emits the event instead of data in this
    example. The `interval` method is used to emit sequential numbers at given intervals.
    We have used `PublishSubject` to make this observable as a hot type.  It can be
    behave as either `Observable` or `Observer`. It is part of the `Observable` chain
    in this case. We then simply add two subscribers to `PublishSubject` with some
    delay in between. You will get an output as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`observableInterval` `Observable`发出的是事件而不是数据。`interval`方法用于在给定的时间间隔内发出连续的数字。我们使用了`PublishSubject`来使这个`Observable`成为热类型。它可以表现为`Observable`或`Observer`。在这种情况下，它是`Observable`链的一部分。然后我们简单地向`PublishSubject`添加两个订阅者，并在它们之间设置一些延迟。你将得到以下输出：
- en: '![](img/a217de70-15dd-4b7d-b788-333717a26b7d.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a217de70-15dd-4b7d-b788-333717a26b7d.png)'
- en: The second `Observer` is subscribed after some delay to the first `Observer`.
    The `Observable` emits the sequential number every two seconds. The second `Observer`
    starts at the fourth second. Hot `Observable` emits just a single stream, which
    is shared across all `Observers`. So, in the case of the second `Observer`, the
    actual value is started from `2` instead of `0` as it subscribes after some time.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`Observer`在延迟之后订阅了第一个`Observer`。`Observable`每两秒发出一个连续数字。第二个`Observer`从第四秒开始。热`Observable`只发出一个流，这个流被所有`Observer`共享。因此，对于第二个`Observer`来说，实际值从`2`开始，而不是`0`，因为它在一段时间后才开始订阅。
- en: 'In this sense, hot `Observable` can be compared with a subscription to a radio
    station. A person who starts listening will not be able to hear what was played
    before he subscribed, as it is common to all subscribers (or say Observers in
    Reactive language). There are other ways to create hot `Observable`. We will see
    one of them as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种意义上，热`Observable`可以与对广播电台的订阅相比较。开始收听的人将无法听到他订阅之前播放的内容，因为它对所有订阅者（或者说在响应式语言中的`Observer`）都是共同的。还有其他创建热`Observable`的方法。以下我们将看到其中一种：
- en: '[PRE14]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this code, hot Observable is created with `ConnectableObservable`. It will
    not start emitting the data until the `connect` method is called on it, making
    it more controllable. Soon after the `connect` method is called, it will start
    a single stream, which is shared across the Observers. You will get an output
    as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，使用`ConnectableObservable`创建了热`Observable`。它不会开始发出数据，直到对其调用`connect`方法，这使得它更加可控。在调用`connect`方法不久之后，它将开始一个单一的流，这个流被所有`Observer`共享。你将得到以下输出：
- en: '![](img/94131b24-bdd1-43f9-8bcd-2faec6bfba0f.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/94131b24-bdd1-43f9-8bcd-2faec6bfba0f.png)'
- en: You can see how the second Observer missed the first few items as it was subscribed
    with some delay. You can convert any cold Observable to `ConnectableObservable`
    by calling the `publish` method on it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到第二个`Observer`是如何因为延迟订阅而错过了前几个项目的。你可以通过在它上面调用`publish`方法将任何冷`Observable`转换为`ConnectableObservable`。
- en: Other ways to get Observable
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取`Observable`的其他方式
- en: 'So far we have seen how to get `Observable` with `just()`, `create()`, and `interval()`.
    However, there are other sources to get the `Observable`. You can get full details
    about each source from at:[https://github.com/ReactiveX/RxJava/wiki/Creating-Observables](https://github.com/ReactiveX/RxJava/wiki/Creating-Observables):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何使用`just()`、`create()`和`interval()`获取`Observable`。然而，还有其他获取`Observable`的来源。你可以从以下位置获取每个来源的详细信息：[https://github.com/ReactiveX/RxJava/wiki/Creating-Observables](https://github.com/ReactiveX/RxJava/wiki/Creating-Observables)
- en: '`range`: If you want to emit a consecutive range of integers, you can use the `Observable.range(int
    from, int to)` call. As its name suggests, it will start emitting a number from
    the start value in increments until the end count is reached.'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`range`：如果你想发出一个连续的整数范围，你可以使用`Observable.range(int from, int to)`调用。正如其名所示，它将从起始值开始以增量增加，直到达到结束计数。'
- en: '`empty`: In a rare situation, you need to create `Observable` that emits nothing
    and calls `onComplete()`. In this case, you can use this source type with the `Observable.empty()` call.'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`empty`：在罕见的情况下，你需要创建一个发出什么也不调用`onComplete()`的`Observable`。在这种情况下，你可以使用这个源类型通过`Observable.empty()`调用。'
- en: '`never`: It is equivalent to `empty` with the difference being that this will
    never make a call to `onComplete()` and keep the `Observable` waiting to emit
    a state. This is also used less frequently.'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`never`：它与`empty`等价，区别在于它永远不会调用`onComplete()`，并使`Observable`等待以发出状态。这也不常使用。'
- en: '`error`: If you wish to create `Observable` that immediately calls `onError()`,
    you can use this source with the `Observable.error()` call. It is used for testing
    purposes mainly.'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`错误`：如果你希望创建一个立即调用`onError()`的`Observable`，你可以使用这个源通过`Observable.error()`调用。这主要用于测试目的。'
- en: '`future`: It was introduced way back and used as a placeholder for the result
    that is not yet produced. `Observable` is more powerful than `future` but if you
    are using old libraries, you can convert `Observable` to `future` with the `Observable.future()`
    call.'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`future`：它是在很久以前引入的，用作尚未生成的结果的占位符。`可观察`对象比`future`更强大，但如果你在使用旧库，可以使用`Observable.future()`调用将`可观察`对象转换为`future`。'
- en: '`defer`: This is basically used to create a separate state for each `Observer`.
    It is useful when the source of the stream is stateful. If you want your observers
    to reflect the changes happening to the  `Observable` state, then you can use
    this source type with an `Observable.defer()` call.'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`defer`：这基本上用于为每个`观察者`创建一个单独的状态。当流源是状态性的时很有用。如果你想让你的观察者反映`可观察`状态的变化，那么你可以使用这个源类型并通过`Observable.defer()`调用。'
- en: '`single`: This type of `Observable` just emits a single value and can be used
    with a `Single.just()` method call.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`single`：这种类型的`可观察`对象只发射一个值，可以使用`Single.just()`方法调用。'
- en: '`maybe`: It is similar to the `single` type, the only difference that it emits
    zero or one data at maximum and can be used with a `Maybe.just()` call.'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`maybe`：它与`single`类型相似，唯一的区别是它最多发射零或一个数据，并且可以使用`Maybe.just()`调用。'
- en: '`fromCallable`: If you want to perform certain actions of computation before
    emitting the data, you can use this source with an `Observable.fromCallable()` call. In
    case any error occurs and you want to pass it to the `Observable` chain through
    an `onError()` call instead of throwing the error, you can use this source type.'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fromCallable`：如果你想在发射数据之前执行某些计算操作，可以使用这个源并通过`Observable.fromCallable()`调用。如果在执行过程中发生任何错误，并且你想通过`onError()`调用将错误传递给`Observable`链而不是抛出错误，可以使用此源类型。'
- en: Operators
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: We have seen operators like map and filter in previous examples. They are basically
    used to perform a specific operation on the stream of data and return new `Observable`
    to form an `Observable` chain. Operators themselves are `Observers` to the `Observable`
    they are called on.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们已经看到了像map和filter这样的运算符。它们基本上用于对数据流执行特定操作，并返回新的`可观察`对象以形成`可观察`链。运算符本身是它们所调用的`可观察`对象的`观察者`。
- en: 'RxJava has a rich set of operators used to perform various operations with
    the following categories:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava有一套丰富的运算符，用于执行以下类别的各种操作：
- en: '**Creating observables:** The set of operators used to create new `Observable`.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建可观察对象**：用于创建新`可观察`对象的一组运算符。'
- en: '**Transforming observables:** Operators used to transform items emitted by
    observables they called upon.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换可观察对象**：用于转换它们所调用的可观察对象发射的项目。'
- en: '**Filtering observable:** Operators used to emit selective data.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤可观察对象**：用于发射选择性数据的运算符。'
- en: '**Combining observable:** Used to combine multiple source observables to form
    a single `Observable`.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合可观察对象**：用于将多个源可观察对象组合成一个单一的`可观察`对象。'
- en: '**Error handling:** Operators that are used to recover from the error condition
    notified from `Observable`.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理**：用于从`可观察`对象通知的错误条件中恢复的运算符。'
- en: '**Utility Operator:** Used to perform some miscellaneous operations with `Observable`.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实用运算符**：用于对`可观察`对象执行一些杂项操作。'
- en: '**Conditional and Boolean operators:** Used to evaluate one or more `Observable`
    or even emitted items.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件运算符和布尔运算符**：用于评估一个或多个`可观察`对象或甚至已发射的项目。'
- en: '**Mathematical and aggregate:** Operators used to perform various operations
    on the entire sequence of emitted data.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数学和聚合**：用于对整个发射数据序列执行各种操作的运算符。'
- en: 'It is good to visit: [http://reactivex.io/documentation/operators.html](http://reactivex.io/documentation/operators.html),
    [to get full details about each of the operators, instead of having details listed
    here.](http://reactivex.io/documentation/operators.html)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 值得访问：[http://reactivex.io/documentation/operators.html](http://reactivex.io/documentation/operators.html)，[以获取每个运算符的完整详细信息，而不是在这里列出详细信息。](http://reactivex.io/documentation/operators.html)
- en: Project Reactor
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 Reactor
- en: The Reactor can be called the reactive library on top of the JDK. Java doesn’t
    support Reactive Programming natively, and Reactor is one of the many libraries
    out there. Reactor comes from the open source group Pivotal and conforms to the
    Reactive Streams standard. It is built on Java 8 and ReactiveX vocabulary.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor可以称为JDK之上的反应式库。Java不支持原生的反应式编程，Reactor是众多库之一。Reactor来自开源组织Pivotal，并符合反应式流标准。它是基于Java
    8和ReactiveX词汇构建的。
- en: It is worthwhile to note here that, although asynchronous seems to be an important
    attribute for  Reactive Programming, the Reactor doesn't force you to go asynchronous/synchronous,
    as it supports both. It depends on the scheduler chosen. That choice is yours.
    In order to understand the Reactor in a better way, we need to understand Reactive
    Streams in more detail.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，尽管异步似乎是对 Reactive Programming 重要的属性，但 Reactor 并不强迫您选择异步/同步，因为它支持两者。这取决于选择的调度器。选择权在您手中。为了更好地理解
    Reactor，我们需要更详细地了解 Reactive Streams。
- en: Reactor features
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reactor 功能
- en: 'Reactor provides event-based architecture and is used to handle a large volume
    of requests concurrently and asynchronously, making a non-blocking and backpressure
    equipped system. With the Project Reactor, you have no need to implement Reactive
    Streams yourself as it provides a set of modules, which are embedded and interoperable. It
    provides the following stunning features:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor 提供基于事件的架构，用于处理大量并发和异步请求，从而构建一个非阻塞和具备背压的系统。使用 Project Reactor，您无需自己实现
    Reactive Streams，因为它提供了一套嵌入式且可互操作的模块。它提供了以下令人惊叹的功能：
- en: Handling data stream with high volume
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理高容量数据流
- en: Project Reactor is capable of providing an API support for specific data cardinality,
    ranging from generating endless streams to publishing just a single data entry.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Project Reactor 能够提供特定数据基数（从生成无限流到发布单个数据条目）的 API 支持。
- en: Instead of waiting for the entire data stream to process, Project Reactor enables
    the subscribers to handle the elements of a stream as they arrive. This makes
    the data processing operation more flexible and optimized by improving resource
    utilization. The memory required to be allocated to a subscriber is limited because
    data processing happens in a subset of items arriving at a particular time, rather
    than processing entire data streams in one go. Also, this makes the system more
    responsive as the results will start as soon as the first set of elements is received,
    instead of waiting until all items have been received and processed to deliver
    a final output.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Project Reactor 允许订阅者在数据流元素到达时即时处理它们，而不是等待整个数据流处理完毕。这使得数据处理操作更加灵活和优化，通过提高资源利用率。分配给订阅者的内存需求有限，因为数据处理发生在特定时间到达的项的子集中，而不是一次性处理整个数据流。这也使得系统更加响应，因为结果将从接收到的第一组元素开始，而不是等待所有项目接收和处理完毕后交付最终输出。
- en: Push-pull mechanism
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推/拉机制
- en: Project Reactor has good assistance for proving a push/pull feature. There are
    practical scenarios where consumers intake the data at a slower rate than the
    producer emits them. In this case, the producer will raise the event and wait
    for Observers to pull it. In some situations, the consumer works faster than the
    producer. To handle it, consumers wait for the events to be pushed from the producer
    side. Project Reactor enables this flow to be dynamic in nature whenever necessary.
    It will be controlled by the rate of production and consumption.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Project Reactor 对实现推/拉功能提供了良好的支持。存在一些实际场景，其中消费者以比生产者发射数据更慢的速度摄取数据。在这种情况下，生产者将引发事件并等待观察者拉取它。在某些情况下，消费者的工作速度比生产者快。为了处理这种情况，消费者等待从生产者端推来的事件。Project
    Reactor 允许在必要时使这种流程具有动态性。它将由生产和消费的速度来控制。
- en: Handling concurrency independently
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立处理并发
- en: The reactor execution paradigm is capable of handling concurrency independently,
    which truly makes it concurrency agnostic. The Reactor library handles the data
    stream in a more abstract way, rather than talking about how to execute different
    types of streams. The transactions happening during various operations are safe
    out of the box. Reactor provides a set of operators that handle different synchronous
    streams in different ways.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor 执行范式能够独立处理并发，这真正使其与并发无关。Reactor 库以更抽象的方式处理数据流，而不是讨论如何执行不同类型的流。在各种操作期间发生的交易是默认安全的。Reactor
    提供了一套操作符，以不同的方式处理不同的同步流。
- en: Operators
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作符
- en: Reactor provides a set of operators that plays a vital role in the execution
    model by handling different synchronous streams in different ways. These operators
    can be used to filter, map, select, transform, and combine the data streams. They
    can be combined with other operators to build high-level, easy-to-operate, and
    highly customized data pipelines to process streams in the way you want.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor 提供了一套操作符，通过以不同的方式处理不同的同步流，在执行模型中发挥着至关重要的作用。这些操作符可用于过滤、映射、选择、转换和组合数据流。它们可以与其他操作符结合使用，构建高级、易于操作和高度定制的数据管道，以您希望的方式处理流。
- en: Reactor sub-projects
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reactor 子项目
- en: 'Project reactor consists of various sub-projects as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Project Reactor 由以下子项目组成：
- en: '**Reactor Core:** This project provides an implementation of Reactive Streams
    specification. Spring Framework 5.0 provides support for Reactive Programming
    with the Reactor Core sub-project as a foundation.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反应堆核心：** 此项目提供了一个响应式流规范的实现。Spring Framework 5.0 通过以 Reactor Core 子项目为基础，提供了对响应式编程的支持。'
- en: '**Reactor Test:** This contains necessary utilities for test verification.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reactor Test：** 它包含测试验证所需的必要工具。'
- en: '**Reactor Extra:** On top of Reactor Core, this project provides various operators
    to work on the data stream to perform required operations.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reactor Extra：** 在 Reactor Core 之上，此项目提供了各种操作符，用于在数据流上执行所需操作。'
- en: '**Reactor IPC:** This project provides backpressure furnished and non-blocking
    inter-process communication support over various network protocols, like HTTP,
    TCP, UDP, and web sockets. Due to this nature, this module is also helpful when
    building asynchronous microservice architectures.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reactor IPC：** 此项目在各种网络协议（如 HTTP、TCP、UDP 和 WebSocket）上提供带背压的非阻塞进程间通信支持。由于这种特性，此模块在构建异步微服务架构时也很有帮助。'
- en: '**Reactor Netty: **It is used to provide a reactive feature to Netty, a client
    server framework to develop network applications.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reactor Netty：** 它用于向 Netty（一个用于开发网络应用程序的客户端服务器框架）提供响应式功能。'
- en: '**Reactive Kafka: **It is a reactive API for Apache Kakfa-based projects. It
    is used to communicate with Kakfa in a non-blocking and functional way.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reactive Kafka：** 它是基于 Apache Kafka 的项目的响应式 API。它用于以非阻塞和函数式的方式与 Kafka 进行通信。'
- en: '**Reactive RabbitMQ: **This project is used to equip RabbitMQ  (a message broker
    system) with reactive capabilities.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reactive RabbitMQ：** 此项目用于为 RabbitMQ（一个消息代理系统）提供响应式功能。'
- en: Reactor types
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reactor 类型
- en: 'Project Reactor is built with two core types based on the number of elements
    they process. They are considered as main building blocks to create a Reactive
    System using Reactor. They are `Flux` and `Mono`. They both implement the `Publisher<T>`
    interface and conform to Reactive Streams specification, and  are furnished with reactive-pull
    and back-pressure facility. They also have several other useful methods. Let''s
    explore the details as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Project Reactor 是基于它们处理的元素数量构建的两个核心类型。它们被认为是使用 Reactor 创建响应式系统的主构建块。它们是 `Flux`
    和 `Mono`。它们都实现了 `Publisher<T>` 接口，并符合响应式流规范，并配备了反应式拉取和背压功能。它们还有其他一些有用的方法。以下将详细探讨：
- en: '`Flux`: It can be considered the equivalent of RxJava''s Observable and can
    emit zero or more items, ending successfully or with an error signal. In short,
    it represents asynchronous event streams having zero or more elements.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flux`：它可以被认为是 RxJava 的 Observable 的等价物，可以发出零个或多个项目，以成功或错误信号结束。简而言之，它代表具有零个或多个元素的异步事件流。'
- en: '`Mono`: It can emit, at most, one element at a time. It is equivalent of the `Single`
    and `Maybe` Observable type from the RxJava side. A `Mono` type can be used for
    one-to-one request-response model implementation; for example, a task wish to
    send a completion signal can use a `Mono` type reactor.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mono`：它一次最多只能发出一个元素。它与 RxJava 侧的 `Single` 和 `Maybe` Observable 类型等价。`Mono`
    类型可用于一对一请求-响应模型实现；例如，一个希望发送完成信号的作业可以使用 `Mono` 类型反应器。'
- en: The clear difference between the number of elements a reactor type can handle
    provides useful semantics and makes it an easy decision to choose which reactor
    type. If the model is sort of *fire and forget* then choose the `Mono` type. If
    execution is dealing with multiple data items or elements in the stream, then
    the `Flux` type is more appropriate.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 反应堆类型可以处理元素数量的明显差异提供了有用的语义，并使得选择哪种反应堆类型变得容易。如果模型是某种 *fire and forget*，则选择 `Mono`
    类型。如果执行涉及流中的多个数据项或元素，则 `Flux` 类型更为合适。
- en: Additionally, various operators play a vital role in deciding the type of reactor.
    For example, calling a`single()` method on a `Flux<T>` type will return `Mono<T>`,
    while concatenating multiple entities of type `Mono<T>` together with `concatWith()`
    will result in the `Flux<T>` type. The reactor type can influence which operators
    we can use with it. For example, some operators are applicable to either one of  `Flux`
    or `Mono` while others can be used for both of them.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，各种操作符在决定反应器类型方面起着至关重要的作用。例如，在 `Flux<T>` 类型上调用 `single()` 方法将返回 `Mono<T>`，而使用
    `concatWith()` 将多个 `Mono<T>` 类型的实体连接起来将得到 `Flux<T>` 类型。反应器类型可以影响我们可以与之一起使用的操作符。例如，一些操作符适用于
    `Flux` 或 `Mono` 中的任何一个，而另一些则可以用于两者。
- en: Reactor in action
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reactor 动作
- en: 'Let''s learn more about the reactor API with a practical example. Create a
    new Maven project similar to what we created in the *Anatomy of RxJava* section.
    The current version of the Project Reactor at the time of writing  is 3.2.6. We
    need to provide a Maven dependency for the reactor as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个实际示例来了解更多关于反应器 API 的信息。创建一个新的 Maven 项目，类似于我们在 *RxJava 的解剖结构* 部分中创建的项目。截至写作时，Project
    Reactor 的当前版本是 3.2.6。我们需要为反应器提供一个 Maven 依赖项，如下所示：
- en: '[PRE15]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When we define a Reactor dependency, Reactive Streams JAR will be added as
    a transitive dependency. Next, is to add a Java class as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个 Reactor 依赖项时，Reactive Streams JAR 将作为传递依赖项添加。接下来，需要添加一个 Java 类，如下所示：
- en: '[PRE16]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We have used `Flux` and `Mono` to create various publishers. The  `just()` method
    is used to populate the stream. We can also reach the iterable types (like `List`,
    `Set`, `n`) to form a data stream with the `fromIterable()` method. A few other
    methods like `from()`, `fromArray()` , and `fromStream()` are used to construct
    data streams from other producers, arrays, and existing Java streams, respectively,
    and can be used as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用 `Flux` 和 `Mono` 创建了各种发布者。`just()` 方法用于填充流。我们还可以使用 `fromIterable()` 方法访问可迭代类型（如
    `List`、`Set`、`n`），并通过该方法形成数据流。还有一些其他方法，如 `from()`、`fromArray()` 和 `fromStream()`，分别用于从其他生产者、数组以及现有的
    Java 流构建数据流，并可以如下使用：
- en: '[PRE17]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The subscriber can be plugged with the `subscribe()` method. This is similar
    to what we have done with Observable in RxJava. With `Flux`, we can create a publisher
    with the finite or infinite stream.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者可以通过 `subscribe()` 方法连接。这与我们在 RxJava 中的 Observable 所做的是类似的。使用 `Flux`，我们可以创建一个有限或无限的流发布者。
- en: 'We can also control to generate a stream with a value or just an empty stream.
    All of that can be done with a few utility methods provided by the `Flux` class
    as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以控制生成带有值的流或只是一个空流。所有这些都可以通过 `Flux` 类提供的几个实用方法来完成，如下所示：
- en: '`Flux.empty()`: It is used to generate an empty stream having no values and
    only executes completion events.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flux.empty()`: 它用于生成一个没有值且只执行完成事件的空流。'
- en: '`Flux.error()`: It is used to signal the error condition by generating an error
    stream with no any value but only errors.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flux.error()`: 它通过生成一个没有任何值但只有错误的错误流来表示错误条件。'
- en: '`Flux.never()`: As its name suggests, it generates a stream with no events
    of any type.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flux.never()`: 如其名所示，它生成一个没有任何类型事件的流。'
- en: '`Flux.defer()`: It is used to construct a publisher when a subscriber makes
    the subscription to `Flux`. In short, it is lazy in nature.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flux.defer()`: 当订阅者订阅 `Flux` 时，它用于构建发布者。简而言之，它是惰性的。'
- en: Types of subscribers
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅者类型
- en: The `Flux` and `Mono` classes both allow Java 8 lambda expressions as a subscriber.
    They also support various overloaded versions of the `subscribe()` method, as
    per the following code.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flux` 和 `Mono` 类都允许使用 Java 8 lambda 表达式作为订阅者。它们还支持 `subscribe()` 方法的各种重载版本，如下面的代码所示。'
- en: '[PRE18]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `Flux` class is created with list of strings. There are five different
    variations of using the `subscribe()` method, and each has provision to capture
    various events. The detail is as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flux` 类使用字符串列表创建。`subscribe()` 方法有五种不同的使用方式，每种方式都提供了捕获各种事件的能力。具体如下：'
- en: The first version does not consume any event.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种版本不消耗任何事件。
- en: The second variant consumes the value event and it is defined with a lambda
    expression.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种变体消耗值事件，并且它使用 lambda 表达式定义。
- en: The third `subscribe()` method listens to error events as a second argument
    along with the value events. We are simply printing stack-trace through lambda
    expressions.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个 `subscribe()` 方法作为第二个参数监听错误事件以及值事件。我们只是通过 lambda 表达式简单地打印堆栈跟踪。
- en: The fourth one consumes value, error, and completion events. On completion of
    a data stream, the completion event will be executed, which we listen to with
    a lambda expression.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个版本消耗值、错误和完成事件。在数据流完成时，将执行完成事件，我们通过 lambda 表达式来监听它。
- en: The fifth version consumes value, error, completion, and subscription events.
    The last parameter of the `Subscription` type makes this version of `subscribe()`
    a special case. The `Subscription` type has a method called `request()`. The publisher
    will not send any event until, and unless, the subscriber sends a demand signal
    with a `Subscription.request()` call. This is only applicable if `Subscription`
    is defined for the subscriber. We have to make a method call as `s.request(5L)`,
    meaning the publisher can only send five elements. It is less than than the total
    value in publisher and fires a completion event. In our case, the total elements
    in a data stream is five, and so it will call a completion event. If you pass
    fewer than five, you will not get a completion event call.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五个版本消耗值、错误、完成和订阅事件。`Subscription` 类型的最后一个参数使这个版本的 `subscribe()` 成为特例。`Subscription`
    类型有一个名为 `request()` 的方法。发布者不会发送任何事件，除非和直到订阅者通过 `Subscription.request()` 调用发送一个需求信号。这仅适用于为订阅者定义了
    `Subscription` 的情况。我们必须进行方法调用 `s.request(5L)`，这意味着发布者只能发送五个元素。这少于发布者中的总元素数，并触发完成事件。在我们的例子中，数据流中的总元素数是五个，因此它将调用完成事件。如果你传递少于五个，你将不会收到完成事件调用。
- en: Custom subscribers
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义订阅者
- en: 'In a certain scenario, calling a `Subscribe` method on `Publisher` is not appropriate
    and you may want to write custom subscriber with own handling. Reactor framework
    provides support for defining custom subscribers by extending the `reactor.core.publisher.BaseSubscriber<T>` abstract
    class. You don''t need to implement the `Subscribe` interface of Reactive Streams
    specification directly. Instead, you need to just extend this class to apply the
    custom implementation as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景下，在 `Publisher` 上调用 `Subscribe` 方法是不合适的，你可能想编写具有自己处理的自定义订阅者。Reactor 框架通过扩展
    `reactor.core.publisher.BaseSubscriber<T>` 抽象类来提供定义自定义订阅者的支持。你不需要直接实现 Reactive
    Streams 规范的 `Subscribe` 接口。相反，你需要仅扩展这个类，如下所示来应用自定义实现：
- en: '[PRE19]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The  `BaseSubscriber` class provides various hook methods, which represent the
    corresponding event. It is a placeholder to provide a custom implementation. Implementing
    these methods is similar to using various versions of the `subscribe()` method
    that we have seen in the *Type of subscriber* section. For example, if you only
    implement the `hookOnNext`, `hookOnError` , and `hookOnComplete` methods, then
    it is equivalent to the fourth version of `subscribe()`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseSubscriber` 类提供了各种钩子方法，这些方法代表相应的事件。它是一个占位符，用于提供自定义实现。实现这些方法类似于使用我们在“订阅者类型”部分看到的
    `subscribe()` 方法的各种版本。例如，如果你只实现了 `hookOnNext`、`hookOnError` 和 `hookOnComplete`
    方法，那么它就等同于 `subscribe()` 的第四个版本。'
- en: 'The  `hookOnSubscribe()` method facilitates a subscription event. The backpressure
    is provided with `subscription.request()`. You can request as many element, as
    you want. For example, update the code for the `hookOnSubscribe()` method as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`hookOnSubscribe()` 方法促进了订阅事件。背压通过 `subscription.request()` 提供。你可以请求任意数量的元素。例如，按照以下方式更新
    `hookOnSubscribe()` 方法的代码：'
- en: '[PRE20]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We are requesting records one-by-one by calling `subscription.request(1)` in
    a loop. To get an idea how it works, we put a two-second delay in between so you
    will get a record for every two requests. Once all data is completed, it will
    trigger the completion event and the `hookOnComplete()` method will be called.
    The output would be as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在循环中调用 `subscription.request(1)` 逐个请求记录。为了了解它是如何工作的，我们在请求之间加入了两秒的延迟，这样你将每两个请求得到一个记录。一旦所有数据完成，它将触发完成事件，并调用
    `hookOnComplete()` 方法。输出将如下所示：
- en: '![](img/82109b35-b274-45f0-a097-21e7a1dee3bb.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/82109b35-b274-45f0-a097-21e7a1dee3bb.png)'
- en: Reactor lifecycle methods
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reactor 生命周期方法
- en: 'Reactor provides lifecycle methods to capture various events happening in publisher-subscriber
    communication. Those lifecycle methods are aligned with Reactive Streams specification.
    Reactor lifecycle methods can be used to hook custom implementation for a given
    event. Let''s understand how that works with the following code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor 提供了生命周期方法来捕获发布者-订阅者通信中发生的各种事件。这些生命周期方法与 Reactive Streams 规范保持一致。Reactor
    生命周期方法可用于为给定事件钩子自定义实现。让我们通过以下代码了解它是如何工作的：
- en: '[PRE21]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We are creating the `Flux` object with data from a list and then calling various
    lifecycle methods, like `doOnComplete()`, `doOnNext()`,  `doOnSubscribe()`, `doOnError()`,
    and `doOnTerminate()` in a chain. Finally, we call the `subscribe()` method, which
    does not consume the events, but all lifecycle methods will be executed as appropriate
    events are triggered.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用列表中的数据创建`Flux`对象，然后以链式调用各种生命周期方法，如`doOnComplete()`、`doOnNext()`、`doOnSubscribe()`、`doOnError()`和`doOnTerminate()`。最后，我们调用`subscribe()`方法，它不会消费事件，但所有生命周期方法将在适当的事件触发时执行。
- en: 'This is similar to the custom subscriber implementation in the *Custom subscribers*
    section. You will see a similar output. The details of these lifecycle methods
    are as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这与*自定义订阅者*部分中的自定义订阅者实现类似。你将看到类似的输出。这些生命周期方法的详细信息如下：
- en: '`doOnComplete()`: Once all the data is received by the `Subscriber`, this method
    will be called.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnComplete()`: 一旦`Subscriber`接收到了所有数据，这个方法就会被调用。'
- en: '`doOnNext()`: This method will listen to the value event coming from the producer.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnNext()`: 这个方法将监听来自生产者的值事件。'
- en: '`doOnSubscribe()`: Used to plug  `Subscription`. It can control the backpressure
    by defining how many more elements are required with a `subscription.request()`
    call.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnSubscribe()`: 用于连接`Subscription`。它可以通过定义使用`subscription.request()`调用需要多少更多元素来控制背压。'
- en: '`doOnError()`: If any error occurs, this method will be executed.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnError()`: 如果发生任何错误，这个方法将被执行。'
- en: '`doOnTerminate()`: Once the operation is completed, either successfully or
    with error, this method will be called. It will not be considered on a manual
    cancellation event.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnTerminate()`: 一旦操作完成，无论是成功还是出错，这个方法将被调用。在手动取消事件中不会考虑它。'
- en: '`doOnEach()`: As the name suggests, it will be called for all `Publisher` events
    raised during stream processing.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnEach()`: 如其名所示，它将在流处理期间引发的所有`Publisher`事件上被调用。'
- en: '`doFinally()`: This will be called on stream closures due to error, cancellation,
    or successful completion of events.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doFinally()`: 由于错误、取消或事件的成功完成，这个方法将在流关闭时被调用。'
- en: Ratpack
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ratpack
- en: Ratpack is set of Java libraries which are event driven, non-blocking, high
    performance, and asynchronous in nature to build scalable services with HTTP.
    It conforms to the Reactive Streams specification, meaning it comes with interoperability
    out of the box. It is built on Netty—a framework to build a client-server application
    over the network with quick and easy development.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Ratpack是一组Java库，它们是事件驱动的、非阻塞的、高性能的，并且本质上是异步的，用于构建具有HTTP的扩展服务。它符合Reactive Streams规范，这意味着它自带互操作性。它是基于Netty构建的——一个用于在网络中构建客户端-服务器应用程序的框架，具有快速和简单开发的特点。
- en: It is a web framework to develop efficient and lightweight JVM-based applications.
    It has its own testing library to easily set up test cases. Spring provides support
    for Ratpack. You can get more information about Ratpack from its official site:  [https://ratpack.io](https://ratpack.io).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个用于开发高效和轻量级基于JVM的应用程序的Web框架。它有自己的测试库，可以轻松设置测试用例。Spring支持Ratpack。你可以从其官方网站了解更多关于Ratpack的信息：[https://ratpack.io](https://ratpack.io)。
- en: Akka stream
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Akka stream
- en: Akka stream provides an implementation of Reactive Streams specifications on
    top of the Akka toolkit that uses Actor patterns for  the concurrency execution
    model. It processes the stream of data asynchronously and in a non-blocking backpressure
    way with Actor. Apart from Java, Akka also works well with Scala language. Explore
    more about the Akka stream at the link [https://akka.io/docs](https://akka.io/docs).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Akka stream在Akka工具包之上提供了一个Reactive Streams规范的实现，它使用Actor模式进行并发执行模型。它使用Actor异步和非阻塞地处理数据流，并提供了背压。除了Java之外，Akka还与Scala语言很好地协同工作。更多关于Akka
    stream的信息，请访问链接[https://akka.io/docs](https://akka.io/docs)。
- en: Vert.x
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vert.x
- en: Vert.x is another tool kit provided by the Eclipse Foundation project used to
    build a JVM-based Reactive System. It also provides an implementation of Reactive
    Streams specifications similar to Ratpack. Vert.x supports and allows the use
    of RxJava to build a Reactive System. Needless to say, Vert.x is event based and
    non-blocking in nature. It supports various programming languages, like Java,
    JavaScript, Ruby, Groovy, Ceylon, Scala, Kotlin, and so on. You can learn more
    about it at:  [https://vertx.io](https://vertx.io).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x是Eclipse Foundation项目提供的另一个工具包，用于构建基于JVM的响应式系统。它还提供了类似于Ratpack的Reactive
    Streams规范的实现。Vert.x支持并允许使用RxJava构建响应式系统。不用说，Vert.x本质上是基于事件的和非阻塞的。它支持各种编程语言，如Java、JavaScript、Ruby、Groovy、Ceylon、Scala、Kotlin等。更多关于它的信息，请访问[https://vertx.io](https://vertx.io)。
- en: Reactive support in Spring Framework
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring框架中的响应式支持
- en: Spring is a modular framework and used to build every aspect of an application
    from the web to the persistence layer. Each module is considered as a sub-framework
    and targeted for a specific area of development. For example, to support a web
    layer with a servlet API,  the Spring MVC module was included in the Spring Framework.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Spring是一个模块化框架，用于构建应用程序的各个方面，从Web层到持久化层。每个模块都被视为一个子框架，针对特定的开发领域。例如，为了支持使用Servlet
    API的Web层，Spring MVC模块被包含在Spring框架中。
- en: Similarly, to support a reactive stack in the web layer, Spring WebFlux was
    introduced in Spring Framework 5\. It is fully non-blocking, backpressure, asynchronous,
    and compliant with Reactive Streams specifications. It can be run on Servlet 3.1+,
    Netty, and Undertow containers.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，为了在Web层支持响应式堆栈，Spring框架5.0引入了Spring WebFlux。它是完全非阻塞的、支持背压、异步的，并且符合响应式流规范。它可以在Servlet
    3.1+、Netty和Undertow容器上运行。
- en: Spring Framework has both the stacks, Spring Web MVC and spring-WebFlux, and
    developers are free to use either of them, or in some scenarios to mix both of
    them to develop a Spring-based web application. The typical example would be using
    spring MVC controller with reactive WebClient; we will talk more about this in
    the latter part of this chapter.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架同时提供了两个堆栈，即Spring Web MVC和Spring WebFlux，开发者可以自由选择使用其中的任何一个，或者在某些场景下混合使用它们来开发基于Spring的Web应用程序。一个典型的例子是使用Spring
    MVC控制器与响应式WebClient；我们将在本章的后续部分更多地讨论这一点。
- en: Spring WebFlux
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring WebFlux
- en: Spring 5 impressively supports creating a Reactive System with Spring WebFlux
    . It is a new reactive web application framework, developed based on the Project
    Reactor API and can also be used to build microservices. The most remarkable and
    direct benefit of making any application reactive is to bring asynchronous qualities
    to it.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 5通过Spring WebFlux令人印象深刻地支持创建响应式系统。它是一个基于Project Reactor API开发的新响应式Web应用程序框架，也可以用来构建微服务。将任何应用程序变为响应式的最显著和直接的好处是为其带来异步特性。
- en: Non-reactive and traditional Java-based applications use thread mechanisms for
    asynchronous and parallel programming. However, usage of the thread is not competent
    and scalable in any manner. On the other hand, Spring WebFlux encourages event
    loop-based programming, which is asynchronous and non-blocking in manner. This
    section introduces WebFlux in the context of the Spring Framework and Reactive
    Programming.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 非响应式和基于传统的Java应用程序使用线程机制进行异步和并行编程。然而，线程的使用在任何方式上都不够高效和可扩展。另一方面，Spring WebFlux鼓励基于事件循环的编程，这种方式是异步和非阻塞的。本节在Spring框架和响应式编程的背景下介绍了WebFlux。
- en: Spring MVC versus Spring WebFlux
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC与Spring WebFlux的比较
- en: Spring MVC has been part of the Spring Framework since version 2, and since
    then, has been a de facto standard when developing web-based applications with
    Spring Framework. To support Reactive Programming, Spring has introduced the WebFlux
    module. Therefore, it is important to understand the similarities and differences
    between Spring MVC and Spring WebFlux.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC自2.0版本以来一直是Spring框架的一部分，并且从那时起，在用Spring框架开发基于Web的应用程序时，已经成为事实上的标准。为了支持响应式编程，Spring引入了WebFlux模块。因此，了解Spring
    MVC和Spring WebFlux之间的相似之处和不同之处非常重要。
- en: The Spring team has done it the hard way and kept the WebFlux syntax similar
    to the Spring MVC, but under the hood it has completely new technology. One of
    the prime differences between these two modules is the mechanism by which they
    handle the request. Spring MVC is based on a pure servlet API and works with a
    thread pool. This means that, every request has one thread from the controller
    to the persistence layer and may be blocked for the resources it needs.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Spring团队采取了艰难的方式，使WebFlux的语法与Spring MVC相似，但在底层它采用了完全新的技术。这两个模块之间主要的区别在于它们处理请求的机制。Spring
    MVC基于纯Servlet API，并使用线程池。这意味着每个请求从控制器到持久化层都有一个线程，并且可能因为所需的资源而被阻塞。
- en: However, Spring WebFlux is based on reactive architecture and works with the
    event loop mechanism, providing non-blocking support out of the box. In the event
    loop mechanism, everything happens as a reaction to the event. It is similar to
    a callback function; when any event happens, the callback function gets triggered.
    The concept event loop was introduced by Node.js.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Spring WebFlux基于响应式架构，并使用事件循环机制，提供开箱即用的非阻塞支持。在事件循环机制中，所有事情都是对事件的反应。它类似于回调函数；当任何事件发生时，回调函数就会被触发。事件循环的概念是由Node.js引入的。
- en: Internally, WebFlux needs servlet API support, which works as an adapter layer,
    so that WebFlux can be deployed on both servlet and non-servlet containers. Spring
    MVC is built on top of a servlet API, which is synchronous (like Filter, Servlet,
    and so on) by nature and also performs blocking IO streams.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，WebFlux需要servlet API支持，它作为一个适配层，使得WebFlux可以部署在servlet和非servlet容器上。Spring
    MVC建立在servlet API之上，本质上是一种同步的（如Filter、Servlet等）API，并且执行阻塞IO流。
- en: WebFlux, on other hand, is developed on asynchronous API (WebHandler, WebFilter,
    and so on) and non-blocking IO mechanisms, like `Flux` and `Mono` , which are
    used to handle the stream with a maximum of one value and many elements, respectively.
    Although Spring WebFlux is based on reactor and used by default, it also supports
    other reactive implementations, like Java 9 Flow API, RxJava, and Akka stream.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，WebFlux是基于异步API（WebHandler、WebFilter等）和非阻塞IO机制（如`Flux`和`Mono`）开发的，分别用于处理最多一个值和多个元素的流。尽管Spring
    WebFlux基于reactor并且默认使用，但它也支持其他响应式实现，如Java 9 Flow API、RxJava和Akka stream。
- en: Both the frameworks, however, support some common features like using some annotation
    (like `@Controller` and `@RequestMapping`) and support for some well-known servers.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这两个框架都支持一些共同特性，例如使用一些注解（如`@Controller`和`@RequestMapping`）以及对一些知名服务器的支持。
- en: We are talking about Reactive Programming support in String with WebFlux; it
    does not mean Spring MVC is of no use. Both frameworks are addressing separate
    concern to the application. Like any framework, WebFlux may not be the best choice
    for all the application types.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在谈论Spring中WebFlux对响应式编程的支持；这并不意味着Spring MVC没有用处。这两个框架都在解决应用的不同关注点。就像任何框架一样，WebFlux可能不是所有应用类型的最佳选择。
- en: So instead of choosing the framework by its features, you need to select it
    as per the requirement. There is absolutely no need to port your existing Spring
    MVC application completely to WebFlux if it is working perfectly well. The excellent
    part of WebFlux is that it can be used in conjunction with Spring MVC (if needed
    explicitly) without any problems.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与其根据其特性选择框架，不如根据需求选择。如果你的现有Spring MVC应用运行良好，完全没有必要将其完全迁移到WebFlux。WebFlux的出色之处在于，它可以与Spring
    MVC（如果需要明确指定）一起使用，而不会出现任何问题。
- en: Apart from this, if your existing Spring MVC application has a dependency on
    other parts that are synchronous and blocking in nature then, adapting WebFlux
    specific changes will obstruct from taking full benefits of reactive paradigm.
    You can decide, however, to pick WebFlux if your application is mainly handling
    the stream of data. If scalability and performance are what you are looking for
    then you can use WebFlux specific changes in your application.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，如果你的现有Spring MVC应用依赖于其他本质上是同步和阻塞的部分，那么适应WebFlux特定的更改将阻碍充分利用响应式范式。然而，你可以决定，如果你的应用主要是处理数据流，那么可以选择WebFlux。如果你在寻找可扩展性和性能，那么你可以在应用中使用WebFlux特定的更改。
- en: Reactive span across Spring modules
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式跨越Spring模块
- en: 'By introducing a reactive web framework, WebFlux , Spring also made necessary
    changes in other modules to provide first-class support for WebFlux. Spring Boot,
    Spring Security, Thymeleaf, and Spring Data are among the few modules that are
    equipped with WebFlux capabilities. This can be described with the following diagram:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入响应式Web框架WebFlux，Spring也对其他模块进行了必要的修改，以提供对WebFlux的一级支持。Spring Boot、Spring
    Security、Thymeleaf和Spring Data是少数几个具备WebFlux功能的模块。这可以用以下图表来描述：
- en: '![](img/7676979f-25e9-46da-aceb-6a29a9fef044.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7676979f-25e9-46da-aceb-6a29a9fef044.png)'
- en: Spring Data has adopted a reactive paradigm and started supporting infinite
    streams from the database with the `@Tailable`annotation. Spring Data JPA is mostly
    associated with RDBMS, which is blocking in nature so it cannot support Reactive
    Programming.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data采用了响应式范式，并开始支持使用`@Tailable`注解从数据库中获取无限流。Spring Data JPA主要与RDBMS相关联，本质上是一种阻塞的，因此它不能支持响应式编程。
- en: Spring MVC is inherently blocking in nature; however, we can use Reactive Programming
    for some of the parts, which can be converted to be reactive. For example, the
    Spring MVC controller can be equipped with the `Flux` and `Mono` types to handle
    the data stream in a reactive way.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC本质上是一种阻塞的；然而，我们可以对某些部分使用响应式编程，这些部分可以被转换为响应式。例如，Spring MVC控制器可以配备`Flux`和`Mono`类型来以响应式的方式处理数据流。
- en: Apart from this, a few annotations like `@Controller`, `@RequestMapping`, and
    so on are supported in WebFlux so you can convert a Spring MVC application to
    WebFlux in an incremental manner. We will see more details about reactive support
    in Spring Framework through WebFlux by creating a sample application.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，WebFlux还支持一些注解，如`@Controller`、`@RequestMapping`等，因此您可以以增量方式将Spring MVC应用程序转换为WebFlux。我们将通过创建一个示例应用程序来了解Spring框架通过WebFlux提供的更多关于反应式支持细节。
- en: Spring WebFlux application
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring WebFlux应用程序
- en: We will create a sample web application with the WebFlux framework. The application
    will simply access existing student information from a data store. Instead of
    making a fully fledged application, we will focus more on how to access data in
    a reactive manner with the WebFlux framework.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用WebFlux框架创建一个示例Web应用程序。该应用程序将简单地从数据存储中访问现有的学生信息。我们不会创建一个完整的应用程序，而是更多地关注如何使用WebFlux框架以反应式的方式访问数据。
- en: We will use Spring Boot to kickstart the development. For those who are new
    to Spring Boot, it is a tool and part of Spring Horizon, which is designed to
    speed up and simplify the bootstrapping and development of new Spring-based applications.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Spring Boot来启动开发。对于Spring Boot的新手来说，它是一个工具，也是Spring Horizon的一部分，旨在加快和简化基于Spring的新应用程序的启动和开发。
- en: You might have come across bulky XML and other configurations repeatedly in
    Spring projects. The Spring team was well aware of this and has finally developed
    a tool called Spring Boot, aimed at freeing the developer from providing a boilerplate
    configuration, which is not only tedious but time consuming.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能在Spring项目中反复遇到庞大的XML和其他配置。Spring团队对此非常清楚，并最终开发了一个名为Spring Boot的工具，旨在让开发者摆脱提供样板配置的负担，这不仅繁琐，而且耗时。
- en: We will create a sample web application using MongoDB as a data store. While
    working with Reactive Programming, it is recommended to use non-blocking and reactive
    capable datastores, like MongoDB, Couchbase, Cassandra, and so on. We will use
    a tool called **Spring Tool Suite** (**STS**), which is an Eclipse-based IDE.
    It provides support for creating Spring Boot-based applications. Download it from: [https://spring.io/tools3/sts/all](https://spring.io/tools3/sts/all) and
    install it in your local machine.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个使用MongoDB作为数据存储的示例Web应用程序。在处理反应式编程时，建议使用非阻塞和反应式数据存储，如MongoDB、Couchbase、Cassandra等。我们将使用一个名为**Spring
    Tool Suite**（**STS**）的工具，它是一个基于Eclipse的IDE。它提供了创建基于Spring Boot的应用程序的支持。从[https://spring.io/tools3/sts/all](https://spring.io/tools3/sts/all)下载它并在您的本地计算机上安装。
- en: The STS link given here is version 3.x. At the time of writing, the current
    version of STS is 4.x. All the codes created in this book are with STS 3.x so
    the link given is version 3.x. However, you can download the latest version of
    STS and play with the code without any problems.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供的STS链接是3.x版本。在撰写本文时，STS的当前版本是4.x。本书中创建的所有代码都是基于STS 3.x的，因此提供的链接是3.x版本。然而，您可以下载STS的最新版本并使用代码而不会遇到任何问题。
- en: 'Once downloaded, open it, select the *File | New | *Spring Starter Project menu
    and fill the form as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 下载后，打开它，选择“*文件 | 新建 | *Spring Starter Project”菜单，并按以下方式填写表单：
- en: '![](img/6e3d6a05-6110-42c1-a873-a1366090b9de.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e3d6a05-6110-42c1-a873-a1366090b9de.png)'
- en: 'Click on the Next button, and you will be asked to define the dependencies.
    Choose the following dependencies. You can use the textbox, Available to search
    for a particular dependency:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“下一步”按钮，您将需要定义依赖项。选择以下依赖项。您可以使用文本框“可用”来搜索特定的依赖项：
- en: '**Web:** Used to add Spring MVC specific dependencies.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web:** 用于添加Spring MVC特定依赖项。'
- en: '**Reactive Web:** To add WebFlux specific dependencies.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reactive Web:** 用于添加WebFlux特定依赖项。'
- en: '**DevTools:** Helpful for development as it will auto-refresh the changes in
    the embedded container to see the changes quickly.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DevTools:** 在开发中非常有用，因为它会自动刷新嵌入式容器中的更改，以便快速查看更改。'
- en: '**Reactive MongoDB:** Spring Data dependency for MongoDB that works in a reactive
    paradigm. Make sure you don''t select MongoDB, which is a dependency to work with
    MongoDB in the non-reactive model.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reactive MongoDB:** 在反应式范式下工作的Spring Data MongoDB依赖项。确保您不要选择MongoDB，它是用于在非反应式模型中与MongoDB一起工作的依赖项。'
- en: Click on Finish, and you will see a project is created in the Package Explorer (or Project
    Explorer) section of STS. Once the project is created, we will perform the following
    steps.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“完成”，您将在STS的“包资源管理器”（或“项目资源管理器”）部分看到一个创建的项目。一旦项目创建，我们将执行以下步骤。
- en: MongoDB installation
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB安装
- en: First, you need to install MongoDB into your local machine. It is distributed
    as a standalone server as well as a cloud service. Download the latest version
    from: [https://www.mongodb.com/download-center/community](https://www.mongodb.com/download-center/community).
    Choose the appropriate OS from the list and install it on your machine.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要在本地机器上安装 MongoDB。它既可以作为独立服务器，也可以作为云服务进行分发。从以下链接下载最新版本：[https://www.mongodb.com/download-center/community](https://www.mongodb.com/download-center/community)。从列表中选择适当的操作系统，并在您的机器上安装它。
- en: MongoDB doesn't has any UI to access it. However, it provides another tool called
    Compass and can be downloaded from: [https://www.mongodb.com/download-center/compass](https://www.mongodb.com/download-center/compass).
    Choose the appropriate version and target platform and download them. In most
    cases, it is directly executable. By default, MongoDB is accessible with the `27017`
    port. Just connect Compass to the MongoDB server to make sure it is running before
    connecting.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 没有任何 UI 来访问它。然而，它提供了一个名为 Compass 的其他工具，可以从以下链接下载：[https://www.mongodb.com/download-center/compass](https://www.mongodb.com/download-center/compass)。选择适当的版本和目标平台，并下载它们。在大多数情况下，它是直接可执行的。默认情况下，MongoDB
    通过 `27017` 端口可访问。只需将 Compass 连接到 MongoDB 服务器，确保它在连接之前正在运行。
- en: MongoDB data structure
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB 数据结构
- en: Before using MongoDB, it is important to understand the schema and data structure
    used in it. Like a relational database, we need to first create a database in
    MongoDB. Along with the database, we also need to create a collection. You can
    consider a collection to be similar to the database table in RDBMS.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 MongoDB 之前，了解其中使用的模式和数据结构非常重要。就像关系型数据库一样，我们首先需要在 MongoDB 中创建一个数据库。除了数据库，我们还需要创建一个集合。您可以将集合视为在
    RDBMS 中的数据库表。
- en: 'Connect the Compass (default: no credentials) and click on the CREATE DATABASE
    button, and you will see model windows as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 连接 Compass（默认：无凭据）并点击“创建数据库”按钮，您将看到如下所示的模型窗口：
- en: '![](img/f78bb8f4-b00b-4848-8fb3-dd8f463fad8a.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f78bb8f4-b00b-4848-8fb3-dd8f463fad8a.png)'
- en: You need to give the Database Name and Collection Nameand click on the CREATE
    DATABASE button from the model window. You can now insert the data for student
    collection into MongoDB.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在模型窗口中给出数据库名称和集合名称，然后点击“创建数据库”按钮。现在，您可以将学生集合的数据插入到 MongoDB 中。
- en: Creating a Spring Data repository
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Spring Data 存储库
- en: Spring Data provides a consistent Spring-based programming model to access data.
    It abstracts away the low-level boilerplate details and can be used to access
    a wide variety of data stores including the SQL (relational and non-relational)
    database, map-reduce frameworks, cloud-based data services, and so on. The Spring
    Data repository basically implements the data access layer and provides abstract
    access to interact with the underlying data store.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data 提供了一致的基于 Spring 的编程模型来访问数据。它抽象了低级样板细节，可以用来访问包括 SQL（关系型和非关系型）数据库、map-reduce
    框架、基于云的数据服务等多种数据存储。Spring Data 存储库基本上实现了数据访问层，并为与底层数据存储进行交互提供了抽象访问。
- en: 'We will configure the Spring Data repository to interact with MongoDB. The
    first step is to create an entity object (domain model). Spring Data allows accessing
    data in an object-oriented way, so first we need to define the entity class and
    provide the necessary mapping with the persistence model. An entity class can
    be created as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将配置 Spring Data 存储库以与 MongoDB 交互。第一步是创建一个实体对象（领域模型）。Spring Data 允许以面向对象的方式访问数据，因此我们首先需要定义实体类并提供与持久化模型的必要映射。实体类可以创建如下：
- en: '[PRE22]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This POJO class represents the student entity in MongoDB with the `@Document`
    annotation. You need to give the same collection name here that we created in
    MongoDB. The attribute ID will be autogenerated by MongoDB and can be considered
    as a primary key for the `Student` entity so it is marked with the `@Id` annotation.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 POJO 类使用 `@Document` 注解表示 MongoDB 中的学生实体。您需要在这里给出与我们在 MongoDB 中创建的相同集合名称。属性
    ID 将由 MongoDB 自动生成，可以视为 `Student` 实体的主键，因此它被标记为 `@Id` 注解。
- en: 'Next add a Spring Data repository. Spring provide repository support for specific
    data stores. For MongoDB, the Spring Data repository should looks as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来添加一个 Spring Data 存储库。Spring 为特定的数据存储提供了存储库支持。对于 MongoDB，Spring Data 存储库应如下所示：
- en: '[PRE23]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Spring Data provides the `ReactiveMongoRepository` interface that can be extended
    to define a custom repository. It is of the `Student` type, which is an object
    entity type when we want to interact with MongoDB and `String` , which represent
    the primary key (ID in our case).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data提供了`ReactiveMongoRepository`接口，可以扩展以定义自定义仓库。它为`Student`类型，当我们想要与MongoDB交互时是一个对象实体类型，以及`String`，它代表主键（在我们的例子中是ID）。
- en: The Spring Data repository provides a nice feature called the **query** method,
    which is used to access data based on specific column or  attribute values by
    following a certain naming convention. For example, `findByName(String name)`
    will return  `StudentData` with the matching name. Spring Data provides underlying
    implementation of these methods out of the box. For simplicity, we kept just two
    methods.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data仓库提供了一个名为**查询方法**的不错特性，它通过遵循一定的命名约定根据特定的列或属性值访问数据。例如，`findByName(String
    name)`将返回匹配名称的`StudentData`。Spring Data提供了这些方法的底层实现。为了简单起见，我们只保留了两个方法。
- en: 'To make sure the Spring application connects to MongoDB, we need to add the
    following properties in the `application.properties` file:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 要确保Spring应用程序连接到MongoDB，我们需要在`application.properties`文件中添加以下属性：
- en: '[PRE24]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is equivalent to defining connection properties in a database.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这与在数据库中定义连接属性等效。
- en: WebFlux programming models
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebFlux编程模型
- en: 'Spring WebFlux is flexible enough to support different development patterns.
    You can create an application in WebFlux with the following two programming models:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux足够灵活，可以支持不同的开发模式。你可以在WebFlux中使用以下两种编程模型创建应用程序：
- en: '**Annotated controller**: This is much similar than the Spring MVC controller.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注解控制器**：这与Spring MVC控制器非常相似。'
- en: '**Functional end point**:  Functional end points are used to process and route
    requests with functional programming features.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能端点**：功能端点用于使用函数式编程特性处理和路由请求。'
- en: We will explore both these options in the sample WebFlux application that we
    created with the Spring Data repository and entity class. The next part is to
    create a controller, which can be done in the following two ways.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们创建的带有Spring Data仓库和实体类的示例WebFlux应用程序中探索这两种选项。下一步是创建一个控制器，这可以通过以下两种方式完成。
- en: Annotated controller
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注解控制器
- en: 'WebFlux provides support for annotation-based configurations in a similar to
    the Spring MVC framework. To begin with, we will create an annotated controller
    class that publishes the Reactive Streams of the `Student` entity from the server
    side as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: WebFlux提供了类似于Spring MVC框架的基于注解的配置支持。首先，我们将创建一个注解控制器类，该类从服务器端发布`Student`实体的响应式流，如下所示：
- en: '[PRE25]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`StudentWebFluxController` is the annotated controller. It is similar to the
    Spring MVC controller. The `@RestController` annotation is used to define this
    controller as a REST controller. The `@RequestMapping` annotation is used to define
    the URL mapping for this controller.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`StudentWebFluxController`是注解控制器。它与Spring MVC控制器相似。使用`@RestController`注解将此控制器定义为REST控制器。使用`@RequestMapping`注解定义此控制器的URL映射。'
- en: The `studentMongoRepository` Spring Data repository supports non-blocking Reactive
    Streams. The `getStudent()` method will return a single `Student` object based
    on the `rollNo` input value. However, the return type is not just in response
    to `Student`; instead, it is of the `Mono` type because it returns at most one
    element, so the `Mono` type is more appropriate.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`studentMongoRepository` Spring Data仓库支持非阻塞的响应式流。`getStudent()`方法将根据输入值`rollNo`返回单个`Student`对象。然而，返回类型不仅仅是响应`Student`；相反，它是`Mono`类型，因为它最多返回一个元素，所以`Mono`类型更合适。'
- en: 'The repository gives `Mono<Student>` based on `rollNo`; then we call the map
    function to map the object of the `Mono<Student>` type to `Mono<ResponseEntity<Student>>` ,
    which will be then taken care of by the WebFlux framework to return the student
    data. Add some values directly from MongoDB and try to access it with the URLs [http://localhost:8080/api/getStudent/21](http://localhost:8080/api/getStudent/21)
    (using the `8080` port, and student `rollNo` is `21`) in REST client (for example,
    Postman), and you will get an output as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 该仓库基于`rollNo`提供了`Mono<Student>`，然后我们调用映射函数将`Mono<Student>`类型的对象映射到`Mono<ResponseEntity<Student>>`，随后将由WebFlux框架处理以返回学生数据。直接从MongoDB添加一些值，并尝试使用REST客户端（例如Postman）通过URL
    [http://localhost:8080/api/getStudent/21](http://localhost:8080/api/getStudent/21)（使用`8080`端口，学生`rollNo`为`21`）访问它，你将得到以下输出：
- en: '![](img/2e5e5589-fb50-4f7f-81cf-8e3340895527.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2e5e5589-fb50-4f7f-81cf-8e3340895527.png)'
- en: 'In case we want to access more than one student, we need to use the `Flux` return
    type as it emits 0 to N elements. Let''s add one more method to the controller
    to fetch all the students as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想访问多个学生，我们需要使用`Flux`返回类型，因为它可以发出0到N个元素。让我们向控制器添加一个方法来获取所有学生，如下所示：
- en: '[PRE26]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add some more student data from MongoDB and hit the URL [http://localhost:8080/api/getAllStudent](http://localhost:8080/api/getAllStudent)
    and you will see results as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 从MongoDB添加一些更多的学生数据，并访问URL [http://localhost:8080/api/getAllStudent](http://localhost:8080/api/getAllStudent)，您将看到以下结果：
- en: '![](img/2a4c5d53-2e30-4c7c-a57d-fbdc2bc1473b.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2a4c5d53-2e30-4c7c-a57d-fbdc2bc1473b.png)'
- en: The WebFlux controller endpoint returns a Publisher in the form of either `Flux`
    or `Mono`. In the second method where we return all the students, it can be in
    the form of a **Server-Sent Event** (**SSE**) to the browser. For that, you need
    to define the return type as `text/event-stream`. The SSE is the technology allowing
    a browser to receive automatic updates from the server via an HTTP connection.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: WebFlux控制器端点以`Flux`或`Mono`的形式返回一个发布者。在第二个方法中，我们返回所有学生时，它可以以**服务器端事件**（**SSE**）的形式发送到浏览器。为此，您需要将返回类型定义为`text/event-stream`。SSE是允许浏览器通过HTTP连接从服务器接收自动更新的技术。
- en: What does this mean? If we have a very huge stream, then the WebFlux controller
    will send the data as it receives from a reactive repository (from MongoDB in
    our case) and send it to the browser, instead of fetching all the records, which
    results in a blocking condition. This is how large volumes of streams are handled
    in Reactive Programming with Spring WebFlux.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着什么？如果我们有一个非常大的流，那么WebFlux控制器将像从反应式存储库（在我们的例子中是MongoDB）接收数据一样发送数据，并将其发送到浏览器，而不是获取所有记录，这会导致阻塞条件。这就是在Spring
    WebFlux中使用反应式编程处理大量流的方式。
- en: Functional endpoint
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能端点
- en: 'Spring Framework 5 supports functional programming models for reactive web
    applications with WebFlux. This is an alternative to using the Spring MVC-style
    annotated controller. The functional style programming in Spring WebFlux uses
    the following essential components:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework 5支持使用WebFlux的函数式编程模型来构建反应式Web应用程序。这是使用Spring MVC风格的注解控制器的一个替代方案。Spring
    WebFlux中的函数式编程风格使用以下基本组件：
- en: '`HandlerFunction`:It is used to handle the request. It is an alternative to
    the Spring MVC controller handler methods and works similar to it.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HandlerFunction`：用于处理请求。它是Spring MVC控制器处理方法的一个替代方案，并且工作方式与之相似。'
- en: '`RouterFunction`: It is used to route incoming HTTP requests. `RouterFunction`
    is an alternative to using request mapping with the `@RequestMapping` annotation and
    works similar to it.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RouterFunction`：用于路由传入的HTTP请求。`RouterFunction`是使用`@RequestMapping`注解进行请求映射的一个替代方案，并且工作方式与之相似。'
- en: Artifacts required in functional-style Reactive Programming
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式反应式编程所需的艺术品
- en: 'Let''s first understand these components. They are defined as an interface
    in Spring WebFlux. The `HandlerFunction` interface looks as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解这些组件。它们在Spring WebFlux中定义为接口。`HandlerFunction`接口如下所示：
- en: '[PRE27]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This interface is similar to the `Function<T,R>` type, which takes the value
    (of the `T`type) and returns another value (of the `R`type). In this case, it
    is equivalent to `Function<ServerRequest,Mono<T>` . It is much like a servlet.
    The `T` type is the response type of the function that should implement the `ServerReponse`
    interface, which represents the server-side HTTP response.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口类似于`Function<T,R>`类型，它接受一个值（`T`类型的值）并返回另一个值（`R`类型的值）。在这种情况下，它相当于`Function<ServerRequest,Mono<T>>`。它非常像servlet。`T`类型是应该实现`ServerResponse`接口的函数的响应类型，该接口代表服务器端的HTTP响应。
- en: The  `handle()` method takes the `ServerRequest` object type and returns a `Mono` 
    object type. `ServerRequest` represents the HTTP request, and we can get headers
    and the body of a request from this. Both `ServerRequest` and `ServerResponse`
    are part of the reactive API of Spring WebFlux.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle()`方法接受`ServerRequest`对象类型并返回一个`Mono`对象类型。`ServerRequest`代表HTTP请求，我们可以从这个请求中获取头和体。`ServerRequest`和`ServerResponse`都是Spring
    WebFlux反应式API的一部分。'
- en: 'You may notice that instead of putting both requests and responses in the same
    method call, the response is returned from the `handle()` method, which really
    makes it side-effect free and easy to test. Let''s see what `RouterFunction` looks
    like. Again it is of the interface type as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，我们不是在同一个方法调用中放置请求和响应，而是从`handle()`方法返回响应，这实际上使其无副作用且易于测试。让我们看看`RouterFunction`的样子。同样，它也是接口类型，如下所示：
- en: '[PRE28]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This interface has the `route()` method that returns `HandlerFunction` , which
    matches the given request. This method is used to create routes by applying `RequestPredicate`.
    When the predicate matches, it will return the handler function, which basically
    processes the request.  `RequestPredicate` is  the Java8 functional interface
    and part of the reactive API of Spring WebFlux. It is used to test the given `ServerRequest`
    for the routing and looks as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口有`route()`方法，该方法返回`HandlerFunction`，它与给定的请求相匹配。此方法用于通过应用`RequestPredicate`创建路由。当谓词匹配时，它将返回处理器函数，该函数基本上处理请求。"RequestPredicate"是Java8函数式接口，是Spring
    WebFlux反应式API的一部分。它用于测试给定的`ServerRequest`进行路由，如下所示：
- en: '[PRE29]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let's create the controller in functional-style programming. We will write a
    controller that works exactly the same to the annotated controller but in a functional
    way.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在函数式编程风格中创建控制器。我们将编写一个与注解控制器工作方式完全相同但以函数方式工作的控制器。
- en: Prerequisite for a functional approach in Spring WebFlux
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring WebFlux中功能方法的先决条件
- en: 'To work in functional way, the very first thing we need to do is to make our
    project WebFlux aware. For that we need to add the `@EnableWebFlux` annotation
    to the main bootstrap class as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以功能方式工作，我们首先需要做的是让我们的项目WebFlux具备意识。为此，我们需要将`@EnableWebFlux`注解添加到主引导类中，如下所示：
- en: '[PRE30]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We also need to instruct Spring that the application is of the `reactive` type
    by adding the following property in the `application.properties` file:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`application.properties`文件中添加以下属性来指示Spring，应用程序是`reactive`类型的：
- en: '[PRE31]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Defining routers and handlers
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义路由器和处理器
- en: 'The next part is to define the router and handler for getting the student data.
    Let''s recall that routers are used to route the request as they serve the purpose
    of `@RequestMapping` in the annotated controller, while handlers actually process
    the incoming request, which is similar to the Spring MVC controller handler method.
    The router class looks as follows:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义获取学生数据用的路由器和处理器。让我们回顾一下，路由器用于路由请求，它们在注解控制器中起到`@RequestMapping`的作用，而处理器实际上处理传入的请求，这与Spring
    MVC控制器处理器方法类似。路由器类如下所示：
- en: '[PRE32]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It is required to declare the router class with the `@Configuration` annotation
    so that Spring container will pick this class at the time of context loading and
    do the necessary configuration. We have two methods to get a single student and
    list of all the student data, respectively.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用`@Configuration`注解声明路由器类，以便Spring容器在上下文加载时选择此类并执行必要的配置。我们有两种方法来获取单个学生和所有学生数据列表。
- en: The router is created with the `RouterFunctions.route()` call. The `RouterFunctions` utility
    class has lots of useful functions. The `route()` method needs two parameters.
    The first parameter is of the `RequestPredicate`. type Another helper class `RequestPredicates`
    is used to define `RequestPredicate` with the URL pattern for each router method. The  `RequestPredicate` class
    has various methods corresponding to HTTP methods.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器是通过`RouterFunctions.route()`调用创建的。`RouterFunctions`实用类有很多有用的功能。`route()`方法需要两个参数。第一个参数是`RequestPredicate`类型的。另一个辅助类`RequestPredicates`用于为每个路由方法定义带有URL模式的`RequestPredicate`。`RequestPredicate`类有各种对应HTTP方法的方法。
- en: We have used the `GET` method as we want to pull data from REST client with
    the `GET` method. The important thing here is to define any path variable along
    with the URL pattern that will be received in the handler to perform the necessary
    operations.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`GET`方法，因为我们想用`GET`方法从REST客户端拉取数据。这里重要的是要定义任何路径变量以及将在处理器中接收的URL模式，以便执行必要的操作。
- en: 'The second parameter is of the `HandlerFunction<T>` type, which is supplied
    by the corresponding method of the `StudentHandler` class. The  `studentHandler::getStudent`
    and `studentHandler::getAllStudent`  double column notations will call the `getStudent()`
    and `getAllStudent()` methods  of the `StudentHandler` class respectively. The
    `StudentHandler` class should look as follows:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是 `HandlerFunction<T>` 类型，它由 `StudentHandler` 类的相应方法提供。`studentHandler::getStudent`
    和 `studentHandler::getAllStudent` 的双列注释将分别调用 `StudentHandler` 类的 `getStudent()`
    和 `getAllStudent()` 方法。`StudentHandler` 类应如下所示：
- en: '[PRE33]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Each handler method will have the object of `ServerRequest` as a parameter,
    which will be supplied by the Spring WebFlux framework while they are called from
    routers. The  `ServerRequest` class represents the HTTP request, and we can get
    parameters and body out of it.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 每个处理程序方法都将有一个 `ServerRequest` 对象作为参数，当它们从路由器调用时，将由 Spring WebFlux 框架提供。`ServerRequest`
    类代表 HTTP 请求，我们可以从中获取参数和体。
- en: In the `getStudent()` method, we are reading the `rollNo` path variable, and
    passing it to the repository method to get student data. The name of the path
    variable here must be the same as the path variable declared as part of the URL
    pattern in a router (`/api/f/getStudent/{**rollNo**}`). Finally, the `ServerResponse`
    class is used to construct a response and return it. To differentiate the functional
    endpoint, we have updated the URL pattern (added `/f/` in between to denote its
    functional endpoints). You will get a similar output to the annotated controller.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `getStudent()` 方法中，我们正在读取 `rollNo` 路径变量，并将其传递给存储库方法以获取学生数据。这里的路径变量名称必须与在路由器中声明的
    URL 模式部分（`/api/f/getStudent/{**rollNo**}`）中的路径变量相同。最后，使用 `ServerResponse` 类构建响应并返回。为了区分功能端点，我们已更新了
    URL 模式（在中间添加了 `/f/` 以表示其功能端点）。你将得到与注解控制器类似的输出。
- en: The handler methods are not required to be defined with the `@Bean` annotation
    or else you will get an error while starting the application.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序方法不需要用 `@Bean` 注解定义，否则在启动应用时你会得到一个错误。
- en: Combining handler and router
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合处理程序和路由器
- en: 'We have written two different classes for the handler and router; however,
    we can declare the configuration that covers the functionality of both the router
    and handler in a single class. This can be done by combining the handler and router
    method pair in one single method as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为处理程序和路由器编写了两个不同的类；然而，我们可以在一个类中声明覆盖路由器和处理程序功能的配置。这可以通过将处理程序和路由器方法对组合在一个单独的方法中来实现，如下所示：
- en: '[PRE34]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This class has two methods to fetch a single student and all students, respectively.
    In each method, we first create an instance of the handler and then pass it into
    the `route()` method while creating the router. The lambda expression is used
    to define the handler. The code is easy and straightforward. Again to make it
    unique, we have changed the URL pattern by adding `/combine/` in between so the
    endpoints of getting a single student and all students can be accessed with the
    URL [http://localhost:8080/api/f/combine/getStudent/21](http://localhost:8080/api/f/combine/getStudent/21)
    and [http://localhost:8080/api/f/combine/getAllStudent,](http://localhost:8080/api/f/combine/getAllStudent)
    respectively. You will get a similar output to when we defined handler and router
    separately.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有两个方法，分别用于获取单个学生和所有学生。在每个方法中，我们首先创建处理程序的一个实例，然后将其传递到创建路由器时的 `route()` 方法中。使用
    lambda 表达式来定义处理程序。代码简单直接。再次为了使其独特，我们通过在中间添加 `/combine/` 来更改 URL 模式，这样可以通过 URL
    [http://localhost:8080/api/f/combine/getStudent/21](http://localhost:8080/api/f/combine/getStudent/21)
    和 [http://localhost:8080/api/f/combine/getAllStudent](http://localhost:8080/api/f/combine/getAllStudent)
    分别访问获取单个学生和所有学生的端点。你将得到与单独定义处理程序和路由器时类似的输出。
- en: You might be wondering how this works under the hood. The bean of the `RouterFunctionMapping` type
    scans the packages and retrieves all `RouterFunctions` at the time of starting
    the application. This bean is created within `WebFluxConfigurationSupport`, which
    is the headquarters of the Spring WebFlux configuration. All these things start
    happening when we define the `@EnableWebFlux` annotation to the main bootstrap
    class along with the `spring.main.web-application-type=reactive` property.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道底层是如何工作的。`RouterFunctionMapping` 类型的“豆”在应用启动时扫描包并检索所有 `RouterFunctions`。这个“豆”是在
    `WebFluxConfigurationSupport` 中创建的，它是 Spring WebFlux 配置的大本营。当我们把 `@EnableWebFlux`
    注解和 `spring.main.web-application-type=reactive` 属性定义到主引导类中时，所有这些事情就开始发生了。
- en: Composite routers
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合路由器
- en: 'If you have lots of routers in your configuration, you can basically compose
    them into a chain with the `and` operator. In the previous example, we defined
    two routers in two different methods. This can be combined in just one method
    as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的配置中有许多路由器，你可以基本上使用`and`运算符将它们组合成一个链。在前面的示例中，我们在两个不同的方法中定义了两个路由器。这可以在一个方法中合并如下：
- en: '[PRE35]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `and` operator is used to combine two routers. Also, the second parameter
    of the `rout()` function, which is of the  `HandlerFunction<T>` type, is defined
    with a lambda expression. This is how you can composite multiple routers in a
    single chain call with the `and` operator. To distinguish this feature, we again
    alter the endpoint URL pattern as we have added `/composite/` instead of `/combine/` to
    the URL pattern. Needless to say that you will get a similar output in this case
    as well.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`and`运算符来组合两个路由器。此外，`rout()`函数的第二个参数是`HandlerFunction<T>`类型，使用lambda表达式定义。这就是如何使用`and`运算符在一个链调用中组合多个路由器。为了区分这个特性，我们再次更改端点URL模式，因为我们已经将`/combine/`替换为`/composite/`添加到URL模式中。不用说，在这种情况下你也会得到类似的结果。
- en: WebSocket support
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSocket支持
- en: 'WebSocket is a protocol that allows full-duplex, two-way communication between
    a server and a client. While establishing the connection, it uses HTTP for the
    initial handshake. Once done, it will request a protocol upgrade. The Spring WebFlux
    framework supports reactive WebSocket communication between a client and server
    based on  the Java WebSocket API. Defining WebSocket is a two-step process as
    follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket是一种协议，允许服务器和客户端之间进行全双工、双向通信。在建立连接时，它使用HTTP进行初始握手。一旦完成，它将请求协议升级。Spring
    WebFlux框架基于Java WebSocket API支持客户端和服务器之间的反应式WebSocket通信。定义WebSocket是一个两步过程，如下所示：
- en: Define the handler to manage the WebSocket request
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义处理程序以管理WebSocket请求
- en: Define mapping to access  the specific handler
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义映射以访问特定处理程序
- en: In WebFlux, the WebSockets are handled by implementing the `WebSocketHandler`
    interface. It has one method called`handle()`. It is provided with the object
    of `WebSocketSession` every time a connection is established to the handler. As
    its name suggests,  `WebSocketSession` represents the connection formed by a single
    client.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebFlux中，WebSocket通过实现`WebSocketHandler`接口来处理。它有一个名为`handle()`的方法。正如其名称所暗示的，`WebSocketSession`代表由单个客户端形成的连接。
- en: 'Two separate streams  accessible through the `receive()` and `send()` methods
    of the `Flux` type, are associated with `WebSocketSession` for handling incoming
    requests and outgoing messages respectively. We will first define  handler mapping
    as follows:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`Flux`类型的`receive()`和`send()`方法可访问的两个单独的流与`WebSocketSession`相关联，分别用于处理传入请求和发送消息。我们首先定义处理程序映射如下：
- en: '[PRE36]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `@Bean` annotated method `webSockertHandlerMapping` is used to map our
    custom handler with a specific URL pattern by which it can be accessible. The `SampleWebSocketHandler`
     custom handler is injected with the `@Autowired` annotation and looks as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Bean`注解的方法`webSockertHandlerMapping`用于将我们的自定义处理程序与特定的URL模式映射，通过该模式它可以被访问。`SampleWebSocketHandler`自定义处理程序通过`@Autowired`注解注入，其代码如下：
- en: '[PRE37]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The  `SampleWebSocketHandler` class provides an implementation of the `WebSocketHandler`
    interface with the `handle()` method. In that method, we are simply fetching all
    student data from `StudentMongoRepository` and calling the `send()` method on `WebSocketSession`.
    In the `send()` method, we first convert the `Student` object to JSON string with
    `ObjectMapper` and finally call the `textMessage()` method of `WebSocketSession`
    to convert it to `WebSocketMessage`.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`SampleWebSocketHandler`类提供了`WebSocketHandler`接口的实现，其中包含`handle()`方法。在该方法中，我们简单地从`StudentMongoRepository`获取所有学生数据，并在`WebSocketSession`上调用`send()`方法。在`send()`方法中，我们首先使用`ObjectMapper`将`Student`对象转换为JSON字符串，最后调用`WebSocketSession`的`textMessage()`方法将其转换为`WebSocketMessage`。'
- en: Next, is to create the client. We will write client code in JavaScript and call
    the server from the browser to see how the stream data is received one by one.
    You can create one HTML file with the following code.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建客户端。我们将用JavaScript编写客户端代码，并在浏览器中调用服务器以查看流数据是如何逐个接收的。你可以创建一个包含以下代码的HTML文件。
- en: '[PRE38]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Almost all modern browsers support WebSocket communication. Open this HTML in
    a browser and you will see student data one by one with a browser alert. This
    is how WebSocket communication happens in the reactive paradigm of Spring WebFlux.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有现代浏览器都支持 WebSocket 通信。在浏览器中打开这个 HTML 文件，你会看到学生数据逐个通过浏览器弹窗显示。这就是 Spring WebFlux
    反应式范式中的 WebSocket 通信方式。
- en: Summary
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Reactive is definitely a promising new technology that will help to build a
    scalable and high-performance application. Spring has done an impressive job of
    supporting Reactive Systems with a new framework called WebFlux. Reactive is the
    future of next-generation applications, and it is needed almost everywhere: datastores,
    middle layers, frontends, or even mobile platforms.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式技术无疑是一种有潜力的新技术，它将有助于构建可扩展且高性能的应用程序。Spring 通过一个名为 WebFlux 的新框架，出色地支持了反应式系统。反应式技术是下一代应用程序的未来，它几乎在所有地方都需要：数据存储、中间层、前端，甚至是移动平台。
- en: Through this chapter, we learned the basics of Reactive Systems and Reactive
    Programming followed by various techniques to achieve it. We then learned about
    Reactive Streams, which is one of the most popular ways of implementing a Reactive
    System. Starting with the Reactive Streams specifications and the basic fundamentals,
    we explored various JVM-based libraries that provide an implementation for a particular
    specification. We did some hands-on work with RxJava and Project Reactor and learned
    the underlying principles.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们学习了反应式系统和反应式编程的基础知识，以及实现它们的各种技术。然后，我们了解了反应式流（Reactive Streams），这是实现反应式系统最受欢迎的方法之一。从反应式流规范和基本原理开始，我们探索了各种基于
    JVM 的库，它们为特定的规范提供了实现。我们使用 RxJava 和 Project Reactor 进行了一些实际操作，并学习了其背后的原理。
- en: In the same direction, we have seen how the Spring Framework provides support
    in a reactive paradigm. We have then explored the Spring WebFlux framework by
    creating a Spring Boot-based web application. Apart from annotated based support
    for WebFlux, which is like Spring MVC, Spring also supports creating Reactive
    Systems with functional programming paradigms. We explored various options in
    functional programming with a series of examples.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一方向上，我们看到了 Spring 框架如何在反应式范式下提供支持。然后，我们通过创建基于 Spring Boot 的 Web 应用程序来探索 Spring
    WebFlux 框架。除了基于注解的 WebFlux 支持，类似于 Spring MVC，Spring 还支持使用函数式编程范式创建反应式系统。我们通过一系列示例探索了函数式编程中的各种选项。
- en: To gain full advantage of the reactive capability of Spring WebFlux, the data
    store should also support Reactive Programming, and that was the reason we chose
    MongoDB as a datastore, and we learned how to configure it in a web application
    with the Spring Boot tool.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用 Spring WebFlux 的反应式能力，数据存储也应支持反应式编程，这也是我们选择 MongoDB 作为数据存储的原因，并且我们学习了如何在
    Spring Boot 工具中配置它。
- en: It has been a very exciting journey so far, and we will continue our journey
    in the next chapter by exploring the interesting topic of the integration of Elasticsearch
    with the Spring Framework. We will develop a sample application called **Blogpress**.
    We will also look in more detail at Spring Boot, Thymeleaf, and so on; stay tuned
    and ready to explore further in the next chapter.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，这已经是一次非常激动人心的旅程，我们将在下一章继续我们的旅程，通过探索 Elasticsearch 与 Spring 框架的集成这一有趣的主题。我们将开发一个名为
    **Blogpress** 的示例应用程序。我们还将更详细地了解 Spring Boot、Thymeleaf 等技术；敬请期待，准备在下一章中进一步探索。
