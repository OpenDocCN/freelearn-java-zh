- en: Building a Reactive Web Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We began our journey by exploring some of the basics of the Spring Framework
    and its module system in [Chapter 1](87add83e-e65b-4b58-9ef1-113ad157a51a.xhtml), *Creating
    an Application to List World Countries with their GDP*. Let''s leave all the new
    and advanced topics of Spring Framework for now and, in this chapter, look at
    one of the most popular topics: how to make highly scalable and responsive applications
    by adopting a reactive paradigm.'
  prefs: []
  type: TYPE_NORMAL
- en: The world of technology is migrating from blocking, synchronous, and thread-driven
    implementation to non-blocking, asynchronous, and event-based systems, which are resilient
    and capable of managing a very large volume of data with a consistent response
    time. This is the core concern addressed by a reactive system.
  prefs: []
  type: TYPE_NORMAL
- en: From the perspective of the programming model, Reactive Programming has influenced
    the paradigm shift from an imperative style to a declarative composition of asynchronous
    logic. Spring Framework did this by incorporating Reactive Streams capabilities
    into its core framework from version 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss and explore Reactive Programming from various
    dimensions and angles with the following exciting topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a reactive system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Reactive programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive Programming basics, benefits, and features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive Programming in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to WebFlux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring supports for Reactive Programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A functional way of working in Reactive Programming with WebFlux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebSocket support in a reactive paradigm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter02](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter02).
    The code can be executed on any operating system, although it has only been tested
    on Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The word reactive has become popular today and has different meanings for different
    people, such as lightweight, real time, asynchronous, streaming, and so on. **Reactive**,
    in broader terms, refers to a set of design techniques or principles, and is a
    way to consider the system architecture in a distributed environment. It comprises
    tooling, design methodologies, and implementation procedures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The analogy of a team can be used to describe a reactive system: individual
    players working with each other to achieve a desired goal. The interaction between
    the components is the main quality that differentiates a Reactive System from
    other systems. Components can operate individually or still work in harmony with
    others to achieve the intended result as a whole system. In other words, it is
    the system design that allows individual sub-applications to form a single logical
    system, perform specific tasks, and remain aware of each other. This enables decision-making,
    like load balancing, scaling up and down, failover mitigation, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: While talking about reactive topics, mainly in the context of software design
    and development, people generally use the terms **Reactive System** and **Reactive
    Programming** interchangeably, although they are not exactly the same. A reactive
    system is message-driven and associated with distributed process communication
    over the network, whereas Reactive Programming is generally event driven and handled
    locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Reactive System is considered to be the same as an asynchronous message-based
    system by many software engineers. But as per the reactive manifesto, the Reactive
    System is an architectural way of developing a distributed system in a responsive
    style. It has the following essential characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Responsive:** It suggests a system should process and respond to a request
    in a reasonable time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilient:** It suggests that even in case of failure, the system should
    remain responsive. In short, any kind of error should not put a system in a non-responsive
    state. All possible factors that may cause a system error must be well handled
    without causing a system halt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elastic:** A system should stay responsive even with a variable load. It
    should be flexible to scale up and down based on the load, and handle it with
    reasonable resource usage. To achieve this, the application must be designed in
    a way to avoid any central bottleneck.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message-driven:** Components within a Reactive System should interact with
    each other with asynchronous message passing. This brings a loose coupling between
    components, isolation in responsibility, and transparency in location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Among these characteristics, responsiveness, resilience, and elasticity are
    the standard requirements for almost every real-world application today. They
    look simple and straightforward, but are tricky to implement. It is the message-driven
    requirement that distinguishes a responsive system from others.
  prefs: []
  type: TYPE_NORMAL
- en: A Reactive System uses an asynchronous message-passing mechanism to interact
    among components. It also furnishes a non-blocking mechanism to control the data
    flow. While building a Reactive System, at all relevant points, the data processing
    operations are composed as stream flows. In short, a Reactive System is focused
    on stream processing.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive Programming can be used to build a Reactive System. By definition,
    **Reactive Programming** is a programming practice or pattern that is aligned
    around the data flow and the propagation of the changes. The changes in data are
    automatically propagated by the underlying execution model through the data flow.
  prefs: []
  type: TYPE_NORMAL
- en: To make it simple, Reactive Programming is a way to handle asynchronous data
    streams in a more effective manner. In other words, it is programming dealing
    with an asynchronous data stream, or it can be called the subset of asynchronous
    programming. Reactive Programming is a way of execution where new information
    will push the flow forward, rather than having the flow controlled by an execution
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: The data stream is a series of business events that happen during the system
    execution, such as various keyboard or mouse events, HTML field changes, HTTP
    requests, notification, REST API data fetch, triggering validations, changing
    of web component state, data updates, or anything else that can cause a change
    in the data stream or alter a program behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In short, Reactive Programming covers a dynamic reaction in the stream that
    is caused by the asynchronous data flow. When the changes happen in one component,
    a reactive library or framework will automatically propagate those changes to
    other components. It is quite possible to define a static order in which the changes
    are propagated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how Reactive Programming is different to imperative
    programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0706314d-9be6-4982-bbcf-c07d4b00c25e.png)'
  prefs: []
  type: TYPE_IMG
- en: In **imperative programming**, the threads talk to each other in a synchronous
    way that results in blocking communication. A thread has to wait until the dependent
    thread of a resource is free, which can cause inefficient utilization and an easy
    bottleneck situation in the system. On the other hand, Reactive Programming doesn't
    need to wait; in fact, it is informed once the resource is available so that it
    can do other work in the meantime. This reduces the risk of the system hanging
    and makes it responsive. This effectively maintains smooth resource usage.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Programming suggests breaking down the given requirements into separate
    and individual steps that can be accomplished in an asynchronous, non-blocking
    style, and later on, combined to form a final output. In the Reactive Programming
    context, asynchronous means that the processing of a message or event occurs at
    some arbitrary time, most probably in the future.
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous and non-blocking nature of Reactive Programming is particularly
    useful in application environments where resources are shared; there is no need
    to halt the thread of execution while a resource is elsewhere engaged.
  prefs: []
  type: TYPE_NORMAL
- en: Basics of Reactive Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a procedural programming model, a task is described as a series of actions
    executed in a sequential order. On the other hand, the Reactive Programming model
    facilitates the necessary arrangement to propagate the changes, which help in
    deciding what to do instead of how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the concept with a very basic example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we generally do in a procedural programming style. In this code,
    we are simply doing a summation of two numbers assigned to the third number and
    then printing it. In the next line, we are changing the value of the initial two
    numbers, but it doesn''t update the third number. This is because `num1 + num2`
    is evaluated and assigned to `num3` on that line only. Now consider the same equation
    in an Excel sheet as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8c00769-ab38-455b-98c9-8dcdc5d03102.png)'
  prefs: []
  type: TYPE_IMG
- en: In this case, the changes of the **E** and **F** columns always listen to the **G** column.
    This is what Reactive Programming does. It propagates the changes to the one interested
    in those changes.
  prefs: []
  type: TYPE_NORMAL
- en: You might have used Reactive Programming unknowingly in your day-to-day coding
    practice. For example, if you have created a user registration screen where you
    validate the username entered by a user who is already present in the system,
    makes an Ajax call and shows an appropriate message saying This username is already
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is the listener or callback function that you define with a
    mouse click or keystroke on the web page. In these cases, mouse click and focus
    out events (for username validation) can be considered as a stream of events that
    you can listen to and execute appropriate action or functions on.
  prefs: []
  type: TYPE_NORMAL
- en: This is just one usage of the event stream. Reactive programming allows you
    to observe and react to any changes caused by the stream of events, like changes
    in a database, user input, property updates, data from external resources, and
    so on. Let's understand it by taking a real-life example.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say you want to invest in mutual funds and there are many companies who
    provide facilities to invest on your behalf. They also produce statistics about
    the performance of various funds along with their history, market share, capital
    investment ratio, and so on. Based on this, they give some categories like moderate
    risk, low risk, moderately high risk, high risk, and so on. They also give a rating
    based on the performance of each fund.
  prefs: []
  type: TYPE_NORMAL
- en: The rating and the category will suggest that users choose a particular fund
    based on their requirement (short term, long term, and so on) and the type of
    risk they can afford. The changes happen in the rating and the category can be
    considered as an event (or data) stream that will cause a system to change the
    suggestion to the user. Another practical example of a data stream would be a
    social media feed, such as Facebook, Twitter, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Function reactive** is a paradigm of reacting to the data stream in a functional
    way, providing additional features such as filters, combine, buffers, maps, and
    lot others. Using them, you can perform certain operations on a data stream, which
    help it to react in a better way. Taking the previous example of a mutual fund,
    the filter function can be used to suggest only those funds that are safe for
    investment in a real-time manner.'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Programming is mainly used to build an interactive user interface and
    other systems that need time interaction, such as graphical applications, animations,
    simulations, chatbots, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Backpressure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the important concepts that you should know about in Reactive Programming
    is backpressure. It significantly improves Reactive Programming over the traditional
    code. What exactly is it? It is considered as one of the non-blocking regulatory
    mechanisms used to send asynchronous messages or feedback to the source of a stream
    for load regulation. Communication back to the stream sender could possibly be
    a request or alert to stop. However, it could also be about the receiver's intent
    to process more messages. The communication back to the sender has to be non-blocking.
    This is important.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the situation where observables (source of an event) send out the data
    at a higher rate than the subscribers can actually handle. In this case, the subscribers
    would be in a stress condition, unable to handle the flow properly, and there
    is a high chance the system would behave unexpectedly. To avoid this situation,
    there must be some arrangement for conveying the speed at which the subscribers
    can consume the data, back to the observables.
  prefs: []
  type: TYPE_NORMAL
- en: The mechanism for notifying the source of the event saying, *Hey, I am under
    pressure,* *so don't send a further message as I can consume X amount of messages
    at a particular time*, is called **backpressure**. In the absence of this, the
    system may keep increasing the buffer size until it runs out of memory error. Backpressure
    is required when emission happens at a faster rate than consumption. It will make
    sure the system remains resilient under the load and will provide information
    that is used to make the decision, whether the system needs additional resources
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of Reactive Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A few years ago, the user interaction was limited to just filling in the form
    on a web page and submitting it to the server. It was just enough for self-sufficient
    applications at the time. Today, in the era of the mobile and responsive requirement,
    a rich user interface showing real-time information is expected to provide wide
    interactive possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, different types of apps like cloud environments, distributed apps, IoT,
    and real-time applications need lots of user interaction. This can be achieved
    by Reactive Programming. It is used to build loosely coupled, responsive, and
    scalable applications that are more tolerant of failure. There are many advantages
    of using Reactive Programming, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource utilization:** One of the essential benefits of Reactive Programming
    is optimizing hardware resource utilization, like the processor, memory, network,
    and so on. It also improves the performance by reducing serialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced user experience:** Reactive Programming provides better and improved
    user experience by using an asynchronous mechanism that makes the application
    smoother and responsive and easy to interact with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency:** You can design the API with lots more consistency for everything,
    including database call, frontend, network, computation, or anything else you
    may need with Reactive Programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handle with ease:** Reactive Programming has first-class support and obvious
    mechanisms for asynchronous operations out of the box. Also, it makes handling
    UI interaction and event management easier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple thread management:** Reactive Programming makes it simpler than regular
    threading mechanisms. Complex threading implementations, making the parallel work
    in a synchronous manner, and executing the callbacks when the function is done
    is easier to achieve with Reactive Programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased developer productivity:** In a typical imperative programming model,
    the developer has to do lots of work to maintain a straightforward approach to
    achieve an asynchronous and non-blocking computation. Reactive Programming, on
    the other hand, addresses the challenge by providing these features out of the
    box so the developer does not need explicit coordination between elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive Programming techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reactive Programming is event-based in most cases. In Reactive Programming,
    the APIs are exposed in the following two flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Callback:** In this type, the anonymous routines are registered to event
    sources as callback functions. They will be invoked when the event is triggered
    by the data flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Declarative:** The events are observed through well-defined functional compositions,
    like a filter, map, and other stream-based operations, like count, trigger, and
    so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reactive Programming puts the importance on data flow rather than the flow
    of control, so it is not uncommon to consider it as a data flow programming. There
    are various techniques that are used to achieve Reactive Programming as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Futures and promise:** It is referred to as a technique to define the variable
    and assign its value. Though futures and promise are used interchangeably, they
    are not exactly the same. The future is used to describe a read-only view of a
    variable (or, say, define the variable), while the promise is a writable, single
    assignment container that is used to set the value of a variable in future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reactive Streams:** It is defined as a standard for the processing of asynchronous
    streams that enables non-blocking, backpressure transmutations between sources
    from where the events are initiated and the destination where they are observed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data flow variables:** It is a variable whose value depends on a given input,
    operations, and other cells, and is updated automatically when changes happen
    to source entities. You can think of a data flow variable as a spreadsheet cell,
    where a change in the value of one cell causes a ripple effect to others based
    on the assigned formula.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to this, there are various frontend libraries available, like React.js,
    AngularJS, Ractive.js, Node.js, and so on, which are used to develop reactive
    frontend applications. Other programming languages and frameworks providing native
    support for reactive applications are Scala, Clojure, and GoLang, along with Java
    9 and Spring 5\. We will see reactive features of Spring 5 later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Programming in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An asynchronous processing approach is a perfect fit while dealing with a huge
    volume of data or a large set of users. It will make the system responsive and
    improve the overall user experience. Implementing asynchronous processing in Java
    with the custom code would be cumbersome and harder to implement. Reactive Programming
    would be beneficial in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Java doesn't provide native support for Reactive Programming like other JVM-based
    programming languages such as Scala or Clojure do. However, from version 9, Java
    has started supporting Reactive Programming natively. Apart from native support
    in Java 9, there are other implementation layers that help to achieve Reactive
    Programming with an older version of Java (such as Java 8). We will see a few
    of them, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive Streams is described simply as an initiative to provide a standard
    for asynchronous stream processing with non-blocking backpressure. It is a small
    and straightforward statement. However, it is essential to note that the first
    focus here is on the asynchronous stream processing and not just on the asynchronous
    programming. As discussed earlier, asynchronous systems have been around for a
    long time.
  prefs: []
  type: TYPE_NORMAL
- en: Before processing a stream, comes receiving the stream data. Asynchronously,
    this would mean managing the risk of uncertainties in the world of streams. For
    example, how much more data or messages could there be? Another challenge might
    be how to know when the stream has finished sending data. There could be a lot
    of questions, and we will see all of them in a little while*.*
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Streams is used to perform Reactive Programming in Java. It is an API
    specification or, say, low-level contract given by the collaborations of various
    companies like Pivotal, Netflix, Red Hat, Twitter, Lightbend (previously known
    as Typesafe), Kaazing, Oracle, and many more. You can consider the Reactive Streams
    API to be just like JPA or JDBC. The actual implementations are provided by various
    vendors.
  prefs: []
  type: TYPE_NORMAL
- en: For example, JPA specifications have various vendors like Hibernate, TopLink,
    Apache OpenJPA that provide actual implementation. Similarly, there are many popular
    JVM-based libraries that support Reactive Programming like Reactor, Akka stream,
    Ratpack, Vert.x, and so on. They all provide an implementation of the Reactive
    Streams specifications, which bring interchangeability.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Streams specifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try to understand in more detail, what the specifications for Reactive
    Streams are. It is dealing with the asynchronous processing of a stream. Let’s
    look at the specification available at [https://github.com/reactive-streams/reactive-streams-jvm](https://github.com/reactive-streams/reactive-streams-jvm) .
    It comprises the following two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**API**: This describes the specification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technology Compatibility Kit** (**TCK**): This is a criteria or standard
    test suite for compliance testing of implementations. In short, it will make sure
    the given implementation conforms to the declared specification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Taking a closer look at the API, we find that it is rather simple and comprises
    just four interfaces as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Publisher**: This interface represents an entity that acts as a supplier
    of an unbounded number of sequenced events or elements. It will publish the elements
    as per the requirement of the subscriber.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscriber:** It represents a consumer of an event from a publisher. For
    that, it will subscribe to the publisher.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscription:** This interface illustrates the process of subscribing or
    registering of a subscriber to a publisher.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Processor:** It is a composition of both the publisher and subscriber. It
    represents a processing stage that implements the contract of both.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java 9 has started providing native support for Reactive Streams. The implementation
    of these interfaces is part of the Flow API in Java 9\. Looking at the structure
    of JAR containing the Reactive Streams, we find the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/946a8436-aacd-43e4-9a11-d8b1498daa00.png)'
  prefs: []
  type: TYPE_IMG
- en: This seems rather straightforward, and implementing a set of a few interfaces
    shouldn’t be a challenge for any developer in Java. Are we able to go to production
    with the implementation of these interfaces, and will it give us a stable system?
    Are we ready to get started with the reactive development? The answers are, *not
    quite yet*.
  prefs: []
  type: TYPE_NORMAL
- en: Passing the messages in an asynchronous way is the key area of focus for Reactive
    Streams. It ensures that it is not just the consumer that is protected from being
    overwhelmed by all the distributed systems. The Publisher is also safeguarded
    in case one or more subscribers is slow to process the messages. It primarily
    says that this is the way you should pass a message from thread *A* to thread
    *B* in a protected manner, to ensure both the publisher and the subscriber are
    protected.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig further into the specifications, (we will come to the TCK a little
    later) and see how they correspond with the original statement of the Reactive
    Streams manifesto. Starting with the publisher, we see that the specifications
    also define a set of rules that must be adhered to by the implementer of the specifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules are defined for all the four interfaces: publisher, subscriber, subscription,
    and processor. It won’t be possible to go through all the rules here, and neither
    it is required, as the rules are available at: [https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.2/README.md](https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.2/README.md) .'
  prefs: []
  type: TYPE_NORMAL
- en: However, in order to draw some relevance from the Reactive Streams manifesto,
    let’s look at some of the important rules. We will analyze one or two rules each
    from all four interfaces to help you understand how they are laid out. Do have
    a look at the glossary table before reading these rules and specifications.
  prefs: []
  type: TYPE_NORMAL
- en: You should have a look at the rest of the rules, as going through them will
    give you a good idea about how detailed the rules are. By the time you finish
    reading all the rules, you will have a very good grasp of what to expect from
    the implementation of Reactive Streams.
  prefs: []
  type: TYPE_NORMAL
- en: Publisher rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Publisher` has the following interface definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Rule number 1.1 says, the total number of `onNext`signaled by a `Publisher`
    to `Subscriber` must be less than, or equal to, the total number of elements requested
    by that `Subscriber`Subscription at all times*.* There are multiple facets to
    this definition here. Let’s try to analyze them one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: First and foremost, there has to be a request for a message from `Subscriber` (total
    number → 1 - N) to `Publisher`. Therefore, `Publisher`cannot start sending messages
    to unsuspecting subscribers on its own as these subscribers might still be deciding
    when to start receiving messages. Furthermore, some might still be performing
    some initial tasks in order to start receiving the message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, only after the request is received by `Publisher` can it begin transmitting
    the messages to `Subscriber`. In response to the request for messages from `Publisher`,
    Subscriber receives `Subscription`. Now `Subscriber`can use `Subscription` to
    interact with `Publisher` and vice versa. How many messages `Publisher` should
    send is mentioned in `Subscription` so the requested messages by `Subscribers`
    should be less than or equal to that number `[message count <= total number]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thirdly, `Publisher` cannot send more messages to `Subscriber` than requested
    by `Subscriber`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three points together form a part of the backpressure we mentioned when
    we began with Reactive Streams.
  prefs: []
  type: TYPE_NORMAL
- en: And yes, the count requested by  `Subscriber` from `Publisher` is not binding
    on `Publisher` as per the other rule, not binding with respect to the count of
    messages. `Publisher` is allowed to send less than the requested count of messages
    from `Subscriber`. This can be described with the following.
  prefs: []
  type: TYPE_NORMAL
- en: Subscriber rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Subscriber` has the following interface definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Rule number 2.1 says, A `Subscriber` must signal demand via Subscription.request(long
    n) to receive `onNext` signals.This rule is in line with `Publisher` rule number
    1.1 in the sense that it  establishes the responsibility of `Subscriber` to inform
    when and how many messages it is able and willing to receive.
  prefs: []
  type: TYPE_NORMAL
- en: Rule number 2.4 says, `.onComplete()` and `Subscriber.onError(Throwable t)`
    must consider the `Subscription` cancelled after having received the signal*.* Here
    again, the design intention at play is highlighted. The design sequence of sending
    ensures that the process of the message being sent from `Publisher` to `Subscriber`
    is completely decoupled. Therefore, `Publisher` is not bound by the `Subscriber` intent
    to keep listening, hence ensuring a non-blocking arrangement.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as `Publisher` sends out a message, it has no messages to be sent with `Subscriber.onComplete()` and the
    `Subscription` object is no longer valid/available. This is similar to when an
    exception is thrown back with `Subscriber.onError(Throwable t)`*.* The `Subscription`
    object can no longer be utilized by  `Subscriber` to request more messages.
  prefs: []
  type: TYPE_NORMAL
- en: It is worthwhile mentioning another couple of rules around the same design.
    These are rules number 2.9 and 2.10 concerning `Subscription.request(long n)`.
    The rule says that a `Subscriber` can get the `onError` signal or the `onComplete`
    signal with or without a preceding call to `Subscription.request(long n)`.
  prefs: []
  type: TYPE_NORMAL
- en: Subscription rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following interface describes the `Subscription` notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The rule number 3.2 says, `Subscription` must allow the `Subscriber` to call
    `Subscription.request` synchronously from within `onNext` or `onSubscribe`*.* It
    talks about preventing both `Publisher` and `Subscriber` by restricting posting
    of the message only when  `Publisher` gets the signal for a further request from
    `Subscriber`. This happens in a synchronous manner to avoid a stack overflow.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar context, another rule, number 3.3, states, `Subscription.request()` must
    place an upper bound on possible synchronous recursion between `Publisher` and
    `Subscriber`*.* It complements rule 3.2 in a sense by deciding an upper limit
    in the recursive interaction between `Publisher` and `Subscriber` in the form
    of the `onNext()` and `request()` call. Setting the upper limit will avoid blowing
    out when calling a thread stack. The rules starting from number 3.5 to 3.15 describe
    the behavior of cancelling and completing the request.
  prefs: []
  type: TYPE_NORMAL
- en: Processor rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Processor` is described with the following interface definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It has just two rules. The first rule talks about the contract that must be
    followed by both `Subscriber` and `Publisher` , while the second rule is intended
    to handle the error situation, either recover or propagate to `Subscriber`.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Streams TCK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing the interfaces defined in Reactive Streams specification is not
    just suffice to build Reactive Streams. The specification comprises a set of components
    and rules. The components part is taken care of with four interfaces we discussed,
    while the rules are defined by Reactive Streams **Technology Compatibility Kit** (**TCK**).
  prefs: []
  type: TYPE_NORMAL
- en: The Reactive Streams TCK is a guideline to Reactive Streams implementors to
    verify their implementations against the rules defined in the specifications.
    The TCK is developed with a testing framework in Java called **TestNG** and can
    be used in other JVM-based programming languages, like Kotlin and Scala.
  prefs: []
  type: TYPE_NORMAL
- en: TCK covers most of the rules, but not all, defined in the specification because
    for some of the rules, it is not possible to construct automated test cases. So
    theoretically, it can't be verified fully against the specification; however,
    it is helpful to validate most of the important rules.
  prefs: []
  type: TYPE_NORMAL
- en: TCK comprises four TestNG test classes and contains test cases, which can be
    extended by implementers and provide their implementation of `Publisher`, `Subscriber`,
    `Subscription`, and `Processor` to validate against the specification rules. You
    can get it in further detail from the link: [https://github.com/reactive-streams/reactive-streams-jvm/tree/master/tck](https://github.com/reactive-streams/reactive-streams-jvm/tree/master/tck).
  prefs: []
  type: TYPE_NORMAL
- en: RxJava
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting with version 8, Java began supporting reactivity features as inbuilt
    capability, yet they were not used widely and didn't become popular among developers.
    However, some third party implementations of Reactive Programming in Java showed
    its advantages and it grew in popularity in the Java community.
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing but the set of tools called **Reactive Extension** (or simply
    ReactiveX) allowing implementation of Reactive Programming for composing asynchronous
    and event-based programs using observable sequences. It is a Java VM (Virtual
    Machine) implementation of Reactive Extension. Initially written on Microsoft
    platforms, Reactive Extension offers reactive capabilities to various other programming
    languages, and one of the most popular among them is RxJava for the Java programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: It was the first Reactive Extension API specific to the Java platform*. *RxJava
    is compatible with older versions of Java and provides a facility to write asynchronous,
    event-based programs for both Java and Android platforms, which is very convenient. ReactiveX
    also covers other programming languages with Reactive Extension, like RxJs, Rx.Net,
    UnixRx, RxScala, RxCloujure, RxCPP, Rx.rb, and RxKotlin, along with other platforms
    and frameworks like RxCocoa, RxAndroid, and RxNetty.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of RxJava
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RxJava basically extends the observer pattern to support iteration on the sequence
    of event/data and allows the forming of sequences at the same time as abstracting
    away the low-level details, like threading, synchronization, concurrency, and
    thread safety.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, the current version of RxJava-2.6 has a single dependency
    on Reactive Streams API and provides support for Java 6 and the later versions, along
    with Android 2.3+. Before going deep into RxJava, let''s look at the basic building
    blocks of ReactiveX as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Observable`: It is  basically a data stream or in other words a source of
    data. It can emit the data just one time or periodically in a continuous manner,
    based on the configuration. `Observable` can send out specific data on particular
    events based on the operators used with `Observable`.  In short, `Observable`
    is the supplier of data to other components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observer`: The data stream emitted by `Observable` is consumed by Observers.
    For that, they need to subscribe to  `Observable` using the `subscribeOn()` method.
    One ore more observers can be subscribed to `Observable`. When  `Observable` sends
    the data, all registered observers receive the data with the `onNext()` callback
    method. Once the data is received, you can perform any operation on that. In case
    any error occurred during the transmission, observers will get the error data
    with the `onError()` callback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Scheduler`:They are used for thread management to achieve asynchronous programming
    in ReactiveX. They will instruct `Observable` and `Observer` to choose particular
    thread on which they can execute the operations. For that, `Scheduler` provide
    the `observerOn()` and `scheduleOn()` methods for the `Observer` and `Observable`
    respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s understand these concepts with a practical example. We will create a
    Maven project in Eclipse with settings as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a177cf08-19f9-42db-af13-7b18e75118aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to give RxJava specific dependency. The current version at this moment
    is 2.2.6\. After adding the dependency,  `pom.xml` should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new Java class with an appropriate package and add the following code
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `adminUsers` instance is of type `Observable<String>` that pushes five strings literals
    (name of admin users), which is essentially a data stream or the source of data.
    For simplicity, we have taken String Literals, but `Observable` can push the data
    or events from any source, such as a database query result, social media feed,
    REST API response, or anything similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Observable.just()` method is used to emit a fixed set of string literals.
    The last line of the code describes how the `Observer` can subscribe to `Observable`
    with the `subscribe()` method. It is defined as a lambda expression that specifies
    what to do with the string it receives from `Observable`. This relation can be
    described in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd64d3e2-a436-40b8-bf0c-6115074fbd17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this code, `Observer` is simply printing the string literal. RxJava provides
    several operators that can be used in between `Observable` and `Observer`*.* These
    operators are used to transform or manipulate each pushed data passed in between.
    Each operator processes the data coming from previous `Observable` and returns
    new `Observable`. Let''s use one of the operators called `map` and update the
    code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, the data emitted by the `adminUsers` observable is passed through
    a map operator before being sent to `Observer`. The `map` operator here provides
    a lambda expression, which is used to process the submitted data from `adminUsers`.
    It basically prints the return string if it starts with `D` or else simply returns
    a string with an asterisk mark (`*`). The  `map` operator returns new `Observable`
    that returns the data processed by the `map` operator and finally sends it to
    `Observer`. You will see the output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d72c518-2035-4803-a37e-fd3542deda26.png)'
  prefs: []
  type: TYPE_IMG
- en: Observer event calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we discussed so far is very high-level information about how we can use
    `Observable` in RxJava. It basically pushes (emits) the items (data or events)
    of a given type through a series of operators (if defined) until it reaches  `Observer`.
    Let's dig into more details to understand which mechanism works under the hood
    between this interaction and how RxJava complies with Reactive Streams specifications.
  prefs: []
  type: TYPE_NORMAL
- en: '`Observable` interacts with `Observers` through the following event calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onNext`: This is the call from where data/events are being sent, one at a
    time, down to all registered `Observers`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onComplete`: This event is used to signal completion of communication to all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observers`: It simply denotes no more `onNext` calls happen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onError`: In case any error occurs before an `onComplete()` call, an `onError()`
    event is used to signal the error from `Observable` to `Observers`. `Observable`
    will stop emitting the data and `Observers` will handle the error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These events are defined as an `abstract` method in the `Observer` type, and
    we will see the implementation type later in this chapter. First let''s see how
    these event calls happen during the interaction with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`Observable.create()` is a factory method and used to create `Observable` with
    the emitter. The `onNext()` method of the emitter is used to emit (send) the data/events
    (one at a time) to the `Observable` chain (and finally to registered `Observers`).
    The `onComplete()` method is used to terminate further communication.'
  prefs: []
  type: TYPE_NORMAL
- en: If you try to make an `onNext()` call after `onComplete()`, the data will not
    be transmitted. In case any error occurs, the `onError()` method is called. It
    is used to push up the error to the `Observable` chain where it is handled by
    `Observer`. In this code, there is no chance of any exception, but you can handle
    any error with `onError()`.
  prefs: []
  type: TYPE_NORMAL
- en: We have used the `map` and `filter` operators to refine the data to uppercase
    and starting with `D` respectively. Finally, they are printed by `Observer`. The
    flow of data will happen from `onNext()` →`map`→`filter`→`Observer`.  Each operator
    will return new `Observable` class in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: You notice that in the first example we used the `Observable.just()` method
    to emit the data. It internally invokes the `onNext()` method for each of the
    values pushed. On getting the last value, it will call `onComplete()`. So `Observable.just()`
    is equivalent to `Observable.create()` calling `onNext()` on each data and `onComplete()`
    on last one. The `create()` method is generally used for sources that are not
    reactive in nature.
  prefs: []
  type: TYPE_NORMAL
- en: Observable for iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Observable` provides support to emit the data from any iterable sources, for
    example, lists, maps, sets, and so on. It will call `onNext()` on each item of
    an iterable type, and once the iterator is over, it will call `onComplete()` automatically.
    Iterable in Java is commonly used in collection frameworks, so `Observable` with
    iterable can be used while fetching data from collection classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We are populating the list of `EmployeeRating` and creating `Observable` with
    the`fromIterable()` method by passing this list. The class `EmployeeRating` is
    a simple POJO containing the `name` and `rating` attributes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: RxJava conforms to Reactive Streams specification by providing an implementation
    of interfaces. Let's recall that the `onNext()`, `onError()`, `onSubscribe()`,
    and `onComplete()` methods are part of the Observer interface. RxJava provides
    an implementation of these interfaces to handle respective events.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Observers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how data emits from `Observable`, passes through a down stream
    of operators and eventually reaches `Observer`. Apparently, we can say that the
    data is transmitted from a series of `Observable` because each operator returns
    new `Observable` , which forms an `Observable` chain. The first `Observable` where
    the emission originates is called the `Observable` source. Therefore, we can say
    that `Observable.create()` and `Observable.just()` return the `Observable` source.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can provide our custom implementation to handle the `Observer` events as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Like previous examples, we have defined the `Observable` with the list of months.
    We also defined custom `Observers` with an implementation of various methods that
    will be called on for a specific event. When we register the observer (`customObserver`
    in our case), `Observable` will call the `onSubscribe()` method on `Observer`.
  prefs: []
  type: TYPE_NORMAL
- en: Every time when `Observable` emits the data, it will call `onNext()` of registered
    observers, which will then be processed by observers. On sending the last data,
    `Observable` will call the `onComplete()` method on `Observer`. In case if any
    error occurs in between, `Observable` will call `onError()` method on `Observer`.
  prefs: []
  type: TYPE_NORMAL
- en: Certainly, the data will be passed through the `Observable` chain. In the previous
    case, the data emitted from the `Observable` source (`months` in this case) will
    be forwarded downstream to the `filter` operator, which will then reach the Observer
    or endpoint where the data is consumed and processed. By processed, we mean the
    data can be saved to the database, sent as a server response, written to the external
    document management system, composed as a structure for UI rendering, or simply
    printed in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will get an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b47c535e-e710-4c86-a677-40b006a98446.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we have used an anonymous class to provide a custom implementation
    of Observer's methods. However, you can use a lambda expression for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Observable types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the examples we have seen in previous subsections of the RxJava section,
    the data was created within Observable.  However, in the real scenario, that data
    comes from other sources like databases, REST APIs, and so on. The representation
    of any set of data/values is referred to as the producer. Observables are divided
    broadly into the following two categories based on where the procedure is cited.
  prefs: []
  type: TYPE_NORMAL
- en: Cold Observable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the `Observable` itself creates the procedure or, say, `Observable` produces
    the data stream itself, it is said to be cold `Observable`. Generally `Observable`
    is lazy in nature, meaning it only emits the data when any `Observer` subscribes
    to it. Cold `Observable` always starts a fresh execution for each subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, cold `Observable` emits separate data/event streams for individual
    Observers. All examples we have seen so far were of a cold `Observable` type,
    where we have created a data stream with the `just()` or `create()` method. Let's
    see how cold `Observable` works for more than one Observer subscribed, with the
    following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, the data is created by `Observable` itself so it is called **cold
    Observable**.  We have subscribed two different Observers. When you run this code,
    you will get an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e87f0f89-91c7-4f0c-9e0b-6b8fc87e0818.png)'
  prefs: []
  type: TYPE_IMG
- en: Cold `Observable` provides a separate data stream for each `Observer` so when
    we applied the filter for first `Observer` there is no effect in the second `Observer`.
    Also if there are more than one `Observer`, then `Observable` will emit the sequence
    of data to all observers one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Hot Observable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hot `Observable`, on the other hand, has the producer created or activated
    outside of it. Hot `Observable` emits the stream that is shared by all observers.
    Let''s see the example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `observableInterval` observable emits the event instead of data in this
    example. The `interval` method is used to emit sequential numbers at given intervals.
    We have used `PublishSubject` to make this observable as a hot type.  It can be
    behave as either `Observable` or `Observer`. It is part of the `Observable` chain
    in this case. We then simply add two subscribers to `PublishSubject` with some
    delay in between. You will get an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a217de70-15dd-4b7d-b788-333717a26b7d.png)'
  prefs: []
  type: TYPE_IMG
- en: The second `Observer` is subscribed after some delay to the first `Observer`.
    The `Observable` emits the sequential number every two seconds. The second `Observer`
    starts at the fourth second. Hot `Observable` emits just a single stream, which
    is shared across all `Observers`. So, in the case of the second `Observer`, the
    actual value is started from `2` instead of `0` as it subscribes after some time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this sense, hot `Observable` can be compared with a subscription to a radio
    station. A person who starts listening will not be able to hear what was played
    before he subscribed, as it is common to all subscribers (or say Observers in
    Reactive language). There are other ways to create hot `Observable`. We will see
    one of them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, hot Observable is created with `ConnectableObservable`. It will
    not start emitting the data until the `connect` method is called on it, making
    it more controllable. Soon after the `connect` method is called, it will start
    a single stream, which is shared across the Observers. You will get an output
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94131b24-bdd1-43f9-8bcd-2faec6bfba0f.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see how the second Observer missed the first few items as it was subscribed
    with some delay. You can convert any cold Observable to `ConnectableObservable`
    by calling the `publish` method on it.
  prefs: []
  type: TYPE_NORMAL
- en: Other ways to get Observable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far we have seen how to get `Observable` with `just()`, `create()`, and `interval()`.
    However, there are other sources to get the `Observable`. You can get full details
    about each source from at:[https://github.com/ReactiveX/RxJava/wiki/Creating-Observables](https://github.com/ReactiveX/RxJava/wiki/Creating-Observables):'
  prefs: []
  type: TYPE_NORMAL
- en: '`range`: If you want to emit a consecutive range of integers, you can use the `Observable.range(int
    from, int to)` call. As its name suggests, it will start emitting a number from
    the start value in increments until the end count is reached.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`empty`: In a rare situation, you need to create `Observable` that emits nothing
    and calls `onComplete()`. In this case, you can use this source type with the `Observable.empty()` call.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`never`: It is equivalent to `empty` with the difference being that this will
    never make a call to `onComplete()` and keep the `Observable` waiting to emit
    a state. This is also used less frequently.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`error`: If you wish to create `Observable` that immediately calls `onError()`,
    you can use this source with the `Observable.error()` call. It is used for testing
    purposes mainly.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`future`: It was introduced way back and used as a placeholder for the result
    that is not yet produced. `Observable` is more powerful than `future` but if you
    are using old libraries, you can convert `Observable` to `future` with the `Observable.future()`
    call.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`defer`: This is basically used to create a separate state for each `Observer`.
    It is useful when the source of the stream is stateful. If you want your observers
    to reflect the changes happening to the  `Observable` state, then you can use
    this source type with an `Observable.defer()` call.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`single`: This type of `Observable` just emits a single value and can be used
    with a `Single.just()` method call.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`maybe`: It is similar to the `single` type, the only difference that it emits
    zero or one data at maximum and can be used with a `Maybe.just()` call.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`fromCallable`: If you want to perform certain actions of computation before
    emitting the data, you can use this source with an `Observable.fromCallable()` call. In
    case any error occurs and you want to pass it to the `Observable` chain through
    an `onError()` call instead of throwing the error, you can use this source type.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen operators like map and filter in previous examples. They are basically
    used to perform a specific operation on the stream of data and return new `Observable`
    to form an `Observable` chain. Operators themselves are `Observers` to the `Observable`
    they are called on.
  prefs: []
  type: TYPE_NORMAL
- en: 'RxJava has a rich set of operators used to perform various operations with
    the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating observables:** The set of operators used to create new `Observable`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transforming observables:** Operators used to transform items emitted by
    observables they called upon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filtering observable:** Operators used to emit selective data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Combining observable:** Used to combine multiple source observables to form
    a single `Observable`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handling:** Operators that are used to recover from the error condition
    notified from `Observable`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utility Operator:** Used to perform some miscellaneous operations with `Observable`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conditional and Boolean operators:** Used to evaluate one or more `Observable`
    or even emitted items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mathematical and aggregate:** Operators used to perform various operations
    on the entire sequence of emitted data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is good to visit: [http://reactivex.io/documentation/operators.html](http://reactivex.io/documentation/operators.html),
    [to get full details about each of the operators, instead of having details listed
    here.](http://reactivex.io/documentation/operators.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Project Reactor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Reactor can be called the reactive library on top of the JDK. Java doesn’t
    support Reactive Programming natively, and Reactor is one of the many libraries
    out there. Reactor comes from the open source group Pivotal and conforms to the
    Reactive Streams standard. It is built on Java 8 and ReactiveX vocabulary.
  prefs: []
  type: TYPE_NORMAL
- en: It is worthwhile to note here that, although asynchronous seems to be an important
    attribute for  Reactive Programming, the Reactor doesn't force you to go asynchronous/synchronous,
    as it supports both. It depends on the scheduler chosen. That choice is yours.
    In order to understand the Reactor in a better way, we need to understand Reactive
    Streams in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Reactor features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reactor provides event-based architecture and is used to handle a large volume
    of requests concurrently and asynchronously, making a non-blocking and backpressure
    equipped system. With the Project Reactor, you have no need to implement Reactive
    Streams yourself as it provides a set of modules, which are embedded and interoperable. It
    provides the following stunning features:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling data stream with high volume
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Project Reactor is capable of providing an API support for specific data cardinality,
    ranging from generating endless streams to publishing just a single data entry.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of waiting for the entire data stream to process, Project Reactor enables
    the subscribers to handle the elements of a stream as they arrive. This makes
    the data processing operation more flexible and optimized by improving resource
    utilization. The memory required to be allocated to a subscriber is limited because
    data processing happens in a subset of items arriving at a particular time, rather
    than processing entire data streams in one go. Also, this makes the system more
    responsive as the results will start as soon as the first set of elements is received,
    instead of waiting until all items have been received and processed to deliver
    a final output.
  prefs: []
  type: TYPE_NORMAL
- en: Push-pull mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Project Reactor has good assistance for proving a push/pull feature. There are
    practical scenarios where consumers intake the data at a slower rate than the
    producer emits them. In this case, the producer will raise the event and wait
    for Observers to pull it. In some situations, the consumer works faster than the
    producer. To handle it, consumers wait for the events to be pushed from the producer
    side. Project Reactor enables this flow to be dynamic in nature whenever necessary.
    It will be controlled by the rate of production and consumption.
  prefs: []
  type: TYPE_NORMAL
- en: Handling concurrency independently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reactor execution paradigm is capable of handling concurrency independently,
    which truly makes it concurrency agnostic. The Reactor library handles the data
    stream in a more abstract way, rather than talking about how to execute different
    types of streams. The transactions happening during various operations are safe
    out of the box. Reactor provides a set of operators that handle different synchronous
    streams in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactor provides a set of operators that plays a vital role in the execution
    model by handling different synchronous streams in different ways. These operators
    can be used to filter, map, select, transform, and combine the data streams. They
    can be combined with other operators to build high-level, easy-to-operate, and
    highly customized data pipelines to process streams in the way you want.
  prefs: []
  type: TYPE_NORMAL
- en: Reactor sub-projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project reactor consists of various sub-projects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reactor Core:** This project provides an implementation of Reactive Streams
    specification. Spring Framework 5.0 provides support for Reactive Programming
    with the Reactor Core sub-project as a foundation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reactor Test:** This contains necessary utilities for test verification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reactor Extra:** On top of Reactor Core, this project provides various operators
    to work on the data stream to perform required operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reactor IPC:** This project provides backpressure furnished and non-blocking
    inter-process communication support over various network protocols, like HTTP,
    TCP, UDP, and web sockets. Due to this nature, this module is also helpful when
    building asynchronous microservice architectures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reactor Netty: **It is used to provide a reactive feature to Netty, a client
    server framework to develop network applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reactive Kafka: **It is a reactive API for Apache Kakfa-based projects. It
    is used to communicate with Kakfa in a non-blocking and functional way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reactive RabbitMQ: **This project is used to equip RabbitMQ  (a message broker
    system) with reactive capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactor types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project Reactor is built with two core types based on the number of elements
    they process. They are considered as main building blocks to create a Reactive
    System using Reactor. They are `Flux` and `Mono`. They both implement the `Publisher<T>`
    interface and conform to Reactive Streams specification, and  are furnished with reactive-pull
    and back-pressure facility. They also have several other useful methods. Let''s
    explore the details as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Flux`: It can be considered the equivalent of RxJava''s Observable and can
    emit zero or more items, ending successfully or with an error signal. In short,
    it represents asynchronous event streams having zero or more elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mono`: It can emit, at most, one element at a time. It is equivalent of the `Single`
    and `Maybe` Observable type from the RxJava side. A `Mono` type can be used for
    one-to-one request-response model implementation; for example, a task wish to
    send a completion signal can use a `Mono` type reactor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The clear difference between the number of elements a reactor type can handle
    provides useful semantics and makes it an easy decision to choose which reactor
    type. If the model is sort of *fire and forget* then choose the `Mono` type. If
    execution is dealing with multiple data items or elements in the stream, then
    the `Flux` type is more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, various operators play a vital role in deciding the type of reactor.
    For example, calling a`single()` method on a `Flux<T>` type will return `Mono<T>`,
    while concatenating multiple entities of type `Mono<T>` together with `concatWith()`
    will result in the `Flux<T>` type. The reactor type can influence which operators
    we can use with it. For example, some operators are applicable to either one of  `Flux`
    or `Mono` while others can be used for both of them.
  prefs: []
  type: TYPE_NORMAL
- en: Reactor in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s learn more about the reactor API with a practical example. Create a
    new Maven project similar to what we created in the *Anatomy of RxJava* section.
    The current version of the Project Reactor at the time of writing  is 3.2.6. We
    need to provide a Maven dependency for the reactor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When we define a Reactor dependency, Reactive Streams JAR will be added as
    a transitive dependency. Next, is to add a Java class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used `Flux` and `Mono` to create various publishers. The  `just()` method
    is used to populate the stream. We can also reach the iterable types (like `List`,
    `Set`, `n`) to form a data stream with the `fromIterable()` method. A few other
    methods like `from()`, `fromArray()` , and `fromStream()` are used to construct
    data streams from other producers, arrays, and existing Java streams, respectively,
    and can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The subscriber can be plugged with the `subscribe()` method. This is similar
    to what we have done with Observable in RxJava. With `Flux`, we can create a publisher
    with the finite or infinite stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also control to generate a stream with a value or just an empty stream.
    All of that can be done with a few utility methods provided by the `Flux` class
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Flux.empty()`: It is used to generate an empty stream having no values and
    only executes completion events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flux.error()`: It is used to signal the error condition by generating an error
    stream with no any value but only errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flux.never()`: As its name suggests, it generates a stream with no events
    of any type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flux.defer()`: It is used to construct a publisher when a subscriber makes
    the subscription to `Flux`. In short, it is lazy in nature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of subscribers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Flux` and `Mono` classes both allow Java 8 lambda expressions as a subscriber.
    They also support various overloaded versions of the `subscribe()` method, as
    per the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Flux` class is created with list of strings. There are five different
    variations of using the `subscribe()` method, and each has provision to capture
    various events. The detail is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first version does not consume any event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second variant consumes the value event and it is defined with a lambda
    expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third `subscribe()` method listens to error events as a second argument
    along with the value events. We are simply printing stack-trace through lambda
    expressions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth one consumes value, error, and completion events. On completion of
    a data stream, the completion event will be executed, which we listen to with
    a lambda expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fifth version consumes value, error, completion, and subscription events.
    The last parameter of the `Subscription` type makes this version of `subscribe()`
    a special case. The `Subscription` type has a method called `request()`. The publisher
    will not send any event until, and unless, the subscriber sends a demand signal
    with a `Subscription.request()` call. This is only applicable if `Subscription`
    is defined for the subscriber. We have to make a method call as `s.request(5L)`,
    meaning the publisher can only send five elements. It is less than than the total
    value in publisher and fires a completion event. In our case, the total elements
    in a data stream is five, and so it will call a completion event. If you pass
    fewer than five, you will not get a completion event call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom subscribers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a certain scenario, calling a `Subscribe` method on `Publisher` is not appropriate
    and you may want to write custom subscriber with own handling. Reactor framework
    provides support for defining custom subscribers by extending the `reactor.core.publisher.BaseSubscriber<T>` abstract
    class. You don''t need to implement the `Subscribe` interface of Reactive Streams
    specification directly. Instead, you need to just extend this class to apply the
    custom implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The  `BaseSubscriber` class provides various hook methods, which represent the
    corresponding event. It is a placeholder to provide a custom implementation. Implementing
    these methods is similar to using various versions of the `subscribe()` method
    that we have seen in the *Type of subscriber* section. For example, if you only
    implement the `hookOnNext`, `hookOnError` , and `hookOnComplete` methods, then
    it is equivalent to the fourth version of `subscribe()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The  `hookOnSubscribe()` method facilitates a subscription event. The backpressure
    is provided with `subscription.request()`. You can request as many element, as
    you want. For example, update the code for the `hookOnSubscribe()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We are requesting records one-by-one by calling `subscription.request(1)` in
    a loop. To get an idea how it works, we put a two-second delay in between so you
    will get a record for every two requests. Once all data is completed, it will
    trigger the completion event and the `hookOnComplete()` method will be called.
    The output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82109b35-b274-45f0-a097-21e7a1dee3bb.png)'
  prefs: []
  type: TYPE_IMG
- en: Reactor lifecycle methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reactor provides lifecycle methods to capture various events happening in publisher-subscriber
    communication. Those lifecycle methods are aligned with Reactive Streams specification.
    Reactor lifecycle methods can be used to hook custom implementation for a given
    event. Let''s understand how that works with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We are creating the `Flux` object with data from a list and then calling various
    lifecycle methods, like `doOnComplete()`, `doOnNext()`,  `doOnSubscribe()`, `doOnError()`,
    and `doOnTerminate()` in a chain. Finally, we call the `subscribe()` method, which
    does not consume the events, but all lifecycle methods will be executed as appropriate
    events are triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is similar to the custom subscriber implementation in the *Custom subscribers*
    section. You will see a similar output. The details of these lifecycle methods
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`doOnComplete()`: Once all the data is received by the `Subscriber`, this method
    will be called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doOnNext()`: This method will listen to the value event coming from the producer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doOnSubscribe()`: Used to plug  `Subscription`. It can control the backpressure
    by defining how many more elements are required with a `subscription.request()`
    call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doOnError()`: If any error occurs, this method will be executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doOnTerminate()`: Once the operation is completed, either successfully or
    with error, this method will be called. It will not be considered on a manual
    cancellation event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doOnEach()`: As the name suggests, it will be called for all `Publisher` events
    raised during stream processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doFinally()`: This will be called on stream closures due to error, cancellation,
    or successful completion of events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ratpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ratpack is set of Java libraries which are event driven, non-blocking, high
    performance, and asynchronous in nature to build scalable services with HTTP.
    It conforms to the Reactive Streams specification, meaning it comes with interoperability
    out of the box. It is built on Netty—a framework to build a client-server application
    over the network with quick and easy development.
  prefs: []
  type: TYPE_NORMAL
- en: It is a web framework to develop efficient and lightweight JVM-based applications.
    It has its own testing library to easily set up test cases. Spring provides support
    for Ratpack. You can get more information about Ratpack from its official site:  [https://ratpack.io](https://ratpack.io).
  prefs: []
  type: TYPE_NORMAL
- en: Akka stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Akka stream provides an implementation of Reactive Streams specifications on
    top of the Akka toolkit that uses Actor patterns for  the concurrency execution
    model. It processes the stream of data asynchronously and in a non-blocking backpressure
    way with Actor. Apart from Java, Akka also works well with Scala language. Explore
    more about the Akka stream at the link [https://akka.io/docs](https://akka.io/docs).
  prefs: []
  type: TYPE_NORMAL
- en: Vert.x
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vert.x is another tool kit provided by the Eclipse Foundation project used to
    build a JVM-based Reactive System. It also provides an implementation of Reactive
    Streams specifications similar to Ratpack. Vert.x supports and allows the use
    of RxJava to build a Reactive System. Needless to say, Vert.x is event based and
    non-blocking in nature. It supports various programming languages, like Java,
    JavaScript, Ruby, Groovy, Ceylon, Scala, Kotlin, and so on. You can learn more
    about it at:  [https://vertx.io](https://vertx.io).
  prefs: []
  type: TYPE_NORMAL
- en: Reactive support in Spring Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring is a modular framework and used to build every aspect of an application
    from the web to the persistence layer. Each module is considered as a sub-framework
    and targeted for a specific area of development. For example, to support a web
    layer with a servlet API,  the Spring MVC module was included in the Spring Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, to support a reactive stack in the web layer, Spring WebFlux was
    introduced in Spring Framework 5\. It is fully non-blocking, backpressure, asynchronous,
    and compliant with Reactive Streams specifications. It can be run on Servlet 3.1+,
    Netty, and Undertow containers.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Framework has both the stacks, Spring Web MVC and spring-WebFlux, and
    developers are free to use either of them, or in some scenarios to mix both of
    them to develop a Spring-based web application. The typical example would be using
    spring MVC controller with reactive WebClient; we will talk more about this in
    the latter part of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Spring WebFlux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring 5 impressively supports creating a Reactive System with Spring WebFlux
    . It is a new reactive web application framework, developed based on the Project
    Reactor API and can also be used to build microservices. The most remarkable and
    direct benefit of making any application reactive is to bring asynchronous qualities
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Non-reactive and traditional Java-based applications use thread mechanisms for
    asynchronous and parallel programming. However, usage of the thread is not competent
    and scalable in any manner. On the other hand, Spring WebFlux encourages event
    loop-based programming, which is asynchronous and non-blocking in manner. This
    section introduces WebFlux in the context of the Spring Framework and Reactive
    Programming.
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC versus Spring WebFlux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring MVC has been part of the Spring Framework since version 2, and since
    then, has been a de facto standard when developing web-based applications with
    Spring Framework. To support Reactive Programming, Spring has introduced the WebFlux
    module. Therefore, it is important to understand the similarities and differences
    between Spring MVC and Spring WebFlux.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring team has done it the hard way and kept the WebFlux syntax similar
    to the Spring MVC, but under the hood it has completely new technology. One of
    the prime differences between these two modules is the mechanism by which they
    handle the request. Spring MVC is based on a pure servlet API and works with a
    thread pool. This means that, every request has one thread from the controller
    to the persistence layer and may be blocked for the resources it needs.
  prefs: []
  type: TYPE_NORMAL
- en: However, Spring WebFlux is based on reactive architecture and works with the
    event loop mechanism, providing non-blocking support out of the box. In the event
    loop mechanism, everything happens as a reaction to the event. It is similar to
    a callback function; when any event happens, the callback function gets triggered.
    The concept event loop was introduced by Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, WebFlux needs servlet API support, which works as an adapter layer,
    so that WebFlux can be deployed on both servlet and non-servlet containers. Spring
    MVC is built on top of a servlet API, which is synchronous (like Filter, Servlet,
    and so on) by nature and also performs blocking IO streams.
  prefs: []
  type: TYPE_NORMAL
- en: WebFlux, on other hand, is developed on asynchronous API (WebHandler, WebFilter,
    and so on) and non-blocking IO mechanisms, like `Flux` and `Mono` , which are
    used to handle the stream with a maximum of one value and many elements, respectively.
    Although Spring WebFlux is based on reactor and used by default, it also supports
    other reactive implementations, like Java 9 Flow API, RxJava, and Akka stream.
  prefs: []
  type: TYPE_NORMAL
- en: Both the frameworks, however, support some common features like using some annotation
    (like `@Controller` and `@RequestMapping`) and support for some well-known servers.
  prefs: []
  type: TYPE_NORMAL
- en: We are talking about Reactive Programming support in String with WebFlux; it
    does not mean Spring MVC is of no use. Both frameworks are addressing separate
    concern to the application. Like any framework, WebFlux may not be the best choice
    for all the application types.
  prefs: []
  type: TYPE_NORMAL
- en: So instead of choosing the framework by its features, you need to select it
    as per the requirement. There is absolutely no need to port your existing Spring
    MVC application completely to WebFlux if it is working perfectly well. The excellent
    part of WebFlux is that it can be used in conjunction with Spring MVC (if needed
    explicitly) without any problems.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from this, if your existing Spring MVC application has a dependency on
    other parts that are synchronous and blocking in nature then, adapting WebFlux
    specific changes will obstruct from taking full benefits of reactive paradigm.
    You can decide, however, to pick WebFlux if your application is mainly handling
    the stream of data. If scalability and performance are what you are looking for
    then you can use WebFlux specific changes in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive span across Spring modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By introducing a reactive web framework, WebFlux , Spring also made necessary
    changes in other modules to provide first-class support for WebFlux. Spring Boot,
    Spring Security, Thymeleaf, and Spring Data are among the few modules that are
    equipped with WebFlux capabilities. This can be described with the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7676979f-25e9-46da-aceb-6a29a9fef044.png)'
  prefs: []
  type: TYPE_IMG
- en: Spring Data has adopted a reactive paradigm and started supporting infinite
    streams from the database with the `@Tailable`annotation. Spring Data JPA is mostly
    associated with RDBMS, which is blocking in nature so it cannot support Reactive
    Programming.
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC is inherently blocking in nature; however, we can use Reactive Programming
    for some of the parts, which can be converted to be reactive. For example, the
    Spring MVC controller can be equipped with the `Flux` and `Mono` types to handle
    the data stream in a reactive way.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from this, a few annotations like `@Controller`, `@RequestMapping`, and
    so on are supported in WebFlux so you can convert a Spring MVC application to
    WebFlux in an incremental manner. We will see more details about reactive support
    in Spring Framework through WebFlux by creating a sample application.
  prefs: []
  type: TYPE_NORMAL
- en: Spring WebFlux application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a sample web application with the WebFlux framework. The application
    will simply access existing student information from a data store. Instead of
    making a fully fledged application, we will focus more on how to access data in
    a reactive manner with the WebFlux framework.
  prefs: []
  type: TYPE_NORMAL
- en: We will use Spring Boot to kickstart the development. For those who are new
    to Spring Boot, it is a tool and part of Spring Horizon, which is designed to
    speed up and simplify the bootstrapping and development of new Spring-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: You might have come across bulky XML and other configurations repeatedly in
    Spring projects. The Spring team was well aware of this and has finally developed
    a tool called Spring Boot, aimed at freeing the developer from providing a boilerplate
    configuration, which is not only tedious but time consuming.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a sample web application using MongoDB as a data store. While
    working with Reactive Programming, it is recommended to use non-blocking and reactive
    capable datastores, like MongoDB, Couchbase, Cassandra, and so on. We will use
    a tool called **Spring Tool Suite** (**STS**), which is an Eclipse-based IDE.
    It provides support for creating Spring Boot-based applications. Download it from: [https://spring.io/tools3/sts/all](https://spring.io/tools3/sts/all) and
    install it in your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: The STS link given here is version 3.x. At the time of writing, the current
    version of STS is 4.x. All the codes created in this book are with STS 3.x so
    the link given is version 3.x. However, you can download the latest version of
    STS and play with the code without any problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once downloaded, open it, select the *File | New | *Spring Starter Project menu
    and fill the form as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e3d6a05-6110-42c1-a873-a1366090b9de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Next button, and you will be asked to define the dependencies.
    Choose the following dependencies. You can use the textbox, Available to search
    for a particular dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Web:** Used to add Spring MVC specific dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reactive Web:** To add WebFlux specific dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DevTools:** Helpful for development as it will auto-refresh the changes in
    the embedded container to see the changes quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reactive MongoDB:** Spring Data dependency for MongoDB that works in a reactive
    paradigm. Make sure you don''t select MongoDB, which is a dependency to work with
    MongoDB in the non-reactive model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on Finish, and you will see a project is created in the Package Explorer (or Project
    Explorer) section of STS. Once the project is created, we will perform the following
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, you need to install MongoDB into your local machine. It is distributed
    as a standalone server as well as a cloud service. Download the latest version
    from: [https://www.mongodb.com/download-center/community](https://www.mongodb.com/download-center/community).
    Choose the appropriate OS from the list and install it on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB doesn't has any UI to access it. However, it provides another tool called
    Compass and can be downloaded from: [https://www.mongodb.com/download-center/compass](https://www.mongodb.com/download-center/compass).
    Choose the appropriate version and target platform and download them. In most
    cases, it is directly executable. By default, MongoDB is accessible with the `27017`
    port. Just connect Compass to the MongoDB server to make sure it is running before
    connecting.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before using MongoDB, it is important to understand the schema and data structure
    used in it. Like a relational database, we need to first create a database in
    MongoDB. Along with the database, we also need to create a collection. You can
    consider a collection to be similar to the database table in RDBMS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect the Compass (default: no credentials) and click on the CREATE DATABASE
    button, and you will see model windows as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f78bb8f4-b00b-4848-8fb3-dd8f463fad8a.png)'
  prefs: []
  type: TYPE_IMG
- en: You need to give the Database Name and Collection Nameand click on the CREATE
    DATABASE button from the model window. You can now insert the data for student
    collection into MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Spring Data repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Data provides a consistent Spring-based programming model to access data.
    It abstracts away the low-level boilerplate details and can be used to access
    a wide variety of data stores including the SQL (relational and non-relational)
    database, map-reduce frameworks, cloud-based data services, and so on. The Spring
    Data repository basically implements the data access layer and provides abstract
    access to interact with the underlying data store.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will configure the Spring Data repository to interact with MongoDB. The
    first step is to create an entity object (domain model). Spring Data allows accessing
    data in an object-oriented way, so first we need to define the entity class and
    provide the necessary mapping with the persistence model. An entity class can
    be created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This POJO class represents the student entity in MongoDB with the `@Document`
    annotation. You need to give the same collection name here that we created in
    MongoDB. The attribute ID will be autogenerated by MongoDB and can be considered
    as a primary key for the `Student` entity so it is marked with the `@Id` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next add a Spring Data repository. Spring provide repository support for specific
    data stores. For MongoDB, the Spring Data repository should looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Spring Data provides the `ReactiveMongoRepository` interface that can be extended
    to define a custom repository. It is of the `Student` type, which is an object
    entity type when we want to interact with MongoDB and `String` , which represent
    the primary key (ID in our case).
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Data repository provides a nice feature called the **query** method,
    which is used to access data based on specific column or  attribute values by
    following a certain naming convention. For example, `findByName(String name)`
    will return  `StudentData` with the matching name. Spring Data provides underlying
    implementation of these methods out of the box. For simplicity, we kept just two
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure the Spring application connects to MongoDB, we need to add the
    following properties in the `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is equivalent to defining connection properties in a database.
  prefs: []
  type: TYPE_NORMAL
- en: WebFlux programming models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring WebFlux is flexible enough to support different development patterns.
    You can create an application in WebFlux with the following two programming models:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Annotated controller**: This is much similar than the Spring MVC controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional end point**:  Functional end points are used to process and route
    requests with functional programming features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will explore both these options in the sample WebFlux application that we
    created with the Spring Data repository and entity class. The next part is to
    create a controller, which can be done in the following two ways.
  prefs: []
  type: TYPE_NORMAL
- en: Annotated controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WebFlux provides support for annotation-based configurations in a similar to
    the Spring MVC framework. To begin with, we will create an annotated controller
    class that publishes the Reactive Streams of the `Student` entity from the server
    side as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`StudentWebFluxController` is the annotated controller. It is similar to the
    Spring MVC controller. The `@RestController` annotation is used to define this
    controller as a REST controller. The `@RequestMapping` annotation is used to define
    the URL mapping for this controller.'
  prefs: []
  type: TYPE_NORMAL
- en: The `studentMongoRepository` Spring Data repository supports non-blocking Reactive
    Streams. The `getStudent()` method will return a single `Student` object based
    on the `rollNo` input value. However, the return type is not just in response
    to `Student`; instead, it is of the `Mono` type because it returns at most one
    element, so the `Mono` type is more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The repository gives `Mono<Student>` based on `rollNo`; then we call the map
    function to map the object of the `Mono<Student>` type to `Mono<ResponseEntity<Student>>` ,
    which will be then taken care of by the WebFlux framework to return the student
    data. Add some values directly from MongoDB and try to access it with the URLs [http://localhost:8080/api/getStudent/21](http://localhost:8080/api/getStudent/21)
    (using the `8080` port, and student `rollNo` is `21`) in REST client (for example,
    Postman), and you will get an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e5e5589-fb50-4f7f-81cf-8e3340895527.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In case we want to access more than one student, we need to use the `Flux` return
    type as it emits 0 to N elements. Let''s add one more method to the controller
    to fetch all the students as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some more student data from MongoDB and hit the URL [http://localhost:8080/api/getAllStudent](http://localhost:8080/api/getAllStudent)
    and you will see results as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a4c5d53-2e30-4c7c-a57d-fbdc2bc1473b.png)'
  prefs: []
  type: TYPE_IMG
- en: The WebFlux controller endpoint returns a Publisher in the form of either `Flux`
    or `Mono`. In the second method where we return all the students, it can be in
    the form of a **Server-Sent Event** (**SSE**) to the browser. For that, you need
    to define the return type as `text/event-stream`. The SSE is the technology allowing
    a browser to receive automatic updates from the server via an HTTP connection.
  prefs: []
  type: TYPE_NORMAL
- en: What does this mean? If we have a very huge stream, then the WebFlux controller
    will send the data as it receives from a reactive repository (from MongoDB in
    our case) and send it to the browser, instead of fetching all the records, which
    results in a blocking condition. This is how large volumes of streams are handled
    in Reactive Programming with Spring WebFlux.
  prefs: []
  type: TYPE_NORMAL
- en: Functional endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Framework 5 supports functional programming models for reactive web
    applications with WebFlux. This is an alternative to using the Spring MVC-style
    annotated controller. The functional style programming in Spring WebFlux uses
    the following essential components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HandlerFunction`:It is used to handle the request. It is an alternative to
    the Spring MVC controller handler methods and works similar to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RouterFunction`: It is used to route incoming HTTP requests. `RouterFunction`
    is an alternative to using request mapping with the `@RequestMapping` annotation and
    works similar to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Artifacts required in functional-style Reactive Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first understand these components. They are defined as an interface
    in Spring WebFlux. The `HandlerFunction` interface looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This interface is similar to the `Function<T,R>` type, which takes the value
    (of the `T`type) and returns another value (of the `R`type). In this case, it
    is equivalent to `Function<ServerRequest,Mono<T>` . It is much like a servlet.
    The `T` type is the response type of the function that should implement the `ServerReponse`
    interface, which represents the server-side HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: The  `handle()` method takes the `ServerRequest` object type and returns a `Mono` 
    object type. `ServerRequest` represents the HTTP request, and we can get headers
    and the body of a request from this. Both `ServerRequest` and `ServerResponse`
    are part of the reactive API of Spring WebFlux.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may notice that instead of putting both requests and responses in the same
    method call, the response is returned from the `handle()` method, which really
    makes it side-effect free and easy to test. Let''s see what `RouterFunction` looks
    like. Again it is of the interface type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface has the `route()` method that returns `HandlerFunction` , which
    matches the given request. This method is used to create routes by applying `RequestPredicate`.
    When the predicate matches, it will return the handler function, which basically
    processes the request.  `RequestPredicate` is  the Java8 functional interface
    and part of the reactive API of Spring WebFlux. It is used to test the given `ServerRequest`
    for the routing and looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Let's create the controller in functional-style programming. We will write a
    controller that works exactly the same to the annotated controller but in a functional
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisite for a functional approach in Spring WebFlux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To work in functional way, the very first thing we need to do is to make our
    project WebFlux aware. For that we need to add the `@EnableWebFlux` annotation
    to the main bootstrap class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to instruct Spring that the application is of the `reactive` type
    by adding the following property in the `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Defining routers and handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next part is to define the router and handler for getting the student data.
    Let''s recall that routers are used to route the request as they serve the purpose
    of `@RequestMapping` in the annotated controller, while handlers actually process
    the incoming request, which is similar to the Spring MVC controller handler method.
    The router class looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It is required to declare the router class with the `@Configuration` annotation
    so that Spring container will pick this class at the time of context loading and
    do the necessary configuration. We have two methods to get a single student and
    list of all the student data, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The router is created with the `RouterFunctions.route()` call. The `RouterFunctions` utility
    class has lots of useful functions. The `route()` method needs two parameters.
    The first parameter is of the `RequestPredicate`. type Another helper class `RequestPredicates`
    is used to define `RequestPredicate` with the URL pattern for each router method. The  `RequestPredicate` class
    has various methods corresponding to HTTP methods.
  prefs: []
  type: TYPE_NORMAL
- en: We have used the `GET` method as we want to pull data from REST client with
    the `GET` method. The important thing here is to define any path variable along
    with the URL pattern that will be received in the handler to perform the necessary
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second parameter is of the `HandlerFunction<T>` type, which is supplied
    by the corresponding method of the `StudentHandler` class. The  `studentHandler::getStudent`
    and `studentHandler::getAllStudent`  double column notations will call the `getStudent()`
    and `getAllStudent()` methods  of the `StudentHandler` class respectively. The
    `StudentHandler` class should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Each handler method will have the object of `ServerRequest` as a parameter,
    which will be supplied by the Spring WebFlux framework while they are called from
    routers. The  `ServerRequest` class represents the HTTP request, and we can get
    parameters and body out of it.
  prefs: []
  type: TYPE_NORMAL
- en: In the `getStudent()` method, we are reading the `rollNo` path variable, and
    passing it to the repository method to get student data. The name of the path
    variable here must be the same as the path variable declared as part of the URL
    pattern in a router (`/api/f/getStudent/{**rollNo**}`). Finally, the `ServerResponse`
    class is used to construct a response and return it. To differentiate the functional
    endpoint, we have updated the URL pattern (added `/f/` in between to denote its
    functional endpoints). You will get a similar output to the annotated controller.
  prefs: []
  type: TYPE_NORMAL
- en: The handler methods are not required to be defined with the `@Bean` annotation
    or else you will get an error while starting the application.
  prefs: []
  type: TYPE_NORMAL
- en: Combining handler and router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have written two different classes for the handler and router; however,
    we can declare the configuration that covers the functionality of both the router
    and handler in a single class. This can be done by combining the handler and router
    method pair in one single method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This class has two methods to fetch a single student and all students, respectively.
    In each method, we first create an instance of the handler and then pass it into
    the `route()` method while creating the router. The lambda expression is used
    to define the handler. The code is easy and straightforward. Again to make it
    unique, we have changed the URL pattern by adding `/combine/` in between so the
    endpoints of getting a single student and all students can be accessed with the
    URL [http://localhost:8080/api/f/combine/getStudent/21](http://localhost:8080/api/f/combine/getStudent/21)
    and [http://localhost:8080/api/f/combine/getAllStudent,](http://localhost:8080/api/f/combine/getAllStudent)
    respectively. You will get a similar output to when we defined handler and router
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering how this works under the hood. The bean of the `RouterFunctionMapping` type
    scans the packages and retrieves all `RouterFunctions` at the time of starting
    the application. This bean is created within `WebFluxConfigurationSupport`, which
    is the headquarters of the Spring WebFlux configuration. All these things start
    happening when we define the `@EnableWebFlux` annotation to the main bootstrap
    class along with the `spring.main.web-application-type=reactive` property.
  prefs: []
  type: TYPE_NORMAL
- en: Composite routers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have lots of routers in your configuration, you can basically compose
    them into a chain with the `and` operator. In the previous example, we defined
    two routers in two different methods. This can be combined in just one method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `and` operator is used to combine two routers. Also, the second parameter
    of the `rout()` function, which is of the  `HandlerFunction<T>` type, is defined
    with a lambda expression. This is how you can composite multiple routers in a
    single chain call with the `and` operator. To distinguish this feature, we again
    alter the endpoint URL pattern as we have added `/composite/` instead of `/combine/` to
    the URL pattern. Needless to say that you will get a similar output in this case
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WebSocket is a protocol that allows full-duplex, two-way communication between
    a server and a client. While establishing the connection, it uses HTTP for the
    initial handshake. Once done, it will request a protocol upgrade. The Spring WebFlux
    framework supports reactive WebSocket communication between a client and server
    based on  the Java WebSocket API. Defining WebSocket is a two-step process as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the handler to manage the WebSocket request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define mapping to access  the specific handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In WebFlux, the WebSockets are handled by implementing the `WebSocketHandler`
    interface. It has one method called`handle()`. It is provided with the object
    of `WebSocketSession` every time a connection is established to the handler. As
    its name suggests,  `WebSocketSession` represents the connection formed by a single
    client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two separate streams  accessible through the `receive()` and `send()` methods
    of the `Flux` type, are associated with `WebSocketSession` for handling incoming
    requests and outgoing messages respectively. We will first define  handler mapping
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@Bean` annotated method `webSockertHandlerMapping` is used to map our
    custom handler with a specific URL pattern by which it can be accessible. The `SampleWebSocketHandler`
     custom handler is injected with the `@Autowired` annotation and looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The  `SampleWebSocketHandler` class provides an implementation of the `WebSocketHandler`
    interface with the `handle()` method. In that method, we are simply fetching all
    student data from `StudentMongoRepository` and calling the `send()` method on `WebSocketSession`.
    In the `send()` method, we first convert the `Student` object to JSON string with
    `ObjectMapper` and finally call the `textMessage()` method of `WebSocketSession`
    to convert it to `WebSocketMessage`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, is to create the client. We will write client code in JavaScript and call
    the server from the browser to see how the stream data is received one by one.
    You can create one HTML file with the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Almost all modern browsers support WebSocket communication. Open this HTML in
    a browser and you will see student data one by one with a browser alert. This
    is how WebSocket communication happens in the reactive paradigm of Spring WebFlux.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reactive is definitely a promising new technology that will help to build a
    scalable and high-performance application. Spring has done an impressive job of
    supporting Reactive Systems with a new framework called WebFlux. Reactive is the
    future of next-generation applications, and it is needed almost everywhere: datastores,
    middle layers, frontends, or even mobile platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: Through this chapter, we learned the basics of Reactive Systems and Reactive
    Programming followed by various techniques to achieve it. We then learned about
    Reactive Streams, which is one of the most popular ways of implementing a Reactive
    System. Starting with the Reactive Streams specifications and the basic fundamentals,
    we explored various JVM-based libraries that provide an implementation for a particular
    specification. We did some hands-on work with RxJava and Project Reactor and learned
    the underlying principles.
  prefs: []
  type: TYPE_NORMAL
- en: In the same direction, we have seen how the Spring Framework provides support
    in a reactive paradigm. We have then explored the Spring WebFlux framework by
    creating a Spring Boot-based web application. Apart from annotated based support
    for WebFlux, which is like Spring MVC, Spring also supports creating Reactive
    Systems with functional programming paradigms. We explored various options in
    functional programming with a series of examples.
  prefs: []
  type: TYPE_NORMAL
- en: To gain full advantage of the reactive capability of Spring WebFlux, the data
    store should also support Reactive Programming, and that was the reason we chose
    MongoDB as a datastore, and we learned how to configure it in a web application
    with the Spring Boot tool.
  prefs: []
  type: TYPE_NORMAL
- en: It has been a very exciting journey so far, and we will continue our journey
    in the next chapter by exploring the interesting topic of the integration of Elasticsearch
    with the Spring Framework. We will develop a sample application called **Blogpress**.
    We will also look in more detail at Spring Boot, Thymeleaf, and so on; stay tuned
    and ready to explore further in the next chapter.
  prefs: []
  type: TYPE_NORMAL
