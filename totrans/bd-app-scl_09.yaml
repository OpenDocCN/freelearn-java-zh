- en: Chapter 9. Design Your REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we added a new chat feature in our app using Akka.
    Our web application is close to the end. This chapter will add the REST API in
    our Play framework application.
  prefs: []
  type: TYPE_NORMAL
- en: We will also create a Scala client using the `ws` library from the Play framework
    in order to call our REST API. Later in this chapter, we will add Swagger support
    and embed the Swagger UI in our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: REST and API design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our API with REST and JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Scala client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding validations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding back pressure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Swagger support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Representational State Transfer** (**REST**) is an architectural style. It
    was defined by Roy Fielding in his doctoral dissertation. REST happens over the
    HTTP 1.1 protocol using HTTP verbs, such as `GET`, `POST`, `DELETE`, `PUT`, and
    **Uniform Resource Identifier** (**URI**), for instance, `/users/profile/1` or
    `sales/cart/add/2`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The REST architecture has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplicity**: Pretty much all languages have libraries to manipulate HTTP
    URIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interoperability**: REST is language, platform, and OS agnostic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalable and Reliable**: As REST is based on HTTP, you can use the HTTP server
    to scale up your application in conjunction with HTTP load balancer, the HTTP
    caches, and HTTP DNS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separation of Concerns** (**SOC**): As you have a URI, that''s your contract,
    not the code, underlying backend, or database. This means that you can change
    the database or language without affecting the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**/**Server**: There is a server that provides the REST interface and
    the clients, which call the REST endpoints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web services that embrace the REST principles are often called RESTful.
  prefs: []
  type: TYPE_NORMAL
- en: REST API design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are working with REST, there are some principles that you should keep
    in mind, and these principles should provide guidance for your design choices
    when you are doing API design.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP verbs design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are the following verbs found in HTTP:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: This is often used to answer queries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: This is often used to insert data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: This is often used to update data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: This is often used to remove data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we keep saying often? Well, there are some exceptions in regards of size
    limitations. For instance, for the `GET` verb, we can't have a request bigger
    than 8192 bytes or 8 KB. If you need to send a bigger payload, we will need to
    use the `POST` verb.
  prefs: []
  type: TYPE_NORMAL
- en: Uniform API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'REST uses a uniform API. For example, consider the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If we change the resource from users to sales, the API would almost be the same.
    Retrieving data is done using `GET` and update is done via `POST`, so it's a uniform
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Response with HTTP status codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'REST runs the error handler using the HTTP 1.1 status codes. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '**200 -> OK**: This is often used with the `GET` verb'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**201 -> Created**: This is often used by the `PUT/POST` verbs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**204 -> No Content**: This is often for the `DELETE` verb'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**400 -> Invalid Request**: This often means an invalid request for the `POST/PUT`
    verbs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**404 -> Not Found**: This is often used with the `GET` verb'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**500 -> Internal Server Error -** **Unexpected Server Error**: This is often
    used by all the verbs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST API patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some commons patterns for good and clear REST API designs, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use nouns; do not use verbs**: Often, you can use standard URIs, such as
    `/cars/` or `/members/`. You should not use `/getCars/` or `getMembers/` because
    you are using the URI with a verb, and the verb already tells the actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GET method should not change state**: If you want to change the state of
    the server, you will need to use verbs such as `PUT`, `POST`, or `DELETE`. `GET`
    should not change the state of the server, so it should always be safe calling
    `GET` as many times as you want. This is called idempotent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prefer sub-resource relation**: Let''s say we have a resource called `/users/`,
    and a user has projects. It''s always a good idea to use sub-resources, such as
    `/users/1/projects/2`, because we have a relationship between users and projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use HTTP headers**: HTTP headers should be used for serialization, security,
    and all the kinds of metadata your application needs. The HTTP Headers are often
    used for content negotiation. For instance, you might do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The URI is the same; however, based on the header type, it will return data
    in XML or JSON format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filter, Sorting and Pagination**: Sometimes, your data may be big. It''s
    always a good idea to provide mechanisms to sort, filter, and paginate as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: API versioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways to perform API versioning. First strategy is to version by
    the endpoint explicit such as `/v1/cars`. The second strategy is based on metadata
    such as `/cars/`, but then you will pass an HTTP HEADER version as v1.
  prefs: []
  type: TYPE_NORMAL
- en: Both strategies have pros and cons. Explicit versioning is more clear, and you
    can always create a new version and don't break your consumers. Header strategy
    is more elegant; however, it can get tricky to manage.
  prefs: []
  type: TYPE_NORMAL
- en: Some anti-patterns to be avoided
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several traps in the REST API design, but the following things need
    to be avoided:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET` verb for everything'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignoring HTTP headers such as MIME-types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning 200 when an error happens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning 500 for an invalid parameter or a missing parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our API with REST and JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alright, now is the time to design a REST API for your Play framework application.
    We will create an API to export all data in the system. This API will be READ
    only; however, you can add write operations if you like.
  prefs: []
  type: TYPE_NORMAL
- en: Later on in this chapter, we will add some back pressure to limit the API REST
    rate for consumers and create a Scala client application for our REST API. So,
    first of all, let's get started with the Play framework (server) first.
  prefs: []
  type: TYPE_NORMAL
- en: We don't need any extra library in order to create a REST API in our Play framework
    application. We will just need a new controller and new routes. Additionally,
    we will leverage most of the code we made in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: RestApiContoller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a new controller located at `ReactiveWebStore/app/controllers`.
  prefs: []
  type: TYPE_NORMAL
- en: REST API Front Controller implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`RestApiController.scala` file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Basically, we have three functions here. These functions list all products,
    images, and reviews. As you can see at the top of the controller, we are injecting
    the three services that we have for products, images, and reviews.
  prefs: []
  type: TYPE_NORMAL
- en: The code is pretty much straightforward for all functions. First, we will call
    the proper service, and then we will wait for the result with the `await` object.
    Once we have the data, we will call a function to convert the data to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the JSON helpers objects that we used here.
  prefs: []
  type: TYPE_NORMAL
- en: JSON mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our REST controller used JSON helper objects to map objects to JSON. First,
    we will start with the Products JSON helper.
  prefs: []
  type: TYPE_NORMAL
- en: '`ProductsJson` is located at `ReactiveWebStore/app/controllers/Product.scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Basically, there are three important concepts here. First, we have `productsWrites`
    , which maps from JSON to `model`, and `Product` for writes, which is also known
    as deserialization. We have another mapping for serialization called `productsReads`,
    which converts objects to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we need to map all fields existing in our model, such as ID,
    name, details, and price. This mapping must match proper types as well. ID mapping
    uses `readNullable` because ID is optional.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have a function to convert from JSON to object, called `toJson`,
    which uses a generic Play framework library called JSON. Let's move for the next
    helper--the review.
  prefs: []
  type: TYPE_NORMAL
- en: '`ReviewsJson` is located at `ReactiveWebStore/app/controllers/Review.scala` and
    should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the same concepts that we saw earlier in the Products JSON helper.
    We have a mapping for reads and writes and a function which converts a `model.Review`
    to JSON. Let's move to the last helper, the `ImageJson`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ImagesJson` is located at `ReactiveWebStore/app/controllers/Image.scala`,
    which should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Just as with the other two mappers, we have reads, writes, mappings, and the
    `toJson` function. We are done with mappers, so now the next step is to create
    the new routes.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring new routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to add the following three new routes for our REST API, which is located
    at `ReactiveWebStore/conf/routes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we mapped all the list operations we just created.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the API using the browser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we can run `$ activator run` and test our new REST API using our web browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to `http://localhost:9000/REST/api/product/all`; you should see something
    similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the API using the browser](img/image00320.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's look at the review API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to `http://localhost:9000/REST/api/review/all`; you should see results similar
    to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the API using the browser](img/image00321.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, let's check out the image of REST API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to `http://localhost:9000/REST/api/image/all`; you should see results similar
    to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the API using the browser](img/image00322.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: OK. Now we will continue to work with REST. We just finished the server; however,
    it is important to create a REST client to consume these REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Scala client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, you will need to create a new project. Go to your file system and create
    a folder called `rest-client`. Then, create another folder inside `rest-client`
    called `project`. Inside `project`, you will need to add the following two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`build.properties`: This contains an SBT configuration, such as version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Plugins.sbt`: This contains an SBT plugins configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with `build.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see here, we are configuring this project to use SBT version 0.13.11\.
    Now, we can move to the plugins file.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring plugins.sbt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your `plugins.sbt` file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are adding Eclipse and IntelliJ support. For this book, we are using
    Eclipse, but feel free to use anything you like.
  prefs: []
  type: TYPE_NORMAL
- en: Outside of the `project` folder, under `rest-client`, we will need to configure
    the `build.sbt` file.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring build.sbt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your `build.sbt` file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So here, we are using Scala version 2.11.7, and we are declaring just two dependencies.
    One dependency is for tests, which is `scala-test`, and the other dependency is
    on the Play framework `ws` library, which we will use to call our REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also create two source folders, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/scala`: This is the Scala source code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/test/scala`: This is the Scala test source code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OK. Now we can run `$ sbt clean compile eclipse` in order to download the dependencies
    from the web and create all the Eclipse project files that we need.
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring build.sbt](img/image00323.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now we can import this code in Eclipse and move on.
  prefs: []
  type: TYPE_NORMAL
- en: Scala client code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we will need to create a `Factory` to instantiate the `WS` Play
    framework library to call `webservices`. Under the `rest-client/src/main/scala`
    location, let''s create a package called `client` and add the following code under
    `WSFactory.scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is just technical. These are the steps needed to instantiate
    the WSClient outside the Play framework. If this client was a web application
    using the Play framework, it would be way easier as we can just use Google Guice
    and inject what we need.
  prefs: []
  type: TYPE_NORMAL
- en: The main idea you need to keep in mind is that you need to use Akka and ActorSystem
    in order to use this feature. As you can see, all this code is locked inside an
    object in a single function called `ws`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need some utility class to work with futures. As we use `ws` library
    to call REST APIs, it returns Future. So, let''s create a new package called `utils`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `Awaits.scala` file should look like something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is pretty simple. We used the `Await` object and then used
    a generic `T` in order to convert the result to a generic parameterized type.
    By using this parameter, we will also receive how many seconds we should wait
    before the timeout.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our REST client proxies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now make REST calls; however, we will create a Scala API. So, the developers
    who use our `rest-client` won''t need to deal with REST and just execute the Scala
    code. This is good for many reasons, some of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SOC**: We still have separation of concerns between the Play framework and
    the client application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolation**: If the REST API changes, we will need to deal with it on the
    proxy layer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abstraction**: The rest of the client code just uses Scala and does not know
    anything about REST or HTTP calls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These techniques are very common nowadays with microservices. These techniques
    can also be known as drivers or thick clients. Right now, we will need to create
    three proxies, one for each resource, that we have on the REST API. Let's create
    a new package called `proxy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `ProductProxy.scala` file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We have three big concepts in this code. First of all, we have a `case` class
    that represents the product. The preceding code is very similar to the code we
    have on the Play framework application. However, if you pay attention, you will
    see it is much cleaner because we don't have any metadata around persistence.
  prefs: []
  type: TYPE_NORMAL
- en: You might think, this is duplicated code! It is, and it is 100% okay. Duplicate
    code is decoupled. Remember that we have a REST interface and also a proxy between
    the rest of the client code, so we have at least two layers of indirection that
    we can deal with changes. If these two code bases share the same class, we would
    have coupling and less space to accommodate changes.
  prefs: []
  type: TYPE_NORMAL
- en: The second big concept here is mapping. We will receive JSON, and we will want
    to convert JSON to our case class, so we will have similar mapping that we did
    in the Play framework application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the proxy implementation. We will instantiate the Play framework
    `WS` library using our factory and call the `ws` function. Then, we will use the
    `url` function passing the REST API URI for products and define a header in order
    to accept JSON. We are also doing this using the HTTP verb, `GET`. The response
    is mapped with `Json.parse` passing `response.body`. Additionally, we will call
    the validate function to make sure this JSON matches our `case` class. This validation
    is important because then we can be sure that the format did not change, and that
    everything works fine. `WS` will return this as a Future, so we will use our `Awaits`
    helper to get the result.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move to the next proxy, the review.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `ReviewProxy.scala` file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the same principles that we had on the product proxy, but this
    time for review. As you can see, we will call a different URI. Now, let's move
    to the last proxy--the `ImageProxy.scala` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `ImageProxy.scala` file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That's it. We have the same concepts as product and review. We have finished
    all our proxies. Now, it is time to test our proxy implementation. The best way
    to do this is via tests, so let's create Scala tests for these three implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Creating ScalaTest tests for the proxies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Under the `/src/test/scala` source folder, we will need to create a package
    called `proxy.test`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `ProductProxtTestSpec.scala` should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The test is quite simple; we will just have to call the `listAll` operation
    in our product proxy and then add some assertions to make sure the result is not
    null. We will also show all the products in the console.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will need to create tests for the review proxy, which will be similar
    to the product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `ReviewProxyTestSpec.scala` file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used the proxy ideas to test the review. We called the proxy using
    the `listAll` function to get all the reviews. Later, we will check to see if
    the review is not null. We will print all the reviews. Finally, it's time to move
    to the last proxy test--the image proxy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `ImageProxyTestSpec.scala` should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Same deal goes for the image proxy. We have all our tests; now, we can run the
    tests. You will need to make sure our `ReactiveWebStore` Play framework app is
    up and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run this test with sbt:'
  prefs: []
  type: TYPE_NORMAL
- en: open your console and type in `$ sbt test`
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating ScalaTest tests for the proxies](img/image00324.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Alright, it all works! Our next step will be to add back pressure.
  prefs: []
  type: TYPE_NORMAL
- en: Adding back pressure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back pressure is a well-known concept in the automotive industry. Nowadays,
    this term is used in software engineering as well. Back pressure in the automotive
    world refers to the pressure opposed to the desired flow of gasses in a confined
    place, such as a pipe. For software engineering, it is often related to slowing
    down a producer, which can be an application, a stream processing engine, or even
    the user itself.
  prefs: []
  type: TYPE_NORMAL
- en: When we are executing REST, it's easy to reach a situation where the client
    can saturate the server. This can be a security breach too, which is also known
    as the **Denial Of Service** (**DOS**) attack.
  prefs: []
  type: TYPE_NORMAL
- en: There are two architectural scenarios. In the first scenario, your REST API
    is internal, and you just have consumers in your company. In the second scenario,
    you are making the REST API a public API so that it will be open to the whole
    Internet. For this scenario, you really should have back pressure, also known
    as throttling.
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to scale our architecture in order to handle more users. We will
    discuss this, and the scalability techniques, in [Chapter 10](part0116.xhtml#aid-3EK181
    "Chapter 10.  Scaling up"), *Scaling Up*.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, there are several ways to apply back pressure. For instance, if our
    code is pure RxScala/RxJava, we can apply back pressure on observables. More details
    can be found at [https://github.com/ReactiveX/RxJava/wiki/Backpressure](https://github.com/ReactiveX/RxJava/wiki/Backpressure).
  prefs: []
  type: TYPE_NORMAL
- en: As we are exposing a REST interface, we will add back pressure on the controller,
    so we will need to create a new class with the back pressure code.
  prefs: []
  type: TYPE_NORMAL
- en: There are some algorithms for back pressure; we will use the leaky bucket algorithm.
    The algorithm itself is very simple--just 30 lines of Scala code.
  prefs: []
  type: TYPE_NORMAL
- en: The leaky bucket algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The leaky bucket metaphor is pretty simple. Let''s take a look at it in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The leaky bucket algorithm](img/image00325.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The metaphor behind the algorithm is based around a bucket with holes. The water
    flows or drips into the bucket and leaks through the holes of the bucket. If there
    is too much water, and the bucket is full of water, the water will spill out of
    the bucket--in other words, it will be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is used in network programing, and also by the telecommunication
    industry. The API manager solutions are also use cases for this algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: This concept allows RATE limit constraints. We can express the back pressure
    rate limits in requests per time. Time, in this case, is often measured in seconds
    or minutes, so we have **Requests Per Second** (**RPS**) or **Requests Per Minute**
    (**RPM**).
  prefs: []
  type: TYPE_NORMAL
- en: You can implement this algorithm with a queue. However, in our implementation,
    we will not use a queue; we will use time in order to control the flow. Our implementation
    will also be lock free, or non-blocking, as we won't use threads or external resources.
  prefs: []
  type: TYPE_NORMAL
- en: Now is the time to code a leaky bucket in Scala. First of all, we will create
    this code for the `ReactiveWebStore` application. We will need to create a new
    package located at `ReactiveWebStore/app`. The new package name will be `backpressure`.
  prefs: []
  type: TYPE_NORMAL
- en: Scala leaky bucket implementation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Your `LeakyBucket.scala` file should have the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see here, we created a Scala class that receives two parameters:
    `rate` and `perDuration`. Rate is an integer, which shows how many requests we
    are able to handle before applying back pressure. `PerDuration` is a Scala `FiniteDuration`,
    which can be any measure of time, such as milliseconds, seconds, minutes, or hours.'
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm keeps track of the time for the last drop in the bucket. As you
    can see, the code is synchronized, but it is fine because we won't call either
    external resources or threads.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will get the current time with new a `Date()`. The first time we run
    the algorithm, we will fail on the `else` statement, and we will get the current
    time as last leak.
  prefs: []
  type: TYPE_NORMAL
- en: The second time it runs, it will enter on the first `If` statement. Then, we
    will calculate the delta (diff) between the last leak and now. This delta will
    be divided by the time in milliseconds that you passed on `perDuration`. If the
    delta is greater than 0, then we leak; otherwise we drop. Then, we will capture
    the time again for the last leak.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will check the drop rate. If the rate is smaller, we will increment
    and return true, which means the request can proceed; otherwise, we will return
    false, and the request should not proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have this algorithm coded in Scala, we can call for one of our controllers.
    We will add this back pressure on the image REST API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `RestApiController.scala` should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will create a leaky bucket with five requests per minute. We have
    two functions: One to process images that will call the service and convert the
    objects to JSON, and the other to process failures. The `processFailure` method
    will just send a message saying that there are too many requests, and we can''t
    accept requests right now.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for the `listAllImages` function, we will just call the bucket trying to
    drop and use the Scala pattern matcher in order to process the proper response.
    If the response is true, we will return JSON with a 200 HTTP code. Otherwise,
    we will return a 500 internal error and deny that request. Here, we implemented
    a global RATE limiter; however, most of the time, people perform this operation
    per user. Now, let''s open the web browser and try more than five requests within
    a minute. You should see something like the following screenshot at `http://localhost:9000/REST/api/images/all`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scala leaky bucket implementation](img/image00326.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Alright, it works! If you wait a minute and make requests again, you will see
    that the flow gets back to normal. The next step is to add a new client test,
    because we know that if we call an image too much in our REST API, we will be
    throttled.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to add one more test in the `rest-client` Scala project. For that,
    we will need to change the `ImageProxyTestSpec`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing back pressure
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Your `ImageProxyTestSpec.scala` should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So, for this test, we will call `ImageProxy` ten times. We know that not all
    requests will be served as we have back pressure on the server. Here, we can call
    the proxy with a try...catch block and have an error counter. Each time it fails,
    we can increment it. So, here, we are expected to fail at least five times.
  prefs: []
  type: TYPE_NORMAL
- en: We are creating the code with Features because we want the requests to happen
    at the same time. We will need to use `CountDownLatch` function, which is a Java
    utility class that lets us wait for all Futures to finish before moving on. This
    is done by the `countDown` function. Every time we execute `countdown`, we decrement
    the internal counter. As you can see, we created the `CountDownLatch` function
    with ten.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have a `while` block to wait for until the counter has pending Futures.
    Now we wait. Once it's all done, we can check the error count; it should be at
    least five. That's it. We have tested our back pressure mechanism and it all works!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is time to move to the next feature that we will implement in our application:
    Swagger--we will add Swagger support to our REST API.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding Swagger support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Swagger ([http://swagger.io/](http://swagger.io/)) is a simple JSON and UI representation
    tool for REST APIs. It can generate code in several languages. It also creates
    a very nice documentation, which is also a runnable Swagger code that allows you
    to call REST web services from the documentation it generates. We will need to
    make some changes in our Play framework application in order to get Swagger up
    and running with the Play framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we will need to add the Swagger dependency to `build.sbt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are using a Snapshot version. Why use Snapshot? Right now,
    it is not supported on a stable version. In order to resolve this dependency,
    we will need to use Git and clone another project. You can get more details at
    [https://github.com/CreditCardsCom/swagger-play](https://github.com/CreditCardsCom/swagger-play).
    Basically, you will need to write a command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will need to enable Swagger on `ReactiveWebStore/conf/application.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `application.conf` file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Next, we can change our controller in order to add Swagger support. Swagger
    has annotation in order to map the REST operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `RestAPIController.scala` file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here we have several annotations. First of all, we have an `@Api` annotation
    at the top of the class. With this annotation, we will define the root path of
    the REST API. Then, for each REST API operation, we have the `@ApiOperation` and
    `@ApiResponses` annotations. The `@ApiOperation` defines the REST API itself where
    you can define the parameters and the HTTP verb, and also put some notes (documentation).
    It's also possible to describe the result; in our case, it will be a JSON representation
    of the models.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it! We have the controller mapped to Swagger. The next step is to add
    a route for Swagger. This needs to be done by adding a new line as shown in the
    following piece of code which, is located at `ReactiveWebStore/conf/routes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Swagger UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Swagger will generate a JSON response for our REST API. It''s possible to use
    the Swagger UI, which is very nice and gives lots of facilities to the developer.
    There are two ways we can work with the Swagger UI: We can use it as a standalone
    or we can embed the Swagger UI into our Play framework application.'
  prefs: []
  type: TYPE_NORMAL
- en: The strategy we will pick here is embedding the Swagger UI in our application.
    If you have multiple REST APIs with multiple Play applications or microservices,
    it is a good idea to have the standalone installation of the swagger UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous steps, we enabled Swagger in our application. Open your browser
    and type `http://localhost:9000/swagger.json`. You can follow the instructions
    at [http://swagger.io/swagger-ui/](http://swagger.io/swagger-ui/). In summary,
    you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Swagger UI](img/image00327.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Build and install Swagger Standalone
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we will download, build, and install Swagger Standalone. Let''s get started
    by writing the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you start the Swagger UI, you can go to the browser, where you will see
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Build and install Swagger Standalone](img/image00328.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's embed the Swagger UI into our Play framework application.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to copy the content from `/swagger-ui/dist/` into our Play framework
    application under `ReactiveWebStore/public`. Then, we will create a folder called
    `swaggerui`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to edit one file in order to put our swagger JSON URI. Open `ReactiveWebStore/public/swaggerui/index.html`
    and change the 40 to the following code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: That's it. Now we will need to create a link from our application to embed the
    swagger UI. So, let's change `ReactiveWebStore/app/views/index.scala.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `index.scala.html` file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now we can run our Play application with `$ activator run`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the browser and go to `http://localhost:9000/`. You will see the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Build and install Swagger Standalone](img/image00329.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can open the Swagger UI by clicking on the Swagger REST API link or
    by just going to `http://localhost:9000/assets/swaggerui/index.html`. It should
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Build and install Swagger Standalone](img/image00330.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the Swagger UI is very nice. You can click on each operation
    and see more details on how they work, which HTTP verb they use, and what the
    URI is. There is a **Try it out!** button. Let''s click on the **Try it out!**
    button for products, which would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Build and install Swagger Standalone](img/image00331.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have our JSON result and also some CURL samples as well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to design a REST API and changed your Play
    framework application in order to have Swagger support. You created a Scala client
    library using proxy techniques, as well as Scala tests for the APIs. Additionally,
    you were introduced to back pressure using the leaky bucket algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, which will be the final chapter, you will learn about software
    architecture and scalability/resiliency techniques, such as discoverability, load
    balancers, caches, Akka Cluster, and the Amazon Cloud.
  prefs: []
  type: TYPE_NORMAL
