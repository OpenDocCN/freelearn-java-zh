- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jakarta Messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Jakarta Messaging** provides a mechanism for Jakarta EE applications to send
    messages to each other. Jakarta Messaging applications do not communicate directly;
    instead, message producers send messages to a destination, and message consumers
    receive the message from the destination.'
  prefs: []
  type: TYPE_NORMAL
- en: The message destination is a message queue when the **point-to-point** (**PTP**)
    messaging domain is used, or a message topic when the **publish/subscribe** (**pub/sub**)
    messaging domain is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with message queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with message topics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Example source code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch13_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch13_src).
  prefs: []
  type: TYPE_NORMAL
- en: Working with message queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned earlier, message queues are used when our Jakarta Messaging
    code uses the PTP messaging domain. For the PTP messaging domain, there is usually
    one message producer and one message consumer. The message producer and the message
    consumer don’t need to be running concurrently in order to communicate. The messages
    placed in the message queue by the message producer will stay in the message queue
    until the message consumer executes and requests the messages from the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages to a message queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example illustrates how to add messages to a message queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Most examples in this chapter are implemented as **Contexts and Dependency Injection**
    (**CDI**) beans. Refer to [*Chapter 2*](B21231_02.xhtml#_idTextAnchor022) for
    an explanation of CDI.
  prefs: []
  type: TYPE_NORMAL
- en: The class-level `@JMSDestinationDefinition` annotation defines a Jakarta Messaging
    destination where our messages will be placed. This annotation has two required
    attributes, `name` and `interfaceName`. The `name` attribute of `@JMSDestinationDefinition`
    defines a `interfaceName` specifies the Jakarta Messaging destination interface;
    PTP messaging, this value must always be `produceMessages()` method of the preceding
    class is invoked from a `commandButton` from a Jakarta Faces page implemented
    using Facelets. For brevity, we will not show the XHTML markup for this page.
    The code download bundle for this chapter contains the complete example.
  prefs: []
  type: TYPE_NORMAL
- en: The `produceMessages()` method in the `MessageSender` class performs all the
    necessary steps to send messages to a message queue.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing this method does is create an instance of `jakarta.jms.JMSContext`
    by invoking the `createContext()` method on the injected instance of `jakarta.jms.ConnectionFactory`.
    Notice that the `mappedName` attribute of the `@Resource` annotation decorating
    the connection factory object matches the `name` attribute of the `@JMSDestinationDefinition`
    annotation. Behind the scenes, a JNDI lookup is made using this name to obtain
    the connection factory object.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create an instance of `jakarta.jms.JMSProducer` by invoking the `createProducer()`
    method on the `JMSContext` instance we just created.
  prefs: []
  type: TYPE_NORMAL
- en: After obtaining an instance of `JMSProducer`, the code sends a series of text
    messages by invoking its `send()` method. This method takes the message destination
    as its first parameter, and a `String` containing the message text as its second
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: There are several overloaded versions of the `send()` method in `JMSProducer`.
    The one we used in our example is a convenient method that creates an instance
    of `jakarta.jms.TextMessage` and sets its text to the `String` we provide as the
    second parameter in the method invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the preceding example sends only text messages to the queue, we are
    not limited to this type of message. Jakarta Messaging provides several types
    of messages that can be sent and received by Jakarta Messaging applications. All
    message types are defined as interfaces in the `jakarta.jms` package. *Table 13.1*
    lists all of the available message types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Message Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `BytesMessage` | Allows sending an array of bytes as a message. `JMSProducer`
    has a convenient `send()` method that takes an array of bytes as one of its parameters.
    This method creates an instance of `jakarta.jms.BytesMessage` on the fly as the
    message is being sent. |'
  prefs: []
  type: TYPE_TB
- en: '| `MapMessage` | Allows sending an implementation of `java.util.Map` as a message.
    `JMSProducer` has a convenient `send()` method that takes a `Map` as one of its
    parameters. This method creates an instance of `jakarta.jms.MapMessage` on the
    fly as the message is being sent. |'
  prefs: []
  type: TYPE_TB
- en: '| `ObjectMessage` | Allows sending any Java object implementing `java.io.Serializable`
    as a message. `JMSProducer` has a convenient `send()` method, which takes an instance
    of a class implementing `java.io.Serializable` as its second parameter. This method
    creates an instance of `jakarta.jms.ObjectMessage` on the fly as the message is
    being sent. |'
  prefs: []
  type: TYPE_TB
- en: '| `StreamMessage` | Allows sending an array of bytes as a message. Differs
    from `BytesMessage` in that it stores the type of each primitive added to the
    stream |'
  prefs: []
  type: TYPE_TB
- en: '| `TextMessage` | Allows sending `java.lang.String` as a message. As seen in
    the preceding example, `JMSProducer` has a convenient `send()` method that takes
    a `String` as its second parameter. This method creates an instance of `jakarta.jms.TextMessage`
    on the fly as the message is being sent. |'
  prefs: []
  type: TYPE_TB
- en: Table 13.1 – Jakarta Messaging message types
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on all of the preceding message types, consult the `JavaDoc`
    documentation at [https://jakarta.ee/specifications/messaging/3.0/apidocs/jakarta/jms/package-summary](https://jakarta.ee/specifications/messaging/3.0/apidocs/jakarta/jms/package-summary).
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving messages from a message queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of course, there is no point in sending messages from a queue if nothing is
    going to receive them. The following example illustrates how to retrieve messages
    from a message queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Just like in the previous example, we define a destination via the `@JMSDestinationDefinition`
    annotation, plus we inject instances of `jakarta.jms.ConnectionFactory` and `jakarta.jms.Queue`
    by using the `@``Resource` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: In our code, we get an instance of `jakarta.jms.JMSContext` by invoking the
    `createContext()` method of `ConnectionFactory`, just like in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we obtain an instance of `jakarta.jms.JMSConsumer` by calling
    the `createConsumer()` method on our `JMSContext` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Messages are received by invoking the `receiveBody()` method on our instance
    of `JMSConsumer`. This method takes the type of the message we are expecting as
    its sole parameter (`String.class` in our example). This method returns an object
    of the type specified in its parameter (an instance of `java.lang.String` in our
    example). Once the message is consumed by `JMSConsumer.receiveBody()`, it is removed
    from the queue.
  prefs: []
  type: TYPE_NORMAL
- en: In this particular example, we placed this method call in a `while` loop since
    we are expecting a message that will let us know no more messages are coming.
    Specifically, we are looking for a message containing the text “Good bye!”. Once
    we receive said message, we break out of the loop and continue processing. In
    this particular case, there is no more processing to do, therefore execution ends
    after we break out of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing the code, we should see the following output in the server
    log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This of course assumes that the previous example was already executed and it
    placed messages in the message queue.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A disadvantage of processing messages as discussed in this section is that message
    processing is synchronous. In Jakarta EE environments, we can process messages
    asynchronously by employing message-driven beans, as discussed in [*Chapter 12*](B21231_12.xhtml#_idTextAnchor164).
  prefs: []
  type: TYPE_NORMAL
- en: Browsing message queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jakarta Messaging provides a way to browse message queues without actually
    removing the messages from the queue. The following example illustrates how to
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the procedure to browse messages in a message queue is straightforward.
    We obtain a connection factory, a queue, and a context the usual way, then invoke
    the `createBrowser()` method on the context object. This method returns an implementation
    of the `jakarta.jms.QueueBrowser` interface. This interface contains a `getEnumeration()`
    method, which we can invoke to obtain an `Enumeration` containing all messages
    in the queue. To examine the messages in the queue, we simply traverse this enumeration
    and obtain the messages one by one. In the example that we discussed, we simply
    invoke the `getText()` method of each message in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how to send and receive messages to and from a queue with
    the PTP messaging domain, we’ll focus our attention on sending and receiving messages
    to and from message topics with the pub/sub messaging domain.
  prefs: []
  type: TYPE_NORMAL
- en: Working with message topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Message topics are used when our Jakarta Messaging code uses the pub/sub messaging
    domain. When using this messaging domain, the same message can be sent to all
    subscribers to the topic.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages to a message topic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example illustrates how to send messages to a message topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the preceding code is nearly identical to the `MessageSender`
    class we saw when we discussed PTP messaging. Jakarta Messaging was designed so
    that the same API can be used for both the PTP and pub/sub domains.
  prefs: []
  type: TYPE_NORMAL
- en: Since the code in this example is nearly identical to the corresponding example
    in the *Working with message queues* section, we will only explain the differences
    between the two examples. In this case, `@JMSDestinationDefinition` has a value
    of `jakarta.jms.Topic` for its `name` attribute, as required when using the pub/sub
    messaging domain. Additionally, instead of declaring an instance of a class implementing
    `jakarta.jms.Queue`, we declare an instance of a class implementing `jakarta.jms.Topic`.
    We then pass this instance of `jakarta.jms.Topic` as the first method of the `send()`
    method of our `JMSProducer` object, along with the message we wish to send.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving messages from a message topic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as sending messages to a message topic is nearly identical to sending
    messages to a message queue, receiving messages from a message topic is nearly
    identical to receiving messages from a message queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the differences between this code and the corresponding code for
    PTP are trivial. Instead of declaring an instance of a class implementing `jakarta.jms.Queue`,
    we declare a class implementing `jakarta.jms.Topic`. We use the `@Resource` annotation
    to inject an instance of this class into our code, using the JNDI name we used
    when configuring our application server. We then obtain an instance of `JMSContext`
    and `JMSConsumer` like before, then it receives the messages from the topic by
    invoking the `receiveBody()` method on `JMSConsumer`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the pub/sub messaging domain as illustrated in this section has the advantage
    that messages can be sent to several message consumers. This can be easily tested
    by concurrently executing two instances of the `MessageReceiver` class we developed
    in this section, and then executing the `MessageSender` class we developed in
    the previous section. We should see console output for each instance, indicating
    that both instances received all messages.
  prefs: []
  type: TYPE_NORMAL
- en: Creating durable subscribers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The disadvantage of using the pub/sub messaging domain is that message consumers
    must be executing when the messages are sent to the topic. If the message consumer
    is not executing at the time, it will not receive the messages, whereas in PTP,
    messages are kept in the queue until the message consumer executes. Fortunately,
    Jakarta Messaging provides a way to use the pub/sub messaging domain and keep
    messages in the topic until all subscribed message consumers execute and receive
    the message. This can be accomplished by creating durable subscribers to a message
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: In order to be able to service durable subscribers, we need to set the `clientId`
    property of our Jakarta Messaging connection factory. Each durable subscriber
    must have a unique client ID, therefore a unique connection factory must be declared
    for each potential durable subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set the `clientId` property of our connection factory using the `@JMSConnectionFactoryDefinition`
    annotation, as illustrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the preceding code is not much different from previous examples
    whose purpose was to retrieve messages. There are only a few differences from
    previous examples: the instance of `ConnectionFactory` we are injecting is defined
    via `@JMSConnectionFactoryDefinition` and given a client ID via its `clientId`
    attribute. Notice the `@Resource` annotation for our connection factory has a
    `mappedName` attribute whose value matches the name attribute we defined in `@JMSConnectionFactoryDefinition`.'
  prefs: []
  type: TYPE_NORMAL
- en: Another difference is that instead of calling the `createConsumer()` method
    on `JMSContext`, we are calling `createDurableConsumer()`. The `createDurableConsumer()`
    method takes two arguments, a messaging `Topic` object to retrieve messages from
    and a `String` designating a name for this subscription. This second parameter
    must be unique between all subscribers to the durable topic.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed at length how to send messages with Jakarta Messaging,
    using both the PTP and pub/sub messaging domains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics we covered included the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to send messages to a message queue via the `jakarta.jms.JMSProducer` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to receive messages from a message queue via the `jakarta.jms.JMSConsumer`
    interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to asynchronously receive messages from a message queue by implementing
    the `jakarta.jms.MessageListener` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the preceding interfaces to send and receive messages to and from
    a message topic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to browse messages in a message queue without removing the messages from
    the queue via the `jakarta.jms.QueueBrowser` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up and interact with durable subscriptions to messaging topics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Armed with the knowledge in this chapter, we can now implement asynchronous
    communication between processes with Jakarta Messaging.
  prefs: []
  type: TYPE_NORMAL
