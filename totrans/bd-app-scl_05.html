<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Testing Your Application" id="aid-1S2JE1"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Testing Your Application</h1></div></div></div><p>In the chapters so far, we bootstrapped our application using Activator, developed our web application using Scala and the Play framework, and added a Reactive microservice call using RxScala for data flow computations. Now we will go ahead and enter the unit test and controller testing using the BDD and Play framework.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Unit testing principles</li><li class="listitem">Testing Scala applications with JUnit</li><li class="listitem">Behavior-driven development principles</li><li class="listitem">Testing with ScalaTest</li><li class="listitem">Testing Play framework applications with ScalaTest</li><li class="listitem">Running tests in Activator / SBT</li></ul></div><p>The need for <code class="literal">testingTest</code> is a fundamental and very important part of software development. Without tests, we cannot be sure that our code works. We should perform tests on almost all the code we produce. There are things that don't make sense for testing, for instance, case classes and classes that just represent structural objects, or, in other words, classes without functions. If you have code that applies computations, transformations, and validations, you definitely want to test this code with a good code coverage, which refers to features or any important code that is not just structural.</p><p>Test coverage is important, because it allows us to do refactoring (improve application code quality by reducing code, creating generic code, or even deleting code) with trust. This is because, if you have tests and if you do something wrong by accident, your tests will let you know. This is all about having short cycles of feedback. The earlier the better; you want to know if you have introduced bugs as soon, and as close to development, as possible. Nobody likes to discover bugs that could be caught by a simple test in production.</p><div class="section" title="Unit testing principles"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec55"/>Unit testing principles</h1></div></div></div><p>Unit testing is the smallest unit of testing that you could possibly apply. You need to apply it at the class level. So a unit test will cover your class with all the functions you have there. But hold on a minute, a class often has dependencies, and these dependencies might have other dependencies, so how do you test that? We need to have mocks, simple dumb objects that simulate other classes' behavior. This is an important technique to isolate code and allow unit testing.</p><div class="section" title="Making code testable"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec72"/>Making code testable</h2></div></div></div><p>Unit testing is simple: basically, we call a function by passing arguments to it, and then we check the output to see if it matches our expectations. This is also called asserts or assertions. So, unit testing is about asserts. Sometimes, your code might not be testable. For instance, let's say you have a function that returns a unit and has no parameters. This is very tough to test, because it implies that the function is full of side-effects. If you remember what we discussed in <a class="link" title="Chapter 1. Introduction to FP, Reactive, and Scala" href="part0015.xhtml#aid-E9OE1">Chapter 1</a>, <span class="emphasis"><em>Introduction to FP, Reactive, and Scala</em></span>, this is against FP principles. So, if we have this case, we need to refactor the code to make the function return something, and then we can test it.</p></div><div class="section" title="Isolation and self-contained tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec73"/>Isolation and self-contained tests</h2></div></div></div><p>Unit tests should be self-contained, which means that a unit test's classes should not depend on any particular order of execution. Let's say you have a unit test class with two test functions. So, each test should test just one function at a time, and both functions should be able to run in any order whatsoever. Otherwise, the tests will be fragile and hard to maintain in the long run.</p></div><div class="section" title="Effective naming"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec74"/>Effective naming</h2></div></div></div><p>Effective naming is essential. The test function needs to say exactly what the test does. This is important because, when the test fails, it is easier to figure out what went wrong and why. Following the same idea, when you do assertions, you should assert just one thing at a time. Imagine that you need to test whether a web service returns a valid JSON. This particular JSON could have two fields: first name and last name. So, you will make one assert for the name and an other for the last name. This way, it will be easier to understand what the test does, and to troubleshoot when the test fails.</p></div><div class="section" title="Levels of testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec75"/>Levels of testing</h2></div></div></div><p>When we run tests, we often do it in layers. Unit testing is the basic level; however, there are other levels such as controller tests, integration tests, UI tests, End-to-End tests, stress tests, and so many others. For this book, we will cover unit tests, controller tests, and UI tests using Junit and <code class="literal">ScalaTest</code>,Play's framework support.</p></div></div></div>
<div class="section" title="Testing with Junit" id="aid-1T1401"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec56"/>Testing with Junit</h1></div></div></div><p>If you come from a Java background, it is highly possible that you have already worked with Junit. It's possible to test with Junit using the Scala and Play framework. However, this is not the best practice when we are creating applications with the Play framework, since it favors <span class="strong"><strong>Behavior Driven Development</strong></span> (<span class="strong"><strong>BDD</strong></span>) testing with Scala Spec. For this chapter, we will cover how to perform all sorts of test using BDD and Play. Right now, let's take a look at how we can do unit testing with Junit before we move to BDD.</p><pre class="programlisting">    @RunWith(classOf[Suite]) &#13;
    @Suite.SuiteClasses(Array(classOf[JunitSimpleTest])) &#13;
    class JunitSimpleSuiteTest &#13;
    class JunitSimpleTest extends PlaySpec with AssertionsForJUnit { &#13;
      @Test def testBaseService() { &#13;
        val s = new ProductService &#13;
        val result = s.findAll() &#13;
        assertEquals(None, result) &#13;
        assertTrue( result != null) &#13;
        println("All good junit works fine with ScalaTest and Play") &#13;
      } &#13;
    } &#13;
</pre><p>So what we have in the preceding code is a class that extends <code class="literal">PlaySpec</code>, and adds a trait called <code class="literal">AssertionForJunit</code>. Why don't we have the classical Junit class here? Because the Play framework is set up to run Scala tests, so this bridge allows us to run Junit by <code class="literal">ScalaTest</code> Play framework constructs.</p><p>Then we have a test function called <code class="literal">testBaseServer</code> , which uses the <code class="literal">@Test</code> annotation from JUnit. Inside the test method, we create an instance of <code class="literal">ProductService</code>, and then we call the function <code class="literal">findAll</code>.</p><p>Finally, we have assertions that will check if the result is what we are expecting. So we don't have products, because we did not insert them earlier. Hence, we expect to have <code class="literal">None</code> as the response, and the result should also not be <code class="literal">null</code>.</p><p>You can run this in your console using the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ activator "test-only JunitSimpleTest"</strong></span>
</pre><p>You will see the result shown in the next screenshot:</p><p>
</p><div class="mediaobject"><img src="../Images/image00273.jpeg" alt="Testing with Junit"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>As you can see, our test was executed without any issues. It's also possible to run this test and a normal test in Junit using the Eclipse IDE. You just right-click on the file and select <span class="strong"><strong>
<span class="strong"><strong>Run As: Scala Junit Test</strong></span>;</strong></span> refer to the following screenshot:</p><p>
</p><div class="mediaobject"><img src="../Images/image00274.jpeg" alt="Testing with Junit"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div>
<div class="section" title="Behavior-Driven Development - BDD" id="aid-1TVKI1"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec57"/>Behavior-Driven Development - BDD</h1></div></div></div><p>
<span class="strong"><strong>Behavior-Driven Development</strong></span> (<span class="strong"><strong>BDD</strong></span>) is an agile development technique, that focuses on the engagement between developers and non-technical people such as product owners from the business. The idea is pretty simple: use the same language as the business uses in order to extract the reason why the code you are building exists in the first place. BDD ends up minimizing the translation between tech language and business language, creating more synergy and less noise between information technology and business.</p><p>BDD tests describe what the application needs to do, and how it behaves. It's very common to write down these tests using pair programing between business people and developers. <code class="literal">ScalaTest</code> is a BDD framework. Play framework has a great integration with <code class="literal">ScalaTest</code>. Let's get started with <code class="literal">ScalaTest</code> and Play right now.</p></div>
<div class="section" title="MyFirstPlaySpec.scala - First BDD with ScalaTest and the Play framework" id="aid-1UU541"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec58"/>MyFirstPlaySpec.scala - First BDD with ScalaTest and the Play framework</h1></div></div></div><p>The <code class="literal">MyFirstPlaySpec.scala</code> class should contain the following code:</p><pre class="programlisting">    class MyFirstPlaySpec extends PlaySpec { 
      "x + 1 " must { 
        "be 2 if x=1 " in { 
          val sum = 1 + 1 
          sum mustBe 2 
        } 
        "be 0 if x=-1 " in { 
          val sum = -1 + 1 
          sum mustBe 0 
        } 
      } 
    } 
</pre><p>So, you create a class called <code class="literal">MyFirstPlaySpec</code>, and we extend it from <code class="literal">PlaySpec</code> in order to get Play framework <code class="literal">ScalaTest</code> support. Then we create two functions to test the sum of two numbers. In the first test, <code class="literal">1 +1</code> should be <code class="literal">2</code>, and in the second, <code class="literal">-1 + 1</code> should be <code class="literal">0</code>. When we execute <code class="literal">mustBe</code>, it is the same thing as doing an assert in Junit. The main difference here is that the test has behavior explicitly on the Spec. Now we can run the test by typing the following:</p><pre class="programlisting">
<span class="strong"><strong>$ activator "test-only MyFirstPlaySpec"</strong></span>
</pre><p>You will see the following result:</p><p>
</p><div class="mediaobject"><img src="../Images/image00275.jpeg" alt="MyFirstPlaySpec.scala - First BDD with ScalaTest and the Play framework"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div>
<div class="section" title="Testing with Play framework support"><div class="titlepage" id="aid-1VSLM2"><div><div><h1 class="title"><a id="ch05lvl1sec59"/>Testing with Play framework support</h1></div></div></div><p>Now we will continue building our application. Let's add BDD tests in our application. We will start doing tests for your services. We have to test <code class="literal">ProductService</code>, <code class="literal">ImageService</code>, and <code class="literal">ReviewService</code>.</p><p>Your <code class="literal">ProductServiceTestSpec.scala file</code> should contain the following code:</p><pre class="programlisting">    class ProductServiceTestSpec extends PlaySpec { 
      "ProductService" must { 
        val service:IProductService = new ProductService 
        "insert a product properly" in { 
          val product = new models.Product(Some(1), 
          "Ball","Awesome Basketball",19.75) 
          service.insert(product) 
        } 
        "update a product" in { 
          val product = new models.Product(Some(1), 
          "Blue Ball","Awesome Blue Basketball",19.99) 
          service.update(1, product) 
        } 
        "not update because does not exit" in { 
          intercept[RuntimeException]{ 
            service.update(333,null) 
          } 
        } 
        "find the product 1" in { 
           val product = service.findById(1) 
           product.get.id mustBe Some(1) 
           product.get.name mustBe "Blue Ball" 
           product.get.details mustBe "Awesome Blue Basketball" 
           product.get.price mustBe 19.99 
        } 
        "find all" in { 
          val products = service.findAll() 
          products.get.length mustBe 1 
          products.get(0).id mustBe Some(1) 
          products.get(0).name mustBe "Blue Ball" 
          products.get(0).details mustBe "Awesome Blue Basketball" 
          products.get(0).price mustBe 19.99 
        } 
        "find all products" in { 
          val products = service.findAllProducts() 
          products.length mustBe 1 
          products(0)._1 mustBe "1" 
          products(0)._2 mustBe "Blue Ball" 
        } 
        "remove 1 product" in { 
          val product = service.remove(1) 
          product mustBe true 
          val oldProduct = service.findById(1) 
          oldProduct mustBe None 
        } 
        "not remove because does not exist" in { 
          intercept[RuntimeException]{ 
            service.remove(-1) 
          } 
        } 
      } 
    } 
</pre><p>For this test, we are testing all public functions available in <code class="literal">ProductService</code>. The tests are pretty straightforward: we call a specific service operation, such as <code class="literal">findById</code>, and then we check the result to make sure that all the data that is supposed to be there is present.</p><p>There are scenarios where the service should return an exception, for instance, if you try to remove something that does not exist. If you take a look at the last test function called <code class="literal">"not remove because does not exist"</code>, we should get an exception. However, there is a bug in the service code. Run the tests, and then you will see it.</p><div class="section" title="ProductService.scala - FIX the code issue"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec76"/>ProductService.scala - FIX the code issue</h2></div></div></div><p>That's the great thing about tests: they show issues in our code so that we can fix them before the code goes to production and affects the user experience. To fix the last test, we need to go to the <code class="literal">ProductService</code> class and fix a method. This is how we fix it:</p><pre class="programlisting">    private def validateId(id:Long):Unit = { 
      val entry = inMemoryDB.get(id) 
      if (entry==null || entry.equals(None)) throw new  
      RuntimeException("Could not find Product: " + id) 
    } 
</pre><p>All set now, everything is okay. The Play framework supports testing for expected exceptions using the intercept function to pass the expected exception, Let's run the test in the console using the <code class="literal">activator</code> command.</p><pre class="programlisting">
<span class="strong"><strong>$ activator "test-only ProductServiceTestSpec"</strong></span>
</pre><p>After executing this command, we get the following:</p><p>
</p><div class="mediaobject"><img src="../Images/image00276.jpeg" alt="ProductService.scala - FIX the code issue"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div><div class="section" title="ImageServiceTestSpec.scala - ImageService Test"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec77"/>ImageServiceTestSpec.scala - ImageService Test</h2></div></div></div><p>Alright, Now we can add tests for <code class="literal">ImageService </code>as follows:</p><pre class="programlisting">    class ImageServiceTestSpec extends PlaySpec { 
      "ImageService" must { 
        val service:IImageService = new ImageService 
        "insert a image properly" in { 
          val image = new models.Image(Some(1),Some(1), 
          "http://www.google.com.br/myimage") 
          service.insert(image) 
        } 
        "update a image" in { 
          val image = new models.Image(Some(2),Some(1), 
          "http://www.google.com.br/myimage") 
          service.update(1, image) 
        } 
        "not update because does not exist" in { 
          intercept[RuntimeException]{ 
            service.update(333,null) 
          } 
        } 
        "find the image1" in { 
          val image = service.findById(1) 
          image.get.id mustBe Some(1) 
          image.get.productId mustBe Some(1) 
          image.get.url mustBe "http://www.google.com.br/myimage" 
        } 
        "find all" in { 
          val reviews = service.findAll() 
          reviews.get.length mustBe 1 
          reviews.get(0).id mustBe Some(1) 
          reviews.get(0).productId mustBe Some(1) 
          reviews.get(0).url mustBe "http://www.google.com.br/myimage" 
        } 
        "remove 1 image" in { 
          val image = service.remove(1) 
          image mustBe true 
          val oldImage = service.findById(1) 
          oldImage mustBe None 
        } 
        "not remove because does not exist" in { 
          intercept[RuntimeException]{ 
            service.remove(-1) 
          } 
        } 
      } 
    } 
</pre><p>So these are the BDD tests for <code class="literal">ImageService</code>. We have covered all the available functions on the service. Like in the <code class="literal">ProductService</code> class, we also have tests for unfortunate scenarios where we expect exceptions to happen.</p><p>Sometimes, we need to call more than one function to test a specific function or a specific test case. For example, in <code class="literal">"remove 1 image"</code>, we first delete an image. Our test case checks for an image that does not exist. Let's run the tests on the Activator console.</p><pre class="programlisting">
<span class="strong"><strong>$ activator "test-only ImageServiceTestSpec"</strong></span>
</pre><p>The following result will be obtained:</p><p>
</p><div class="mediaobject"><img src="../Images/image00277.jpeg" alt="ImageServiceTestSpec.scala - ImageService Test"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div><div class="section" title="ReviewServiceTestSpec.scala - ReviewService test"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec78"/>ReviewServiceTestSpec.scala - ReviewService test</h2></div></div></div><p>Next, we need add tests for the review service. Here we go.</p><pre class="programlisting">    class ReviewServiceTestSpec extends PlaySpec { 
      "ReviewService" must { 
        val service:IReviewService = new ReviewService 
        "insert a review properly" in { 
          val review = new  
          models.Review(Some(1),Some(1),"diegopacheco", 
          "Testing is Cool") 
          service.insert(review) 
        } 
        "update a review" in { 
          val review = new models.Review(Some(1),Some(1), 
          "diegopacheco","Testing so so Cool") 
          service.update(1, review) 
        } 
        "not update because does not exist" in { 
          intercept[RuntimeException]{ 
            service.update(333,null) 
          } 
        } 
        "find the review 1" in { 
          val review = service.findById(1) 
          review.get.id mustBe Some(1) 
          review.get.author mustBe "diegopacheco" 
          review.get.comment mustBe "Testing so so Cool" 
          review.get.productId mustBe Some(1) 
        } 
        "find all" in { 
          val reviews = service.findAll() 
          reviews.get.length mustBe 1 
          reviews.get(0).id mustBe Some(1) 
          reviews.get(0).author mustBe "diegopacheco" 
          reviews.get(0).comment mustBe "Testing so so Cool" 
          reviews.get(0).productId mustBe Some(1) 
        } 
        "remove 1 review" in { 
          val review = service.remove(1) 
          review mustBe true 
          val oldReview= service.findById(1) 
          oldReview mustBe None 
        } 
        "not remove because does not exist" in { 
          intercept[RuntimeException]{ 
            service.remove(-1) 
          } 
        } 
      } 
    } 
</pre><p>Alright, we have tests for the review service. We can run them now.</p><pre class="programlisting">
<span class="strong"><strong>$ activator "test-only ReviewServiceTestSpec"</strong></span>
</pre><p>Here is the output:</p><p>
</p><div class="mediaobject"><img src="../Images/image00278.jpeg" alt="ReviewServiceTestSpec.scala - ReviewService test"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div></div>
<div class="section" title="Testing routes" id="aid-20R681"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec60"/>Testing routes</h1></div></div></div><p>The Play framework allows us to test routes as well. This is good, because as our application grows and we refactor the code, we can be 100% sure that our routes are functioning. Route testing could be easily confused with controller testing. The main difference is that, with routing testing, we should test if we are able to reach the routes and that's it. After route testing, we will cover controller testing in detail.</p><div class="section" title="RoutesTestingSpec.scala - Play framework route testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec79"/>RoutesTestingSpec.scala - Play framework route testing</h2></div></div></div><p>Your <code class="literal">RoutesTestingSpec.scala</code> file should contain the following code:</p><pre class="programlisting">    class RoutesTestingSpec extends PlaySpec with OneAppPerTest { &#13;
      "Root Controller" should { &#13;
        "route to index page" in { &#13;
          val result = route(app, FakeRequest(GET, "/")).get &#13;
          status(result) mustBe OK &#13;
          contentType(result) mustBe Some("text/html") &#13;
          contentAsString(result) must include ("Welcome to Reactive  &#13;
          Web Store") &#13;
        } &#13;
      } &#13;
      "Product Controller" should { &#13;
        "route to index page" in { &#13;
          val result = route(app, FakeRequest(GET, "/product")).get &#13;
          status(result) mustBe OK &#13;
          contentType(result) mustBe Some("text/html") &#13;
          contentAsString(result) must include ("Product") &#13;
        } &#13;
        "route to new product page" in { &#13;
          val result = route(app, FakeRequest(GET,  &#13;
          "/product/add")).get &#13;
          status(result) mustBe OK &#13;
          contentType(result) mustBe Some("text/html") &#13;
          contentAsString(result) must include ("Product") &#13;
        } &#13;
        "route to product 1 details page page" in {  &#13;
          try{ &#13;
            route(app, FakeRequest(GET, "/product/details/1")).get &#13;
            }catch{ &#13;
              case e:Exception =&gt; Unit &#13;
            } &#13;
          } &#13;
        } &#13;
        "Review Controller" should { &#13;
          "route to index page" in { &#13;
            val result = route(app, FakeRequest(GET, "/review")).get &#13;
            status(result) mustBe OK &#13;
            contentType(result) mustBe Some("text/html") &#13;
            contentAsString(result) must include ("Review") &#13;
          } &#13;
          "route to new review page" in { &#13;
            val result = route(app, FakeRequest(GET,  &#13;
            "/review/add")).get &#13;
            status(result) mustBe OK &#13;
            contentType(result) mustBe Some("text/html") &#13;
            contentAsString(result) must include ("review") &#13;
          } &#13;
          "route to review 1 details page page" in { &#13;
            try{ &#13;
              route(app, FakeRequest(GET, "/review/details/1")).get &#13;
            }catch{ &#13;
              case e:Exception =&gt; Unit &#13;
            } &#13;
          } &#13;
        } &#13;
        "Image Controller" should { &#13;
          "route to index page" in { &#13;
            val result = route(app, FakeRequest(GET, "/image")).get &#13;
            status(result) mustBe OK &#13;
            contentType(result) mustBe Some("text/html") &#13;
            contentAsString(result) must include ("Image") &#13;
          } &#13;
          "route to new image page" in { &#13;
            val result = route(app, FakeRequest &#13;
            (GET, "/image/add")).get &#13;
            status(result) mustBe OK &#13;
            contentType(result) mustBe Some("text/html") &#13;
            contentAsString(result) must include ("image") &#13;
          } &#13;
          "route to image 1 details page page" in { &#13;
          try{ &#13;
            route(app, FakeRequest(GET, "/image/details/1")).get &#13;
          }catch{ &#13;
            case e:Exception =&gt; Unit  &#13;
          } &#13;
        } &#13;
      }  &#13;
    } &#13;
</pre><p>So here we have tests for all our main controllers, which are root, product, review, and image. <code class="literal">RootController</code> is the controller of the main page when you visit <code class="literal">http://localhost:9000</code>.</p><p>There is a special helper function called <code class="literal">route</code> in the Play framework, which helps us to test routes. Then we use <code class="literal">FakeRequest</code> pass the path to the route. It's possible to test the status code and content type of the page to which the router routed our request.</p><p>For product, image, and review controllers, you can see we are trying to call an item that does not exist. That's why we have the try...catch, because we expect to have an exception happening there.</p><pre class="programlisting">
<span class="strong"><strong>$  activator "test-only RoutesTestingSpec"</strong></span>
</pre><p>Executing this preceding command produces the following result:</p><p>
</p><div class="mediaobject"><img src="../Images/image00279.jpeg" alt="RoutesTestingSpec.scala - Play framework route testing"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div></div>
<div class="section" title="Controller testing"><div class="titlepage" id="aid-21PMQ2"><div><div><h1 class="title"><a id="ch05lvl1sec61"/>Controller testing</h1></div></div></div><p>We did unit tests, we did route tests, and now is the time to add controller tests. Controller tests are similar to routes tests, but they are not the same. For instance, our controller always respond to UI pages, so we expected to create specific HTML pages based on each method. The Play framework has integration with Selenium, which is a testing framework for UIs, and a controllers that allows you to simulate web browsers, and you can do pretty much the same as you would by clicking on the pages like a real user.</p><p>So let's get started. First, we will start with <code class="literal">RndDoubleGeneratorControllerTestSpec</code>.</p><div class="section" title="RndDoubleGeneratorControllerTestSpec.scala - RndDoubleGeneratorController tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec80"/>RndDoubleGeneratorControllerTestSpec.scala - RndDoubleGeneratorController tests</h2></div></div></div><p>The <code class="literal">RndDoubleGeneratorControllerTestSpec.scala</code> file should contain the following code:</p><pre class="programlisting">    class RndDoubleGeneratorControllerTestSpec &#13;
    extends PlaySpec  &#13;
    with OneServerPerSuite with OneBrowserPerSuite with HtmlUnitFactory &#13;
    { &#13;
      val injector = new GuiceApplicationBuilder() &#13;
      .injector &#13;
      val ws:WSClient = injector.instanceOf(classOf[WSClient]) &#13;
      import play.api.libs.concurrent.Execution. &#13;
      Implicits.defaultContext &#13;
      "Assuming ng-microservice is down rx number should be" must { &#13;
        "work" in { &#13;
          val future = ws.url(s"http://localhost:${port}/rnd/rxbat") &#13;
          .get().map { res =&gt; res.body } &#13;
          val response = Await.result(future, 15.seconds) &#13;
          response mustBe "2.3000000000000007" &#13;
        } &#13;
      } &#13;
    } &#13;
</pre><p>This class has some interesting things. For instance, we inject <code class="literal">WSClient</code> using Google Guice with <code class="literal">GuiceApplicationBuilder</code>. Secondly, we assume that the <code class="literal">ng-microservice</code>  we created in the previous chapter is down, so we can predict the response coming from the fallback.</p><p>We call the controller using <code class="literal">WSClient</code>, and then we map the response to return the body content as a string. So this will be an Async Future, and in order to get the result, we use <code class="literal">Await</code> to wait five seconds for the response to come back. Once the response is back, we make sure the result is 2.3. If the result does not come back in 15s, the test will fail. Run the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ activator "test-only RndDoubleGeneratorControllerTestSpec"</strong></span>
</pre><p>Now you will see the following result:</p><p>
</p><div class="mediaobject"><img src="../Images/image00280.jpeg" alt="RndDoubleGeneratorControllerTestSpec.scala - RndDoubleGeneratorController tests"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>All right, now we have a controller test fully working using Guice injections and the <code class="literal">WSClient</code> Play framework library. Let's now make controller tests for the product, image, and review controllers.</p></div><div class="section" title="IntegrationSpec.scala"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec81"/>IntegrationSpec.scala</h2></div></div></div><p>We can test our main page to check if it is okay. This is a very simple test, and gets you ready for the next tests. So, here we go.</p><pre class="programlisting">    class IntegrationSpec extends PlaySpec with OneServerPerTest with  &#13;
    OneBrowserPerTest with HtmlUnitFactory { &#13;
     &#13;
      "Application" should { &#13;
        "work from within a browser" in {  &#13;
           go to ("http://localhost:" + port) &#13;
           pageSource must include ("Welcome to Reactive Web Store") &#13;
        } &#13;
      } &#13;
    } &#13;
</pre><p>This test is very easy. We just call the main page, and we check if it contains the text <code class="literal">Welcome to Reactive WebStore</code>. Let's run it.</p><pre class="programlisting">
<span class="strong"><strong>$ activator "test-only IntegrationSpec"</strong></span>
</pre><p>The result after running this test is shown in the following image:</p><p>
</p><div class="mediaobject"><img src="../Images/image00281.jpeg" alt="IntegrationSpec.scala"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div><div class="section" title="ProductControllerTestSpec.scala"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec82"/>ProductControllerTestSpec.scala</h2></div></div></div><p>Now we will look at the product controller test spec:</p><pre class="programlisting">    class ProductControllerTestSpec extends PlaySpec with &#13;
    OneServerPerSuite with OneBrowserPerSuite with HtmlUnitFactory { &#13;
      "ProductController" should { &#13;
        "insert a new product should be ok" in { &#13;
          goTo(s"http://localhost:${port}/product/add") &#13;
          click on id("name") &#13;
          enter("Blue Ball") &#13;
          click on id("details") &#13;
          enter("Blue Ball is a Awesome and simple product") &#13;
          click on id("price") &#13;
          enter("17.55") &#13;
          submit() &#13;
        } &#13;
        "details from the product 1 should be ok" in { &#13;
          goTo(s"http://localhost:${port}/product/details/1") &#13;
          textField("name").value mustBe "Blue Ball" &#13;
          textField("details").value mustBe "Blue Ball is a Awesome  &#13;
          and simple product" &#13;
          textField("price").value mustBe "17.55" &#13;
        } &#13;
        "update product 1 should be ok" in { &#13;
          goTo(s"http://localhost:${port}/product/details/1") &#13;
          textField("name").value = "Blue Ball 2" &#13;
          textField("details").value = "Blue Ball is a Awesome and  &#13;
          simple product 2 " &#13;
          textField("price").value = "17.66" &#13;
          submit() &#13;
          goTo(s"http://localhost:${port}/product/details/1") &#13;
          textField("name").value mustBe "Blue Ball 2" &#13;
          textField("details").value mustBe "Blue Ball is a Awesome  &#13;
          and simple product 2 " &#13;
          textField("price").value mustBe "17.66" &#13;
        } &#13;
        "delete a product should be ok" in { &#13;
          goTo(s"http://localhost:${port}/product/add") &#13;
          click on id("name") &#13;
          enter("Blue Ball") &#13;
          click on id("details") &#13;
          enter("Blue Ball is a Awesome and simple product") &#13;
          click on id("price") &#13;
          enter("17.55") &#13;
          submit() &#13;
          goTo(s"http://localhost:${port}/product") &#13;
          click on id("btnDelete") &#13;
        } &#13;
      } &#13;
    } &#13;
</pre><p>So, for the product controller, we simulate a web browser using Selenium Play's framework support. We test basic controller functionality such as inserting a new product, details for a specific product, and updating and removing a product.</p><p>For insert, we go to the new product form using <code class="literal">goTo</code>. We use <code class="literal">$port</code> as a variable. We do this because the Play framework will boot up the application for us, but we don't know in which port. So we need to use this variable in order to get to the product controller.</p><p>Then we click on each text field using the <code class="literal">click</code> function, and we enter values using the <code class="literal">enter</code> function. After filling in the whole form, we submit it using the <code class="literal">submit</code> function.</p><p>For details, we just go to the product details page, and we check if the text fields have the values that we are expecting. We do that using the <code class="literal">textField.value</code> function.</p><p>In order to check the product update function, we need to first update the product definition, and then go to details to see if the values we changed are there.</p><p>Finally, we test the <code class="literal">delete</code> function. For this function, we need to click on a button. We need to set the ID of the button in order to have this working. We need to do a small refactoring in our UI to have the ID there.</p></div><div class="section" title="product_index.scala.html"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec83"/>product_index.scala.html</h2></div></div></div><p>Your <code class="literal">product_index.scala.html</code> file should contain the following code:</p><pre class="programlisting">    @(products:Seq[Product])(implicit flash: Flash) &#13;
    @main("Products") { &#13;
      @if(!products.isEmpty) { &#13;
        &lt;table class="table table-striped"&gt; &#13;
          &lt;tr&gt; &#13;
            &lt;th&gt;Name&lt;/th&gt; &#13;
            &lt;th&gt;Details&lt;/th&gt;  &#13;
            &lt;th&gt;Price&lt;/th&gt; &#13;
            &lt;th&gt;&lt;/th&gt; &#13;
          &lt;/tr&gt; &#13;
          @for(product &lt;- products) { &#13;
            &lt;tr&gt; &#13;
              &lt;td&gt;&lt;a href="@routes.ProductController.details &#13;
              (product.id.get)"&gt;@product.name&lt;/a&gt;&lt;/td&gt; &#13;
              &lt;td&gt;@product.details&lt;/td&gt; &#13;
              &lt;td&gt;@product.price&lt;/td&gt; &#13;
              &lt;td&gt;&lt;form method="post" action= &#13;
              "@routes.ProductController.remove(product.id.get)"&gt; &#13;
                &lt;button id="btnDelete" name="btnDelete" class="btn  &#13;
                btn-link" type="submit"&gt;&lt;i class="icon- &#13;
                trash"&gt;&lt;/i&gt;Delete&lt;/button&gt; &#13;
              &lt;/form&gt;&lt;/td&gt;  &#13;
            &lt;/tr&gt; &#13;
          } &#13;
        &lt;/table&gt; &#13;
      } &#13;
      &lt;p&gt;&lt;a href="@routes.ProductController.blank"  &#13;
      class="btn btn-success"&gt;&lt;i class="icon-plus icon-white"&gt; &#13;
      &lt;/i&gt;Add Product&lt;/a&gt;&lt;/p&gt; &#13;
    } &#13;
</pre><p>All set. Now we can run our tests on Activators using the console.</p><pre class="programlisting">
<span class="strong"><strong>$ activator "test-only ProductControllerTestSpec"</strong></span>
</pre><p>This preceding command shows the result in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="../Images/image00282.jpeg" alt="product_index.scala.html"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Since this test runs the application for real and calls the controller simulating the web browser, this test could take some time. Now it's time to move to the <code class="literal">ImageController</code> tests.</p></div><div class="section" title="ImageControllerTestSpec.scala"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec84"/>ImageControllerTestSpec.scala</h2></div></div></div><p>Your <code class="literal">product_index.scala.html</code> should contain the following code:</p><pre class="programlisting">    class ImageControllerTestSpec extends PlaySpec with OneServerPerSuite with OneBrowserPerSuite with &#13;
    HtmlUnitFactory { &#13;
      "ImageController" should { &#13;
        "insert a new image should be ok" in { &#13;
          goTo(s"http://localhost:${port}/product/add") &#13;
          click on id("name") &#13;
          enter("Blue Ball") &#13;
          click on id("details") &#13;
          enter("Blue Ball is a Awesome and simple product") &#13;
          click on id("price") &#13;
          enter("17.55") &#13;
          submit() &#13;
          goTo(s"http://localhost:${port}/image/add") &#13;
          singleSel("productId").value = "1" &#13;
          click on id("url") &#13;
          enter("http://myimage.com/img.jpg") &#13;
          submit() &#13;
        } &#13;
        "details from the image 1 should be ok" in { &#13;
          goTo(s"http://localhost:${port}/image/details/1") &#13;
          textField("url").value mustBe "http://myimage.com/img.jpg" &#13;
        } &#13;
        "update image 1 should be ok" in { &#13;
          goTo(s"http://localhost:${port}/image/details/1") &#13;
          textField("url").value = "http://myimage.com/img2.jpg" &#13;
          submit() &#13;
          goTo(s"http://localhost:${port}/image/details/1") &#13;
          textField("url").value mustBe "http://myimage.com/img2.jpg" &#13;
        } &#13;
        "delete a image should be ok" in { &#13;
          goTo(s"http://localhost:${port}/image/add") &#13;
          singleSel("productId").value = "1" &#13;
          click on id("url") &#13;
          enter("http://myimage.com/img.jpg") &#13;
          submit() &#13;
          goTo(s"http://localhost:${port}/image") &#13;
          click on id("btnDelete") &#13;
        } &#13;
      } &#13;
    } &#13;
</pre><p>First of all, we need to go to the product controller to insert a product; otherwise, we cannot do image operations, since they all need a product ID.</p></div><div class="section" title="image_index.scala.html"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec85"/>image_index.scala.html</h2></div></div></div><p>Your <code class="literal">image_index.scala.html</code> file should contain the following code:</p><pre class="programlisting">    @(images:Seq[Image])(implicit flash:Flash) &#13;
    @main("Images") { &#13;
      @if(!images.isEmpty) { &#13;
        &lt;table class="table table-striped"&gt; &#13;
          &lt;tr&gt; &#13;
            &lt;th&gt;ProductID&lt;/th&gt; &#13;
            &lt;th&gt;URL&lt;/th&gt; &#13;
            &lt;th&gt;&lt;/th&gt; &#13;
          &lt;/tr&gt; &#13;
          @for(image &lt;- images) { &#13;
            &lt;tr&gt; &#13;
              &lt;td&gt;&lt;a href="@routes.ImageController.details &#13;
              (image.id.get)"&gt;@image.id&lt;/a&gt;&lt;/td&gt; &#13;
              &lt;td&gt;@image.productId&lt;/td&gt; &#13;
              &lt;td&gt;@image.url&lt;/td&gt; &#13;
              &lt;td&gt;&lt;form method="post" action= &#13;
              "@routes.ImageController.remove(image.id.get)"&gt; &#13;
                &lt;button id="btnDelete" name="btnDelete" class="btn  &#13;
                btn-link" type="submit"&gt;&lt;i class="icon- &#13;
                trash"&gt;&lt;/i&gt;Delete&lt;/button&gt;&lt;/form&gt; &#13;
              &lt;/td&gt; &#13;
            &lt;/tr&gt; &#13;
          } &#13;
        &lt;/table&gt; &#13;
      } &#13;
      &lt;p&gt;&lt;a href="@routes.ImageController.blank"  &#13;
      class="btn btn-success"&gt;&lt;i class="icon-plus icon-white"&gt; &#13;
      &lt;/i&gt;Add Image&lt;/a&gt;&lt;/p&gt; &#13;
    } &#13;
</pre><p>All set. Now we can run the <code class="literal">ImageController</code> tests.</p><pre class="programlisting">
<span class="strong"><strong>$ activator "test-only ImageControllerTestSpec"</strong></span>
</pre><p>The result is shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="../Images/image00283.jpeg" alt="image_index.scala.html"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>
<code class="literal">ImageController</code> has passed all its tests. Now we will move to the <code class="literal">ReviewController</code> tests.</p></div><div class="section" title="ReviewControllerTestSpec.scala"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec86"/>ReviewControllerTestSpec.scala</h2></div></div></div><p>Your <code class="literal">ReviewControllerTestSpec.scala</code> file should contain the following code:</p><pre class="programlisting">    class ReviewControllerTestSpec extends PlaySpec with OneServerPerSuite with OneBrowserPerSuite &#13;
    with HtmlUnitFactory { &#13;
      "ReviewController" should { &#13;
        "insert a new review should be ok" in { &#13;
          goTo(s"http://localhost:${port}/product/add") &#13;
          click on id("name") &#13;
          enter("Blue Ball") &#13;
          click on id("details") &#13;
          enter("Blue Ball is a Awesome and simple product") &#13;
          click on id("price") &#13;
          enter("17.55") &#13;
          submit() &#13;
          goTo(s"http://localhost:${port}/review/add") &#13;
          singleSel("productId").value = "1" &#13;
          click on id("author") &#13;
          enter("diegopacheco") &#13;
          click on id("comment") &#13;
          enter("Tests are amazing!") &#13;
          submit() &#13;
        } &#13;
        "details from the review 1 should be ok" in { &#13;
          goTo(s"http://localhost:${port}/review/details/1") &#13;
          textField("author").value mustBe "diegopacheco" &#13;
          textField("comment").value mustBe "Tests are amazing!" &#13;
        } &#13;
        "update review 1 should be ok" in { &#13;
          goTo(s"http://localhost:${port}/review/details/1") &#13;
          textField("author").value = "diegopacheco2" &#13;
          textField("comment").value = "Tests are amazing 2!" &#13;
          submit() &#13;
          goTo(s"http://localhost:${port}/review/details/1") &#13;
          textField("author").value mustBe "diegopacheco2" &#13;
          textField("comment").value mustBe "Tests are amazing 2!" &#13;
        } &#13;
        "delete a review should be ok" in { &#13;
          goTo(s"http://localhost:${port}/review/add") &#13;
          singleSel("productId").value = "1" &#13;
          click on id("author") &#13;
          enter("diegopacheco") &#13;
          click on id("comment") &#13;
          enter("Tests are amazing!") &#13;
          submit() &#13;
          goTo(s"http://localhost:${port}/review") &#13;
          click on id("btnDelete") &#13;
          } &#13;
    } &#13;
</pre><p>First of all, we need to go to the product controller to insert a product; otherwise, we cannot do image operations, since they all need a product ID.</p><p>For insert, we go to the new product form using goto. We use <code class="literal">$port</code> as a variable. We do this because the Play framework will boot up the application for us, but we don't know on which port, so we need to use this variable in order to get to the product controller.</p><p>Then we click on each text field using the <code class="literal">click</code> function, and we enter values using the <code class="literal">enter</code> function. After filling in the whole form, we submit it using the <code class="literal">submit</code> function.</p><p>For details, we just go to the product details page and check if the text fields have the values that we expect. We do that using the <code class="literal">textField.value</code> function.</p><p>In order to check the product update function, we need to first update the product definition, and then go to the details to see if the values we changed are there.</p><p>Finally, we test the <code class="literal">delete</code> function. For this function, we need to click on a button. We need to set the ID of the button in order to have this working. Then we do a small refactoring in our UI to have the ID there.</p></div><div class="section" title="review_index.scala.html"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec87"/>review_index.scala.html</h2></div></div></div><p>Your <code class="literal">review_index.scala.html</code> file should contain the following code:</p><pre class="programlisting">    @(reviews:Seq[Review])(implicit flash: Flash) &#13;
    @main("Reviews") { &#13;
      @if(!reviews.isEmpty) { &#13;
        &lt;table class="table table-striped"&gt; &#13;
          &lt;tr&gt; &#13;
            &lt;th&gt;ProductId&lt;/th&gt; &#13;
            &lt;th&gt;Author&lt;/th&gt; &#13;
            &lt;th&gt;Comment&lt;/th&gt; &#13;
            &lt;th&gt;&lt;/th&gt; &#13;
          &lt;/tr&gt; &#13;
          @for(review &lt;- reviews) { &#13;
            &lt;tr&gt; &#13;
              &lt;td&gt;&lt;a href="@routes.ReviewController. &#13;
              details(review.id.get)"&gt;@review.productId&lt;/a&gt;&lt;/td&gt; &#13;
              &lt;td&gt;@review.author&lt;/td&gt; &#13;
              &lt;td&gt;@review.comment&lt;/td&gt; &#13;
              &lt;td&gt; &#13;
                &lt;form method="post" action="@routes. &#13;
                ReviewController.remove(review.id.get)"&gt; &#13;
                  &lt;button id="btnDelete" name="btnDelete"  &#13;
                  class="btn btn-link" type="submit"&gt;&lt;i class="icon- &#13;
                  trash"&gt;&lt;/i&gt;Delete&lt;/button&gt; &#13;
                &lt;/form&gt; &#13;
              &lt;/td&gt; &#13;
            &lt;/tr&gt; &#13;
          } &#13;
        &lt;/table&gt; &#13;
      } &#13;
      &lt;p&gt;&lt;a href="@routes.ReviewController.blank" class="btn btn- &#13;
      success"&gt;&lt;i class="icon-plus icon-white"&gt;&lt;/i&gt;Add Review&lt;/a&gt;&lt;/p&gt; &#13;
    } &#13;
</pre><p>Finally, we can run the tests on the console.</p><pre class="programlisting">
<span class="strong"><strong>$ activator "test-only ReviewControllerTestSpec"</strong></span>
</pre><p>The test will show the following output:</p><p>
</p><div class="mediaobject"><img src="../Images/image00284.jpeg" alt="review_index.scala.html"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Alright, <code class="literal">ReviewController</code> has passed all our tests.</p><p>It's a very good practice to have the tests separated by type. However, if you want, you could mix all the tests such as unit testing, controller testing, and route testing in one single file.</p></div><div class="section" title="ApplicationSpec.scala"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec88"/>ApplicationSpec.scala</h2></div></div></div><p>Your <code class="literal">ApplicationSpec.scala</code> should have the following code:</p><pre class="programlisting">    class ApplicationSpec extends PlaySpec with OneAppPerTest { &#13;
      "Routes" should { &#13;
        "send 404 on a bad request" in { &#13;
          route(app, FakeRequest(GET, "/boum")).map(status(_)) mustBe  &#13;
          Some(NOT_FOUND) &#13;
        } &#13;
      } &#13;
      "HomeController" should { &#13;
        "render the index page" in { &#13;
          val home = route(app, FakeRequest(GET, "/")).get &#13;
          status(home) mustBe OK &#13;
          contentType(home) mustBe Some("text/html") &#13;
          contentAsString(home) must include ("Welcome to Reactive Web  &#13;
          Store") &#13;
        } &#13;
      } &#13;
      "RndController" should { &#13;
        "return a random number" in { &#13;
          // Assuming ng-microservice is down otherwise will fail. &#13;
          contentAsString(route(app, FakeRequest(GET,  &#13;
          "/rnd/rxbat")).get) mustBe "2.3000000000000007" &#13;
        } &#13;
      } &#13;
    } &#13;
</pre><p>We can run these mixed tests, and they will all pass.</p><pre class="programlisting">
<span class="strong"><strong>$ activator "test-only ApplicationSpec"</strong></span>
</pre><p>You will see this result:</p><p>
</p><div class="mediaobject"><img src="../Images/image00285.jpeg" alt="ApplicationSpec.scala"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>OK, we are almost done. We just need to add some tests for the microservice called <code class="literal">ng-microservice</code> , which we created in <a class="link" title="Chapter 4. Developing Reactive Backing Services" href="part0060.xhtml#aid-1P71O2">Chapter 4</a>, <span class="emphasis"><em>Developing Reactive Backing Services</em></span>.</p></div><div class="section" title="NGServiceImplTestSpec.scala"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec89"/>NGServiceImplTestSpec.scala</h2></div></div></div><p>Your NGServiceImplTestSpec.scala file should have the following code:</p><pre class="programlisting">    class NGServiceImplTestSpec extends PlaySpec { &#13;
      "The NGServiceImpl" must { &#13;
        "Generate a Ramdon number" in { &#13;
          val service:NGContract = new NGServiceImpl &#13;
          val double = service.generateDouble &#13;
          assert( double &gt;= 1 ) &#13;
        } &#13;
        "Generate a list of 3 Ramdon numbers" in { &#13;
          val service:NGContract = new NGServiceImpl &#13;
          val doubles = service.generateDoubleBatch(3) &#13;
          doubles.size mustBe 3 &#13;
          assert( doubles(0) &gt;= 1 ) &#13;
          assert( doubles(1) &gt;= 1 ) &#13;
          assert( doubles(2) &gt;= 1 ) &#13;
        } &#13;
      } &#13;
    } &#13;
</pre><p>So here, in the preceding code, we have two methods to test the two operations that we have in our microservice. First we generate one double, and then we ask for a list of three doubles. As you can see, we just check if we get a positive double back from the service, and that's it. Since the result is not predictable, this is a good way to test it. Sometimes, even when the result is predictable, you want tests like this. Why? Because it makes the tests more reliable, and often, when we use too many hardcore values. The values could be changing and breaking our tests, and that's not cool. Let's run it on the console.</p><pre class="programlisting">
<span class="strong"><strong>$  activator "test-only NGServiceImplTestSpec"</strong></span>
</pre><p>Here is the result that we get:</p><p>
</p><div class="mediaobject"><img src="../Images/image00286.jpeg" alt="NGServiceImplTestSpec.scala"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Now let's move on to the controller, and do some controller testing.</p></div><div class="section" title="NGServiceEndpointControllerTest.scala"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec90"/>NGServiceEndpointControllerTest.scala</h2></div></div></div><p>Your <code class="literal">NGServiceEndpointControllerTest.scala</code> file should contain the following code:</p><pre class="programlisting">    class NGServiceEndpointControllerTest extends PlaySpec with OneServerPerSuite with &#13;
    OneBrowserPerSuite with HtmlUnitFactory { &#13;
      val injector = new GuiceApplicationBuilder() &#13;
      .injector &#13;
      val ws:WSClient = injector.instanceOf(classOf[WSClient]) &#13;
      import play.api.libs.concurrent.Execution. &#13;
      Implicits.defaultContext &#13;
      "NGServiceEndpointController" must { &#13;
        "return a single double" in { &#13;
          val future = ws.url(s"http://localhost:${port}/double") &#13;
          .get().map { res =&gt; res.body } &#13;
          val response = Await.result(future, 15.seconds) &#13;
          response must not be empty &#13;
          assert( new java.lang.Double(response) &gt;= 1 ) &#13;
        } &#13;
        "return a list of 3 doubles" in { &#13;
          val future = ws.url(s"http://localhost:${port}/doubles/3") &#13;
          .get().map { res =&gt; res.body } &#13;
          val response = Await.result(future, 15.seconds) &#13;
          response must (not be empty and include ("[") and  &#13;
          include ("]")) &#13;
        } &#13;
      } &#13;
    } &#13;
</pre><p>Here we have to inject the <code class="literal">WSClient</code> library so we can call the controller. This controller has two methods like the service we tested before. The second method returns a JSON structure. Then we check for <code class="literal">"["and "]"</code> to make sure that the array is present, since this is a list of three numbers.</p><p>We use the assert function to check the response from the controller, and to be 100% sure that everything is okay. Let's run it.</p><pre class="programlisting">
<span class="strong"><strong>$ activator "test-only NGServiceEndpointControllerTest"</strong></span>
</pre><p>Refer to the following screenshot to see the test result:</p><p>
</p><div class="mediaobject"><img src="../Images/image00287.jpeg" alt="NGServiceEndpointControllerTest.scala"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Great! We have covered pretty much everything .</p><p>In this chapter, we ran all kinds of tests. We always used the command <code class="literal">$ activator "test-only xxx"</code>; the reason for this is to save time. However, it is very common to run all tests. You can do that in both projects; we have to just type <code class="literal">$ activator test</code>.</p><p>When running all the tests in the <code class="literal">ng-microservice</code> project, we get the result shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="../Images/image00288.jpeg" alt="NGServiceEndpointControllerTest.scala"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>On the other hand, running all the tests in the <code class="literal">ReactiveWebStore</code> project gives the result shown in the next screenshot:</p><p>
</p><div class="mediaobject"><img src="../Images/image00289.jpeg" alt="NGServiceEndpointControllerTest.scala"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div></div>
<div class="section" title="Summary" id="aid-22O7C1"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec62"/>Summary</h1></div></div></div><p>In this chapter, you learned how to do tests. We added several tests for your Scala and Play framework projects. You also learned about unit testing principles, testing Scala applications with JUnit, BDD principles, testing with <code class="literal">ScalaTest</code>, testing Play framework applications with <code class="literal">ScalaTest</code>, and running tests in Activator / SBT.</p><p>In the next chapter, you will learn more about persistence using Slick, which is reactive. We will also change our tests a little bit in order to work with a database.</p></div></body></html>