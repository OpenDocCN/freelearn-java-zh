<html><head></head><body>
  <div id="_idContainer264" class="Basic-Text-Frame">
    <h1 class="chapterNumber">10</h1>
    <h1 id="_idParaDest-446" class="chapterTitle">Concurrency – Virtual Threads and Structured Concurrency</h1>
    <p class="normal">This chapter includes 16 problems that briefly introduce <em class="italic">virtual threads</em> and <em class="italic">structured concurrency</em>. </p>
    <p class="normal">If you don’t have a background in concurrency in Java, then I strongly recommend postponing this chapter until after you have read some good introductory coverage on the topic. For instance, you could try out <em class="italic">Chapters 10</em> an<em class="italic">d 11</em> from <em class="italic">Java Coding Problems</em>, <em class="italic">First Edition</em>.</p>
    <p class="normal"><em class="italic">Virtual threads</em> are one of the most important and astonishing features added by Java in the last few years. They have a significant impact on how we will continue to write and understand concurrent code from this point forward. In this chapter, you’ll learn, step by step, every single detail of this topic and the <em class="italic">structured concurrency</em> paradigm.</p>
    <p class="normal">After this chapter, you’ll be quite knowledgeable in working with virtual threads and structured concurrency.</p>
    <h1 id="_idParaDest-447" class="heading-1">Problems</h1>
    <p class="normal">Use the following problems to test your programming prowess in virtual threads and structured concurrency in Java. I strongly encourage you to give each problem a try before you turn to the solutions and download the example programs:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="209"><strong class="keyWord">Explaining concurrency vs. parallelism</strong>: Provide a brief but meaningful explanation of concurrency vs. parallelism.</li>
      <li class="numberedList"><strong class="keyWord">Introducing structured concurrency</strong>: Write an example highlighting the main issues of “unstructured” concurrency. Moreover, provide an introduction to the structured concurrency paradigm.</li>
      <li class="numberedList"><strong class="keyWord">Introducing virtual threads</strong>: Explain and exemplify the main concepts of virtual threads.</li>
      <li class="numberedList"><strong class="keyWord">Using the ExecutorService for virtual threads</strong>: Write several examples that highlight the <em class="italic">task-per-thread</em> model via <code class="inlineCode">ExecutorService</code> and virtual threads.</li>
      <li class="numberedList"><strong class="keyWord">Explaining how virtual threads work</strong>: Provide comprehensive coverage of how virtual threads work internally.</li>
      <li class="numberedList"><strong class="keyWord">Hooking virtual threads and sync code</strong>: Explain and exemplify via a meaningful snippet of code how virtual threads and sync code work together.</li>
      <li class="numberedList"><strong class="keyWord">Exemplifying thread context switching</strong>: Write several examples that show how <em class="italic">thread context switching</em> works for virtual threads.</li>
      <li class="numberedList"><strong class="keyWord">Introducing the ExecutorService invoke all/any for virtual threads – part 1</strong>: Provide a brief introduction of <code class="inlineCode">ExecutorService</code> invoke all/any for virtual threads.</li>
      <li class="numberedList"><strong class="keyWord">Introducing the ExecutorServiceinvoke all/any for virtual threads – part 2</strong>: Re-write the example of “unstructured” concurrency from <em class="italic">Problem 210</em> via <code class="inlineCode">ExecutorService</code> invoke all/any for virtual threads.</li>
      <li class="numberedList"><strong class="keyWord">Hooking task state</strong>: Explain and exemplify the new <code class="inlineCode">Future#state()</code> API.</li>
      <li class="numberedList"><strong class="keyWord">Combining new VirtualThreadPerTaskExecutor() and streams</strong>: Write several examples that introduce how Java stream pipelines can be combined with the <code class="inlineCode">newVirtualThreadPerTaskExecutor()</code> executor.</li>
      <li class="numberedList"><strong class="keyWord">Introducing a scope object (StructuredTaskScope)</strong>: Provide a brief introduction of structured concurrency via the <code class="inlineCode">StructuredTaskScope</code> API.</li>
      <li class="numberedList"><strong class="keyWord">Introducing ShutdownOnSuccess</strong>: Exemplify the <code class="inlineCode">ShutdownOnSuccess</code> flavor of <code class="inlineCode">StructuredTaskScope</code>.</li>
      <li class="numberedList"><strong class="keyWord">Introducing ShutdownOnFailure</strong>: Exemplify the <code class="inlineCode">ShutdownOnFailure</code> flavor of <code class="inlineCode">StructuredTaskScope</code>.</li>
      <li class="numberedList"><strong class="keyWord">Combining StructuredTaskScope and streams</strong>: Write several examples that introduce how Java stream pipelines can be combined with <code class="inlineCode">StructuredTaskScope</code>.</li>
      <li class="numberedList"><strong class="keyWord">Observing and monitoring virtual threads</strong>: Exemplify how we can use <strong class="keyWord">JFR</strong> (<strong class="keyWord">Java Flight Recorder</strong>), <strong class="keyWord">JMX</strong> (<strong class="keyWord">Java Management Extensions</strong>), and any other tool that you like, for observing and monitoring virtual threads.</li>
    </ol>
    <p class="normal">The following sections describe solutions to the preceding problems. Remember that there usually isn’t a single correct way to solve a particular problem. Also, remember that the explanations shown here include only the most interesting and important details needed to solve the problems. Download the example solutions to see additional details and to experiment with the programs at <a href="https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter10"><span class="url">https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter10</span></a>.</p>
    <h1 id="_idParaDest-448" class="heading-1">209. Explaining concurrency vs. parallelism</h1>
    <p class="normal">Before<a id="_idIndexMarker1135"/> tackling the main topic of this chapter, <em class="italic">structured concurrency</em>, let’s forget about <em class="italic">structure</em>, and let’s keep only <em class="italic">concurrency</em>. Next, let’s put <em class="italic">concurrency</em> against <em class="italic">parallelism</em>, since these two notions are often a source of confusion.</p>
    <p class="normal">Both of them, concurrency and parallelism, use <em class="italic">tasks</em> as the main unit of work. However, the way that they handle these tasks makes them very different.</p>
    <p class="normal">In the case of parallelism, a task is split into subtasks across multiple CPU cores. These subtasks are computed in parallel, and each of them represents a partial solution for the given task. By joining these partial solutions, we obtain the solution. Ideally, solving a task in parallel should result in less wall-clock time than in the case of solving the same task sequentially. In a nutshell, in parallelism, at least two threads run at the same time, which means that parallelism can solve a single task faster.</p>
    <p class="normal">In the case of concurrency, we try to solve as many tasks as possible via several threads that compete with each other, progressing in a time-slicing fashion. This means that concurrency can complete multiple tasks faster. This is why concurrency is also referred to as virtual parallelism.</p>
    <p class="normal">The following figure depicts parallelism vs. concurrency:</p>
    <figure class="mediaobject"><img src="../Images/B19665_10_01.png" alt="Figure 10.1.png"/></figure>
    <p class="packt_figref">Figure 10.1: Concurrency vs. parallelism</p>
    <p class="normal">In parallelism, tasks (subtasks) are part of the implemented solution/algorithm. We write the code, set/control the number of tasks, and use them in a context that has parallel computational capabilities. On the other hand, in concurrency, tasks are part of the problem.</p>
    <p class="normal">Typically, we measure parallelism efficiency in <em class="italic">latency</em> (the amount of time needed to complete the task), while the efficiency of concurrency is measured in <em class="italic">throughput</em> (the number of tasks that we can solve).</p>
    <p class="normal">Moreover, in <a id="_idIndexMarker1136"/>parallelism, tasks control resource allocation (CPU time, I/O operations, and so on). On the other hand, in concurrency, multiple threads compete with each other to gain as many resources (I/O) as possible. They cannot control resource allocation.</p>
    <p class="normal">In parallelism, threads operate on CPU cores in such a way that every core is busy. In concurrency, threads operate on tasks in such a way that, ideally, each thread has a separate task.</p>
    <p class="normal">Commonly, when parallelism and concurrency are compared, somebody comes and says: <em class="italic">How about asynchronous methods?</em></p>
    <p class="normal">It is important to understand that <em class="italic">asynchrony</em> is a separate concept. Asynchrony is about the capability to accomplish non-blocking operations. For instance, an application sends an HTTP request, but it doesn’t just wait for the response. It goes and solves something else (other tasks) while waiting for the response. We do asynchronous tasks every day. For instance, we start the washing machine and then go to clean other parts of the house. We don’t just wait by the washing machine until it is finished.</p>
    <h1 id="_idParaDest-449" class="heading-1">210. Introducing structured concurrency</h1>
    <p class="normal">If you are as old as I am, then <a id="_idIndexMarker1137"/>most probably you started programming with a language such as BASIC or a similar unstructured programming language. At that time, an application was just a sequence of lines that defined a sequential logic/behavior via a bunch of GOTO statements, driving the flow by jumping like a kangaroo back and forward between the code lines. Well, in Java, the building blocks of a typical concurrent code are so primitive that the code looks somewhat like unstructured programming because it is hard to follow and understand. Moreover, a thread dump of a concurrent task doesn’t provide the needed answers.</p>
    <p class="normal">Let’s follow a snippet of Java concurrent code and stop every time we have a question (always check the code below the question). The task is to concurrently load three testers by ID and team them up in a testing team. First, let’s list the server code (we will use this simple code to serve us in this problem and subsequent problems):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">fetchTester</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> id)</span> 
      <span class="hljs-keyword">throws</span> IOException, InterruptedException {
  <span class="hljs-type">HttpClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> HttpClient.newHttpClient();
  <span class="hljs-type">HttpRequest</span> <span class="hljs-variable">requestGet</span> <span class="hljs-operator">=</span> HttpRequest.newBuilder()
    .GET()
    .uri(URI.create(<span class="hljs-string">"https://reqres.in/api/users/"</span> + id))
    .build();
  HttpResponse&lt;String&gt; responseGet = client.send(
    requestGet, HttpResponse.BodyHandlers.ofString());
  <span class="hljs-keyword">if</span> (responseGet.statusCode() == <span class="hljs-number">200</span>) {
    <span class="hljs-keyword">return</span> responseGet.body();
  }
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">UserNotFoundException</span>(<span class="hljs-string">"Code: "</span> 
    + responseGet.statusCode());
}
</code></pre>
    <p class="normal">Next, the <a id="_idIndexMarker1138"/>code that we are especially interested in starts as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> 
  <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TestingTeam <span class="hljs-title">buildTestingTeam</span><span class="hljs-params">()</span> 
    <span class="hljs-keyword">throws</span> InterruptedException {
  ...
</code></pre>
    <p class="normal"><em class="italic">First stop</em>: As you can see, <code class="inlineCode">buildTestingTeam()</code> throws an <code class="inlineCode">InterruptedException</code>. So if the thread executing <code class="inlineCode">buildTestingTeam()</code> gets interrupted, how can we easily interrupt the following threads?</p>
    <pre class="programlisting code"><code class="hljs-code">  Future&lt;String&gt; future1 = futureTester(<span class="hljs-number">1</span>);
  Future&lt;String&gt; future2 = futureTester(<span class="hljs-number">2</span>);
  Future&lt;String&gt; future3 = futureTester(<span class="hljs-number">3</span>);
  <span class="hljs-keyword">try</span> {
    ... 
</code></pre>
    <p class="normal"><em class="italic">Second stop</em>: Here, we have three <code class="inlineCode">get()</code> calls. So the current thread waits for other threads to complete. Can we easily observe those threads?</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-type">String</span> <span class="hljs-variable">tester1</span> <span class="hljs-operator">=</span> future1.get();
    <span class="hljs-type">String</span> <span class="hljs-variable">tester2</span> <span class="hljs-operator">=</span> future2.get();
    <span class="hljs-type">String</span> <span class="hljs-variable">tester3</span> <span class="hljs-operator">=</span> future3.get();
    logger.info(tester1);
    logger.info(tester2);
    logger.info(tester3);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">TestingTeam</span>(tester1, tester2, tester3);
  } <span class="hljs-keyword">catch</span> (ExecutionException ex) {
    ...
</code></pre>
    <p class="normal"><em class="italic">Third stop: </em>If an <code class="inlineCode">ExecutionException</code> is caught, then we know that one of these three <code class="inlineCode">Future</code> instances<a id="_idIndexMarker1139"/> has failed. Can we easily cancel the remaining two, or will they just hang on there? <code class="inlineCode">future1</code> will probably fail while <code class="inlineCode">future2</code> and <code class="inlineCode">future3</code> will complete successfully, or maybe <code class="inlineCode">future2</code> will complete successfully while <code class="inlineCode">future3</code> will just run forever (a so-called <em class="italic">orphan</em> thread). This can lead to serious mismatches in the expected results, memory leaks, and so on:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">RuntimeException</span>(ex);
  } <span class="hljs-keyword">finally</span> {
    ...
</code></pre>
    <p class="normal"><em class="italic">Fourth stop</em>: The next line of code is used to shut down the <code class="inlineCode">executor</code>, but it is so easy to overlook. Is this the proper place to do this?</p>
    <pre class="programlisting code"><code class="hljs-code">    shutdownExecutor(executor);
  }
}
</code></pre>
    <p class="normal"><em class="italic">Fifth stop</em>: If you didn’t spot the previous line of code, then it is legitimate to ask yourself how/where this executor got shut down:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Future&lt;String&gt; <span class="hljs-title">futureTester</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> id)</span> {
  <span class="hljs-keyword">return</span> executor.submit(() -&gt; fetchTester(id));
}
</code></pre>
    <p class="normal">We skip the rest of the code, since you can find it in the bundled code.</p>
    <p class="normal">Of course, we can implement code answers to each of these questions via error handling, task abandons and abortions, <code class="inlineCode">ExecutorService</code>, and so on, but this means a lot of work for the developer. Writing failsafe solutions that carefully cover all possible scenarios across multiple tasks/subtasks while tracking their progress in a concurrent environment is not an easy job. That’s not to mention how hard it is to understand and maintain the resulting code by another developer, or even the same developer after 1–2 years or even months.</p>
    <p class="normal">It is time to add some structure to this code, so let’s introduce <em class="italic">structured concurrency</em> (or Project Loom).</p>
    <p class="normal"><em class="italic">Structured concurrency</em> relies on several pillars meant to bring lightweight concurrency to Java. The fundamental pillar or principle of structured concurrency is highlighted next.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">The fundamental principle of structured concurrency is that when a task has to be solved concurrently, then all the threads needed to solve it are spun and rejoined in the same block of code. In other words, all these threads’ lifetimes are bound to the block’s lexical scope, so we have clear and explicit entry-exit points for each concurrent code block.</p>
    </div>
    <p class="normal">Based on this principle, the thread that initiates a concurrent context is the <em class="italic">parent-thread</em> or the <em class="italic">owner-thread</em>. All threads started by the parent-thread are <em class="italic">children-threads</em> or <em class="italic">forks</em>, so between them, these threads are siblings. Together, the parent-thread and the child-threads define a <em class="italic">parent-child hierarchy</em>.</p>
    <p class="normal">Putting the<a id="_idIndexMarker1140"/> structured concurrency principle into a diagram will show us the following:</p>
    <figure class="mediaobject"><img src="../Images/B19665_10_02.png" alt="Figure 10.2.png"/></figure>
    <p class="packt_figref">Figure 10.2: Parent-child hierarchy in structured concurrency</p>
    <p class="normal">In the context of the parent-child hierarchy, we have support for error/exception handling with short-circuiting, cancellation propagation, and monitoring/observability:</p>
    <ul>
      <li class="bulletList"><em class="italic">Error/exception handling with short-circuiting</em>: If a child-thread fails, then all child-threads are canceled unless they are complete. For instance, if <code class="inlineCode">futureTester(1)</code> fails, then <code class="inlineCode">futureTester(2)</code> and <code class="inlineCode">futureTester(3)</code> are automatically canceled.</li>
      <li class="bulletList"><em class="italic">Cancellation propagation</em>: If the parent-thread is interrupted until joining the child-threads is over, then these forks (the child-threads/subtasks) are canceled automatically. For instance, if the thread executing <code class="inlineCode">buildTestingTeam()</code> gets interrupted, then its three forks are automatically canceled.</li>
      <li class="bulletList"><em class="italic">Monitoring/observability</em>: A thread dump reveals a crystal-clear image of the entire parent-child hierarchy, no matter how many levels have been spawned. Moreover, in structured concurrency, we take advantage of scheduling and the memory management of threads.</li>
    </ul>
    <p class="normal">While these are purely concepts, writing code that respects and follows these concepts requires the proper API and the following awesome callout:</p>
    <figure class="mediaobject"><img src="../Images/B19665_10_03.png" alt="Figure 10.3.png"/></figure>
    <p class="packt_figref">Figure 10.3: Don’t reuse virtual threads</p>
    <p class="normal">Cut this out <a id="_idIndexMarker1141"/>and stick it somewhere so that you see it every day! So in structured concurrency, <strong class="keyWord">don’t reuse virtual threads</strong>. I know what you are thinking: <em class="italic">hey dude, threads are expensive and limited, so we have to reuse them</em>. A quick hint: we are talking about <em class="italic">virtual threads</em> (massive throughput), not <em class="italic">classical threads</em>, but the virtual threads topic is covered in the next problem.</p>
    <h1 id="_idParaDest-450" class="heading-1">211. Introducing virtual threads</h1>
    <p class="normal">Java allows <a id="_idIndexMarker1142"/>us to write multithreaded applications via the <code class="inlineCode">java.lang.Thread</code> class. These are classical Java threads that are basically just thin wrappers of OS (kernel) threads. As you’ll see, these classical Java threads are referred to as <em class="italic">platform threads</em>, and they have been available for quite a long time (since JDK 1.1, as the following diagram reveals):</p>
    <figure class="mediaobject"><img src="../Images/B19665_10_04.png" alt="Figure 10.4.png"/></figure>
    <p class="packt_figref">Figure 10.4: JDK multithreading evolution</p>
    <p class="normal">Next, let’s move on to JDK 19 virtual threads.</p>
    <h2 id="_idParaDest-451" class="heading-2">What’s the problem with platform (OS) threads?</h2>
    <p class="normal">OS threads <a id="_idIndexMarker1143"/>are expensive in every single way, or more specifically, they are costly in terms of time and space. Creating OS threads is, therefore, a costly operation that requires a lot of stack space (around 20 megabytes) to store their context, Java call stacks, and additional resources. Moreover, the OS thread scheduler is responsible for scheduling Java threads, which is another costly operation that requires moving around a significant amount of data. This is referred to as <em class="italic">thread context switching.</em></p>
    <p class="normal">In the following figure, you can see the one-to-one relationship between a Java thread and an OS thread:</p>
    <figure class="mediaobject"><img src="../Images/B19665_10_05.png" alt="Figure 10.4.png"/></figure>
    <p class="packt_figref">Figure 10.5: JVM to OS threads</p>
    <p class="normal">For decades, our multithreaded applications have run in this context. All this time and experience taught us that we can create a limited number of Java threads (because of low throughput) and that we should reuse them wisely. The number of Java threads is a limiting factor that is usually exhausted before other resources, such as network connections, CPU, and so on. Java doesn’t differentiate between threads that perform intensive computational tasks (i.e., threads that really exploit the CPU) or those that just wait for data (i.e., they just hang on the CPU).</p>
    <p class="normal">Let’s do a quick exercise. Let’s assume that our machine has 8 GB of memory, and a single Java thread needs 20 MB. This means that we have room for around 400 Java threads (8 GB = 8,000 MB / 20 MB = 400 threads). Next, let’s assume that these threads perform I/O operations over a network. Each I/O operation needs around 100 ms to complete, while the request preparation and response processing needs around 500 ns. So a thread works for 1,000 ns (0.001 ms) and then waits for 100 ms (100,000,000 ns) for the I/O operation to complete. This means that at 8 GB of memory, the 400 threads will use 0.4% of CPU availability (under 1%), which is very low. We can conclude that a thread is idle for 99.99% of the time.</p>
    <p class="normal">Based on this exercise, it is quite obvious that Java threads become a bottleneck in throughput that doesn’t allow us to solicit hardware at full capacity. Of course, we can sweeten the situation a little bit by using <em class="italic">thread pools </em>to minimize the costs, but it still does not solve the major issues of dealing with resources. You have to go for <code class="inlineCode">CompletableFuture</code>, reactive programming (for instance, Spring <code class="inlineCode">Mono</code> and <code class="inlineCode">Flux</code>), and so on.</p>
    <p class="normal">However, how<a id="_idIndexMarker1144"/> many classical Java threads can we create? We can easily find out by running a simple snippet of code, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">AtomicLong</span> <span class="hljs-variable">counterOSThreads</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">AtomicLong</span>();
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">new</span> <span class="hljs-title">Thread</span>(() -&gt; {
    <span class="hljs-type">long</span> <span class="hljs-variable">currentOSThreadNr</span>
      <span class="hljs-operator">=</span> counterOSThreads.incrementAndGet();
    System.out.println(<span class="hljs-string">"</span><span class="hljs-string">Thread: "</span> + currentOSThreadNr);
    LockSupport.park();
  }).start();
}
</code></pre>
    <p class="normal">Alternatively, if we want to taste from the new concurrent API, we can call the new <code class="inlineCode">Thread.ofPlatform()</code> method, as follows (<code class="inlineCode">OfPlatform</code> is a <code class="inlineCode">sealed</code> interface, introduced in JDK 19):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">AtomicLong</span> <span class="hljs-variable">counterOSThreads</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">AtomicLong</span>();
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
  Thread.ofPlatform().start(() -&gt; {
    <span class="hljs-type">long</span> <span class="hljs-variable">currentOSThreadNr</span>
      <span class="hljs-operator">=</span> counterOSThreads.incrementAndGet();
    System.out.println(<span class="hljs-string">"Thread: "</span> + currentOSThreadNr);
    LockSupport.park();
  });
}
</code></pre>
    <p class="normal">On my machine, I got an <code class="inlineCode">OutOfMemoryError</code> after around 40,000 Java threads. Depending on your OS and hardware, this number may vary.</p>
    <p class="normal">The <code class="inlineCode">Thread.ofPlatform()</code> method was added in JDK 19 to easily distinguish between Java threads (i.e., classical Java threads as we have known them for decades – thin wrappers of OS threads) and the new kids in town, virtual threads.</p>
    <h2 id="_idParaDest-452" class="heading-2">What are virtual threads?</h2>
    <p class="normal">Virtual threads<a id="_idIndexMarker1145"/> were introduced in JDK 19 as a preview (JEP 425), and they became a final feature in JDK 21 (JEP 444). Virtual threads run on top of platform threads in a one-to-many relationship, while the platform threads run on top of OS threads in a one-to-one relationship, as shown in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_10_06.png" alt="Figure 10.5.png"/></figure>
    <p class="packt_figref">Figure 10.6: Virtual threads architecture</p>
    <p class="normal">If we break <a id="_idIndexMarker1146"/>this figure down into a few words, then we can say that JDK maps a large number of virtual threads to a small number of OS threads.</p>
    <p class="normal">Before creating a virtual thread, let’s see two important notes that will help us to quickly understand the fundamentals of virtual threads. First, let’s have a quick note about a virtual thread’s memory footprint:</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">Virtual threads are not wrappers of OS threads. They are lightweight Java entities (they have their own stack memory with a small footprint – only a few hundred bytes) that are cheap to create, block, and destroy (creating a virtual thread is around 1,000 times cheaper than creating a classical Java thread). There can be many of them at the same time (millions) so that they sustain a massive throughput. Virtual threads should not be reused (they are disposable) or pooled.</p>
    </div>
    <p class="normal">When we talk about virtual threads, there are more things that we should unlearn than things that we should learn. But where are virtual threads stored, and who’s responsible for scheduling them accordingly?</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">Virtual threads are stored in the JVM heap (so they take advantage of Garbage Collector) instead of the OS stack. Moreover, virtual threads are scheduled by the JVM via a <em class="italic">work-stealing</em> <code class="inlineCode">ForkJoinPool</code> scheduler. Practically, JVM schedules and orchestrates virtual threads to run on platform threads in such a way that a platform thread executes only one virtual thread at a time.</p>
    </div>
    <p class="normal">Next, let’s create a virtual thread.</p>
    <h3 id="_idParaDest-453" class="heading-3">Creating a virtual thread</h3>
    <p class="normal">From the <a id="_idIndexMarker1147"/>API perspective, a virtual thread is another flavor of <code class="inlineCode">java.lang.Thread</code>. If we dig a little bit via <code class="inlineCode">getClass()</code>, we can see that a virtual thread class is <code class="inlineCode">java.lang.VirtualThread</code>, which is a <code class="inlineCode">final</code> non-public class that extends the <code class="inlineCode">BaseVirtualThread</code> class, which, in turn, is a <code class="inlineCode">sealed abstract</code> class that extends <code class="inlineCode">java.lang.Thread</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VirtualThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseVirtualThread</span> {…}
<span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BaseVirtualThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span>
  permits VirtualThread, ThreadBuilders.BoundVirtualThread {…}
</code></pre>
    <p class="normal">Let’s consider that we have the following task (<code class="inlineCode">Runnable</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; logger.info(
  Thread.currentThread().toString());
</code></pre>
    <h4 class="heading-4">Creating and starting a virtual thread</h4>
    <p class="normal">We can <a id="_idIndexMarker1148"/>create and start a virtual thread for our task via the <code class="inlineCode">startVirtualThread(Runnable task)</code> method, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Thread</span> <span class="hljs-variable">vThread</span> <span class="hljs-operator">=</span> Thread.startVirtualThread(task);
<span class="hljs-comment">// next you can set its name</span>
vThread.setName(<span class="hljs-string">"my_vThread"</span>);
</code></pre>
    <p class="normal">The returned <code class="inlineCode">vThread</code> is scheduled for execution by the JVM itself. But we can also create and start a virtual thread via <code class="inlineCode">Thread.ofVirtual()</code>, which returns <code class="inlineCode">OfVirtual</code> (the <code class="inlineCode">sealed</code> interface introduced in JDK 19), as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Thread</span> <span class="hljs-variable">vThread</span> <span class="hljs-operator">=</span>Thread.ofVirtual().start(task); 
<span class="hljs-comment">// a named virtual thread</span>
Thread.ofVirtual().name(<span class="hljs-string">"my_vThread"</span>).start(task);
</code></pre>
    <p class="normal">Now, <code class="inlineCode">vThread</code> will solve our <code class="inlineCode">task</code>.</p>
    <p class="normal">Moreover, we have the <code class="inlineCode">Thread.Builder</code> interface (and <code class="inlineCode">Thread.Builder.OfVirtual</code> subinterface) that can be used to create a virtual thread, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Thread.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> 
  <span class="hljs-operator">=</span> Thread.ofVirtual().name(<span class="hljs-string">"my_vThread"</span>);
<span class="hljs-type">Thread</span> <span class="hljs-variable">vThread</span> <span class="hljs-operator">=</span> builder.start(task);
</code></pre>
    <p class="normal">Here is anothe<a id="_idIndexMarker1149"/>r example of creating two virtual threads via <code class="inlineCode">Thread.Builder</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">Thread.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span>
  <span class="hljs-operator">=</span> Thread.ofVirtual().name(<span class="hljs-string">"vThread-"</span>, <span class="hljs-number">1</span>);
<span class="hljs-comment">// name "vThread-1"</span>
<span class="hljs-type">Thread</span> <span class="hljs-variable">vThread1</span> <span class="hljs-operator">=</span> builder.start(task);
vThread1.join();
logger.info(() -&gt; vThread1.getName() + <span class="hljs-string">" terminated"</span>);
<span class="hljs-comment">// name "vThread-2"</span>
<span class="hljs-type">Thread</span> <span class="hljs-variable">vThread2</span> <span class="hljs-operator">=</span> builder.start(task);
vThread2.join();
logger.info(() -&gt; vThread2.getName() + <span class="hljs-string">" terminated"</span>);
</code></pre>
    <p class="normal">You can check out these examples further in the bundled code.</p>
    <h4 class="heading-4">Waiting for a virtual task to terminate</h4>
    <p class="normal">The<a id="_idIndexMarker1150"/> given <code class="inlineCode">task</code> is executed by a virtual thread, while the main thread is not blocked. In order to wait for the virtual thread to terminate, we have to call one of the <code class="inlineCode">join()</code> flavors. We have <code class="inlineCode">join()</code> without arguments that waits indefinitely, and a few flavors that wait for a given time (for instance, <code class="inlineCode">join(Duration duration)</code> and <code class="inlineCode">join(long millis)</code>):</p>
    <pre class="programlisting code"><code class="hljs-code">vThread.join();
</code></pre>
    <p class="normal">These methods throw an <code class="inlineCode">InterruptedException</code>, so you have to catch it and handle it (or just throw it). Now, because of <code class="inlineCode">join()</code>, the main thread cannot terminate before the virtual thread. It has to wait until the virtual thread completes.</p>
    <h4 class="heading-4">Creating an unstarted virtual thread</h4>
    <p class="normal">Creating <a id="_idIndexMarker1151"/>an unstarted virtual thread can be done via <code class="inlineCode">unstarted(Runnable task)</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Thread</span> <span class="hljs-variable">vThread</span> <span class="hljs-operator">=</span> Thread.ofVirtual().unstarted(task);
</code></pre>
    <p class="normal">Or via <code class="inlineCode">Thread.Builder</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Thread.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> Thread.ofVirtual();
<span class="hljs-type">Thread</span> <span class="hljs-variable">vThread</span> <span class="hljs-operator">=</span> builder.unstarted(task);
</code></pre>
    <p class="normal">This time, the thread is not scheduled for execution. It will be scheduled for execution only after we explicitly call the <code class="inlineCode">start()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">vThread.start();
</code></pre>
    <p class="normal">We can <a id="_idIndexMarker1152"/>check if a thread is alive (i.e., it was started but not terminated) via the <code class="inlineCode">isAlive()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">boolean</span> <span class="hljs-variable">isalive</span> <span class="hljs-operator">=</span> vThread.isAlive();
</code></pre>
    <p class="normal">The <code class="inlineCode">unstarted()</code> method is available for platform threads as well (there is also the <code class="inlineCode">Thread.Builder.OfPlatform</code> subinterface):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Thread</span> <span class="hljs-variable">pThread</span> <span class="hljs-operator">=</span> Thread.ofPlatform().unstarted(task);
</code></pre>
    <p class="normal">We can start <code class="inlineCode">pThread</code> by calling the <code class="inlineCode">start()</code> method.</p>
    <h4 class="heading-4">Creating a ThreadFactory for virtual threads</h4>
    <p class="normal">You can <a id="_idIndexMarker1153"/>create a <code class="inlineCode">ThreadFactory</code> of virtual threads, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">tfVirtual</span> <span class="hljs-operator">=</span> Thread.ofVirtual().factory();
<span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">tfVirtual</span> = Thread.ofVirtual()
  .name(<span class="hljs-string">"vt-"</span>, <span class="hljs-number">0</span>).factory(); <span class="hljs-comment">// 'vt-' name prefix, 0 counter</span>
</code></pre>
    <p class="normal">Or, via <code class="inlineCode">Thread.Builder</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Thread.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> Thread.ofVirtual().name(<span class="hljs-string">"vt-"</span>, <span class="hljs-number">0</span>);
<span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">tfVirtual</span> <span class="hljs-operator">=</span> builder.factory();
</code></pre>
    <p class="normal">And a <code class="inlineCode">ThreadFactory</code> for platform threads, as follows (you can use <code class="inlineCode">Thread.Builder</code> as well):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">tfPlatform</span> <span class="hljs-operator">=</span> Thread.ofPlatform()
  .name(<span class="hljs-string">"pt-"</span>, <span class="hljs-number">0</span>).factory(); <span class="hljs-comment">// 'pt-' name prefix, 0 counter</span>
</code></pre>
    <p class="normal">Or a <code class="inlineCode">ThreadFactory</code> that we can use to switch between virtual/platform threads, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SimpleThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ThreadFactory</span> {
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> {
    <span class="hljs-comment">// return new Thread(r);                // platform thread</span>
    <span class="hljs-keyword">return</span> Thread.ofVirtual().unstarted(r); <span class="hljs-comment">// virtual thread</span>
  }
}
</code></pre>
    <p class="normal">Next, we can use any of these factories via the <code class="inlineCode">ThreadFactory.newThread(Runnable task)</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">tfVirtual.newThread(task).start();
tfPlatform.newThread(task).start();
<span class="hljs-type">SimpleThreadFactory</span> <span class="hljs-variable">stf</span> = <span class="hljs-keyword">new</span> <span class="hljs-title">SimpleThreadFactory</span>();
stf.newThread(task).start();
</code></pre>
    <p class="normal">If the thread factory<a id="_idIndexMarker1154"/> starts the created thread as well, then there is no need to explicitly call the <code class="inlineCode">start()</code> method.</p>
    <h4 class="heading-4">Checking a virtual thread’s details</h4>
    <p class="normal">Moreover, we can<a id="_idIndexMarker1155"/> check if a certain thread is a platform thread or a virtual thread via <code class="inlineCode">isVirtual()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Thread</span> <span class="hljs-variable">vThread</span> <span class="hljs-operator">=</span> Thread.ofVirtual()
  .name(<span class="hljs-string">"my_vThread"</span>).unstarted(task);
<span class="hljs-type">Thread</span> <span class="hljs-variable">pThread1</span> <span class="hljs-operator">=</span> Thread.ofPlatform()
  .name(<span class="hljs-string">"my_pThread"</span>).unstarted(task);
<span class="hljs-type">Thread</span> <span class="hljs-variable">pThread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Thread</span>(() -&gt; {});
logger.info(() -&gt; <span class="hljs-string">"Is vThread virtual ? "</span> 
  + vThread.isVirtual());  <span class="hljs-comment">// true</span>
logger.info(() -&gt; <span class="hljs-string">"Is pThread1 virtual ? "</span> 
  + pThread1.isVirtual()); <span class="hljs-comment">// false</span>
logger.info(() -&gt; <span class="hljs-string">"Is pThread2 virtual ? "</span> 
  + pThread2.isVirtual()); <span class="hljs-comment">// false</span>
</code></pre>
    <p class="normal">Obviously, only <code class="inlineCode">vThread</code> is a virtual thread.</p>
    <p class="normal"><em class="italic">A virtual thread always runs as a daemon thread.</em> The <code class="inlineCode">isDaemon()</code> method returns <code class="inlineCode">true</code>, and trying to call <code class="inlineCode">setDaemon(false)</code> will throw an exception.</p>
    <p class="normal"><em class="italic">The priority of a virtual thread is always </em><code class="inlineCode">NORM_PRIORITY</code> (calling <code class="inlineCode">getPriority() </code>always returns <code class="inlineCode">5</code> – constant <code class="inlineCode">int</code> for <code class="inlineCode">NORM_PRIORITY</code>). Calling <code class="inlineCode">setPriority()</code> with a different value has no effect.</p>
    <p class="normal"><em class="italic">A virtual thread cannot be part of a thread group</em> because it already belongs to the <em class="italic">VirtualThreads</em> group. Calling <code class="inlineCode">getThreadGroup().getName()</code> returns <em class="italic">VirtualThreads</em>.</p>
    <p class="normal">A virtual thread has no permission with Security Manager (which is deprecated anyway).</p>
    <h4 class="heading-4">Printing a thread (toString())</h4>
    <p class="normal">If we print<a id="_idIndexMarker1156"/> a virtual thread (calling the <code class="inlineCode">toString()</code> method), then the output will be something like the following:</p>
    <pre class="programlisting con"><code class="hljs-con">VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1
VirtualThread[#26,vt-0]/runnable@ForkJoinPool-1-worker-1
</code></pre>
    <p class="normal">In a <a id="_idIndexMarker1157"/>nutshell, this output can be interpreted as follows: <code class="inlineCode">VirtualThread[#22]</code> indicates that this is a virtual thread that contains the thread identifier (<code class="inlineCode">#22</code>) with no name (in the case of <code class="inlineCode">VirtualThread[#26,vt-0]</code>, the id is <code class="inlineCode">#26</code> and the name is <code class="inlineCode">vt-0</code>). Then, we have the <code class="inlineCode">runnable</code> text, which indicates the state of the virtual thread (<code class="inlineCode">runnable</code> means that the virtual thread is running). Next, we have the <em class="italic">carrier thread </em>of the virtual thread, which is a platform thread; <code class="inlineCode">ForkJoinPool-1-worker-1</code> contains the platform thread name (<code class="inlineCode">worker-1</code>) of the default <code class="inlineCode">ForkJoinPool</code> (<code class="inlineCode">ForkJoinPool-1</code>).</p>
    <h3 id="_idParaDest-454" class="heading-3">How many virtual threads we can start</h3>
    <p class="normal">Finally, let’s run <a id="_idIndexMarker1158"/>code that allows us to see how many virtual threads we can create and start:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">AtomicLong</span> <span class="hljs-variable">counterOSThreads</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">AtomicLong</span>();
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
  Thread.startVirtualThread(() -&gt; {
    <span class="hljs-type">long</span> <span class="hljs-variable">currentOSThreadNr</span>
      <span class="hljs-operator">=</span> counterOSThreads.incrementAndGet();
    System.out.println(<span class="hljs-string">"Virtual thread: "</span> 
      + currentOSThreadNr);
    LockSupport.park();
  });
}
</code></pre>
    <p class="normal">On my machine, this code started to slow down after around 14,000,000 virtual threads. It continues to run slowly while memory becomes available (Garbage Collector is in action), but it didn’t crash. So a massive throughput!</p>
    <h3 id="_idParaDest-455" class="heading-3">Backward compatibility</h3>
    <p class="normal">Virtual threads<a id="_idIndexMarker1159"/> are compatible with:</p>
    <ul>
      <li class="bulletList">Synchronized blocks</li>
      <li class="bulletList">Thread-local variables</li>
      <li class="bulletList"><code class="inlineCode">Thread</code> and <code class="inlineCode">currentThread()</code></li>
      <li class="bulletList">Thread interruption (<code class="inlineCode">InterruptedException</code>)</li>
    </ul>
    <p class="normal">Basically, virtual threads work out of the box once you update to at least JDK 19. They heavily sustain a clean, readable, and more structured code, being the bricks behind the structured <a id="_idIndexMarker1160"/>concurrency paradigm.</p>
    <h3 id="_idParaDest-456" class="heading-3">Avoiding fake conclusions (potentially myths)</h3>
    <p class="normal">There are a few fake conclusions about virtual threads that we should consider as follow:</p>
    <ul>
      <li class="bulletList"><em class="italic">Virtual threads are faster than platform threads (WRONG!)</em>: There can be a lot of virtual<a id="_idIndexMarker1161"/> threads, but they are not faster than classical (platform) threads. They don’t boost in-memory computational capabilities (for that, we have parallel streams). Don’t conclude that virtual threads do some magic that makes them faster or more optimal to solve a task. So virtual threads can seriously improve throughput (since millions of them can wait for jobs), but they cannot improve latency. However, virtual threads can be launched much faster than platform threads (a virtual thread has a creation time measured in µs and needs space in the order of kB).</li>
      <li class="bulletList"><em class="italic">Virtual threads should be pooled (WRONG!)</em>: Virtual threads should not be part of any thread pool and should never be pooled.</li>
      <li class="bulletList"><em class="italic">Virtual threads are expensive (WRONG!)</em>: Virtual threads are not for free (nothing is for free), but they are cheaper to create, block, and destroy than platform threads. A virtual thread is 1,000x cheaper than a platform thread.</li>
      <li class="bulletList"><em class="italic">Virtual threads can release a task (WRONG!)</em>: This is not true! A virtual thread takes a task and will return a result unless it gets interrupted. It cannot release the task.</li>
      <li class="bulletList"><em class="italic">Blocking a virtual thread blocks its carrier thread (WRONG!)</em>: Blocking a virtual thread doesn’t block its carrier thread. The carrier thread can serve other virtual threads.</li>
    </ul>
    <h1 id="_idParaDest-457" class="heading-1">212. Using the ExecutorService for virtual threads</h1>
    <p class="normal">Virtual threads <a id="_idIndexMarker1162"/>allow us to write more expressive and straightforward concurrent code. Thanks to the massive throughput obtained via virtual threads, we can easily adopt the <em class="italic">task-per-thread</em> model (for an HTTP server, this<a id="_idIndexMarker1163"/> means a request per thread, for a database, this means a transaction per thread, and so on). In other words, we can assign a new virtual thread for each concurrent task. </p>
    <p class="normal">Trying to use the <em class="italic">task-per-thread</em> model with platform threads will result in a throughput limited by the number of hardware cores – this is explained by Little’s law (<a href="https://en.wikipedia.org/wiki/Little%27s_law"><span class="url">https://en.wikipedia.org/wiki/Little%27s_law</span></a>), L = λW, or throughput equals average concurrency multiplied by latency.</p>
    <p class="normal">Whenever possible, it is recommended to avoid interacting with threads directly. JDK sustains this via the <code class="inlineCode">ExecutorService</code>/<code class="inlineCode">Executor</code> API. More precisely, we are used to submitting a task (<code class="inlineCode">Runnable</code>/<code class="inlineCode">Callable</code>) to an <code class="inlineCode">ExecutorService</code>/<code class="inlineCode">Executor</code> and working with the returned <code class="inlineCode">Future</code>. This pattern is valid for virtual threads as well.</p>
    <p class="normal">So we don’t<a id="_idIndexMarker1164"/> have to write ourselves all the plumbing code to adopt the <em class="italic">task-per-thread model </em>for virtual threads because, starting with JDK 19, this model is available via the <code class="inlineCode">Executors</code> class. More precisely, it’s via the <code class="inlineCode">newVirtualThreadPerTaskExecutor()</code> method, which creates an <code class="inlineCode">ExecutorService</code> capable of creating <a id="_idIndexMarker1165"/>an unbounded number of virtual threads that follow the <em class="italic">task-per-thread</em> model. This <code class="inlineCode">ExecutorService</code> exposes methods that allow us to give tasks such as the <code class="inlineCode">submit()</code> (as you’ll see next) and <code class="inlineCode">invokeAll</code>/<code class="inlineCode">Any()</code> (as you’ll see later) methods, returning a <code class="inlineCode">Future</code> containing an exception or a result.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">Starting with JDK 19, the <code class="inlineCode">ExecutorService</code> extends the <code class="inlineCode">AutoCloseable</code> interface. In other words, we can use <code class="inlineCode">ExecutorService</code> in a <code class="inlineCode">try-with-resources</code> pattern. </p>
    </div>
    <p class="normal">Consider the following simple <code class="inlineCode">Runnable</code> and <code class="inlineCode">Callable</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Runnable</span> <span class="hljs-variable">taskr</span> <span class="hljs-operator">=</span> () -&gt;logger.info(
  Thread.currentThread().toString());
Callable&lt;Boolean&gt; taskc = () -&gt; {
  logger.info(Thread.currentThread().toString());
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
};
</code></pre>
    <p class="normal">Executing the <code class="inlineCode">Runnable</code>/<code class="inlineCode">Callable</code> can be done as follows (here, we submit 15 tasks (<code class="inlineCode">NUMBER_OF_TASKS = 15</code>)):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> 
      <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) {
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; NUMBER_OF_TASKS; i++) {
    executor.submit(taskr); <span class="hljs-comment">// executing Runnable</span>
    executor.submit(taskc); <span class="hljs-comment">// executing Callable</span>
  }
}
</code></pre>
    <p class="normal">Of course, in the case of <code class="inlineCode">Runnable</code>/<code class="inlineCode">Callable</code>, we can capture a <code class="inlineCode">Future</code> and act accordingly, via the blocking <code class="inlineCode">get()</code> method or whatever we want to do:</p>
    <pre class="programlisting code"><code class="hljs-code">Future&lt;?&gt; future = executor.submit(taskr);
Future&lt;Boolean&gt; future = executor.submit(taskc);
</code></pre>
    <p class="normal">A possible output looks as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">VirtualThread[#28]/runnable@ForkJoinPool-1-worker-6 
VirtualThread[#31]/runnable@ForkJoinPool-1-worker-5 
VirtualThread[#29]/runnable@ForkJoinPool-1-worker-7 
VirtualThread[#25]/runnable@ForkJoinPool-1-worker-3 
VirtualThread[#24]/runnable@ForkJoinPool-1-worker-2 
VirtualThread[#27]/runnable@ForkJoinPool-1-worker-5 
VirtualThread[#26]/runnable@ForkJoinPool-1-worker-4 
VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 
VirtualThread[#36]/runnable@ForkJoinPool-1-worker-1 
VirtualThread[#37]/runnable@ForkJoinPool-1-worker-2 
VirtualThread[#35]/runnable@ForkJoinPool-1-worker-7 
VirtualThread[#34]/runnable@ForkJoinPool-1-worker-4 
VirtualThread[#32]/runnable@ForkJoinPool-1-worker-3 
VirtualThread[#33]/runnable@ForkJoinPool-1-worker-2 
VirtualThread[#30]/runnable@ForkJoinPool-1-worker-1
</code></pre>
    <p class="normal">Check <a id="_idIndexMarker1166"/>out <a id="_idIndexMarker1167"/>the virtual threads’ IDs. They range between #22 and #37 without repetition. Each task is executed by its own virtual thread.</p>
    <p class="normal">The <em class="italic">task-per-thread</em> model is also available for classical threads via <code class="inlineCode">newThreadPerTaskExecutor(ThreadFactory threadFactory)</code>. Here is an example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SimpleThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ThreadFactory</span> {
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Thread</span>(r);   <span class="hljs-comment">// classic</span>
   <span class="hljs-comment">// return Thread.ofVirtual().unstarted(r); // virtual </span>
  }
}
<span class="hljs-keyword">try</span> (<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> 
     Executors.newThreadPerTaskExecutor(
         <span class="hljs-keyword">new</span> <span class="hljs-title">SimpleThreadFactory</span>())) {
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; NUMBER_OF_TASKS; i++) {
    executor.submit(taskr); <span class="hljs-comment">// executing Runnable</span>
    executor.submit(taskc); <span class="hljs-comment">// executing Callable</span>
  }
}
</code></pre>
    <p class="normal">As you can see, <code class="inlineCode">newThreadPerTaskExecutor()</code> can be used for classic or virtual threads. The number of created threads is unbounded. By simply modifying the thread factory, we can switch <a id="_idIndexMarker1168"/>between virtual/classic threads.</p>
    <p class="normal">A possible<a id="_idIndexMarker1169"/> output looks as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">Thread[#75,Thread-15,5,main] 
Thread[#77,Thread-17,5,main] 
Thread[#76,Thread-16,5,main] 
Thread[#83,Thread-23,5,main] 
Thread[#82,Thread-22,5,main] 
Thread[#80,Thread-20,5,main] 
Thread[#81,Thread-21,5,main] 
Thread[#79,Thread-19,5,main] 
Thread[#78,Thread-18,5,main] 
Thread[#89,Thread-29,5,main] 
Thread[#88,Thread-28,5,main] 
Thread[#87,Thread-27,5,main] 
Thread[#86,Thread-26,5,main] 
Thread[#85,Thread-25,5,main] 
Thread[#84,Thread-24,5,main]
</code></pre>
    <p class="normal">Check out the threads’ IDs. They range between #75 and #89 without repetition. Each task is executed by its own thread.</p>
    <h1 id="_idParaDest-458" class="heading-1">213. Explaining how virtual threads work</h1>
    <p class="normal">Now that <a id="_idIndexMarker1170"/>we know how to create and start a virtual thread, let’s see how they actually work.</p>
    <p class="normal">Let’s start with a meaningful diagram:</p>
    <figure class="mediaobject"><img src="../Images/B19665_10_07.png" alt="Figure 10.6.png"/></figure>
    <p class="packt_figref">Figure 10.7: How virtual threads work</p>
    <p class="normal">As you can see, <em class="italic">Figure 10.7</em> is similar to <em class="italic">Figure 10.6</em>, except that we have added a few more elements. </p>
    <p class="normal">First of all, notice <a id="_idIndexMarker1171"/>that the platform threads run under a <code class="inlineCode">ForkJoinPool</code> umbrella. This is a <strong class="keyWord">First-In-First-Out</strong> (<strong class="keyWord">FIFO</strong>) dedicated fork/join pool, dedicated to scheduling and orchestrating the relationships between virtual threads and platform threads (detailed coverage of Java’s fork/join framework is available in <em class="italic">Java Coding Problems</em>, <em class="italic">First Edition</em>, <em class="italic">Chapter 11</em>).</p>
    <div class="note">
      <p class="normal"> <strong class="keyWord">Important note</strong></p>
      <p class="normal">This dedicated <code class="inlineCode">ForkJoinPool</code> is controlled by the JVM, and it acts as the virtual thread scheduler based on a FIFO queue. Its initial capacity (i.e., the number of threads) is equal to the number of available cores, and it can be increased to 256. The default virtual thread scheduler is implemented in the <code class="inlineCode">java.lang.VirtualThread</code> class:</p>
      <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ForkJoinPool <span class="hljs-title">createDefaultScheduler</span><span class="hljs-params">()</span> {...}
</code></pre>
      <p class="normal">Do not confuse this <code class="inlineCode">ForkJoinPool</code> with the one used for parallel streams (the Common Fork Join Pool - <code class="inlineCode">ForkJoinPool.commonPool()</code>).</p>
    </div>
    <p class="normal">Between the virtual threads and the platform threads, there is a one-to-many association. Nevertheless, the JVM schedules virtual threads to run on platform threads in such a way that only one virtual thread runs on a platform thread at a time. When the JVM assigns a virtual thread to a platform thread, the so-called <em class="italic">stack chunk object</em> of the virtual thread is copied from the heap memory on the platform thread. </p>
    <p class="normal">If the code running on a virtual thread encounters a blocking (I/O) operation that should be handled by the JVM, then the virtual thread<a id="_idIndexMarker1172"/> is released by copying its <em class="italic">stack chunk object</em> back into the heap (this operation of copying the <em class="italic">stack chunk</em> between the heap memory and platform thread is the cost of blocking a virtual thread - this is much cheaper than blocking a platform thread). Meanwhile, the platform thread can run other virtual threads. When the blocking (I/O) of the released virtual thread is done, JVM reschedules the virtual thread for execution on a platform thread. This can be the same platform thread or another one.</p>
    <div class="note">
      <p class="normal"> <strong class="keyWord">Important note</strong></p>
      <p class="normal">The operation of assigning a virtual thread to a platform thread is called <em class="italic">mounting</em>. The operation of unassigning a virtual thread from the platform thread is called <em class="italic">unmounting</em>. The platform thread running the assigned virtual thread is called a <em class="italic">carrier thread</em>. </p>
    </div>
    <p class="normal">Let’s see an example that reveals how the virtual threads are mounted:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NUMBER_OF_TASKS</span> 
  <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors();
<span class="hljs-type">Runnable</span> <span class="hljs-variable">taskr</span> <span class="hljs-operator">=</span> () -&gt;
  logger.info(Thread.currentThread().toString()); 
<span class="hljs-keyword">try</span> (<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> 
    <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) {
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; NUMBER_OF_TASKS + <span class="hljs-number">1</span>; i++) {
    executor.submit(taskr);
  }
}
</code></pre>
    <p class="normal">In this snippet of code, we create a number of virtual threads equal to the number of available cores + 1. On my machine, I have 8 cores (so 8 <em class="italic">carriers</em>), and each of them carries a virtual thread. Since we have + 1, a <em class="italic">carrier</em> will work twice. The output reveals this scenario (check out the workers; here, <code class="inlineCode">worker-8</code> runs virtual threads <code class="inlineCode">#30</code> and <code class="inlineCode">#31</code>):</p>
    <pre class="programlisting con"><code class="hljs-con">VirtualThread[#25]/runnable@ForkJoinPool-1-worker-3 
<span class="code-highlight"><strong class="hljs-con-slc">VirtualThread[#30]/runnable@ForkJoinPool-1-worker-8 </strong></span>
VirtualThread[#28]/runnable@ForkJoinPool-1-worker-6 
VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 
VirtualThread[#24]/runnable@ForkJoinPool-1-worker-2 
VirtualThread[#29]/runnable@ForkJoinPool-1-worker-7 
VirtualThread[#26]/runnable@ForkJoinPool-1-worker-4 
VirtualThread[#27]/runnable@ForkJoinPool-1-worker-5 
<span class="code-highlight"><strong class="hljs-con-slc">VirtualThread[#31]/runnable@ForkJoinPool-1-worker-8</strong></span>
</code></pre>
    <p class="normal">However, we<a id="_idIndexMarker1173"/> can configure the <code class="inlineCode">ForkJoinPool</code> via three system properties, as follows:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">jdk.virtualThreadScheduler.parallelism</code> – the number of CPU cores</li>
      <li class="bulletList"><code class="inlineCode">jdk.virtualThreadScheduler.maxPoolSize</code> – the maximum pool size (256)</li>
      <li class="bulletList"><code class="inlineCode">jdk.virtualThreadScheduler.minRunnable</code> – the minimum number of running threads (half the pool size)</li>
    </ul>
    <p class="normal">In a subsequent problem, we will use these properties to better shape <em class="italic">virtual thread context switching</em> (mounting/unmounting) details.</p>
    <h2 id="_idParaDest-459" class="heading-2">Capturing virtual threads</h2>
    <p class="normal">So far, we have<a id="_idIndexMarker1174"/> learned that a virtual thread is mounted by the JVM to a platform thread, which becomes its carrier thread. Moreover, the carrier thread runs the virtual thread until it hits a blocking (I/O) operation. At that point, the virtual thread is unmounted from the carrier thread, and it will be rescheduled after the blocking (I/O) operation is done.</p>
    <p class="normal">While this scenario is true for most of the blocking operations, resulting in unmounting the virtual threads and freeing the platform thread (and the underlying OS thread), there are a few exceptional cases when the virtual threads are not unmounted. There are two main causes for this behavior:</p>
    <ul>
      <li class="bulletList">Limitations on the OS (for instance, a significant number of filesystem operations)</li>
      <li class="bulletList">Limitations on the JDK (for instance, <code class="inlineCode">Object.wait()</code>)</li>
    </ul>
    <p class="normal">When the virtual thread cannot be unmounted from its carrier thread, it means that the carrier thread and the underlying OS thread are blocked. This may affect the scalability of the application, so if the platform threads pool allows it, the JVM can decide to add one more platform thread. So for a period of time, the number of platform threads may exceed the number of available cores.</p>
    <h2 id="_idParaDest-460" class="heading-2">Pinning virtual threads</h2>
    <p class="normal">There<a id="_idIndexMarker1175"/> are also two other use cases when a virtual thread cannot be unmounted:</p>
    <ul>
      <li class="bulletList">When the virtual thread runs code inside a <code class="inlineCode">synchronized</code> method/block</li>
      <li class="bulletList">When the virtual thread invokes a foreign function or native method (a topic covered in <em class="italic">Chapter 7</em>)</li>
    </ul>
    <p class="normal">In this scenario, we say that the virtual thread is <em class="italic">pinned</em> to the carrier thread. This may affect the scalability of the application, but the JVM will not increase the number of platform<a id="_idIndexMarker1176"/> threads. Instead of this, we should take action and refactor the <code class="inlineCode">synchronized</code> blocks to ensure that the locking code is simple, clear, and short. Whenever possible, we should prefer <code class="inlineCode">java.util.concurrent</code> locks instead of <code class="inlineCode">synchronized</code> blocks. If we manage to avoid long and frequent locking periods, then we will not face any significant scalability issues. In future releases, the JDK team aims to eliminate the pinning inside <code class="inlineCode">synchronized</code> blocks.</p>
    <h1 id="_idParaDest-461" class="heading-1">214. Hooking virtual threads and sync code</h1>
    <p class="normal">The <a id="_idIndexMarker1177"/>goal of this problem is to highlight how virtual threads interact with synchronous code. For this, we use the built-in <code class="inlineCode">java.util.concurrent.SynchronousQueue</code>. This is a built-in blocking queue that allows only one thread to operate at a time. More precisely, a thread that wants to insert an element in this queue is blocked until another thread attempts to remove an element from it, and vice versa. Basically, a thread cannot insert an element unless another thread attempts to remove an element.</p>
    <p class="normal">Let’s assume that a virtual thread attempts to insert an element into a <code class="inlineCode">SynchronousQueue</code>, while a platform thread attempts to remove an element from this queue. In code lines, we have:</p>
    <pre class="programlisting code"><code class="hljs-code">SynchronousQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title">SynchronousQueue</span>&lt;&gt;();
<span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; {
  logger.info(() -&gt; Thread.currentThread().toString() 
    + <span class="hljs-string">" sleeps for 5 seconds"</span>);
  <span class="hljs-keyword">try</span> { Thread.sleep(Duration.ofSeconds(<span class="hljs-number">5</span>)); } 
    <span class="hljs-keyword">catch</span> (InterruptedException ex) {}
  logger.info(() -&gt; <span class="hljs-string">"Running "</span> 
    + Thread.currentThread().toString());
  <span class="code-highlight"><strong class="hljs-slc">queue.add(Integer.MAX_VALUE);</strong></span>
};
logger.info(<span class="hljs-string">"Before running the task ..."</span>);
<span class="hljs-type">Thread</span> <span class="hljs-variable">vThread</span> <span class="hljs-operator">=</span>Thread.ofVirtual().start(task);
logger.info(vThread.toString());
</code></pre>
    <p class="normal">So the virtual thread (<code class="inlineCode">vThread</code>) waits for 5 seconds before attempting to insert an element into the queue. However, it will not successfully insert an element until another thread attempts to remove an element from this queue:</p>
    <pre class="programlisting code"><code class="hljs-code">logger.info(() -&gt; Thread.currentThread().toString()
  + <span class="hljs-string">" can't take from the queue yet"</span>);
<span class="code-highlight"><strong class="hljs-type-slc">int</strong><strong class="hljs-slc"> </strong><strong class="hljs-variable-slc">max int</strong><strong class="hljs-slc"> </strong><strong class="hljs-operator-slc">=</strong><strong class="hljs-slc"> queue.take(); </strong></span>
logger.info(() -&gt; Thread.currentThread().toString() 
  + <span class="hljs-string">"took from queue: "</span> + maxint);
logger.info(vThread.toString());
logger.info(<span class="hljs-string">"After running the task ..."</span>);
</code></pre>
    <p class="normal">Here, the <code class="inlineCode">Thread.currentThread()</code> refers to the main thread of the application, which is a platform<a id="_idIndexMarker1178"/> thread not blocked by <code class="inlineCode">vThread</code>. This thread successfully removes from the queue only if another thread attempts to insert (here, <code class="inlineCode">vThread</code>):</p>
    <p class="normal">The output of this code looks as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">[09:41:59] Before running the task ... 
[09:42:00] VirtualThread[#22]/runnable 
[09:42:00] Thread[#1,main,5,main] 
           can't take from the queue yet
[09:42:00] VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1  
           sleeps for 5 seconds 
[09:42:05] VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 
           inserts in the queue
[09:42:05] Thread[#1,main,5,main]took from queue: 2147483647 
[09:42:05] VirtualThread[#22]/terminated 
[09:42:05] After running the task ...
</code></pre>
    <p class="normal">The virtual thread started its execution (it is in a <em class="italic">runnable</em> state), but the main thread cannot remove an element from the queue until the virtual thread inserts an element, so it is blocked by the <code class="inlineCode">queue.take()</code> operation:</p>
    <pre class="programlisting con"><code class="hljs-con">[09:42:00] VirtualThread[#22]/runnable 
[09:42:00] Thread[#1,main,5,main] 
           can't take from the queue yet
</code></pre>
    <p class="normal">Meanwhile, the virtual thread sleeps for 5 seconds (currently, the main thread has nothing to do), and afterward, it inserts an element:</p>
    <pre class="programlisting con"><code class="hljs-con">[09:42:00] VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1  
           sleeps for 5 seconds 
[09:42:05] VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 
           inserts in the queue
</code></pre>
    <p class="normal">The <a id="_idIndexMarker1179"/>virtual thread has inserted an element into the queue, so the main thread can remove this element from it:</p>
    <pre class="programlisting con"><code class="hljs-con">[09:42:05] Thread[#1,main,5,main]took from queue: 2147483647
</code></pre>
    <p class="normal">The virtual thread is also terminated:</p>
    <pre class="programlisting con"><code class="hljs-con">[09:42:05] VirtualThread[#22]/terminated
</code></pre>
    <p class="normal">So virtual threads, platform threads, and synchronous code work as expected. In the bundled code, you can find an example where the virtual and platform threads switch places. So the platform thread attempts to insert elements, and the virtual thread attempts to remove them.</p>
    <h1 id="_idParaDest-462" class="heading-1">215. Exemplifying thread context switching</h1>
    <p class="normal">Remember <a id="_idIndexMarker1180"/>that a virtual thread is mounted on a platform thread, and it is executed by that platform thread until a blocking operation occurs. At that point, the virtual thread is unmounted from the platform thread, and it will be rescheduled for execution by the JVM later on after the blocking operation is done. This means that, during its lifetime, a virtual thread can be mounted multiple times on a different or the same platform thread.</p>
    <p class="normal">In this problem, let’s write several snippets of code meant to capture and exemplify this behavior. </p>
    <h2 id="_idParaDest-463" class="heading-2">Example 1</h2>
    <p class="normal">In the first <a id="_idIndexMarker1181"/>example, let’s consider the following thread factory that we can use to easily switch between the platform and virtual threads:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SimpleThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ThreadFactory</span> {
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Thread</span>(r);                      <span class="hljs-comment">// classic thread</span>
  <span class="hljs-comment">// return Thread.ofVirtual().unstarted(r); // virtual thread</span>
  }
}
</code></pre>
    <p class="normal">Next, we try to execute the following task via 10 platform threads:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> index)</span> {
  logger.info(() -&gt; index + <span class="hljs-string">" "</span> 
    + Thread.currentThread().toString());
  <span class="hljs-keyword">try</span> { Thread.sleep(Duration.ofSeconds(<span class="hljs-number">3</span>)); } 
    <span class="hljs-keyword">catch</span> (InterruptedException ex) {}
   logger.info(() -&gt; index + <span class="hljs-string">"</span><span class="hljs-string"> "</span> 
    + Thread.currentThread().toString());
}
</code></pre>
    <p class="normal">Between the two <a id="_idIndexMarker1182"/>logging lines, we have a blocking operation (<code class="inlineCode">sleep()</code>). Next, we rely on <code class="inlineCode">newThreadPerTaskExecutor()</code> to submit 10 tasks that should log their details, sleep for 3 seconds, and log again:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> 
    Executors.newThreadPerTaskExecutor(
      <span class="hljs-keyword">new</span> <span class="hljs-title">SimpleThreadFactory</span>())) {
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX_THREADS; i++) {
    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> i;
    executor.submit(() -&gt; doSomething(index));
  }
}
</code></pre>
    <p class="normal">Running this code with platform threads reveals the following side-to-side output:</p>
    <figure class="mediaobject"><img src="../Images/B19665_10_08.png" alt="Figure 10.7.png"/></figure>
    <p class="packt_figref">Figure 10.8: Using platform threads</p>
    <p class="normal">By carefully inspecting this figure, we can see that there is a fixed association between these numbers. For instance, the task with ID 5 is executed by <code class="inlineCode">Thread-5</code>, the task with ID 3 by <code class="inlineCode">Thread-3</code>, and so on. After sleeping (i.e., a blocking operation), these numbers are unchanged. This means that while the tasks sleep, the threads just hang and wait there. They have no work to do.</p>
    <p class="normal">Let’s switch from platform threads to virtual threads and then run the code again:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> {
  <span class="hljs-comment">// return new Thread(r);    // classic thread</span>
  <span class="hljs-keyword">return</span> Thread.ofVirtual().unstarted(r); <span class="hljs-comment">// virtual thread</span>
}
</code></pre>
    <p class="normal">Now, the <a id="_idIndexMarker1183"/>output is resumed, as shown in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_10_09.png" alt="Figure 10.8.png"/></figure>
    <p class="packt_figref">Figure 10.9: Using virtual threads</p>
    <p class="normal">This time, we can see that things are more dynamic. For instance, the task with ID 5 is started by a virtual thread executed by <code class="inlineCode">worker-6</code>, but it is finished by <code class="inlineCode">worker-4</code>. The task with ID 3 is started by a virtual thread executed by <code class="inlineCode">worker-4</code>, but it is finished by <code class="inlineCode">worker-6</code>. This means that, while a task sleeps (a blocking operation), the corresponding virtual thread is unmounted, and its worker can serve other virtual threads. When the sleeping is over, the JVM schedules the virtual thread for execution and is mounted on another (it could also be the same) worker. This is also referred to as <em class="italic">thread context switching</em>.</p>
    <h2 id="_idParaDest-464" class="heading-2">Example 2</h2>
    <p class="normal">In this example, let’s start by limiting the parallelism to 1 (which is like having a single core and a single virtual thread):</p>
    <pre class="programlisting code"><code class="hljs-code">System.setProperty(
  <span class="hljs-string">"jdk.virtualThreadScheduler.maxPoolSize"</span>, <span class="hljs-string">"1"</span>);
System.setProperty(
  <span class="hljs-string">"jdk.virtualThreadScheduler.maxPoolSize"</span>, <span class="hljs-string">"1"</span>);
System.setProperty(
  <span class="hljs-string">"jdk.virtualThreadScheduler.maxPoolSize"</span>, <span class="hljs-string">"1"</span>);
</code></pre>
    <p class="normal">Next, let’s consider that we have a slow task (we call it slow because it sleeps for 5 seconds):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Runnable</span> <span class="hljs-variable">slowTask</span> <span class="hljs-operator">=</span> () -&gt; {
  logger.info(() -&gt; Thread.currentThread().toString() 
    + <span class="hljs-string">" | working on something"</span>);
  logger.info(() -&gt; Thread.currentThread().toString() 
    + <span class="hljs-string">" | break time (blocking)"</span>);
  <span class="hljs-keyword">try</span> { Thread.sleep(Duration.ofSeconds(<span class="hljs-number">5</span>)); } 
    <span class="hljs-keyword">catch</span> (InterruptedException ex) {} <span class="hljs-comment">// blocking</span>
  logger.info(() -&gt; Thread.currentThread().toString() 
    + <span class="hljs-string">" | work done"</span>);
};
</code></pre>
    <p class="normal">And then, a fast task (similar to the slow task, but it sleeps for only 1 second):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Runnable</span> <span class="hljs-variable">fastTask</span> <span class="hljs-operator">=</span> () -&gt; {
  logger.info(() -&gt; Thread.currentThread().toString() 
    + <span class="hljs-string">" | working on something"</span>);
  logger.info(() -&gt; Thread.currentThread().toString() 
    + <span class="hljs-string">" | break time (blocking)"</span>);
  <span class="hljs-keyword">try</span> { Thread.sleep(Duration.ofSeconds(<span class="hljs-number">1</span>)); } 
    <span class="hljs-keyword">catch</span> (InterruptedException ex) {} <span class="hljs-comment">// blocking</span>
  logger.info(() -&gt; Thread.currentThread().toString() 
    + <span class="hljs-string">" | work done"</span>);
};
</code></pre>
    <p class="normal">Next, we define<a id="_idIndexMarker1184"/> two virtual threads to execute these two tasks, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Thread</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Thread.ofVirtual()
  .name(<span class="hljs-string">"slow-"</span>, <span class="hljs-number">0</span>).start(slowTask);
<span class="hljs-type">Thread</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> Thread.ofVirtual()
  .name(<span class="hljs-string">"fast-"</span>, <span class="hljs-number">0</span>).start(fastTask);
st.join();
ft.join();
</code></pre>
    <p class="normal">If we run this code, then the output will be as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">[08:38:46] VirtualThread[#22,slow-0]/runnable
           @ForkJoinPool-1-worker-1 | working on something 
[08:38:46] VirtualThread[#22,slow-0]/runnable
           @ForkJoinPool-1-worker-1 | break time (blocking) 
[08:38:46] VirtualThread[#24,fast-0]/runnable
           @ForkJoinPool-1-worker-1 | working on something 
[08:38:46] VirtualThread[#24,fast-0]/runnable
           @ForkJoinPool-1-worker-1 | break time (blocking) 
[08:38:47] VirtualThread[#24,fast-0]/runnable
           @ForkJoinPool-1-worker-1 | work done 
[08:38:51] VirtualThread[#22,slow-0]/runnable
           @ForkJoinPool-1-worker-1 | work done
</code></pre>
    <p class="normal">If we analyze this output, we can see that the execution starts the slow task. The fast task cannot be executed, since <code class="inlineCode">worker-1</code> (the only available worker) is busy executing the slow task:</p>
    <pre class="programlisting con"><code class="hljs-con">[08:38:46] VirtualThread[#22,slow-0]/runnable
           @ForkJoinPool-1-worker-1 | working on something
</code></pre>
    <p class="normal"><code class="inlineCode">Worker-1</code> executes <a id="_idIndexMarker1185"/>the slow task until this task hits the sleeping operation. Since this is a blocking operation, the corresponding virtual thread (#22) is unmounted from <code class="inlineCode">worker-1</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">[08:38:46] VirtualThread[#22,slow-0]/runnable
           @ForkJoinPool-1-worker-1 | break time (blocking)
</code></pre>
    <p class="normal">The JVM takes advantage of the fact that <code class="inlineCode">worker-1</code> is available and pushes for the execution of the fast task:</p>
    <pre class="programlisting con"><code class="hljs-con">[08:38:46] VirtualThread[#24,fast-0]/runnable
           @ForkJoinPool-1-worker-1 | working on something
</code></pre>
    <p class="normal">The fast task also hits a sleeping operation, and its virtual thread (#24) is unmounted:</p>
    <pre class="programlisting con"><code class="hljs-con">[08:38:46] VirtualThread[#24,fast-0]/runnable
           @ForkJoinPool-1-worker-1 | break time (blocking)
</code></pre>
    <p class="normal">However, the fast task sleeps for only 1 second, so its blocking operation is over before the slow task blocking operation, which is still sleeping. So the JVM can schedule the fast task for execution again, and <code class="inlineCode">worker-1</code> is ready to accept it:</p>
    <pre class="programlisting con"><code class="hljs-con">[08:38:47] VirtualThread[#24,fast-0]/runnable
           @ForkJoinPool-1-worker-1 | work done
</code></pre>
    <p class="normal">At this moment, the fast task is done, and <code class="inlineCode">worker-1</code> is free. But the slow task is still sleeping. After these 5 seconds, the JVM schedules the slow task for execution, and <code class="inlineCode">worker-1</code> is there to take it.</p>
    <pre class="programlisting con"><code class="hljs-con">[08:38:51] VirtualThread[#22,slow-0]/runnable
           @ForkJoinPool-1-worker-1 | work done
</code></pre>
    <p class="normal">Done! </p>
    <h2 id="_idParaDest-465" class="heading-2">Example 3</h2>
    <p class="normal">This example is just a slight modification of Example 2. This time, let’s consider that the slow task contains a non-blocking operation that runs forever. In this case, this operation is simulated via an infinite loop:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Runnable</span> <span class="hljs-variable">slowTask</span> <span class="hljs-operator">=</span> () -&gt; {
  logger.info(() -&gt; Thread.currentThread().toString() 
    + <span class="hljs-string">" | working on something"</span>);
  logger.info(() -&gt; Thread.currentThread().toString() 
    + <span class="hljs-string">" | break time (non-blocking)"</span>);
  <span class="code-highlight"><strong class="hljs-keyword-slc">while</strong><strong class="hljs-slc">(dummyTrue()) {} </strong><strong class="hljs-comment-slc">// non-blocking </strong></span>
  logger.info(() -&gt; Thread.currentThread().toString() 
    + <span class="hljs-string">" | work done"</span>);
};
<span class="hljs-keyword">static</span> <span class="hljs-title">boolean dummyTrue</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }
</code></pre>
    <p class="normal">We have a<a id="_idIndexMarker1186"/> single worker (<code class="inlineCode">worker-1</code>), and the fast task is the same as in Example 2. If we run this code, the execution hangs on, as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">[09:02:45] VirtualThread[#22,slow-0]/runnable
           @ForkJoinPool-1-worker-1 | working on something 
[09:02:45] VirtualThread[#22,slow-0]/runnable
           @ForkJoinPool-1-worker-1 | break time(non-blocking)
// hang on
</code></pre>
    <p class="normal">The execution hangs on because the infinite loop is not seen as a blocking operation. In other words, the virtual thread of the slow task (#22) is never unmounted. Since there is a single worker, the JVM cannot push for the execution of the fast task.</p>
    <p class="normal">If we increase the parallelism from 1 to 2, then the fast task will be successfully executed by <code class="inlineCode">worker-2</code>, while <code class="inlineCode">worker-1</code> (executing the slow task) will simply hang on to a partial execution. We can avoid such situations by relying on a timeout join, such as <code class="inlineCode">join(Duration duration)</code>. This way, after the given timeout, the slow task will be automatically interrupted. So pay attention to such scenarios.</p>
    <h1 id="_idParaDest-466" class="heading-1">216. Introducing the ExecutorService invoke all/any for virtual threads – part 1</h1>
    <p class="normal">In this problem, we won’t spend time on the basics and, instead, jump right into how to use <code class="inlineCode">invokeAll()</code> and <code class="inlineCode">invokeAny()</code>. If you need a primer on the <code class="inlineCode">ExecutorService</code> API’s <code class="inlineCode">invokeAll()</code>/<code class="inlineCode">invokeAny()</code> functions, then you could consider <em class="italic">Java Coding Problems</em>, <em class="italic">First Edition</em>, <em class="italic">Chapter 10</em>, <em class="italic">Problem 207</em>. </p>
    <h2 id="_idParaDest-467" class="heading-2">Working with invokeAll()</h2>
    <p class="normal">In a <a id="_idIndexMarker1187"/>nutshell, <code class="inlineCode">invokeAll()</code> executes a collection of tasks (<code class="inlineCode">Callable</code>) and returns a <code class="inlineCode">List&lt;Future&gt;</code> that holds the results/status of each task. The tasks can finish naturally or be forced by a given timeout. Each task can finish successfully or exceptionally. Upon return, all the tasks that have not been completed yet are automatically canceled. We<a id="_idIndexMarker1188"/> can check out the status of each task via <code class="inlineCode">Future.isDone()</code> and <code class="inlineCode">Future.isCancelled()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? <span class="hljs-keyword">extends</span> 
  <span class="hljs-title">Callable</span>&lt;T&gt;&gt; tasks) <span class="hljs-keyword">throws</span> InterruptedException
&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(
  Collection&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title">Callable</span>&lt;T&gt;&gt; tasks, <span class="hljs-type">long</span> timeout,
    TimeUnit unit) <span class="hljs-keyword">throws</span> InterruptedException
</code></pre>
    <p class="normal">Using <code class="inlineCode">invokeAll()</code> with virtual threads via <code class="inlineCode">newVirtualThreadPerTaskExecutor()</code> (or with <code class="inlineCode">newThreadPerTaskExecutor()</code>) is straightforward. For instance, here we have a simple example of executing three <code class="inlineCode">Callable</code> instances:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> 
    <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) {
  List&lt;Future&lt;String&gt;&gt; futures = executor.invokeAll(
    List.of(() -&gt; <span class="hljs-string">"pass01"</span>, () -&gt; <span class="hljs-string">"pass02"</span>, () -&gt; <span class="hljs-string">"pass03"</span>));
  futures.forEach(f -&gt; logger.info(() -&gt;
    <span class="hljs-string">"State: "</span> + f.state()));
}
</code></pre>
    <p class="normal">Have you spotted the <code class="inlineCode">f.state()</code> call? This API was introduced in JDK 19, and it computes the state of a future based on the well-known <code class="inlineCode">get()</code>, <code class="inlineCode">isDone()</code>, and <code class="inlineCode">isCancelled()</code>. While we will detail this in a subsequent problem, currently, the output is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">[10:17:41] State: SUCCESS 
[10:17:41] State: SUCCESS 
[10:17:41] State: SUCCESS
</code></pre>
    <p class="normal">The three tasks have successfully completed.</p>
    <h2 id="_idParaDest-468" class="heading-2">Working with invokeAny()</h2>
    <p class="normal">In a <a id="_idIndexMarker1189"/>nutshell, <code class="inlineCode">invokeAny()</code> executes a collection of tasks (<code class="inlineCode">Callable</code>) and strives to return a result corresponding to a task that has successfully terminated (before the given timeout, if any). All the tasks that have not been completed are automatically canceled:</p>
    <pre class="programlisting code"><code class="hljs-code">&lt;T&gt; T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span>
  <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException
&lt;T&gt; T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span>
<span class="hljs-params">  </span><span class="hljs-type">long</span><span class="hljs-params"> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException,
    ExecutionException, TimeoutException
</code></pre>
    <p class="normal">Using <code class="inlineCode">invokeAny()</code> with virtual threads via <code class="inlineCode">newVirtualThreadPerTaskExecutor()</code> is also straightforward (or with <code class="inlineCode">newThreadPerTaskExecutor()</code>). For instance, here we have a simple <a id="_idIndexMarker1190"/>example of executing three <code class="inlineCode">Callable</code> instances when we are interested in a single result:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> 
<span class="hljs-operator">    =</span> Executors.newVirtualThreadPerTaskExecutor()) {
  <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> executor.invokeAny(
    List.of(() -&gt; <span class="hljs-string">"pass01"</span>, () -&gt; <span class="hljs-string">"pass02"</span>, () -&gt; <span class="hljs-string">"pass03"</span>));
  logger.info(result);
}
</code></pre>
    <p class="normal">A possible output might be:</p>
    <pre class="programlisting con"><code class="hljs-con">[10:29:33] pass02
</code></pre>
    <p class="normal">This output corresponds to the second <code class="inlineCode">Callable</code>.</p>
    <p class="normal">In the next problem, we will come up with a more realistic example.</p>
    <h1 id="_idParaDest-469" class="heading-1">217. Introducing the ExecutorService invoke all/any for virtual threads – part 2</h1>
    <p class="normal">Earlier, in <em class="italic">Problem 210</em>, we wrote a piece of “unstructured” concurrency code to build a testing team of three testers, served by an external server. </p>
    <p class="normal">Now, let’s try <a id="_idIndexMarker1191"/>to rewrite the <code class="inlineCode">buildTestingTeam()</code> method via <code class="inlineCode">invokeAll()</code>/<code class="inlineCode">Any()</code> and <code class="inlineCode">newVirtualThreadPerTaskExecutor()</code>. If we rely on <code class="inlineCode">invokeAll()</code>, then the application will attempt to load three testers by ID, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TestingTeam <span class="hljs-title">buildTestingTeam</span><span class="hljs-params">()</span> 
      <span class="hljs-keyword">throws</span> InterruptedException {
  <span class="hljs-keyword">try</span> (<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> 
      <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) {
    List&lt;Future&lt;String&gt;&gt; futures = executor.invokeAll(
      List.of(() -&gt; fetchTester(<span class="hljs-number">1</span>), 
              () -&gt; fetchTester(<span class="hljs-number">2</span>), 
              () -&gt; fetchTester(<span class="hljs-number">3</span>)));
    futures.forEach(f -&gt; logger.info(() -&gt; <span class="hljs-string">"State: "</span> 
      + f.state())); 
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">TestingTeam</span>(futures.get(<span class="hljs-number">0</span>).resultNow(), 
      futures.get(<span class="hljs-number">1</span>).resultNow(), futures.get(<span class="hljs-number">2</span>).resultNow());
  } 
}
</code></pre>
    <p class="normal">We have three<a id="_idIndexMarker1192"/> testers with IDs 1, 2, and 3. So the output will be:</p>
    <pre class="programlisting con"><code class="hljs-con">[07:47:32] State: SUCCESS
[07:47:32] State: SUCCESS 
[07:47:32] State: SUCCESS
</code></pre>
    <p class="normal">In the next problem, we will see how we can make decisions based on task state.</p>
    <p class="normal">If we can handle the testing phase even with a single tester, then we can rely on <code class="inlineCode">invokeAny()</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TestingTeam <span class="hljs-title">buildTestingTeam</span><span class="hljs-params">()</span> 
      <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException {
  <span class="hljs-keyword">try</span> (<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> 
    <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) {
    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> executor.invokeAny(
      List.of(() -&gt; fetchTester(<span class="hljs-number">1</span>), 
              () -&gt; fetchTester(<span class="hljs-number">2</span>), 
              () -&gt; fetchTester(<span class="hljs-number">3</span>)));
    logger.info(result);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">TestingTeam</span>(result);
  } 
}
</code></pre>
    <p class="normal">This code will return a single result representing one of these three testers. If none of them is available, then we will get a <code class="inlineCode">UserNotFoundException</code>.</p>
    <h1 id="_idParaDest-470" class="heading-1">218. Hooking task state</h1>
    <p class="normal">Starting <a id="_idIndexMarker1193"/>with JDK 19, we can rely on <code class="inlineCode">Future.state()</code>. This method computes the state of a <code class="inlineCode">Future</code> based on the well-known <code class="inlineCode">get()</code>, <code class="inlineCode">isDone()</code>, and <code class="inlineCode">isCancelled()</code>, returning a <code class="inlineCode">Future.State</code> enum entry, as follows:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">CANCELLED</code> – the task was canceled.</li>
      <li class="bulletList"><code class="inlineCode">FAILED</code> – the task was completed exceptionally (with an exception).</li>
      <li class="bulletList"><code class="inlineCode">RUNNING</code> – the task is still running (has not been completed).</li>
      <li class="bulletList"><code class="inlineCode">SUCCESS</code> – the task was completed normally with a result (no exception).</li>
    </ul>
    <p class="normal">In the following<a id="_idIndexMarker1194"/> snippet of code, we analyze the state of loading the testing team members and act accordingly:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TestingTeam <span class="hljs-title">buildTestingTeam</span><span class="hljs-params">()</span> 
       <span class="hljs-keyword">throws</span> InterruptedException {
  List&lt;String&gt; testers = <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;();
  <span class="hljs-keyword">try</span> (<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> 
      <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) {
    List&lt;Future&lt;String&gt;&gt; futures = executor.invokeAll(
      List.of(() -&gt; fetchTester(Integer.MAX_VALUE),
              () -&gt; fetchTester(<span class="hljs-number">2</span>), 
              () -&gt; fetchTester(Integer.MAX_VALUE)));
    futures.forEach(f -&gt; {
      logger.info(() -&gt; <span class="hljs-string">"Analyzing "</span> + f + <span class="hljs-string">" state ..."</span>); 
      <span class="hljs-keyword">switch</span> (f.state()) {
        <span class="hljs-keyword">case</span> RUNNING -&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">IllegalStateException</span>(
          <span class="hljs-string">"Future is still in the running state ..."</span>);
        <span class="hljs-keyword">case</span> SUCCESS -&gt; {
          logger.info(() -&gt; <span class="hljs-string">"Result: "</span> + f.resultNow());
          testers.add(f.resultNow());
        }
        <span class="hljs-keyword">case</span> FAILED -&gt;
          logger.severe(() -&gt; <span class="hljs-string">"Exception: "</span> 
            + f.exceptionNow().getMessage());
        <span class="hljs-keyword">case</span> CANCELLED -&gt;
          logger.info(<span class="hljs-string">"Cancelled ?!?"</span>);
      }
    }); 
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">TestingTeam</span>(testers.toArray(String[]::<span class="hljs-keyword">new</span>));
}
</code></pre>
    <p class="normal">We know that when the execution reaches the <code class="inlineCode">switch</code> block, the <code class="inlineCode">Future</code> objects should be completely normal or exceptional. So if the current <code class="inlineCode">Future</code> state is <code class="inlineCode">RUNNING</code>, then this is a really weird situation (possibly a bug), and we throw an <code class="inlineCode">IllegalStateException</code>. Next, if the <code class="inlineCode">Future</code> state is <code class="inlineCode">SUCCESS</code> (<code class="inlineCode">fetchTester(2)</code>), then we have a result that can be obtained via <code class="inlineCode">resultNow()</code>. This method was added in JDK 19, and it is useful when we know that we have a result. The <code class="inlineCode">resultNow()</code> method returns immediately without waiting (as <code class="inlineCode">get()</code>). If the state is <code class="inlineCode">FAILED</code> (<code class="inlineCode">fetchTester(Integer.MAX_VALUE)</code>), then we log the exception via <code class="inlineCode">exceptionNow()</code>. This method was also added in JDK 19, and it returns immediately the underlying exception of a failed <code class="inlineCode">Future</code>. Finally, if the <code class="inlineCode">Future</code> was canceled, then there is nothing to do. We just report it in the log.</p>
    <h1 id="_idParaDest-471" class="heading-1">219. Combining newVirtualThreadPerTaskExecutor() and streams</h1>
    <p class="normal">Streams and <code class="inlineCode">newVirtualThreadPerTaskExecutor()</code> is a handy combination. Here is an example <a id="_idIndexMarker1195"/>that relies on <code class="inlineCode">IntStream</code> to submit 10 simple tasks and collect the returned <code class="inlineCode">List</code> of <code class="inlineCode">Future</code> instances:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> 
      <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) {
  List&lt;Future&lt;String&gt;&gt; futures = IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)
    .mapToObj(i -&gt; executor.submit(() -&gt; {
       <span class="hljs-keyword">return</span> Thread.currentThread().toString() 
         + <span class="hljs-string">"("</span> + i + <span class="hljs-string">")"</span>;
  })).collect(toList());
  <span class="hljs-comment">// here we have the following snippet of code</span>
}
</code></pre>
    <p class="normal">Next, we wait for each <code class="inlineCode">Future</code> to complete by calling the <code class="inlineCode">get()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">  futures.forEach(f -&gt; {
    <span class="hljs-keyword">try</span> {
      logger.info(f.get());
    } <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException ex) {
      <span class="hljs-comment">// handle exception</span>
    }
  });
</code></pre>
    <p class="normal">Moreover, using stream pipelines is quite useful in combination with <code class="inlineCode">invokeAll()</code>. For instance, the following stream pipeline returns a <code class="inlineCode">List</code> of results (it filters all <code class="inlineCode">Future</code> instances that haven’t completed successfully):</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;String&gt; results = executor.invokeAll(
  List.of(() -&gt; <span class="hljs-string">"pass01"</span>, () -&gt; <span class="hljs-string">"</span><span class="hljs-string">pass02"</span>, () -&gt; <span class="hljs-string">"pass03"</span>))
  .stream()
  .filter(f -&gt; f.state() == Future.State.SUCCESS)
  .&lt;String&gt;mapMulti((f, c) -&gt; {
    c.accept((String) f.resultNow());
  }).collect(Collectors.toList());
</code></pre>
    <p class="normal">Alternatively, we can write the following solution (without <code class="inlineCode">mapMulti()</code>):</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;String&gt; results = executor.invokeAll(
  List.of(() -&gt; <span class="hljs-string">"pass01"</span>, () -&gt; <span class="hljs-string">"pass02"</span>, () -&gt; <span class="hljs-string">"pass03"</span>))
  .stream()
  .filter(f -&gt; f.state() == Future.State.SUCCESS)
  .map(f -&gt; f.resultNow().toString())
  .toList();
</code></pre>
    <p class="normal">Of course, if <code class="inlineCode">List&lt;Object&gt;</code> is all you need, then you can go straight ahead via <code class="inlineCode">Future::resultNow</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Object&gt; results = executor.invokeAll(
  List.of(() -&gt; <span class="hljs-string">"</span><span class="hljs-string">pass01"</span>, () -&gt; <span class="hljs-string">"pass02"</span>, () -&gt; <span class="hljs-string">"pass03"</span>))
  .stream()
  .filter(f -&gt; f.state() == Future.State.SUCCESS)
  .map(Future::resultNow)
  .toList();
</code></pre>
    <p class="normal">On the <a id="_idIndexMarker1196"/>other hand, you may need to collect all the <code class="inlineCode">Future</code> that has been completed exceptionally. This can be achieved via <code class="inlineCode">exceptionNow()</code>, as follows (we intentionally sneaked into the given <code class="inlineCode">List&lt;Callable&gt;</code> a <code class="inlineCode">Callable</code> that will generate an <code class="inlineCode">StringIndexOutOfBoundsException</code>, <code class="inlineCode">() -&gt; "pass02".substring(50)</code>):</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Throwable&gt; exceptions = executor.invokeAll(
  List.of(() -&gt; <span class="hljs-string">"</span><span class="hljs-string">pass01"</span>, 
          () -&gt; <span class="hljs-string">"pass02"</span>.substring(<span class="hljs-number">50</span>), () -&gt; <span class="hljs-string">"pass03"</span>))
  .stream()
  .filter(f -&gt; f.state() == Future.State.FAILED)
  .&lt;Throwable&gt;mapMulti((f, c) -&gt; {
    c.accept((Throwable) f.exceptionNow());
  }).collect(Collectors.toList());
</code></pre>
    <p class="normal">If you don’t prefer <code class="inlineCode">mapMulti()</code>, then rely on the classical approach:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Throwable&gt; exceptions = executor.invokeAll(
  List.of(() -&gt; <span class="hljs-string">"pass01"</span>, () -&gt; <span class="hljs-string">"pass02"</span>.substring(<span class="hljs-number">50</span>), 
          () -&gt; <span class="hljs-string">"pass03"</span>))
  .stream()
  .filter(f -&gt; f.state() == Future.State.FAILED)
  .map(Future::exceptionNow)
  .toList();
</code></pre>
    <p class="normal">You can find all these examples in the bundled code.</p>
    <h1 id="_idParaDest-472" class="heading-1">220. Introducing a scope object (StructuredTaskScope)</h1>
    <p class="normal">So far, we have covered a bunch of problems that use virtual threads directly or indirectly via an <code class="inlineCode">ExecutorService</code>. We<a id="_idIndexMarker1197"/> already know that virtual threads are cheap to create and block and that an application can run millions of them. We don’t need to reuse them, pool them, or do any fancy stuff. <em class="italic">Use and throw</em> is the proper and recommended<a id="_idIndexMarker1198"/> way to deal with virtual threads. This means that virtual threads are very useful for expressing and writing asynchronous code, which is commonly based on a lot of threads that are capable of blocking/unblocking several times in a short period. On the other hand, we know that OS threads are expensive to create, very expensive to block, and are not easy to put into an asynchronous context.</p>
    <p class="normal">Before virtual threads (so for many, many years), we had to manage the life cycle of OS threads via an <code class="inlineCode">ExecutorService</code>/<code class="inlineCode">Executor</code>, and we could write asynchronous (or reactive) code via <em class="italic">callbacks</em> (you can find detailed coverage of asynchronous programming in <em class="italic">Java Coding Problems</em>, <em class="italic">First Edition</em>, <em class="italic">Chapter 11</em>).</p>
    <p class="normal">However, asynchronous/reactive code is hard to write/read, very hard to debug and profile, and almost deadly hard to unit-test. Nobody wants to read and fix your asynchronous code! Moreover, once we start to write an application via asynchronous callback, we tend to use this model for all tasks, even for those that shouldn’t be asynchronous. We can easily fall into this trap when we need to somehow link asynchronous code/results to non-asynchronous code. And the easiest way to do it is to go only for asynchronous code.</p>
    <p class="normal">So is there a better way? Yes, there is! Structured concurrency is the answer. Structured concurrency started as an <em class="italic">incubator</em> project and reached the <em class="italic">preview</em> stage in JDK 21 (JEP 453).</p>
    <p class="normal">And, in this context, we should introduce <code class="inlineCode">StructuredTaskScope</code>. A <code class="inlineCode">StructuredTaskScope</code> is a virtual thread launcher for <code class="inlineCode">Callable</code> tasks that returns a <code class="inlineCode">Subtask</code>. A subtask is an extension of the well-known <code class="inlineCode">Supplier&lt;T&gt;</code> functional interface represented by the <code class="inlineCode">StructuredTaskScope.Subtask&lt;T&gt;</code> interface and forked with <code class="inlineCode">StructuredTaskScope.fork(Callable task)</code>. It follows and works based on the fundamental principle of structured concurrency (see <em class="italic">Problem 210</em>): “<em class="italic">When a task has to be solved concurrently, then all the threads needed to solve it are spun and rejoined in the same block of code. In other words, all these threads’ lifetimes are bound to the block’s scope, so we have clear and explicit entry-exit points for each concurrent code block</em>.” These threads are responsible for running subtasks (<code class="inlineCode">Subtask</code>) of the given task as a single unit of work.</p>
    <p class="normal">Let’s look at an example of fetching a single tester (with ID 1) from our web server via <code class="inlineCode">StructuredTaskScope</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TestingTeam <span class="hljs-title">buildTestingTeam</span><span class="hljs-params">()</span> 
       <span class="hljs-keyword">throws</span> InterruptedException {
  <span class="hljs-keyword">try</span> (<span class="hljs-type">StructuredTaskScope</span> <span class="hljs-variable">scope</span> 
      <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">StructuredTaskScope</span>&lt;String&gt;()) {
    Subtask&lt;String&gt; subtask
      = scope.fork(() -&gt; fetchTester(<span class="hljs-number">1</span>));
    logger.info(() -&gt; <span class="hljs-string">"Waiting for "</span> + subtask.toString() 
      + <span class="hljs-string">" to finish ...\n"</span>);
    scope.join(); 
    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> subtask.get();
    logger.info(result);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">TestingTeam</span>(result);
  } 
}
</code></pre>
    <p class="normal">First, we create a <code class="inlineCode">StructuredTaskScope</code> in a <code class="inlineCode">try-with-resources</code> pattern. <code class="inlineCode">StructuredTaskScope</code> implements <code class="inlineCode">AutoCloseable</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">StructuredTaskScope</span> <span class="hljs-variable">scope</span> 
      <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">StructuredTaskScope</span>&lt;String&gt;()) {
    ...  
}
</code></pre>
    <p class="normal">The <code class="inlineCode">scope</code> is a<a id="_idIndexMarker1199"/> wrapper for the virtual threads’ lifetimes. We use the <code class="inlineCode">scope</code> to fork as <a id="_idIndexMarker1200"/>many virtual threads (subtasks) as needed via the <code class="inlineCode">fork(Callable task)</code> method. Here, we fork only one virtual thread and get back a <code class="inlineCode">Subtask</code> (forking is a non-blocking operation):</p>
    <pre class="programlisting code"><code class="hljs-code">Subtask&lt;String&gt; subtask = scope.fork(() -&gt; fetchTester(<span class="hljs-number">1</span>));
</code></pre>
    <p class="normal">Next, we have to call the <code class="inlineCode">join()</code> method (or <code class="inlineCode">joinUntil(Instant deadline)</code>). This method waits for all threads (all <code class="inlineCode">Subtask</code> instances) forked from this <code class="inlineCode">scope</code> (or all threads that have been submitted to this <code class="inlineCode">scope</code>) to complete, so it is a blocking operation. A scope should block only while it waits for its subtasks to complete, and this happens via <code class="inlineCode">join()</code> or <code class="inlineCode">joinUntil()</code>.</p>
    <pre class="programlisting code"><code class="hljs-code">scope.join(); 
</code></pre>
    <p class="normal">When the execution passes this line, we know that all threads (all forked <code class="inlineCode">Subtask</code>) forked from this <code class="inlineCode">scope</code> are complete, with a result or an exception (each subtask runs independently, so each of them can complete with a result or an exception). Here, we call the non-blocking <code class="inlineCode">get()</code> method to get the result, but pay attention – calling <code class="inlineCode">get()</code> for a task that did not complete will raise an exception as <code class="inlineCode">IllegalStateException(</code><em class="italic">"Owner did not join after forking subtask"</em><code class="inlineCode">)</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> subtask.get();
</code></pre>
    <p class="normal">On the other hand, we <a id="_idIndexMarker1201"/>can obtain the exception of a failed task via <code class="inlineCode">exception()</code>. However, if we call <code class="inlineCode">exception()</code> for a subtask (<code class="inlineCode">Subtask</code>) that is completed with a result, then we will get back an exception as <code class="inlineCode">IllegalStateException(</code><em class="italic">"Subtask not completed or did not complete with exception"</em><code class="inlineCode">)</code>. </p>
    <p class="normal">So if you are not sure whether your task(s) completed with a <a id="_idIndexMarker1202"/>result or an exception, it is better to call <code class="inlineCode">get()</code> or <code class="inlineCode">exception()</code> only after you test the state of the corresponding <code class="inlineCode">Subtask</code>. A state of <code class="inlineCode">SUCCESS</code> will safely allow you to call <code class="inlineCode">get()</code>, while a state of <code class="inlineCode">FAILED</code> will safely allow you to call <code class="inlineCode">exception()</code>. So in our case, we may prefer it this way:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">""</span>;
<span class="hljs-keyword">if</span> (subtask.state().equals(Subtask.State.SUCCESS)) {
  result = subtask.get();
}
</code></pre>
    <p class="normal">Besides <code class="inlineCode">Subtask.State.SUCCESS</code> and <code class="inlineCode">Subtask.State.FAILED</code>, we also have <code class="inlineCode">Subtask.State.UNAVAILABLE</code>, which means that the subtask is not available (for instance, if the subtask is still running, then its state is <code class="inlineCode">UNAVAILABLE</code>, but there could be another cause as well).</p>
    <h2 id="_idParaDest-473" class="heading-2">ExecutorService vs. StructuredTaskScope</h2>
    <p class="normal">The previous<a id="_idIndexMarker1203"/> code looks like the code that we would write via a classical <code class="inlineCode">ExecutorService</code>, but there are two big differences between these solutions. First of all, an <code class="inlineCode">ExecutorService</code> holds the precious platform threads and allows us to pool them. On the other hand, a <code class="inlineCode">StructuredTaskScope</code> is just a thin launcher for virtual threads that are cheap and shouldn’t be pooled. So once we’ve done our job, a <code class="inlineCode">StructuredTaskScope</code> can be destroyed and garbage-collected. Second, an <code class="inlineCode">ExecutorService</code> holds a single queue for all the tasks, and the threads take from this queue whenever they have the chance to do so. A <code class="inlineCode">StructuredTaskScope</code> relies on a fork/join pool, and each virtual thread has its own wait queue. However, a virtual thread can steal a task from another queue as well. This is known as the <em class="italic">work-stealing </em>pattern, and if you want to read more about it, we covered it in depth in<em class="italic"> Java Coding Problem</em>, <em class="italic">First Edition</em>, <em class="italic">Chapter 11</em>.</p>
    <h1 id="_idParaDest-474" class="heading-1">221. Introducing ShutdownOnSuccess</h1>
    <p class="normal">In the <a id="_idIndexMarker1204"/>previous problem, we introduced <code class="inlineCode">StructuredTaskScope</code> and used it to solve a task via a single virtual thread (a single <code class="inlineCode">Subtask</code>). Basically, we fetched the tester with ID 1 from our server (we had to wait until this one was available). Next, let’s assume that we still need a single tester, but not mandatorily the one with ID 1. This time, it could be any of IDs 1, 2, or 3. We simply take the first one that is available from these three, and we cancel the other two requests.</p>
    <p class="normal">Especially for <a id="_idIndexMarker1205"/>such scenarios, we have an extension of <code class="inlineCode">StructuredTaskScope</code> called <code class="inlineCode">StructuredTaskScope.ShutdownOnSuccess</code>. This scope is capable of returning the result of the first task that completes successfully and interrupts the rest of the threads. It follows the “invoke any” model and can be used as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TestingTeam <span class="hljs-title">buildTestingTeam</span><span class="hljs-params">()</span> 
       <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException {
  <span class="hljs-keyword">try</span> (<span class="hljs-type">ShutdownOnSuccess</span> <span class="hljs-variable">scope</span> 
      <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">StructuredTaskScope</span>.ShutdownOnSuccess&lt;String&gt;()) {
    Subtask&lt;String&gt; subtask1 
      = scope.fork(() -&gt; fetchTester(<span class="hljs-number">1</span>));
    Subtask&lt;String&gt; subtask2 
      = scope.fork(() -&gt; fetchTester(<span class="hljs-number">2</span>));
    Subtask&lt;String&gt; subtask3 
      = scope.fork(() -&gt; fetchTester(<span class="hljs-number">3</span>));
    scope.join();
    logger.info(() -&gt; <span class="hljs-string">"Subtask-1 state: "</span> + future1.state());
    logger.info(() -&gt; <span class="hljs-string">"Subtask-2 state: "</span> + future2.state());
    logger.info(() -&gt; <span class="hljs-string">"Subtask-3 state: "</span> + future3.state());
    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (String) scope.result();
    logger.info(result);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">TestingTeam</span>(result);
  }
}
</code></pre>
    <p class="normal">Here, we fork three subtasks (threads) that will compete with each other to complete. The first subtask (thread) that completes successfully wins and returns. The <code class="inlineCode">result()</code> method returns this result (if none of the subtasks (threads) complete successfully, then it throws an <code class="inlineCode">ExecutionException</code>).</p>
    <p class="normal">If we check the state of these three <code class="inlineCode">Subtask</code>, we can see that one succeeds while the other two are unavailable:</p>
    <pre class="programlisting con"><code class="hljs-con">[09:01:50] Subtask-1 state: UNAVAILABLE
[09:01:50] Subtask-2 state: SUCCESS
[09:01:50] Subtask-3 state: UNAVAILABLE
</code></pre>
    <p class="normal">Of course, you don’t need the code that checks/prints the state of each <code class="inlineCode">Subtask</code>. It was added here just to highlight how <code class="inlineCode">ShutdownOnSuccess</code> works. You don’t even need the explicit <code class="inlineCode">Subtask</code> objects, since we don’t call <code class="inlineCode">get()</code> or anything else from this API. Basically, we can reduce<a id="_idIndexMarker1206"/> the code to the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TestingTeam <span class="hljs-title">buildTestingTeam</span><span class="hljs-params">()</span> 
       <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException {
  <span class="hljs-keyword">try</span> (<span class="hljs-type">ShutdownOnSuccess</span> <span class="hljs-variable">scope</span> 
      <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">StructuredTaskScope</span>.ShutdownOnSuccess&lt;String&gt;()) {
    scope.fork(() -&gt; fetchTester(<span class="hljs-number">1</span>));
    scope.fork(() -&gt; fetchTester(<span class="hljs-number">2</span>));
    scope.fork(() -&gt; fetchTester(<span class="hljs-number">3</span>));
    scope.join();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">TestingTeam</span>((String) scope.result());
  }
}
</code></pre>
    <p class="normal">Done! You just create the scope, fork your subtasks, call <code class="inlineCode">join()</code>, and collect the result. So the scope is really business-focused.</p>
    <p class="normal">A task that completes exceptionally under the <code class="inlineCode">ShutdownOnSuccess</code> umbrella will never be chosen to produce a result. However, if all tasks complete exceptionally, then we will get an <code class="inlineCode">ExecutionException</code> that wraps the exception (i.e., the cause) of the first completed task.</p>
    <h1 id="_idParaDest-475" class="heading-1">222. Introducing ShutdownOnFailure</h1>
    <p class="normal">As its name suggests, <code class="inlineCode">StructuredTaskScope.ShutdownOnFailure</code> is capable of returning the exception <a id="_idIndexMarker1207"/>of the first subtask that completes exceptionally and interrupts the rest of the subtasks (threads). For instance, we may want to fetch the testers with IDs 1, 2, and 3. Since we need exactly these three testers, we want to be informed if any of them are not available and, if so, cancel everything (i.e., the remaining threads). The code looks as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">TestingTeam buildTestingTeam</span><span class="hljs-params">()</span> 
       <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException {
  <span class="hljs-keyword">try</span> (<span class="hljs-type">ShutdownOnFailure</span> <span class="hljs-variable">scope</span> 
      <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">StructuredTaskScope</span>.ShutdownOnFailure()) {
    Subtask&lt;String&gt; subtask1 
      = scope.fork(() -&gt; fetchTester(<span class="hljs-number">1</span>));
    Subtask&lt;String&gt; subtask2 
      = scope.fork(() -&gt; fetchTester(<span class="hljs-number">2</span>));
    Subtask&lt;String&gt; subtask3 
      = scope.fork(() -&gt; fetchTester(Integer.MAX_VALUE));
    scope.join();
    logger.info(() -&gt; <span class="hljs-string">"Subtask-1 state: "</span> + subtask1.state());
    logger.info(() -&gt; <span class="hljs-string">"Subtask-2 state: "</span> + subtask2.state());
    logger.info(() -&gt; <span class="hljs-string">"Subtask-3 state: "</span> + subtask3.state());
    Optional&lt;Throwable&gt; exception = scope.exception();
    <span class="hljs-keyword">if</span> (exception.isEmpty()) {
      logger.info(() -&gt; <span class="hljs-string">"Subtask-1 result:"</span> + subtask1.get());
      logger.info(() -&gt; <span class="hljs-string">"Subtask-2 result:"</span> + subtask2.get());
      logger.info(() -&gt; <span class="hljs-string">"Subtask-3 result:"</span> + subtask3.get());
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">TestingTeam</span>(
        subtask1.get(), subtask2.get(), subtask3.get());
    } <span class="hljs-keyword">else</span> {
      logger.info(() -&gt; exception.get().getMessage());
      scope.throwIfFailed();
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">TestingTeam</span>();
}
</code></pre>
    <p class="normal">In this example, we<a id="_idIndexMarker1208"/> intentionally replaced ID 3 with <code class="inlineCode">Integer.MAX_VALUE</code>. Since there is no tester with this ID, the server will throw <code class="inlineCode">UserNotFoundException</code>. This means that the states of the subtasks will reveal that the third subtask has failed:</p>
    <pre class="programlisting con"><code class="hljs-con">[16:41:15] Subtask-1 state: SUCCESS
[16:41:15] Subtask-2 state: SUCCESS
[16:41:15] Subtask-3 state: FAILED
</code></pre>
    <p class="normal">Moreover, when we call the <code class="inlineCode">exception()</code> method, we will get back an <code class="inlineCode">Optional&lt;Throwable&gt;</code> containing this exception (if you’re interested in reading more about this subject, in-depth coverage of the <code class="inlineCode">Optional</code> feature is available in <em class="italic">Java Coding Problems</em>, <em class="italic">First Edition</em>, <em class="italic">Chapter 12</em>). If we decide to throw it, then we simply call the <code class="inlineCode">throwIfFailed()</code> method, which wraps the original exception (the cause) in an <code class="inlineCode">ExecutionException</code> and throws it. The message of the exception in our case will be:</p>
    <pre class="programlisting con"><code class="hljs-con">Exception in thread "main" 
java.util.concurrent.ExecutionException: 
modern.challenge.UserNotFoundException: Code: 404
</code></pre>
    <p class="normal">If we remove<a id="_idIndexMarker1209"/> the guideline code, then we can compact the previous code, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TestingTeam <span class="hljs-title">buildTestingTeam</span><span class="hljs-params">()</span> 
       <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException {
  <span class="hljs-keyword">try</span> (<span class="hljs-type">ShutdownOnFailure</span> <span class="hljs-variable">scope</span> 
      <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">StructuredTaskScope</span>.ShutdownOnFailure()) {
    Subtask&lt;String&gt; subtask1 
      = scope.fork(() -&gt; fetchTester(<span class="hljs-number">1</span>));
    Subtask&lt;String&gt; subtask2 
      = scope.fork(() -&gt; fetchTester(<span class="hljs-number">2</span>));
    Subtask&lt;String&gt; subtask3 
      = scope.fork(() -&gt; fetchTester(
        Integer.MAX_VALUE)); <span class="hljs-comment">// this causes exception</span>
    scope.join();
    scope.throwIfFailed();
    <span class="hljs-comment">// because we have an exception the following </span>
    <span class="hljs-comment">// code will not be executed</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">TestingTeam</span>(
      subtask1.get(), subtask2.get(), subtask3.get()); 
  }
}
</code></pre>
    <p class="normal">If no exception occurs, then <code class="inlineCode">throwIfFailed()</code> doesn’t do anything, and those three testers are available. The result of each <code class="inlineCode">Subtask</code> is available via the non-blocking <code class="inlineCode">Subtask.get()</code>.</p>
    <p class="normal">A subtask that completes exceptionally under the <code class="inlineCode">ShutdownOnFailure</code> umbrella will be chosen to produce an exception. However, if all subtasks complete normally, then we will not get any exceptions. On the other hand, if no subtasks were completed exceptionally but were canceled, then <code class="inlineCode">ShutdownOnFailure</code> will throw <code class="inlineCode">CancellationException</code>.</p>
    <h1 id="_idParaDest-476" class="heading-1">223. Combining StructuredTaskScope and streams</h1>
    <p class="normal">If you prefer<a id="_idIndexMarker1210"/> functional programming, then you’ll be happy to see that streams can be used with <code class="inlineCode">StructuredTaskScope</code> as well. For instance, here we rewrite the application from <em class="italic">Problem 221</em>, using a stream pipeline to fork our tasks:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TestingTeam <span class="hljs-title">buildTestingTeam</span><span class="hljs-params">()</span> 
       <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException {
  <span class="hljs-keyword">try</span> (<span class="hljs-type">ShutdownOnSuccess</span> <span class="hljs-variable">scope</span> 
      <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">StructuredTaskScope</span>.ShutdownOnSuccess&lt;String&gt;()) {
    Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
      .&lt;Callable&lt;String&gt;&gt;map(id -&gt; () -&gt; fetchTester(id))
      .forEach(scope::fork);
    scope.join();
    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (String) scope.result();
    logger.info(result);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">TestingTeam</span>(result);
  }
}
</code></pre>
    <p class="normal">Moreover, we <a id="_idIndexMarker1211"/>can use stream pipelines to collect results and exceptions, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TestingTeam <span class="hljs-title">buildTestingTeam</span><span class="hljs-params">()</span> 
    <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException {
 <span class="hljs-keyword">try</span> (<span class="hljs-type">ShutdownOnSuccess</span> <span class="hljs-variable">scope</span> 
  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">StructuredTaskScope</span>.ShutdownOnSuccess&lt;String&gt;()) {
  List&lt;Subtask&gt; subtasks = Stream.of(Integer.MAX_VALUE, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
    .&lt;Callable&lt;String&gt;&gt;map(id -&gt; () -&gt; fetchTester(id))
    .map(scope::fork)
    .toList();
  scope.join();
  List&lt;Throwable&gt; failed = subtasks.stream()
    .filter(f -&gt; f.state() == Subtask.State.FAILED)
    .map(Subtask::exception)
    .toList();
  logger.info(failed.toString());
  <span class="hljs-type">TestingTeam</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> subtasks.stream()
    .filter(f -&gt; f.state() == Subtask.State.SUCCESS)
    .map(Subtask::get) 
    .collect(collectingAndThen(toList(),
      list -&gt; { <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">TestingTeam</span>(list.toArray(
        String[]::<span class="hljs-keyword">new</span>)); }));
  logger.info(result.toString());
  <span class="hljs-keyword">return</span> result;
  }
}
</code></pre>
    <p class="normal">You can find these <a id="_idIndexMarker1212"/>examples in the bundled code.</p>
    <h1 id="_idParaDest-477" class="heading-1">224. Observing and monitoring virtual threads</h1>
    <p class="normal">Observing <a id="_idIndexMarker1213"/>and monitoring virtual threads can be done in several ways. First, we can <a id="_idIndexMarker1214"/>use <strong class="keyWord">Java Flight Recorder</strong> (<strong class="keyWord">JFR</strong>) – we introduced this tool in <em class="italic">Chapter 6</em>, <em class="italic">Problem 143</em>.</p>
    <h2 id="_idParaDest-478" class="heading-2">Using JFR</h2>
    <p class="normal">Among its <a id="_idIndexMarker1215"/>reach list of events, JFR can monitor and record the following events related to virtual threads:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">jdk.VirtualThreadStart</code> – this event is recorded when a virtual thread starts (by default, it is disabled)</li>
      <li class="bulletList"><code class="inlineCode">jdk.VirtualThreadEnd</code> – this event is recorded when a virtual thread ends (by default, it is disabled)</li>
      <li class="bulletList"><code class="inlineCode">jdk.VirtualThreadPinned</code> – this event is recorded when a virtual thread is parked while pinned (by default, it is enabled with a threshold of 20 ms)</li>
      <li class="bulletList"><code class="inlineCode">jdk.VirtualThreadSubmitFailed</code> – this event is recorded if a virtual thread cannot be started or unparked (by default, it is enabled)</li>
    </ul>
    <p class="normal">You can find all the JFR events at <a href="https://sap.github.io/SapMachine/jfrevents/"><span class="url">https://sap.github.io/SapMachine/jfrevents/</span></a>.</p>
    <p class="normal">We start configuring JFR to monitor the virtual threads, by adding to the root folder of the application the following <code class="inlineCode">vtEvent.jfc</code> file: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">&lt;?xml version=</span><span class="hljs-string">"1.0"</span><span class="hljs-meta"> encoding=</span><span class="hljs-string">"UTF-8"</span><span class="hljs-meta">?&gt;</span>
<span class="hljs-tag">&lt;</span><span class="hljs-name">configuration</span><span class="hljs-tag"> </span><span class="hljs-attr">version</span><span class="hljs-tag">=</span><span class="hljs-string">"2.0"</span><span class="hljs-tag"> </span><span class="hljs-attr">description</span><span class="hljs-tag">=</span><span class="hljs-string">"test"</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">  &lt;</span><span class="hljs-name">event</span><span class="hljs-tag"> </span><span class="hljs-attr">name</span><span class="hljs-tag">=</span><span class="hljs-string">"jdk.VirtualThreadStart"</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">    &lt;</span><span class="hljs-name">setting</span><span class="hljs-tag"> </span><span class="hljs-attr">name</span><span class="hljs-tag">=</span><span class="hljs-string">"enabled"</span><span class="hljs-tag">&gt;</span>true<span class="hljs-tag">&lt;/</span><span class="hljs-name">setting</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">    &lt;</span><span class="hljs-name">setting</span><span class="hljs-tag"> </span><span class="hljs-attr">name</span><span class="hljs-tag">=</span><span class="hljs-string">"stackTrace"</span><span class="hljs-tag">&gt;</span>true<span class="hljs-tag">&lt;/</span><span class="hljs-name">setting</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">  &lt;/</span><span class="hljs-name">event</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">  &lt;</span><span class="hljs-name">event</span><span class="hljs-tag"> </span><span class="hljs-attr">name</span><span class="hljs-tag">=</span><span class="hljs-string">"jdk.VirtualThreadEnd"</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">    &lt;</span><span class="hljs-name">setting</span><span class="hljs-tag"> </span><span class="hljs-attr">name</span><span class="hljs-tag">=</span><span class="hljs-string">"enabled"</span><span class="hljs-tag">&gt;</span>true<span class="hljs-tag">&lt;/</span><span class="hljs-name">setting</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">  &lt;/</span><span class="hljs-name">event</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">  &lt;</span><span class="hljs-name">event</span><span class="hljs-tag"> </span><span class="hljs-attr">name</span><span class="hljs-tag">=</span><span class="hljs-string">"jdk.VirtualThreadPinned"</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">    &lt;</span><span class="hljs-name">setting</span><span class="hljs-tag"> </span><span class="hljs-attr">name</span><span class="hljs-tag">=</span><span class="hljs-string">"enabled"</span><span class="hljs-tag">&gt;</span>true<span class="hljs-tag">&lt;/</span><span class="hljs-name">setting</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">    &lt;</span><span class="hljs-name">setting</span><span class="hljs-tag"> </span><span class="hljs-attr">name</span><span class="hljs-tag">=</span><span class="hljs-string">"stackTrace"</span><span class="hljs-tag">&gt;</span>true<span class="hljs-tag">&lt;/</span><span class="hljs-name">setting</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">    &lt;</span><span class="hljs-name">setting</span><span class="hljs-tag"> </span><span class="hljs-attr">name</span><span class="hljs-tag">=</span><span class="hljs-string">"threshold"</span><span class="hljs-tag">&gt;</span>20 ms<span class="hljs-tag">&lt;/</span><span class="hljs-name">setting</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">  &lt;/</span><span class="hljs-name">event</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">  &lt;</span><span class="hljs-name">event</span><span class="hljs-tag"> </span><span class="hljs-attr">name</span><span class="hljs-tag">=</span><span class="hljs-string">"jdk.VirtualThreadSubmitFailed"</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">    &lt;</span><span class="hljs-name">setting</span><span class="hljs-tag"> </span><span class="hljs-attr">name</span><span class="hljs-tag">=</span><span class="hljs-string">"enabled"</span><span class="hljs-tag">&gt;</span>true<span class="hljs-tag">&lt;/</span><span class="hljs-name">setting</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">    &lt;</span><span class="hljs-name">setting</span><span class="hljs-tag"> </span><span class="hljs-attr">name</span><span class="hljs-tag">=</span><span class="hljs-string">"stackTrace"</span><span class="hljs-tag">&gt;</span>true<span class="hljs-tag">&lt;/</span><span class="hljs-name">setting</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">  &lt;/</span><span class="hljs-name">event</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">&lt;/</span><span class="hljs-name">configuration</span><span class="hljs-tag">&gt;</span>
</code></pre>
    <p class="normal">Next, let’s <a id="_idIndexMarker1216"/>consider the following code (basically, this is the application from Problem 216):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TestingTeam <span class="hljs-title">buildTestingTeam</span><span class="hljs-params">()</span> 
       <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException {
  <span class="hljs-keyword">try</span> (<span class="hljs-type">ShutdownOnSuccess</span> <span class="hljs-variable">scope</span> 
    <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">StructuredTaskScope</span>.ShutdownOnSuccess&lt;String&gt;()) {
    Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
      .&lt;Callable&lt;String&gt;&gt;map(id -&gt; () -&gt; fetchTester(id))
      .forEach(scope::fork);
    scope.join();
    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (String) scope.result();
    logger.info(result);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">TestingTeam</span>(result);
  }
}
</code></pre>
    <p class="normal">Next, we use <code class="inlineCode">-XX:StartFlightRecording=filename=recording.jfr</code> to instruct JFR to record output in a file named <code class="inlineCode">recording.jfr</code>, and we continue with <code class="inlineCode">settings=vtEvent.jfc</code> to highlight the configuration file listed previously.</p>
    <p class="normal">So the final command is the one from this figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_10_10.png" alt="Figure 10.10.png"/></figure>
    <p class="packt_figref">Figure 10.10: Running JFR</p>
    <p class="normal">JFR has produced a file named <code class="inlineCode">recording.jfr</code>. We can easily view the content of this file via the JFR CLI. The command (<code class="inlineCode">jfr print recording.jfr</code>) will display the content of <code class="inlineCode">recording.jfr</code>. The <a id="_idIndexMarker1217"/>content is too large to be listed here (it contains three entries for <code class="inlineCode">jdk.VirtualThreadStart</code> and three for <code class="inlineCode">jdk.VirtualThreadEnd</code>), but here is the event specific to starting a virtual thread:</p>
    <figure class="mediaobject"><img src="../Images/B19665_10_11.png" alt="Figure 10.11.png"/></figure>
    <p class="packt_figref">Figure 10.11: JFR event to start a virtual thread</p>
    <p class="normal">And, in the next figure, you can see the event recorded to end this virtual thread:</p>
    <figure class="mediaobject"><img src="../Images/B19665_10_12.png" alt="Figure 10.12.png"/></figure>
    <p class="packt_figref">Figure 10.12: JFR event to end a virtual thread</p>
    <p class="normal">Besides the JFR CLI, you can use more powerful tools to consume the virtual thread events, such as JDK Mission Control (<a href="https://www.oracle.com/java/technologies/jdk-mission-control.html"><span class="url">https://www.oracle.com/java/technologies/jdk-mission-control.html</span></a>) and the well-known Advanced Management Console (<a href="https://www.oracle.com/java/technologies/advancedmanagementconsole.html"><span class="url">https://www.oracle.com/java/technologies/advancedmanagementconsole.html</span></a>).</p>
    <p class="normal">To get a stack trace for threads that block while pinned, we can set the system property, <code class="inlineCode">jdk.tracePinnedThreads</code>. A complete (verbose) stack trace is available via <code class="inlineCode">-Djdk.tracePinnedThreads=full</code>, or if all you need is a brief/short stack trace, then rely on <code class="inlineCode">-Djdk.tracePinnedThreads=short</code>.</p>
    <p class="normal">In our example, we can easily get a pinned virtual thread by marking the <code class="inlineCode">fetchTester()</code> method as <code class="inlineCode">synchronized</code> (remember that a virtual thread cannot be unmounted if it runs code inside a <code class="inlineCode">synchronized</code> method/block):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title">fetchTester</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> id)</span> 
    <span class="hljs-keyword">throws</span> IOException, InterruptedException {
  ...
}
</code></pre>
    <p class="normal">In this <a id="_idIndexMarker1218"/>context, JFR will record a pinned virtual thread, as shown in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_10_13.png" alt="Figure 10.12.png"/></figure>
    <p class="packt_figref">Figure 10.13: JFR event for a pinned virtual thread</p>
    <p class="normal">If we run the application with <code class="inlineCode">-Djdk.tracePinnedThreads=full</code>, then your IDE will print a detailed stack trace that starts as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">Thread[#26,ForkJoinPool-1-worker-1,5,CarrierThreads]    java.base/java.lang.VirtualThread<span class="hljs-con-variable">$VThreadContinuation</span>.onPinned(VirtualThread.java:183)
...
</code></pre>
    <p class="normal">You can see the complete output by executing the bundled code. Of course, you can get a thread dump and analyze it via several other tools. You may prefer any of <code class="inlineCode">jstack</code>, <strong class="keyWord">Java Mission Control</strong> (<strong class="keyWord">JMC</strong>), <code class="inlineCode">jvisualvm</code>, or <code class="inlineCode">jcmd</code>. For instance, we can obtain a thread dump in plain text or the JSON format via <code class="inlineCode">jcmd</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">jcmd &lt;PID&gt; Thread.dump_to_file -format=text &lt;file&gt;
jcmd &lt;PID&gt; Thread.dump_to_file -format=json &lt;file&gt;
</code></pre>
    <p class="normal">Next, let’s play with <code class="inlineCode">jconsole</code> (JMX) to quickly analyze the performance of virtual threads.</p>
    <h2 id="_idParaDest-479" class="heading-2">Using Java Management Extensions (JMX)</h2>
    <p class="normal">Until JDK 20 (inclusive), JMX provided support for monitoring only the platform and threads. However, we <a id="_idIndexMarker1219"/>can still use JMX to observe the performance brought by virtual threads in comparison with platform threads.</p>
    <p class="normal">For instance, we can use JMX to monitor platform threads at 500 ms each, via the following snippet of code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">scheduledExecutor</span>
      <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);
scheduledExecutor.scheduleAtFixedRate(() -&gt; {
  <span class="hljs-type">ThreadMXBean</span> <span class="hljs-variable">threadBean</span>
    <span class="hljs-operator">=</span> ManagementFactory.getThreadMXBean();
  ThreadInfo[] threadInfo
    = threadBean.dumpAllThreads(<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);
  logger.info(() -&gt; <span class="hljs-string">"Platform threads: "</span> + threadInfo.length);
}, <span class="hljs-number">500</span>, <span class="hljs-number">500</span>, TimeUnit.MILLISECONDS);
</code></pre>
    <p class="normal">We rely on this code in the following three scenarios.</p>
    <h2 id="_idParaDest-480" class="heading-2">Running 10,000 tasks via the cached thread pool executor</h2>
    <p class="normal">Next, let’s <a id="_idIndexMarker1220"/>add a snippet of code that runs 10,000 tasks via <code class="inlineCode">newCachedThreadPool()</code> and platform threads. We also measure the time elapsed to execute these tasks:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
<span class="hljs-keyword">try</span> (<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorCached</span>
    <span class="hljs-operator">=</span> Executors.newCachedThreadPool()) {
  IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">10_000</span>).forEach(i -&gt; {
    executorCached.submit(() -&gt; {
      Thread.sleep(Duration.ofSeconds(<span class="hljs-number">1</span>));
      logger.info(() -&gt; <span class="hljs-string">"Task: "</span> + i);
      <span class="hljs-keyword">return</span> i;
    });
  });
}
logger.info(() -&gt; <span class="hljs-string">"Time (ms): "</span> 
  + (System.currentTimeMillis() - start));
</code></pre>
    <p class="normal">On my machine, it took 8,147 ms (8 seconds) to run these 10,000 tasks, using at peak 7,729 platform <a id="_idIndexMarker1221"/>threads. The following screenshot from <code class="inlineCode">jconsole</code> (JMX) reveals this information:</p>
    <figure class="mediaobject"><img src="../Images/B19665_10_14.png" alt="Figure 10.12.png"/></figure>
    <p class="packt_figref">Figure 10.14: Running 10,000 tasks via the cached thread pool executor</p>
    <p class="normal">Next, let’s repeat this test via a fixed thread pool.</p>
    <h2 id="_idParaDest-481" class="heading-2">Running 10,000 tasks via the fixed thread pool executor</h2>
    <p class="normal">Depending <a id="_idIndexMarker1222"/>on your machine, the previous test may finish successfully, or it may result in an <code class="inlineCode">OutOfMemoryError</code>. We can avoid this unpleasant scenario by using a fixed thread pool. For instance, let’s limit the number of platform threads to 200 via the following snippet of code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
<span class="hljs-keyword">try</span> (<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorFixed</span>
    <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">200</span>)) {
  IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">10_000</span>).forEach(i -&gt; {
    executorFixed.submit(() -&gt; {
      Thread.sleep(Duration.ofSeconds(<span class="hljs-number">1</span>));
      logger.info(() -&gt; <span class="hljs-string">"Task: "</span> + i);
      <span class="hljs-keyword">return</span> i;
    });
  });
}
logger.info(() -&gt; <span class="hljs-string">"Time (ms): "</span> 
  + (System.currentTimeMillis() - start));
</code></pre>
    <p class="normal">On my machine, it took 50,190 ms (50 seconds) to run these 10,000 tasks, using at peak 216 platform threads. The following screenshot from JMX reveals this information:</p>
    <figure class="mediaobject"><img src="../Images/B19665_10_15.png" alt="Figure 10.13.png"/></figure>
    <p class="packt_figref">Figure 10.15: Running 10,000 tasks via the fixed thread pool executor</p>
    <p class="normal">Obviously, a <a id="_idIndexMarker1223"/>smaller number of platform threads is reflected in performance. If we put 216 workers to do the job of 7,729 workers, of course, it will take longer. Next, let’s see how virtual threads will handle this challenge.</p>
    <h2 id="_idParaDest-482" class="heading-2">Running 10,000 tasks via the virtual thread per task executor</h2>
    <p class="normal">This time, let’s <a id="_idIndexMarker1224"/>see how the <code class="inlineCode">newVirtualThreadPerTaskExecutor()</code> can handle these 10,000 tasks. The code is straightforward:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
<span class="hljs-keyword">try</span> (ExecutorService executorVirtual
      = Executors.newVirtualThreadPerTaskExecutor()) {
  IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">10_000</span>).forEach(i -&gt; {
    executorVirtual.submit(() -&gt; {
      Thread.sleep(Duration.ofSeconds(<span class="hljs-number">1</span>));
      logger.info(() -&gt; <span class="hljs-string">"Task: "</span> + i);
      <span class="hljs-keyword">return</span> i;
    });
  });
}
logger.info(() -&gt; <span class="hljs-string">"Time (ms): "</span> 
  + (System.currentTimeMillis() - start));
</code></pre>
    <p class="normal">On my machine, it took 3,519 ms (3.5 seconds) to run these 10,000 tasks, using at peak 25 platform threads. The following screenshot from JMX reveals this information:</p>
    <figure class="mediaobject"><img src="../Images/B19665_10_16.png" alt="Figure 10.14.png"/></figure>
    <p class="packt_figref">Figure 10.16: Running 10000 tasks via the virtual thread per task executor</p>
    <p class="normal">Wow! How cool is this?! The resulting time is far and away the best in comparison with the previous tests, and it uses fewer resources (only 25 platform threads). So virtual threads really rock!</p>
    <p class="normal">I also strongly <a id="_idIndexMarker1225"/>recommend you check out the following benchmark: <a href="https://github.com/colincachia/loom-benchmark/tree/main"><span class="url">https://github.com/colincachia/loom-benchmark/tree/main</span></a>.</p>
    <p class="normal">Starting with JDK 21, JMX’s <code class="inlineCode">HotSpotDiagnosticMXBean</code> was enriched with the <code class="inlineCode">dumpThreads(String outputFile, ThreadDumpFormat format)</code> method. This method outputs a thread dump to the given file (<code class="inlineCode">outputFile</code>) in the given format (<code class="inlineCode">format</code>). The thread dump will contain all platform threads, but it may also contain some or all virtual threads.</p>
    <p class="normal">In the following code, we attempt to obtain a thread dump for all subtasks (threads) of a <code class="inlineCode">StructuredTaskScope</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">ShutdownOnSuccess</span> <span class="hljs-variable">scope</span>
  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">StructuredTaskScope</span>.ShutdownOnSuccess&lt;String&gt;()) {
    Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
          .&lt;Callable&lt;String&gt;&gt;map(id -&gt; () -&gt; fetchTester(id))
          .forEach(scope::fork);
  <span class="hljs-type">HotSpotDiagnosticMXBean</span> <span class="hljs-variable">mBean</span> <span class="hljs-operator">=</span> ManagementFactory
    .getPlatformMXBean(HotSpotDiagnosticMXBean.class);
  mBean.dumpThreads(Path.of(<span class="hljs-string">"dumpThreads.json"</span>)
    .toAbsolutePath().toString(), 
  HotSpotDiagnosticMXBean.ThreadDumpFormat.JSON);
  scope.join();
  <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (String) scope.result();
  logger.info(result);
}
</code></pre>
    <p class="normal">The <a id="_idIndexMarker1226"/>output file is named <code class="inlineCode">threadDump.json</code>, and you can find it in the root folder of the application. The part of the output that we are interested in is partially listed here:</p>
    <pre class="programlisting code"><code class="hljs-code">...
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"container"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"java.util.concurrent</span>
<span class="hljs-string">             .StructuredTaskScope$ShutdownOnSuccess@6d311334"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"parent"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"&lt;root&gt;"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"owner"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"1"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"threads"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"tid"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"22"</span>
    <span class="hljs-attr">"</span><span class="hljs-attr">name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"stack"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      ...
      <span class="hljs-string">"java.base\/java.lang.VirtualThread</span>
<span class="hljs-string">       .run(VirtualThread.java:311)"</span>
      <span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">},</span>
   <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"tid"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"24"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"stack"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      ...
      <span class="hljs-string">"java.base\/java.lang.VirtualThread</span>
<span class="hljs-string">        .run(VirtualThread.java:311)"</span>
      <span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">},</span>
    <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"tid"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"25"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"stack"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      ...
      <span class="hljs-string">"java.base\/java.lang.VirtualThread</span>
<span class="hljs-string">        .run(VirtualThread.java:311)"</span>
      <span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">],</span>
  <span class="hljs-attr">"threadCount"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"3"</span>
<span class="hljs-punctuation">}</span>
...
</code></pre>
    <p class="normal">As you can see, we have three virtual threads (#22, #24, and #25) that run subtasks of our scope. In the <a id="_idIndexMarker1227"/>bundled code, you can find the complete output.</p>
    <h1 id="_idParaDest-483" class="heading-1">Summary</h1>
    <p class="normal">This chapter covered 16 introductory problems about virtual threads and structured concurrency. You can see this chapter as preparation for the next one, which will cover more detailed aspects of these two topics.</p>
    <h1 class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
    <p class="normal"><a href="https://discord.gg/8mgytp5DGQ "><span class="url">https://discord.gg/8mgytp5DGQ</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1139613064111216156.png" alt="" role="presentation"/></p>
  </div>
</body></html>