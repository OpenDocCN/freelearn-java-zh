<html><head></head><body>
		<div id="_idContainer006">
			<h1 id="_idParaDest-16"><em class="italic"><a id="_idTextAnchor015"/>Chapter 1</em>: Starting jOOQ and Spring Boot</h1>
			<p>This chapter is a practical guide to start working with jOOQ (open source and free trial commercial) in Spring Boot applications. For convenience, let's assume that we have a Spring Boot stub application and plan to implement the persistence layer via jOOQ. </p>
			<p>The goal of this chapter is to highlight the fact that setting the environment for generating and executing SQL queries via jOOQ in a Spring Boot application is a job that can be accomplished almost instantly in any of the Java/Kotlin and Maven/Gradle combinations. Besides that, this is a good opportunity to have your first taste of the jOOQ DSL-fluent API and to get your first impressions.</p>
			<p>The topics of this chapter include the following:</p>
			<ul>
				<li>Starting jOOQ and Spring Boot instantly</li>
				<li>Using the jOOQ query DSL API to generate a valid SQL statement</li>
				<li>Executing the generated SQL and mapping the result set to a POJO</li>
			</ul>
			<p>Let's get started!</p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter01">https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter01</a>.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Starting jOOQ and Spring Boot instantly</h1>
			<p>Spring Boot provides <a id="_idIndexMarker000"/>support for jOOQ, and this aspect is introduced in <a id="_idIndexMarker001"/>the Spring Boot official documentation under the <em class="italic">Using jOOQ</em> section. Having built-in support for jOOQ makes our mission easier, since, among other things, Spring Boot is capable of dealing with aspects that involve useful default configurations and settings.</p>
			<p>Consider having <a id="_idIndexMarker002"/>a Spring Boot stub application that will run against MySQL and <a id="_idIndexMarker003"/>Oracle, and let's try to add jOOQ to this context. The goal is to use jOOQ as a SQL builder for constructing valid SQL statements and as a SQL executor that maps the result set to a POJO.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Adding the jOOQ open source edition</h2>
			<p>Adding the jOOQ open source edition into a Spring Boot application is quite straightforward.</p>
			<h3>Adding the jOOQ open source edition via Maven</h3>
			<p>From the <a id="_idIndexMarker004"/>Maven perspective, adding the jOOQ open source <a id="_idIndexMarker005"/>edition into a Spring Boot application starts from the <strong class="source-inline">pom.xml</strong> file. The jOOQ open source edition dependency<a id="_idIndexMarker006"/> is available at Maven Central (<a href="https://mvnrepository.com/artifact/org.jooq/jooq">https://mvnrepository.com/artifact/org.jooq/jooq</a>) and can be added like this:</p>
			<pre class="source-code">&lt;dependency&gt;</pre>
			<pre class="source-code">  &lt;groupId&gt;org.jooq&lt;/groupId&gt;</pre>
			<pre class="source-code">  &lt;artifactId&gt;jooq&lt;/artifactId&gt;</pre>
			<pre class="source-code">  &lt;version&gt;...&lt;/version&gt; &lt;!-- optional --&gt;</pre>
			<pre class="source-code">&lt;/dependency&gt;</pre>
			<p>Alternatively, if you prefer a Spring Boot starter, then rely on this one:</p>
			<pre class="source-code">&lt;dependency&gt;</pre>
			<pre class="source-code">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</pre>
			<pre class="source-code">  &lt;artifactId&gt;spring-boot-starter-jooq&lt;/artifactId&gt;</pre>
			<pre class="source-code">&lt;/dependency&gt;</pre>
			<p>If you are a fan <a id="_idIndexMarker007"/>of Spring Initializr (<a href="https://start.spring.io/">https://start.spring.io/</a>), then just select the jOOQ dependency from the corresponding list of dependencies.</p>
			<p>That's all! Note that <strong class="source-inline">&lt;version&gt;</strong> is optional. If <strong class="source-inline">&lt;version&gt;</strong> is omitted, then Spring Boot will <a id="_idIndexMarker008"/>properly choose the jOOQ version <a id="_idIndexMarker009"/>compatible with the Spring Boot version used by the application. Nevertheless, whenever you want to try a different jOOQ version, you can simply add <strong class="source-inline">&lt;version&gt;</strong> explicitly. At this point, the jOOQ open source edition is ready to be used to start developing the persistence layer of an application.</p>
			<h3>Adding the jOOQ open source edition via Gradle</h3>
			<p>From the <a id="_idIndexMarker010"/>Gradle perspective, adding the jOOQ <a id="_idIndexMarker011"/>open source edition into <a id="_idIndexMarker012"/>a Spring Boot application can be accomplished via a plugin named <strong class="source-inline">gradle-jooq-plugin</strong> (<a href="https://github.com/etiennestuder/gradle-jooq-plugin/">https://github.com/etiennestuder/gradle-jooq-plugin/</a>). This can be added to your <strong class="source-inline">build.gradle</strong>, as follows:</p>
			<pre class="source-code">plugins {</pre>
			<pre class="source-code">  id 'nu.studer.jooq' version ...</pre>
			<pre class="source-code">}</pre>
			<p>Of course, if you rely on Spring Initializr (<a href="https://start.spring.io/">https://start.spring.io/</a>), then just select a Gradle project, add the jOOQ dependency from the corresponding list of dependencies, and once the project is generated, add the <strong class="source-inline">gradle-jooq-plugin</strong> plugin. As you'll see in the next chapter, using <strong class="source-inline">gradle-jooq-plugin</strong> is quite convenient for configuring the jOOQ Code Generator.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Adding a jOOQ free trial (commercial edition)</h2>
			<p>Adding a free trial commercial edition of jOOQ (jOOQ Express, Professional, and Enterprise editions) to <a id="_idIndexMarker013"/>a Spring Boot project (overall, in any other type of project) requires a few preliminary steps. Mainly, these steps are needed because the jOOQ free trial commercial distributions are not available on Maven Central, so you have to manually download the <a id="_idIndexMarker014"/>one that you need from the jOOQ download page (<a href="https://www.jooq.org/download/">https://www.jooq.org/download/</a>). For instance, you can choose the most popular one, the jOOQ Professional distribution, which comes packaged as a ZIP archive. Once you have unzipped it, you can install it locally via the <strong class="source-inline">maven-install</strong> command. You can find these steps exemplified in a short movie in the bundled code (<em class="italic">Install_jOOQ_Trial.mp4</em>).</p>
			<p>For Maven applications, we use the jOOQ free trial identified as <strong class="source-inline">org.jooq.trial</strong> (for Java 17) or <strong class="source-inline">org.jooq.trial-java-{version}</strong>. When this book was written, the <strong class="source-inline">version</strong> placeholder could be 8 or 11, but don't hesitate to check for the latest updates. We prefer <a id="_idIndexMarker015"/>the former, so in <strong class="source-inline">pom.xml</strong>, we have the following:</p>
			<pre class="source-code">&lt;dependency&gt;</pre>
			<pre class="source-code">  &lt;groupId&gt;org.jooq.trial-java-8&lt;/groupId&gt;</pre>
			<pre class="source-code">  &lt;artifactId&gt;jooq&lt;/artifactId&gt;</pre>
			<pre class="source-code">  &lt;version&gt;...&lt;/version&gt;</pre>
			<pre class="source-code">&lt;/dependency&gt;</pre>
			<p>For Java/Gradle, you can do it, as shown in the following example, via <strong class="source-inline">gradle-jooq-plugin</strong>:</p>
			<pre class="source-code">jooq {</pre>
			<pre class="source-code">  version = '...'</pre>
			<pre class="source-code">  edition = nu.studer.gradle.jooq.JooqEdition.TRIAL_JAVA_8</pre>
			<pre class="source-code">}</pre>
			<p>For Kotlin/Gradle, you can do it like this:</p>
			<pre class="source-code">jooq {</pre>
			<pre class="source-code">  version.set(...)</pre>
			<pre class="source-code">  edition.set(nu.studer.gradle.jooq.JooqEdition.TRIAL_JAVA_8)</pre>
			<pre class="source-code">}</pre>
			<p>In this book, we will use jOOQ open source in applications that involve MySQL and PostgreSQL, and jOOQ free trial in applications that involve SQL Server and Oracle. These two database <a id="_idIndexMarker016"/>vendors are not supported in jOOQ open source.</p>
			<p>If you're interested in adding jOOQ in a Quarkus project then consider this resource: <a href="https://github.com/quarkiverse/quarkus-jooq">https://github.com/quarkiverse/quarkus-jooq</a></p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Injecting DSLContext into Spring Boot repositories</h2>
			<p>One of the <a id="_idIndexMarker017"/>most important interfaces <a id="_idIndexMarker018"/>of jOOQ is <strong class="source-inline">org.jooq.DSLContext</strong>. This interface represents the starting point of using jOOQ, and its main goal is to configure the behavior of jOOQ when executing queries. The default implementation of this interface is named <strong class="source-inline">DefaultDSLContext</strong>. Among the approaches, <strong class="source-inline">DSLContext</strong> can be created via an <strong class="source-inline">org.jooq.Configuration</strong> object, directly from a JDBC connection (<strong class="source-inline">java.sql.Connection</strong>), a data source (<strong class="source-inline">javax.sql.DataSource</strong>), and a dialect needed for translating the Java API query representation, written via jOOQ into a database-specific SQL query (<strong class="source-inline">org.jooq.SQLDialect</strong>). </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">For <strong class="source-inline">java.sql.Connection</strong>, jOOQ will give you full control of the connection life cycle (for example, you are responsible for closing this connection). On the other hand, connections acquired via <strong class="source-inline">javax.sql.DataSource</strong> will be automatically closed after query execution by jOOQ. Spring Boot loves data sources, therefore the connection management is already handled (acquire and return connection from/to the connection pool, transaction begin/commit/rollback, and so on).</p>
			<p>All jOOQ objects, including <strong class="source-inline">DSLContext</strong>, are created from <strong class="source-inline">org.jooq.impl.DSL</strong>. For creating a <strong class="source-inline">DSLContext</strong>, the <strong class="source-inline">DSL</strong> class exposes a <strong class="source-inline">static</strong> method named <strong class="source-inline">using()</strong>, which comes in several flavors. Of these, the most notable are listed next:</p>
			<pre class="source-code">// Create DSLContext from a pre-existing configuration</pre>
			<pre class="source-code">DSLContext ctx = DSL.using(configuration);</pre>
			<pre class="source-code">// Create DSLContext from ad-hoc arguments</pre>
			<pre class="source-code">DSLContext ctx = DSL.using(connection, dialect);</pre>
			<p>For example, connecting to the MySQL <strong class="source-inline">classicmodels</strong> database can be done as follows:</p>
			<pre class="source-code">try (Connection conn = DriverManager.getConnection(</pre>
			<pre class="source-code">    "jdbc:mysql://localhost:3306/classicmodels", </pre>
			<pre class="source-code">    "root", "root")) {</pre>
			<pre class="source-code">  DSLContext ctx = </pre>
			<pre class="source-code">    DSL.using(conn, SQLDialect.MYSQL);</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">} catch (Exception e) {</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">}</pre>
			<p>Alternatively, you can connect via a data source:</p>
			<pre class="source-code">DSLContext ctx = DSL.using(dataSource, dialect);</pre>
			<p>For example, connecting <a id="_idIndexMarker019"/>to the <a id="_idIndexMarker020"/>MySQL <strong class="source-inline">classicmodels</strong> database via a data source can be done as follows:</p>
			<pre class="source-code">DSLContext getContext() {</pre>
			<pre class="source-code">  MysqlDataSource dataSource = new MysqlDataSource();</pre>
			<pre class="source-code">  dataSource.setServerName("localhost");</pre>
			<pre class="source-code">  dataSource.setDatabaseName("classicmodels");</pre>
			<pre class="source-code">  dataSource.setPortNumber("3306");</pre>
			<pre class="source-code">  dataSource.setUser(props.getProperty("root");</pre>
			<pre class="source-code">  dataSource.setPassword(props.getProperty("root");</pre>
			<pre class="source-code">  return DSL.using(dataSource, SQLDialect.MYSQL);</pre>
			<pre class="source-code">}</pre>
			<p>But Spring Boot is capable of automatically preparing a ready-to-inject <strong class="source-inline">DSLContext</strong> based on <a id="_idIndexMarker021"/>our database settings. For <a id="_idIndexMarker022"/>example, Spring Boot can prepare <strong class="source-inline">DSLContext </strong>based on the MySQL database settings specified in <strong class="source-inline">application.properties</strong>:</p>
			<pre class="source-code">spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver</pre>
			<pre class="source-code">spring.datasource.url=jdbc:mysql://localhost:3306/</pre>
			<pre class="source-code">                 classicmodels?createDatabaseIfNotExist=true</pre>
			<pre class="source-code">spring.datasource.username=root</pre>
			<pre class="source-code">spring.datasource.password=root</pre>
			<pre class="source-code">spring.jooq.sql-dialect=MYSQL</pre>
			<p>Once Spring Boot detects the jOOQ presence, it uses the preceding settings to create <strong class="source-inline">org.jooq.Configuration</strong>, which is used to prepare a ready-to-inject <strong class="source-inline">DSLContext</strong>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">While <strong class="source-inline">DSLContext</strong> has a high degree of configurability and flexibility, Spring Boot performs only the minimum effort to serve a default <strong class="source-inline">DSLContext</strong> that can be injected and used immediately. As<a id="_idIndexMarker023"/> you'll see in this book (but especially in the official jOOQ manual – <a href="https://www.jooq.org/doc/latest/manual/">https://www.jooq.org/doc/latest/manual/</a>), <strong class="source-inline">DSLContext</strong> has tons of configurations and settings that allow taking control of almost anything that happens with our SQL statements.</p>
			<p>The <strong class="source-inline">DSLContext</strong> object provided by Spring Boot can be easily injected into our persistence repositories. For instance, the next snippet of code serves such a <strong class="source-inline">DSLContext</strong> object directly into <strong class="source-inline">ClassicModelsRepository</strong>:</p>
			<pre class="source-code">@Repository</pre>
			<pre class="source-code">public class ClassicModelsRepository {</pre>
			<pre class="source-code">  private final DSLContext ctx;</pre>
			<pre class="source-code">  public ClassicModelsRepository(DSLContext ctx) {</pre>
			<pre class="source-code">    this.ctx = ctx;</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">}</pre>
			<p>Don't conclude here that the application needs to keep a reference to <strong class="source-inline">DSLContext</strong>. That can <a id="_idIndexMarker024"/>still be used directly in a local variable, as <a id="_idIndexMarker025"/>you saw earlier (which means that you can have as many <strong class="source-inline">DSLContext</strong> objects as you want). It only means that, in a Spring Boot application, for most common scenarios, it is more convenient to simply inject it as shown previously.</p>
			<p>Internally, jOOQ can use <strong class="source-inline">java.sql.Statement</strong> or <strong class="source-inline">PreparedStatement</strong>. By default, and for very good and strong reasons, jOOQ uses <strong class="source-inline">PreparedStatement</strong>.</p>
			<p>Typically, the <strong class="source-inline">DSLContext</strong> object is labeled as <strong class="source-inline">ctx</strong> (used in this book) or <strong class="source-inline">dsl</strong>. But, other names such as <strong class="source-inline">dslContext</strong>, <strong class="source-inline">jooq</strong>, and <strong class="source-inline">sql</strong> are also good choices. Basically, you name it.</p>
			<p>Okay, so far, so good! At this<a id="_idIndexMarker026"/> point, we have access to <strong class="source-inline">DSLContext</strong> provided out <a id="_idIndexMarker027"/>of the box by Spring Boot, based on our settings from <strong class="source-inline">application.properties</strong>. Next, let's see <strong class="source-inline">DSLContext</strong> at work via jOOQ's query DSL API.</p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>Using the jOOQ query DSL API to generate valid SQL</h1>
			<p>Using the jOOQ query DSL API to generate valid SQL is a good start for exploring the jOOQ world. Let's <a id="_idIndexMarker028"/>take a simple SQL statement, and <a id="_idIndexMarker029"/>let's express it via jOOQ. In other words, let's use the jOOQ query DSL API to express a given SQL string query into the jOOQ object-oriented style. Consider the next SQL <strong class="source-inline">SELECT</strong> written in the MySQL dialect:</p>
			<pre class="source-code">SELECT * FROM `office` WHERE `territory` = ?</pre>
			<p>The SQL, <strong class="source-inline">SELECT * FROM `office` WHERE `territory` = ?</strong>, is written as a plain string. This query can be generated by jOOQ if it is written via the DSL API, as follows (the value of the <strong class="source-inline">territory</strong> binding variable is supplied by the user):</p>
			<pre class="source-code">ResultQuery&lt;?&gt; query = ctx.selectFrom(table("office"))</pre>
			<pre class="source-code">  .where(field("territory").eq(territory));</pre>
			<p>Alternatively, if we want to have the <strong class="source-inline">FROM</strong> clause closer to SQL look, then we can write it as follows:</p>
			<pre class="source-code">ResultQuery&lt;?&gt; query = ctx.select()</pre>
			<pre class="source-code">  .from(table("office"))                  </pre>
			<pre class="source-code">  .where(field("territory").eq(territory));</pre>
			<p>Most schemas are case-insensitive, but there are databases such as MySQL and PostgreSQL that prefer mostly lowercase, while others such as Oracle prefer mostly uppercase. So, writing the preceding query in Oracle style can be done as follows:</p>
			<pre class="source-code">ResultQuery&lt;?&gt; query = ctx.selectFrom(table("OFFICE"))</pre>
			<pre class="source-code">  .where(field("TERRITORY").eq(territory));</pre>
			<p>Alternatively, you can write it via an explicit call of <strong class="source-inline">from()</strong>:</p>
			<pre class="source-code">ResultQuery&lt;?&gt; query = ctx.select()</pre>
			<pre class="source-code">  .from(table("OFFICE"))                  </pre>
			<pre class="source-code">  .where(field("TERRITORY").eq(territory));</pre>
			<p>The jOOQ fluent API is a piece of art that looks like fluent English and, therefore, is quite intuitive to read and write. </p>
			<p>Reading the preceding queries is pure English: <em class="italic">select all offices from the OFFICE table where the TERRITORY column is equal to the given value</em>. </p>
			<p>Pretty <a id="_idIndexMarker030"/>soon, you'll be amazed at how fast <a id="_idIndexMarker031"/>you can write these queries in jOOQ.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">As you'll see in the next chapter, jOOQ can generate a Java-based schema that mirrors the one in the database via a feature named the<a id="_idIndexMarker032"/> jOOQ Code Generator. Once this feature is enabled, writing these queries becomes even simpler and cleaner because there will be no need to reference the database schema explicitly, such as the table name or the table columns. Instead, we will reference the Java-based schema.</p>
			<p class="callout">And, thanks to the Code Generator feature, jOOQ makes the right choices for us upfront almost everywhere. We no longer need to take care of queries' type-safety and case-sensitivity, or identifiers' quotation and qualification.</p>
			<p class="callout">The jOOQ Code Generator atomically boosts the jOOQ capabilities and increases developer productivity. This is why using the jOOQ Code Generator is the recommended way to exploit jOOQ. We will tackle the jOOQ Code Generator in the next chapter.</p>
			<p>Next, the jOOQ query (<strong class="source-inline">org.jooq.ResultQuery</strong>) must be executed against the database, and the result set will be mapped to a user-defined simple POJO.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/>Executing the generated SQL and mapping the result set</h1>
			<p>Executing the <a id="_idIndexMarker033"/>generated<a id="_idIndexMarker034"/> SQL and mapping the result set to a POJO via jOOQ can be done via the fetching methods available in the jOOQ API. For instance, the next snippet of code relies on the <strong class="source-inline">fetchInto()</strong> flavor:</p>
			<pre class="source-code">public List&lt;Office&gt; findOfficesInTerritory(String territory) {</pre>
			<pre class="source-code">  List&lt;Office&gt; result = ctx.selectFrom(table("office"))</pre>
			<pre class="source-code"><strong class="bold">    </strong>.where(field("territory").eq(territory))</pre>
			<pre class="source-code"><strong class="bold">    .fetchInto(Office.class); </strong></pre>
			<pre class="source-code">  return result;</pre>
			<pre class="source-code">}</pre>
			<p>What happened there?! Where did <strong class="source-inline">ResultQuery</strong> go? Is this black magic? Obviously not! It's just that jOOQ has immediately fetched results after constructing the query and mapped them to the <strong class="source-inline">Office</strong> POJO. Yes, the jOOQ's <strong class="source-inline">fetchInto(Office.class)</strong> or <strong class="source-inline">fetch().into(Office.class)</strong> would work just fine out of the box. Mainly, jOOQ executes the <a id="_idIndexMarker035"/>query and maps the result set to the <strong class="source-inline">Office</strong> POJO by <a id="_idIndexMarker036"/>wrapping and abstracting the JDBC complexity in a more object-oriented way. If we don't want to immediately fetch the results after constructing the query, then we can use the <strong class="source-inline">ResultQuery</strong> object like this:</p>
			<pre class="source-code">// 'query' is the ResultQuery object</pre>
			<pre class="source-code">List&lt;Office&gt; result = query.fetchInto(Office.class);</pre>
			<p>The <strong class="source-inline">Office</strong> POJO is available in the code bundled with this book.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">jOOQ has a comprehensive API for fetching and mapping a result set into collections, arrays, maps, and so on. We will detail these aspects later on in <a href="B16833_08.xhtml#_idTextAnchor128"><em class="italic">Chapter 8</em></a>, <em class="italic">Fetching and Mapping</em>.</p>
			<p>The complete <a id="_idIndexMarker037"/>application is named <em class="italic">DSLBuildExecuteSQL</em>. Since this can be used as a stub application, you can find it available for Java/Kotlin in combination with Maven/Gradle. These applications (along with, in fact, all the applications in this book) use Flyway for schema migration. As you'll see later, Flyway and jOOQ make a great team.</p>
			<p>So, let's quickly <a id="_idIndexMarker038"/>summarize this chapter before moving on to exploit the <a id="_idIndexMarker039"/>astonishing jOOQ Code Generator feature.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Summary</h1>
			<p>Note that we barely scratched the surface of jOOQ's capabilities by using it only for generating and executing a simple SQL statement. Nevertheless, we've already highlighted that jOOQ can generate valid SQL against different dialects and can execute and map a result set in a straightforward manner. </p>
			<p>In the next chapter, we learn how to trust jOOQ more by increasing its level of involvement. jOOQ will generate type-safe queries, POJOs, and DAOs on our behalf.</p>
		</div>
	</body></html>