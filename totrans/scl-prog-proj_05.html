<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Type Classes</h1>
                </header>
            
            <article>
                
<p>In this chapter, you will learn about concepts that are built on top of Scala. The concepts in this chapter will be abstract, and they will require some concentration to understand; do not feel bad if you do not get it right away. Each individual part is relatively easy to understand, but when you put them all together, things can get complicated.</p>
<p>We will be focusing on type classes, with a definition for each one. They will be followed by an example illustrating how type classes can be useful in typical programs. As these concepts can be difficult, we also suggest some optional exercises that can strengthen your understanding. You do not have to do them to be able to follow the rest of the chapter. The solutions to the exercises are available on GitHub.</p>
<p>The majority of type classes presented here come from a library called Cats, created by Typelevel.</p>
<p>In this chapter, we will cover the following type classes:</p>
<ul>
<li>scala.math.Ordering</li>
<li>org.scalactic.Equality</li>
<li>cats.Semigroup</li>
<li>cats.Monoid</li>
<li>cats.Functor</li>
<li>cats.Apply</li>
<li>cats.Applicative</li>
<li>cats.Monad</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding type classes</h1>
                </header>
            
            <article>
                
<p>A <strong>type class</strong> represents a group of types that share a common behavior. A type class is to a type what a class is to an object. As with traditional classes, a type class can define methods. These methods can be invoked on all types that belong to the type class.</p>
<p class="mce-root"><span>Type classes were introduced in the Haskell programming language. However, thanks to the power of</span> implicits<span>, we can also use them in Scala. In Scala, type classes are not built-in language constructs (like they are in Haskell) and, as a result, we need to write a bit of boilerplate code to define them.</span></p>
<p>In Scala, we declare a type class by using <kbd>trait</kbd>, which accepts a type parameter. For instance, let's define a <kbd>Combine</kbd> type class that allows for combining two objects into one, as follows:</p>
<pre><span>trait </span>Combine[<span>A</span>] {<br/>  <span>def </span>combine(x: <span>A</span>, y: <span>A</span>): <span>A<br/></span>}</pre>
<p>Then, we can define two type class instances for <kbd>Combine</kbd>, as follows:</p>
<ul>
<li>One for <kbd>Int</kbd>, which will add the two arguments</li>
<li>One for <kbd>String</kbd>, which will concatenate them</li>
</ul>
<p>The code definition is as follows:</p>
<pre><span>object </span>Combine {<br/>  <span>def </span>apply[<span>A</span>](<span>implicit </span>combineA: Combine[<span>A</span>]): Combine[<span>A</span>] = combineA<br/><br/>  <span>implicit val </span><span>combineInt</span>: Combine[Int] = <span>new </span>Combine[Int] {<br/>    <span>override def </span>combine(x: Int, y: Int): Int = x + y<br/>  }<br/><br/>  <span>implicit val </span><span>combineString</span>: Combine[<span>String</span>] = <span>new </span>Combine[<span>String</span>] {<br/>    <span>override def </span>combine(x: <span>String</span>, y: <span>String</span>) = x + y<br/>  }<br/>}</pre>
<p>First, we define an <kbd>apply</kbd> constructor for our type class, which just returns the implicit argument. Then, we declare the type class instances by using <kbd>implicit val</kbd>. This way, the compiler will be able <span>to </span>automatically discover them by using the implicit resolution rules that we saw in the previous section.</p>
<p>Now, we can instantiate and use our type class, as follows:</p>
<pre><span>Combine</span>[Int].combine(<span>1</span>, <span>2</span>)<br/><span>// res0: Int = 3<br/></span><span>Combine</span>[<span>String</span>].combine(<span>"Hello"</span>, <span>" type class"</span>)<br/><span>// res1: String = Hello type class<br/></span></pre>
<p>When we call <kbd>Combine[Int]</kbd>, we actually call <kbd>Combine.apply[Int]</kbd>. Since our <kbd>apply</kbd> function accepts an implicit parameter of the type <kbd>Combine[Int]</kbd>, the compiler tries to find it. One of the implicit resolution rules is to search in the companion object of the argument's type.</p>
<p>As we declared <kbd>combineInt</kbd> in the companion object of <kbd>Combine</kbd>, the compiler uses it as the argument for <kbd>Combine.apply</kbd>.</p>
<p>Once we have obtained an instance of the <kbd>Combine</kbd> type class, we can invoke its method, <kbd>combine</kbd>. When we call it with two <kbd>Int</kbd> it will sum them, and when we call it with two <kbd>String</kbd> it will concatenate them.</p>
<p>So far, so good; but, this is a bit cumbersome to use. It would be more practical to call <kbd>combine</kbd> as if it were a method on <kbd>Int</kbd> or <kbd>String</kbd>.</p>
<p>As you saw in the previous section, we can define an implicit class inside of the <kbd>Combine</kbd> object, as follows:</p>
<pre>object Combine {<br/>...<br/>  implicit class CombineOps[A](val x: A)(implicit combineA: Combine[A]) {<br/>    def combine(y: A): A = combineA.combine(x, y)<br/>  }<br/>}</pre>
<p>This implicit class allows us to call <kbd>combine</kbd> on any type <kbd>A</kbd> that has a type class instance <kbd>Combine[A]</kbd>. Therefore, we can now call <kbd>combine</kbd> on <kbd>Int</kbd> or <kbd>String</kbd>, as follows:</p>
<pre><span>2</span>.combine(<span>3</span>)<br/><span>// res2: Int = 5<br/></span><span>"abc" </span>combine <span>"def"</span><br/><span>// res3: String = abcdef</span></pre>
<p>It might not look impressive; you might say that we merely gave another name to the <kbd>+</kbd> method. The key benefit of using type classes is that we can make the <kbd>combine</kbd> method available for any other type, without having to change it.</p>
<p>In traditional object-oriented programming, you would have to change all classes and make them extend a trait, which is not always possible.</p>
<p>Type classes allow us to morph a type into another one on demand (in our example, from <kbd>Int</kbd> to <kbd>Combine</kbd>). This is what we call <strong>ad hoc polymorphism</strong>.</p>
<p>Another key benefit is that by using <kbd>implicit def</kbd>, we can generate type class instances for parameterized types, such as <kbd>Option</kbd> or <kbd>Vector</kbd>. All we have to do is add them in the <kbd>Combine</kbd> companion object:</p>
<pre>object Combine {<br/>...<br/>  implicit def combineOption[A](implicit combineA: Combine[A])<br/>  : Combine[Option[A]] = new Combine[Option[A]] {<br/>    override def combine(optX: Option[A], optY: Option[A]): Option[A] =<br/>      for {<br/>        x &lt;- optX<br/>        y &lt;- optY<br/>      } yield combineA.combine(x, y)<br/>  }<br/>}</pre>
<p>As long as we have an implicit <kbd>Combine[A]</kbd> for a type parameter <kbd>A</kbd>, our function, <kbd>combineOption</kbd>, can generate <kbd>Combine[Option[A]]</kbd>.</p>
<p>This pattern is extremely powerful; it lets us generate type class instances by using other type class instances! The compiler will automatically find the right generator, based on its return type.</p>
<p>This is so common that Scala provides some syntactic sugar to simplify the definitions of such functions. We can rewrite <kbd>combineOption</kbd> as follows:</p>
<pre><span>implicit def </span>combineOption<strong>[<span>A</span>: Combine]</strong>: Combine[Option[<span>A</span>]] = <span>new </span>Combine[Option[<span>A</span>]] {<br/>  <span>override def </span>combine(optX: Option[<span>A</span>], optY: Option[<span>A</span>]): Option[<span>A</span>] =<br/>    <span>for </span>{<br/>      x &lt;- optX<br/>      y &lt;- optY<br/>    } <span>yield </span><strong><span>Combine</span>[<span>A</span>]</strong>.combine(x, y)<br/>}</pre>
<p>Having a function that has a type parameter declared with <kbd>A: MyTypeClass</kbd> is equivalent to having an implicit parameter of the type <kbd>MyTypeClass[A]</kbd>.</p>
<p>However, when we use this syntax, we do not have a name for that implicit; we just have it in the current scope. Having it in scope is sufficient to call any other function that accepts an implicit parameter of the type <kbd>MyTypeClass[A]</kbd>.</p>
<p>That is why we can call <kbd>Combine.apply[A]</kbd> in the preceding example. With this <kbd>combineOption</kbd> definition, we can now call <kbd>combine</kbd> on <kbd>Option</kbd>, too:</p>
<pre><span>Option</span>(<span>3</span>).combine(<span>Option</span>(<span>4</span>))<br/><span>// res4: Option[Int] = Some(7)<br/></span><span>Option</span>(<span>3</span>) combine Option.<span>empty<br/></span><span>// res5: Option[Int] = None<br/></span><span>Option</span>(<span>"Hello "</span>) combine <span>Option</span>(<span>" world"</span>)<br/><span>// res6: Option[String] = Some(Hello  world)</span></pre>
<p class="mce-root">Exercise: Define a type class instance for <kbd>Combine[Vector[A]]</kbd> that concatenates two vectors.</p>
<p class="mce-root">Exercise: Define a type class instance for <kbd>Combine[(A, B)]</kbd> that combines the first and second elements of two tuples. For instance, <kbd>(1, "Hello ") combine (2, "World")</kbd> should return <kbd>(3, "Hello World")</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type class recipe</h1>
                </header>
            
            <article>
                
<p>To summarize, if we want to create a type class, we have to perform the following steps:</p>
<ol>
<li>
<p>Create <kbd>trait</kbd>, <kbd>MyTypeClass[A]</kbd>, that accepts a parameterized type <kbd>A</kbd>. It represents the type class interface.</p>
</li>
<li>
<p>Define an <kbd>apply[A]</kbd> function in the companion object of <kbd>MyTypeClass</kbd>, in order to facilitate the instantiation of type class instances.</p>
</li>
<li>
<p>Provide implicit instances of <kbd>trait</kbd> for all of the desired types (<kbd>Int</kbd>, <kbd>String</kbd>, <kbd>Option</kbd>, and so on).</p>
</li>
<li>
<p>Define an implicit conversion to an <kbd>Ops</kbd> class, so that we can call methods of the type class as if they were declared in the target type (like you saw previously, with <kbd>2.combine(3)</kbd>).</p>
</li>
</ol>
<p>These definitions can be written manually, like in the previous section. Alternatively, you can use <strong>simulacrum</strong> to generate some of them for you. This has the double benefit of reducing boilerplate code and ensuring some consistency. You can check it out here: <a href="https://github.com/mpilquist/simulacrum">https://github.com/mpilquist/simulacrum</a>.</p>
<p class="mce-root">Exercise: Use simulacrum to define the <kbd>Combine</kbd> type class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Common type classes</h1>
                </header>
            
            <article>
                
<p>In a typical project, you will not create many of your own type classes. Since type classes capture behaviors that are common across several types, it is likely that someone else has already implemented a type class similar to what you need, located in a library. It is usually more productive to reuse type classes defined in the SDK (or in third-party libraries) than to try and define your own.</p>
<p>In general, these libraries define predefined instances of a type class for the SDK types (<kbd>String</kbd>, <kbd>Int</kbd>, <kbd>Option</kbd>, and so on). You would typically reuse these instances to derive instances for your own types.</p>
<p>In this section, we will present the type classes that you are most likely to encounter, and how to use them to solve day-to-day programming challenges.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">scala.math.Ordering</h1>
                </header>
            
            <article>
                
<p><kbd>Ordering</kbd> is an SDK type class that represents a strategy to sort the instances of a type. The most common use case is to sort the elements of a collection, as follows:</p>
<pre class="western"><span>Vector</span>(<span>1</span>,<span>3</span>,<span>2</span>).sorted
// res0: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3)</pre>
<p>If you look at the declaration of <kbd>sorted</kbd>, you will see that it accepts an implicit, <kbd>Ordering[B]</kbd>:</p>
<pre class="western"><span>def sorted[B &gt;: A](implicit ord: Ordering[B]): Repr</span></pre>
<p>When we called <kbd>sorted</kbd> on our <kbd>Vector[Int]</kbd>, the compiler found an implicit value of the type <kbd>Ordering[Int]</kbd> to pass to the function. This implicit was found in the companion object of <kbd>Ordering</kbd>, which also defines instances for <kbd>String</kbd>, <kbd>Long</kbd>, <kbd>Option</kbd>, <kbd>Tuples</kbd>, and so on.</p>
<p>We can define an instance of the type class for <kbd>LocalDate</kbd>, so that we can compare dates, or sort them more easily:</p>
<pre class="western"><span>import java.time.LocalDate</span>
<span>implicit val dateOrdering: Ordering[LocalDate] =   <br/>  Ordering.fromLessThan[LocalDate](_ isBefore _)</span>
<span>import Ordering.Implicits._</span>
<span>LocalDate.of(2018, 5, 18) &lt; LocalDate.of(2017, 1, 1)</span>
<span>// res1: Boolean = false</span>
<span>Vector(<br/>  LocalDate.of(2018, 5, 18), <br/>  LocalDate.of(2018, 6, 1)<br/>).sorted(dateOrdering.reverse)</span>
<span>// res2: Vector[LocalDate] = Vector(2018-06-01, 2018-05-18)</span></pre>
<p>With <kbd>Ordering[LocalDate]</kbd> and <kbd>Ordering.Implicits</kbd> in scope, we can use the <kbd>&lt;</kbd> operator to compare dates. <kbd>Ordering.Implicits</kbd> also defines other useful pimped methods, such as <kbd>&lt;</kbd>, <kbd>&gt;</kbd>, <kbd>&lt;=</kbd>, <kbd>&gt;=</kbd>, <kbd>max</kbd>, and <kbd>min</kbd>.</p>
<p>We can also easily sort <kbd>Vector[LocalDate]</kbd> in reverse order by using a reversed <kbd>Ordering[LocalDate]</kbd>. This is more efficient than sorting in ascending order and then reversing the vector.</p>
<p class="mce-root">Exercise: Define an <kbd>Ordering[Person]</kbd> that can order instances of <kbd>case class Person(name: String, age: Int)</kbd> from the oldest to the youngest. You will need to use <kbd>Ordering.by</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">org.scalactic.Equality</h1>
                </header>
            
            <article>
                
<p>The <kbd>Equality</kbd> type class is used by ScalaTest unit tests whenever you write assertions, such as the following:</p>
<pre>actual shouldBe expected<br/>actual should === (expected)</pre>
<p>Most of the time, you will not have to worry about it; the default instance compares types by using the <kbd>equals</kbd> method. However, whenever you compare double values or classes that contain double attributes, it becomes necessary to provide a different <kbd>Equality</kbd> instance.</p>
<p>Consider the following unit test:</p>
<pre class="western"><span>class </span>EqualitySpec <span>extends </span>WordSpec <span>with </span>Matchers <span>with </span>TypeCheckedTripleEquals{
  <span>"Equality" </span><span>should {</span>
    <span>"allow to compare two Double</span><span>s</span><span> with a tolerance" </span><span>in {</span>
      <span>1.6 </span><span>+ </span><span>1.8 </span><span>should === (</span><span>3.4</span><span>)</span>
    <span>}</span>
  <span>}</span>
}</pre>
<p>This test should pass, right? Wrong! Try to run it; the assertion fails, as follows:</p>
<pre>3.4000000000000004 did not equal 3.4</pre>
<p>This is because <kbd>Double</kbd> is an IEEE754 double-precision floating point number.</p>
<p>As such, some decimal numbers cannot be represented exactly with <kbd>Double</kbd>. To make our test pass, we need to provide an <kbd>Equality[Double]</kbd> instance that will return true if the absolute difference between the two numbers is less than a certain tolerance:</p>
<pre class="western"><span>class </span>EqualitySpec <span>extends </span>WordSpec <span>with </span>Matchers <span>with <br/></span> TypeCheckedTripleEquals{
  <span>implicit val </span><span>doubleEquality</span><span>: Equality[Double] = <br/>  TolerantNumerics.tolerantDoubleEquality(</span><span>0.0001</span><span>)</span>
  <span>"Equality" </span><span>should {...</span><span>}</span></pre>
<p>Run the test again; it will pass.</p>
<p class="mce-root">Exercise: Implement a type class derivation, <kbd>Equality[Vector[A]]</kbd>, so that we can compare two <kbd>Vector[Double]</kbd> instances with a tolerance.</p>
<p>The following is the declaration of the equality instance that you have to implement in the exercise:</p>
<pre class="western"><span>class EqualitySpec extends WordSpec with Matchers with TypeCheckedTripleEquals{</span>
  <span>implicit val </span><span>doubleEquality</span><span>: Equality[Double] = <br/>  TolerantNumerics.tolerantDoubleEquality(</span><span>0.0001</span><span>)</span>
<span>  implicit def vectorEquality[A](implicit eqA: Equality[A]):   <br/>  Equality[Vector[A]] = ???</span></pre>
<p>Once you have done the exercise, it should make the test pass, as follows:</p>
<pre class="western"><span>"Equality" should {</span>
<span>  (...)</span>
<span>  "allow to compare two Vector[Double] with a tolerance" in {</span>
<span>    Vector(1.6 + 1.8, 0.0051) should === (Vector(3.4, 0.0052))</span>
<span>  }</span>
<span>}</span></pre>
<p>For more information about floating point number encoding, please refer to <a href="https://www.javaworld.com/article/2077257/learn-java/floating-point-arithmetic.html">https://www.javaworld.com/article/2077257/learn-java/floating-point-arithmetic.html</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">cats.Semigroup</h1>
                </header>
            
            <article>
                
<p>In the type class introduction, we defined a <kbd>Combine</kbd> type class. It turns out that this type class is already defined in the Cats library. Its name is <kbd>Semigroup</kbd>; this name comes from the mathematical representation of this algebraic structure.</p>
<p>Open it in IntelliJ to see how it is defined:</p>
<pre class="western"><span>/**</span>
<span> * A semigroup is any set `A` with an associative operation (`combine`).</span>
<span> */</span>
<span>trait Semigroup[@sp(Int, Long, Float, Double) A] extends Any with Serializable {</span>
<span>  /**</span>
<span>   * Associative operation taking which combines two values.</span>
<span>   */</span>
<span>  def combine(x: A, y: A): A</span>
<span>(...)</span>
<span>}</span></pre>
<p>The <kbd>@sp</kbd> annotation is an optimization to avoid the boxing/unboxing of primitive types. Apart from that, the definition of <kbd>Semigroup</kbd> is the same as our <kbd>Combine</kbd> type class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Laws</h1>
                </header>
            
            <article>
                
<p>The documentation mentions a very important point: the instances of the type class must implement an associative combine function.</p>
<p>This means that they must verify the following law:</p>
<pre>a combine (b combine c) = (a combine b) combine c</pre>
<p>Most type classes in Cats have their own specific laws. The library guarantees that the type class instances that it defines verify this law. However, if you implement your own instance of a type class, it is your responsibility to verify that it does not break any law.</p>
<p>A user of a type class instance expects that it verifies all of the laws of the type class; it is part of the type class’s contract.</p>
<div class="mce-root packt_infobox">A type class contract is the type class trait plus the laws.</div>
<p>When a type class verifies certain laws, you can reason about generic code more easily, and you can confidently apply some transformations.</p>
<p>For instance, if you know that the associativity law is verified, you can evaluate <kbd>a combine b combine c combine d</kbd> in parallel: one thread can evaluate <kbd>(a combine b)</kbd>, while another one evaluates <kbd>(c combine d)</kbd>.</p>
<p>Cats provide a <kbd>laws</kbd> module to help check your type class instances. You can check that your type class respects the laws by writing unit tests. This will not be detailed in this book; if you are interested in more information, you can go to <a href="https://typelevel.org/cats/typeclasses/lawtesting.html">https://typelevel.org/cats/typeclasses/lawtesting.html</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Usage examples</h1>
                </header>
            
            <article>
                
<p>Cats provide several derivations of the <kbd>Semigroup</kbd> type class. It also declares a <kbd>|+|</kbd> operator in <kbd>SemigroupOps</kbd>, which is an alias for <kbd>combine</kbd>.</p>
<p>Some examples are as follows:</p>
<pre class="western"><span>import cats.implicits._</span>
<span>1 |+| 2</span>
<span>// res0: Int = 3</span>
<span>"Hello " |+| "World !"</span>
<span>// res1: String = Hello World !</span>
<span>(1, 2, "Hello ") |+| (2, 4, "World !")</span>
<span>// res2: (Int, Int, String) = (3,6,Hello World !)</span></pre>
<p>Thanks to the built-in derivations brought up with <kbd>import cats.implicits._</kbd>, we can combine <kbd>Int</kbd>, <kbd>String</kbd>, <kbd>Tuple2</kbd>, and <kbd>Tuple3</kbd>.</p>
<p>We can also combine some parameterized types, such as <kbd>Option</kbd> and <kbd>Vector</kbd>:</p>
<pre class="western"><span>Vector(1, 2) |+| Vector(3, 4)</span>
<span>// res3: Vector[Int] = Vector(1, 2, 3, 4)</span>
<span>Option(1) |+| Option(2)</span>
<span>// res4: Option[Int] = Some(3)</span>
<span>Option(1) |+|  None |+| Option(2)</span>
<span>// res5: Option[Int] = Some(3)</span></pre>
<p>For <kbd>Option</kbd>, notice that an empty <kbd>Option</kbd> is ignored whenever we combine it with a non-empty <kbd>Option</kbd>.</p>
<p>In <a href="f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml">Chapter 3</a>, <em>Handling Errors</em>, you saw that <kbd>Option</kbd> was one way of handling errors, and you learned that whenever an error message is needed, you can use <kbd>Either</kbd> instead of <kbd>Option</kbd>.</p>
<p>What happens, then, if we call <kbd>combine</kbd> on <kbd>Either</kbd>? Consider the following code:</p>
<pre class="western"><span>1.asRight |+| 2.asRight</span>
<span>// res6: Either[B,Int] = Right(3)</span>
<span>1.asRight[String] |+| 2.asRight |+| "error".asLeft</span>
<span>// res7: Either[String,Int] = Left(error)</span>
<span>"error1".asLeft[Int] |+| "error2".asLeft</span>
<span>// res8: Either[String,Int] = Left(error1)</span></pre>
<p>The <kbd>|+|</kbd> (or <kbd>combine</kbd>) function returns the first argument of type <kbd>Left</kbd>. If all the combined values are of type Right, their values are combined and put in <kbd>Right</kbd>.</p>
<p>In the first line, all the combined values are of type <kbd>Right</kbd>, hence the result is a <kbd>Right(3)</kbd>, because <kbd>3</kbd>  is the result of <kbd>combine</kbd> applied to <kbd>1</kbd> and <kbd>2</kbd>.</p>
<p>In the second line, the first combined value of type <kbd>Left</kbd> is <kbd>Left("error")</kbd>, hence the result is also <kbd>Left("error")</kbd>.</p>
<p>In the third line, the first combined value of type <kbd>Left</kbd> is  <kbd>Left("error1")</kbd>, hence the result is <kbd>Left("error1")</kbd>.</p>
<p class="mce-root">Exercise: Use the <kbd>|+|</kbd> operator to combine instances of <kbd>ValidatedNel[String, Int]</kbd>.<br/>
What happens when you combine several invalid values?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">cats.Monoid</h1>
                </header>
            
            <article>
                
<p>A <kbd>Monoid</kbd> is <kbd>Semigroup</kbd> with an additional <kbd>empty</kbd> function, also called an <strong>identity element</strong>.</p>
<p>The following is an extract of this trait's definition in Cats:</p>
<pre class="western"><span>trait Monoid[@sp(Int, Long, Float, Double) A] extends Any with Semigroup[A] {</span>
<span>  /**</span>
<span>   * Return the identity element for this monoid.</span>
<span>   */</span>
<span>  def empty: A</span></pre>
<p>The <kbd>Monoid</kbd> trait extends the <kbd>Semigroup</kbd> trait. As such, it has all of the methods of <kbd>Semigroup</kbd>, plus this additional <kbd>empty</kbd> method. We have already seen several examples of the <kbd>combine</kbd> operation of <kbd>Semigroup</kbd>'s for different types.</p>
<p>Let’s see what happens when we call <kbd>empty</kbd> for the same types, as follows:</p>
<pre class="western"><span>import cats.implicits._</span>
<span>import cats.kernel.Monoid</span>
<span>Monoid[Int].empty</span>
<span>// res0: Int = 0</span>
<span>Monoid[String].empty</span>
<span>// res1: String = </span>
<span>Monoid[Option[Double]].empty</span>
<span>// res2: Option[Double] = None</span>
<span>Monoid[Vector[Int]].empty</span>
<span>// res2: Vector[Int] = Vector()</span>
<span>Monoid[Either[String, Int]].empty</span>
<span>// res4: Either[String,Int] = Right(0)</span></pre>
<p>For each type, the <kbd>empty</kbd> element is quite natural: <kbd>0</kbd> for <kbd>Int</kbd>, <kbd>None</kbd> for <kbd>Option</kbd>, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Laws</h1>
                </header>
            
            <article>
                
<p>We can see why this <kbd>empty</kbd> function is called the identity element; if you combine any object with the identity element, it returns the same object, as follows:</p>
<pre class="western"><span>(3 |+| Monoid[Int].empty) == 3</span>
<span>("Hello identity" |+| Monoid[String].empty) == "Hello identity"</span>
<span>(Option(3) |+| Monoid[Option[Int]].empty) == Option(3)</span></pre>
<p>This property is formally defined by the identity laws, as follows:</p>
<ul>
<li>Left identity: For all <kbd>x</kbd> of type <kbd>A</kbd>, <kbd>Monoid[A].empty |+| x == x</kbd></li>
<li>Right identity: For all <kbd>x</kbd> <span>of type</span> <kbd>A</kbd><span>,</span> <kbd>x |+| Monoid[A].empty == x</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Usage examples</h1>
                </header>
            
            <article>
                
<p>This is interesting—how can we use <kbd>Monoid</kbd> in our day-to-day programs? The most compelling use case is to fold data structures. When you have <kbd>Monoid[A]</kbd>, it is trivial to combine all of the elements of <kbd>Vector[A]</kbd> to obtain one <kbd>A</kbd>. For instance, we can get the sum of all of the elements of <kbd>Vector[Int]</kbd>, as follows:</p>
<pre class="western"><span>Vector(1,2,3).combineAll</span>
<span>// res8: Int = 6</span></pre>
<p>This is equivalent to calling <kbd>foldLeft</kbd> on <kbd>Vector</kbd>:</p>
<pre class="western"><span>Vector(1, 2, 3).foldLeft(0) { case (acc, i) =&gt; acc + i }</span></pre>
<p>Indeed, <kbd>foldLeft</kbd> accepts two arguments, as follows:</p>
<ul>
<li>A start value, for which we can pass the monoid's empty value</li>
<li>A function, for which we can pass the monoid's <kbd>combine</kbd> function</li>
</ul>
<p>Cats also provide a <kbd>foldMap</kbd> function, which lets you transform the elements of a collection into <kbd>Monoid</kbd> before folding them:</p>
<pre class="western"><span>Vector("1", "2", "3").foldMap(s =&gt; (s, s.toInt))</span>
<span>// res10: (String, Int) = (123,6)</span></pre>
<p class="mce-root">Exercise: Implement an instance of <kbd>Monoid[Int]</kbd> to multiply all of the elements of a <kbd>Vector[Int]</kbd>.</p>
<p class="mce-root">Exercise: Use <kbd>foldMap</kbd> to compute the average of <kbd>Vector[Double]</kbd>.</p>
<p class="mce-root">Hint: The return type of the call to <kbd>foldMap</kbd> should be <kbd>(Int, Double)</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Higher-kinded types</h1>
                </header>
            
            <article>
                
<p>Before exploring other type classes, it would be useful to be familiar with the concept of <strong>higher-kinded</strong> types and <strong>arities</strong>.<br/>
You are already familiar with values and functions. A value is a literal or an object, such as <kbd>1</kbd>, <kbd>false</kbd>, or <kbd>"hello world"</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Arity</h1>
                </header>
            
            <article>
                
<p>A function takes one or many values as parameters and returns another value.<br/>
The <strong>arity</strong> of a function is the number of parameters it takes.<br/>
For instance:</p>
<ul>
<li>A <strong>nullary</strong> (arity 0) function does not take any parameter</li>
<li>A <strong>unary</strong> (arity 1) function takes only one parameter</li>
<li>A <strong>binary</strong> (arity 2) function takes two parameters</li>
</ul>
<p>A <strong>type constructor</strong> is a type that accepts parameters. It is called type constructor, because it constructs a concrete type when we pass a concrete type to it. For instance, <kbd>Option[A]</kbd> is a type constructor. When we pass a concrete type <kbd>Int</kbd> to it, we obtain a concrete type <kbd>Option[Int]</kbd>.</p>
<p>As type constructors can accept 0 to n arguments, the concept or arity also applies here:</p>
<ul>
<li>A nullary type does not take any parameter. It is a concrete type—<kbd>Int</kbd>, <kbd>Boolean</kbd>, and many more</li>
<li>A unary type takes one parameter—<kbd>Option[A]</kbd>, <kbd>Vector[A]</kbd></li>
<li>A binary type takes two parameters—<kbd>Either[L, R]</kbd>, <kbd>Map[K, V]</kbd></li>
<li>A ternary type takes three parameters—<kbd>Tuple3[A, B, C]</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Higher-order function</h1>
                </header>
            
            <article>
                
<p>The <strong>order</strong> of a function is the nesting depth of function arrows:</p>
<ul>
<li>Order 0—values, for instance, <kbd>1</kbd>, <kbd>false</kbd> or <kbd>"hello"</kbd></li>
<li>Order 1—functions <kbd>A =&gt; B</kbd>, for instance <kbd>def addOne: Int =&gt; Int = x =&gt; x + 1</kbd></li>
<li>Order 2—higher-order functions <kbd>A =&gt; B =&gt; C</kbd>, for instance:</li>
</ul>
<pre style="padding-left: 60px">def map: Vector[Int] =&gt; (Int =&gt; Int) =&gt; Vector[Int] = <br/>                                        xs =&gt; f =&gt; xs.map(f)</pre>
<ul>
<li>Order 3—higher-order functions <kbd>A =&gt; B =&gt; C =&gt; D</kbd></li>
</ul>
<p>Any function of an order strictly greater than <kbd>1</kbd> is a higher-order function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Higher-kinded types</h1>
                </header>
            
            <article>
                
<p>It turns out that similar concepts exist with types and <strong>kinds</strong>:</p>
<ul>
<li>The kind of ordinary types such as <kbd>Int</kbd> or <kbd>Boolean</kbd> is <kbd>*</kbd></li>
<li>The kind of unary type constructors is <kbd>* -&gt; *</kbd>, for instance, <kbd>Option</kbd> or <kbd>List</kbd></li>
<li>The kind of binary type constructors is <kbd>(*, *) -&gt; *</kbd>, for instance, <kbd>Either</kbd> or <kbd>Map</kbd></li>
</ul>
<p>Similarly to functions and order, we can order kinds by the number of type arrow <kbd>-&gt;</kbd> they have:</p>
<ul>
<li>Order 0 (<kbd>*</kbd>): Ordinary types such as <kbd>Int</kbd>, <kbd>Boolean</kbd>, or <kbd>String</kbd></li>
<li>Order 1 (<kbd>* -&gt; *</kbd> or <kbd>(*, *) -&gt; *</kbd>): Type constructors <kbd>Option</kbd>, <kbd>Vector</kbd>, <kbd>Map</kbd>, and many more</li>
<li>Order 2 (<kbd>(* -&gt; *) -&gt; *</kbd>): Higher-kinded types <kbd>Functor</kbd>, <kbd>Monad</kbd>, and many more</li>
</ul>
<p>A <strong>higher-kinded</strong> type is a type constructor that has strictly more than one arrow <kbd>-&gt;</kbd>. In the following section, we are going to explore type classes that are defined using higher-kinded types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">cats.Functor</h1>
                </header>
            
            <article>
                
<p><kbd>Functor</kbd> is a <strong>higher-kinded</strong> <strong>type</strong> of <strong>arity</strong> one. It accepts a unary type parameter <kbd>F[_]</kbd>. In other words, its type parameter must be a type that has a type parameter itself; for instance, <kbd>Option[A]</kbd>, <kbd>Vector[A]</kbd>, <kbd>Future[A]</kbd>, and so on. It declares a <kbd>map</kbd> method that can transform the elements inside of <kbd>F</kbd>. Here is a simplified definition of <kbd>cats.Functor</kbd>:</p>
<pre class="western"><span>trait Functor[F[_]] {</span>
<span>  def map[A, B](fa: F[A])(f: A =&gt; B): F[B]</span></pre>
<p class="mce-root">This should be familiar. We have already seen several classes of the SDK that define a <kbd>map</kbd> function doing the same thing: <kbd>Vector</kbd>, <kbd>Option</kbd>, and so on. Hence, you might wonder why you would ever need to use an instance of <kbd>Functor[Option]</kbd> or <kbd>Functor[Vector]</kbd>; they would only define a <kbd>map</kbd> function that is already available.</p>
<p>One advantage of having this <kbd>Functor</kbd> abstraction in Cats is that it lets us write more generic functions:</p>
<pre class="western"><span>import cats.Functor</span>
<span>import cats.implicits._</span>
<span>def addOne[F[_] : Functor](fa: F[Int]): F[Int] = fa.map(_ + 1)</span></pre>
<p>This function adds <kbd>1</kbd> for any <kbd>F[Int]</kbd> that has a <kbd>Functor</kbd> type class instance. The only thing I know about <kbd>F</kbd> is that it has a <kbd>map</kbd> operation. Hence, this function will work for many parameterized types such as <kbd>Option</kbd> or <kbd>Vector</kbd>:</p>
<pre class="western"><span>addOne(Vector(1, 2, 3))</span>
<span>// res0: Vector[Int] = Vector(2, 3, 4)</span>
<span>addOne(Option(1))</span>
<span>// res1: Option[Int] = Some(2)</span>
<span>addOne(1.asRight)</span>
<span>// res2: Either[Nothing,Int] = Right(2)</span></pre>
<p>Our function, <kbd>addOne</kbd>, applies the principle of the least power; given a choice of solutions, it picks the least powerful solution capable of solving your problem.</p>
<p>We use a parameter type that is more generic, and hence, less powerful (it only has one <kbd>map</kbd> function). This makes our function more reusable, easier to read, and easier to test:</p>
<ul>
<li><strong>More reusable</strong>: The same function can be used with <kbd>Option</kbd> or <kbd>Vector</kbd> or <kbd>List</kbd>, or anything that has a <kbd>Functor</kbd> type class instance.</li>
<li><strong>Easier to read</strong>: When you read the signature of <kbd>addOne</kbd>, you know that the only thing it can do is transform the elements inside of the <kbd>F</kbd>. It cannot, for instance, shuffle the order of the elements, nor can it drop some elements. This is guaranteed by the <kbd>Functor</kbd> laws. Therefore, you do not have to read its implementation to make sure that it does not get into any mischief.</li>
<li><strong>Easier to test</strong>: You can test the function with the simplest type that has a <kbd>Functor</kbd> instance, which is <kbd>cats.Id</kbd>. the code coverage will be the same. A simple test would be, for instance, <kbd>addOne[cats.Id](1) == 2</kbd>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Laws</h1>
                </header>
            
            <article>
                
<p>In order to be <kbd>Functor</kbd>, the <kbd>Functor</kbd> instance's <kbd>map</kbd> function must satisfy two laws.  In the rest of this chapter, we will define our laws in terms of an equality: <kbd>left_expression == right_expression</kbd>. These equalities must be true for any types and instances specified.</p>
<p>Given a type <kbd>F</kbd> that has a <kbd>Functor[F]</kbd> instance, for any type <kbd>A</kbd> and any instance <kbd>fa: F[A]</kbd>, the following equalities must be satisfied:</p>
<ul>
<li>
<p><strong>Identity preservation</strong>: <kbd>fa.map(identity) == fa</kbd>. The identity function always returns its argument. Mapping with this function should not change <kbd>fa</kbd>.</p>
</li>
<li>
<p><strong>Composition preservation</strong>: For any function <kbd>f</kbd> and <kbd>g</kbd>, <kbd>fa.map(f).map(g) == fa.map(f andThen g)</kbd>. Mapping <kbd>f</kbd> and <kbd>g</kbd> successively is the same as mapping with a composition of these functions. This law allows us to optimize code. When we find ourselves calling <kbd>map</kbd> many times on a large vector, we know that we can replace all of the <kbd>map</kbd> calls with a single one.</p>
</li>
</ul>
<p class="mce-root">Exercise: Write an instance of <kbd>Functor[Vector]</kbd> that breaks the identity preservation law.</p>
<p class="mce-root">Exercise: Write an instance of <kbd>Functor[Vector]</kbd> that breaks the composition preservation law.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Usage examples</h1>
                </header>
            
            <article>
                
<p>Whenever you have a function <kbd>A =&gt; B</kbd>, you can lift it to make a function <kbd>F[A] =&gt; F[B]</kbd>, as long as you have a <kbd>Functor[F]</kbd> instance in scope, as follows:</p>
<pre class="western"><span>def square(x: Double): Double = x * x</span>
<span>def squareVector: Vector[Double] =&gt; Vector[Double] =</span>
<span>  Functor[Vector].lift(square)</span>
<span>  squareVector(Vector(1, 2, 3))</span>
<span>// res0: Vector[Double] = Vector(1.0, 4.0, 9.0)</span>
<span>def squareOption: Option[Double] =&gt; Option[Double] =</span>
<span>  Functor[Option].lift(square)</span>
<span>  squareOption(Some(3))</span>
<span>// res1: Option[Double] = Some(9.0)</span></pre>
<p>Another handy function is <kbd>fproduct</kbd>, which tuples value with the result of applying a function:</p>
<pre class="western"><span>Vector("Functors", "are", "great").fproduct(_.length).toMap</span><span> <br/>//res2: Map[String,Int] = Map(Functors -&gt; 8, are -&gt; 3, great -&gt; 5)</span></pre>
<p>We created <kbd>Vector[(String, Int)]</kbd> by using <kbd>fproduct</kbd>, and then converted it to <kbd>Map</kbd>. We obtain <kbd>Map</kbd> (keyed with a word) whose associated value is the number of characters of the word.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">cats.Apply</h1>
                </header>
            
            <article>
                
<p><kbd>Apply</kbd> is a subclass of <kbd>Functor</kbd>. It declares an additional <kbd>ap</kbd> function. Here is a simplified definition of <kbd>cats.Apply</kbd>:</p>
<pre class="western"><span>trait Apply[F[_]] extends Functor[F] {</span>
<span>  def ap[A, B](ff: F[A =&gt; B])(fa: F[A]): F[B]</span>
<span>  /** Alias for [[ap]]. */</span>
<span>  @inline final def &lt;*&gt;[A, B](ff: F[A =&gt; B])(fa: F[A]): F[B] =</span>
  <span>ap(ff)(fa)</span></pre>
<p>This signature means that for a given context <kbd>F</kbd>, if we have a function <kbd>A =&gt; B</kbd> inside of <kbd>F</kbd>, we can apply it to <kbd>A</kbd> inside of another <kbd>F</kbd> to obtain <kbd>F[B]</kbd>. We can also use <kbd>ap</kbd> alias operator, <kbd>&lt;*&gt;</kbd>. Let's try it out with different <kbd>F</kbd> contexts, as follows:</p>
<pre class="western"><span>import cats.implicits._<br/></span> 
<span>Option[String =&gt; String]("Hello " + _).ap(Some("Apply"))</span>
<span>// res0: Option[String] = Some(Hello Apply)</span>
<span>Option[String =&gt; String]("Hello " + _) &lt;*&gt; None</span>
<span>// res1: Option[String] = None</span>
<span>Option.empty[String =&gt; String] &lt;*&gt; Some("Apply")</span>
<span>// res2: Option[String] = None</span></pre>
<p>For <kbd>F = Option</kbd>, <kbd>ap</kbd> returns a nonempty <kbd>Option</kbd> only if both arguments are nonempty.</p>
<p>For <kbd>F = Vector</kbd>, we get the following:</p>
<pre class="western"><span>def addOne: Int =&gt; Int = _ + 1</span> <br/><span>def multByTwo: Int =&gt; Int = _ * 2</span> <br/><span>Vector(addOne, multByTwo) &lt;*&gt; Vector(1, 2, 3)</span> <br/><span>// res3: Vector[Int] = Vector(2, 3, 4, 2, 4, 6)</span></pre>
<p>In the case of <kbd>Vector</kbd>, <kbd>ap</kbd> takes each element for the first <kbd>Vector</kbd> and applies it to each element of the second <kbd>Vector</kbd>. Hence, we obtain all of the combinations of applying every function to every element.</p>
<p class="mce-root">Exercise: Use <kbd>ap</kbd> with <kbd>Future</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Laws</h1>
                </header>
            
            <article>
                
<p>As with other Cats type classes, an <kbd>Apply</kbd> instance must obey certain laws.</p>
<p>Given a type <kbd>F</kbd> that has an <kbd>Apply[F]</kbd> instance, for all types <kbd>A</kbd>, given an instance <kbd>fa: F[A]</kbd>, the following equalities must be verified:</p>
<ol>
<li><strong>Product associativity</strong>: For all <kbd>fb: F[B]</kbd> and <kbd>fc: F[C]</kbd>, the following applies:</li>
</ol>
<pre style="padding-left: 60px">(fa product (fb product fc)) ==<br/>  ((fa product fb) product fc).map { <br/>     case ((a, b), c) =&gt; (a, (b,c))<br/>    }</pre>
<p style="padding-left: 60px">We can change the parenthesis and hence the evaluation order without changing the result.</p>
<ol start="2">
<li> <strong><kbd>ap</kbd> function composition</strong>: For all types <kbd>B</kbd> and <kbd>C</kbd>, given the instances <kbd>fab: F[A =&gt; B]</kbd> and <kbd>fbc: F[B =&gt; C]</kbd>, the following applies:</li>
</ol>
<pre class="western" style="padding-left: 60px"><span>(fbc &lt;*&gt; (fab &lt;*&gt; fa)) == ((fbc.map(_.compose[A] _) &lt;*&gt; fab) &lt;*&gt; fa)</span></pre>
<p style="padding-left: 30px">This is similar to the function composition law that we saw in the <kbd>Functor</kbd> section: <kbd><span>fa.map(f).map(g) == fa.map(f andThen g)</span></kbd><span>.</span></p>
<p class="CDPAlignLeft CDPAlign" style="padding-left: 30px">Do not get lost in reading this law; the <kbd>&lt;*&gt;</kbd> function is applied right to left, and the <kbd>andThen</kbd> used for a function is <kbd>.compose[A]</kbd> for <kbd>Functor</kbd>.</p>
<p class="mce-root">Exercise: Verify the product associativity for <kbd>F = Option</kbd>. You can use specific values for <kbd>fa</kbd>, <kbd>fc</kbd>, and <kbd>fc</kbd>, for instance <kbd>val (fa, fb, fc) = (Option(1), Option(2), Option(3))</kbd>.</p>
<p class="mce-root">Exercise: Verify the <kbd>ap</kbd> function composition for <kbd>F = Option</kbd>. As before, you can use specific values for <kbd>fa</kbd>, <kbd>fab</kbd>, and <kbd>fbc</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Usage examples</h1>
                </header>
            
            <article>
                
<p>This is all good, but in practice, I rarely put functions inside of contexts. I find that the function <kbd>map2</kbd> in <kbd>Apply</kbd> is more useful. It is defined in <kbd>Apply</kbd> by using <kbd>product</kbd> and <kbd>map</kbd>. The <kbd>product</kbd> defines itself, using <kbd>ap</kbd> and <kbd>map</kbd>:</p>
<pre class="western"><span>trait Apply[F[_]] extends Functor[F] … {</span>
<span>  (...)</span>
<span>  def map2[A, B, Z](fa: F[A], fb: F[B])(f: (A, B) =&gt; Z): F[Z] =</span>
<span>    map(product(fa, fb))(f.tupled)</span>
    <span>override def product[A, B](fa: F[A], fb: F[B]): F[(A, B)] =</span>
<span>    ap(map(fa)(a =&gt; (b: B) =&gt; (a, b)))(fb)</span></pre>
<p>The <kbd>map2</kbd> object allows for applying a function to two values inside of an <kbd>F</kbd> context. This can be used to combine two values inside <kbd>F</kbd>, as follows:</p>
<pre class="western"><span>def parseIntO(s: String): Option[Int] = Either.catchNonFatal(s.toInt).toOption</span>
<span>parseIntO("6").map2(parseIntO("2"))(_ / _)</span>
<span>// res4: Option[Int] = Some(3)</span>
<span>parseIntO("abc").map2(parseIntO("def"))(_ / _)</span>
<span>// res5: Option[Int] = None</span></pre>
<p>In the preceding example, for <kbd>F = Option</kbd>, <kbd>map2</kbd> lets us call the function <kbd>/</kbd> if both values are nonempty.</p>
<p>Cats also provide an <kbd>Apply</kbd> instance for <kbd>F = Either[E, ?]</kbd>. Therefore, we can change the signature of <kbd>parseIntOpt</kbd> to return <kbd>Either[Throwable, Int]</kbd>, and the rest of the code will be the same:</p>
<pre class="western"><span>def parseIntE(s: String): Either[Throwable, Int] = Either.catchNonFatal(s.toInt)</span>
<span>parseIntE("6").map2(parseIntE("2"))(_ / _)</span>
<span>// res6: Either[Throwable,Int] = Right(3)</span>
<span>parseIntE("abc").map2(parseIntE("3"))(_ / _)</span>
<span>// res7: Either[Throwable,Int] = Left(java.lang.NumberFormatException: For input string: "abc")</span></pre>
<p>This <kbd>map2</kbd> function works well for two elements, but what if we have three, four, or <em>N</em> elements? <kbd>Apply</kbd> does not define a <kbd>map3</kbd> or <kbd>map4</kbd> function, but fortunately, Cats defines a <kbd>mapN</kbd> function on tuples:</p>
<pre class="western"><span>(parseIntE("1"), parseIntE("2"), parseIntE("3")).mapN( (a,b,c) =&gt; a + b + c)</span>
<span>// res8: Either[Throwable,Int] = Right(6)</span></pre>
<p>In <a href="f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml">Chapter 3</a>, <em>Handling Errors</em>, we saw that <kbd>Either</kbd> is used when we want to stop at the first error. This is what we saw in the previous example: the error mentions that <kbd>"abc"</kbd> cannot be parsed, but it does not mention anything about <kbd>"def"</kbd>.</p>
<p>Applying what we just learned, if we want to accumulate all errors, we can use <kbd>ValidatedNel</kbd>:</p>
<pre class="western"><span>import cats.data.ValidatedNel</span>
<span>def parseIntV(s: String): ValidatedNel[Throwable, Int] = Validated.catchNonFatal(s.toInt).toValidatedNel</span>
<span>(parseIntV("abc"), parseIntV("def"), parseIntV("3")).mapN( (a,b,c) =&gt; a + b + c)</span>
<span>// res9: ValidatedNel[Throwable,Int] = Invalid(NonEmptyList(</span>
<span>// java.lang.NumberFormatException: For input string: "abc", </span>
<span>// java.lang.NumberFormatException: For input string: "def")</span></pre>
<p class="mce-root">Exercise: Use <kbd>mapN</kbd> with <kbd>Future[Int]</kbd>. This allows you to run several computations in parallel, and to process their results when they are complete.</p>
<p class="mce-root">Exercise: Use <kbd>mapN</kbd> with <kbd>Vector[Int]</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">cats.Applicative</h1>
                </header>
            
            <article>
                
<p><kbd>Applicative</kbd> is a subclass of <kbd>Apply</kbd>. It declares an additional function, called <kbd>pure</kbd>:</p>
<pre class="western"><span>@typeclass trait Applicative[F[_]] extends Apply[F] { </span>
<span>  def pure[A](x: A): F[A]</span>
<span>}</span></pre>
<p>The <kbd>pure</kbd> function puts any value of type <kbd>A</kbd> into the <kbd>F</kbd> context. A type <kbd>F</kbd> that has an instance of <kbd>Applicative[F]</kbd> and that respects the associated laws is called an <strong>Applicative Functor</strong>.</p>
<p>Let's try this new <kbd>pure</kbd> function with different <kbd>F</kbd> contexts, as follows:</p>
<pre class="western"><span>import cats.Applicative</span>
<span>import cats.data.{Validated, ValidatedNel}</span>
<span>import cats.implicits._<br/> </span>
<span>Applicative[Option].pure(1)</span>
<span>// res0: Option[Int] = Some(1)</span>
<span>3.pure[Option]</span>
<span>// res1: Option[Int] = Some(3)</span>
<span>type Result[A] = ValidatedNel[Throwable, A]</span>
<span>Applicative[Result].pure("hi pure")</span>
<span>// res2: Result[String] = Valid(hi pure)</span>
<span>"hi pure".pure[Result]</span>
<span>// res3: Result[String] = Valid(hi pure)</span></pre>
<p>In most cases, <kbd>pure</kbd> is equivalent to the <kbd>apply</kbd> constructor. We can call it by using the function declared on the <kbd>Applicative</kbd> trait, or by calling <kbd>.pure[F]</kbd> on any type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Laws</h1>
                </header>
            
            <article>
                
<p>As you would expect, <kbd>Applicative</kbd> must conform to some laws.</p>
<p>Given a type <kbd>F</kbd> that has an <kbd>Applicative[F]</kbd> instance, for all types <kbd>A</kbd> given an instance <kbd>fa: F[A]</kbd>, the following equalities must be <span>verified:</span></p>
<ol>
<li>The Applicative identity is as follows:<br/>
<pre><span>((identity[A] _).pure[F] &lt;*&gt; fa)  ==  fa</span></pre></li>
</ol>
<p style="padding-left: 60px">When we put the <kbd>identity</kbd> function in a <kbd>F</kbd> context using <kbd>pure</kbd> and call <kbd>&lt;*&gt;</kbd> on <kbd>fa</kbd>, it does not change <kbd>fa</kbd>. It is similar to the identity law in <kbd>Functor</kbd>.</p>
<ol start="2">
<li>The Applicative composition<span>, given the instances</span> <kbd>fab: F[A =&gt; B]</kbd><span> and</span> <kbd>fbc: F[B =&gt; C]</kbd><span>, is as follows:</span><br/>
<pre>(fbc &lt;*&gt; (fab &lt;*&gt; fa)) == ((fbc.map(_.compose[A] _) &lt;*&gt; fab) &lt;*&gt; fa)</pre></li>
</ol>
<p style="padding-left: 60px">It is similar to the composition preservation in <kbd>Functor</kbd> . By using <kbd>compose</kbd>, we can change the parenthesis around the <kbd>&lt;*&gt;</kbd> expressions without changing the result.</p>
<ol start="3">
<li>The <kbd>Applicative</kbd> homomorphism is as follows:
<pre><span>Applicative</span>[<span>F</span>].<span>pure</span>(f) &lt;*&gt; <span>Applicative</span>[F].pure(a) == Applicative[F].pure(f(a))</pre></li>
</ol>
<p style="padding-left: 60px">When we call <kbd>pure(f)</kbd> and then <kbd>&lt;*&gt;</kbd> , it is the same as applying <kbd>f</kbd> and then calling <kbd>pure</kbd>.</p>
<ul>
<li>The <kbd>Applicative</kbd> interchange, <span>given the instance</span> <kbd>fab: F[A =&gt; B]</kbd><span>, is</span> <span>as follows:</span>
<pre>fab &lt;*&gt; Applicative[F].pure(a) == <br/>  Applicative[F].pure((f: A =&gt; B) =&gt; f(a)) &lt;*&gt; fab</pre></li>
</ul>
<p style="padding-left: 60px">We can flip the <kbd>fab</kbd> argument of <kbd>&lt;*&gt;</kbd>, provided that we wrap <kbd>a</kbd> on the left side of the equality, or <kbd>f(a)</kbd> on the right side of the equality.</p>
<p>As an exercise, I encourage you to open the <kbd>cats.laws.ApplicativeLaws</kbd> class from the Cats source code. There are a few other laws to discover, as well as the implementations of all of the tests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Usage examples</h1>
                </header>
            
            <article>
                
<p>In the section <em>cats.Apply</em> about <kbd>Apply</kbd>, you saw that we can combine many values in an <kbd>F</kbd> context by using <kbd>mapN</kbd>. However, what if the values that we want to combine are in a collection instead of a tuple?</p>
<p>In that case, we can use the <kbd>Traverse</kbd> type class. Cats provide instances of this type class for many collection types, such as <kbd>List</kbd>, <kbd>Vector</kbd>, and <kbd>SortedMap</kbd>.</p>
<p>The following is a simplified definition of <kbd>Traverse</kbd>:</p>
<pre class="western"><span>@typeclass trait Traverse[F[_]] extends Functor[F] with Foldable[F] with UnorderedTraverse[F] { self =&gt;</span>
<span>  def traverse[G[_]: Applicative, A, B](fa: F[A])(f: A =&gt; G[B]): <br/>  G[F[B]]</span>
  <span>(...)</span>
<span>}</span></pre>
<p>This signature means that I can call it with a collection, <kbd>fa: F[A]</kbd> (for instance, <kbd>Vector[String]</kbd>), and a function that takes <kbd>A</kbd> and returns <kbd>G[B]</kbd>, <kbd>G</kbd> being <kbd>Applicative Functor</kbd> (for instance, <kbd>Option[Int]</kbd>). It will run the <kbd>f</kbd> function on all of the values inside the <kbd>F</kbd>, and will return <kbd>F[B]</kbd> in a <kbd>G</kbd> context.</p>
<p>Let’s see it in action with concrete examples, as follows:</p>
<pre class="western"><span>import cats.implicits._</span>
def parseIntO(s: String): Option[Int] =<br/>  Either.catchNonFatal(s.toInt).toOption
<span>Vector("1", "2" , "3").traverse(parseIntO)</span>
<span>// res5: Option[Vector[Int]] = Some(Vector(1, 2, 3))</span>
<span>Vector("1", "boom" , "3").traverse(parseIntO)</span>
<span>// res6: Option[Vector[Int]] = None</span></pre>
<p>We can safely parse <kbd>Vector[String]</kbd> to return <kbd>Option[Vector[Int]]</kbd>. The result will be <kbd>None</kbd> if any value cannot be parsed. In this example, we called <kbd>Traverse</kbd> with <kbd>F = Vector</kbd>, <kbd>G = Option</kbd>, <kbd>A = String</kbd>, and <kbd>B = Int</kbd>.</p>
<p>If we want to keep some details about the parsing error, we can use <kbd>G = ValidatedNel</kbd>, as follows:</p>
<pre class="western"><span>import cats.data.{Validated, ValidatedNel}<br/></span><span>def</span> <span>parseIntV(s:</span> <span>String</span><span>):</span> <span>ValidatedNel</span><span>[</span><span>Throwable</span><span>, Int] = Validated.catchNonFatal(s.toInt).toValidatedNel<br/><br/></span><span>Vector("1", "2" , "3").traverse(parseIntV)</span>
<span>// res7: ValidatedNel[Throwable, Vector[Int]] = Valid(Vector(1, 2, 3))</span>
<span>Vector("1", "boom" , "crash").traverse(parseIntV)</span>
<span>// res8: ValidatedNel[Throwable, Vector[Int]] = </span>
<span>// Invalid(NonEmptyList(</span>
<span>//   NumberFormatException: For input string: "boom", </span>
<span>//   NumberFormatException: For input string: "crash"))</span></pre>
<p class="mce-root">Exercise: Use <kbd>Traverse</kbd> with <kbd>G = Future</kbd>. This will let you run a function in parallel for each element of the collection.</p>
<p>Another common use case is to flip a structure <kbd>F[G[A]]</kbd> into an <kbd>F[G[A]]</kbd>, using <kbd>sequence</kbd>.</p>
<p>The following is the definition of <kbd>sequence</kbd> in the <kbd>cats.Traverse</kbd> trait:</p>
<pre class="western"><span>def sequence[G[_]: Applicative, A](fga: F[G[A]]): G[F[A]] =</span>
<span>  traverse(fga)(ga =&gt; ga)</span></pre>
<p>We can see that <kbd>sequence</kbd> is actually implemented using <kbd>traverse</kbd>.</p>
<p>The following is an example, with <kbd>F = Vector</kbd> and <kbd>G = Option</kbd>:</p>
<pre class="western"><span>val vecOpt: Vector[Option[Int]] = Vector(Option(1), Option(2), Option(3))</span>
<span>val optVec: Option[Vector[Int]] = vecOpt.sequence</span>
<span>// optVec: Option[Vector[Int]] = Some(Vector(1, 2, 3))</span></pre>
<p>And here is another example, with <kbd>F = List</kbd> and <kbd>G = Future</kbd>:</p>
<pre><span>import </span>scala.concurrent._<br/><span>import </span>ExecutionContext.Implicits.<span>global<br/></span><span>import </span>duration.Duration<br/><br/><span>val </span>vecFut: <span>Vector</span>[Future[Int]] = <span>Vector</span>(<span>Future</span>(<span>1</span>), <span>Future</span>(<span>2</span>), <span>Future</span>(<span>3</span>))<br/><span>val </span>futVec: Future[<span>Vector</span>[Int]] = vecFut.sequence<br/><br/>Await.<span>result</span>(futVec, Duration.<span>Inf</span>)<br/><span>// res9: Vector[Int] = Vector(1, 2, 3)</span></pre>
<p>The call to <kbd>sequence</kbd> returns <kbd>Future</kbd> which will complete only when the three futures inside of <kbd>vecFut</kbd> complete.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">cats.Monad</h1>
                </header>
            
            <article>
                
<p><kbd>Monad</kbd> is a subclass of <kbd>Applicative</kbd>. It declares an additional function, <kbd>flatMap</kbd>, as follows:</p>
<pre class="western"><span>@typeclass trait Monad[F[_]] extends FlatMap[F] with Applicative[F]</span><span>@typeclass trait FlatMap[F[_]] extends Apply[F] {</span>
<span>  def flatMap[A, B](fa: F[A])(f: A =&gt; F[B]): F[B]</span>
<span>}</span></pre>
<p>This signature tells us that in order to produce <kbd>F[B]</kbd>, <kbd>flatMap</kbd> will somehow have to extract <kbd>A</kbd> inside <kbd>fa: F[A]</kbd>, and then call the function, <kbd>f</kbd>.</p>
<p>Previously, you saw that <kbd>Applicative</kbd> and <kbd>mapN</kbd> allow us to process several <kbd>F[A]</kbd> values in parallel, and combine them into a single <kbd>F[B]</kbd>. What <kbd>Monad</kbd> adds is the capability of processing <kbd>F[]</kbd> values in sequence: <kbd>flatMap</kbd> must process the <kbd>F</kbd> effect first, then call the <kbd>f</kbd> function.</p>
<p>Similar to <kbd>Functor</kbd> and <kbd>map</kbd>, many classes of the SDK already have a <kbd>flatMap</kbd> method, such as <kbd>Option</kbd>, <kbd>Vector</kbd>, <kbd>Future</kbd>, and so on. One advantage of having this <kbd>Monad</kbd> abstraction is that we can write functions that accept <kbd>Monad</kbd> so that it can be reused with different types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Laws</h1>
                </header>
            
            <article>
                
<p>Given a type <kbd>F</kbd> that has a <kbd>Monad[F]</kbd> instance, for all types <kbd>A</kbd> given an instance <kbd>fa: F[A]</kbd>, the following equalities must be verified:</p>
<ul>
<li><strong>All of the laws from the super traits</strong>: See <kbd>Applicative</kbd>, <kbd>Apply</kbd>, and <kbd>Functor</kbd>.</li>
<li><strong>FlatMap associativity</strong>: Given two types <kbd>B</kbd> and <kbd>C</kbd>, and two functions <kbd>f: A =&gt; F[B]</kbd> and <kbd>g: B =&gt; F[C]</kbd>, the following applies:</li>
</ul>
<pre style="padding-left: 60px">((fa flatMap f) flatMap g) == (fa flatMap(f(_) flatMap g))</pre>
<ul>
<li><strong>Left identity</strong>: Given a type <kbd>B</kbd>, a value <kbd>a: A</kbd>, and a function <kbd>f: A =&gt; F[B]</kbd>, the following applies:</li>
</ul>
<pre style="padding-left: 60px"><span>Monad</span>[<span>F</span>].pure(a).flatMap(f) == f(a)</pre>
<p class="mce-root" style="padding-left: 90px">Bringing a value in the <kbd>F</kbd> context and calling <kbd>flatMap f</kbd> should provide the same result as calling the function <kbd>F</kbd> directly.</p>
<ul>
<li><strong>Right identity</strong>:</li>
</ul>
<pre style="padding-left: 60px">fa.flatMap(<span>Monad</span>[<span>F</span>].pure) == fa</pre>
<p style="padding-left: 90px">The <kbd>fa</kbd> object should not change when we call <kbd>flatMap</kbd> and <kbd>pure</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Usage examples</h1>
                </header>
            
            <article>
                
<p>Suppose that you are building a program to manage a shop's inventory. The following is a simplified API to manage the items:</p>
<pre><span>import </span>cats.{<span>Id</span>, Monad}<br/><span>import </span>cats.implicits._<br/><br/><span>case class </span>Item(id: Int, label: <span>String</span>, price: Double, category: <span>String</span>)<br/><br/><span>trait </span>ItemApi[<span>F</span>[_]] {<br/> <span>def </span>findAllItems: <span>F</span>[<span>Vector</span>[Item]]<br/> <span>def </span>saveItem(item: Item): <span>F</span>[Unit]<br/>}</pre>
<p>The API is parametrized with an <kbd>F</kbd> context. This allows you to have different implementations of your API, as follows:</p>
<ul>
<li>In your unit tests, you would use <kbd>class TestItemApi extends ItemApi[cats.Id]</kbd>. If you look for the definition of <kbd>Id</kbd>, you will find <kbd>type Id[A] = A</kbd>. This means that this <kbd>TestItemApi</kbd> can directly return <kbd>Vector[Item]</kbd> in <kbd>findAllItems</kbd>, and <kbd>Unit</kbd> in <kbd>saveItem</kbd>.</li>
<li>In your production code, you will need access to a database, or to call a remote REST service. These actions take time and can fail; hence, you will need to use something like <kbd>F = Future</kbd>, or maybe <kbd>F = cats.effects.IO</kbd>. You will, for instance, define <kbd>class DbItemApi extends ItemApi[Future]</kbd>.</li>
</ul>
<div class="packt_infobox">The <kbd>Future</kbd> class in the SDK has some issues and breaks some laws. I encourage you to use better abstractions, such as <kbd>cats.effects.IO</kbd> (<a href="https://typelevel.org/cats-effect/datatypes/io.html">https://typelevel.org/cats-effect/datatypes/io.html</a>) or <kbd>monix.eval.Task</kbd> (<a href="https://monix.io/docs/2x/eval/task.html">https://monix.io/docs/2x/eval/task.html</a>).</div>
<p>Equipped with this API, we can implement some business logic. The following is the implementation of a function that applies a discount to all items:</p>
<div>
<pre><span>def </span>startSalesSeason[<span>F</span>[_] : Monad](api: ItemApi[<span>F</span>]): <span>F</span>[Unit] = {<br/>  <span>for </span>{<br/>    items &lt;- api.findAllItems<br/>    _ &lt;- items.traverse { item =&gt;<br/>      <span>val </span>discount = <span>if </span>(item.category == <span>"shoes"</span>) <span>0.80 </span><span>else </span><span>0.70<br/></span><span>      </span><span>val </span>discountedItem = item.copy(price = item.price * discount)<br/>      api.saveItem(discountedItem)<br/>    }<br/>  } <span>yield </span>()<br/>}</pre></div>
<p>The <kbd>F[_]: Monad</kbd> type parameter constraint implies that we can call <kbd>startSalesSeason</kbd> with any <kbd>ItemApi[F]</kbd>, as long as <kbd>F</kbd> has a <kbd>Monad</kbd> instance. The presence of this implicit in scope allows us to call <kbd>map</kbd> and <kbd>flatMap</kbd> on an instance <kbd>F[A]</kbd>. Since a <kbd>for</kbd> comprehension is transformed by the compiler into a combination of <kbd>map</kbd>/<kbd>flatMap</kbd>, we can use a <kbd>for</kbd> comprehension to make our function more readable. In the section <em>cats.Applicative</em>, about <kbd>Applicative</kbd>, you saw that we can call <kbd>traverse</kbd> on <kbd>Vector</kbd>, as long as the function returns <kbd>F</kbd> which has an <kbd>Applicative[F]</kbd> instance. Since <kbd>Monad</kbd> extends <kbd>Applicative</kbd>, we could use <kbd>traverse</kbd> to iterate through the items and save each of them.</p>
<p>If you squint at this code, it looks very similar to what an imperative implementation would look like. We managed to write a purely functional function while keeping readability. The advantage of this technique is that we can easily unit test the logic of <kbd>startSalesSeason</kbd> with <kbd>F = Id</kbd>, without having to deal with <kbd>Futures</kbd>. In the production code, the same code can use <kbd>F = Future</kbd>, or even <kbd>F = Future[Either[Exception, ?]]</kbd>, and gracefully handle the process in multiple threads.</p>
<p class="mce-root">Exercise: Implement <kbd>TestItemApi</kbd>, which extends <kbd>ItemApi[Id]</kbd>. You can use a mutable <kbd>Map</kbd> to store the items. After that, write a unit test for <kbd>startSalesSeason</kbd>. Then, implement a production version of the API that extends <kbd>ItemApi[Future]</kbd>.</p>
<p>This approach is known as <strong>tagless final encoding</strong>. You can find more information about this pattern at <a href="https://www.beyondthelines.net/programming/introduction-to-tagless-final/">https://www.beyondthelines.net/programming/introduction-to-tagless-final/</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We covered some challenging concepts in this chapter. Type classes are also used in other functional programming languages, such as Haskell.</p>
<p>For convenience, the following table summarizes the type classes that we enumerated in this chapter:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 8%">Name</td>
<td style="width: 43.7838%">Method</td>
<td style="width: 10%">Law(s)</td>
<td style="width: 51%">Example(s)</td>
</tr>
<tr>
<td style="width: 8%"><kbd>Semigroup</kbd></td>
<td style="width: 43.7838%">
<p class="mce-root"><kbd>def combine(</kbd><br/>
<kbd>x: A, y: A) : A</kbd></p>
</td>
<td style="width: 10%"><span>Associativity</span></td>
<td style="width: 51%">
<pre class="western"><span>Option(1) |+|  None |+| Option(2)</span>
<span>// res5: Option[Int] = Some(3)</span></pre></td>
</tr>
<tr>
<td style="width: 8%"><kbd>Monoid</kbd></td>
<td style="width: 43.7838%"><kbd>def empty: A</kbd></td>
<td style="width: 10%">Identity</td>
<td style="width: 51%">
<pre class="western"><span>Vector(1,2,3).combineAll</span>
<span>// res8: Int = 6</span></pre>
<pre class="western">Vector("1", "2", "3").foldMap(s =&gt; (s,s.toInt))
<span>// res10: (String, Int) = (123,6)</span></pre></td>
</tr>
<tr>
<td style="width: 8%"><kbd>Functor</kbd></td>
<td style="width: 43.7838%"><kbd>def map[A, B]</kbd><br/>
<kbd>(fa: F[A])</kbd><br/>
<kbd>(f: A =&gt; B): F[B]</kbd></td>
<td style="width: 10%">Identity,<br/>
<span>Composability</span></td>
<td style="width: 51%">
<pre class="western">def square(x: Double): Double = x * x<br/>def squareVector: <br/>  Vector[Double] =&gt; Vector[Double] =<br/>    Functor[Vector].lift(square)
<span>squareVector(Vector(1, 2, 3))</span>
<span>// res0: Vector[Double] = Vector(1.0, 4.0, 9.0)</span></pre>
<pre class="western">Vector("Functors", "are", "great")<br/>  .fproduct(_.length)<br/>  .toMap
<span>// res2: Map[String,Int] = Map(Functors -&gt; 8, //are -&gt; 3, great -&gt; 5)</span></pre></td>
</tr>
<tr>
<td style="width: 8%"><kbd>Apply</kbd></td>
<td style="width: 43.7838%"><kbd>def ap[A, B]</kbd><br/>
<kbd>(ff: F[A =&gt; B])</kbd><br/>
<kbd>(fa: F[A]): F[B]</kbd><br/>
alias <kbd>&lt;*&gt;</kbd></td>
<td style="width: 10%">Associativity,<br/>
Composability</td>
<td style="width: 51%">
<pre class="western">Option[String =&gt; String]<br/>    ("Hello " + _).ap(Some("Apply"))
<span>// res0: Option[String] = Some(Hello Apply)</span>
<span>Option[String =&gt; String]("Hello " + _) &lt;*&gt; None</span>
<span>// res1: Option[String] = None</span></pre>
<pre class="western"><span>def addOne: Int =&gt; Int = _ + 1</span>
<span>def multByTwo: Int =&gt; Int = _ * 2</span>
<span>Vector(addOne, multByTwo) &lt;*&gt; Vector(1, 2, 3)</span>
<span>// res3: Vector[Int] = Vector(2, 3, 4, 2, 4, 6)</span></pre></td>
</tr>
<tr>
<td style="width: 8%"><kbd>Applicative</kbd></td>
<td><kbd>def pure[A]</kbd><br/>
<kbd>(x: A): F[A]</kbd></td>
<td style="width: 10%">
<p class="mce-root"><span>Identity,</span><br/>
<span>Composability,<br/></span> <span>Homomorphism,<br/></span><span>Interchange</span></p>
</td>
<td style="width: 51%">
<pre class="western"><span>import cats.data.{Validated, ValidatedNel}<br/></span><span>def</span> <span>parseIntV(s:</span> <span>String</span><span>):</span> <span>ValidatedNel</span><span>[</span><span>Throwable</span><span>, Int] = Validated.catchNonFatal(s.toInt).toValidatedNel<br/><br/></span><span>Vector("1", "2" , "3").traverse(parseIntV)</span>
<span>// res7: ValidatedNel[Throwable, Vector[Int]] = Valid(Vector(1, 2, 3))</span>
Vector("1", "boom" , "crash")<br/>  .traverse(parseIntV)
<span>// res8: ValidatedNel[Throwable, Vector[Int]] = </span>
<span>// Invalid(NonEmptyList(</span>
<span>//   NumberFormatException: For input string: "boom", </span>
<span>//   NumberFormatException: For input string: "crash"))</span></pre></td>
</tr>
<tr>
<td style="width: 8%"><kbd>Monad</kbd></td>
<td><kbd>def flatMap[A, B]</kbd><br/>
<kbd>(fa: F[A])</kbd><br/>
<kbd>(f: A =&gt;F[B]): F[B]</kbd></td>
<td style="width: 10%">
<p class="mce-root"><span>Identity,<br/></span><span>Associativity,</span><br/>
<span>Composability,<br/></span><span>Homomorphism,<br/></span><span>Interchange</span></p>
</td>
<td style="width: 51%">
<pre>import cats.{Id, Monad}<br/>import cats.implicits._<br/>case class Item(id: Int,<br/>  label: String,<br/>  price: Double,<br/>  category: String)<br/>trait ItemApi[F[_]] {<br/>  def findAllItems: F[Vector[Item]]<br/>  def saveItem(item: Item): F[Unit]<br/>}</pre>
<pre>def startSalesSeason[F[_] : Monad](<br/>  api: ItemApi[F]): F[Unit] = {<br/>  for {<br/>    items &lt;- api.findAllItems<br/>    _ &lt;- items.traverse { item =&gt;<br/>    val discount = if (item.category ==<br/>      "shoes") 0.80 else 0.70<br/>    val discountedItem = item.copy(price =<br/>      item.price * discount)<br/>    api.saveItem(discountedItem)<br/>  }} yield ()<br/>}</pre></td>
</tr>
</tbody>
</table>
<p> </p>
<p>If you would like to explore type classes in more detail, I encourage you to view the Cats documentation at <a href="https://typelevel.org/cats">https://typelevel.org/cats</a>. I have also found it very helpful to read the source code and tests in the SDK, or in libraries such as Cats.</p>
<p>Cats is the main library of the Typelevel initiative, but there are many more fascinating projects hosted under this umbrella, as shown at <a href="https://typelevel.org/projects/">https://typelevel.org/projects/</a>.</p>
<p>In the next chapter, we will implement a cart for a shopping website, using frameworks that are popular in the Scala community.</p>


            </article>

            
        </section>
    </body></html>