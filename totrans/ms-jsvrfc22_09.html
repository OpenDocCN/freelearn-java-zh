<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;JSF State Management"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. JSF State Management</h1></div></div></div><p>Commonly, the JSF applications' performance is directly related to CPU memory, serialization/deserialization tasks, and network bandwidth. When these variables start to become the source of headache, or errors of type <code class="literal">ViewExpiredException</code> or <code class="literal">NotSerializableException</code> occur, it is time to find out about JSF's managing view state feature and how it can be finely tuned to increase the performance. Therefore, in this chapter, we will discuss about JSF saving the view state (JSF's partial saving view state feature, JSF saving the view state on server/client, logical and physical views, and so on) and JSF 2.2 stateless views.</p><div class="section" title="JSF saving the view state"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec82"/>JSF saving the view state</h1></div></div></div><p>First, you have to know that JSF saves and restores the view state between requests using the <code class="literal">ViewHandler</code>/<code class="literal">StateManager</code> API. JSF does this during its lifecycle, the view state is saved in the session (or on the client machine) at the end of a request and is restored at the beginning of a request.</p><p>JSF uses this technique<a id="id1141" class="indexterm"/> because it needs to preserve the views state over the HTTP protocol, which is a stateless protocol. Since JSF is stateful, it needs to save the state of views in order to perform the JSF lifecycle over multiple requests from the same user. Each page has a view state that acts as a ping-pong ball between the client and the server. A view is basically a component tree that may be dynamically changed (altered) during HTTP GET and POST requests. Each request will successfully go through the JSF lifecycle only if the component tree was previously saved and is fully capable to provide the needed information, that is, Faces Servlet succeeds to call the needed view handler implementations to restore or build the view. So, when the component tree is programmatically changed (for example, from backing beans or static components) it can't be successfully recreated from scratch (or rebuilt). The only solution is to use the existing state saved at the <span class="emphasis"><em>Render Response</em></span> phase. Trying to recreate it from scratch will make the programmatic changes useless, since they would no longer be available.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note160"/>Note</h3><p>Keep in mind that the component tree is just a hand of UI components hierarchically and logically related. The view state maintains the tree structure and the components state (selected/deselected, enabled/disabled, and so on). Therefore, the<a id="id1142" class="indexterm"/> component tree contains only references to backing beans properties/actions through EL expressions, and does not store the model values.</p></div></div><div class="section" title="JSF partial saving view state"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec97"/>JSF partial saving view state</h2></div></div></div><p>Starting with JSF 2.0, the performance of managing the state was seriously increased by adding the partial state saving feature. Basically, JSF will not save the entire component tree, only a<a id="id1143" class="indexterm"/> piece of it. Obviously this will require less memory. In other words, this means that instead of saving the entire component tree (the whole view, <code class="literal">&lt;html&gt;</code>), now, for every request during restore view, JSF will recreate the entire component tree<a id="id1144" class="indexterm"/> from scratch and initialize the components from their tag attributes. In this way, JSF will save only the things that are deserved to be saved. These are the things that are susceptible to changes (for example, <code class="literal">&lt;h:form&gt;</code>) that cannot be recreated from scratch and/or represent inland details of components. These details are: dynamic (programmatic) changes that alter the component tree, different kinds of values that were determined for some components (usually at first postback), and values that were changed for components but have not been submitted (for example, moving a slider or checking a checkbox). On the other hand, the things that cannot be changed by the client will not be saved.</p></div><div class="section" title="Partial state saving and tree visiting"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec98"/>Partial state saving and tree visiting</h2></div></div></div><p>In JSF 2.0, the JSF partial state saving feature raised a question similar to how a JSF implementation should visit<a id="id1145" class="indexterm"/> all the components in the component tree and ask them for their state (partial)? The answer in JSF 2.1 (and earlier versions) was specific to this implementation: Mojarra used a tree visiting algorithm, while MyFaces used a so-called "facets + children" traversal. But, technically speaking, these two approaches are pretty different, because<a id="id1146" class="indexterm"/> Mojarra provides a pluggable algorithm, while MyFaces doesn't. Moreover, the Mojarra approach is in context (before children are visited, the parent component can choose to use a context/scope), while the MyFaces approach follows a pointer design. Furthermore, the Mojarra algorithm can visit virtual components. (These kinds of components are obtained by looping components such as <code class="literal">UIData</code>.) On the other hand, from the saving state perspective, using a context/scope and looping virtual components is not desirable, even if affecting the visiting process can be major and useful.</p><p>In order to solve this problem, JSF 2.1 offers some hints, which can be considered deprecated starting with JSF 2.2. Starting with JSF 2.2, tree visiting is fully capable of partial state saving; thanks to the <code class="literal">StateManagementStrategy.saveView</code> and <code class="literal">StateManagementStrategy.restoreView</code> methods. These two methods are meant to replace their counterparts from the <code class="literal">StateManager</code> class, and their implementations are now mandatory to use<a id="id1147" class="indexterm"/> the visit API. (A good point to start studying may be the <code class="literal">UIComponent.visitTree</code> method.) As a JSF developer, you<a id="id1148" class="indexterm"/> will probably never interact with this feature, but for the sake of completeness, it may be good to be aware of it.</p></div><div class="section" title="JSF saving view state on the server or client"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec99"/>JSF saving view state on the server or client</h2></div></div></div><p>Saving the view state<a id="id1149" class="indexterm"/> can be accomplished on the server that hosts the application, or on the client machine. We can easily choose between the client and the server by adding the context parameter named <code class="literal">javax.faces.STATE_SAVING_METHOD</code> to the <code class="literal">web.xml</code> file. The value of this method can be <code class="literal">server</code> or <code class="literal">client</code> as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;context-param&gt;
 &lt;param-name&gt;javax.faces.STATE_SAVING_METHOD&lt;/param-name&gt;
 &lt;param-value&gt;server&lt;/param-value&gt;
&lt;/context-param&gt;</pre></div><p>Starting with JSF 2.2, the values of this context parameter are case insensitive.</p><p>Saving the state on the server means to save it in a session with a special ID known as the view state ID that refers to the state stored in the server memory. This is sent to the client as the value of a hidden input field named, <code class="literal">javax.faces.ViewState</code>. This can be easily tested by running the <code class="literal">ch9_1_1</code> application, which produces the HTML code that contains this field, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_09_01.jpg" alt="JSF saving view state on the server or client"/></div><p>If the state is saved on the client, JSF stores it as the value of the same hidden input field. This value is a base64 encrypted string representing the serialization of the state. Running the <code class="literal">ch9_1_2</code> application will produce the following output:</p><div class="mediaobject"><img src="graphics/6466EN_09_02.jpg" alt="JSF saving view state on the server or client"/></div><p>Specifying where the view state will be saved is a piece of cake, but choosing between saving the view state on a client or on a server can be a difficult choice, because each has its own advantages and disadvantages. Both have a cost, and everybody wants to pay a lower price. Choosing the client will increase network traffic because the serialized state will generate a larger value for the <code class="literal">javax.faces.ViewState</code> input field. Moreover, encoding/decoding the view state and possible trespasser attacks are also important drawbacks of this approach. On the other hand, the server uses less memory because nothing is stored in the session. Moreover, storing the view state on the client will also be a good solution to prevent losing it when the server is down, and to prevent <code class="literal">ViewExpiredException</code> that occurs when the session has expired, or when the maximum number <a id="id1150" class="indexterm"/>of opened views was reached. Saving the state on the server has an opposite effect: the network traffic is lower, the usage of memory by the server increases, and the server failures will result in loss of the state and possible <code class="literal">ViewExpiredException</code> instances.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note161"/>Note</h3><p>Usually, developers prefer to have a lower network traffic and use more memory on the server, because memory is easy to provide to an application server. But this is not a rule; you just have to think what's cheaper for you. Some heavy benchmarks can also provide compelling indications about storing the state on the client or on the server.</p></div></div><p>In order to make the right choice, do not forget that JSF 2.0 comes, by default, with partial state saving, which will be reflected in a smaller size of the <code class="literal">javax.faces.ViewState</code> input field (the state saved on the client) or in less memory needed (the state saved on the server). You can disable partial state saving by adding the following <code class="literal">context</code> parameter in <code class="literal">web.xml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;context-param&gt;
 &lt;param-name&gt;javax.faces.PARTIAL_STATE_SAVING&lt;/param-name&gt;
 &lt;param-value&gt;false&lt;/param-value&gt;
&lt;/context-param&gt;</pre></div><p>For a simple visual test, you can choose to save the state on the client and run the same application twice (you can use the application named, <code class="literal">ch9_1_2</code>): first time, enable partial state saving, and second time, disable it—the result shown in the following screenshot speaks for itself:</p><div class="mediaobject"><img src="graphics/6466EN_09_03.jpg" alt="JSF saving view state on the server or client"/></div><p>Furthermore, in the same application, you can use partial state saving for some views and full state saving for other views. Skip the <code class="literal">javax.faces.PARTIAL_STATE_SAVING</code> context parameter and use the <code class="literal">javax.faces.FULL_STATE_SAVING_VIEW_IDS</code> context parameter. The value<a id="id1151" class="indexterm"/> of this context parameter contains a list of view IDs for which the partial state saving will be disabled. The IDs should be comma separated, as shown in the following code (suppose you have three pages: <code class="literal">index.xhtml</code>, <code class="literal">done.xhtml</code>, and <code class="literal">error.xhtml</code>, partial state saving is used only for <code class="literal">index.xhtml</code>):</p><div class="informalexample"><pre class="programlisting">&lt;context-param&gt;
 &lt;param-name&gt;javax.faces.FULL_STATE_SAVING_VIEW_IDS&lt;/param-name&gt;
 &lt;param-value&gt;/done.xhtml,/error.xhtml&lt;/param-value&gt;
&lt;/context-param&gt;</pre></div><p>Programmatically, you can check if the state is saved on the client as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In view/page the code is as follows:<div class="informalexample"><pre class="programlisting">#{facesContext.application.stateManager.
                           isSavingStateInClient(facesContext)}</pre></div></li><li class="listitem" style="list-style-type: disc">In backing bean, the code is as follows:<div class="informalexample"><pre class="programlisting">FacesContext facesContext = FacesContext.getCurrentInstance();
Application application = facesContext.getApplication();
StateManager stateManager = application.getStateManager();
logger.log(Level.INFO, "Is view state saved on client ? {0}", 
                stateManager.isSavingStateInClient(facesContext));</pre></div></li></ul></div></div><div class="section" title="JSF logical and physical views"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec100"/>JSF logical and physical views</h2></div></div></div><p>So far, so good! We know that JSF can store a full or partial view state on server or on client with some advantages and disadvantages. Further, you have to know that JSF differentiates views in logical<a id="id1152" class="indexterm"/> views (specific to the GET requests) and physical views (specific to the POST requests). Each GET request generates a new<a id="id1153" class="indexterm"/> logical view. By default, JSF Mojarra (the reference implementation of JSF) manages 15 logical views, but this number can be<a id="id1154" class="indexterm"/> adjusted through the context parameter, <code class="literal">com.sun.faces.numberOfLogicalViews</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;context-param&gt;
 &lt;param-name&gt;com.sun.faces.numberOfLogicalViews&lt;/param-name&gt;
 &lt;param-value&gt;2&lt;/param-value&gt;
&lt;/context-param&gt;</pre></div><p>You can easily perform a test of this setting by starting the browser and opening the <code class="literal">ch9_2</code> application three times, in three different browser tabs. Afterwards, come back to the first tab and try to submit the form. You will see a <code class="literal">ViewExpiredException</code> because the first logical view was removed from the logical views map, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_09_04.jpg" alt="JSF logical and physical views"/></div><p>If you open the application in one or two tabs, this error will not occur.</p><p>There is another story with the POST requests (non-AJAX), because, in this case, JSF (Mojarra implementation) will store every single form in the session until the maximum size is reached. A <code class="literal">POST</code> request creates a new physical view (except AJAX requests which use the same physical view repeatedly) and JSF Mojarra can store 15 physical views per logical view (<code class="literal">Map&lt;LogicalView</code>, <code class="literal">Map&lt;PhysicalView</code>, and <code class="literal">ViewState&gt;&gt;</code>). Obviously, a physical view can contain multiple forms.</p><p>You can control the number of physical views through the context parameter named <code class="literal">com.sun.faces.numberOfViewsInSession</code>. For example, you can decrease its value to <code class="literal">4</code> as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;context-param&gt;
 &lt;param-name&gt;com.sun.faces.numberOfViewsInSession&lt;/param-name&gt;
 &lt;param-value&gt;4&lt;/param-value&gt;
&lt;/context-param&gt;</pre></div><p>This small value allows you to perform a quick test. Open the application named <code class="literal">ch9_3</code> in the browser and<a id="id1155" class="indexterm"/> submit that form four times. Afterwards, press the browser's back<a id="id1156" class="indexterm"/> button four times, to return to the first form and try to submit it again. You will see an exception, because this physical view was removed from the physical view's map. This will not happen if you submit the form less than four times.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note162"/>Note</h3><p>In case you need more than 15 logical/physical views, then you can increase their number or choose to save the state on the client. Saving the state on the client is recommended since it will totally eliminate this problem.</p></div></div><p>In case of<a id="id1157" class="indexterm"/> navigation between pages, JSF doesn't store anything in the session for the GET requests, but will save the state of forms for the POST requests.</p></div><div class="section" title="Saving the state in a database – an experimental application"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec101"/>Saving the state in a database – an experimental application</h2></div></div></div><p>Combining the client saving state and complex views can really stress up the network bandwidth. The root of<a id="id1158" class="indexterm"/> this drawback is represented by the size of the serialized state that should be passed between the client and the server at each request-response cycle. Usually, this string increases the server's response size significantly. An interesting idea is to save the view state in a database and send to the client only an identifier to the corresponding record. In this section, you will see how to accomplish this task using a MongoDB database and a custom implementation of saving the client view state. The implementation is tight coupled to JSF Mojarra (there are <code class="literal">com.sun.faces.*</code> specific dependencies requiring Mojarra). So, since it is not utilizing the standard API methods, this approach won't work in MyFaces.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note163"/>Note</h3><p>If you are not familiar with MongoDB (or NoSQL database systems), you can use SQL RDBMSs (for example, MySQL) and plain JDBC.</p></div></div><p>In order to pass the client view state into a database, you have to be aware of how JSF deals with it by default, and perform the corresponding adjustments. The magic of saving the state begins in the <code class="literal">ViewHandler</code>/<code class="literal">StateManager</code> pair of classes, which guides the tasks of saving/restoring the views between requests. Both of them use a helper class, named <code class="literal">ResponseStateManager</code>, which knows how to determine where the state should be saved (based on the default settings or on <code class="literal">web.xml</code> explicit settings) and delegates the saving/restoring task to one of the two helper classes, named <code class="literal">ClientSideStateHelper</code> and <code class="literal">ServerSideStateHelper</code>.</p><p>Getting more in details, when the view state should be saved, the <code class="literal">StateManager.writeState</code> method is called<a id="id1159" class="indexterm"/> from the <code class="literal">ViewHandler.renderView</code> method. In the <code class="literal">StateManager.writeState</code> method, JSF will obtain an instance of <code class="literal">ResponseStateManager</code>. This object can inspect each rendering-technology-specific request, because it knows the rendering technology used. The instance of <code class="literal">ResponseStateManager</code> comes from the <code class="literal">RenderKit</code> class (by calling the <code class="literal">RenderKit</code> method, named <code class="literal">getResponseStateManager</code>) and delegates the writing task to the <code class="literal">ResponseStateManager.writeState</code> method. In the <code class="literal">ResponseStateManager</code> constructor, JSF<a id="id1160" class="indexterm"/> will determine where the view state should be saved (on the client or the server), and indicates that the writing task should happen in one of the two helper classes, which are responsible for effectively writing the view state.</p><p>On the way back, during<a id="id1161" class="indexterm"/> restore view, the <code class="literal">ViewHandler</code> uses the <code class="literal">ResponseStateManager</code> class<a id="id1162" class="indexterm"/> to test if the request is an initial request or a postback request. In case of a postback request, JSF will call the <code class="literal">ViewHandler.restoreView</code> method.</p><p>Since we are interested in saving view state on the client, we will focus on the <code class="literal">ClientSideStateHelper</code> class, which<a id="id1163" class="indexterm"/> defines the following important methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">writeState</code>: This method<a id="id1164" class="indexterm"/> generates the hidden input field and populates its value with the encrypted version of the serialization view state</li><li class="listitem" style="list-style-type: disc"><code class="literal">getState</code>: This method<a id="id1165" class="indexterm"/> inspects the incoming request parameters for the standardized state parameter name and decrypts the string</li></ul></div><p>So, we need to write our helper class, named <code class="literal">CustomClientSideStateHelper</code>. The <code class="literal">writeState</code> method<a id="id1166" class="indexterm"/> is a convenient<a id="id1167" class="indexterm"/> point to start. The idea is to modify the default method for sending the encrypted state into a MongoDB database, instead of sending it to the client. The client will receive the primary key used for storing the state in the database. The modifications are highlighted in the following code:</p><div class="informalexample"><pre class="programlisting">@Override
public void writeState(FacesContext ctx, Object state,
            StringBuilder stateCapture) throws IOException {

   if (stateCapture != null) {
       doWriteState(ctx,state,new StringBuilderWriter(stateCapture));
   } else {
       ResponseWriter writer = ctx.getResponseWriter();

       writer.startElement("input", null);
       writer.writeAttribute("type", "hidden", null);
       writer.writeAttribute("name", 
                         ResponseStateManager.VIEW_STATE_PARAM, null);
       if (webConfig.isOptionEnabled(EnableViewStateIdRendering)) {
           String viewStateId = Util.getViewStateId(ctx);
           writer.writeAttribute("id", viewStateId, null);
       }
       StringBuilder stateBuilder = new StringBuilder();
       doWriteState(ctx,state,new StringBuilderWriter(stateBuilder));

       WriteStateInDB writeStateInDB = new WriteStateInDB();
       String client_id = 
          writeStateInDB.writeStateDB(stateBuilder.toString());

       if (client_id != null) {   
           writer.writeAttribute("value", client_id, null);
       } else {
           writer.writeAttribute("value", 
                                  stateBuilder.toString(), null);
       }
       if (webConfig.isOptionEnabled(AutoCompleteOffOnViewState)) {
           writer.writeAttribute("autocomplete", "off", null);
       }
       writer.endElement("input");

       writeClientWindowField(ctx, writer);
       writeRenderKitIdField(ctx, writer);
   }
 }</pre></div><p>Further, a subsequent <a id="id1168" class="indexterm"/>client request will pass the primary key to the default<a id="id1169" class="indexterm"/> <code class="literal">getState</code> method. Therefore, you need to write a custom <code class="literal">getState</code> method that will extract the corresponding state from the database by its ID (primary key):</p><div class="informalexample"><pre class="programlisting">@Override
public Object getState(FacesContext ctx, String viewId) 
                                            throws IOException {

 String stateString = ClientSideStateHelper.getStateParamValue(ctx);

 if (stateString == null) {
     return null;
 }

 if ("stateless".equals(stateString)) {
     return "stateless";
 } else {
     WriteStateInDB writeStateInDB = new WriteStateInDB();
     stateString = writeStateInDB.readStateDB(stateString);
     if (stateString == null) {
         return null;
     }
 }

 return doGetState(stateString);
}</pre></div><div class="section" title="Writing the custom ResponseStateManager class"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec04"/>Writing the custom ResponseStateManager class</h3></div></div></div><p>At this point, we can save/restore the client view state using a MongoDB database. Looking forward, we need to tell JSF to use our <code class="literal">CustomClientSideStateHelper</code> class instead of<a id="id1170" class="indexterm"/> the default <code class="literal">ClientSideStateHelper</code> class. This task can be easily accomplished if we<a id="id1171" class="indexterm"/> write a custom implementation<a id="id1172" class="indexterm"/> of the <code class="literal">ResponseStateManager</code> class. This will be almost the same as the Mojarra implementation, but with a small adjustment in the constructor (notice how we slipped the <code class="literal">CustomClientSideStateHelper</code> class here) as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public class CustomResponseStateManager extends ResponseStateManager {

 private StateHelper helper;

 public CustomResponseStateManager() {
  WebConfiguration webConfig = WebConfiguration.getInstance();
  String stateMode =
         webConfig.getOptionValue(StateSavingMethod);
  helper = ((StateManager.STATE_SAVING_METHOD_CLIENT.equalsIgnoreCase(stateMode)
<span class="strong"><strong>     ? new CustomClientSideStateHelper()</strong></span>
     : new ServerSideStateHelper()));
 }
...</pre></div><p>Following the same reasoning, we need to tell JSF to use our custom <code class="literal">ResponseStateManager</code> class. Remember that JSF obtains an instance of this class through the default <code class="literal">RenderKit</code> class; therefore, we can easily write our custom <code class="literal">RenderKit</code> class and override the <code class="literal">getResponseStateManager</code> method, which is responsible for creating an instance of the <code class="literal">ResponseStateManager</code> class. In order to write a custom <code class="literal">RenderKit</code> class, we will extend the wrapper class, <code class="literal">RenderKitWrapper</code>, which represents a<a id="id1173" class="indexterm"/> simple implementation of the <code class="literal">RenderKit</code> abstract class and spares us the implementation <a id="id1174" class="indexterm"/>of all the methods as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public class CustomRenderKit extends RenderKitWrapper {

 private RenderKit renderKit;
 private ResponseStateManager responseStateManager = 
                              new CustomResponseStateManager();

 public CustomRenderKit() {}

 public CustomRenderKit(RenderKit renderKit) {
  this.renderKit = renderKit;
 }

 @Override
 public synchronized ResponseStateManager getResponseStateManager() {
        
  if (responseStateManager == null) {
      responseStateManager = new CustomResponseStateManager();
  }
  return responseStateManager;
 }</pre></div><div class="informalexample"><pre class="programlisting"> @Override
 public RenderKit getWrapped() {
  return renderKit;
 }
}</pre></div><p>The<a id="id1175" class="indexterm"/> custom <code class="literal">RenderKit</code> class must be appropriately configured in the <code class="literal">faces-config.xml</code> file as follows:</p><div class="informalexample"><pre class="programlisting">&lt;render-kit&gt;
 &lt;render-kit-class&gt;
   book.beans.CustomRenderKit
 &lt;/render-kit-class&gt;
&lt;/render-kit&gt;</pre></div><p>Done! Now, the default <code class="literal">StateManager</code> class will require a <code class="literal">ResponseStateManager</code> instance<a id="id1176" class="indexterm"/> from our <code class="literal">RenderKit</code> class, which will provide an instance of the <code class="literal">CustomResponseStateManager</code> class. Further, the <code class="literal">CustomResponseStateManager</code> class will use <code class="literal">CustomClientSideStateHelper</code> for saving/restoring the client state.</p></div><div class="section" title="Adding MongoDB in equation"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec05"/>Adding MongoDB in equation</h3></div></div></div><p>The missing<a id="id1177" class="indexterm"/> part of the preceding section is the <code class="literal">WriteStateInDB</code> class. This is a class capable of writing/reading data from a MongoDB (Version 2.2.2 or later) database using the <a id="id1178" class="indexterm"/>MongoDB Java Driver (Version 2.8.0 or later), and is listed in the <a id="id1179" class="indexterm"/>following code (for those who are familiar with the MongoDB Java Driver, this is a very simple code):</p><div class="informalexample"><pre class="programlisting">public class WriteStateInDB {

 private DBCollection dbCollection;

 public WriteStateInDB() throws UnknownHostException {
  Mongo mongo = new Mongo("127.0.0.1", 27017);
  DB db = mongo.getDB("jsf_db");
  dbCollection = db.getCollection(("jsf"));
 }

 protected String writeStateDB(String state) {

 //TTL Index        
 BasicDBObject index = new BasicDBObject("date", 1);
 BasicDBObject options = new BasicDBObject("expireAfterSeconds", 
                                    TimeUnit.MINUTES.toSeconds(1));
        dbCollection.ensureIndex(index, options);

 BasicDBObject basicDBObject = new BasicDBObject();
 basicDBObject.append("date", new Date());
 basicDBObject.append("state", state);

 dbCollection.insert(basicDBObject);
 ObjectId id = (ObjectId) basicDBObject.get("_id");

 return String.valueOf(id);

 }

 protected String readStateDB(String id) {
 
  BasicDBObject query = new BasicDBObject("_id", new ObjectId(id));
  DBObject dbObj = dbCollection.findOne(query);
  if (dbObj != null) {
      return dbObj.get("state").toString();
  }
  return null;

  }
}</pre></div><p>Moreover, this class exploits a great facility of MongoDB, named TTL (<a class="ulink" href="http://docs.mongodb.org/manual/tutorial/expire-data/">http://docs.mongodb.org/manual/tutorial/expire-data/</a>), which is capable of automatically removing the data after a specified number of seconds or at a specific clock time. This is useful for cleaning up the database for the expired sessions (orphans). In this demo, each state<a id="id1180" class="indexterm"/> will be deleted after 60 seconds from the insertion of data into the database, but setting the time to 30 minutes can be more realistic. Of course, even so, you are under the risk of deleting<a id="id1181" class="indexterm"/> the states that are currently active; therefore, supplementary checks or an alternative solution is needed. Unfortunately, we can't provide more<a id="id1182" class="indexterm"/> details regarding MongoDB, since this is beyond the scope of this book. Therefore you have to go for a<a id="id1183" class="indexterm"/> research (<a class="ulink" href="http://www.mongodb.org/">http://www.mongodb.org/</a>). In the following screenshots, you can see a simple test that reveals the page size difference between the default client view state saving (1.3 KB) and the customized client view state. The default approach is as follows:</p><div class="mediaobject"><img src="graphics/6466EN_09_05.jpg" alt="Adding MongoDB in equation"/></div><p>The custom approach is as follows:</p><div class="mediaobject"><img src="graphics/6466EN_09_06.jpg" alt="Adding MongoDB in equation"/></div><p>Of course, this<a id="id1184" class="indexterm"/> approach brings into discussion the main drawback represented by the need of hitting the database for each save/restore state (caching can solve this).</p><p>The complete application is<a id="id1185" class="indexterm"/> named <code class="literal">ch9_9</code>. In order for it to work, you need to install MongoDB 2.2.2 (or later). The application comes with the MongoDB Java Driver Version 2.8.0, but you can provide a more recent one.</p><p>As a final note<a id="id1186" class="indexterm"/> to this section, keep in mind that a custom <code class="literal">StateManager</code> class can be written by extending the wrapper class, <code class="literal">StateManagerWrapper</code>, as shown in the following code (starting with JSF 2.0, we can use this wrapper class to easily decorate the <code class="literal">StateManager</code> class):</p><div class="informalexample"><pre class="programlisting">public class CustomStateManager extends StateManagerWrapper {

 private StateManager stateManager;
 
 public CustomStateManager() {
 }

 public CustomStateManager(StateManager stateManager) {
  this.stateManager = stateManager;
 }

 @Override
 // ... override here the needed methods
    
 
 @Override
 public StateManager getWrapped() {
  return stateManager;
 }   
}</pre></div><p>The custom state<a id="id1187" class="indexterm"/> manager <a id="id1188" class="indexterm"/>should be configured in the <code class="literal">faces-config.xml</code> file as follows:</p><div class="informalexample"><pre class="programlisting">&lt;application&gt;
 &lt;state-manager&gt;
   book.beans.CustomStateManager
 &lt;/state-manager&gt;
&lt;/application&gt;</pre></div></div></div><div class="section" title="Handling ViewExpiredException"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec102"/>Handling ViewExpiredException</h2></div></div></div><p>When a user<a id="id1189" class="indexterm"/> session expires (for any reason) <code class="literal">ViewExpiredException</code> occurs. The scenario behind<a id="id1190" class="indexterm"/> this exception is based on the following steps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The user view state is saved on the server (the <code class="literal">javax.faces.STATE_SAVING_METHOD</code> context parameter's value is server).</li><li class="listitem" style="list-style-type: disc">The user receives the view state ID as the value of the hidden input field, <code class="literal">javax.faces.ViewState</code>. This points out the view state saved on the server.</li><li class="listitem" style="list-style-type: disc">The user session expires (for example, timeout session) and the view state is removed from the server session, but the user still has the view state ID.</li><li class="listitem" style="list-style-type: disc">The user sends a POST request, but the view state ID indicates an unavailable view state; therefore, <code class="literal">ViewExpiredException</code> occurs.</li></ul></div><p>In order to deal with this exception, you have two choices: to avoid it or to treat it. Suppose that you are in view <span class="strong"><strong>A</strong></span> and you click on the <span class="strong"><strong>Logout</strong></span> button that invalidates the session and redirects control to view <span class="strong"><strong>B</strong></span> (when the session is invalidated the state is automatically removed from the session). Since this is a POST non-AJAX request, the user can press the browser back button, which will load the view <span class="strong"><strong>A</strong></span> again. Now, he can click on the <span class="strong"><strong>Logout</strong></span> button again, but this time, instead of view <span class="strong"><strong>B</strong></span>, he/she will see <code class="literal">ViewExpiredException</code>, because, most probably, view <span class="strong"><strong>A</strong></span> is not requested to the server again, and is loaded from the browser cache. Since it is loaded from the cache, the <code class="literal">javax.faces.ViewState</code> view state ID is the same as it was at first logout; therefore, the associated state is not available anymore. The flow is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_09_07.jpg" alt="Handling ViewExpiredException"/></div><p>Obviously, this is not the desired behavior. You have to tell the browser to make a new request to the server instead of loading the view <span class="strong"><strong>A</strong></span> from the cache. This can be accomplished by<a id="id1191" class="indexterm"/> a filter that sets the right headers in order<a id="id1192" class="indexterm"/> to disable browser caching. The filter will be applied to the <code class="literal">Faces Servlet</code> class<a id="id1193" class="indexterm"/> as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@WebFilter(filterName = "LogoutFilter", servletNames = {"Faces Servlet"})
public class LogoutFilter implements Filter {
...
@Override
public void doFilter(ServletRequest request, ServletResponse response,
             FilterChain chain) throws IOException, ServletException {

 HttpServletRequest requestHTTP = (HttpServletRequest) request;
 HttpServletResponse responseHTTP = (HttpServletResponse) response;
 try {
     String resourceURI = requestHTTP.getContextPath() + 
            requestHTTP.getServletPath() + 
            ResourceHandler.RESOURCE_IDENTIFIER;
     String requestURI = requestHTTP.getRequestURI();
                      
     if (!requestURI.startsWith(resourceURI)) {                   
         responseHTTP.setHeader("Expires", 
                                "Sat, 6 May 1995 12:00:00 GMT");
         responseHTTP.setHeader("Cache-Control", 
                                "no-store,no-cache,must-revalidate");
         responseHTTP.addHeader("Cache-Control", 
                                "post-check=0, pre-check=0");
         responseHTTP.setHeader("Pragma", "no-cache");
     }
     chain.doFilter(request, response);
 } catch (IOException | ServletException t) {
 }
}</pre></div><p>Now, repeat the scenario and note that instead of <code class="literal">ViewExpiredException</code>, view <span class="strong"><strong>A</strong></span> receives a new view state ID in <code class="literal">javax.faces.ViewState</code>.</p><p>You can see two examples in the code bundle of this chapter. One is named <code class="literal">ch9_4_1</code>, and the other one is named <code class="literal">ch9_4_2</code>.</p><p>The preceding solution may be a little bit confusing to the user, since it doesn't provide any explicit<a id="id1194" class="indexterm"/> information about what is happening. Moreover, a session may expire for many other reasons; therefore it would be a better idea to display<a id="id1195" class="indexterm"/> an error page to the user instead of using a filter to prevent browser cache. The error page can be the login page or just an intermediary page containing a link to the login page. This can be accomplished by adding in the <code class="literal">web.xml</code> file as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;error-page&gt;
 &lt;exception-type&gt;
  javax.faces.application.ViewExpiredException
 &lt;/exception-type&gt;
 &lt;location&gt;/faces/expired.xhtml&lt;/location&gt;
&lt;/error-page&gt;</pre></div><p>A simple <code class="literal">expired.xhtml</code> will be as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:body&gt;
 Your session expired ...
 &lt;h:link value="Go to Login Page ..." outcome="index" /&gt;         
&lt;/h:body&gt;</pre></div><p>The complete example is named <code class="literal">ch9_5</code> and is available in the code bundle of this book.</p><p>There is at least one more approach that comes from JSF 1.2 that works in JSF 2.2 also. You can try to set the following <code class="literal">context</code> parameter:</p><div class="informalexample"><pre class="programlisting">&lt;context-param&gt;
 &lt;param-name&gt;
  com.sun.faces.enableRestoreView11Compatibility
 &lt;/param-name&gt;
 &lt;param-value&gt;true&lt;/param-value&gt;
&lt;/context-param&gt;</pre></div><p>Well, this can be interpreted as: when the current view expires, generate a brand new one and do not throw <code class="literal">ViewExpiredException</code>.</p><p>The complete example is named <code class="literal">ch9_6</code> and is available in the code bundle of this book.</p><p>More details about<a id="id1196" class="indexterm"/> this exception (including how you can deal<a id="id1197" class="indexterm"/> with it in AJAX environments) are available in the <span class="emphasis"><em>Configuring the view handler</em></span> and <span class="emphasis"><em>Configuring the global exception handler</em></span> sections in <a class="link" href="ch05.html" title="Chapter 5. JSF Configurations Using XML Files and Annotations – Part 2">Chapter 5</a>, <span class="emphasis"><em>JSF Configurations Using XML Files and Annotations – Part 2</em></span>.</p></div><div class="section" title="Server-state serialization in a session"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec103"/>Server-state serialization in a session</h2></div></div></div><p>On the server side, the state can be stored as a shallow copy or as a deep copy. In a shallow copy, the<a id="id1198" class="indexterm"/> state is not serialized in the session (JSF stores only pointers to the state in a session and only the container deals with serialization stuff), which requires less memory and allows you<a id="id1199" class="indexterm"/> to inject EJBs in the view scoped beans (use this technique carefully, since the changes that affect objects in one copy will be reflected in the rest of the copies). The deep copy represents a full serialization of the state in a session, which requires more memory and doesn't allow injecting EJBs.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note164"/>Note</h3><p>By default, JSF Mojarra uses shallow copy, while JSF MyFaces uses deep copy. Anyway, perform a quick test to be sure which is the default.</p></div></div><p>We can easily alter the default behavior by explicitly setting the <code class="literal">javax.faces.SERIALIZE_SERVER_STATE</code> context parameter<a id="id1200" class="indexterm"/> in <code class="literal">web.xml</code>. This context parameter was introduced starting with JSF 2.2 and represents the standard context parameter for setting the server state serialization in Mojarra and MyFaces. You can indicate that the shallow copy should be used as follows:</p><div class="informalexample"><pre class="programlisting">&lt;context-param&gt;
 &lt;param-name&gt;javax.faces.SERIALIZE_SERVER_STATE&lt;/param-name&gt;
 &lt;param-value&gt;false&lt;/param-value&gt;
&lt;/context-param&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note165"/>Note</h3><p>In order to avoid exceptions of type, <code class="literal">java.io.NotSerializableException</code> (and warnings of type <code class="literal">Setting non-serializable attribute value ...</code>), keep in mind that serializing the state in a session implies serializable backing beans. (They import <code class="literal">java.io.Serializable</code> and their properties are serializable. Special attention to nested beans, EJBs, streams, JPA entities, connections, and so on.) This is also true when you are storing the view state in the client since the entire state should be serializable. When a bean property should not (or cannot) be serialized, just declare it <code class="literal">transient</code> and do not forget that it will be <code class="literal">null</code> at deserialization.</p></div></div><p>In addition to the preceding note, a common case implies <code class="literal">java.io.NotSerializableException</code>, when the state is saved on the client. But when switching the state on the server, this exception miraculously disappears on Mojarra, while it is still present in MyFaces. This can be confusing, but is perfectly normal if you are using Mojarra implementation, the state should be fully serializable while saving it on the<a id="id1201" class="indexterm"/> client (and it is not, since this exception occurred), while this is not true on the server, where<a id="id1202" class="indexterm"/> Mojarra by default doesn't serialize the state in a session. On the other hand, MyFaces defaults to serialize the state; therefore, the exception persists.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note166"/>Note</h3><p>Sometimes, you may optimize memory usage and save server resources by redesigning the application state, which contains view or session or application backing beans (don't cache the data that can be queried from a database and try to reduce the number of such beans). Besides managing the view state, this is also an important aspect that reflects directly in performance. When more memory is needed, the container may choose to serialize the parts of the application state, which means that you have to pay the price of deserialization also. While the price of saving in the session is represented by memory, the price of serialization/deserialization is represented by the time and insignificant disk space (at least it should be insignificant).</p></div></div></div></div></div>
<div class="section" title="JSF 2.2 is stateless"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec83"/>JSF 2.2 is stateless</h1></div></div></div><p>The notion of being stateless is pretty confusing, because every application must maintain some kind of state (for example, for runtime variables). Generically speaking, a stateless application will follow the rule of a state per request, which means that a state's lifecycle is the same as the<a id="id1203" class="indexterm"/> request-response lifecycle. This is an important issue in web applications, where we need to use session/application scope that, obviously, breaks down the notion of stateless.</p><p>Even so, one of the most popular features of JSF 2.2 consists of stateless views (and is actually available starting with Version 2.1.19). The idea behind this concept assumes that JSF will not save/restore the view state between requests and will prefer to recreate the view state from the XHTML tags on every request. The goal is to seriously increase performances: the gain time used for the save/restore view state, more efficient usage of server memory, more support for clustered environments, and the prevention of <code class="literal">ViewExpiredException</code>s. So, JSF developers have certain requirements of the stateless feature.</p><p>Nevertheless, it seems that the stateless feature doesn't affect too much of the time used for saving/restoring the view state (this is not expensive, especially when the state is saved on a server session and is not going to be serialized) and memory performances. On the other hand, when an application is deployed on several computers (in clustered environments), the stateless feature can be a real help because we don't need session replication (refers to replicating the data stored in a session across different instances) and/or sticky sessions (refers to the mechanism used by the load balancer to improve efficiency of persistent sessions in a clustered configuration) anymore. For stateless applications, the nodes do not need to share states, and client postback requests can be resolved by different nodes. This is a big achievement, because in order to resolve many requests, we can add new nodes without worrying about sharing the state. In addition, preventing <code class="literal">ViewExpiredException</code> is also a big advantage.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note167"/>Note</h3><p>Stateless views can be used to postpone session creation or dealing with big (complex) component trees that implies an uncomfortable state.</p></div></div><p>Starting with JSF 2.2, the developers can choose between saving the view state and creating stateless views in the same application, which means that the application can use dynamic forms in some views (stateful) and create/recreate them for every request in other views (stateless). For a stateless view, the component tree cannot be dynamically generated/changed (for example, JSTL and bindings are not available in the stateless mode) and resubmitting forms will probably not work as expected. Moreover, some of the JSF components are stateful, which will lead to serious issues in a stateless view. But, it is not so easy to nominate those components and the issues, since their behavior is dependent on the environment (context). Some specific tests may be helpful.</p><p>In order to write a JSF stateless application, you have to design everything to work only with the request scoped bean. In some cases, we can use different tricks to accomplish this task, like using<a id="id1204" class="indexterm"/> hidden fields and special request parameters for emulating a session. While session and application beans will break down the idea of stateless (even if it is possible to use), the view bean will act as request beans.</p><p>Programmatically speaking, defining a view as stateless is a piece of cake: just add the attribute named, <code class="literal">transient</code> to the <code class="literal">&lt;f:view&gt;</code> tag and set its value to <code class="literal">true</code>. Note that in order to have a stateless view, the presence of <code class="literal">&lt;f:view&gt;</code> tag is mandatory, even if it doesn't have any other use. Each stateless view of an application needs this setting because there isn't a global setting for indicating that the stateless effect should be applied at the application level.</p><div class="informalexample"><pre class="programlisting">&lt;f:view transient="true"&gt;
 ...
&lt;/f:view&gt;   </pre></div><p>When a view is stateless, the <code class="literal">javax.faces.ViewState</code> value will be <code class="literal">stateless</code>, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_09_08.jpg" alt="JSF 2.2 is stateless"/></div><div class="section" title="The view scoped beans and the stateless feature"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec104"/>The view scoped beans and the stateless feature</h2></div></div></div><p>In a stateless environment, the view scoped beans act as request scoped beans. Besides the fact that you can't create/manipulate views dynamically, this is one of the big disadvantages that<a id="id1205" class="indexterm"/> comes with the stateless feature, because it will affect AJAX-based applications that usually use view scoped beans. You can easily test this behavior with a set of beans with different scopes (the complete application is named <code class="literal">ch9_7</code>). The view scoped bean can be defined as follows:</p><div class="informalexample"><pre class="programlisting">@Named
@ViewScoped
public class TimestampVSBean implements Serializable{

 private Timestamp timestamp;

 public TimestampVSBean() {
  java.util.Date date = new java.util.Date();
  timestamp = new Timestamp(date.getTime());
 }

 public Timestamp getTimestamp() {
  return timestamp;
 }

 public void setTimestamp(Timestamp timestamp) {
  this.timestamp = timestamp;
 }
}</pre></div><p>Just change<a id="id1206" class="indexterm"/> the scope to request, session, and application to obtain the other three beans.</p><p>Next, we will write a simple stateless view as follows:</p><div class="informalexample"><pre class="programlisting">&lt;f:view transient="true"&gt;       
 &lt;h:form&gt;            
  &lt;h:commandButton value="Generate Timestamp"/&gt;
 &lt;/h:form&gt;
 &lt;hr/&gt;
 Request Scoped Bean:&lt;h:outputText value="#{timestampRSBean.timestamp}"/&gt;
 &lt;hr/&gt;
 View Scoped Bean:&lt;h:outputText value="#{timestampVSBean.timestamp}"/&gt;  
 [keep an eye on this in stateless mode]   
 &lt;hr/&gt;
 Session Scoped Bean:&lt;h:outputText value="#{timestampSSBean.timestamp}"/&gt;
 &lt;hr/&gt;
 Application Scoped Bean:&lt;h:outputText value="#{timestampASBean.timestamp}"/&gt;
 &lt;hr/&gt;
&lt;/f:view&gt;</pre></div><p>Afterwards, just submit this form several times (click on the <span class="strong"><strong>Generate Timestamp</strong></span> button) and notice that<a id="id1207" class="indexterm"/> the timestamp generated by <a id="id1208" class="indexterm"/>the view scoped bean changes at every request as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_09_09.jpg" alt="The view scoped beans and the stateless feature"/></div><p>The request, session, and application scopes work as expected!</p></div><div class="section" title="Detecting stateless views programmatically"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec105"/>Detecting stateless views programmatically</h2></div></div></div><p>Programmatically <a id="id1209" class="indexterm"/>speaking, you can detect if a view is stateless by using the following options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In view or page, enter the following code:<div class="informalexample"><pre class="programlisting">&lt;f:view transient="true"&gt;
  Is Stateless (using transient) ? #{facesContext.viewRoot.transient}  
   ...
&lt;/f:view&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">In view or page, enter the following code. This works only for the <code class="literal">postback</code> requests:<div class="informalexample"><pre class="programlisting">Is Stateless (using stateless) ? 
#{facesContext.postback ? facesContext.renderKit.responseStateManager.
            isStateless(facesContext, null) : 'Not postback yet!'}</pre></div></li><li class="listitem" style="list-style-type: disc">In backing<a id="id1210" class="indexterm"/> bean, enter the following code:<div class="informalexample"><pre class="programlisting">FacesContext facesContext = FacesContext.getCurrentInstance();
UIViewRoot uiViewRoot = facesContext.getViewRoot();
logger.log(Level.INFO, "Is stateless (using isTransient) ? {0}",
                                        uiViewRoot.isTransient());
logger.log(Level.INFO, "Is stateless (using isStateless) ? {0}", facesContext.getRenderKit().getResponseStateManager().isStateless(facesContext, null));</pre></div></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note168"/>Note</h3><p>Notice that the <code class="literal">isStateless</code> method<a id="id1211" class="indexterm"/> can be used only on the <code class="literal">postback</code> requests.</p></div></div><p>The complete <a id="id1212" class="indexterm"/>application is named <code class="literal">ch9_8</code>.</p></div></div>
<div class="section" title="JSF security notes"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec84"/>JSF security notes</h1></div></div></div><p>Dissertations about JSF saving state also imply some aspects regarding JSF security. It appears that saving the JSF state on the client is less secure than saving the JSF state on the server. For the most common security concerns (for example, XSS, CSRF, SQL injection, and phishing), JSF provides implicit protection.</p><div class="section" title="Cross-site request forgery (CSRF)"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec106"/>Cross-site request forgery (CSRF)</h2></div></div></div><p>CSRF and phishing attacks<a id="id1213" class="indexterm"/> can be prevented by saving state on the server. JSF 2.0 comes with implicit protection<a id="id1214" class="indexterm"/> against CSRF attacks based on the value of the <code class="literal">javax.faces.ViewState</code> hidden field. Starting with JSF 2.2, this protection was seriously fortified by creating a powerful and robust value for this field.</p></div><div class="section" title="Cross-site scripting (XSS)"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec107"/>Cross-site scripting (XSS)</h2></div></div></div><p>XSS attacks are<a id="id1215" class="indexterm"/> implicitly prevented by JSF through the <code class="literal">escape</code> attribute, which<a id="id1216" class="indexterm"/> is set to <code class="literal">true</code> by default (<code class="literal">&lt;h:outputText/&gt;, &lt;h:outputLabel/&gt;</code>). The following are the examples:</p><div class="informalexample"><pre class="programlisting">&lt;p&gt;Hi, &lt;h:outputText value="#{loginbean.name}" /&gt;&lt;/p&gt;
&lt;p&gt;Hi, #{loginbean.name}&lt;/p&gt;</pre></div><p>The preceding examples are XSS protected because they are both escaped.</p><p>But, if you write the following example, then an XSS attack is possible:</p><div class="informalexample"><pre class="programlisting">&lt;p&gt;Hi, &lt;h:outputText value="#{loginbean.name}" escape="false" /&gt;&lt;/p&gt;</pre></div><p>In order to<a id="id1217" class="indexterm"/> allow HTML tags, you have to focus on a specialized tool, which <a id="id1218" class="indexterm"/>will be able to parse the HTML code.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note169"/>Note</h3><p>In the stateless mode, the <code class="literal">escape</code> attribute<a id="id1219" class="indexterm"/> should always be set to <code class="literal">true</code>, because an XSS gap can facilitate an easy way for CSRF attacks.</p></div></div></div><div class="section" title="SQL injection"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec108"/>SQL injection</h2></div></div></div><p>SQL injection is usually<a id="id1220" class="indexterm"/> an attack that speculates SQL queries that<a id="id1221" class="indexterm"/> are created based on user inputs/selections. JSF itself cannot prevent these kinds of attacks, because it is not implicated in generating and executing SQL transactions. On the other hand, you can use JSF to filter/validate user inputs or selections, which may prevent such attacks. Outside JSF, it is a good technique to prevent these attacks consisting of writing parameterized queries instead of embedding user inputs in the statements and be extra careful at filtering escape characters and type handling.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec85"/>Summary</h1></div></div></div><p>I hope you found this as an interesting dissertation about the JSF state. This was a controversial subject for a long time, and starting with JSF 2.2, the stateless views pour more gas on the fire of this controversy. Nevertheless, choosing the right way of managing states is a serious decision that affects the applications' performance; therefore, choose wisely and try to be documented about the existing benchmarks and workarounds regarding the JSF state.</p><p>See you in the next chapter, where we will discuss about custom and composite components in JSF.</p></div></body></html>