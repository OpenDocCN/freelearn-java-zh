- en: Chapter 10.  Scaling up
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。扩展
- en: In the previous chapters, we built a Scala and Play framework application. We
    used the most effective frameworks and tools around the Scala ecosystem, such
    as Play framework and Akka; and we used the Reactive and Functional Programming
    techniques using Futures and RxScala. Additionally, we created reports with Jasper
    and Chat with WebSockets. This is the final chapter, and we will learn how to
    deploy and scale our application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们构建了一个Scala和Play框架应用程序。我们使用了Scala生态系统中最有效的框架和工具，如Play框架和Akka；我们使用了Reactive和函数式编程技术，使用Futures和RxScala。此外，我们使用Jasper和WebSocket进行聊天。这是最后一章，我们将学习如何部署和扩展我们的应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Standalone deploy
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立部署
- en: Architecture principles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构原则
- en: Reactive drivers and discoverability
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式驱动和可发现性
- en: Mid-Tier load-balancer, timeouts, Back pressure, and caching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间层负载均衡器、超时、背压和缓存
- en: Scaling up microservices with an Akka cluster
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Akka集群扩展微服务
- en: Scaling up the infrastructure with Docker and AWS cloud
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker和AWS云扩展基础设施
- en: Standalone deploy
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立部署
- en: Throughout this book, we used the Activator and SBT build and development tools.
    However, when we talk about production, we can't run the application with SBT
    or Activator; we need to do a standalone deploy.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们使用了Activator和SBT构建和开发工具。然而，当我们谈论生产时，我们不能使用SBT或Activator运行应用程序；我们需要进行独立部署。
- en: What about standard Java Servlet containers, such as Tomcat? Tomcat is great;
    however, Play is greater. You won't get better performance by deploying your app
    on Tomcat. The standalone play uses Netty, which has superior network stack.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，关于标准的Java Servlet容器，如Tomcat呢？Tomcat很棒；然而，Play更棒。你在Tomcat上部署应用程序不会获得更好的性能。独立的Play使用Netty，它具有优越的网络堆栈。
- en: There are some small changes that we will need to make in order to deploy our
    application for Jasper reports. Don't worry; these changes are very simple and
    straightforward.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了部署我们的Jasper报告应用程序，我们需要做一些小的修改。别担心；这些更改非常简单直接。
- en: Reports folder
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 报告文件夹
- en: We need to move the reports template (JRXML files) from the source folder to
    the public folder. Why do we need to do this? Because when we generate the standalone
    deploy, they won't be included in the application jars. What is inside the public
    folder will be packed and deployed into a proper JAR file. That's why we need
    to make this change.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将报告模板（JRXML文件）从源文件夹移动到公共文件夹。我们为什么需要这样做？因为当我们生成独立部署时，它们不会被包含在应用程序JAR文件中。公共文件夹中的内容将被打包并部署到适当的JAR文件中。这就是为什么我们需要进行这个更改。
- en: Create a folder called `reports` at `ReactiveWebStore/public/`. Then move all
    the JRXML files there.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ReactiveWebStore/public/`下创建一个名为`reports`的文件夹。然后将所有JRXML文件移到那里。
- en: Changing report builder
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改报告生成器
- en: 'As our templates will be inside a JAR file, we need to change the loading logic
    in order to get the templates properly. Under `ReactiveWebStore/app/report/`,
    we need to change `ReportBuilder.scala`, which should look something like this
    after editing:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的模板将位于JAR文件中，我们需要更改加载逻辑以正确获取模板。在`ReactiveWebStore/app/report/`下，我们需要更改`ReportBuilder.scala`，编辑后应如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The main changes that we made were around the `compile` function. Now, we are
    using the Jasper JRXmlLoader in order to load the Jasper template from an `InputStream`
    method. Passing the `InputStream` method provided by the `Play.resourceAsStream`
    function. As you can see, we are passing the new path, `/public/reports/`, in
    order to get the templates. The rest of the code is pretty much the same as the
    one we executed earlier.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的主要更改是围绕`compile`函数。现在，我们使用Jasper JRXmlLoader从`InputStream`方法加载Jasper模板。通过`Play.resourceAsStream`函数提供的`InputStream`方法传递。正如你所见，我们传递了新的路径`/public/reports/`以获取模板。其余的代码基本上与之前执行的一样。
- en: 'Now we are ready to deploy. In order to do so, we will need to run a command
    on `activator`, which is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备部署。为了做到这一点，我们需要在`activator`上运行一个命令，如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will see the following result:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下结果：
- en: '![Changing report builder](img/image00332.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![更改报告生成器](img/image00332.jpeg)'
- en: As soon as the task is finished, our app will be packed into the `ReactiveWebStore/target/universal/`
    directory, and you will see a `reactivewebstore-1.0-SNAPSHOT.tgz` file.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 任务完成后，我们的应用程序将被打包到`ReactiveWebStore/target/universal/`目录中，你将看到一个`reactivewebstore-1.0-SNAPSHOT.tgz`文件。
- en: 'Then you need to extract the file and you shall have the following directory:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你需要提取文件，你将拥有以下目录：
- en: '`reactivewebstore-1.0-SNAPSHOT`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reactivewebstore-1.0-SNAPSHOT`'
- en: '`bin`: Scripts to run the app'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bin`: 运行应用的脚本'
- en: '`conf`: All config files: routes, logging, messages'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conf`: 所有配置文件：路由、日志、消息'
- en: '`bib`: All JARs including third-party dependencies'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bib`: 包括第三方依赖的所有JAR文件'
- en: '`share`: All documentation about the app'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`share`: 关于应用程序的所有文档'
- en: Defining the secret
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义秘密
- en: Before we run our standalone application, we will need to apply one more change.
    We need to change the default secret. Locate the `reactivewebstore-1.0-SNAPSHOT/conf/application.conf`
    file.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行独立应用程序之前，我们需要进行一个额外的更改。我们需要更改默认的秘密。定位到`reactivewebstore-1.0-SNAPSHOT/conf/application.conf`文件。
- en: 'Change the secret to following in the `application.conf` file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在`application.conf`文件中将秘密更改为以下内容：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You will need to provide a different value. It can be anything, as long as you
    don't call it `changeme`. If you don't change this, your application will not
    boot up. You can get more information at [http://www.playframework.com/documentation/latest/ApplicationSecret](http://www.playframework.com/documentation/latest/ApplicationSecret).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要提供一个不同的值。它可以是什么都行，只要你不叫它`changeme`。如果你不更改这个，你的应用程序将无法启动。你可以在[http://www.playframework.com/documentation/latest/ApplicationSecret](http://www.playframework.com/documentation/latest/ApplicationSecret)获取更多信息。
- en: If you just want to test the deploy for now, let's call it `playworks`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在只想测试部署，我们可以称它为`playworks`。
- en: Now, we are all set to start the application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好启动应用程序。
- en: Running the standalone deploy
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行独立部署
- en: 'In order to run the app, we will use the script generated by the universal
    task. Go to the `reactivewebstore-1.0-SNAPSHOT` directory and then run `$ bin/reactivewebstore`, which
    would look something like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行应用程序，我们将使用通用任务生成的脚本。转到`reactivewebstore-1.0-SNAPSHOT`目录，然后运行`$ bin/reactivewebstore`，它看起来可能像这样：
- en: '![Running the standalone deploy](img/image00333.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![运行独立部署](img/image00333.jpeg)'
- en: Now, you can open your browser and go to `http://localhost:9000/`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以打开浏览器并访问`http://localhost:9000/`。
- en: That's it; we have our app up and running. Feel free to test all the features
    we built--they all work!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；我们的应用程序已经启动并运行。请随意测试我们构建的所有功能——它们都正常工作！
- en: 'It should look something like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该看起来像这样：
- en: '![Running the standalone deploy](img/image00334.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![运行独立部署](img/image00334.jpeg)'
- en: Architecture principles
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构原则
- en: Scalability is about handling more users, traffic, and data; and in order to
    do it, we will need to apply some principles and techniques. Our application is
    already using the most modern techniques and technologies, such as functional
    and ReactiveX programming, RxScala, Akka framework, Play, and much more. However,
    in order to scale, we will need to have an infrastructure in place and other kinds
    of system that will allow us to handle more users.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性是处理更多用户、流量和数据的能力；为了实现这一点，我们需要应用一些原则和技术。我们的应用程序已经使用了最现代的技术和工具，如函数式编程、ReactiveX编程、RxScala、Akka框架、Play等。然而，为了实现扩展，我们需要建立一个基础设施，以及其他能够让我们处理更多用户的系统。
- en: 'A good application architecture should be created around the following principles:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的应用程序架构应该围绕以下原则创建：
- en: '**Separation of Concerns** (**SOC**) (more details at [https://en.wikipedia.org/wiki/Separation_of_concerns](https://en.wikipedia.org/wiki/Separation_of_concerns))'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**（**SOC**）（更多详情请见[https://en.wikipedia.org/wiki/Separation_of_concerns](https://en.wikipedia.org/wiki/Separation_of_concerns)）'
- en: Service Orientation (SOA/microservices)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务导向（SOA/microservices）
- en: Performance
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能
- en: Scalability/Resiliency
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性/弹性
- en: Let's see these principles in detail.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这些原则。
- en: Service orientation (SOA/microservices)
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务导向（SOA/microservices）
- en: Service orientation is about having a higher level of abstraction, which is
    also called services or microservices. SOA is not about a specific technology,
    but about principles such as shared services, flexibility, and intrinsic operability.
    If you want to learn more about SOA, check out the SOA Manifesto at [http://www.soa-manifesto.org/](http://www.soa-manifesto.org/).
    Microservices is a particular flavor of SOA where the main difference is the focus
    on the granularity, autonomy, and isolation. If you want to learn more about microservices,
    you can check out [https://www.linkedin.com/pulse/soa-microservices-isolation-evolution-diego-pacheco](https://www.linkedin.com/pulse/soa-microservices-isolation-evolution-diego-pacheco)
    as well as [http://microservices.io/](http://microservices.io/).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 服务导向是关于拥有更高层次的抽象，这也可以称为服务或微服务。SOA不是关于特定技术，而是关于共享服务、灵活性和内在可操作性等原则。如果你想了解更多关于SOA的信息，可以查看[http://www.soa-manifesto.org/](http://www.soa-manifesto.org/)的SOA宣言。微服务是SOA的一个特定风味，主要区别在于对粒度、自治和隔离的关注。如果你想了解更多关于微服务的信息，你还可以查看[https://www.linkedin.com/pulse/soa-microservices-isolation-evolution-diego-pacheco](https://www.linkedin.com/pulse/soa-microservices-isolation-evolution-diego-pacheco)以及[http://microservices.io/](http://microservices.io/)。
- en: Performance
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: The right algorithm might make your application work smoothly and the wrong
    algorithm might make your users have a poor experience. Performance is achieved
    by design--first of all, choose the right set of collections and the right set
    of algorithms and frameworks. However, performance needs to be measured and tuned
    eventually. The practice you should do in your application with regard of performance
    is stress testing. The best stress testing tools in the Scala ecosystem is Gatling.
    Gatling ([http://gatling.io/#/](http://gatling.io/#/)) allows you to code in Scala
    using a very simple yet powerful DSL. Gatling focuses on HTTP and latency percentiles
    and distributions, which is the right thing to do nowadays. Latency is not only
    used for the sake of performance and scalability, but it is also heavily related
    to user experience as everything is online.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的算法可以使你的应用程序运行顺畅，而错误的算法可能会让用户有糟糕的体验。性能是通过设计实现的——首先，选择正确的集合集和算法集以及框架集。然而，性能最终需要被测量和调整。你在应用程序中应该进行的性能实践是压力测试。Scala生态系统中最优秀的压力测试工具是Gatling。Gatling([http://gatling.io/#/](http://gatling.io/#/))允许你使用一个非常简单但强大的DSL在Scala中编码。Gatling专注于HTTP和延迟百分位数和分布，这是当今正确的做法。延迟不仅用于性能和可扩展性，而且与用户体验密切相关，因为一切都在线。
- en: Scalability/Resiliency
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可扩展性/弹性
- en: Scalability is one of the main reasons why we do software architecture, because
    an architecture that does not scale does not have business value. We will continue
    talking about Scalability principles during this chapter. Resiliency is about
    how much the system can resist and keep operating under the most adverse situations,
    such as hardware failure or infrastructure failure. Resiliency is an old term.
    Currently, there is a new and more modern and accurate principle called antifragility.
    This principle was well developed and used in practice by Netflix. Antifragility
    is about systems and architecture that can adapt and fail over to other systems
    and other operational modes to keep working no matter what. If you want to know
    more about antifragility, you can visit [http://diego-pacheco.blogspot.com.br/2015/09/devops-is-about-anti-fragility-not-only.html](http://diego-pacheco.blogspot.com.br/2015/09/devops-is-about-anti-fragility-not-only.html)
    and [http://diego-pacheco.blogspot.com.br/2015/11/anti-fragility-requires-chaos.html](http://diego-pacheco.blogspot.com.br/2015/11/anti-fragility-requires-chaos.html).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性是我们进行软件架构的主要原因之一，因为无法扩展的架构没有商业价值。我们将继续在本章中讨论可扩展性原则。弹性是指系统在极端不利情况下（如硬件故障或基础设施故障）能够抵抗并保持运行的能力。弹性是一个旧术语。目前，有一个新的、更现代、更准确的原理，称为反脆弱性。这个原理在Netflix得到了很好的发展和实际应用。反脆弱性是关于系统和架构能够适应并转移到其他系统和操作模式以保持工作状态的能力。如果你想了解更多关于反脆弱性的信息，你可以访问[http://diego-pacheco.blogspot.com.br/2015/09/devops-is-about-anti-fragility-not-only.html](http://diego-pacheco.blogspot.com.br/2015/09/devops-is-about-anti-fragility-not-only.html)和[http://diego-pacheco.blogspot.com.br/2015/11/anti-fragility-requires-chaos.html](http://diego-pacheco.blogspot.com.br/2015/11/anti-fragility-requires-chaos.html)。
- en: Scalability principles
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展性原则
- en: Having architecture around these principles makes it possible to scale your
    application up. However, we will still need to rely on other principles and techniques
    to scale it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕这些原则构建的架构使得扩展你的应用程序成为可能。然而，我们仍然需要依赖其他原则和技术来扩展它。
- en: 'There are several principles and techniques for scalability, which are as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着几个关于可扩展性的原则和技术，如下所述：
- en: Vertical and horizontal scaling (up and out)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直和水平扩展（向上和向外）
- en: Caching
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Proxy
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: Load balancer
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡器
- en: Throttling
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节流
- en: Database cluster
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库集群
- en: Cloud computing/containers
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云计算/容器
- en: Auto Scaling
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动扩展
- en: Reactive drivers
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式驱动器
- en: Vertical and horizontal scaling (up and out)
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垂直和水平扩展（向上和向外）
- en: You can add more resources, have better hardware, or you can add more boxes.
    These are the two basic ways to scale. You can always improve and tune your app
    to use fewer resources and get more from a single box. Recently, there were several
    improvements in this area around reactive programming that uses fewer resources
    and delivers more throughput. However, there are always limits to which a single
    box can provide in sense of scaling up, which is why we always need to be able
    to scale out.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加更多资源，拥有更好的硬件，或者你可以添加更多盒子。这是两种基本的扩展方式。你总是可以改进和调整你的应用程序，以使用更少的资源并从单个盒子中获得更多。最近，在反应式编程方面有一些改进，使用更少的资源并提供了更高的吞吐量。然而，单个盒子在扩展方面总是存在限制，这就是为什么我们总是需要能够向外扩展。
- en: Caching
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存
- en: Databases are great. However, there is a latency cost to call a traditional
    database. A great way to fix this is having a memory cache, which you can use
    as a subset of your data and get the benefit of fast retrieval. Play framework
    has cache support. If you want to learn more, check out [https://www.playframework.com/documentation/2.5.x/ScalaCache](https://www.playframework.com/documentation/2.5.x/ScalaCache).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库很棒。然而，调用传统数据库会有延迟成本。一个很好的解决方案是拥有内存缓存，你可以将其用作数据子集并从中获得快速检索的好处。Play框架支持缓存。如果你想了解更多，请查看[https://www.playframework.com/documentation/2.5.x/ScalaCache](https://www.playframework.com/documentation/2.5.x/ScalaCache)。
- en: 'There are other options in sense of caching. There are lots of companies that
    use the memory as a definitive data store nowadays. For this, you can consider
    tools such as Redis ([http://redis.io/](http://redis.io/)) and Memcached ([https://memcached.org/](https://memcached.org/)).
    However, if you want to scale Redis and Memcached, you will need something like
    Netflix/Dynomite ([https://github.com/Netflix/dynomite](https://github.com/Netflix/dynomite)).
    Dynomite provides a cluster based on AWS Dynamo paper for Redis, which has the
    following benefits:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓存方面还有其他选项。现在有很多公司使用内存作为最终的数据存储。为此，你可以考虑使用Redis ([http://redis.io/](http://redis.io/))
    和Memcached ([https://memcached.org/](https://memcached.org/)) 等工具。然而，如果你想扩展Redis和Memcached，你需要像Netflix/Dynomite
    ([https://github.com/Netflix/dynomite](https://github.com/Netflix/dynomite)) 这样的东西。Dynomite提供了一个基于AWS
    Dynamo论文的集群，对于Redis有以下好处：
- en: High throughput and low latency
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高吞吐量和低延迟
- en: Multi-region support (AWS cloud)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多区域支持（AWS云）
- en: Token aware
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令牌感知
- en: Consistent hashing
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致性哈希
- en: Replication
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制
- en: Sharding
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分片
- en: High availability
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高可用性
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to learn more about dynomite, check out [https://github.com/Netflix/dynomite/wiki](https://github.com/Netflix/dynomite/wiki).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于Dynomite的信息，请查看[https://github.com/Netflix/dynomite/wiki](https://github.com/Netflix/dynomite/wiki)。
- en: Load balancer
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 负载均衡器
- en: A load balancer is a key tool to scale servers. So, let's say, you have 10 boxes
    with our Play framework application or 10 Docker containers. We will need something
    in front of our application to distribute the traffic. There are several servers
    that can do this, such as NGINX ([https://nginx.org/](https://nginx.org/)) and
    Apache HTTP Server ([https://httpd.apache.org/](https://httpd.apache.org/)). If
    you want to scale your application, this is the easiest solution for it. Configuration
    and more details can be found at [https://www.playframework.com/documentation/2.5.x/HTTPServer#Setting-up-a-front-end-HTTP-server](https://www.playframework.com/documentation/2.5.x/HTTPServer#Setting-up-a-front-end-HTTP-server).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器是扩展服务器的关键工具。所以，比如说，你拥有10个运行我们的Play框架应用程序的盒子或10个Docker容器。我们将在应用程序前面需要一些东西来分发流量。有几个服务器可以完成这项工作，例如NGINX
    ([https://nginx.org/](https://nginx.org/)) 和Apache HTTP服务器 ([https://httpd.apache.org/](https://httpd.apache.org/))。如果你想扩展你的应用程序，这是最简单的解决方案。配置和更多详细信息可以在[https://www.playframework.com/documentation/2.5.x/HTTPServer#Setting-up-a-front-end-HTTP-server](https://www.playframework.com/documentation/2.5.x/HTTPServer#Setting-up-a-front-end-HTTP-server)找到。
- en: Load balancers are often proxy servers as well. You can use them to have HTTPS
    support. If you want, you can have HTTPS on Play framework as well ([https://www.playframework.com/documentation/2.5.x/ConfiguringHttps](https://www.playframework.com/documentation/2.5.x/ConfiguringHttps)).
    Keep in mind that you will need to change swagger embedded installation as all
    the code that we have points to the HTTP interface. If you are doing deploys in
    the AWS cloud, you will need to change some of the configuration to forward the
    proxies, which you can find at [https://www.playframework.com/documentation/2.5.x/HTTPServer#Setting-up-a-front-end-HTTP-server](https://www.playframework.com/documentation/2.5.x/HTTPServer#Setting-up-a-front-end-HTTP-server).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器通常是代理服务器。您可以使用它们来支持HTTPS。如果您愿意，您还可以在Play框架上启用HTTPS ([https://www.playframework.com/documentation/2.5.x/ConfiguringHttps](https://www.playframework.com/documentation/2.5.x/ConfiguringHttps))。请记住，您需要更改swagger嵌入式安装，因为我们所有的代码都指向HTTP接口。如果您在AWS云中进行部署，您需要更改一些配置以转发代理，您可以在[https://www.playframework.com/documentation/2.5.x/HTTPServer#Setting-up-a-front-end-HTTP-server](https://www.playframework.com/documentation/2.5.x/HTTPServer#Setting-up-a-front-end-HTTP-server)找到这些配置。
- en: Throttling
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节流
- en: This is also known as Back pressure. We covered throttling in [Chapter 9](part0110.xhtml#aid-38STS1
    "Chapter 9. Design Your REST API"), *Design Your REST API*. You can get more details
    there. However, the main idea is to limit the request for each user. This is also
    a way to make sure that a single user does not steal all computational resources.
    This is also important from the security point of view, especially for the services
    that are Internet-facing or also known as edge. Another great way to protect and
    have this capability is using Netflix/Zuul ([https://github.com/Netflix/zuul](https://github.com/Netflix/zuul)).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这也被称为背压。我们在第9章“设计您的REST API”中介绍了节流，您可以在此处获取更多详细信息。[第9章](part0110.xhtml#aid-38STS1
    "第9章。设计您的REST API")。您可以在那里了解更多。然而，主要思想是限制每个用户的请求。这也是确保单个用户不会窃取所有计算资源的一种方式。从安全角度来看，这也非常重要，尤其是对于面向互联网或也称为边缘的服务。另一种保护和拥有这种能力的好方法是使用Netflix/Zuul
    ([https://github.com/Netflix/zuul](https://github.com/Netflix/zuul))。
- en: Database cluster
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库集群
- en: 'Sometimes, the problem is not on the application side, but in the database.
    When we talk about scalability, we need be able to scale everything. We need to
    have the same concepts for databases that we have for the Mid-Tier. For databases,
    it is important to work with the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，问题不在于应用层面，而是在数据库中。当我们谈论可伸缩性时，我们需要能够扩展一切。我们需要为数据库拥有与中端相同的理念。对于数据库，以下工作非常重要：
- en: Clustering
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群
- en: Index
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引
- en: Materialized views
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物化视图
- en: Data partition
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据分区
- en: 'For our application, we used the MySQL database. Here are some resources that
    can help you scale the database and apply the previous concepts:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们使用了MySQL数据库。以下是一些可以帮助您扩展数据库并应用先前概念的资源：
- en: '[http://dev.mysql.com/doc/refman/5.7/en/faqs-mysql-cluster.html](http://dev.mysql.com/doc/refman/5.7/en/faqs-mysql-cluster.html)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MySQL 5.7 参考手册 - MySQL集群常见问题解答](http://dev.mysql.com/doc/refman/5.7/en/faqs-mysql-cluster.html)'
- en: '[http://www.fromdual.com/mysql-materialized-views](http://www.fromdual.com/mysql-materialized-views)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MySQL物化视图](http://www.fromdual.com/mysql-materialized-views)'
- en: '[http://dev.mysql.com/doc/refman/5.7/en/optimization-indexes.html](http://dev.mysql.com/doc/refman/5.7/en/optimization-indexes.html)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MySQL 5.7 参考手册 - 优化索引](http://dev.mysql.com/doc/refman/5.7/en/optimization-indexes.html)'
- en: '[http://dev.mysql.com/doc/refman/5.7/en/partitioning.html](http://dev.mysql.com/doc/refman/5.7/en/partitioning.html)'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MySQL 5.7 参考手册 - 分区](http://dev.mysql.com/doc/refman/5.7/en/partitioning.html)'
- en: '[https://dev.mysql.com/doc/refman/5.7/en/partitioning-overview.html](https://dev.mysql.com/doc/refman/5.7/en/partitioning-overview.html)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MySQL 5.7 参考手册 - 分区概述](https://dev.mysql.com/doc/refman/5.7/en/partitioning-overview.html)'
- en: Cloud computing/containers
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云计算/容器
- en: 'Scaling up application in traditional data centers is always hard because we
    need to have the hardware in place. This gets done by the practice of capacity
    planning. Capacity planning is great to make sure we don''t spend money beyond
    our budget. However, it is very hard to get it done right. Software is hard to
    predict, and that''s a great advantage of the cloud. Cloud is just another level
    of abstraction. Hardware and networks become logical, and they are encapsulated
    behind APIs. This makes it easier to scale our application as we can rely on cloud
    elasticity and scale on demand when we need to. However, the architecture needs
    to be ready for this moment and use the tools and techniques described in this
    chapter. Currently, there are several public clouds; the best options are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统数据中心中扩展应用程序总是很困难，因为我们需要硬件就位。这是通过容量规划实践完成的。容量规划很好，可以确保我们不超出预算。然而，正确完成它非常困难。软件难以预测，这是云的一个巨大优势。云只是另一层抽象。硬件和网络变得逻辑化，并且被API封装起来。这使得我们可以依赖云的弹性，并在需要时按需扩展我们的应用程序。然而，架构需要为这一时刻做好准备，并使用本章中描述的工具和技术。目前，有几个公共云；最佳选项如下：
- en: AWS--Amazon Cloud ([https://aws.amazon.com/](https://aws.amazon.com/))
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS--亚马逊云([https://aws.amazon.com/](https://aws.amazon.com/))
- en: Google Cloud ([https://cloud.google.com/](https://cloud.google.com/))
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谷歌云([https://cloud.google.com/](https://cloud.google.com/))
- en: Microsoft Azure Cloud ([https://azure.microsoft.com/en-us/](https://azure.microsoft.com/en-us/))
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软Azure云([https://azure.microsoft.com/en-us/](https://azure.microsoft.com/en-us/))
- en: Today, Cloud is not the only big elephant in the room. We also have the Linux
    containers, such as Docker ([https://www.docker.com/](https://www.docker.com/))
    and LXC ([https://linuxcontainers.org/](https://linuxcontainers.org/)). Containers
    provide another level of abstraction, and they can run on the cloud or on premises.
    This makes your application more portable and also more cost effective. Containers
    also scale. The main advantage around containers is speed and flexibility. It's
    way faster to boot up a container in comparison with a virtualized image in any
    public cloud. They are also portable and can run everywhere.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，云不再是房间里唯一的巨象。我们还有Linux容器，例如Docker([https://www.docker.com/](https://www.docker.com/))和LXC([https://linuxcontainers.org/](https://linuxcontainers.org/))。容器提供了另一层抽象，它们可以在云上或本地运行。这使得您的应用程序更加便携，同时也更加经济高效。容器还可以进行扩展。容器的主要优势在于速度和灵活性。与任何公共云中的虚拟化镜像相比，启动容器要快得多。它们也是便携的，可以在任何地方运行。
- en: Auto Scaling
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动扩展
- en: Currently, this is one of the greatest resources of cloud computing. Basically,
    you can define a base image, which is a state of an operational system such as
    Linux, and the cloud will create and destroy instances for you on demand. These
    instances can be created by the increase in computational resources, such as memory,
    CPU, network, or even based on custom rules. This is the key concern in order
    to have elasticity. If you want to learn more about Auto Scaling, check out [https://aws.amazon.com/autoscaling/](https://aws.amazon.com/autoscaling/).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这是云计算最大的资源之一。基本上，您可以定义一个基础镜像，它是一个操作系统的状态，如Linux，云将根据需求为您创建和销毁实例。这些实例可以通过增加计算资源，如内存、CPU、网络，甚至基于自定义规则来创建。这是实现弹性的关键关注点。如果您想了解更多关于自动扩展的信息，请查看[https://aws.amazon.com/autoscaling/](https://aws.amazon.com/autoscaling/)。
- en: A note about automation
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于自动化的注意事项
- en: In order to use all these techniques and technologies at scale, we need to have
    full automation ([https://en.wikipedia.org/wiki/List_of_build_automation_software](https://en.wikipedia.org/wiki/List_of_build_automation_software))
    because it is impossible to handle all this with manual work. When we are using
    the cloud or containers, there is no other way around; everything needs to be
    automated. There are several tools that help us achieve this goal, such as Ansible
    ([https://www.ansible.com/](https://www.ansible.com/)).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了大规模使用所有这些技术和技术，我们需要实现完全自动化([https://en.wikipedia.org/wiki/List_of_build_automation_software](https://en.wikipedia.org/wiki/List_of_build_automation_software))，因为手动处理这一切是不可能的。当我们使用云或容器时，没有其他选择；一切都需要自动化。有几个工具帮助我们实现这一目标，例如Ansible([https://www.ansible.com/](https://www.ansible.com/))。
- en: Don't forget about telemetry
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要忘记遥测
- en: When you have all infrastructures in place, you will also need to have monitoring,
    alerting, and proper dashboards. There are plenty of great tools for containers
    and public clouds, such as Sensu ([https://sensuapp.org/](https://sensuapp.org/))
    and Prometheus ([https://prometheus.io/](https://prometheus.io/)).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当你所有的基础设施都到位时，你还需要有监控、警报和适当的仪表板。有许多针对容器和公共云的出色工具，例如Sensu ([https://sensuapp.org/](https://sensuapp.org/))
    和 Prometheus ([https://prometheus.io/](https://prometheus.io/))。
- en: Reactive Drivers and discoverability
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反应式驱动器和可发现性
- en: '**Reactive Drivers**: We talked a lot and did a lot of reactive code using
    Play framework and RxScala. However, to have full benefits of ReactiveX programming,
    you need to make sure everything is a non-blocking IO and reactive. In other words,
    we need to have all of our drivers reactive. Slick is great because it gives us
    reactivity with the MySQL database. We will need to apply the same principles
    everywhere we have a driver or connection point. There are lots of libraries becoming
    reactive these days. For instance, if you want to cache using Redis, you can use
    Lettuce ([https://github.com/mp911de/lettuce](https://github.com/mp911de/lettuce)),
    which is reactive.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**反应式驱动器**：我们谈论了很多，也使用Play框架和RxScala编写了很多反应式代码。然而，为了充分利用ReactiveX编程的优势，你需要确保一切都是非阻塞IO和反应式的。换句话说，我们需要让所有的驱动器都是反应式的。Slick很棒，因为它给我们提供了与MySQL数据库的反应性。我们将在有驱动器或连接点的任何地方都需要应用相同的原理。现在有很多库正在变得反应式。例如，如果你想使用Redis进行缓存，你可以使用Lettuce
    ([https://github.com/mp911de/lettuce](https://github.com/mp911de/lettuce))，这是一个反应式库。'
- en: When we work with microservices, we tend to have hundreds of microservice instances.
    These microservices will run on containers and/or cloud computing units. You can't
    point to specific IPs because the code will not be managed and will not survive
    in a cloud/container environment. Cloud/container infrastructure is ephemeral,
    and you don't know when an instance will be terminated. That's why you need to
    be able to switch to another availability zone or region at any moment.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们与微服务一起工作时，我们往往会有数百个微服务实例。这些微服务将在容器和/或云计算单元上运行。你不能指向特定的IP，因为代码将不会被管理，也不会在云/容器环境中生存。云/容器基础设施是短暂的，你不知道何时一个实例会被终止。这就是为什么你需要能够在任何时候切换到另一个可用区域或地区。
- en: There are tools that can help us apply these changes in our code. These tools
    are Netflix/Eureka ([https://github.com/Netflix/eureka](https://github.com/Netflix/eureka))
    and Consul ([https://www.consul.io/](https://www.consul.io/)), or even Apache
    Zookeeper ([https://zookeeper.apache.org/](https://zookeeper.apache.org/)). Eureka
    has one advantage--it is easier to use and has tools around the JVM ecosystem,
    which was battle tested by Netflix.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具可以帮助我们在代码中应用这些更改。这些工具是Netflix/Eureka ([https://github.com/Netflix/eureka](https://github.com/Netflix/eureka))
    和 Consul ([https://www.consul.io/](https://www.consul.io/))，甚至是Apache Zookeeper
    ([https://zookeeper.apache.org/](https://zookeeper.apache.org/))。Eureka有一个优势——它更容易使用，并且有围绕JVM生态系统的工具，这些工具已经由Netflix进行了实战测试。
- en: Eureka is a central registry where microservices register their IP and metadata.
    Eureka has a REST API. Microservices can use the Eureka API to query and search
    existing applications. Eureka can run in a multi-vpc/multi-region environment.
    There are other JVM components, such as ribbon ([https://github.com/Netflix/ribbon](https://github.com/Netflix/ribbon))
    and karyon ([https://github.com/Netflix/karyon](https://github.com/Netflix/karyon)),
    which can automatically register and retrieve eureka information and metadata.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka是一个中央注册中心，微服务在这里注册它们的IP和元数据。Eureka有一个REST API。微服务可以使用Eureka API查询和搜索现有应用程序。Eureka可以在多VPC/多区域环境中运行。还有其他JVM组件，例如ribbon
    ([https://github.com/Netflix/ribbon](https://github.com/Netflix/ribbon)) 和 karyon
    ([https://github.com/Netflix/karyon](https://github.com/Netflix/karyon))，它们可以自动注册和检索Eureka信息和元数据。
- en: Based on the Eureka information, you can perform microservice load balancing
    and fail over to other availability zones and regions automatically. Why use Eureka
    if I can use DNS? DNS for Mid-Tier load balancing is not the right choice as DNS
    is not flexible and the timeout is quite big. If you want know more about discoverability,
    check out [http://microservices.io/patterns/service-registry.html](http://microservices.io/patterns/service-registry.html).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Eureka信息，你可以自动执行微服务负载均衡和故障转移至其他可用区域和地区。为什么我要使用Eureka而不是DNS呢？DNS用于中间层负载均衡并不是一个好的选择，因为DNS不够灵活，超时时间相当长。如果你想了解更多关于可发现性的信息，请查看[http://microservices.io/patterns/service-registry.html](http://microservices.io/patterns/service-registry.html)。
- en: '![Reactive Drivers and discoverability](img/image00335.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![反应式驱动器和可发现性](img/image00335.jpeg)'
- en: Eureka overview - Eureka architecture overview on the AWS cloud
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka概述 - AWS云上的Eureka架构概述
- en: As you can see in the preceding diagram, you will deploy the Eureka server at
    least in three **Availability Zones** (**AZs**) in order to have availability.
    Then, Eureka data will be replicated to each server. Our applications or microservices
    will register in Eureka, and other applications/microservices can retrieve this
    metadata, such as IP address, to them to the REST calls. If you want learn more,
    you can check out [https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance](https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，你至少需要在三个**可用区（AZs**）中部署Eureka服务器，以确保可用性。然后，Eureka数据将复制到每个服务器。我们的应用程序或微服务将在Eureka中注册，其他应用程序/微服务可以通过REST调用检索这些元数据，例如IP地址。如果你想了解更多，你可以查看[https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance](https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance)。
- en: Mid-Tier load balancer, timeouts, Back pressure, and caching
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间层负载均衡器、超时、背压和缓存
- en: Eureka, Zookeeper, or Consul are only one part of the equation. We still need
    some software on the client side that can use the Eureka information in order
    to do Mid-Tier load balancing, fail over, and caching. The Netflix stack has a
    component for that, which is called ribbon ([https://github.com/Netflix/ribbon](https://github.com/Netflix/ribbon)).
    With ribbon, you can automatically resolve the microservice IPs from Eureka, do
    retries, and failover to other AZs and regions. Ribbon has a cache concept; however,
    it is on preloaded cache.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka、Zookeeper或Consul只是方程的一部分。我们仍然需要在客户端上使用一些软件来使用Eureka信息，以便进行中间层负载均衡、故障转移和缓存。Netflix堆栈有一个组件可以做到这一点，称为Ribbon
    ([https://github.com/Netflix/ribbon](https://github.com/Netflix/ribbon))。使用Ribbon，你可以自动从Eureka解析微服务IP，进行重试，并将故障转移到其他可用区（AZ）和地区。Ribbon有一个缓存概念；然而，它是在预加载的缓存上。
- en: Ribbon ideas are simple. The great thing about ribbon is that everything is
    reactive, and you can use RxJava and RxScala in order to work with the stack.
    If you don't want to use ribbon, you can still create a simple integration layer
    with Scala and perform the same concerns, such as load balancing, failover, and
    caching.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Ribbon的理念很简单。Ribbon的伟大之处在于一切都是响应式的，你可以使用RxJava和RxScala来与该堆栈一起工作。如果你不想使用Ribbon，你仍然可以使用Scala创建一个简单的集成层，并执行相同的关注点，例如负载均衡、故障转移和缓存。
- en: What about Back pressure? Back pressure can be done with RxJava and Rxscala,
    and you will be able to do it on the client side as well. You can learn more about
    Back pressure in Rx at [https://github.com/ReactiveX/RxJava/wiki/Backpressure](https://github.com/ReactiveX/RxJava/wiki/Backpressure).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，背压怎么办？背压可以使用RxJava和Rxscala实现，你也将能够在客户端实现它。你可以在Rx的[https://github.com/ReactiveX/RxJava/wiki/Backpressure](https://github.com/ReactiveX/RxJava/wiki/Backpressure)上了解更多关于背压的信息。
- en: So, if I have client-side load balancing, failover, caching, and Back pressure,
    am I good to go? Yes, you are; however, we can always do better. Working with
    microservices is not easy as everything is a remote call, and remote calls can
    fail, hang, or timeout. These cons are hard and dangerous if not managed well.
    There is another solution that can help us a lot with this concept; it is called
    Hystrix ([https://github.com/Netflix/Hystrix](https://github.com/Netflix/Hystrix)).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我有了客户端负载均衡、故障转移、缓存和背压功能，我就可以放心了吗？是的，你可以；然而，我们总是可以做得更好。与微服务一起工作并不容易，因为一切都是远程调用，远程调用可能会失败、挂起或超时。如果不妥善管理，这些缺点既困难又危险。还有一个解决方案可以帮助我们解决这个概念；它被称为Hystrix
    ([https://github.com/Netflix/Hystrix](https://github.com/Netflix/Hystrix))。
- en: Hystrix is a library for the JVM designed for latency and fault tolerance protection.
    At a glance, Hystrix is a wrapper around any remote code that can take time or
    go wrong.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix是为JVM设计的库，用于延迟和容错保护。乍一看，Hystrix是任何可能耗时或出错的外部代码的包装器。
- en: Hystrix has thread isolation and provides a dedicated thread pool for each resource.
    This is great because it prevents you from running out of resources. It has an
    execution pattern called circuit breaker. Circuit breaker will prevent requests
    from tearing down the whole system. Additionally, it has a dashboard where we
    can visualize the circuits, so, at runtime, we can see what's going on. This capability
    is great not only for sense of telemetry, but also because it is easy to troubleshoot
    and visualize where the problem is.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix具有线程隔离功能，并为每个资源提供专门的线程池。这很好，因为它可以防止你耗尽资源。它有一个名为断路器的执行模式。断路器将防止请求破坏整个系统。此外，它有一个仪表板，我们可以在这里可视化电路，因此，在运行时，我们可以看到正在发生什么。这种能力不仅对于监控非常有用，而且因为它易于故障排除和可视化问题所在。
- en: 'It can be further explained with the help of the following flowchart:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用以下流程图进一步解释：
- en: '![Mid-Tier load balancer, timeouts, Back pressure, and caching](img/image00336.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![中继层负载均衡器、超时、背压和缓存](img/image00336.jpeg)'
- en: The code you want to protect will be around a Hystrix command. This command
    can be manipulated in sync or async programming models. The first thing that Hystrix
    will check is if the circuit is closed, which is good, and how it should be. Then,
    it checks if there are threads available for that command, and if there are available
    threads, then the command will be executed. If this fails, it tries to get a fallback
    code, which is a second option that you can provide in case of failure. This fallback
    should be static; however, you can be loading data in the background and then
    return on the fallback. Another option is fallback to other AZ or Region.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要保护的代码将围绕Hystrix命令。这个命令可以在同步或异步编程模型中操作。Hystrix首先会检查电路是否关闭，这是好的，并且应该如何关闭。然后，它会检查是否有可用的线程来执行该命令，如果有可用的线程，则执行该命令。如果失败，它会尝试获取回退代码，这是在失败情况下您可以提供的第二个选项。这个回退应该是静态的；然而，您可以在后台加载数据，然后在回退时返回。另一个选项是回退到其他可用区域或地区。
- en: 'Following is a snapshot of how a Hystrix dashboard circuit breaker view would
    work:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是Hystrix仪表板断路器视图的工作快照：
- en: '![Mid-Tier load balancer, timeouts, Back pressure, and caching](img/image00337.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![中继层负载均衡器、超时、背压和缓存](img/image00337.jpeg)'
- en: In the preceding image, we can see the Hystrix dashboard sample, where we can
    visualize critical information, such as success and error rate and if the circuit
    is open or closed. If you want learn more about the Hystrix dashboard, check out
    [https://github.com/Netflix/Hystrix/wiki/Dashboard](https://github.com/Netflix/Hystrix/wiki/Dashboard).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，我们可以看到Hystrix仪表板的示例，其中我们可以可视化关键信息，例如成功率和错误率以及电路是开启还是关闭。如果您想了解更多关于Hystrix仪表板的信息，请查看[https://github.com/Netflix/Hystrix/wiki/Dashboard](https://github.com/Netflix/Hystrix/wiki/Dashboard)。
- en: Scaling up microservices with an Akka cluster
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Akka集群扩展微服务
- en: Our application also uses Akka. In order to scale Akka, we will need to use
    an Akka cluster. The Akka cluster allows us to clusterize several Actor systems
    in several machines. It has special Actor routers that are cluster aware, and
    we can use these Actors to route requests to the whole cluster; more details can
    be found at [http://doc.akka.io/docs/akka/2.4.9/java/cluster-usage.html#Cluster_Aware_Routers](http://doc.akka.io/docs/akka/2.4.9/java/cluster-usage.html#Cluster_Aware_Routers).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序也使用了Akka。为了扩展Akka，我们需要使用Akka集群。Akka集群允许我们在多台机器上集群化多个Actor系统。它有特殊的集群感知Actor路由器，我们可以使用这些Actor将请求路由到整个集群；更多详细信息可以在[http://doc.akka.io/docs/akka/2.4.9/java/cluster-usage.html#Cluster_Aware_Routers](http://doc.akka.io/docs/akka/2.4.9/java/cluster-usage.html#Cluster_Aware_Routers)找到。
- en: The Akka cluster provides membership protocol and life cycle. Basically, we
    can be notified by the cluster when a new member joins or when a member leaves
    the cluster. Given this capability, it is possible for us to code a scalable solution
    around these semantics. As we know when a member joins, we can deploy more nodes,
    and we can also drop nodes on demand.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Akka集群提供了成员协议和生命周期。基本上，当新成员加入或成员离开集群时，我们可以通过集群得到通知。有了这个功能，我们可以围绕这些语义编写可扩展的解决方案。正如我们所知，当成员加入时，我们可以部署更多节点，我们也可以根据需要删除节点。
- en: A simple sample would be to create an Actor called frontend, and when we see
    this Actor, we could deploy three backend Actors across the cluster. If the frontend
    Actor leaves, we could undeploy the other Actors. All this logic can be archived
    using the membership protocol and clusters events that Akka generates for us.
    A frontend Actor is a not a UI or web application, it is just an Actor that receives
    work. So, let's say we want to generate analytics around our products catalog.
    We could have a frontend Actor who receives that request and delegates the work
    to backend Actors, which will be deployed across the cluster and deliver the analytical
    work.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的示例是创建一个名为 frontend 的 Actor，当我们看到这个 Actor 时，我们可以在集群中部署三个后端 Actor。如果前端 Actor
    离开，我们可以卸载其他 Actor。所有这些逻辑都可以使用 Akka 为我们生成的成员协议和集群事件来实现。前端 Actor 不是一个 UI 或 Web 应用程序，它只是一个接收工作的
    Actor。所以，假设我们想要围绕我们的产品目录生成分析。我们可以有一个前端 Actor 接收这个请求并将工作委托给后端 Actor，这些 Actor 将在集群中部署并执行分析工作。
- en: 'The following image is the process view of an Akka cluster membership protocol:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下图是 Akka 集群成员协议的过程视图：
- en: '![Scaling up microservices with an Akka cluster](img/image00338.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Akka 集群扩展微服务](img/image00338.jpeg)'
- en: As you can see in the preceding image, there is a set of states. First of all,
    the node is joining the cluster; then the node can be up. Once the node is up,
    it can leave the cluster. There are intermediate states, such as leaving and existing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，有一组状态。首先，节点正在加入集群；然后节点可以启动。一旦节点启动，它可以离开集群。还有中间状态，例如离开和存在。
- en: The Akka cluster provides many options to scale our Actor system. Another interesting
    option is to use the pattern of distributed Pub/Sub. If you are familiar with
    JMS Topics, it is almost the same idea. For those who are not familiar, you can
    check out [http://doc.akka.io/docs/akka/2.4.9/java/distributed-pub-sub.html](http://doc.akka.io/docs/akka/2.4.9/java/distributed-pub-sub.html).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Akka 集群为我们提供了许多扩展 Actor 系统的选项。另一个有趣的选项是使用分布式 Pub/Sub 模式。如果你熟悉 JMS 主题，这几乎是一个相同的概念。对于那些不熟悉的人，你可以查看[http://doc.akka.io/docs/akka/2.4.9/java/distributed-pub-sub.html](http://doc.akka.io/docs/akka/2.4.9/java/distributed-pub-sub.html)。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want learn more about the Akka cluster, you can check out [http://doc.akka.io/docs/akka/2.4.9/common/cluster.html](http://doc.akka.io/docs/akka/2.4.9/common/cluster.html).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 Akka 集群的信息，你可以查看[http://doc.akka.io/docs/akka/2.4.9/common/cluster.html](http://doc.akka.io/docs/akka/2.4.9/common/cluster.html)。
- en: Scaling up the infrastructure with Docker and AWS cloud
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 和 AWS 云扩展基础设施
- en: Scaling up with the AWS cloud is easy, as at any moment, with a simple click
    on the AWS console, you can change the hardware and use more memory, CPU, or better
    network. Scale-out is not hard; however, we need to have good automation in place.
    The key principle to scale is to have the Auto Scaling groups in place with good
    policies. You can learn more about it at [http://docs.aws.amazon.com/autoscaling/latest/userguide/policy_creating.html](http://docs.aws.amazon.com/autoscaling/latest/userguide/policy_creating.html).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AWS 云进行扩展非常简单，因为任何时候，只需在 AWS 控制台中简单点击一下，你就可以更改硬件并使用更多的内存、CPU 或更好的网络。向外扩展并不难；然而，我们需要有良好的自动化。扩展的关键原则是拥有具有良好策略的自动扩展组。你可以在[http://docs.aws.amazon.com/autoscaling/latest/userguide/policy_creating.html](http://docs.aws.amazon.com/autoscaling/latest/userguide/policy_creating.html)了解更多信息。
- en: There are other interesting services and components that can help you scale
    your application. However, you will need to keep in mind that this can lead to
    coupling. The IT industry is moving toward the container direction because it
    is faster, and it's easy to deploy in other public clouds.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他有趣的服务和组件可以帮助你扩展你的应用程序。然而，你需要记住，这可能会导致耦合。IT 行业正在向容器方向移动，因为它更快，并且易于在其他公共云中部署。
- en: 'We can scale out with Docker as well, because there are cluster managers that
    can help us scale our containers. Currently, there are several solutions. In the
    sense of capabilities and maturity, the following are the better solutions:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 Docker 进行扩展，因为有一些集群管理器可以帮助我们扩展我们的容器。目前，有几种解决方案。在功能和成熟度方面，以下是一些更好的解决方案：
- en: Docker Swarm ([https://docs.docker.com/swarm/overview/](https://docs.docker.com/swarm/overview/))
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Swarm ([https://docs.docker.com/swarm/overview/](https://docs.docker.com/swarm/overview/))
- en: Kubernetes ([http://kubernetes.io/](http://kubernetes.io/))
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes ([http://kubernetes.io/](http://kubernetes.io/))
- en: Apache Mesos ([http://mesos.apache.org/](http://mesos.apache.org/))
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Mesos ([http://mesos.apache.org/](http://mesos.apache.org/))
- en: '**Docker Swarm**: This is a cluster for Docker. Docker Swarm is very flexible
    and integrates well with other Docker ecosystem tools, such as Docker machine,
    Docker compose, and Consul. It can handle hundreds of nodes, and you can learn
    more about them at [https://blog.docker.com/2015/11/scale-testing-docker-swarm-30000-containers/](https://blog.docker.com/2015/11/scale-testing-docker-swarm-30000-containers/).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker Swarm**：这是一个Docker集群。Docker Swarm非常灵活，并且与其他Docker生态系统工具（如Docker Machine、Docker
    Compose和Consul）集成良好。它可以处理数百个节点，你可以在[https://blog.docker.com/2015/11/scale-testing-docker-swarm-30000-containers/](https://blog.docker.com/2015/11/scale-testing-docker-swarm-30000-containers/)了解更多相关信息。'
- en: '**Kubernetes**: This was created by Google, and it is a full solution for development
    automation, operation, and scaling Docker containers. The Kubernetes cluster has
    two roles, a master node that coordinates the cluster, schedules applications,
    and keeps applications on a desired state; and there are nodes, that are workers
    that run applications. It can handle hundreds of containers and scale very well.
    To learn more about it, check out [http://blog.kubernetes.io/2016/03/1000-nodes-and-beyond-updates-to-Kubernetes-performance-and-scalability-in-12.html](http://blog.kubernetes.io/2016/03/1000-nodes-and-beyond-updates-to-Kubernetes-performance-and-scalability-in-12.html).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubernetes**：这是由谷歌创建的，它是一个针对开发自动化、操作和扩展Docker容器的完整解决方案。Kubernetes集群有两个角色，一个是协调集群、调度应用程序并保持应用程序处于所需状态的master节点；还有节点，即运行应用程序的工作节点。它可以处理数百个容器并且扩展性非常好。想了解更多关于它的信息，请查看[http://blog.kubernetes.io/2016/03/1000-nodes-and-beyond-updates-to-Kubernetes-performance-and-scalability-in-12.html](http://blog.kubernetes.io/2016/03/1000-nodes-and-beyond-updates-to-Kubernetes-performance-and-scalability-in-12.html)。'
- en: '**Apache Mesos**: This was created by Twitter. It is very interesting, as you
    can run a bare metal on a premises datacenter or on a public cloud. Mesos allows
    you to use Docker containers as well. If you want to learn more about mesos, check
    out the following paper:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**Apache Mesos**：这是由Twitter创建的。它非常有趣，因为它可以在本地数据中心或公共云上运行裸金属。Mesos允许你使用Docker容器。如果你想了解更多关于Mesos的信息，请查看以下论文：'
- en: '[http://mesos.berkeley.edu/mesos_tech_report.pdf](http://mesos.berkeley.edu/mesos_tech_report.pdf)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://mesos.berkeley.edu/mesos_tech_report.pdf](http://mesos.berkeley.edu/mesos_tech_report.pdf)'
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to deploy your Play framework application as
    a standalone distribution. Additionally, you learned several architectural principles,
    techniques, and tools, to help you scale out your application to thousands of
    users.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将你的Play框架应用程序作为独立分发进行部署。此外，你还学习了几个架构原则、技术和工具，以帮助你将应用程序扩展到数千用户。
- en: With this, we also reach the end of this book. I hope you enjoyed this journey.
    We built a nice application using Scala, Play Framework, Slick, REST, Akka, Jasper,
    and RxScala. Thank you for your time. I wish you the best in your coding career
    with the Scala language.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们也到达了这本书的结尾。希望你喜欢这次旅程。我们使用Scala、Play Framework、Slick、REST、Akka、Jasper和RxScala构建了一个不错的应用程序。感谢你抽出时间。我祝愿你在Scala语言编码生涯中一切顺利。
