- en: Switch Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`switch`表达式'
- en: With `switch` expressions, Java 12 is enhancing one of its basic language constructs—`switch`—to
    improve the everyday coding experience of developers. The benefits of this are
    manifold. As compared to **traditional** `switch` constructs, `switch` expressions
    (**JDK Enhancement Proposal** (**JEP**) 325—[http://openjdk.java.net/jeps/325](http://openjdk.java.net/jeps/325))
    can return a value. The ability to define multiple constants with a `switch` branch,
    and improve code semantics, make it concise. By removing default fall through
    of control across `switch` branches, you are less likely to introduce a logical
    error in a `switch` expression.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`switch`表达式，Java 12正在增强其基本语言结构之一——`switch`——以改善开发者的日常编码体验。这种做法的好处是多方面的。与**传统**的`switch`结构相比，`switch`表达式（JDK增强提案**JEP**
    325—[http://openjdk.java.net/jeps/325](http://openjdk.java.net/jeps/325)）可以返回一个值。通过在`switch`分支中定义多个常量并改进代码语义，可以使代码更加简洁。通过移除`switch`分支间的默认穿透控制，你不太可能在`switch`表达式中引入逻辑错误。
- en: 'In this chapter, you''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将涵盖以下主题：
- en: Issues with existing `switch` statements
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有`switch`语句的问题
- en: The `switch` expression syntax
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch`表达式语法'
- en: Defining local variables in `switch` branches
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`switch`分支中定义局部变量
- en: The extended `break` statement
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展的`break`语句
- en: Comparing `break` with `break <return value>`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较`break`与`break <返回值>`
- en: Exhaustive cases
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全情况
- en: A preview language feature
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预览语言特性
- en: Using `return` and `continue` in `switch` expressions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`switch`表达式中使用`return`和`continue`
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To compile and execute the code included in this chapter, install JDK 12 on
    your system. All code in this chapter can be accessed using the following URL: [https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和执行本章包含的代码，请在您的系统上安装 JDK 12。本章中的所有代码都可以通过以下 URL 访问：[https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features)。
- en: Let's get started by covering the issues with existing `switch` statements.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从解决现有`switch`语句的问题开始。
- en: Issues with traditional switch constructs
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统`switch`结构的问题
- en: At present, the syntax of `switch` statements is highly constrained. It is not
    as powerful as the `if-else` construct. With `if-else` constructs, you can define
    and match complex patterns; but not with the `switch` construct. Also, the syntax
    of `switch` is verbose, which makes it visually annoying. This can lead to error-prone
    code that can be difficult to debug.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`switch`语句的语法受到高度限制。它不如`if-else`结构强大。使用`if-else`结构，你可以定义和匹配复杂的模式；但使用`switch`结构则不行。此外，`switch`的语法较为冗长，这使其在视觉上令人烦恼。这可能导致易于出错且难以调试的代码。
- en: 'Let''s work with an example to show all of these issues. The following example
    defines an enum, `Size`. The `Shirt` class defines a `setSize()` method, which
    accepts `Size` and accordingly assigns an integer value to the instance variable, `length`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来展示所有这些问题。以下示例定义了一个枚举，`Size`。`Shirt`类定义了一个`setSize()`方法，该方法接受`Size`并根据需要将一个整数值分配给实例变量`length`：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s how you can call the preceding method:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是调用前面方法的示例：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code outputs the following expected results:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码输出以下预期结果：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'However, let''s see what happens when you try executing the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们看看当你尝试执行以下代码时会发生什么：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code outputs an unexpected mismatch in the values:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码输出一个意外的值不匹配：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What do you think is the reason for these mismatching values? To answer this
    question, here's a quick recap—the `switch` branches (that is, the `case` labels)
    in existing `switch` constructs must include a `break` statement to prevent the
    fall through of the control. This essentially means that, when the control finds
    a matching `case` value, it will execute the statements until it finds a `break`
    statement or it reaches the end of the `switch` construct.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为这些不匹配的值的原因是什么？为了回答这个问题，这里有一个快速回顾——现有`switch`结构中的`switch`分支（即`case`标签）必须包含一个`break`语句以防止控制流穿透。这本质上意味着，当控制流找到一个匹配的`case`值时，它将执行语句直到找到一个`break`语句或达到`switch`结构的末尾。
- en: 'On closer inspection, you''ll realize that the branch corresponding to the
    `M` value doesn''t define a `break` statement. The branch corresponding to the
    next case, that is, `L`, misses the `System.out.println` value statement. So,
    when you call `s.setSize(Size.M)`, the following happens:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查后，你会发现对应于 `M` 值的分支没有定义 `break` 语句。对应于下一个情况的分支（即 `L`），缺少了 `System.out.println`
    值语句。因此，当你调用 `s.setSize(Size.M)` 时，以下情况发生：
- en: '`14` is assigned to the `length` instance variable'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`14` 被分配给 `length` 实例变量'
- en: '`System.out.println()` outputs `14`'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`System.out.println()` 输出 `14`'
- en: Control falls through the arm corresponding to the `L` value
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制贯穿与 `L` 值对应的分支
- en: '`16` is assigned to the `length` instance variable'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`16` 被分配给 `length` 实例变量'
- en: The traditional `switch` construct has a **default** fall through of control
    across the `case` labels, in the absence of a `break` statement; this leads to
    unexpected bugs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 传统 `switch` 构造在缺少 `break` 语句的情况下，会在 `case` 标签之间贯穿控制，这可能导致意外的错误。
- en: The `switch` construct works as a block. However, if you revisit the example
    code in the preceding section, you'll agree that the language construct takes
    the focus away from the business logic and introduces complexity.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 构造作为一个块工作。然而，如果你回顾前面章节中的示例代码，你会同意语言构造将焦点从业务逻辑转移开，并引入了复杂性。'
- en: 'This is shown in the following diagram:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下图中展示：
- en: '![](img/b7cccce7-c482-4cd1-bab5-9851cbbb0b41.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7cccce7-c482-4cd1-bab5-9851cbbb0b41.png)'
- en: The new `switch` expressions are here to bring the spotlight back to the business
    logic.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `switch` 表达式旨在将焦点重新投向业务逻辑。
- en: Using switch expressions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 switch 表达式
- en: 'Here''s an example of a traditional `switch` construct that is modifying a
    variable based on an enum value passed to a method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个修改变量的传统 `switch` 构造示例，该变量基于传递给方法的枚举值：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s see how the preceding code changes if we use `switch` expressions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们使用 `switch` 表达式，前面的代码会如何变化：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's compare the new `switch` expressions with traditional `switch` statements.
    The code in the preceding block, which uses `switch` expressions, is a lot more
    concise. You define what to execute on the right of the arrow (`->`). Also, you
    no longer need `break` statements in each `switch` branch. There's less boilerplate
    and less likelihood of accidental errors from missing `break` statements.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较新的 `switch` 表达式与传统 `switch` 语句。前面代码块中使用 `switch` 表达式的代码要简洁得多。你定义在箭头（`->`）右侧要执行的操作。此外，你不再需要在每个
    `switch` 分支中使用 `break` 语句。减少了样板代码，减少了由于缺少 `break` 语句而导致的意外错误的可能性。
- en: 'The following diagram highlights the changes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图解突出了这些变化：
- en: '![](img/472b3507-f596-4955-ba13-988f009112fd.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/472b3507-f596-4955-ba13-988f009112fd.png)'
- en: These `switch` expressions are in addition to traditional `switch` constructs.
    They are not here to replace existing `switch` constructs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `switch` 表达式是传统 `switch` 构造的补充。它们并不是要取代现有的 `switch` 构造。
- en: 'A `switch` expression offers multiple benefits and features:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 表达式提供了多个优点和特性：'
- en: Unlike a `switch` statement, a `switch` expression can return a value
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `switch` 语句不同，`switch` 表达式可以返回一个值
- en: The return value for a `switch` branch is defined to the right of `->`
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch` 分支的返回值定义在 `->` 的右侧'
- en: The same `switch` branch can define multiple labels that are separated using
    `,`
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一个 `switch` 分支可以定义多个使用逗号（`,`）分隔的标签
- en: There isn't any default fall through of the control across `switch` branches
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `switch` 分支之间没有默认的贯穿控制
- en: The code is less verbose
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码更简洁
- en: Let's work with the finer details of `switch` expressions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨 `switch` 表达式的更细微的细节。
- en: Defining local variables in a switch branch
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 `switch` 分支中定义局部变量
- en: It is possible to define variables that are local to a `switch` branch. To do
    so, a `switch` branch can define a block of code to execute for a matching `case`
    label. To return the value from the branch, it can include a `break` statement
    specifying the value to return.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义局部于 `switch` 分支的变量。为此，`switch` 分支可以定义一个代码块来执行匹配的 `case` 标签。要从中返回值，它可以在其中包含一个指定要返回的值的
    `break` 语句。
- en: 'Let''s modify the code in the preceding example to define a code block, as
    follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改前面示例中的代码，以定义一个代码块，如下所示：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The scope and accessibility of the local variable, `radius`, are limited to
    the `switch` branch, in which it is defined.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量 `radius` 的作用域和可访问性仅限于定义它的 `switch` 分支。
- en: Another syntax for switch expressions
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`switch` 表达式的另一种语法'
- en: 'Apart from using `->` to specify the return value, a `switch` expression can
    also use a colon (`:`) to mark the beginning of the code to execute and a `break`
    statement to return a value. Here''s an example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 `->` 来指定返回值之外，`switch` 表达式还可以使用冒号（`:`）来标记要执行的代码的开始，并使用 `break` 语句来返回一个值。以下是一个示例：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Comparing break with break <return value>
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较 `break` 与 `break <return value>`
- en: A `break` statement of the `break <return value>` form is referred to as an **extended
    break statement**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 形式为 `break <return value>` 的 `break` 语句被称为**扩展的 break 语句**。
- en: A traditional `switch` construct uses a `break` statement without any return
    values in its `switch` branches, to take control out of a `switch` construct.
    This also <indexentry content="break:comparing, with break ">prevents fall through
    the control <indexentry content="break :comparing, with break">across multiple
    `switch` branches. A `switch` expression uses a `break` statement with a return
    value and breaks out of `switch` expressions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 `switch` 构造在 `switch` 分支中不包含任何返回值的 `break` 语句，以从 `switch` 构造中退出控制。这也防止了在多个
    `switch` 分支之间的控制跳过。`switch` 表达式使用带返回值的 `break` 语句并从 `switch` 表达式中退出。
- en: 'Let''s compare the `break` statement with the `return` statement, which can
    be used with or without a value. In a method, you can use a `return` statement
    to return a value and exit a method or just exit a method without returning a
    value. Here''s a quick example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较 `break` 语句和 `return` 语句，后者可以带或不带值使用。在方法中，你可以使用 `return` 语句返回一个值并退出方法，或者只是退出方法而不返回值。以下是一个快速示例：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A `switch` expression uses `break` to return a value. A traditional `switch`
    construct uses a `break` statement to prevent the fall through of control across
    its `case` labels.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 表达式使用 `break` 来返回一个值。传统的 `switch` 构造使用 `break` 语句来防止控制流在其 `case` 标签之间跳过。'
- en: A preview language feature
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预览语言特性
- en: A `switch` expression is a preview language feature (JEP 12). This essentially
    means that, even though it is complete, it has a possibility of not being confirmed
    as a permanent feature in a future Java release. This happens for a reason.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 表达式是一个预览语言特性（JEP 12）。这本质上意味着，尽管它是完整的，但它有可能在未来 Java 版本中不被确认为一个永久性特性。这有一个原因。'
- en: Java runs on billions of devices and is used by millions of developers. The
    risks are high for any mistake in a new Java language feature. Before permanently
    adding a language feature to Java, the architects of Java evaluate what the developers
    have to say about it—that is, how good or bad it is. Depending on the feedback,
    a preview language feature might be refined before it's added to Java SE or dropped
    completely. So, if you have any feedback on `switch` expressions, please share
    it with `amber-dev` ([https://mail.openjdk.java.net/mailman/listinfo/amber-dev](https://mail.openjdk.java.net/mailman/listinfo/amber-dev)).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Java 在数十亿台设备上运行，并被数百万开发者使用。任何新的 Java 语言特性中的错误都存在高风险。在永久性地将语言特性添加到 Java 之前，Java
    的架构师会评估开发者对它的反馈——也就是说，它有多好或多坏。根据反馈，预览语言特性可能会在添加到 Java SE 之前进行改进，或者完全取消。因此，如果你对
    `switch` 表达式有任何反馈，请与 `amber-dev` 分享（[https://mail.openjdk.java.net/mailman/listinfo/amber-dev](https://mail.openjdk.java.net/mailman/listinfo/amber-dev)）。
- en: Exhaustive cases
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 穷尽情况
- en: A `switch` expression can be used to return a value or just execute a set of
    statements, like the traditional `switch` statement.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 表达式可以用来返回一个值或仅执行一组语句，就像传统的 `switch` 语句一样。'
- en: When you are using a `switch` expression to return a value that is used to assign
    a value to a variable, its cases must be exhaustive. This essentially means that,
    whatever value you pass to the `switch` argument, it must be able to find an appropriate
    branch to execute. A `switch` expression can accept arguments of the `byte`, `short`,
    `int`, `Byte`, `Short`, `Integer`, or `String` types or enums. Of these, only
    an enum has exhaustive values.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `switch` 表达式返回一个值并将其用于给变量赋值时，其情况必须是穷尽的。这本质上意味着，无论你传递给 `switch` 参数的值是什么，它都必须能够找到一个适当的分支来执行。`switch`
    表达式可以接受 `byte`、`short`、`int`、`Byte`、`Short`、`Integer` 或 `String` 类型的参数或枚举。在这些中，只有枚举有穷尽值。
- en: 'In the following example, a `switch` expression is being used to assign a value
    to the `damage` variable. Since there is no matching branch to execute for the `PLATE` value,
    this code won''t compile:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`switch` 表达式被用来给 `damage` 变量赋值。由于没有匹配的分支来执行 `PLATE` 值，这段代码将无法编译：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To compile the preceding code, you can either add the `switch` branch with
    the `case` label, `PLATE`, or add a `default` branch, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译前面的代码，你可以添加带有`case`标签`PLATE`的`switch`分支，或者添加一个`default`分支，如下所示：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For `switch` arguments such as primitive types, wrapper classes, or `String` classes,
    which don''t have an exhaustive list of values, you must define a default `case` label
    (if you are returning a value from `switch` expressions), as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像原始类型、包装类或`String`类这样的`switch`参数，它们没有穷尽的值列表，你必须定义一个默认的`case`标签（如果你从`switch`表达式中返回值），如下所示：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s work with the second situation where you are *not* using `switch` expressions
    to return a value. The following code modifies the `getBook()` method from the
    preceding code. Though `switch` expressions use the new syntax (using `->` to
    define the code to execute), it is *not* returning a value. In such a case, the
    cases of a `switch` expression need *not* be exhaustive:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看第二种情况，即你*不*使用`switch`表达式来返回值。以下代码修改了前面代码中的`getBook()`方法。尽管`switch`表达式使用了新的语法（使用`->`来定义要执行的代码），但它*不*返回值。在这种情况下，`switch`表达式的case不需要是穷尽的：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When you use `switch` expressions to return a value, its cases must be exhaustive,
    otherwise, your code won't compile. When you are using `switch` expressions to
    execute a set of statements without returning a value, it's cases might not be
    exhaustive.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`switch`表达式返回值时，其case必须是穷尽的，否则你的代码将无法编译。当你使用`switch`表达式执行一组语句而不返回值时，其case可能不是穷尽的。
- en: What can a switch branch execute other than returning a value?
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`switch`分支除了返回值之外还能执行什么？'
- en: 'In a `switch` expression, when a `switch` branch isn''t returning a value,
    it can execute a single statement, a block of statements, or even throw an exception.
    In the following example, the `switch` statement is not returning a value. It
    executes a single statement (prints out a value) for the `case` label, `Sun`;
    executes a block of code for the `case` labels, `Mon` and `Tue`; and throws an
    exception for its default case:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`switch`表达式中，当一个`switch`分支不返回值时，它可以执行单个语句、一组语句，甚至抛出异常。在以下示例中，`switch`语句不返回值。它为`case`标签`Sun`执行单个语句（打印出一个值），为`case`标签`Mon`和`Tue`执行一组代码，并为默认情况抛出异常：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How not to use labels and continue in switch expressions
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在`switch`表达式中不使用标签和`continue`
- en: 'You can use labels and a `continue` statement within `switch` expressions.
    However, you can''t jump through `switch` expressions by using them as follows.
    Here''s an example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`switch`表达式中使用标签和`continue`语句。然而，你不能像以下这样通过使用它们来跳过`switch`表达式。以下是一个示例：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Summary
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you saw how `switch` expressions have enhanced the traditional
    `switch` statement. You can use `switch` expressions to return a value that can
    be used to initialize variables or reassign values to them. It also makes your
    code less verbose. By removing default fall through of the control across `switch`
    branches, you are less likely to introduce logical errors with `switch` expressions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到了`switch`表达式如何增强了传统的`switch`语句。你可以使用`switch`表达式返回一个值，该值可以用来初始化变量或将值重新分配给它们。这也使你的代码更简洁。通过移除`switch`分支之间的默认穿透，你使用`switch`表达式时更不容易引入逻辑错误。
- en: In the next chapter, we'll cover multiple improvements and additions in JDK
    12.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍JDK 12中的多个改进和新增功能。
