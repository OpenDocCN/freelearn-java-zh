- en: Switch Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With `switch` expressions, Java 12 is enhancing one of its basic language constructs—`switch`—to
    improve the everyday coding experience of developers. The benefits of this are
    manifold. As compared to **traditional** `switch` constructs, `switch` expressions
    (**JDK Enhancement Proposal** (**JEP**) 325—[http://openjdk.java.net/jeps/325](http://openjdk.java.net/jeps/325))
    can return a value. The ability to define multiple constants with a `switch` branch,
    and improve code semantics, make it concise. By removing default fall through
    of control across `switch` branches, you are less likely to introduce a logical
    error in a `switch` expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Issues with existing `switch` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `switch` expression syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining local variables in `switch` branches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The extended `break` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing `break` with `break <return value>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exhaustive cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A preview language feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `return` and `continue` in `switch` expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compile and execute the code included in this chapter, install JDK 12 on
    your system. All code in this chapter can be accessed using the following URL: [https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features).
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started by covering the issues with existing `switch` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Issues with traditional switch constructs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At present, the syntax of `switch` statements is highly constrained. It is not
    as powerful as the `if-else` construct. With `if-else` constructs, you can define
    and match complex patterns; but not with the `switch` construct. Also, the syntax
    of `switch` is verbose, which makes it visually annoying. This can lead to error-prone
    code that can be difficult to debug.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s work with an example to show all of these issues. The following example
    defines an enum, `Size`. The `Shirt` class defines a `setSize()` method, which
    accepts `Size` and accordingly assigns an integer value to the instance variable, `length`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how you can call the preceding method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code outputs the following expected results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'However, let''s see what happens when you try executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code outputs an unexpected mismatch in the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What do you think is the reason for these mismatching values? To answer this
    question, here's a quick recap—the `switch` branches (that is, the `case` labels)
    in existing `switch` constructs must include a `break` statement to prevent the
    fall through of the control. This essentially means that, when the control finds
    a matching `case` value, it will execute the statements until it finds a `break`
    statement or it reaches the end of the `switch` construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'On closer inspection, you''ll realize that the branch corresponding to the
    `M` value doesn''t define a `break` statement. The branch corresponding to the
    next case, that is, `L`, misses the `System.out.println` value statement. So,
    when you call `s.setSize(Size.M)`, the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '`14` is assigned to the `length` instance variable'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`System.out.println()` outputs `14`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Control falls through the arm corresponding to the `L` value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`16` is assigned to the `length` instance variable'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The traditional `switch` construct has a **default** fall through of control
    across the `case` labels, in the absence of a `break` statement; this leads to
    unexpected bugs.
  prefs: []
  type: TYPE_NORMAL
- en: The `switch` construct works as a block. However, if you revisit the example
    code in the preceding section, you'll agree that the language construct takes
    the focus away from the business logic and introduces complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7cccce7-c482-4cd1-bab5-9851cbbb0b41.png)'
  prefs: []
  type: TYPE_IMG
- en: The new `switch` expressions are here to bring the spotlight back to the business
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Using switch expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s an example of a traditional `switch` construct that is modifying a
    variable based on an enum value passed to a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how the preceding code changes if we use `switch` expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's compare the new `switch` expressions with traditional `switch` statements.
    The code in the preceding block, which uses `switch` expressions, is a lot more
    concise. You define what to execute on the right of the arrow (`->`). Also, you
    no longer need `break` statements in each `switch` branch. There's less boilerplate
    and less likelihood of accidental errors from missing `break` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram highlights the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/472b3507-f596-4955-ba13-988f009112fd.png)'
  prefs: []
  type: TYPE_IMG
- en: These `switch` expressions are in addition to traditional `switch` constructs.
    They are not here to replace existing `switch` constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `switch` expression offers multiple benefits and features:'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike a `switch` statement, a `switch` expression can return a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return value for a `switch` branch is defined to the right of `->`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same `switch` branch can define multiple labels that are separated using
    `,`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There isn't any default fall through of the control across `switch` branches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code is less verbose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's work with the finer details of `switch` expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Defining local variables in a switch branch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to define variables that are local to a `switch` branch. To do
    so, a `switch` branch can define a block of code to execute for a matching `case`
    label. To return the value from the branch, it can include a `break` statement
    specifying the value to return.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the code in the preceding example to define a code block, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The scope and accessibility of the local variable, `radius`, are limited to
    the `switch` branch, in which it is defined.
  prefs: []
  type: TYPE_NORMAL
- en: Another syntax for switch expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from using `->` to specify the return value, a `switch` expression can
    also use a colon (`:`) to mark the beginning of the code to execute and a `break`
    statement to return a value. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Comparing break with break <return value>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `break` statement of the `break <return value>` form is referred to as an **extended
    break statement**.
  prefs: []
  type: TYPE_NORMAL
- en: A traditional `switch` construct uses a `break` statement without any return
    values in its `switch` branches, to take control out of a `switch` construct.
    This also <indexentry content="break:comparing, with break ">prevents fall through
    the control <indexentry content="break :comparing, with break">across multiple
    `switch` branches. A `switch` expression uses a `break` statement with a return
    value and breaks out of `switch` expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compare the `break` statement with the `return` statement, which can
    be used with or without a value. In a method, you can use a `return` statement
    to return a value and exit a method or just exit a method without returning a
    value. Here''s a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A `switch` expression uses `break` to return a value. A traditional `switch`
    construct uses a `break` statement to prevent the fall through of control across
    its `case` labels.
  prefs: []
  type: TYPE_NORMAL
- en: A preview language feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `switch` expression is a preview language feature (JEP 12). This essentially
    means that, even though it is complete, it has a possibility of not being confirmed
    as a permanent feature in a future Java release. This happens for a reason.
  prefs: []
  type: TYPE_NORMAL
- en: Java runs on billions of devices and is used by millions of developers. The
    risks are high for any mistake in a new Java language feature. Before permanently
    adding a language feature to Java, the architects of Java evaluate what the developers
    have to say about it—that is, how good or bad it is. Depending on the feedback,
    a preview language feature might be refined before it's added to Java SE or dropped
    completely. So, if you have any feedback on `switch` expressions, please share
    it with `amber-dev` ([https://mail.openjdk.java.net/mailman/listinfo/amber-dev](https://mail.openjdk.java.net/mailman/listinfo/amber-dev)).
  prefs: []
  type: TYPE_NORMAL
- en: Exhaustive cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `switch` expression can be used to return a value or just execute a set of
    statements, like the traditional `switch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: When you are using a `switch` expression to return a value that is used to assign
    a value to a variable, its cases must be exhaustive. This essentially means that,
    whatever value you pass to the `switch` argument, it must be able to find an appropriate
    branch to execute. A `switch` expression can accept arguments of the `byte`, `short`,
    `int`, `Byte`, `Short`, `Integer`, or `String` types or enums. Of these, only
    an enum has exhaustive values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, a `switch` expression is being used to assign a value
    to the `damage` variable. Since there is no matching branch to execute for the `PLATE` value,
    this code won''t compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the preceding code, you can either add the `switch` branch with
    the `case` label, `PLATE`, or add a `default` branch, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For `switch` arguments such as primitive types, wrapper classes, or `String` classes,
    which don''t have an exhaustive list of values, you must define a default `case` label
    (if you are returning a value from `switch` expressions), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s work with the second situation where you are *not* using `switch` expressions
    to return a value. The following code modifies the `getBook()` method from the
    preceding code. Though `switch` expressions use the new syntax (using `->` to
    define the code to execute), it is *not* returning a value. In such a case, the
    cases of a `switch` expression need *not* be exhaustive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When you use `switch` expressions to return a value, its cases must be exhaustive,
    otherwise, your code won't compile. When you are using `switch` expressions to
    execute a set of statements without returning a value, it's cases might not be
    exhaustive.
  prefs: []
  type: TYPE_NORMAL
- en: What can a switch branch execute other than returning a value?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a `switch` expression, when a `switch` branch isn''t returning a value,
    it can execute a single statement, a block of statements, or even throw an exception.
    In the following example, the `switch` statement is not returning a value. It
    executes a single statement (prints out a value) for the `case` label, `Sun`;
    executes a block of code for the `case` labels, `Mon` and `Tue`; and throws an
    exception for its default case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How not to use labels and continue in switch expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use labels and a `continue` statement within `switch` expressions.
    However, you can''t jump through `switch` expressions by using them as follows.
    Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you saw how `switch` expressions have enhanced the traditional
    `switch` statement. You can use `switch` expressions to return a value that can
    be used to initialize variables or reassign values to them. It also makes your
    code less verbose. By removing default fall through of the control across `switch`
    branches, you are less likely to introduce logical errors with `switch` expressions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover multiple improvements and additions in JDK
    12.
  prefs: []
  type: TYPE_NORMAL
