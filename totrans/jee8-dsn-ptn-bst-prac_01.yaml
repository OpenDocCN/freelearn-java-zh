- en: Introduction to Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce design patterns, looking at reasons to use them,
    how they differ from enterprise patterns, and how they behave in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we assume that you are already familiar with the Java programming language
    and Java EE, our goal is not to teach Java EE, but to demonstrate its most common
    design patterns. We will also demonstrate examples of the implementation of design
    patterns using Java EE 8\. Furthermore, we will demonstrate the best way to implement
    design patterns and discuss the benefits of using design patterns and enterprise
    patterns. If you do not know about design patterns and enterprise patterns, then
    this book will be a great tool for learning about the concepts and implementations
    of design patterns and enterprise patterns. If you already know about design patterns
    and enterprise patterns, then this book will be a great point of reference to
    address when implementing them. We''ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the advantages of design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the basic design patterns of the Java world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining enterprise patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the difference between design patterns and enterprise patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design patterns are sets of solutions to common design problems that occur over
    and over in development. They work as a solution template in which an abstract
    solution for a common problem is described and the user then applies it, adapting
    it to their problem. In object-oriented programming, the design pattern provides
    a way to design reusable classes and objects for a specific problem as well as
    defining the relationship between objects and classes. In addition, design patterns
    provide a common idiom among programming languages that allows architects and
    software developers to communicate about a common and recurring problem regardless
    of the programming language they are using. With this, we are able to identify
    a problem and its solution by the name of the pattern and thinking about a solution
    by a model point of view in a high abstraction level of language programming details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The design patterns theme gained strength in 1994 after the *Gang of Four*
    (formed by Rich Gamma, Richard Helm, Ralph Johnson, and John Vlissides) wrote *Design
    Patterns*: *Elements of Reusable Object‐Oriented Software*. Here, they described
    23 design patterns that were later known as GoF design patterns and are still
    used today.'
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the Gang of Four design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Gang of Four** (**GoF**) design patterns are 23 patterns that are classified
    as creational patterns, structural patterns, and behavioral patterns. The creational
    patterns control the creation and initialization of the object and class selection;
    the structural patterns define the relationship between classes and objects, and
    the behavioral patterns control the communication and interaction between objects. As
    well as this, the GoF design patterns have two types of scope which define the
    focus of solutions. These scopes are *object scope,* which resolves problems about
    object relations, and *class scope, *which resolves problems about class relations.
  prefs: []
  type: TYPE_NORMAL
- en: The *object scope* works with composition and the behavior changes are done
    in a runtime. Thus, the object can have a dynamic behavior. The class scope works
    with inheritance and its behavior is static-fixed at compile-time way. Then, to
    change the behavior of a class-scope pattern, we need to change the class and
    recompile.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns classified as class scope solve problems about the relationship between
    classes and are static (fixed at compile time and cannot be changed once compiled).
    However, patterns classified under the object scope solve problems about the relationship
    between objects and can be changed at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows us the three classifications, as well as their
    patterns and scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cc41ee8-491b-4867-9682-d8663b902064.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we can see the **Factory Method** pattern on the **Class** section and
    the **Abstract Factory** pattern on the **Object** section. This occurs because
    the **Factory Method** works with inheritance and the abstract method pattern
    works with composition. Then, the Factory Method is static-fixed at compile time
    and cannot be changed after compilation. However, the **Abstract Factory** is
    dynamic and can be changed at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: GoF design patterns are generally described using a graphical notation such
    as a use case diagram, and an example of the implementation's code. The used notation
    must be able to describe the classes and objects as well as the relationship between
    these classes and objects.
  prefs: []
  type: TYPE_NORMAL
- en: The pattern's name is an important part of the design patterns. This is because
    it is what the developer uses to quickly identify the problem related to the pattern
    and to understand how the pattern will solve it. The name of the pattern must
    be brief and refer to the problem and its solution.
  prefs: []
  type: TYPE_NORMAL
- en: A design pattern is a great tool for designing software development, but its
    use needs to be analyzed to determine if the design pattern is really required
    in order to solve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: The catalog of Gang of Four design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Names of design patterns need be succinct, making them easy to identify. This
    is because design patterns create a vocabulary for communicating between developers
    independent of programming language, permitting developers to identify problems
    and solutions only by name of a design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In design patterns, a catalog is a set of pattern names which are designed to
    permit a better communication between developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The catalog of GoF''s design patterns has 23 patterns, as shown in the preceding
    diagram. Here is a description of these patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstract Factory**: This provides an interface to create objects without
    specifying their concrete class, making it possible to decouple the business logic
    and the object creation logic. With this, we can update the object creation logic
    in an easy way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adapter**: This provides an interface that makes it possible for two incompatible
    interfaces to work together. The adapter pattern works as a bridge between interfaces,
    adapting these interfaces to work together. Furthermore, the adapter can adopt
    a class or objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bridge**: This patterndecouples an abstraction from its implementation, making
    them vary independently. With this, we can modify the implementations without
    impacting the abstractions and we can also modify the abstractions without impacting
    the implementations. The class of abstraction hides implementations and its complexity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Builder**: This pattern separates the construction of a complex object from
    its representation. With this, we can construct the objects of several representations
    using the same process to that. Thus, we create a standard process of construction
    of objects that have a complex process to construct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chain of responsibility**: This pattern avoids coupling the sender and receiver
    of a request creating some objects that have a chance to treat the requests. These
    objects create a chain of receiver objects for a sender''s request. Each object
    of this chain receives the request and verifies whether or not it will treat this
    request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command**: This pattern encapsulates a request for an object and creates
    a wrapper of requests containing their information about the request. With this,
    we can do a request to some object sending parameters without knowing about this
    operation. Furthermore, the command permits us to execute an `undo` operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composite**: This pattern composes objects into a tree structure, which represents
    a part-whole hierarchy. It permits you to treat a group of objects as a single
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decorator**: This pattern permit extends a functionality of a class with
    flexibility, without use subclass. It allows you to dynamically attach a new responsibility
    to an object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Facade**: This hides the complexity of the system, applying a unified interface
    to a set of interfaces on a subsystem. This makes the subsystem easy to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Factory Method**: This defines an interface for creating an object, and the
    subclass states which class to initiate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flyweight**: This uses sharing to efficiently support a large number of fine-grained
    objects. This pattern reduces the number of objects created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interpreter**: This pattern represents language grammar and uses it to interpret
    them as sentences of a language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterator**: This pattern provides a way to sequentially access the elements of
    a set of objects without knowing its underlying representation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mediator**: This reduces the complexity of communication by creating an object
    that encapsulates all the communication and interaction between objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memento**: This pattern captures the object''s internal states without hurting
    encapsulated concepts, with this, the state of the object can be restored by the
    object. This pattern works as a backup that maintains the current state of an
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observer**: This defines a one-to-many dependency between objects. This means
    that if one object is modified, all of its dependents are automatically notified
    and updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prototype**: This pattern permits us to create a new object using an object
    or instance as a prototype. This pattern creates a copy of an object, creating
    a new object with the same state of the object used as a prototype.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proxy**: This pattern creates a surrogate object (proxy object) for another
    object (original object) in order to control the access to the original object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State:** This permits an object to alter its behavior when its internal state
    changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Singleton**: This ensures that a class has only one instance in the entire
    project, and the same instance of the object is returned every time the creation
    process is performed/run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strategy**: This creates a family of algorithms, encapsulating each one and
    making them interchangeable. This pattern permits you to change the algorithm
    at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Template method**: This defines a skeleton for an algorithm in an operation,
    and the subclass defines some steps to the algorithm. This pattern algorithm structure
    and the subclass redefine some steps of this algorithm without modifying its structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visitor**: This represents an operation to be performed on an object structure.
    This pattern permits us to add new operations to an element without modifying
    its class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the advantages of design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating an object-oriented design is a tough task. This is because we have several
    important elements to think about with regard to the scenario that we'll work
    in and the problem we'll solve. This includes defining the appropriate objects that we
    need to create in order to reach the solution; defining the granularity of objects
    and looking at what interfaces we need to create. These tasks need to be addressed
    during the creation process in design. Objects can be created to represent a real-world
    object or to represent a process with its algorithms and responsibilities. Furthermore,
    we even need to consider the number of objects, their size, and the interface
    we need to access.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns are great tools for helping us to identify classes and objects
    that don't represent real-world objects and objects that are less-obvious abstractions.
    Moreover, design patterns help us to apply the finest granularity to objects and
    they also allow us to analyze a problem and solution as a model. Design patterns
    make the design flexible, providing a decoupling between classes and objects.
    They also provide the ability to organize solutions, allowing delegate responsibilities
    to classes with the best way.
  prefs: []
  type: TYPE_NORMAL
- en: Building software is an expensive process for companies because it requires
    capable professionals and infrastructure to build and maintain the software. Design
    patterns, with their flexibility and decoupled design, make maintenance easy and
    therefore decrease its cost.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basic design patterns of the Java world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All GoF patterns have a good purpose and solve major problems of object-oriented
    design, but some patterns are most commonly used in the Java and Java EE ecosystem.
    In this book, these patterns are treated as basic design patterns because they
    are most commonly used to implement solutions on Java's APIs, frameworks, and
    algorithms. Consequently, understanding these patterns will help us to understand
    these APIs, frameworks, and algorithms, and we'll, in turn, be able to create
    a better solution using Java. These patterns are Singleton, Abstract Factory,
    Facade, Iterator, and Proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining Singleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a software project, in some solutions, we may want to ensure that a class
    has only one instance of an object throughout the project and that this object
    is accessible at any point in the project. Creating a global instance or static
    instance will not ensure that this class will not be used at another point in
    another instance. The best way to solve this is by using the Singleton pattern,
    which ensures that there is only one instance of a class in the entire project.
    In the following diagram, we are showing the structure of Singleton and how it
    is designed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b845e3ba-cca7-4b81-95d9-ef5b8e714936.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we have one class called **Singleton** which has a `private` constructor,
    as well as a reference variable of Singleton and a method for returning its unique
    instance. A good example of an application is a situation in which we want to
    create a class responsible for application configurations (paths to some resource,
    parameters to access filesystems, behaviors of the environment). Often, the application
    has some configurations and we need a class to represent these application configurations.
    Thus, this class of application configuration doesn't need various instances,
    but only one instance.
  prefs: []
  type: TYPE_NORMAL
- en: Another application of Singleton is when we want to create an Abstract Factory
    that will be explained in the following subsection. Generally, we will have only
    one Abstract Factory throughout the application. With this, we can use a Singleton
    to guarantee that we will have only one instance of Abstract Factory.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is often used in frameworks and APIs, but it is common for this
    pattern to be found in the code of projects, mainly on Java EE.
  prefs: []
  type: TYPE_NORMAL
- en: The use of the Singleton pattern can be a good practice depending on the scenario,
    but depending on the scenario the use of Singleton can be a bad practice. The
    Singleton should not be used when the object is stateful and maintain a state,
    because with Singleton the same instance of the object is shared by all processes
    of application and if some process updates a state of this object all processes
    of application will be impacted by this update. Furthermore, we can have a problem
    with the concurrent update of the state of a Singleton.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining Abstract Factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we need to create a family of objects in a project. Imagine that
    we have an e-commerce and we have various kinds of products such as cell phones,
    notebooks, and tablets. These products are objects of the same family. If we create
    objects throughout a software, we will face problems if we then need to modify
    the initialization process of this object.
  prefs: []
  type: TYPE_NORMAL
- en: Using Abstract Factory will help us to solve problems including a system which
    should be independent of how its products are created, a system that should use
    one of the multiple families of products, and a system that should work with objects
    which are designed to be used together. Using this pattern will be beneficial
    as it isolates concrete classes. This means that with this pattern, we can control
    which class of objects that can be initiated on software. Furthermore, it permits
    the exchange of products easily and provides consistency among products.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Abstract Factory pattern creates a single point of creation for objects
    and if we need to change the algorithm of object creation, we need only modify
    the concrete factory. In the following diagram, you can see the structure of Abstract
    Factory and how it is designed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/338bd53e-8bd1-4a15-871f-2f2cc94ffd83.png)'
  prefs: []
  type: TYPE_IMG
- en: In our example, the Abstract Factory's structure has three main classes—`AbstractFactory`,
    `Product`, and `Sale`. The concrete classes of `AbstractFactory` are `CellPhoneFactory`,
    `NotebookFactory`, and `TabletFactory`. `CellPhoneFactory` is a concrete class
    responsible for creating the concrete classes `CellphoneProduct` and `CellphoneSale`,
    `NotebookFactory` is a concrete class responsible for creating the concrete classes
    `NotebookProduct` and `NotebookSale`, and the `TabletFactory` is a concrete class
    responsible for creating the concrete classes `TabletProduct` and `TabletSale`.
    A `Client` is a class responsible for using `AbstractFactory` to create `AbstractProduct`
    and `AbstractSale`. The concrete factory is created at runtime and it then creates
    the concrete product and sale.
  prefs: []
  type: TYPE_NORMAL
- en: The Abstract Factory pattern is sometimes used with another pattern such as
    Singleton, which we described earlier. Abstract Factory is a single point of creation,
    and often we need only one instance of it in an entire system. With this, using
    a Singleton pattern can help us create a design better and more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is often used in frameworks and APIs that have a difficult creation
    process for an object, such as connections or sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining Facade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Projects can sometimes turn out to be very complex and big, making them difficult
    to design and organize. To solve this, a great solution is to break a system into
    subsystems (divide and conquer) and make them less complex and better organized.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Facade pattern creates a higher-level interface to hide a complexity of
    a set of interfaces in a subsystem. This pattern reduces the complexity and coupling,
    minimizing communication and dependencies between subsystems. In the following
    diagram, you can see the structure of **Facade** and how it is designed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13464b99-60bf-42ba-8557-25d1193fd008.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we can see the **Facade** pattern encapsulating all
    of the calls to subsystems and hiding these calls from the client. The system
    has one interface, Facade, and the client calls this interface in order to call
    subsystems. Thus, clients does not call the subsystems directly. With this solution,
    the client doesn't need to know about the subsystem and its complexity.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is often used in projects and systems that have high complexity
    and need to be broken down into subsystems.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining Iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that we want a way to access elements of an aggregate object sequentially
    without exposing its internal structure. The Iterator pattern does just that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Iterator pattern is responsible for sequentially accessing the aggregate
    object and defining an interface to access the elements without exposing the internal
    structure. This interface doesn''t put a new element on the aggregate object,
    but simply reads elements to it. In the following diagram, you can see the structure
    of an **Iterator** and how it is designed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d661cc1e-2e1e-4662-8d77-7110231045b4.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we can see the **Aggregate** and **Iterator **interfaces with
    their concrete subclasses. The client is the class that uses the **Iterator**
    to access elements of **Aggregate**.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is used on Java collections such as list, deque, and set. Understanding
    this pattern will help you to understand Java collections.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining Proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, creating a new object can be a big process and several rules can
    be involved in creating this object. Imagine that we want to create a list of
    objects, and these objects represent telecommunication equipment, which has a
    lot of calculus to generate the information of each object. As well as this, these
    objects will not be accessed at the same time but will be accessed on demand.
    A good strategy is to create each object when it is accessed, thereby minimizing the
    cost and time it takes to create all objects and only access some. The Proxy can
    help us to solve this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Proxy pattern is a pattern that surrogates an object instance (original
    object) to another object instance (Proxy object) that permitting access control
    to the original object. In the following diagram, you can see the structure of
    **Proxy** and how it is designed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/029d3aca-04db-4bb9-b452-d94796b46a09.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding diagram, we can see a structure of the **Proxy** pattern.
    If **Subject** is an interface that clients use to access object operations, then
    **RealSubject** is the class of the original object and **Proxy** is the class
    that works as a **Proxy**. Then, when the client accesses the object, they will
    access the **Proxy** object, and the **Proxy** object will then access the **RealSubject**
    object and return this object to the client.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is used in frameworks and APIs that implement JPA specification
    and **object relational mapping** (**ORM**).
  prefs: []
  type: TYPE_NORMAL
- en: Explaining enterprise patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over time, technology has evolved and new tools have emerged and helped to change
    some areas. Seeing the potential of these technologies, organizations increasingly
    began to use and invest in these tools to automate their processes and optimize
    their costs. These tools then began to be referred to as enterprise software.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise software is a type of software widely used in organizations, companies,
    or governments that provide a service to make their processes better and optimize
    the cost and efficiency. Over time, the complexity of this software increased
    as they began to provide a lot of services. As different services demanded more
    communication, scalability became increasingly important. With this, some problems
    surfaced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enterprise patterns is a set of solutions for common problems that appear in
    enterprise software as a result of the complexity of enterprise environments.
    Many enterprise patterns are based on GoF patterns and differ only in the way
    in which we implement them. On Java EE, enterprise patterns are divided into three
    groups: presentation patterns, business patterns, and integration patterns. These
    patterns act on the presentation tier, business tier, and integration patterns,
    and we''ll cover their details in [Chapter 2](7db5fa69-8dea-4753-80f4-5ca2e8feab28.xhtml),
    *Presentation Patterns*, which covers presentation patterns, [Chapter 3](2e0b5048-f52a-4868-b5d4-b7e8f7f3c6b3.xhtml), *Business
    Patterns*, which covers business patterns, and [Chapter 4](4d4d0c00-31ce-4d19-8547-b95d92500f8c.xhtml),* Integration
    Patterns*, which covers integration patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise patterns are very important for professionals who create software,
    because bad practices in the creation of software could inflate the cost and risks
    involved in the projects. Because of the complexity of the enterprise software,
    an error could propagate along the time and environment, making the enterprise
    environment unsustainable.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the difference between design patterns and enterprise patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Comparing design patterns with enterprise patterns is not an easy task, because
    some behaviors are similar. Design patterns were the first subject that arrived,
    and this was covered in *Design Patterns: Elements of Reusable Object*-*Oriented
    Software*, written by Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides.
    These design patterns were also the base to other patterns. Enterprise patterns
    became necessities that design patterns cannot resolve. This is because the design
    patterns describe solutions for of classes and objects relationships, but the
    enterprise environments have other necessities such as integrations between systems
    and software relations. However, enterprise patterns use some design patterns
    to solve problems.'
  prefs: []
  type: TYPE_NORMAL
- en: The principal difference between design patterns and enterprise patterns is
    the aim; design patterns aim to organize and optimize the object-oriented design,
    and enterprise patterns focus on improving the use of Java EE tools as well as
    making communications between Java EE components better. Design patterns are focused
    on object-oriented and class and object relations, whereas enterprise patterns
    are focused on communication between Java EE components.
  prefs: []
  type: TYPE_NORMAL
- en: The use of design patterns makes it possible to reuse algorithms and also makes
    the design flexible; enterprise design patterns promote an abstraction of the
    complexity of Java EE tools and make it easier for the architecture to make changes.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the complexity of architecture, the minimal use of enterprise patterns
    tends to be worse than the minimal use of design patterns. This is because, with
    the lack of use of enterprise patterns, the professional will always work with
    Java EE's complexity, increasing the probability of error.
  prefs: []
  type: TYPE_NORMAL
- en: Some implementations of Java EE patterns are already present in Java EE tools,
    and this makes them easy to use. In the next chapters, we will describe some of
    these patterns and their implementation using Java EE tools and see how these
    patterns will favor the design and architecture of your project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced you to design patterns, explaining the GoF design
    patterns and their catalog. We covered the basic design patterns of the Java world
    with a brief introduction to Singleton, Abstract Factory, Facade, Iterator, and
    Proxy. As well as this, we looked at enterprise patterns and the difference between
    them and design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explain presentation patterns, including their
    concepts and implementation. We will also demonstrate the concepts of presentation
    patterns and how they help us to write better software. We will then show examples
    of the implementation of presentation patterns, using real-world problems as an
    example.
  prefs: []
  type: TYPE_NORMAL
