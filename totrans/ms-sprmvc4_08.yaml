- en: Chapter 8. Optimizing Your Requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be looking at different techniques to improve our application's
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will implement classical ways of optimizing a web application: cache control
    headers, Gzipping, an application cache, and ETags, as well as more reactive stuff,
    such as asynchronous method calls and WebSockets.'
  prefs: []
  type: TYPE_NORMAL
- en: A production profile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how to define an application properties file
    that will only be read while launching the application with a specific profile.
    We will use the same approach and create an `application-prod.properties` file
    in `src/main/resources`, right next to the existing `application.properties` file.
    This way, we will be able to configure the production environment with optimized
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: We will put a few properties in this file to get started. In [Chapter 3](ch03.html
    "Chapter 3. Handling Forms and Complex URL Mapping"), *Handling Forms and Complex
    URL Mapping*, we deactivated the Thymeleaf cache and forced translation bundles
    to reload on every access.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is great for developing but is useless and time consuming in production.
    So let''s fix that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A cache period of `-1` means caching the bundle forever.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we launch our application with the "prod" profile, templates and bundles
    should be cached forever.
  prefs: []
  type: TYPE_NORMAL
- en: The properties coming from the "prod" profile will indeed overwrite the ones
    declared in our `application.properties` file.
  prefs: []
  type: TYPE_NORMAL
- en: Gzipping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Gzipping** is a compression algorithm widely understood by browsers. Your
    server will serve compressed responses, which will consume a few more CPU cycles
    but will save bandwidth.'
  prefs: []
  type: TYPE_NORMAL
- en: The client browser will then be charged for unzipping the resources and displaying
    them to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To leverage Tomcat''s Gzipping abilities, simply add the following line to
    the `application-prod.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will enable Tomcat's Gzipping compression when serving any file matching
    the MIME types specified in the list, and whose length is greater than 2048 bytes.
    You can set `server.tomcat.compression` to `force` to enforce compression or set
    it to a numerical value if you want to change the value for the minimal length
    of Gzipped assets.
  prefs: []
  type: TYPE_NORMAL
- en: If you want more control over the compression, say over the level of compression,
    or want to exclude user agents from compression, you can use the `GzipFilter`
    class in Jetty by adding the `org.eclipse.jetty:jetty-servlets` dependency to
    your project.
  prefs: []
  type: TYPE_NORMAL
- en: This will automatically trigger the `GzipFilterAutoConfiguration` class, which
    can be configured with a handful of properties prefixed by `spring.http.gzip`.
    Have a look at `GzipFilterProperties` to understand its level of customization.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to the documentation at [http://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-servlet-containers.html#how-to-enable-http-response-compression](http://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-servlet-containers.html#how-to-enable-http-response-compression)
    for additional information.
  prefs: []
  type: TYPE_NORMAL
- en: Cache control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cache control is a set of HTTP headers sent by the server to control how the
    user's browser is allowed to cache resources.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we have seen that Spring Security automatically disables
    caching for secured resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to benefit from cache control, we must first disable that feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, launch the application, go to the main page, and check the Chrome developer
    console. You will see that our JavaScript files are Gzipped and cached, as marked
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cache control](img/2117_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want more control over your cache, you could add handlers for your own
    resources in your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also override the Spring Security default settings. If we want to
    deactivate the "no cache control" policy for our API, we can change the `ApiSecurityConfiguration`
    class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Application cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our web requests have been compressed and cached, the next step we
    can take to reduce server load is to put the results of costly operations in a
    cache. The Twitter search takes some time and will consume our application request
    ratio on the Twitter API. With Spring, we can easily cache the search and return
    the same result each time the search is called with the same parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we need to do is activate Spring caching with the `@EnableCache`
    annotation. We also need to create a `CacheManager` that will resolve our caches.
    Let''s create a `CacheConfiguration` class in the `config` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we use the simplest possible cache abstraction. Other
    implementations are also available, such as `EhCacheCacheManager` or `GuavaCacheManager`,
    which we will use in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have configured our cache, we can use the `@Cacheable` annotation
    on our methods. When we do that, Spring will automatically cache the result of
    the method and associate it with the current parameters for retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: Spring needs to create a proxy around beans whose methods are cached. This typically
    means that calling a cached method inside of the same bean will not fail to use
    Spring's cache.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, in the `SearchService` class, the part where we call the search
    operations, would benefit greatly from caching.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a preliminary step, it would be good to put the code responsible for creating
    the `SearchParameters` class in a dedicated object called `SearchParamsBuilder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will help us to create search parameters in our service.
  prefs: []
  type: TYPE_NORMAL
- en: Now we want to create a cache for our search results. We want each call to the
    Twitter API to be cached. Spring cache annotations rely on proxies to instrument
    the `@Cacheable` methods. We therefore need a new class with a method annotated
    with the `@Cacheable` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: When you use the Spring abstraction API, you don't know about the underlying
    implementation of the cache. Many will require both the return type and the parameter
    types of the cached method to be Serializable.
  prefs: []
  type: TYPE_NORMAL
- en: '`SearchParameters` is not Serializable, that''s why we will pass both the search
    type and the keyword (both strings) in the cached method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we want to put the `LightTweets` object in cache, we want to make them
    `Serializable`; this will ensure that they can always be written and read from
    any cache abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a `SearchCache` class and put it in the `search.cache` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It can't really get simpler than that. We used the `@Cacheable` annotation to
    specify the name of the cache that will be used. Different caches may have different
    policies.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we manually created a new `TwitterTemplate` method rather than injecting
    it like before. That's because we will have to access the cache from other threads
    a little bit later. In Spring Boot's `TwitterAutoConfiguration` class, the `Twitter`
    bean is bound to the request scope and is therefore not available outside of a
    Servlet thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'With those two new objects, the code of our `SearchService` class simply becomes
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that we annotated the service with `@Profile("!async")`. This means that
    we only create this bean if the profile `async` is not activated.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we will create another implementation of the `TwitterSearch` class to
    be able to switch between the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Neat! Say we restart our application and try a big request such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8080/search/mixed;keywords=docker,spring,spring%20boot,spring%20mvc,groovy,grails`'
  prefs: []
  type: TYPE_NORMAL
- en: 'It will take a little time at first, but then our console will display the
    following log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After that, if we hit refresh, the result will be displayed immediately and
    no cache miss will be seen in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it for our cache, but there is much more to the cache API. You can
    annotate methods with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@CachEvict`: This will remove an entry from the cache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@CachePut`: This will put the result of a method into a cache without interfering
    with the method itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Caching`: This regroups the caching annotation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@CacheConfig`: This points to different caching configurations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Cacheable` annotation can also be configured to cache results on certain
    conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on Spring cache, please see the following documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.spring.io/spring/docs/current/spring-framework-reference/html/cache.html](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/cache.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Cache invalidation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Currently, search results will be cached forever. Using the default simple
    cache manager doesn''t give us a lot of options. There is one more thing that
    we can do to improve our application caching. Since we have Guava in our classpath,
    we can replace the existing cache manager in the cache configuration with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will build a cache expiring after 10 minutes and using soft values, meaning
    that the entries will be cleaned up if the JVM runs low on memory.
  prefs: []
  type: TYPE_NORMAL
- en: Try to fiddle around with Guava's cache builder. You can specify a smaller time
    unit for your testing, and even specify different cache policies.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See the documentation at [https://code.google.com/p/guava-libraries/wiki/CachesExplained](https://code.google.com/p/guava-libraries/wiki/CachesExplained).
  prefs: []
  type: TYPE_NORMAL
- en: Distributed cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already have a Redis profile. If Redis is available, we could also use it
    as our cache provider. It would allow us to distribute the cache across multiple
    servers. Let''s change the `RedisConfig` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With this configuration, if we run our application with the "Redis" profile,
    the Redis cache manager will be used instead of the one defined in the `CacheConfig`
    class since it is annotated with `@Primary`.
  prefs: []
  type: TYPE_NORMAL
- en: This will allow the cache to be distributed in case we want to scale on more
    than one server. The Redis template is used to serialize the cache return values
    and parameters, and will require objects to be `Serializable`.
  prefs: []
  type: TYPE_NORMAL
- en: Async methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is still a bottleneck in our application; when a user searches ten keywords,
    each search will be executed sequentially. We could easily improve the speed of
    our application by using different threads and launching all the searches at the
    same time.
  prefs: []
  type: TYPE_NORMAL
- en: To enable Spring's asynchronous capabilities, one must use the `@EnableAsync`
    annotation. This will transparently execute any method annotated with `@Async`
    using a `java.util.concurrent.Executor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to customize the default executor used by implementing the `AsyncConfigurer`
    interface. Let''s create a new configuration class called `AsyncConfig` in the
    `config` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: With this configuration, we ensure that no more than 10 threads will be allocated
    to handle our asynchronous tasks in the whole application. This is very important
    in a web application where each client has a dedicated thread. The more threads
    you use and the longer they block, the fewer client requests you can process.
  prefs: []
  type: TYPE_NORMAL
- en: Let's annotate our search method and make it asynchronous. We will need to make
    it return a subtype of `Future`, a java concurrent class that represents an asynchronous
    result.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a new implementation of the `TwitterSearch` class that will query
    the search API in different threads. The implementation is a bit tricky so I'll
    break it down into small parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to annotate the method that will query the API with the `@Async`
    annotation to tell Spring to schedule the task using our executor. Again, Spring
    will use proxy to do its magic so this method has to be in a different class to
    the service calling it. It would also be nice if this component could use our
    cache. That would lead us to create this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Don't create this class yet. Let's see what our service needs first.
  prefs: []
  type: TYPE_NORMAL
- en: The `ListenableFuture` abstraction allows us to add callbacks after the completion
    of the future, either in the case of correct results or if an exception occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm to wait for a bunch of asynchronous tasks would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you don't know the `CountDownLatch` method, it is just a simple blocking
    counter.
  prefs: []
  type: TYPE_NORMAL
- en: The `await()` method will wait until the latch reaches 0 to unlock the thread.
  prefs: []
  type: TYPE_NORMAL
- en: The `asyncFetch` method, shown in the preceding code, will attach a callback
    to each of our `asynFetch` methods. The callback will add the results to the `allTweets`
    list and decrement the latch. Once each callback has been called, the method will
    return all the tweets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Got it? Here is the final code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, to use this implementation, we need to run the application with the `async`
    profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run it with multiple profiles active at the same time by separating
    them with commas, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--spring.profiles.active=redis,async`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we launch a search on multiple terms, we can see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This shows that the different searches are done in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java 8 actually introduced a new type called `CompletableFuture`, which is
    a much better API to manipulate futures. The main problem with completable futures
    is that no executor can work with them without a bit of code. This is outside
    of the scope of the article, but you can check my blog for an article on the subject:
    [http://geowarin.github.io/spring/2015/06/12/completable-futures-with-spring-async.html](http://geowarin.github.io/spring/2015/06/12/completable-futures-with-spring-async.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Disclaimer**'
  prefs: []
  type: TYPE_NORMAL
- en: The following sections contains a lot of JavaScript. Obviously, I think you
    should have a look at the code, especially if JavaScript is not your favorite
    language. It is time to learn it. That being said, even if WebSocket is insanely
    cool, it is not a requirement. You can safely skip ahead to the last chapter and
    deploy your application right now.
  prefs: []
  type: TYPE_NORMAL
- en: ETags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Twitter results are neatly cached, so a user refreshing the result page
    will not trigger an additional search on the Twitter API. However, the response
    will be sent to this user multiple times even if the results do not change, which
    will waste bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: An ETag is a hash of the data of a web response and is sent as a header. The
    client can memorize the ETag of a resource and send the last known version to
    the server with the `If-None-Match` header. This allows the server to answer `304
    Not Modified` if the request does not change in the meantime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring has a special Servlet filter, called `ShallowEtagHeaderFilter`, to handle
    ETags. Simply add it as a bean in the `MasterSpringMvc4Application` configuration
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This will automatically generate ETags for your responses as long as the response
    has no cache control headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if we interrogate our RESTful API, we can see that an ETag is sent along
    with the server response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we request the same resource one more time, specifying the last ETag
    that we know of in the `If-None-Match` headers, the server will automatically
    respond with a `304 Not Modified` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to the parallel nature of our search, the tweets fetched for different keywords
    might arrive in different orders, which will make the ETag change. If you want
    this technique to work for multiple searches, please consider ordering your search
    results before sending them to the client.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to take advantage of that, we obviously need to rewrite our client
    code to handle them. We will see a simple solution to do that with jQuery, using
    the local storage of the browser to save the latest query of the user.
  prefs: []
  type: TYPE_NORMAL
- en: First, remove the `tweets` variable from our model; we won't do the search from
    the server anymore. You will have to modify a test or two to reflect this change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before going further, let''s add lodash to our JavaScript libraries. If you
    don''t know lodash, let''s say it is the Apache Utils of JavaScript. You can add
    it to your project dependencies like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Add it to the `default.html` layout, just under the materialize''s JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We will modify the `resultPage.html` file and leave the part where the tweets
    should appear empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will add a script element at the bottom of the page, just before closing
    the body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding script will just be in charge of constructing the URL for our
    request. We will use it by issuing a simple jQuery AJAX call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the `beforeSend` callback to have a chance to modify the request
    headers just before the call is made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can easily read and write from local storage. The gotcha
    here is that local storage only works with strings so we have to parse and serialize
    the query object to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can handle the response by retrieving the content from local storage if
    the HTTP status is `304 Not Modified`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `addTweet` function that you will see next, I''m using lodash, a very
    useful JavaScript utility library, to generate templates. The function to add
    tweets to the page can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: That was a lot of JavaScript! It would make more sense to generalize this pattern
    in a Single Page Application using a library such as Backbone.js. Hopefully, though,
    this will serve as a simple example of how to implement ETags in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to refresh the search page multiple times, you will see that the
    contents do not change and will be displayed immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ETags](img/2117_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are other uses for ETags, such as optimistic locking for transactions
    (it lets you know on which version of an object the client is supposed to be working
    on at any time). It is also extra work on the server side to hash the data before
    sending it across, but it will save bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another kind of optimization we can think about is sending the data to the client
    as it becomes available to the server. Since we fetch results of the search in
    multiple threads, the data will come in multiple chunks. We could send them bit
    by bit instead of waiting for all the results.
  prefs: []
  type: TYPE_NORMAL
- en: Spring has excellent support for WebSockets, which is a protocol that allows
    clients to maintain a long-running connection to the server. Data can be pushed
    in web sockets on both ends of the connection and consumers will get the data
    in real-time.
  prefs: []
  type: TYPE_NORMAL
- en: We will use a JavaScript library called SockJS to ensure compatibility with
    all browsers. Sockjs will transparently fall back on another strategy if our users
    have an outdated browser.
  prefs: []
  type: TYPE_NORMAL
- en: We will also use StompJS to connect to our message broker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following library to your build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the WebJars to our default Thymeleaf template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To configure WebSockets in our application, we need to add a bit of configuration
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will configure the different channels available in our application. SockJS
    clients will connect to the `twitterSearch` endpoint and will push data to the
    server on `/ws/ channel` and be able to listen to `/topic/` for changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will allow us to inject a `SimpMessagingTemplate` in a new controller
    to push data to the client in the `/topic/searchResult` channel, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `resultPage`, the JavaScript code is really simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `displayTweets` function remains essentially the same as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here you go! The client will now receive the results of all the searches in
    the application-- live!
  prefs: []
  type: TYPE_NORMAL
- en: 'Before pushing this to production, it will require a little bit more work.
    Here are some ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: Create subchannels for clients to privately listen to changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Close the channel when a client is done using it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add CSS transitions to the new tweets so the user can feel that it's real-time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a real broker, such as RabbitMQ, to allow the backend to scale with connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is much more to WebSocket than just this simple example. Don't forget
    to have a look at the documentation at [http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: The check point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we created two new configurations: `AsyncConfiguration`, which
    will allow us to use the `@Async` annotation to submit tasks to an executor, and
    `CacheConfiguration`, which will create a `CacheManager` interface and allow us
    to use the `@Cacheable` annotation. Since we can use Redis as a cache manager,
    we also amended the `RedisConfig` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We created a `SearchCache` class, which contained a cache of tweets, and we
    now have two `TwitterSearch` implementations to choose from: good old `SearchService`,
    which will fetch each result synchronously, and `ParallelSearchService`, which
    will issue each query in a different thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The check point](img/2117_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen two different philosophies relating to performance
    improvement. At the beginning, we tried to reduce the bandwidth used by our clients
    by caching data and using as few connections to our server as possible.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part, though, we began to do something more advanced by allowing
    searches to be run in parallel and each client to remain in sync with a persistent
    connection to the server through web sockets. This will allow clients to receive
    updates in real time, and our application will feel more reactive but consume
    more threads.
  prefs: []
  type: TYPE_NORMAL
- en: I strongly encourage you to polish the result before we move on to the next
    chapter and deploy our application for good!
  prefs: []
  type: TYPE_NORMAL
