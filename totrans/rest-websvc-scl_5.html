<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;5.&#xA0;Defining a REST Service Using Akka HTTP DSL"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. Defining a REST Service Using Akka HTTP DSL</h1></div></div></div><p class="calibre7">In this chapter, we'll look at the successor to one of the most popular REST frameworks available in the Scala space, called <a id="id228" class="calibre1"/>
<span class="strong"><strong class="calibre8">Spray</strong></span>. Spray has been around for a couple of years, and provides a very extensive <a id="id229" class="calibre1"/>
<span class="strong"><strong class="calibre8">domain-specific language</strong></span> (<span class="strong"><strong class="calibre8">DSL</strong></span>), which you can use to define your REST services. Spray itself isn't being actively developed and has merged into the Akka HTTP initiative provided by Typesafe. The DSL structure and way you create REST services, however, hasn't changed that much. So in this chapter, we'll explore the following features provided by Akka HTTP's DSL:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The first DSL-based service</li><li class="listitem">Verb and path handling through directives</li><li class="listitem">Exception handling</li><li class="listitem">Validations and JSON support</li></ul></div><p class="calibre7">In the next section, we'll first look a bit deeper at what this DSL entails and the history of the Akka HTTP project.</p></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Defining a REST Service Using Akka HTTP DSL">
<div class="book" title="What is Akka HTTP?"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec34" class="calibre1"/>What is Akka HTTP?</h1></div></div></div><p class="calibre7">Akka HTTP <a id="id230" class="calibre1"/>is part of the Akka set of libraries and framework. Akka itself is a very well-known actor framework, which is used to create highly scalable, distributed, and resilient applications. Akka HTTP is built on top of the Akka framework, and the 1.0 version was released in the summer of 2015. You can work with Akka HTTP in two different manners. You can use the low-level API and directly work with reactive flows to process the raw HTTP information, or you can use the high-level API and use an advanced DSL to process your requests. In this chapter, we'll use the latter approach.</p><p class="calibre7">You might think that Akka HTTP isn't a very mature framework since the 1.0 version was only recently released. This isn't the case. The Akka HTTP DSL is based on the well-known Spray <a id="id231" class="calibre1"/>framework, which has been around for a couple of years. Development of Spray has stopped, and has continued in the Akka HTTP DSL project. So, for those of you who have experience with Spray, the DSL will look pretty much the same, and you'll recognize all the standard constructs from Spray.</p></div></div>
<div class="book" title="Creating a simple DSL-based service"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec35" class="calibre1"/>Creating a simple DSL-based service</h1></div></div></div><p class="calibre7">For each<a id="id232" class="calibre1"/> framework in this book, we create a simple getting started service. So for Akka HTTP, we did the same thing. Before we look at the code, let's begin by starting the service and firing a request using Postman. To start the service, from the command line, run the <code class="email">sbt runCH05-HelloAkka-DSL</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">$ sbt runCH05-HelloAkka-DSL</strong></span>
<span class="strong"><strong class="calibre8">[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project</strong></span>
<span class="strong"><strong class="calibre8">[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)</strong></span>
<span class="strong"><strong class="calibre8">[info] Running org.restwithscala.chapter5.gettingstarted.HelloDSL </strong></span>
<span class="strong"><strong class="calibre8">Press &lt;enter&gt; to exit.</strong></span>
</pre></div><p class="calibre7">Open up Postman, and from the <span class="strong"><strong class="calibre8">Chapter 05</strong></span> collection, run the <code class="email">Hello Akka-DSL</code> command. The server will respond with a simple message:</p><div class="mediaobject"><img src="../images/00036.jpeg" alt="Creating a simple DSL-based service" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">To create this example, we of course need to import the external dependencies. For this sample, the following <code class="email">sbt</code> dependencies are used:</p><div class="informalexample"><pre class="programlisting">  lazy val akkaHttpVersion = "1.0"

  val backendDeps = Seq (
    "com.typesafe.akka" %% "akka-stream-experimental" % akkaHttpVersion,
    "com.typesafe.akka" %% "akka-http-core-experimental" % akkaHttpVersion,
    "com.typesafe.akka" %% "akka-http-experimental" % akkaHttpVersion,
    "com.typesafe.akka" %% "akka-http-spray-json-experimental" % akkaHttpVersion
  )</pre></div><p class="calibre7">Note that the <a id="id233" class="calibre1"/>dependencies still have the experimental tag in their name. This means that the implementation might change and, at this point, there isn't any official support from Typesafe yet. So there might be some changes in the future, which aren't binary-compatible. Typesafe itself defines it as:</p><div class="blockquote"><blockquote class="blockquote1"><p class="calibre24"><span class="strong"><em class="calibre9">"This module of Akka is marked as experimental, which means that it is in early access mode, which also means that it is not covered by commercial support. An experimental module doesn't have to obey the rule of staying binary compatible between minor releases. Breaking API changes may be introduced in minor releases without notice as we refine and simplify based on your feedback. An experimental module may be dropped in major releases without prior deprecation."</em></span></p></blockquote></div><p class="calibre7">So at this point, it might be wise to not yet convert all your existing Spray code to this codebase, but wait until they move out of the experimental phase.</p><p class="calibre7">With these dependencies in place, we can create our simple service:</p><div class="informalexample"><pre class="programlisting">import akka.actor.ActorSystem
import akka.stream.ActorMaterializer
import akka.http.scaladsl.Http
import akka.http.scaladsl.server.Directives._

object HelloDSL extends App {
  // used to run the actors
  implicit val system = ActorSystem("my-system")
  // materializes underlying flow definition into a set of actors
  implicit val materializer = ActorMaterializer()

  val route =
    path("hello") {
      get {
        complete {
          "hello Akka-HTTP DSL"
        }
      }
    }

  // start the server
  val bindingFuture = Http().bindAndHandle(route, "localhost", 8080)

  // wait for the user to stop the server
  println("Press &lt;enter&gt; to exit.")
  Console.in.read.toChar

  // gracefully shut down the server
  import system.dispatcher
  bindingFuture
    .flatMap(_.unbind())
    .onComplete(_ =&gt; system.shutdown())
}</pre></div><p class="calibre7">The first <a id="id234" class="calibre1"/>thing we do in this service is define two implicit values. The implicit <code class="email">ActorSystem</code> is needed to define the actor system that will be used to run the various processing steps of a request asynchronously. Akka HTTP will convert the DSL we create into a flow definition (which is a construct of Akka Streams). This flow can be seen as a blueprint of the steps that a request takes from the beginning to the end. The implicit <code class="email">ActorMaterializer</code> will convert this flow into a set of Akka actors so that multiple requests can be executed concurrently without interfering with each other, which runs on the implicitly defined <code class="email">ActorSystem</code>.</p><p class="calibre7">With the implicits defined, we can define the route:</p><div class="informalexample"><pre class="programlisting">  val route =
    path("hello") {
      get {
        complete {
          "hello Akka-HTTP DSL"
        }
      }
    }</pre></div><p class="calibre7">Each request is passed through this route and, when one matches, its inner route is executed. So in this case, the following steps are executed:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, the provided URL path is checked. In this case, if the path matches <code class="email">hello</code>, the inner route of the path function (this is called a<a id="id235" class="calibre1"/> <span class="strong"><strong class="calibre8">directive</strong></span>) is executed.</li><li class="listitem" value="2">The next check Akka HTTP makes is to see whether the verb matches. In this example, we check for a <code class="email">GET</code> verb.</li><li class="listitem" value="3">The <a id="id236" class="calibre1"/>final inner route completes the request by calling complete. When complete is called, the result of the provided block is returned as response. In this example, we just return a string.</li></ol><div class="calibre13"/></div><p class="calibre7">The last piece of code in this hello world example shuts down the server when a key is pressed. Shutting down the server is done through the following code:</p><div class="informalexample"><pre class="programlisting">  import system.dispatcher
  bindingFuture
    .flatMap(_.unbind())
    .onComplete(_ =&gt; system.shutdown())</pre></div><p class="calibre7">This might seem a complex way to shut down the server, but when you look at the types, it is actually really simple. We call <code class="email">flatMap</code> on the <code class="email">bindingFuture</code> instance (of the type <code class="email">Future[ServerBinding]</code>), so when the <code class="email">Future</code> is ready (the server is started successfully), we call unbind on the <code class="email">ServerBinding</code> instance. This, in itself, also returns a <code class="email">Future</code>, which is flattened since we called <code class="email">flatMap</code>. When this last <code class="email">Future</code> resolves, we close the Akka system to cleanly shut down everything.</p><p class="calibre7">We will use the same way to start and stop the service in other examples.</p></div>
<div class="book" title="Working with paths and directives"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec36" class="calibre1"/>Working with paths and directives</h1></div></div></div><p class="calibre7">The first example we'll look at <a id="id237" class="calibre1"/>is the first simple implementation of our API. We won't be returning real objects or JSON yet, but a couple of strings. The code for this step looks like this:</p><div class="informalexample"><pre class="programlisting">  val route =
    // handle the /tasks part of the request
    path("tasks") {
      get {
        complete { "Return all the tasks" }
      } ~
      post {
        complete { s"Create a new task" }
      } // any other request is also rejected.
    } ~ { // we handle the "/tasks/id separately"
      path("tasks" / IntNumber) {
        task =&gt; {
          entity(as[String]) { body =&gt; {
            put { complete { 
        s"Update an existing task with id: $task and body: $body" } }
          } ~
            get { complete { 
        s"Get an existing task with id : $task and body: $body" } }
          } ~ {
            // We can manually add this rejection.
            reject(MethodRejection(HttpMethods.GET),
                   MethodRejection(HttpMethods.PUT))
          }
        }
      }
    }</pre></div><p class="calibre7">This <a id="id238" class="calibre1"/>code doesn't look that different from the previous example we saw. We define a route by using directives such as <code class="email">path</code>, <code class="email">get</code>, <code class="email">post</code>, and <code class="email">put</code> and return values by using the <code class="email">complete</code> function. We do, however, use a couple of new concepts. Before we explain the code and the concepts provided by Akka HTTP, first let's fire some requests. For this, start up the example for this section:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">$ sbt runCH05-runCH05Step1</strong></span>
<span class="strong"><strong class="calibre8">[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project</strong></span>
<span class="strong"><strong class="calibre8">[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)</strong></span>
<span class="strong"><strong class="calibre8">[info] Compiling 3 Scala sources to /Users/jos/dev/git/rest-with-scala/chapter-05/target/scala-2.11/classes...</strong></span>
<span class="strong"><strong class="calibre8">[info] Running org.restwithscala.chapter5.steps.AkkaHttpDSLStep1 </strong></span>
<span class="strong"><strong class="calibre8">Press &lt;enter&gt; to exit.</strong></span>
</pre></div><p class="calibre7">Open up Postman in your browser and firstly execute the <span class="strong"><strong class="calibre8">Step 01 - Update task with id</strong></span> request:</p><div class="mediaobject"><img src="../images/00037.jpeg" alt="Working with paths and directives" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">As you can see, we return a simple response, which shows what data was sent to the server. Another <a id="id239" class="calibre1"/>interesting example is where we send an invalid request—<span class="strong"><strong class="calibre8">Step 01 - Invalid request</strong></span>:</p><div class="mediaobject"><img src="../images/00038.jpeg" alt="Working with paths and directives" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Here, you can see that we can easily provide the user with additional information on how to use our service.</p><p class="calibre7">Let's look a bit closer at the second part of the code we saw at the beginning of this section:</p><div class="informalexample"><pre class="programlisting">path("tasks" / IntNumber) {
        task =&gt; {
          entity(as[String]) { body =&gt; {
            put { complete { 
        s"Update an existing task with id: $task and body: $body" } }
          } ~
            get { complete { 
        s"Get an existing task with id : $task and body: $body" } }
          } 
        }
      }
    }</pre></div><p class="calibre7">Here, we once again see the familiar <code class="email">path</code>, <code class="email">get</code>, and <code class="email">put</code> directives, and we also use additional directives to get extra information from the request. We use the <code class="email">IntNumber</code> path matcher to convert part of the path to an integer and use the <code class="email">entity(as[String])</code> extractor to <a id="id240" class="calibre1"/>extract the body of the request as a string (we'll see more of this directive at the end of this chapter when we use the same approach to handle JSON input). Let's start though by looking a bit closer at the <code class="email">path</code> directive.</p><p class="calibre7">In this example, we already used three different path matchers. We used a string value to match a part of the URL, the <code class="email">/</code> matcher to indicate that we expected a forward slash, and the <code class="email">IntNumber</code> path matcher to match and extract a number. Besides these, you can also use the matchers explained in the following table:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Path matchers</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">"/hello"</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This <a id="id241" class="indexterm"/>matcher matches part of the URL and also consumes it. Nothing is extracted here.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">"[a-b]"r</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">You can also specify a regular expression with a maximum of one capture group with this matcher. The capture group is extracted.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">Map[String, T]</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">Using this matcher, you can extract a value, based on the path that matches <code class="literal">Map("path1" -&gt; 1, "path2" -&gt; 2, "path3" -&gt; 3)</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">Slash (or /)</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matcher matches a single forward slash.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">Segment</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matches if the path starts with a path segment (not a forward slash). The current path segment is extracted as a string.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">PathEnd</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matches the end of the path and extracts nothing.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">Rest</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matches the rest of the path and returns it as a string.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">RestPath</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matches the rest of the path and returns it as a path.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">IntNumber</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matches a number of digits that can be converted to an integer. The matched integer is extracted.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">LongNumber</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matches a number of digits that can be converted to a long number and extracts the matched long number.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">HexIntNumber</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matches a number of hex-digits that can be converted to an integer and extracts the matched integer.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">HexLongNumber</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matches a number of hex-digits that can be converted to a long number and extracts the matched long number.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">DoubleNumber</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matches a number of digits that can be converted to a double number and extracts the matched double number.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">JavaUUID</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matches and extracts the string representation of a <code class="literal">java.util.JavaUUID</code> object. The result is a <code class="literal">.java.util.JavaUUID</code> instance.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">Neutral</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matches everything and doesn't consume anything.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">Segments</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This is the same as the <code class="literal">Segment</code> matcher but, this time, matches all the remaining segments and returns these as a <code class="literal">List[String]</code> object.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">separateOnSlashes</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This creates a matcher that interprets slashes as path segment separators.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">provide</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matcher always matches and extracts the provided tuple value.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">~</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This operator allows you to concatenate two matchers, for example <code class="literal">"hello" ~ "world"</code> is the same as <code class="literal">"helloworld"</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">|</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This combines two matchers together. The right-hand side one will only be evaluated when the left-hand side one fails to match.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21">Postfix: <code class="literal">?</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">The <code class="literal">?</code> postfix makes the matcher optional, and it will always match. The result of the extracted value will be an <code class="literal">Option[T]</code> object.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21">Prefix: <code class="literal">!</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This prefix inverses the matcher.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21">Postfix: <code class="literal">.repeat</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">With <a id="id242" class="indexterm"/>
<code class="literal">repeat</code>, you can make a matcher that repeats itself the specified amount of time.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">transform, flatMap, map</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This allows you to customize the matcher and create your own custom logic.</p>
</td></tr></tbody></table></div><p class="calibre7">So even in the <code class="email">path</code> directive, you can already extract a lot of information and apply multiple matchers. Besides <a id="id243" class="calibre1"/>the <code class="email">path</code> directive, there are a lot of other directives. We've already seen the entity extracted in this example used like this:</p><div class="informalexample"><pre class="programlisting">entity(as[String]) { body =&gt; {
            put { complete { 
        s"Update an existing task with id: $task and body: $body" } }
     }</pre></div><p class="calibre7">When you use an extractor, the extracted value is passed as an argument to the inner route (<code class="email">body</code> in this code fragment). Akka HTTP comes with a large number of extractors you can use to get values out of the request. The following table shows the most useful ones:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Directive</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">cookie("name")</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This extracts a cookie with the specified name and returns an <code class="literal">HttpCookiePair</code> instance. There is also an <code class="literal">Option</code> variant—<code class="literal">optionalCookie</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">entity(as[T])</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This unmarshals the request entity to the specified type (for more information, see the section on JSON).</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">extractClientIp</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This extracts the client's IP from either the X-Forwarded- or Remote-Addressor X-Real-IP header as a <code class="literal">RemoteAddress</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">extractCredentials</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This gets an <code class="literal">Option[HttpCredentials]</code> from the authorization header.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">extractExecutionContext</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This provides access to the Akka <code class="literal">ExecutionContext</code> instance.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">extractMaterializer</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This provides access to the Akka <code class="literal">Materializer</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">extractHost</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This gets the <code class="literal">hostname</code> part of the host request header value as a string.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">extractMethod</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This extracts the request method as an <code class="literal">HttpMethod</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">extractRequest</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This provides access to the current <code class="literal">HttpRequest</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">extractScheme</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns the URI scheme (<code class="literal">http</code>, <code class="literal">https</code>, and others) from the request as a string.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">extractUnmatchedPath</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This extracts the part of the path that is unmatched at this point as a <code class="literal">Uri.Path</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">extractUri</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This accesses the full URI of the request as a <code class="literal">Uri</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">formFields</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This extracts fields from a POST made in an HTML form. For more information, see the section on path matchers.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">headerValueByName</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This extracts the value of the first HTTP request header with a given name and returns it as a string. You can also get an <code class="literal">Option[String]</code> by using <code class="literal">OptionalHeaderValueByName</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">headerValueByType [T]</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">You can also extract a header and automatically convert it to a specific type with this directive. For this one, there is also an <code class="literal">Option</code> variant—<code class="literal">OptionalHeaderValueByType</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">parameterMap</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This gets all the parameters from the request as a <code class="literal">Map[String, String]</code>. If multiple parameters with the same name exist, only the last one will be returned.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">parameterMultiMap</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This gets all the parameters from the request as a <code class="literal">Map[String, List[String]]</code>. If multiple parameters with the same name exist, all will be returned.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">parameterSeq</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This extracts all the parameters in order as a <code class="literal">Seq[(String, String)]</code> of tuples.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">provide("value")</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This injects the provided value into the inner route. There is also a <code class="literal">tprovide</code> function, which injects a tuple.</p>
</td></tr></tbody></table></div><p class="calibre7">Most of these extractors are pretty much self-explanatory. For instance, when you want to extract a specific HTTP header, you can write a route like this:</p><div class="informalexample"><pre class="programlisting">val exampleHeaderRoute = path("example") {
  (headerValueByName("my-custom-header")) { header =&gt; {
      complete(s"Extracted header value: $header")
    }
  }
}</pre></div><p class="calibre7">Now, let's get back to our example and look again at a very simple part of our route:</p><div class="informalexample"><pre class="programlisting">      get {
        complete { "Return all the tasks" }
      }</pre></div><p class="calibre7">So far, we've only <a id="id244" class="calibre1"/>seen a small number of Akka directives. We looked at the possible extractors in the previous table, and the simple directives to match parts of the path and the specific-HTTP verbs. Besides these, Akka HTTP provides a very large number of directives, much more than we can explain in this single chapter. In the following table, we'll list the directives we feel are the most important and flexible for you to use in the routes:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Directive</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">conditional</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This provides support for conditional requests as specified in <a class="indexterm" href="http://tools.ietf.org/html/draft-ietf-httpbis-p4-conditional-26">http://tools.ietf.org/html/draft-ietf-httpbis-p4-conditional-26</a>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">decodeRequest / encodeRequest</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This compresses and decompresses a request that is sent using gzip or deflate compression.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">decodeRequestWith / encodeRequestWith</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This compresses and decompresses a request with the specified encoder and decoder.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">get / delete / post / put / head / options / patch </code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">The inner route of this directive will be executed when the specified HTTP verb matches.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">host</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This only runs the inner route if the host specified in this directive matches. You can use strings or a regex.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">method(httpMethod)</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This checks whether the request matches the specified <code class="literal">HttpMethod</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">onComplete(future)</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This runs the inner route when the provided <code class="literal">Future</code> completes.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">onSuccess</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This runs the inner route when the provided <code class="literal">Future</code> completes successfully.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">overrideMethodWithParameter</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This changes the method (HTTP verb) of the incoming request to the provided <code class="literal">HttpMethod</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">pass</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This always passes the request to the inner route.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">path</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">If the provided path matches, this passes the request to the inner route (you will get to know more about it in the next example).</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">pathEnd</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This only passes the request on if its complete path is matched.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">pathEndOrSingleSlash</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This only passes the request on if it's complete path is matched or only a single slash remains.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">pathPrefix</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matches first part of a path. A leading slash is automatically added. If you just want to test and not consume the path, use <code class="literal">pathPrefixTest</code>. If you don't want a leading slash, you can use <code class="literal">rawPrefix</code> and <code class="literal">rawPrefixTest</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">pathSingleSlash</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This only runs the inner route if the path contains a single slash.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">pathSuffix</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This checks the end of the current path and, if it matches, runs the inner route. If you just want to test and not consume the path, use the <code class="literal">pathSuffixTest</code> directive.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">requestEncodedWith</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This checks whether the request encoding matches the specified <code class="literal">HttpEncoding</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">requestEntityEmpty</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matches if the request doesn't contain a body.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">requestEntityPresent</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matches if the request contains a body.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">scheme("http")</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This checks the scheme of the request. If the scheme matches, the request is passed on to the inner route.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">validate</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This allows you to test against an arbitrary condition.</p>
</td></tr></tbody></table></div><p class="calibre7">Before we <a id="id245" class="calibre1"/>move on to the next example, we'll quickly look at one last inner route that we saw at the beginning of this section:</p><div class="informalexample"><pre class="programlisting">{
// We can manually add this rejection.
reject(MethodRejection(HttpMethods.GET),
   MethodRejection(HttpMethods.PUT))
}</pre></div><p class="calibre7">With this inner route, we inform Akka HTTP that the inner route rejects the request. In this case, we reject the request because the <code class="email">HttpMethod</code> (the verb) didn't match anything we can process. When you reject a request, Akka HTTP will check whether there are any routes that might match and, if not, will convert the rejection in to an HTTP error message. Further, in this chapter, we'll look a bit closer at how Akka HTTP works with rejections and handles exceptions.</p></div>
<div class="book" title="Processing request parameters and customizing the response"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec37" class="calibre1"/>Processing request parameters and customizing the response</h1></div></div></div><p class="calibre7">In this <a id="id246" class="calibre1"/>section, we'll dive a bit deeper into how we can extract query parameters <a id="id247" class="calibre1"/>from requests and how to customize the response you send back to the client. In this section, we'll look a bit closer at how to implement the following requests:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">Create a task</strong></span>: We'll use a set of query parameters to create a new task</li><li class="listitem"><span class="strong"><strong class="calibre8">Get all tasks</strong></span>: We will return all the tasks that have been created</li><li class="listitem"><span class="strong"><strong class="calibre8">Get a task</strong></span>: We will return a specific task based on the provided ID</li></ul></div><p class="calibre7">For each of these requests, we'll first show the call from Postman and then how it is implemented with Akka HTTP. First, start up the correct server with the <code class="email">sbt runCH05-runCH05Step2</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">$ sbt runCH05-runCH05Step2</strong></span>
<span class="strong"><strong class="calibre8">[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project</strong></span>
<span class="strong"><strong class="calibre8">[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)</strong></span>
<span class="strong"><strong class="calibre8">[info] Compiling 1 Scala source to /Users/jos/dev/git/rest-with-scala/chapter-05/target/scala-2.11/classes...</strong></span>
<span class="strong"><strong class="calibre8">[info] Running org.restwithscala.chapter5.steps.AkkaHttpDSLStep2 </strong></span>
<span class="strong"><strong class="calibre8">Press &lt;enter&gt; to exit.</strong></span>
</pre></div><p class="calibre7">Now open Postman and execute the <span class="strong"><strong class="calibre8">Step 02 - Create Task</strong></span> request:</p><div class="mediaobject"><img src="../images/00039.jpeg" alt="Processing request parameters and customizing the response" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">In the response, you <a id="id248" class="calibre1"/>can see that we return a string representation <a id="id249" class="calibre1"/>of the task that was added, and that the content of the task is based on the query parameters in the URL. To accomplish this, we implement the following route:</p><div class="informalexample"><pre class="programlisting">        ((post) &amp; 
        (parameters("title", "person".?, "status" ? "new"))) { 
                                 (title, assignedTo, status) =&gt; {
          (entity(as[String])) { body =&gt; {
            complete {
              val createdTask = TaskService.insert(
                 Task(-1, 
                      title,
                      body,
                      assignedTo.map(Person(_)),
                      List.empty, Status(status)))
              createdTask.map(_.toString)
            }
           }
          }
        }
      }</pre></div><p class="calibre7">In this route, we first combine two directives, the <code class="email">post</code> directive and the <code class="email">parameters</code> directive by using the <code class="email">&amp;</code> symbol. This means that both directives should match before the inner route is executed. There is also a <code class="email">|</code> symbol you can use, which means either the left or the right directive should match (<code class="email">put</code> <code class="email">|</code> <code class="email">post</code>). The parameters, together with the body, are used to create a <code class="email">Task</code> instance using the <code class="email">TaskService</code> object. The resulting <code class="email">Future[Task]</code> is then converted to a <code class="email">Future[String]</code> and returned. We need to convert the <code class="email">Task</code> to a string here manually <a id="id250" class="calibre1"/>since we haven't told Akka HTTP how to deal with the <code class="email">Task</code> class (you will get to know more about it later). If <a id="id251" class="calibre1"/>you look at the parameters directive, you'll not only recognize the query parameters from the original request, but also see a number of modifiers. The following bullets explain how the parameters directive works:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">"title"</code>: This extracts the value of the parameter as a string. This marks this query parameter as required.</li><li class="listitem"><code class="email">"person".?</code>: By using the <code class="email">.?</code> postfix, you make a value optional. This result is an <code class="email">Option[String]</code>.</li><li class="listitem"><code class="email">"status" ? "new"</code>: This retrieves the parameter and, if it can't be found, uses the default value (<code class="email">"new"</code> in this case). The result is a string.</li><li class="listitem"><code class="email">"status" ! "new"</code>: This requires the query parameter with the name <code class="email">"status"</code> to be <code class="email">"new"</code>.</li><li class="listitem"><code class="email">"number".as[Int]</code>: This tries to convert the parameter to the specified type.</li><li class="listitem"><code class="email">"title.*"</code>: This extracts multiple instances of the title parameter to an <code class="email">Iterable[String]</code>.</li><li class="listitem"><code class="email">"number".as[Int].*</code>: This is same as the previous function, but works on types.</li></ul></div><p class="calibre7">So for our sample, we require a <code class="email">title</code> parameter, an optional <code class="email">person</code> parameter, and an optional <code class="email">status</code> parameter, which has a default value of <code class="email">"new"</code>. With these constructs, it is very easy to extract the correct values from a request's query parameters.</p><p class="calibre7">Now let's look a bit closer at the response we send back from this example. We use the complete directive which we've seen earlier, and just return a <code class="email">Future[String]</code> instance. Since it is a string, Akka HTTP knows how to marshal it to an HTTP response. We use the same approach for the get all tasks request. From Postman, after you've created a couple of tasks, make the <span class="strong"><strong class="calibre8">Step 02 - Get All</strong></span> request:</p><div class="mediaobject"><img src="../images/00040.jpeg" alt="Processing request parameters and customizing the response" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">You'll see that you get back the list of tasks you've created. Once again, it's very simple:</p><div class="informalexample"><pre class="programlisting">complete {
  // our TaskService returns a Future[List[String]]. We map // this to a single Future[String] instance that can be returned // automatically by Akka HTTP
  TaskService.all.map(_.foldLeft("")((z, b) =&gt; z + b.toString + "\n"))
}</pre></div><p class="calibre7">We make a call to <a id="id252" class="calibre1"/>the <code class="email">TaskService</code> object, which returns a <code class="email">Future[List[Task]]</code> instance. Since we haven't told Akka HTTP yet how to handle this type, we manually convert it to the correct type and use <code class="email">complete</code> to <a id="id253" class="calibre1"/>send back the response. So far, we've only seen the use of complete. In most cases, the default behavior provided by Akka HTTP is good enough, however, there are also different ways you can customize the response that is sent by Akka HTTP.</p><p class="calibre7">Open Postman again, use the <span class="strong"><strong class="calibre8">Step 02 - Create Task</strong></span> option to create a number of tasks and this time execute the <span class="strong"><strong class="calibre8">Step 02 – Get Task Invalid</strong></span> request to get a single request. This request will try to get the request with ID 100, which is invalid (unless you added 100 tasks). The result looks similar to this:</p><div class="mediaobject"><img src="../images/00041.jpeg" alt="Processing request parameters and customizing the response" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">As you can see, this <a id="id254" class="calibre1"/>time we get a <span class="strong"><strong class="calibre8">404</strong></span> message, with a custom error message. If <a id="id255" class="calibre1"/>you make a request for a task which is available (use the Step <span class="strong"><strong class="calibre8">02 – Get Task</strong></span> request), you'll see the following:</p><div class="mediaobject"><img src="../images/00042.jpeg" alt="Processing request parameters and customizing the response" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">For the rest, there isn't too much special in these two requests. However, if you look at the <span class="strong"><strong class="calibre8">Cookies</strong></span> and <span class="strong"><strong class="calibre8">Headers</strong></span> tabs, you might notice that we get additional results there. If you open these tabs, you'll notice a custom hello cookie with <code class="email">world</code> as the value, and in the <span class="strong"><strong class="calibre8">Headers</strong></span> tab, we added a custom header called <span class="strong"><strong class="calibre8">helloheader</strong></span>.</p><p class="calibre7">To accomplish this, we used a couple of standard Akka HTTP features. The following code fragment <a id="id256" class="calibre1"/>shows <a id="id257" class="calibre1"/>how this is done:</p><div class="informalexample"><pre class="programlisting">val sampleHeader: HttpHeader = 
          (HttpHeader.parse("helloheader","hellovalue") match {
    case ParsingResult.Ok(header, _) =&gt; Some(header)
    case ParsingResult.Error(_) =&gt; None
}).get
...

implicit val StringMarshaller: ToEntityMarshaller[Task] =
    Marshaller.opaque { s =&gt;
           HttpEntity(ContentType(`text/plain`), s.toString) }
...

get {
  ( setCookie(HttpCookie(name = "hello", value = "world")) &amp;
    respondWithHeader(sampleHeader)
    ) {
    onComplete(TaskService.select(task)) {
      case Success(Some(value)) =&gt; complete(value)
      case Success(None) =&gt; complete(StatusCodes.NotFound, 
                                         "No tasks found")
      case Failure(ex)  =&gt; complete(StatusCodes.InternalServerError,
                              s"An error occurred: ${ex.getMessage}")
    }
  }
}</pre></div><p class="calibre7">In this code fragment, we use a couple of directives provided by Akka HTTP that can be used to customize the response to a request. With the <code class="email">setCookie</code> and <code class="email">respndWithHeader</code> directives, we add the custom cookie and header. In the inner route of this directive, we use the <code class="email">onComplete</code> directive to determine what to do with the response from the <code class="email">TaskService.select</code> function. If the <code class="email">Future</code> succeeds with <code class="email">Some[Task]</code>, we respond with this <code class="email">Task</code>. If no <code class="email">Task</code> is found, we return with a <code class="email">404</code> (the <code class="email">NotFound</code> status code). Finally, if the <code class="email">Future</code> fails to complete successfully, we respond with an <code class="email">InternalServerError</code>. You might notice that this time, we didn't convert the <code class="email">Task</code> to a string, but just returned it. This works in this case because we've also defined an implicit, <code class="email">ToEntityMarshaller[Task]</code>. This marshaller allows Akka HTTP to convert the <code class="email">Task</code> case class to an <code class="email">HTTPEntity</code> instance, which Akka HTTP knows how to marshal to an <code class="email">HttpResponse</code>.</p><p class="calibre7">Besides the directives shown here, Akka HTTP provides a number of other directives and functions you <a id="id258" class="calibre1"/>can use to customize the responses. The following table <a id="id259" class="calibre1"/>shows the directives related to customizing the response:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Directive</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">complete</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This completes the request with the provided arguments.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">completeOrRecoverWith</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns the result of the provided <code class="literal">Future</code> object. If the <code class="literal">Future</code> fails the exception is extracted and the inner route is run.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">completeWith</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This extracts a function that can be called to complete the request.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">getFromBrowseableDirectories</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This serves the content of the given directories as a file-system browser.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">getFromBrowseableDirectory</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This serves the content of the given directory as a file-system browser.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">getFromDirectory</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matches a <code class="literal">GET</code> request and returns with the content of a file in a specific directory.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">getFromFile</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matches a <code class="literal">GET</code> request and returns with the content of a file.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">getFromResource</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matches a <code class="literal">GET</code> request and returns with the content of a classpath resource.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">getFromResourceDirectory</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matches a <code class="literal">GET</code> request and returns with the content of a classpath resource in a specified classpath directory.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">listDirectoryContents</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matches a <code class="literal">GET</code> request and returns with the content of a specific directory.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">redirect</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This sends a redirection response. There are also more specific directives:</p>
<div class="itemizedlist2"><ul class="itemizedlist3"><li class="listitem1"><code class="literal">redirectToNoTrailingSlashIfPresent</code></li><li class="listitem1"><code class="literal">redirectToTrailingSlashIfMissing</code></li></ul></div>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">respondWithHeader</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This sets a specific header on the response object. You can also add multiple headers at once using the <code class="literal">responseWithHeaders</code> directive. This directive overwrites the already set headers. If you don't want to override the existing headers, use the following directives:</p>
<div class="itemizedlist2"><ul class="itemizedlist3"><li class="listitem1"><code class="literal">respondWithDefaultHeaders</code></li><li class="listitem1"><code class="literal">respondWithDefaultHeader</code></li></ul></div>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">setCookie, deleteCookie</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This adds or deletes a cookie.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">overrideStatusCode</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This sets the HTTP status code of the response. Akka HTTP provides a <code class="literal">StatusCode</code> object, which you can use to access all the available response codes.</p>
</td></tr></tbody></table></div><p class="calibre7">If these directives aren't enough, there is also the option to simply return an <code class="email">HttpResponse</code> object. Akka HTTP <a id="id260" class="calibre1"/>provides an <code class="email">HttpResponse</code> case class for that, which you can use like this:</p><div class="informalexample"><pre class="programlisting">final case class HttpResponse(status: StatusCode = StatusCodes.OK,
                 headers: immutable.Seq[HttpHeader] = Nil,
                 entity: ResponseEntity = HttpEntity.Empty,
                 protocol: HttpProtocol = HttpProtocols.`HTTP/1.1`)</pre></div><p class="calibre7">So far in this <a id="id261" class="calibre1"/>chapter, we saw how to access and extract information from the request and ways to set and customize the response. In the last couple of pages from this chapter, we'll look at the different ways you can handle errors and exception situations from Akka HTTP.</p></div>
<div class="book" title="Exception handling and rejections"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec38" class="calibre1"/>Exception handling and rejections</h1></div></div></div><p class="calibre7">In this <a id="id262" class="calibre1"/>section, we'll look at how Akka HTTP handles exceptions and rejections. Before we look at the code, we'll once again use Postman to show what we want to accomplish. Let's start with how rejections are handled. Rejections are functional errors that are either thrown by <a id="id263" class="calibre1"/>directives or which you can throw yourself. In this example, we add some validations to the create task request. So run <code class="email">sbt runCH05-runCH05Step3</code>, open up Postman, and execute the request, <span class="strong"><strong class="calibre8">Step 03 - Rejection handling</strong></span>:</p><div class="mediaobject"><img src="../images/00043.jpeg" alt="Exception handling and rejections" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">As you can see from the response, the title of the task we want to create must be at least 10 characters. The <a id="id264" class="calibre1"/>code <a id="id265" class="calibre1"/>where we add this validation and also configure the rejection handler is shown here:</p><div class="informalexample"><pre class="programlisting">handleRejections(customRejectionHandler) {
  ((post) &amp; (parameters("title", "person".?, "status" ? "new"))) { 
         (title, assignedTo, status) =&gt; { 
    (entity(as[String])) { body =&gt; {
      (validate(title.length &gt; 10, 
            "Title must be longer than 10 characters") &amp;
        validate(List("new", "done", "in progress").contains(status),  
            "Status must be either 'new', 'done' or 'in progress'") &amp;
        validate(body.length &gt; 0, 
            "Title must be longer than 10 characters")
        ) {
        complete {
TaskService.insert(Task(-1, title, body, 
                    assignedTo.map(Person(_)),
                    List.empty, Status(status)))
         
        }
      }
    }
    }
  }
  }
}</pre></div><p class="calibre7">In this code we use the <code class="email">validate</code> directive to check the incoming parameters. If one of the validations fails, the request will be rejected with a <code class="email">ValidationRejection</code> result. We've wrapped this route with the <code class="email">handleRejections</code> directive, so all the rejections from this route will be caught by this handler. The following code fragment shows what this handler looks like:</p><div class="informalexample"><pre class="programlisting">  val customRejectionHandler =
    RejectionHandler.newBuilder()
      .handle {
      case ValidationRejection(cause, exception) =&gt;
        complete(HttpResponse(StatusCodes.BadRequest, entity = 
                 s"Validation failed: $cause"))
    }.result()</pre></div><p class="calibre7">When you want to create a rejection handler, it's easiest to use the <code class="email">RejectionHandler.newBuilder</code> object. This object provides you with a couple of functions you can call to define this handler's behavior. The <code class="email">handle</code> function we used here allows us to handle single rejections, and we used this to respond with a 400 bad request, when a <code class="email">ValidationRejection</code> occurs. Any <a id="id266" class="calibre1"/>other rejections bubble up the <a id="id267" class="calibre1"/>route. Besides <code class="email">handle</code>, you can also use <code class="email">handleAll</code> to handle multiple instances of the same rejection at the same time. Finally, there is a specific <code class="email">handleNotFound</code> function you can use to define behavior for when a resource isn't found.</p><p class="calibre7">Handling exceptions works in pretty much the same way. Open up Postman again and use the <span class="strong"><strong class="calibre8">Step 03 - Exception handling</strong></span> request to trigger an exception:</p><div class="mediaobject"><img src="../images/00044.jpeg" alt="Exception handling and rejections" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">In this case, we return an internal server error. The following code fragment shows how to do this with Akka HTTP:</p><div class="informalexample"><pre class="programlisting">val customExceptionHandler = ExceptionHandler {
  case _: IllegalArgumentException =&gt;
    // you can easily access any request parameter here using extractors.
    extractUri { uri =&gt;
      complete(HttpResponse(StatusCodes.InternalServerError, entity = s"The function on $uri isn't implemented yet"))
    }
}
...
path("search") {
  handleExceptions(customExceptionHandler) {
      failWith(IllegalArgumentException("Search call not implemented"))
  }
}</pre></div><p class="calibre7">As you can <a id="id268" class="calibre1"/>see, using an exception handler is not that different from the <a id="id269" class="calibre1"/>rejection handler we discussed previously. This time, we define an <code class="email">ExceptionHandler</code> and use the <code class="email">handleExceptions</code> directive to connect it to a specific part of the route. For the <code class="email">ExceptionHandler</code>, we only provide a partial function where we specify the exceptions to catch.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip15" class="calibre1"/>Tip</h3><p class="calibre7">In this section, we explicitly used the <code class="email">handleExceptions</code> and <code class="email">handleRejections</code> functions to define which handler to use for part of the route. If you want to create a custom handler that matches the complete request, you can also define the handlers as implicits. This way, they will be used for all the rejections and exceptions produced by the route. Also, good to note is that you don't necessarily have to match all the rejections and exceptions. If you don't match a specific exception or rejection, it will bubble up to one higher in the route and, eventually, it will reach the Akka HTTP provided default handlers.</p></div><p class="calibre7">In this sample, we've so far seen the <code class="email">handleRejections</code> and <code class="email">handleExceptions</code> directives; there are a couple of other directives and functions available that are related to rejections and exceptions. The following table lists all of these:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Directive</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">handleRejection</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This handles the current set of rejections using the provided <code class="literal">RejectionHandler</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">handleException</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This handles exceptions thrown from the inner route using the provided <code class="literal">ExceptionHandler</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">cancelRejection</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This allows you to cancel a rejection coming from the inner route. You can also use the <code class="literal">cancelRejections</code> directive to cancel multiple ones.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">failWith</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This directive raises the specified exception; this should be used instead of throwing exceptions.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">recoverRejections</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This directive and <code class="literal">RecoverRejectionsWith</code> allow you to handle rejections and transform them in to a normal result.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">reject</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This rejects the request with the specified rejections.</p>
</td></tr></tbody></table></div><p class="calibre7">With these directives, and the use of global rejection and exception handlers, you should be able to cleanly handle the fault situations in your REST service.</p><p class="calibre7">For the last subject in the discussion on Akka HTTP we'll quickly show you how to add JSON support to your service.</p></div>
<div class="book" title="Adding JSON support"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec39" class="calibre1"/>Adding JSON support</h1></div></div></div><p class="calibre7">As a final <a id="id270" class="calibre1"/>step, we'll add JSON support to our Akka HTTP REST service. With this added, we'll be able to send JSON to our service, and Akka HTTP will automatically convert it to the case classes we use. The first thing we need to do is add an additional SBT dependency:</p><div class="informalexample"><pre class="programlisting">val backendDeps = Seq (
  "com.typesafe.akka" %% "akka-stream-experimental" % akkaHttpVersion,
  "com.typesafe.akka" %% "akka-http-core-experimental" % akkaHttpVersion,
  "com.typesafe.akka" %% "akka-http-experimental" % akkaHttpVersion,
  "com.typesafe.akka" %% "akka-http-spray-json-experimental" % akkaHttpVersion
)</pre></div><p class="calibre7">Once added, we need to inform Akka HTTP which of our case classes should be marshaled to and from JSON. The common way to do this is by defining a specific trait, which contains the implicits needed by Akka HTTP. For our example, we define that trait like this:</p><div class="informalexample"><pre class="programlisting">trait AkkaJSONProtocol extends DefaultJsonProtocol {
  implicit val statusFormat = jsonFormat1(Status.apply)
  implicit val noteFormat = jsonFormat2(Note.apply)
  implicit val personFormat = jsonFormat1(Person.apply)
  implicit val taskFormat = jsonFormat6(Task.apply)
}</pre></div><p class="calibre7">This code is pretty self-explanatory. What we do here is define which case classes should be marshaled to and from JSON. Next, we need to make sure we import Akka HTTP's JSON library:</p><div class="informalexample"><pre class="programlisting">import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport</pre></div><p class="calibre7">And finally, make sure we extend this trait in our application:</p><div class="informalexample"><pre class="programlisting">object AkkaHttpDSLStep4 extends App with AkkaJSONProtocol</pre></div><p class="calibre7">At this point, we can remove the custom marshallers we defined earlier in this chapter, and make all our methods just return the <code class="email">Task</code> instances instead of converting the <code class="email">Task</code> instances into strings. For instance, to retrieve all the current stored tasks, we just do this:</p><div class="informalexample"><pre class="programlisting">path("tasks") {
  get {
    complete {
      TaskService.all
    }
  }
}</pre></div><p class="calibre7">To also<a id="id271" class="calibre1"/> convert incoming JSON to a <code class="email">Task</code> object, we need to use the <code class="email">entity</code> directive. The code to add a <code class="email">Task</code> object now becomes this:</p><div class="informalexample"><pre class="programlisting">post {
   (entity(as[Task])) { task =&gt; {
      complete {
        TaskService.insert(task)
      }
    }
  }
}</pre></div><p class="calibre7">With these steps taken, we can open up Postman and see whether it works. In Postman, open request, <span class="strong"><strong class="calibre8">04 - Create Task</strong></span>, and run it:</p><div class="mediaobject"><img src="../images/00045.jpeg" alt="Adding JSON support" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Here, we <a id="id272" class="calibre1"/>can see that the JSON sent is being processed by the server and is successfully added. Now repeat this a couple of times and then use the <span class="strong"><strong class="calibre8">04 - Get all Tasks</strong></span> request to see whether we can retrieve the list of all the tasks we've added:</p><div class="mediaobject"><img src="../images/00046.jpeg" alt="Adding JSON support" class="calibre10"/></div><p class="calibre11"> </p></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec40" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we explored most of the features provided by Akka HTTP. You learned to use the available directives to match specific request properties and extract information from the headers, parameters, and body of the request. Besides directives to process incoming requests, Akka HTTP also provides directives to create and customize the response that is sent back to the client. If errors occur while processing the request, Akka HTTP provides standard exception and rejection handlers. You also learned how you can override the default behavior by adding custom handlers. Finally, this chapter also showed you how easy it is to add JSON support and automatically marshal your classes to and from JSON.</p><p class="calibre7">In the next chapter, we'll look at the final REST framework that we'll discuss in this book, <span class="strong"><strong class="calibre8">Play 2</strong></span>.</p></div></body></html>