<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Microservices Development with Java EE</h1>
                </header>
            
            <article>
                
<p>Microservices is an architectural style in which code is deployed in small, granular modules. A microservices architecture reduces coupling and increases cohesion. Typically, microservices are implemented as RESTful web services, usually using JSON to pass data to one another by invoking HTTP methods (<kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>PUT</kbd> or <kbd>DELETE</kbd>) on each other. Since communication between microservices is done via HTTP methods, microservices written in different programming languages can interact with each other. In this chapter, we will cover how we can use Java EE to implement microservices.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Introduction to microservices</li>
<li>Advantages of a microservices architecture</li>
<li>Disadvantages of a microservices architecture</li>
<li>Developing microservices using Java EE</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to microservices</h1>
                </header>
            
            <article>
                
<p>Architecting applications as a series of microservices offer some advantages over traditionally designed applications, as well as some disadvantages. When considering a microservices architecture for our applications, we must carefully weigh the advantages and disadvantages before we make our decision.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advantages of a microservices architecture</h1>
                </header>
            
            <article>
                
<p>Developing an application as a series of microservices offers several advantages over traditionally designed applications:</p>
<ul>
<li><strong>Smaller code bases</strong>: since each microservice is a small, standalone unit, code bases for microservices tend to be smaller and easier to manage than traditionally designed applications.</li>
<li><strong>Microservices encourage good coding practices:</strong> a microservices architecture encourages loose coupling and high cohesion.</li>
<li><strong>Greater resilience:</strong> traditionally designed applications act as a single point of failure; if any component of the application is down or unavailable, the whole application is unavailable. Since microservices are independent modules, one component (that is, one microservice) being down does not necessarily make the whole application unavailable.</li>
<li><strong>Scalability:</strong> since applications developed as a series of microservices are composed of a number of different modules, scalability becomes easier; we can focus only on those services that may need scaling, without having to waste effort on parts of the application that do not need to be scaled.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Disadvantages of a microservices architecture</h1>
                </header>
            
            <article>
                
<p>Developing and deploying applications adhering to microservice architecture comes with its own set of challenges, regardless of which programming language or application framework is used to develop the application:</p>
<ul>
<li><strong>Additional operational and tooling overhead:</strong> each microservice implementation would require its own (possibly automated) deployment, monitoring systems, and so on.</li>
<li><strong>Debugging microservices may be more involved than debugging traditional enterprise applications:</strong> if an end user reports a problem with their application and that application utilizes multiple microservices internally, it is not always clear which of the microservices may be the culprit. This may be especially difficult if the microservices involved are developed by different teams with different priorities.</li>
<li><strong>Distributed transactions may be a challenge:</strong> rolling back a transaction involving several microservices may be hard. A common approach to working around this is to isolate microservices as much as possible, treating them as single units, then have local transaction management for each microservice. For example, if microservice A invokes microservice B, if there is a problem with microservice B, a local transaction in microservice B would roll back, then it would return an HTTP status code <kbd>500</kbd> (server error) to microservice A. Microservice A could then use this HTTP status code as a signal to initiate a compensating transaction to bring the system back to its initial state.</li>
<li><strong>Network latency:</strong> since microservices rely on HTTP method calls for communication, performance can sometimes suffer <span>due to network latency</span>.</li>
<li><strong>Potential for complex interdependencies:</strong> while independent microservices tend to be simple, they are dependent on each other. A microservices architecture can potentially create a complex dependency graph. This situation can be worrisome if some of our services depend on microservices developed by other teams who may have conflicting priorities (for example, if we find a bug in their microservice, however, fixing the bug may not be a priority for the other team).</li>
<li><strong>Susceptible to the fallacies of distributed computing:</strong> applications developed following microservice architecture may make some incorrect assumptions, such as network reliability, zero latency, infinite bandwidth, and so on.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Microservices and Java EE</h1>
                </header>
            
            <article>
                
<p>Some may think that Java EE is "too heavyweight" for microservices development, but this is simply not the case. Because of this misconception, some may think that Java EE may not be suitable for a microservices architecture, when, in reality, Java EE fits microservices development well. In the past, Java EE applications were deployed to a "heavyweight" application server. Nowadays, most Java EE application server vendors offer lightweight application servers that use very little memory or disk space. Some examples of these Java EE compliant lightweight application servers include IBM's Open Liberty, Red Hat's WildFly Swarm, Apache TomEE, and Payara Micro.</p>
<p>Developing microservices with Java EE involves writing standard Java EE applications while limiting yourself to a certain subset of Java EE APIsâ€”typically, JAX-RS and JSON-P or JSON-B, and perhaps some others, such as CDI and, if interacting with a relational database, JPA. Java EE developers can leverage their existing expertise when developing microservices. The main requirement is the development of RESTful web services using JAX-RS. Then, these web services are packaged in a WAR file and deployed to a lightweight application server as usual.</p>
<p>When using modern, embeddable Java EE application servers, usually only one application is deployed to each instance of the application server, and, in some cases, the "tables are turned" so to speak, by having the application server be just a library that the application uses as a dependency. With these modern application servers, several instances of the application server are often deployed to a server, making modern Java EE particularly suitable for microservices development. Many modern, lightweight Java EE application servers are embeddable, allowing the creation of an "uber jar", which includes both the application code and the application server libraries. This "uber jar" is then transferred to the server and run as a standalone application. In addition to "uber jars", modern application servers can be added to a container image (such as Docker), then applications can be deployed as a thin war, typically only a few kilobytes in size; this approach has the advantage of very fast deployments, usually under 2 seconds.</p>
<p>By deploying to a contemporary Java EE Web Profile compliant application server (or, as explained in the previous paragraph, creating an "uber jar"), Java EE developers can certainly leverage their existing expertise to develop microservice compliant applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing microservices using Java EE</h1>
                </header>
            
            <article>
                
<p>Now that we have given a brief introduction to microservices, we are ready to see an example microservices application written using Java EE. Our example application should be very familiar to most Java EE developers. It is a simple <strong>CRUD</strong> (<strong>Create, Read, Update, Delete</strong>) application. Developed as a series of microservices, the application will follow the familiar MVC design pattern, with the "View" and "Controller" developed as microservices. The application will also utilize the very common DAO pattern, with our DAO developed as a microservice as well.</p>
<div class="packt_infobox">Actually, the example code is not a full CRUD application. For simplicity, we decided to only implement the "Create" part of our CRUD application.</div>
<p>We will be using Payara Micro to deploy our example code. Payara Micro is a lightweight Java EE application server derived from GlassFish, it is open source and freely available, and supports the Java EE web profile, which includes a subset of all Java EE specifications, namely, Security, Bean Validation, CDI, EJB Lite (provides a subset of full EJB functionality), the Unified Expression Language, JAX-RS, JDBC, JNDI, JPA, JSF, JSON-P, JSP, Servlets, and WebSockets.</p>
<div class="packt_infobox">Payara Micro can be downloaded at <a href="https://www.payara.fish/downloads"><span class="URLPACKT">https://www.payara.fish/downloads<span>.</span></span></a></div>
<p>Our application will be developed as three modules: first, a microservices client, followed by a microservices implementation of a controller in the MVC design pattern, then an implementation of the DAO design pattern implemented as a microservice.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing microservices client code</h1>
                </header>
            
            <article>
                
<p>Before delving into developing our services, we will first develop a microservices client, in the form of an HTML5 page, using the popular Twitter Bootstrap CSS library as well as the ubiquitous jQuery JavaScript library. The JavaScript code in the frontend service will invoke the controller microservice, passing a JSON representation of user entered data. The controller service will then invoke the persistence service and save data to a database. Each microservice will return an HTTP code indicating success or an error condition.</p>
<p>The most relevant parts of our client code are the HTML form and the jQuery code to submit the form to our controller microservice.</p>
<div class="packt_infobox">We will only show small snippets of code here. The complete code for the sample application can be found at:<br/>
<a href="https://github.com/dheffelfinger/Java-EE-8-Application-Development-Code-Samples"><span class="URLPACKT">https://github.com/dheffelfinger/Java-EE-8-Application-Development-Code-Samples</span></a>.</div>
<p>Markup for the form in our HTML5 page looks as follows:</p>
<pre style="padding-left: 60px">&lt;form id="customerForm"&gt; 
    &lt;div class="form-group"&gt; 
        &lt;label for="salutation"&gt;Salutation&lt;/label&gt;&lt;br/&gt; 
        &lt;select id="salutation" name="salutation" <br/>            class="form-control" style="width: 100px !important;"&gt; 
            &lt;option value=""&gt; &lt;/option&gt; 
            &lt;option value="Mr"&gt;Mr&lt;/option&gt; 
            &lt;option value="Mrs"&gt;Mrs&lt;/option&gt; 
            &lt;option value="Miss"&gt;Miss&lt;/option&gt; 
            &lt;option value="Ms"&gt;Ms&lt;/option&gt; 
            &lt;option value="Dr"&gt;Dr&lt;/option&gt; 
        &lt;/select&gt; 
    &lt;/div&gt; 
    &lt;div class="form-group"&gt; 
        &lt;label for="firstName"&gt;First Name&lt;/label&gt; 
        &lt;input type="text" maxlength="10" class="form-control"<br/>         id="firstName" name="firstName"  placeholder="First Name"&gt; 
    &lt;/div&gt; 
    &lt;div class="form-group"&gt; 
        &lt;label for="middleName"&gt;Middle Name&lt;/label&gt; 
        &lt;input type="text" maxlength="10" class="form-control"<br/>         id="middleName" name="middleName" placeholder="Middle <br/>         Name"&gt; 
    &lt;/div&gt; 
    &lt;div class="form-group"&gt; 
        &lt;label for="lastName"&gt;Last Name&lt;/label&gt; 
        &lt;input type="text" maxlength="20" class="form-control"<br/>         id="lastName" name="lastName" placeholder="Last Name"&gt; 
    &lt;/div&gt; 
    &lt;div class="form-group"&gt; 
        &lt;button type="button" id="submitBtn" <br/>         class="btn btn-primary"&gt;Submit&lt;/button&gt; 
    &lt;/div&gt; 
&lt;/form&gt; 
As we can see, this is a standard HTML form using Twitter Bootstrap CSS classes. Our page also has a script to send form data to the controller microservice. 
&lt;script&gt; 
  $(document).ready(function () { 
      $("#submitBtn").on('click', function () { 
         <strong> var customerData = $("#customerForm").serializeArray();</strong> 
          $.ajax({ 
              headers: { 
                  'Content-Type': 'application/json' 
              }, 
             <strong> crossDomain: true,</strong> 
              dataType: "json", 
              type: "POST", 
              <strong>url:   <br/>          "http://localhost:8180/CrudController/webresources/customercontroller/"</strong>, 
              data: JSON.stringify(customerData) 
            }).done(function (data, textStatus, jqXHR) { 
              if (jqXHR.status === 200) { 
                  $("#msg").removeClass(); 
                  $("#msg").toggleClass("alert alert-success"); 
                  $("#msg").html("Customer saved successfully."); 
              } else { 
                  $("#msg").removeClass(); 
                  $("#msg").toggleClass("alert alert-danger"); 
                  $("#msg").html("There was an error saving <br/>                   customer data."); 
              } 
          }).fail(function (data, textStatus, jqXHR) { 
              console.log("ajax call failed"); 
              console.log("data = " + JSON.stringify(data)); 
              console.log("textStatus = " + textStatus); 
              console.log("jqXHR = " + jqXHR); 
              console.log("jqXHR.status = " + jqXHR.status); 
          }); 
      }); 
  }); 
&lt;/script&gt; </pre>
<p>The script is invoked when the <span class="packt_screen">Submit</span> button on the page is clicked. It uses jQuery's <kbd>serializeArray()</kbd> function to collect user-entered form data and create a JSON-formatted array with it. The <kbd>serializeArray()</kbd> function creates an array of JSON objects. Each element on the array has a <span class="SourceText">name</span> property matching the name attribute on the HTML markup, and a <kbd>value</kbd> property matching the user-entered value.</p>
<p>For example, if a user selected <kbd>"Mr"</kbd> in the salutation drop down, entered <kbd>"John"</kbd> in the first name field, left the middle name blank, and entered <kbd>"Doe"</kbd> as the last name, the generated JSON array would look as follows:</p>
<pre style="padding-left: 60px">[{"name":"salutation","value":"Mr"},{"name":"firstName","value":"John"},{"name":"middleName","value":""},{"name":"lastName","value":"Doe"}] </pre>
<p>Notice that the value of each <kbd>"name"</kbd> property in the JSON array above matches the <kbd>"name"</kbd> attributes in the HTML form; the corresponding <kbd>"value"</kbd> attributes match the user entered values.</p>
<p>Since the generated HTTP request will be sent to a different instance of Payara Micro, we need to set the <kbd>crossDomain</kbd> property of the <kbd>Ajax</kbd> settings object to <kbd>true</kbd>, even though we are deploying all of our microservices to the same server (or, in our case, to our local workstation).</p>
<p>Notice that the <kbd>url</kbd> property value of the <kbd>Ajax</kbd> setting objects has a port of <kbd><span class="SourceText">8180</span></kbd>, we need to make sure our controller microservice is listening to this port when we deploy it.</p>
<p>We can deploy our View microservice to Payara Micro from the command line as follows:</p>
<pre><strong>java -jar payara-micro-4.1.2.173.jar --noCluster --deploy /path/to/CrudView.war</strong></pre>
<p>Payara micro is distributed as an executable JAR file, therefore, we can start it via the <kbd>java -jar</kbd> command. The exact name of the JAR file will depend on the version of Payara Micro you are using.</p>
<p>By default, Payara Micro instances running on the same server form a cluster automatically. For our simple example, we don't need this functionality, therefore, we used the <kbd>--noCluster</kbd> command-line argument.</p>
<p>The <kbd>--deploy</kbd> command-line argument is used to specify the artifact we want to deploy. In our case, it is a WAR file containing the HTML5 page serving as the user interface of our example application.</p>
<p>We can examine the Payara Micro output to make sure our application was deployed successfully:</p>
<pre>    <strong>
      <span class="SourceText">
<strong>[2017-10-21T12:00:35.196-0400] [] [INFO] [AS-WEB-GLUE-00172] [javax.enterprise.web] [tid: _ThreadID=1 _ThreadName=main] [timeMillis: 1508601635196] [levelValue: 800] Loading application [CrudView] at [/CrudView]</strong>
      </span>
    </strong>
    <strong>
      
    </strong>
    <strong>
      <span class="SourceText">
<strong>[2017-10-21T12:00:35.272-0400] [] [INFO] [] [javax.enterprise.system.core] [tid: _ThreadID=1 _ThreadName=main] [timeMillis: 1508601635272] [levelValue: 800] CrudView was successfully deployed in 1,332 milliseconds.</strong>
      </span>
    </strong>
    <strong>
      
    </strong>
    <strong>
      <span class="SourceText">
<strong>[2017-10-21T12:00:35.274-0400] [] [INFO] [] [PayaraMicro] [tid: _ThreadID=1 _ThreadName=main] [timeMillis: 1508601635274] [levelValue: 800] Deployed 1 archive(s)</strong>
      </span>
    </strong>
  </pre>
<p>We can now point our browser to our CrudView application URL (<kbd><span class="InternetLink">http://localhost:8080/CrudView</span></kbd> in our example). After entering some data, the page will look as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/8168e3e7-e98e-4f9e-a8ad-180cd90c6aa2.png" style="width:36.75em;height:31.08em;"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">When the user clicks on the <span class="packt_screen">Submit</span> button, the client passes a JSON representation of user-entered data to the controller service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The controller service</h1>
                </header>
            
            <article>
                
<p>The controller service is a standard RESTful web service implementation of a controller in the MVC design pattern, implemented using JAX-RS:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.microservices.crudcontroller.service; 
//imports omitted for brevity 
@Path("/customercontroller") 
public class CustomerControllerService { 
     
    public CustomerControllerService() { 
    } 
 
    @OPTIONS 
    public Response options() { 
        return Response.ok("") 
<strong>                .header("Access-Control-Allow-Origin",</strong><strong>                        <br/>                "http://localhost:8080")</strong> 
                .header("Access-Control-Allow-Headers", "origin," +  
                        "content-type, accept, authorization") 
                .header("Access-Control-Allow-Credentials", "true") 
                .header("Access-Control-Allow-Methods",  
                        "GET, POST, PUT, DELETE, OPTIONS, HEAD") 
                .header("Access-Control-Max-Age", "1209600") 
                .build(); 
    } 
 
    <strong>@POST 
    @Consumes(MediaType.APPLICATION_JSON) 
    public Response addCustomer(String customerJson) { 
        Response response; 
        Response persistenceServiceResponse; 
        CustomerPersistenceClient client =  
          new CustomerPersistenceClient(); 
        Customer customer = jsonToCustomer(customerJson); 
        persistenceServiceResponse = client.create(customer); 
        client.close(); 
 
        if (persistenceServiceResponse.getStatus() == 201) { 
            response = Response.ok("{}"). 
                    header("Access-Control-Allow-Origin", 
                           "http://localhost:8080").build(); 
 
        } else { 
            response = Response.serverError(). 
                    header("Access-Control-Allow-Origin",</strong><br/><strong>                                  "http://localhost:8080").build(); 
        } 
        return response; 
    }</strong> 
 
    private Customer jsonToCustomer(String customerJson) { 
        Customer customer = new Customer(); 
        JsonArray jsonArray; 
        try (JsonReader jsonReader = Json.createReader( 
                new StringReader(customerJson))) { 
            jsonArray = jsonReader.readArray(); 
        } 
 
        for (JsonValue jsonValue : jsonArray) { 
            JsonObject jsonObject = (JsonObject) jsonValue; 
            String propertyName = jsonObject.getString("name"); 
            String propertyValue = jsonObject.getString("value"); 
 
            switch (propertyName) { 
                case "salutation": 
                    customer.setSalutation(propertyValue); 
                    break; 
                case "firstName": 
                    customer.setFirstName(propertyValue); 
                    break; 
                case "middleName": 
                    customer.setMiddleName(propertyValue); 
                    break; 
                case "lastName": 
                    customer.setLastName(propertyValue); 
                    break; 
                default: 
                    LOG.log(Level.WARNING, String.format( 
                            "Unknown property name found: %s", 
                             propertyName)); 
                    break; 
            } 
        } 
        return customer; 
    } 
} </pre>
<p>The <kbd>options()</kbd> method, annotated with the <kbd>javax.ws.rs.OPTIONS</kbd> annotation, is necessary since the browser automatically calls it before invoking the actual <kbd>POST</kbd> request containing the main logic of our server. In this method, we set some header values to allow <strong>Cross-Origin Resource Sharing</strong> (<strong>CORS</strong>), which in simple terms means we allow our service to be invoked from a different server than the one our service is running on. In our case, the client is deployed to a different instance of Payara Micro, therefore, it is considered a different origin. These headers are necessary to allow our client code and controller service to communicate with each other. Notice that we explicitly allow requests from <kbd>http://localhost:8080</kbd>, which is the host and port where our client code is deployed.</p>
<p>The main logic of our controller service is in the <kbd>addCustomer()</kbd> method. This method receives the JSON string sent by the client as a parameter. In this method, we create an instance of <kbd>CustomerPersistenceClient()</kbd>, which is a client for the persistence service implemented using the JAX-RS client API.</p>
<p>We then create an instance of a <kbd>Customer</kbd> class by invoking the <kbd>jsonToCustomer()</kbd> method. This method takes the JSON string sent by the client and, using the standard Java EE JSON-P API, populates an instance of the <kbd>Customer</kbd> class with the corresponding values in the JSON string.</p>
<div class="packt_infobox">The <kbd>Customer</kbd> class is a simple <strong>Data Transfer Object</strong> (<strong>DTO</strong>) containing a few properties matching the input fields in the form in the client, plus corresponding getters and setters. The class is so simple we decided not to show it.</div>
<p>Our <kbd>addCustomer()</kbd> method then invokes the persistence service by invoking the <kbd>create()</kbd> method on <kbd>CustomerPersistenceClient</kbd>, checks the HTTP status code returned by the persistence service, then returns a corresponding status code to the client.</p>
<p>Let's now take a look at the implementation of our JAX-RS client code:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.microservices.crudcontroller.restclient; 
//imports omitted 
public class CustomerPersistenceClient { 
 
    private final WebTarget webTarget; 
    private final Client client; 
<strong>    private static final String BASE_URI =</strong><strong>       <br/>    "http://localhost:8280/CrudPersistence/webresources";</strong> 
 
    public CustomerPersistenceClient() { 
<strong>        client = javax.ws.rs.client.ClientBuilder.newClient();</strong><strong>       <br/>        webTarget =</strong><strong> <br/>        client.target(BASE_URI).path("customerpersistence");</strong> 
    } 
 
    public Response create(Customer customer) throws 
      ClientErrorException { 
<strong>        return webTarget.request(</strong><strong>           <br/>        javax.ws.rs.core.MediaType.APPLICATION_JSON).</strong><strong>           <br/>         post(javax.ws.rs.client.Entity.entity(customer,</strong><strong>           <br/>          javax.ws.rs.core.MediaType.APPLICATION_JSON),</strong><strong>      <br/>           Response.class);</strong> 
    } 
 
    public void close() { 
        client.close(); 
    } 
} </pre>
<p>Our controller service only uses two standard Java EE APIs, namely JAX-RS and JSON-P. As we can see, our client code is a fairly simple class. Making use of the JAX-RS client API, we declare a constant containing the base URI of the service we are invoking (our persistence service). In its constructor, we create a new instance of <kbd>javax.ws.rs.client.ClientBuilder</kbd>, then set its base URI and path, matching the appropriate values for our persistence service. Our client class has a single method, which submits an HTTP <kbd>POST</kbd> request to the persistence service, then returns the response sent back from it.</p>
<p>We can deploy our controller service to Payara Micro from the command line as follows:</p>
<pre><strong>java -jar payara-micro-4.1.2.173.jar --noCluster --port 8180 --deploy /path/to/CrudController.war</strong></pre>
<p>By examining Payara Micro's output, we can see that our code deployed successfully:</p>
<pre><strong>[2017-10-21T12:04:06.505-0400] [] [INFO] [AS-WEB-GLUE-00172] [javax.enterprise.web] [tid: _ThreadID=1 _ThreadName=main] [timeMillis: 1508601846505] [levelValue: 800] Loading application [CrudController] at [/CrudController]</strong>
    
<strong>[2017-10-21T12:04:06.574-0400] [] [INFO] [] [javax.enterprise.system.core] [tid: _ThreadID=1 _ThreadName=main] [timeMillis: 1508601846574] [levelValue: 800] CrudController was successfully deployed in 1,743 milliseconds.</strong>
    
<strong>[2017-10-21T12:04:06.576-0400] [] [INFO] [] [PayaraMicro] [tid: _ThreadID=1 _ThreadName=main] [timeMillis: 1508601846576] [levelValue: 800] Deployed 1 archive(s)</strong></pre>
<p>Now that we have successfully deployed our controller service, we are ready to go through the final component of our application, the persistence service:</p>
<pre style="padding-left: 60px">package net.ensode.javaee9book.microservices.crudpersistence.service; 
 
//imports omitted for brevity 
@ApplicationScoped 
@Path("customerpersistence") 
public class CustomerPersistenceService { 
    @Context 
    private UriInfo uriInfo; 
    @Inject 
    private CrudDao customerDao; 
 
    @POST 
    @Consumes(MediaType.APPLICATION_JSON) 
    public Response create(Customer customer) { 
        try { 
            customerDao.create(customer); 
        } catch (Exception e) { 
            return Response.serverError().build(); 
        } 
        return Response.created(uriInfo.getAbsolutePath()).build(); 
    } 
} </pre>
<p>In this case, since the client code invoking our service is developed in Java, there is no need to convert the JSON string we receive to Java code; this is done automatically under the covers. Our <kbd>create()</kbd> method is invoked when the controller service sends an HTTP <kbd>POST</kbd> request to the persistence service. This method simply invokes a <kbd>create()</kbd> method on a class implementing the DAO design pattern. Our persistence service returns an <kbd>HTTP response 201</kbd> (created). If everything goes well, if the DAO's <kbd>create()</kbd> method throws an exception, then our service will return an <kbd>HTTP error 500</kbd> (Internal Server Error).</p>
<p>Our DAO is implemented as a CDI-managed bean, using JPA to insert data into the database:</p>
<pre style="padding-left: 60px">package net.ensode.microservices.crudpersistence.dao; 
//imports omitted for brevity 
@ApplicationScoped 
@Transactional 
public class CrudDao { 
    @PersistenceContext(unitName = "CustomerPersistenceUnit") 
    private EntityManager em; 
 
    public void create(Customer customer) { 
        em.persist(customer); 
    } 
} </pre>
<p>Our DAO couldn't be much simpler; it implements a single method that invokes the <kbd>persist()</kbd> method on an injected instance of <kbd>EntityManager</kbd>.</p>
<div class="packt_infobox">In our persistence service project, the <kbd>Customer</kbd> class is a trivial JPA entity.</div>
<p>We now deploy our persistence service to Payara Micro as usual:</p>
<pre><strong>java -jar payara-micro-4.1.2.173.jar --port 8280 --noCluster --deploy /path/to//CrudPersistence.war</strong> </pre>
<p>Examining Payara Micro's output, we can see that our persistence service was deployed successfully:</p>
<pre><strong>[2017-10-21T15:15:17.361-0400] [] [INFO] [AS-WEB-GLUE-00172] [javax.enterprise.web] [tid: _ThreadID=1 _ThreadName=main] [timeMillis: 1508613317361] [levelValue: 800] Loading application [CrudPersistence] at [/CrudPersistence]</strong>
    
<strong>[2017-10-21T15:15:17.452-0400] [] [INFO] [] [javax.enterprise.system.core] [tid: _ThreadID=1 _ThreadName=main] [timeMillis: 1508613317452] [levelValue: 800] CrudPersistence was successfully deployed in 4,201 milliseconds.</strong>
    
<strong>[2017-10-21T15:15:17.453-0400] [] [INFO] [] [PayaraMicro] [tid: _ThreadID=1 _ThreadName=main] [timeMillis: 1508613317453] [levelValue: 800] Deployed 1 archive(s)</strong>
  </pre>
<p>Now that we have deployed all three components of our application, we are ready to see it in action.</p>
<p>Once the user enters some data and clicks the <span class="packt_screen">Submit</span> button, we should see a <em>success</em> message at the top of our page:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/df5271b0-d2ec-495c-923c-d07e61c65b4e.png" style="width:31.25em;height:28.83em;"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">If we take a look at the database, we should see that the user-entered data was persisted successfully:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/a7e9c3e2-7e30-42ac-b6f5-7b99ee7401bc.png" style="width:51.92em;height:25.50em;"/></div>
<p class="mce-root CDPAlignCenter CDPAlign CDPAlignLeft">As shown by our example code, developing applications following microservices architecture in Java EE is very simple; it doesn't require any special knowledge. Microservices are developed using standard Java EE APIs and deployed to a lightweight application server. All of our example code used standard Java EE APIs, covered in previous chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>As we can see, Java EE is particularly suitable for microservices development. Java EE developers can leverage their existing knowledge to develop a microservice architecture and deploy it to modern, lightweight application servers. Traditional Java EE applications can interact with microservices well, as well as being refactored iteratively into a microservice architecture when it makes sense. Whether developing new applications following a microservice architecture, refactoring an existing application to microservices, or modifying existing applications to interact with microservices, Java EE developers can leverage their existing skills for the task at hand.</p>


            </article>

            
        </section>
    </body></html>