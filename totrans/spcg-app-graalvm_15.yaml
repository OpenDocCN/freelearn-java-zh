- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: This section contains answers to the questions from all chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含所有章节的问题答案。
- en: Chapter 1 – Evolution of Java Virtual Machine
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章 – Java虚拟机的发展历程
- en: Java code is compiled to bytecode. JVM uses interpreters to convert the bytecode
    to machine language and uses JIT compilers to compile the most commonly used code
    snippets (hotspots). This approach helps Java to achieve "write-once run-anywhere,"
    as a result of which programmers don't have to write machine-specific code.
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java代码编译成字节码。JVM使用解释器将字节码转换为机器语言，并使用即时编译器编译最常用的代码片段（热点）。这种方法帮助Java实现“一次编写，到处运行”，因此程序员不需要编写特定于机器的代码。
- en: A class loader subsystem is responsible for loading the classes. It not only
    finds the classes, but also verifies and resolves the classes.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类加载器子系统负责加载类。它不仅找到类，还验证和解析类。
- en: 'JVM has five memory areas:'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM有五个内存区域：
- en: 'a. Method: A shared area, where all the class-level data is stored at the JVM
    level'
  id: totrans-6
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 方法：一个共享区域，其中所有类级别的数据都存储在JVM级别
- en: 'b. Heap: All instance variables and objects stored at the JVM level (shared
    across threads)'
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 堆：所有实例变量和对象存储在JVM级别（跨线程共享）
- en: 'c. Stack: A runtime stack per thread to store the local variables at the method
    scope, as well as operands and frame data'
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 栈：每个线程的运行时栈，用于存储方法作用域内的局部变量，以及操作数和帧数据
- en: 'd. Registries: PC registers with the addresses of current executing instructions
    (for each thread)'
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 注册表：具有当前执行指令地址的PC寄存器（每个线程）
- en: 'e. Native method stack: Native method information for each thread that is used
    to invoke native methods'
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: e. 原生方法栈：用于调用原生方法的每个线程的原生方法信息
- en: Chapter 2 – JIT, Hotspot, and GraalJIT
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 – JIT、Hotspot和GraalJIT
- en: A code cache is a special memory area within JVM that is used by JVM to store
    the compiled code. The code is compiled by JIT compilers and stored in the code
    cache. If a method is compiled and is found in the code cache, JVM will use that
    code to run, instead of interpreting the method code. Refer to the *Code cache*
    section for more details
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码缓存是JVM内部的一个特殊内存区域，用于存储编译后的代码。代码由即时编译器编译并存储在代码缓存中。如果一个方法被编译并发现存在于代码缓存中，JVM将使用该代码来运行，而不是解释方法代码。有关更多详细信息，请参阅*代码缓存*部分。
- en: 'The code cache size can be changed using the following flags for fine-tuning.
    Refer to the *Code cache* section for more details:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用以下标志来更改代码缓存大小，以进行微调。有关更多详细信息，请参阅*代码缓存*部分：
- en: a. `-XX:InitialCodeCacheSize` – The initial size of the code cache. The default
    size is 160 KB (the size varies based on the JVM version)
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. `-XX:InitialCodeCacheSize` – 代码缓存的初始大小。默认大小是160 KB（大小根据JVM版本而变化）
- en: b. `-XX:ReservedCodeCacheSize` – This is the maximum size the code cache can
    grow to. The default size is 32/48 MB. When the code cache reaches this limit,
    JVM will throw a warning, `CodeCache is full. Compiler has been disabled.` JVM
    offers the `UseCodeCacheFlushing` option to flush the code cache when the code
    cache is full. The code cache is also flushed when the compiled code is not hot
    enough (when the counter is less than the compiler threshold).
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. `-XX:ReservedCodeCacheSize` – 这是代码缓存可以增长到的最大大小。默认大小是32/48 MB。当代码缓存达到这个限制时，JVM将抛出一个警告，“代码缓存已满。编译器已被禁用。”
    JVM提供了`UseCodeCacheFlushing`选项，当代码缓存满时可以刷新代码缓存。当编译的代码不够热（计数器小于编译器阈值）时，也会刷新代码缓存。
- en: c. `-XX:CodeCacheExpansionSize` – This is the expansion size. When it scales
    up, its default value is 32/64 KB.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. `-XX:CodeCacheExpansionSize` – 这是扩展大小。当它扩大时，其默认值是32/64 KB。
- en: The compiler threshold is the factor that is used to decide when the code is
    "hot." When the code reaches the compiler threshold, JVM will spin off the JIT
    compilation (C1 or C2) on a compilation thread. Refer to the *Compiler threshold*
    section for more details.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器阈值是用于决定代码何时“热”的因子。当代码达到编译器阈值时，JVM将在编译线程上启动即时编译（C1或C2）。有关更多详细信息，请参阅*编译器阈值*部分。
- en: Sometimes, the code can become hot while it is running a long-running loop.
    In such cases, JVM will compile that code and perform OSR. Refer to the *On-stack
    replacement* section for more details and a detailed flow chart regarding how
    JVM performs OSR.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时，代码在运行长时间循环时可能会变得“热”。在这种情况下，JVM将编译该代码并执行OSR。有关更多详细信息以及JVM如何执行OSR的详细流程图，请参阅*栈上替换*部分。
- en: 'In JVM, there is an interpreter and two types of compiler – C1 and C2\. Users
    can specify any specific compiler to be used to optimize the code. By default,
    JVM performs tiered compilation, which is a combination of C1 and C2, based on
    various compiler thresholds. There are five tiers:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JVM中，有一个解释器和两种类型的编译器——C1和C2。用户可以指定任何特定的编译器来优化代码。默认情况下，JVM执行分层编译，这是基于各种编译器阈值的C1和C2的组合。共有五个层级：
- en: a. Interpreted code (level 0)
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 解释型代码（级别0）
- en: b. Simple C1 compiled code (level 1)
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 简单C1编译代码（级别1）
- en: c. Limited C1 compiled code (level 2)
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 有限C1编译代码（级别2）
- en: d. Full C1 compiled code (level 3)
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 完整C1编译代码（级别3）
- en: e. C2 compiled code (level 4)
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: e. C2编译代码（级别4）
- en: 'There are three main patterns that JVM follows:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JVM遵循三种主要模式：
- en: a. Normal Flow
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 正常流程
- en: b. C2 Busy
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. C2繁忙
- en: c. Trivial Code
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 简单代码
- en: Refer to the *Tiered compilation* section for more details.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参阅*分层编译*部分以获取更多详细信息。
- en: Inlining is one of the key optimization techniques that JIT compilers use. Based
    on the profiling of the code, JIT identifies the methods that can be inlined in
    order to avoid method calls. Method calls are expensive, as it performs jumps
    and stack frames are created.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内联是JIT编译器使用的关键优化技术之一。基于代码分析，JIT识别出可以内联的方法以避免方法调用。方法调用成本较高，因为它执行跳转并创建栈帧。
- en: Monomorphic dispatch is another optimization technique used to identify the
    specific implementations of a polymorphic implementation. JIT profiles the code,
    identifies the specific implementation, and optimizes the code around that. Please
    refer to the *Monomorphic, bimorphic, and megamorphic dispatch* section for more
    details.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单态分发是另一种用于识别多态实现的具体实现的优化技术。JIT分析代码，识别具体实现，并围绕该实现优化代码。请参阅*单态、双态和巨态分发*部分以获取更多详细信息。
- en: Loop unrolling is one of the most effective optimizations that JIT performs,
    by inlining code in the loop body, with additional code, and reducing the number
    of iterations a loop has to iterate through. Please refer to the *Loop optimization
    – loop unrolling* section for more details and examples.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环展开是JIT执行的最有效的优化之一，通过在循环体中内联代码、添加额外代码并减少循环必须迭代的次数来实现。请参阅*循环优化——循环展开*部分以获取更多详细信息及示例。
- en: Escape analysis is an optimization technique that the JIT profiler performs
    to identify the allocation and scope of the variables, and takes decisions in
    avoiding heap allocation, and replaces that with stack allocation, based on the
    scope of the variable. This is one of the most advanced analyses performed by
    JIT profilers. Please refer to the *Escape analysis* section for more details.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逃逸分析是JIT分析器执行的一种优化技术，用于识别变量的分配和作用域，并基于变量的作用域做出避免堆分配的决定，并用栈分配替换。这是JIT分析器执行的最先进的分析之一。请参阅*逃逸分析*部分以获取更多详细信息。
- en: JIT performs deoptimization when any of the optimistic assumptions that were
    made to optimize and compile the code are invalid. JIT will make the compiled
    code non-entrant and fall back to the interpreter.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当JIT在优化和编译代码时所做的任何乐观假设无效时，JIT将执行去优化。JIT将编译代码设置为非可进入状态，并回退到解释器。
- en: JVMCI stands for *Java Virtual Machine Compiler Interface*. This interface was
    added to the JDK in Java 9\. JVMCI provides an API to extend JVM and build custom
    compilers. Graal JIT is an implementation of JVMCI. Please refer to the *Graal
    JIT and the JVM Compiler Interface (JVMCI)* section for more details.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVMCI代表*Java虚拟机编译器接口*。此接口在Java 9中添加到JDK中。JVMCI提供了一个API来扩展JVM并构建自定义编译器。Graal
    JIT是JVMCI的一个实现。请参阅*Graal JIT和JVM编译器接口（JVMCI）*部分以获取更多详细信息。
- en: Chapter 3 – Graal VM Architecture
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 - Graal VM架构
- en: GraalVM comes in two versions – Community Edition and Enterprise Edition. Refer
    to *Reviewing the GraalVM editions* section for more details.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GraalVM有两种版本——社区版和企业版。请参阅*查看GraalVM版本*部分以获取更多详细信息。
- en: JVMCI stands for *Java Virtual Machine Compiler Interface*. Java 9 and above
    provide a way to implement custom JIT compilers. JVMCI provides an API to implement
    these custom compilers and provides access to JVM objects and the code cache.
    Graal JIT is an implementation of JVMCI. Refer to the *Java Virtual Machine Compiler
    Interface (JVMCI)* section for more details.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVMCI代表*Java虚拟机编译器接口*。Java 9及以上版本提供了一种实现自定义JIT编译器的方法。JVMCI提供了一个API来实现这些自定义编译器，并提供了对JVM对象和代码缓存的访问。Graal
    JIT是JVMCI的一个实现。请参阅*Java虚拟机编译器接口（JVMCI）*部分以获取更多详细信息。
- en: Graal JIT replaces the C2 JIT compiler. Graal JIT is completely written in Java
    from the ground up but uses the hardened logic and best practices of the C2 compiler.
    Graal JIT implements better optimization strategies than C2 JIT, making it the
    best JIT compiler for Java. Graal JIT can also be used to compile other languages
    that are converted into intermediate representations in order to use the advanced
    optimization strategies. Refer to the *Graal compiler and tooling* section for
    more details.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Graal JIT 替代了 C2 JIT 编译器。Graal JIT 完全用 Java 从头编写，但使用了 C2 编译器的强化逻辑和最佳实践。Graal
    JIT 实现了比 C2 JIT 更好的优化策略，使其成为 Java 最好的 JIT 编译器。Graal JIT 还可以用于编译其他语言，这些语言被转换为中间表示，以便使用高级优化策略。有关详细信息，请参阅
    *Graal 编译器和工具* 部分。
- en: Graal JIT requires a considerable amount of time to warm up, profile, and optimize
    the code. In certain use cases, this may not be suitable (such as serverless or
    containers). For such cases, Graal provides AOT compilation to compile the code
    directly to the native image.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Graal JIT 需要相当长的时间来预热、配置文件和优化代码。在某些用例中，这可能不合适（如无服务器或容器）。对于此类情况，Graal 提供了 AOT
    编译，将代码直接编译成本地图像。
- en: Graal AOT optimization is more related to static code analysis, but it does
    now have the runtime profile of the code to apply any advanced optimization**.
    Profile Guided Optimization** (**PGO**) provides a way to compile the code with
    instrumentation, generate a profile of the runtime, and use that profile to recompile
    the code to the most optimum native image. Refer to the *SubstrateVM (Graal AOT,
    Native Image)* section for more details.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Graal AOT 优化更相关于静态代码分析，但现在它已经有了代码的运行时配置文件来应用任何高级优化**。配置文件引导优化**（**PGO**）提供了一种方法，通过添加工具来编译代码，生成运行时配置文件，并使用该配置文件重新编译代码以生成最优化本机图像。有关详细信息，请参阅
    *SubstrateVM（Graal AOT、本地图像）* 部分。
- en: The Truffle framework is built on top of Graal to support non-JVM languages
    to run on Graal JVM. Truffle provides the Truffle Language Implementation API
    and various other polyglot APIs to provide a very sophisticated environment where
    code in multiple languages can be embedded and interact. Refer to the *Truffle*
    section for more details.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Truffle 框架建立在 Graal 之上，以支持非 JVM 语言在 Graal JVM 上运行。Truffle 提供了 Truffle 语言实现 API
    以及各种其他多语言 API，以提供一个非常复杂的编程环境，其中多种语言的代码可以嵌入并交互。有关详细信息，请参阅 *Truffle* 部分。
- en: SubstrateVM is an embeddable VM that can be packaged along with the native images
    that are compiled by the Graal AOT compiler. Refer to the *SubstrateVM (Graal
    AOT and Native Image)* section for more details.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SubstrateVM 是一个可嵌入的虚拟机，可以与 Graal AOT 编译器编译的本地图像一起打包。有关详细信息，请参阅 *SubstrateVM（Graal
    AOT 和本地图像）* 部分。
- en: Guest Access Context is an object that is used by the host language (such as
    Java) to provide access to the guest language (such as JavaScript) to various
    OS resources, such as the filesystem, I/O, and thread. Refer to the *Security*
    section for more details.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端访问上下文是一个对象，由宿主语言（如 Java）使用，以提供对客户端语言（如 JavaScript）以及各种操作系统资源（如文件系统、I/O 和线程）的访问。有关详细信息，请参阅
    *安全* 部分。
- en: GraalVM provides the most advanced JIT compilation, ideal for long-running processes
    involving high throughput. The GraalVM AOT compiler, along with SubstrateVM, provides
    the smallest and fastest runtime for cloud-native microservices implementations.
    Combined with PGO, it generates the optimum code to run on the cloud. Refer to
    the *GraalVM microservices architecture overview* section for more details.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GraalVM 提供了最先进的 JIT 编译，非常适合涉及高吞吐量的长时间运行过程。GraalVM AOT 编译器以及 SubstrateVM 提供了云原生微服务实现的最小和最快的运行时。结合
    PGO，它生成在云上运行的优化代码。有关详细信息，请参阅 *GraalVM 微服务架构概述* 部分。
- en: Chapter 4 – Graal Just-In-Time Compiler
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 – Graal 即时编译器
- en: 'Graal JIT compilation can be divided into two phases: frontend and backend.'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Graal JIT 编译可以分为两个阶段：前端和后端。
- en: 'The frontend phase is platform-independent compilation, where the code is converted
    to a platform-independent intermediate representation called **High-Level Intermediate
    Representation** (**HIR**), represented via Graal Graphs. This HIR is optimized
    in three tiers: High, Medium, and Low.'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前端阶段是平台无关的编译，其中代码被转换为一种平台无关的中间表示，称为 **高级中间表示**（**HIR**），通过 Graal 图表示。这种 HIR
    在三个级别上进行优化：高、中、低。
- en: The backend phase is more platform-dependent compilation, where a **Low-Level
    Intermediate Representation** (**LIR**) is created and optimized at the machine
    code level. These optimizations are platform dependent.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 后端阶段是更依赖于平台的编译，其中在机器代码级别创建并优化了**低级中间表示法**（**LIR**）。这些优化依赖于平台。
- en: Refer to the *Graal JIT compilation pipeline and Tiered Optimization* section
    for more details.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请参阅**Graal JIT编译器管道和分层优化**部分以获取更多详细信息。
- en: '**Intermediate Representations** (**IRs**) are among the most important data
    structures for compiler design. IRs provide a graph that helps the compiler understand
    the structure of the code, identify opportunities, and perform optimizations.
    Refer to the *Graal Intermediate Representation* section for more details.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**中间表示法**（**IRs**）是编译器设计中最重要的数据结构之一。中间表示法提供了一个图，帮助编译器理解代码的结构，识别机会，并执行优化。请参阅**Graal中间表示法**部分以获取更多详细信息。'
- en: '**Static Single Assignment** (**SSA**) is a form used in IRs where each variable
    is assigned once, and any time there is a change in the value, a new variable
    is used. Every variable is declared before it is used. This helps us to keep track
    of variables and values and helps optimize the code better using graphs. Refer
    to the *Graal intermediate representation* section for more details.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**静态单赋值**（**SSA**）是中间表示法中使用的一种形式，其中每个变量只赋值一次，任何时间值发生变化时，都会使用一个新的变量。每个变量在使用之前都会被声明。这有助于我们跟踪变量和值，并有助于使用图更好地优化代码。请参阅**Graal中间表示法**部分以获取更多详细信息。'
- en: Speculative optimization is a compiler optimization technique of performing
    various code optimizations with speculation. Speculations are assumptions that
    are made based on profiling the code. The optimizations are performed on the code
    based on these assumptions. When these assumptions are proven wrong, at runtime,
    a deoptimization is performed. This helps to optimize focused parts of the code,
    instead of the whole code, which might slow down the runtime. Refer to the *Graal
    compiler optimizations* section for more details.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 投机优化是一种编译器优化技术，通过投机执行各种代码优化。投机是基于对代码进行剖析所做的假设。根据这些假设在代码上执行优化。当这些假设在运行时被证明是错误的时候，会执行去优化。这有助于优化代码的焦点部分，而不是整个代码，这可能会减慢运行时。请参阅**Graal编译器优化**部分以获取更多详细信息。
- en: Escape analysis is an optimization technique that identifies the scope and usage
    of the objects and decides the allocation of the objects either on the heap or
    the stack or the register. This has a significant impact on memory usage and performance.
    Escape analysis is performed at the method level, while partial escape analysis
    performs a deeper analysis of the code to track the objects not just at the method-level
    scope, but also at the control block level. This helps further optimize the code.
    Refer to the *Partial escape analysis* section for more details.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逃逸分析是一种优化技术，它识别对象的作用域和用法，并决定对象在堆、栈或寄存器上的分配。这对内存使用和性能有重大影响。逃逸分析在方法级别执行，而部分逃逸分析则对代码进行更深入的分析，以跟踪不仅限于方法级别作用域的对象，还包括控制块级别的对象。这有助于进一步优化代码。请参阅**部分逃逸分析**部分以获取更多详细信息。
- en: Chapter 5 – Graal Ahead-of-Time Compiler and Native Image
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 - Graal即时编译器和原生图像
- en: GraalVM comes with a tool called the Native Image builder, `native-image`. This
    can be used to compile ahead of time and create a native image. Please refer to
    the *Building native images* section for more details.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GraalVM附带一个名为Native Image builder的工具，即`native-image`。这可以用来编译并创建原生图像。请参阅**构建原生图像**部分以获取更多详细信息。
- en: The Native Image builder, when it compiles the code ahead of time, performs
    points-to analysis to understand all the dependent classes and methods that are
    accessed by the application code. It uses this information to optimize the native
    image, by only building the required code into the image. This provides faster
    execution and smaller images. Please refer to the *Building native images* section
    for more details.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Native Image builder在编译代码之前执行时，会进行指针分析以理解应用程序代码访问的所有依赖类和方法。它使用这些信息来优化原生图像，只将所需的代码构建到图像中。这提供了更快的执行速度和更小的图像。请参阅**构建原生图像**部分以获取更多详细信息。
- en: The Native Image builder performs region analysis to initialize classes ahead
    of time into the heap so that the startup of the native image is faster. Please
    refer to the *Building native images* section for more details.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原生图像构建器执行区域分析，以便在启动之前将类初始化到堆中，从而使原生图像的启动更快。请参阅*构建原生图像*部分以获取更多详细信息。
- en: The Native Image builder packages the **Garbage Collector** (**GC**) code along
    with the native image. There are two types of GC that can be enabled in the native
    image. The Serial GC is a default GC and is available both in the Community and
    Enterprise editions. G1 performs more advanced garbage collection and is only
    available in the Enterprise edition. Please refer to the *Native Image memory
    management configurations* section for more details.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原生图像构建器将**垃圾收集器**（**GC**）代码与原生图像一起打包。原生图像中可以启用两种类型的GC。串行GC是默认的GC，在社区和商业版中均可用。G1执行更高级的垃圾收集，仅在商业版中可用。请参阅*原生图像内存管理配置*部分以获取更多详细信息。
- en: The Native Image builder can only perform static code analysis, unlike the JIT
    compiler, which can perform the runtime profiling of the code and optimize the
    code at runtime. PGO brings the runtime profiling information to a native image
    for further optimization. Please refer to the *Profile-guided optimization (PGO)*
    section for more details.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与JIT编译器不同，原生图像构建器只能执行静态代码分析，JIT编译器可以在运行时对代码进行性能分析并在运行时优化代码。PGO将运行时性能分析信息带到原生图像中，以进行进一步优化。请参阅*性能引导优化（PGO）*部分以获取更多详细信息。
- en: Since native images are built ahead of time, the Native Image builder needs
    to have all the classes loaded at build time. Hence, native images have limitations
    in supporting dynamic features such as reflection and JNI. However, GraalVM's
    Native Image builder provides ways to pass dynamic resource information at build
    time. Please refer to the *Native image configuration* and *Limitations of Graal
    AOT (Native Image)* sections for more details.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于原生图像是在构建之前构建的，原生图像构建器需要在构建时加载所有类。因此，原生图像在支持动态功能（如反射和JNI）方面存在限制。然而，GraalVM的原生图像构建器提供了在构建时传递动态资源信息的方法。请参阅*原生图像配置*和*Graal
    AOT（原生图像）限制*部分以获取更多详细信息。
- en: Chapter 6 – Truffle – An Overview
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 – 松露 – 概述
- en: Specialization is a key optimization that helps identify the specific type of
    a variable. In dynamically typed languages, the type of a variable is not declared
    in the code. The interpreter starts assuming generic types and, based on the runtime
    profiling, will speculate on the type of the variable. Please refer to the *Truffle
    interpreter/compiler pipeline* section for more details.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 专业化是一种关键优化，有助于识别变量的特定类型。在动态类型语言中，变量的类型在代码中未声明。解释器开始假设通用类型，并根据运行时性能分析推测变量的类型。请参阅*Truffle解释器/编译器管道*部分以获取更多详细信息。
- en: When Truffle speculates on a specialized type of a node, the node is rewritten
    dynamically, and the Truffle AST provides a way to rewrite the nodes to optimize
    the AST before submitting it to Graal for further optimized execution. Please
    refer to the *Truffle interpreter/compiler pipeline* section for more details.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Truffle对节点的一个特定类型进行推测时，节点会动态重写，Truffle AST提供了一种方法，在将节点提交给Graal进行进一步优化执行之前，优化AST。请参阅*Truffle解释器/编译器管道*部分以获取更多详细信息。
- en: When Truffle finds that the AST has not been rewritten, it assumes that the
    AST has stabilized. The code is then compiled to machine code for the guest language
    after aggressive constant folding, inlining, and escape analysis. This is called
    Partial Evaluation. Please refer to *Partial Evaluation* in the *Truffle interpreter/compiler
    pipeline* section for more details.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Truffle发现AST没有被重写时，它假定AST已经稳定。然后，在进行了激进的常量折叠、内联和逃逸分析之后，将代码编译为客语言的机器代码。这被称为部分评估。请参阅*Truffle解释器/编译器管道*部分的*部分评估*以获取更多详细信息。
- en: Truffle provides a Domain-Specific Language implemented as annotation generators.
    This helps guest language developers write smaller code and focus on the logic,
    rather than the boilerplate code. Please refer to the *Truffle DSL* section for
    more details.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 松露提供了一种作为注解生成器实现的领域特定语言。这有助于客语言开发者编写更小的代码，并专注于逻辑，而不是样板代码。请参阅*Truffle DSL*部分以获取更多详细信息。
- en: A frame is a Truffle class that provides the interface to read and store data
    in the current namespace. Refer to *Frame management and local variables* in the
    *Truffle interoperability* section for more details.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 框架是Truffle类，它提供了在当前命名空间中读取和存储数据的接口。请参阅*Truffle框架管理和局部变量*部分以获取更多细节。
- en: Truffle defines a Dynamic Object Model to provide a standard interface and framework
    for various guest language implementations to have a standard way of defining
    and exchanging data. Refer to *Dynamic Object Model* in the *Truffle interoperability*
    section for more details.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Truffle定义了一个动态对象模型，为各种客语言实现提供了一个标准接口和框架，以便以标准方式定义和交换数据。请参阅*Truffle互操作性*部分的*动态对象模型*以获取更多细节。
- en: Chapter 7 – GraalVM Polyglot – JavaScript and Node.js
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第七章 – GraalVM多语言 – JavaScript和Node.js
- en: '`Polyglot` is the object that is used in JavaScript to run other language code.
    We use the method `eval()` to run the code. Please refer to the *JavaScript interoperability*
    section for more details on how to use this object to run the code.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Polyglot`是JavaScript中用于运行其他语言代码的对象。我们使用`eval()`方法来运行代码。请参阅*JavaScript互操作性*部分，了解如何使用此对象运行代码的更多细节。'
- en: The `Context` object provides the polyglot context to allow the guest language
    code to run in the host language. A polyglot context represents the global runtime
    state of all installed and permitted languages. Please refer to the *JavaScript
    embedded code in Java* section for more details on how to use this object to run
    the code.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Context`对象提供了多语言上下文，以便在宿主语言中运行客语言代码。多语言上下文表示所有已安装和允许的语言的全局运行时状态。请参阅*Java中嵌入JavaScript代码*部分，了解如何使用此对象运行代码的更多细节。'
- en: The `Context` object helps provide fine-grained access control. The access control
    can be controlled with `ContextBuilder`. Please refer to the *JavaScript embedded
    code in Java* section for more details on how to use this object to run the code.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Context`对象有助于提供细粒度的访问控制。访问控制可以通过`ContextBuilder`进行控制。请参阅*Java中嵌入JavaScript代码*部分，了解如何使用此对象运行代码的更多细节。'
- en: GraalVM provides a Native Image builder option to build native images of applications
    that have multiple languages embedded. A language flag is used to let the Native
    Image builder know which languages are used in the application. This flag can
    also be specified in `native-image` property files. Refer to the *Polyglot native
    images* section in this chapter to understand more. Refer to *Chapter 5* , *Graal
    Ahead-of-Time Compiler and Native Image* for more details about the native image.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GraalVM提供了一个原生图像构建器选项，用于构建具有多种嵌入式语言的程序的原生图像。语言标志用于让原生图像构建器知道应用程序中使用了哪些语言。此标志也可以在`native-image`属性文件中指定。请参阅本章的*多语言原生图像*部分以了解更多。有关原生图像的更多详细信息，请参阅*第五章*，*Graal即时编译器和原生图像*。
- en: The `binding` object acts as an intermediate layer between Java and JavaScript
    to access methods, variables, and objects between the languages. Please refer
    to the *Bindings* section to find out more about the binding object and how it
    is used as an intermediate layer between languages.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`binding`对象在Java和JavaScript之间充当中间层，用于访问两种语言之间的方法、变量和对象。请参阅*绑定*部分，了解更多关于绑定对象及其作为语言之间中间层的用法。'
- en: Chapter 8 – GraalVM Polyglot – Java on Truffle, Python, and R
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章 – GraalVM多语言 – Java在Truffle、Python和R上
- en: Java on Truffle is the new way to run Java programs on top of the Truffle framework.
    Java on Truffle provides an interpreter that is completely built on Java and runs
    in the same memory space as other Truffle languages. This was introduced in GraalVM
    version 21\. For more details refer to the *Understanding Espresso (Java on Truffle)*
    section.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java在Truffle是运行Java程序在Truffle框架之上的新方法。Java在Truffle提供了一个完全基于Java构建的解释器，并在与其他Truffle语言相同的内存空间中运行。这是在GraalVM版本21中引入的。更多详细信息请参阅*理解Espresso（Java在Truffle上）*部分。
- en: Java on Truffle provides an isolationist layer, which helps to run untrusted
    code and code written in an older version of JDK, and provides hot-swap and other
    advanced features. To learn more about the advantages of using Java on Truffle,
    refer to the *Why do we need Java on Java?* section for more details.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Truffle上运行的Java提供了一个隔离层，有助于运行不受信任的代码和用较旧版本的JDK编写的代码，并提供热插拔和其他高级功能。要了解更多关于在Truffle上使用Java的优势，请参阅*为什么我们需要在Java上运行Java？*部分以获取更多详细信息。
- en: The `Polyglot.cast()` method is used in Java on Truffle to typecast the data
    that is exported or returned by dynamic languages. Refer to the *Exploring Espresso
    interoperability with other Truffle languages* section for more details and code
    examples.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Truffle 上，`Polyglot.cast()` 方法用于将动态语言导出或返回的数据进行类型转换。请参阅 *探索 Espresso 与其他 Truffle
    语言之间的互操作性* 部分以获取更多细节和代码示例。
- en: '**SST** stands for **Simple Syntax Tree** and **ST** stands for **Scope Tree**.
    Python generates these intermediate representations before converting them into
    an AST intermediate representation. Python does this using the ANTLR parser and
    the cache, and speeds up parsing. Refer to the *Understanding Graalpython compilation
    and interpreter pipeline* section for more details.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SST** 代表 **Simple Syntax Tree**，而 **ST** 代表 **Scope Tree**。Python 在将它们转换为
    AST 中间表示之前生成这些中间表示。Python 使用 ANTLR 解析器和缓存来完成此操作，并加快了解析速度。请参阅 *理解 Graalpython 编译器和解释器管道*
    部分以获取更多细节。'
- en: A `.pyc` file is a cache Python creates after parsing Python code and generating
    SST and ST representations. This helps speed up parsing the next time the Python
    module is loaded. Python automatically keeps this cache validated. Refer to the
    *Understanding Graalpython compilation and interpreter pipeline* section for more
    details.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.pyc` 文件是 Python 在解析 Python 代码并生成 SST 和 ST 表示之后创建的缓存。这有助于加快下次加载 Python 模块时的解析速度。Python
    会自动保持此缓存的有效性。请参阅 *理解 Graalpython 编译器和解释器管道* 部分以获取更多细节。'
- en: '`polyglot.import_value()` is used to import definitions from other dynamic
    languages, and `polyglot.export_value()` is used to export Python definitions
    to other languages. `polyglot.eval()` is used to execute other language code.
    Refer to the *Exploring interoperability between Python and other dynamic languages*
    section for more detailed explanations and sample code.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`polyglot.import_value()` 用于从其他动态语言导入定义，而 `polyglot.export_value()` 用于将 Python
    定义导出到其他语言。`polyglot.eval()` 用于执行其他语言代码。请参阅 *探索 Python 与其他动态语言之间的互操作性* 部分以获取更详细的解释和示例代码。'
- en: In R, we use the `import()` function to import the definitions from other languages.
    Refer to the *Exploring interoperability of R* section for more details.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 R 中，我们使用 `import()` 函数从其他语言导入定义。请参阅 *探索 R 的互操作性* 部分以获取更多细节。
- en: We use `java.type('classname')` to load a Java class and interoperate with it.
    This function provides the class, and we can use the `new()` function to create
    an instance of the object. Refer to the *Exploring the interoperability of R*
    section for more details and sample code.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `java.type('classname')` 来加载 Java 类并与它交互。此函数提供了类，我们可以使用 `new()` 函数来创建对象的实例。请参阅
    *探索 R 的互操作性* 部分以获取更多细节和示例代码。
- en: Chapter 9 – GraalVM Polyglot – LLVM, Ruby, and WASM
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章 – GraalVM Polyglot – LLVM、Ruby 和 WASM
- en: Sulong is an LLVM interpreter that is written in Java and internally uses the
    Truffle language implementation framework. This enables all language compilers
    that can generate LLVM IR to directly run on GraalVM. Refer to the *Understanding
    LLVM – the (Sulong) Truffle interface* section for more details.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sulong 是一个用 Java 编写的 LLVM 解释器，它内部使用 Truffle 语言实现框架。这使得所有可以生成 LLVM IR 的语言编译器都可以直接在
    GraalVM 上运行。请参阅 *理解 LLVM – (Sulong) Truffle 接口* 部分以获取更多细节。
- en: GraalVM Enterprise Edition provides a managed environment of LLVM. The managed
    mode of execution provides a safe runtime, which, with additional safety, guarantees
    to catch illegal pointer accesses and access arrays outside of the bounds.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GraalVM 企业版提供了一个管理的 LLVM 环境。执行管理的模式提供了一个安全的运行时环境，它通过额外的安全性保证能够捕获非法指针访问和访问超出边界的数组。
- en: The TruffleRuby interpreter interoperates with the LLVM interpreter to implement
    the C extensions. This also extends the possibility to use other LLVM languages,
    such as Rust and Swift, to run as Ruby extensions. Refer to the *Understanding
    the TruffleRuby interpreter/compiler pipeline* section for more details.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TruffleRuby 解释器与 LLVM 解释器交互以实现 C 扩展。这也扩展了使用其他 LLVM 语言（如 Rust 和 Swift）作为 Ruby
    扩展运行的可能性。请参阅 *理解 TruffleRuby 解释器/编译器管道* 部分以获取更多细节。
- en: WASM is binary code that can run on modern web browsers. It has a very small
    footprint and performs much faster than JavaScript. Refer to the *Understanding
    WASM* section for more details.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WASM 是可以在现代网络浏览器上运行的二进制代码。它具有非常小的体积，并且比 JavaScript 执行速度快得多。请参阅 *理解 WASM* 部分以获取更多细节。
- en: Emscripten or `emcc` is the compiler that generates the WASM binary image (`.wasm`)
    files. Refer to the *Installing and running GraalWasm* section for more details.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Emscripten 或 `emcc` 是生成 WASM 二进制图像（`.wasm`）文件的编译器。请参阅“*安装和运行 GraalWasm*”部分以获取更多详细信息。
- en: Chapter 10 – Microservices Architecture with GraalVM
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章 – 使用 GraalVM 的微服务架构
- en: Microservices is an architectural pattern that decomposes a large application
    into smaller, manageable, and self-contained components that expose the functionality
    through a standard interface called services. Please refer to the *Microservices
    architecture overview* section for more details.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务是一种将大型应用程序分解为更小、更易于管理和自包含的组件的架构模式，这些组件通过称为服务的标准接口公开其功能。请参阅“*微服务架构概述*”部分以获取更多详细信息。
- en: The microservices architecture pattern helps us build an application that is
    scalable, manageable, and loosely coupled. This is very important for building
    cloud-native applications in order to get the most out of the cloud infrastructure
    and services. Please refer to the *Microservices architecture overview* section
    for more details.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务架构模式帮助我们构建一个可扩展、可管理和松散耦合的应用程序。这对于构建云原生应用以充分利用云基础设施和服务非常重要。请参阅“*微服务架构概述*”部分以获取更多详细信息。
- en: GraalVM provides a high-performance runtime for JVM and non-JVM languages with
    a small footprint, which is critical for building scalable cloud-native applications.
    Refer to the *Reviewing modern architectural requirements* section in *Chapter
    3*, *Graal VM Architecture,* and the *Understanding how GraalVM helps build a
    microservice architecture* section in this chapter for more details.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GraalVM 提供了一个具有小内存占用的高性能运行时环境，这对于构建可扩展的云原生应用至关重要。请参阅第 3 章“Graal VM 架构”中的“*审查现代架构要求*”部分以及本章的“*理解
    GraalVM 如何帮助构建微服务架构*”部分以获取更多详细信息。
