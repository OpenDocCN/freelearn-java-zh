<html><head></head><body><div class="book" title="Chapter&#xA0;8.&#xA0;AngularJS and Java RESTful Services" id="aid-26I9K1"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch08" class="calibre1"/>Chapter 8. AngularJS and Java RESTful Services</h1></div></div></div><div class="blockquote"><table border="0" cellspacing="0" cellpadding="0" class="blockquote1" summary="Block quote"><tr class="calibre12"><td valign="top" class="calibre13"> </td><td valign="top" class="calibre13"><p class="calibre14"><span><em class="calibre15">"Slow – Anything faster than 50ms is imperceptible to humans and thus can be considered 'instant'.</em></span></p></td><td valign="top" class="calibre13"> </td></tr><tr class="calibre12"><td valign="top" class="calibre13"> </td><td colspan="2" valign="top" class="calibre16">--<span><span><em class="calibre15">Misko Hevery, co-creator of AngularJS</em></span></span></td></tr></table></div><p class="calibre7">For this chapter, we shall move out of the comfort zone of JSF and explore a different mode of web application. Most of you will be familiar with popular social media like Google Mail, Facebook, and Twitter and their web-user interfaces. These web applications have a special user experience and information architecture that gives the illusion of the interaction taking place on one single web page. However, behind the scenes, these applications depend on standard technologies: HTML5, CSS, and client-side JavaScript. They all use AJAX calls to communicate over HTTP to a back-end server. When the server side application sends data to the web client, only a partial part of the page is updated. In contemporary use, many digital sites take advantage of the RESTful service endpoints on the application backend. Some sophisticated enterprise applications may deliver notices to <a id="id843" class="calibre1"/>the working multiple users using <span class="strong"><strong class="calibre8">Server Sent Events</strong></span> (<span class="strong"><strong class="calibre8">SSE</strong></span>), and the more leading-edge ones lean on the newly minted HTML5 WebSocket specification to deliver a full-duplex communication between the client and the server. Incidentally, the full Java EE 7 specification from the Java Community Process supports JAX-RS, SSE, and WebSocket.</p><div class="book" title="Single-page applications"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch08lvl1sec67" class="calibre1"/>Single-page applications</h1></div></div></div><p class="calibre7">The design <a id="id844" class="calibre1"/>philosophy behind building an application on a single page such that it resembles a desktop application is in marked contrast to the JavaServer Faces' original design of navigation links between pages. JSF 1.0 was created in the early noughties, long before the rediscovery of the <code class="email">XMLHttpRequest</code> JavaScript object and Google Maps in 2005, so that historical note should not be<a id="id845" class="calibre1"/> a surprise (<a class="calibre1" href="http://en.wikipedia.org/wiki/JavaServer_Faces">http://en.wikipedia.org/wiki/JavaServer_Faces</a>). It is entirely possible to write JSF as a single-page application, but I would not recommend the effort of forcing a square peg into a round hole! JSF lends itself to applications that are extremely stateful in nature and design, where the customer journey is based on page-to-page navigation. In the previous chapters, we have already covered a great deal about stateful web applications with JSF, flow scopes, conversations, and view-scoped beans. If you are not thorough with those concepts, then I strongly recommend you revise the material again. We shall press on now with the alternate design mode.</p><p class="calibre7">Let's list the beneficial <a id="id846" class="calibre1"/>characteristics of single-page applications:</p><div class="book"><ul class="itemizedlist"><li class="listitem">SPAs often feature a website or web application that fits on a single page.</li><li class="listitem">They rely on the modern digital JavaScript techniques including AJAX, HTML5, and CSS.</li><li class="listitem">Instead of loading whole pages during navigation, this type of application manipulates the <span class="strong"><strong class="calibre8">Document Object Model</strong></span> (<span class="strong"><strong class="calibre8">DOM</strong></span>) in order to provide page updates.</li><li class="listitem">These<a id="id847" class="calibre1"/> applications typically employ an HTML-templating engine to render the content locally on the client side. There is a separation of concerns between the presentation logic on the client and the business logic on the server side.</li><li class="listitem">SPAs communicate dynamically with a web server, usually with RESTful services, with JSON as a popular payload type.</li></ul></div><p class="calibre7">There are some drawbacks for single-page applications that the content strategists, technical lead developers, and, obviously, the stakeholder businessperson should be aware of:</p><div class="book"><ul class="itemizedlist"><li class="listitem">It may be hard to apply Search Engine Optimization to an SPA.</li><li class="listitem">Using the back button in the browser may cause lost data entries; SPAs do not play well with web browser history.</li><li class="listitem">SPA requires a higher degree of application development knowledge to deal with reactive programming and concepts. Notably, engineers should be aware of factors concerning trade-off round scalability, resilience, event-driven handling, and notifications, and be responsive.</li></ul></div><p class="calibre7">Finally, allow me to offer you a word of advice. Digital interface developers in the industry have JavaScript, HTML5, and CSS skills. In this chapter, you will learn to acknowledge that the JavaScript programming capability is equally as important as the Java server-side requirement. In other words, working with AngularJS and similar client-side frameworks tends to be a full-stack engagement.</p></div></div>
<div class="book" title="The caseworker application" id="aid-27GQ61"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch08lvl1sec68" class="calibre1"/>The caseworker application</h1></div></div></div><p class="calibre7">For this <a id="id848" class="calibre1"/>chapter, we are going to look at one particular type of single-page application for international governments called a caseworker system. The business users of the caseworkers will sit on desks, and for the majority of their day, process applicants through stages of applying for a product.</p><p class="calibre7">The following is a screenshot of the application:</p><div class="mediaobject"><img src="../Images/image00418.jpeg" alt="The caseworker application" class="calibre10"/><div class="caption"><p class="calibre24">Screenshot of the caseworker application, xen national force</p></div></div><p class="calibre11"> </p><p class="calibre7">The application is called <span class="strong"><strong class="calibre8">xen-national-force</strong></span>, and it is designed to process passports through a miniature<a id="id849" class="calibre1"/> workflow. It is far from serving the requirements of a true business application. For example, there is no user input security implemented in order to keep things as simple as possible. It works very well for only one caseworker and there is a very obvious design flaw from the user-experience side. However, the xen-national-force application demonstrates how to build a system having master-detail records with CRUD operations using AngularJS, and it features a basic Finite State Machine implementation.</p><p class="calibre7">We shall now <a id="id850" class="calibre1"/>move on to learning about the popular AngularJS framework.</p></div>
<div class="book" title="AngularJS"><div class="book" id="aid-28FAO2"><div class="book"><div class="book"><h1 class="title"><a id="ch08lvl1sec69" class="calibre1"/>AngularJS</h1></div></div></div><p class="calibre7">In recent years, one<a id="id851" class="calibre1"/> particular JavaScript client-side framework has emerged as a strong contender for building single page applications for enterprise business. It is called<a id="id852" class="calibre1"/> AngularJS (<a class="calibre1" href="http://angularjs.org">http://angularjs.org</a>) and is supported and licensed by Google. The software repository can be found on GitHub at <a class="calibre1" href="https://github.com/angular/angular.js">https://github.com/angular/angular.js</a>. I should say that it is not the only framework to provide DOM two-way binding, Model-View Controller, templating, modules, services, and factories.</p><p class="calibre7">In this book, we are only concerned with AngularJS, but you should be aware of two major competitors in the JavaScript client-side world, namely <code class="email">Backbone.js</code> and <code class="email">Ember.js</code>. Due to the scope of the task, we hit the ground with the AngularJS framework, and in this chapter there is beginner's introduction to the framework. We will cover the AngularJS version 1.3.15 running against Java EE 7.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip34" class="calibre1"/>Tip</h3><p class="calibre7">For a thorough discussion on AngularJS and client-side JavaScript from the ground up, we recommend reading another Packt Publishing book, <span class="strong"><em class="calibre9">Mastering Single Application Development with AngularJS</em></span> by <span class="strong"><em class="calibre9">Kozlowski and Darwin</em></span>.</p></div><p class="calibre7">Programming with<a id="id853" class="calibre1"/> AngularJS means that you very rarely need to delve into the low-level W3C HTML DOM API. In fact, operations that took tens-of-lines of JavaScript custom binding code to sanity check, now become one-liners.</p><p class="calibre7">Let's suppose we have a simple HTML form that implements the classic <code class="email">Hello, World</code>! snippet. We want the user to type his/her name in a text field and have that name in a greeting in the real world. Our HTML content might appear like this:</p><div class="informalexample"><pre class="programlisting">&lt;form id="helloForm"&gt;
  &lt;input class="greeting-name" type="text" &gt;&lt;/input&gt;
  &lt;div class="greeting-name"&gt;message &lt;/div&gt;
&lt;/form&gt;</pre></div><p class="calibre7">How would we wire up the text input with the message area in the <code class="email">div</code> element with jQuery? One plausible approach would be to write event handlers and callback functions like the following fragment of a JavaScript module:</p><div class="informalexample"><pre class="programlisting">$('#helloForm input.greeting-name').on('value', function() {
  $('#helloForm div.greeting-name').text('Hello ' + this.val() + '!');
});</pre></div><p class="calibre7">The preceding <a id="id854" class="calibre1"/>code snippet, without the boilerplate of the JavaScript object modules and dependency injection, will do the trick. When the user types into the text field identified by the CSS class selector <code class="email">input.greeting-name</code>, then jQuery invokes the callback function, which updates the inner HTML in the <code class="email">div</code> element layer, identified with the CSS class <code class="email">div.greeting.name</code>. We could extend this code and write a generic solution with parameters, especially if we have more cases like this in our application, but sooner rather than later, programming at this low-level introduces complexities and bugs.</p><p class="calibre7">The designers of AngularJS realized that there was an opportunity for improvement. The same example can be re-written using AngularJS, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;script src="http://ajax.googleapis.com/ajax/lib/angularjs/1.3.15/angular.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body ng-app ng-init="greeting-name = 'Mr. Anderson'"&gt;
  &lt;form&gt;
    &lt;input ng-model="customer-name" type="text" /&gt;
    &lt;div class="greeting-name"&gt;Hello {{customer-name}}!&lt;/div&gt;
  &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">The preceding fragment is entirely in HTML. It includes the AngularJS framework from a remote server, <span class="strong"><strong class="calibre8">Content Delivery Network</strong></span> (<span class="strong"><strong class="calibre8">CDN</strong></span>). The body HTML element is annotated with a<a id="id855" class="calibre1"/> non-standard attribute, <code class="email">ng-app</code>, in order to declare that this DOM node is part of the overall template. The other attribute, <code class="email">ng-init</code>, declares a data model before the template is rendered on the client side. AngularJS needs to know where to start templating or modifying the DOM dynamically; therefore, every page starts with the <code class="email">ng-app</code> attribute. Usually, the <code class="email">ng-app</code> attribute is applied to the HTML <code class="email">body</code> element. An AngularJS template would be useless without access to a data model, and this is the purpose of the <code class="email">ng-init</code> attribute. It sets up a scoped variable called <code class="email">greeting-name</code> and assigns it the String literal value, <code class="email">Mr. Anderson</code>.</p><p class="calibre7">Note the additional attribute type <code class="email">ng-model</code> and the special, double curly bracket syntax: <code class="email">{{customer-name}}</code>. The attribute is a special extension provided by the AngularJS framework that identifies the data model inline, and the curly brackets represent a special HTML templating <a id="id856" class="calibre1"/>syntax called directive. Here we applied the <code class="email">ng-model</code> attribute to the input field element. When the page is loaded, the input text field is shown with the text <code class="email">Mr Anderson</code>. The code also allows the user to enter text in the input field and simultaneously updates the message area. There is no programming required for this simple case; in fact it is declarative. So what is the secret sauce? The following code shows one form of two-way binding. Let's extend it to demonstrate the complete two-way binding:</p><div class="informalexample"><pre class="programlisting">&lt;form&gt;
  &lt;input ng-model="customer-name" type="text" /&gt;
  &lt;div class="greeting-name"&gt;Hello {{customer-name}}!&lt;/div&gt;
  &lt;p&gt;
   &lt;button class="btn-large" ng-click="user-model = 'Karen'"&gt;
   Karen &lt;/button&gt; &lt;/p&gt;
  &lt;p&gt;
   &lt;button class="btn-large" ng-click="user-model = 'Albert'"&gt;
   Albert &lt;/button&gt; &lt;/p&gt;
&lt;/form&gt;</pre></div><p class="calibre7">We introduced the HTML <code class="email">button</code> elements with a new attribute, <code class="email">ng-click</code>. The value of the attribute is an AngularJS JavaScript expression. Each button updates the data model with a new name. Effectively, they reset the name in the input field and the message area. How cool is that? There is no jQuery programming in there at all. AngularJS has many special custom attributes such as <code class="email">ng-repeat</code>, <code class="email">ng-switch</code>, and <code class="email">ng-option</code>, which we will encounter later in this chapter.</p><p class="calibre7">You might be wondering about these bindings and templates being very clever; so how does it work on the client side?</p><div class="book" title="How does AngularJS work?"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch08lvl2sec92" class="calibre1"/>How does AngularJS work?</h2></div></div></div><p class="calibre7">AngularJS is <a id="id857" class="calibre1"/>loaded in a web browser as part of the HTML page content. The strongest part of the framework is that it encourages the separation of concerns. The presentation view should be mixed deliberately with business logic and the data model. There are a couple of reasons for this. When the Angular JS framework is loaded a page is triggered, the framework marches up and down the DOM and looks for certain non-standard attributes called directives. It parses and processes this markup with the compiler. Effectively, AngularJS transforms the statically loaded DOM and produces a rendered view. The framework takes these directives and creates associations, binding, and extra behavior.</p><p class="calibre7">The <code class="email">ng-app</code> attribute is linked to a directive that initializes the application. The <code class="email">ng-init</code> is linked to a directive that allows the programmer to set up a data model. It can be used to assign values to the variables. The <code class="email">ng-model</code> is associated with directive access or stores the value that is associated with an HTML Input element. AngularJS allows the developers to write custom directives. You may want to write one in the future to get access to the DOM.</p><p class="calibre7">AngularJS <a id="id858" class="calibre1"/>works on the idea of nested scopes within a template view. A scope is an execution context for expressions. Scopes can be organized in an hierarchical fashion such that they mimic the DOM model.</p><div class="mediaobject"><img src="../Images/image00419.jpeg" alt="How does AngularJS work?" class="calibre10"/><div class="caption"><p class="calibre24">How AngularJS works in principle</p></div></div><p class="calibre11"> </p><p class="calibre7">AngularJS relies on the JavaScript modules that define controllers and other logic. Modules can be dependent on other modules; however, unlike RequireJS, modules that are a part of disparate JavaScript files are not automatically loaded in the application. A scope is the glue that binds the presentation and the data model. A scope is the place in the AngularJS where <a id="id859" class="calibre1"/>watchers and listeners are defined. Most of the time, the framework will automatically handle expression handling and data binding, and handle the notifications between JavaScript modules and DOM element components. After the compilation phase, AngularJS moves on to the linking phase and associates expressions to the module controller methods and other resources.</p><p class="calibre7">Let's summarize these steps:</p><div class="book"><ol class="orderedlist"><li class="listitem">AngularJS framework bootstraps itself. In particular, it searches the DOM for an HTML element with the <code class="email">ng-app</code> attribute. This is the trigger point for the framework.</li><li class="listitem">Once the <code class="email">ng-app</code> element is found, AngularJS creates a dependency injector.</li><li class="listitem">It then compiles the static DOM into rendering an intermediate view, collecting directives as it goes.</li><li class="listitem">AngularJS then starts to link and compose the directives with their associated scope. This is an algorithmic and hierarchical operation. The framework creates an initial scope called the root scope before executing the linking phase.</li><li class="listitem">Finally, AngularJS invokes an apply call using the root scope, and during this stage, the view is rendered.</li></ol><div class="calibre25"/></div><p class="calibre7">Let's look at the view of the caseworker. In the book's source code, you will find the Gradle project called <span class="strong"><strong class="calibre8">xen-force-angularjs</strong></span>. It follows the Maven convention for Java EE projects. Our<a id="id860" class="calibre1"/> discussion will be split into two sections. We will look at the frontend code that consists of HTML5, JavaScript, and some CSS. Afterwards, we will delve into the Java server-side backend. Let's have a look at the following figure:</p><div class="mediaobject"><img src="../Images/image00420.jpeg" alt="How does AngularJS work?" class="calibre10"/><div class="caption"><p class="calibre24">Th relationship of directives to business logic in AngularJS</p></div></div><p class="calibre11"> </p></div></div>
<div class="book" title="Caseworker overview"><div class="book" id="aid-29DRA2"><div class="book"><div class="book"><h1 class="title"><a id="ch08lvl1sec70" class="calibre1"/>Caseworker overview</h1></div></div></div><p class="calibre7">The caseworker project shows a master-detail application. Our worker starts the application and <a id="id861" class="calibre1"/>sees a list of case records, which contains the names and the passport details for each applicant. This is the master record. Each case record may have a zero or more task records attached. Those are the details records of the master. Each master record also contains a state property that shows where each applicant is in the process. Our user is permitted to access all of the case records and move the current state from start to finish.</p><div class="book" title="Caseworker main view"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch08lvl2sec93" class="calibre1"/>Caseworker main view</h2></div></div></div><p class="calibre7">There is only <a id="id862" class="calibre1"/>one HTML file in the caseworker example, and it serves as the template in the <code class="email">src/main/webapp/index.xhtml</code> file. Remember, this is meant to be a single-page application!</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html ng-app="app"&gt;
  &lt;head&gt;
    ...
    &lt;link href="styles/bootstrap.css" rel="stylesheet"&gt;
    &lt;link href="styles/main.css" rel="stylesheet"&gt;
  &lt;/head&gt;

  &lt;body ng-controller="CaseRecordController"&gt;
    ...
    &lt;div id="mainContent"&gt;
      ...
      &lt;div class="case-record-view" &gt;
        ...
        &lt;div class="actionBar"
          ng-controller="NewCaseRecordModalController" &gt;
          &lt;button class="btn btn-primary" ng-click="openCreateCaseRecordDialog()" &gt;Add New Case Record&lt;/button&gt;
          &lt;div ng-show="selected"&gt;Selection from a modal: {{ selected }}&lt;/div&gt;
        &lt;/div&gt;

        &lt;h2 class="case-record-headline"&gt;Case Records&lt;/h2&gt;
        &lt;table class="table table-bordered" &gt;
          &lt;tr&gt;
            &lt;th&gt;Id&lt;/th&gt;
            &lt;th&gt;Last Name&lt;/th&gt;
            &lt;th&gt;First Name&lt;/th&gt;
            &lt;th&gt;Sex&lt;/th&gt;
            &lt;th&gt;Country&lt;/th&gt;
            &lt;th&gt;Passport No&lt;/th&gt;
            &lt;th&gt;D.o.B&lt;/th&gt;
            &lt;th&gt;Expiration Date&lt;/th&gt;
            &lt;th&gt;Status&lt;/th&gt;
          &lt;/tr&gt;
          ...
        &lt;/table&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">The HTML tag<a id="id863" class="calibre1"/> element is attributed with an AngularJS directive, <code class="email">ng-app</code>, which specifies the name of the scoped value that serves as the application. We have the usual <code class="email">head</code> and <code class="email">body</code> elements. We include the CSS files Bootstrap (<code class="email">bootstrap.css</code>) and the application's style file, <code class="email">main.css</code>. There is not much difference until we arrive at the <code class="email">Body</code> tag, which is declared with the <code class="email">ng-controller</code> attribute. The <code class="email">ng-controller</code> directive attaches a controller to the view. The controller is the JavaScript object that is part of the MVC pattern. So the entire <code class="email">body</code> tag element in the DOM is bound to the JavaScript object called <code class="email">CaseRecordController</code>. We will see the code for it later, but first, let's dive just a little bit deeper.</p><p class="calibre7">As you examine the code further, you will notice another controller directive on the <code class="email">div</code> element with the CSS selector named <code class="email">action-bar</code>. This element is associated with a different controller called <code class="email">NewCaseRecordModalController</code>. Every time an <code class="email">ng-controller</code> directive is attributed, AngularJS creates a brand new scope. So scopes can be nested with one another. This is the key concept in the AngularJS framework. The scope exists on the element that is associated with and enclosing other nested scopes, should they exist.</p><p class="calibre7">The main view renders a table of the case records. The preceding code renders the first and last names of the applicant, their sex, their date of birth, their ISO country code, their passport number, and their passport's expiration date.</p><p class="calibre7">The following is the next part of the content that renders the master table row:</p><div class="informalexample"><pre class="programlisting">    &lt;tr ng-repeat-start="caseRecord in caseRecords"&gt;
      &lt;td&gt;
        &lt;div ng-controller="NewCaseRecordModalController" style="display: inline;"&gt;
          &lt;a class="btn" href="#" ng-click="showOrHideTasks($parent.caseRecord)"&gt;
          &lt;i class="glyphicon" ng-class="getIconClass($parent.caseRecord)" &gt;&lt;/i&gt;
          &lt;/a&gt;
        &lt;/div&gt;
      &lt;/td&gt;
      &lt;td&gt;{{caseRecord.lastName}}&lt;/td&gt;
      &lt;td&gt;{{caseRecord.firstName}}&lt;/td&gt;
      &lt;td&gt;{{caseRecord.sex}}&lt;/td&gt;
      &lt;td&gt;{{caseRecord.country}}&lt;/td&gt;
      &lt;td&gt;{{caseRecord.passportNo}}&lt;/td&gt;
      &lt;td&gt;{{caseRecord.dateOfBirth}}&lt;/td&gt;
      &lt;td&gt;{{caseRecord.expirationDate}}&lt;/td&gt;
      &lt;td&gt;{{caseRecord.currentState}}&lt;/td&gt;
    &lt;/tr&gt;</pre></div><p class="calibre7">There are several parts to this code content. The <code class="email">ng-repeat-start</code> is a special directive that allows the <a id="id864" class="calibre1"/>content to be iterated using an expression. The expression is a form selection query that AngularJS evaluates dynamically. So, the <code class="email">&lt;"caseRecord in caseRecords"&gt;</code> expression means an overall iteration of the objects in the scope named <code class="email">caseRecords</code>, and assigning each element as an object called <code class="email">caseRecord</code>. We use the AngularJS binding directive expressions to render the information for each case record in the appropriate table cell element. We do this for the cell <code class="email">{{caseRecord.lastName}}</code>, then rinse and repeat.</p><p class="calibre7">The first data cell is special, because it renders an embedded <code class="email">div</code> element. It illustrates how to associate a Boolean value and provides an expanding and collapsing association to the case record. We must create a scope on the <code class="email">div</code> and associate the appropriate controller <code class="email">NewCaseRecordModalController</code> with the <code class="email">ng-controller</code> attribute. We take advantage of the <code class="email">ng-click</code> directive to invoke a method on the controller called <code class="email">showOrHideTasks()</code>. Notice that we pass the parent of the scope, which contains the current <code class="email">CaseRecord</code> as the table is being rendered. There is another directive, <code class="email">ng-class</code>, that associates the icon element with the appropriate glyph icon from Bootstrap by setting the CSS selector. This code opens and closes a secondary row in the table view, which renders a task view. It also updates the glyph icon correctly based on whether the task view is open or closed.</p><p class="calibre7">The third part of this table view content now follows:</p><div class="informalexample"><pre class="programlisting">&lt;tr ng-repeat-end  ng-if="caseRecord.showTasks" &gt;
  &lt;td colspan="9"&gt;
    &lt;div class="case-record-task-view"&gt;
      &lt;div ng-controller="NewCaseRecordModalController"&gt;
        &lt;button class="btn btn-info"
        ng-click="openEditCaseRecordDialog($parent.caseRecord)" &gt;Edit Case Record Details&lt;/button&gt;
        &lt;button class="btn btn-info"
        ng-click="changeStateCaseRecordDialog($parent.caseRecord)" &gt;Change State&lt;/button&gt;
      &lt;/div&gt;
      &lt;br /&gt;

      &lt;div ng-controller="NewTaskModalController"&gt;
        &lt;p&gt;
          &lt;button class="btn btn-primary"
            ng-click="openNewTaskDialog(caseRecord.id)"&gt;Add New Task&lt;/button&gt;
        &lt;/p&gt;
      &lt;/div&gt;

      &lt;table class="case-record-task-table"&gt;
        &lt;tr&gt;
          &lt;td&gt; Item &lt;/td&gt;
          &lt;td&gt; Description &lt;/td&gt;
          &lt;td&gt; Completed &lt;/td&gt;
          &lt;td&gt; Due Date &lt;/td&gt;
          &lt;td&gt; Control &lt;/td&gt;
        &lt;/tr&gt;

        &lt;tr ng-repeat="task in caseRecord.tasks"&gt;
          ...
        &lt;/tr&gt;&lt;!-- ng-repeat-end ## tasks in caseRecords.tasks --&gt;
      &lt;/table&gt;
    &lt;/div&gt;
  &lt;/td&gt;
&lt;/tr&gt;&lt;!-- ng-repeat-end ## caseRecord in caseRecords --&gt;</pre></div><p class="calibre7">The secondary<a id="id865" class="calibre1"/> row in the master table has an <code class="email">ng-repeat-end</code> directive, which informs AngularJS which DOM element finishes the loop iteration for each <code class="email">CaseRecord</code> element. There is actually another directive called <code class="email">ng-repeat</code> that combines <code class="email">ng-repeat-start</code> and <code class="email">ng-repeat-end</code> for a single DOM element. That directive is usually for rendering the simple rows in a table.</p><p class="calibre7">The <code class="email">ng-if</code> directive conditionally adds or removes content from the DOM. We use this <code class="email">ng-if</code> to show and hide the task view area for each case record element. AngularJS provides other similar directives called <code class="email">ng-show</code> and <code class="email">ng-hide</code>, but those do not dynamically add or remove content from the DOM.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip35" class="calibre1"/>Tip</h3><p class="calibre7">Why would we choose <code class="email">ng-if</code> over <code class="email">ng-show</code>? Suppose you have hundreds of case record elements in your database, would we want to render all of those cases and their task history on the web frontend?</p></div><p class="calibre7">We have a <code class="email">div-layer</code> element dedicated for showing the tasks associated with a case record. Look at the CSS selector, <code class="email">case-record-task-view</code>. We add content to display each <code class="email">task</code> element as a table. There is an example for using the <code class="email">ng-repeat</code> that has an expression task, in <code class="email">caseRecord.tasks</code>.</p><p class="calibre7">There are two other inner <code class="email">div</code> layers. The first element is bound to the logic to edit the current case record and references the controller called <code class="email">NewCaseRecordModalController</code>. The second element allows the user to create a new task, and it references a new controller called <code class="email">NewTaskModalController</code>. We will see the JavaScript code for these controllers later on.</p><p class="calibre7">The following screenshot illustrates the expansion and contraction for show tasks:</p><div class="mediaobject"><img src="../Images/image00421.jpeg" alt="Caseworker main view" class="calibre10"/><div class="caption"><p class="calibre24">This screenshot depicts the expansion and contraction of the secondary row element with <code class="email">ng-if</code>.</p></div></div><p class="calibre11"> </p><p class="calibre7">To complete the<a id="id866" class="calibre1"/> content for the table view, we write table data rows to show the properties of the <code class="email">task</code> element:</p><div class="informalexample"><pre class="programlisting">&lt;tr ng-repeat="task in caseRecord.tasks"&gt;
  &lt;td&gt; {{task.id}} &lt;/td&gt;
  &lt;td&gt;
    &lt;span class="done-{{task.completed}}"&gt; {{task.name}} &lt;/span&gt;
  &lt;/td&gt;
  &lt;td&gt;
    &lt;label class="checkbox"&gt;
      &lt;input type="checkbox" ng-model="task.completed" ng-change="updateProjectTaskCompleted(task)"&gt;
      Done
    &lt;/label&gt;
  &lt;/td&gt;
  &lt;td&gt;
    {{task.targetDate}}
  &lt;/td&gt;
  &lt;td&gt;
    &lt;div ng-controller="NewTaskModalController"&gt;
      &lt;a class="btn" href="#"ng-click="openEditTaskDialog($parent.task)" &gt;
        &lt;i class="glyphicon glyphicon-edit"&gt;&lt;/i&gt;&lt;/a&gt;
      &lt;a class="btn" href="#"ng-click="openDeleteTaskDialog($parent.task)" &gt;
        &lt;i class="glyphicon glyphicon-trash"&gt;&lt;/i&gt;&lt;/a&gt;
    &lt;/div&gt;
  &lt;/td&gt;
&lt;/tr&gt;&lt;!-- ng-repeat-end ## tasks in caseRecords.tasks --&gt;</pre></div><p class="calibre7">In the fourth part of the view, we take full advantage of the AngularJS two-way binding to render an HTML <code class="email">checkbox</code> element and associate it with the Boolean property, <code class="email">caseRecord.completed</code>. Using the CSS selector, we dynamically change the text of the task name with the <a id="id867" class="calibre1"/>class selector expression, <code class="email">class="done-{{task.completed}}"</code>. When the user changes the checkbox, the following CSS is chosen:</p><div class="informalexample"><pre class="programlisting">.done-true {
  text-decoration: line-through; color: #52101d;
}</pre></div><p class="calibre7">When the task is completed, the text is struck through! We added an <code class="email">ng-change</code> directive to the checkbox element, which AngularJS associates with a change event. AngularJS invokes the method, <code class="email">updateProjectTaskCompleted()</code> on the controller <code class="email">NewTaskModalController</code>. This method invokes a <code class="email">WebSocket</code> call. We will explain the code behind it soon! Notice that the method call passes the current <code class="email">task</code> element, because we are still in the rendering scope.</p><p class="calibre7">In order to complete the task view, we have a <code class="email">div</code> layer associated with the controller <code class="email">NewTaskModalController</code> with glyph icon buttons to edit and remove a task. As you can see, we need to pass in <code class="email">$parent.task</code> in order to reference the element loop variable.</p><p class="calibre7">It's time to look at the project organization and then the individual JavaScript modules, controllers, and factories.</p></div></div>
<div class="book" title="Project organization" id="aid-2ACBS1"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch08lvl1sec71" class="calibre1"/>Project organization</h1></div></div></div><p class="calibre7">The project is <a id="id868" class="calibre1"/>organized into a Java EE web application. We put all our JavaScript code into the folders that follow the convention for AngularJS, because it is likely that we are professionally working in a full-stack environment and sharing the code base with mixed skills. The AngularJS controllers are placed under <code class="email">app/controllers</code>, while the factories and services are placed under <code class="email">app/service</code>, as shown in the following structure:</p><p class="calibre7">
<code class="email">src/main/webapp/app/controllers</code>
</p><p class="calibre7">
<code class="email">src/main/webapp/app/controllers/main.js</code>
</p><p class="calibre7">
<code class="email">src/main/webapp/app/controllers/newcaserecord-modal.js</code>
</p><p class="calibre7">
<code class="email">src/main/webapp/app/controllers/newtask-modal.js</code>
</p><p class="calibre7">
<code class="email">src/main/webapp/app/services</code>
</p><p class="calibre7">
<code class="email">src/main/webapp/app/services/iso-countries.js</code>
</p><p class="calibre7">
<code class="email">src/main/webapp/app/services/shared-services.js</code>
</p><p class="calibre7">Next, we put the third-party JavaScript libraries into their designated area:</p><p class="calibre7">
<code class="email">src/main/webapp/javascripts</code>
</p><p class="calibre7">
<code class="email">src/main/webapp/javascripts/angular.js</code>
</p><p class="calibre7">
<code class="email">src/main/webapp/javascripts/bootstrap.js</code>
</p><p class="calibre7">
<code class="email">src/main/webapp/javascripts/jquery-2.1.3.js</code>
</p><p class="calibre7">
<code class="email">src/main/webapp/javascripts/ui-bootstrap-0.12.1.js</code>
</p><p class="calibre7">
<code class="email">src/main/webapp/javascripts/ui-bootstrap-tpl-0.12.1.js</code>
</p><p class="calibre7">Note that our <a id="id869" class="calibre1"/>caseworker application also depends on Bootstrap, jQuery, and the extension library, Bootstrap UI for AngularJS. We include all these libraries explicitly in the last part of the content for the main view <code class="email">index.html</code>, which is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;html ng-app="app"&gt;  ...
  &lt;body&gt; ...
    &lt;script src="javascripts/jquery-2.1.3.js"&gt;&lt;/script&gt;
    &lt;script src="javascripts/angular.js"&gt;&lt;/script&gt;
    &lt;script src="javascripts/bootstrap.js"&gt;&lt;/script&gt;
    &lt;script src="javascripts/ui-bootstrap-tpls-0.12.1.js"&gt;&lt;/script&gt;
    &lt;script src="app/controllers/main.js"&gt;&lt;/script&gt;
    &lt;script src="app/controllers/newcaserecord-modal.js"&gt;&lt;/script&gt;
    &lt;script src="app/controllers/newtask-modal.js"&gt;&lt;/script&gt;
    &lt;script src="app/services/shared-service.js"&gt;&lt;/script&gt;
    &lt;script src="app/services/iso-countries.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">As I said earlier, we've kept the code base simpler for the purpose of demonstration, but we could have used RequireJS to handle the dependency loading.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip36" class="calibre1"/>Tip</h3><p class="calibre7">If you don't explicitly load jQuery before AngularJS, then it will load its own smaller version of jQuery <a id="id870" class="calibre1"/>called <span class="strong"><strong class="calibre8">jq-lite</strong></span>. So if your application depends on the full version of the jQuery library, please ensure it is loaded before AngularJS.</p></div><p class="calibre7">The final step is to put the CSS in their own special area:</p><p class="calibre7">
<code class="email">src/main/webapp/styles</code>
</p><p class="calibre7">
<code class="email">src/main/webapp/styles/bootstrap.css</code>
</p><p class="calibre7">
<code class="email">src/main/webapp/styles/bootstrap-theme.css</code>
</p><p class="calibre7">
<code class="email">src/main/webapp/styles/main.css</code>
</p><p class="calibre7">The preceding files are loaded at the top of the main view, inside the usual <code class="email">head</code> HTML element.</p></div>
<div class="book" title="Application main controller"><div class="book" id="aid-2BASE2"><div class="book"><div class="book"><h1 class="title"><a id="ch08lvl1sec72" class="calibre1"/>Application main controller</h1></div></div></div><p class="calibre7">The first module in our AngularJS application declares the name of the application. The following is the declaration in the file: <code class="email">src/main/webapp/app/controllers/main.js</code>:</p><div class="informalexample"><pre class="programlisting">var myApp = angular.module('app', ['ui.bootstrap', 'newcaserecord','newtask', 'sharedService', 'isoCountries']);</pre></div><p class="calibre7">The framework <a id="id871" class="calibre1"/>exports a function object called <code class="email">angular</code>, and it has a method called <code class="email">module</code> that defines a module. The first argument is the name of the module and the second argument is an array of the dependent module names. The <code class="email">module()</code> method returns an AngularJS module object to the caller. From there, we declare the initial controller.</p><p class="calibre7">The module <code class="email">ui.bootstrap</code> contains AngularJS and Bootstrap integrations. The module <code class="email">newcaserecord</code> is part of the caseworker application and defines a controller, which inserts and amends the master records. The module <code class="email">newtask</code> defines a controller, which inserts, amends, and removes the details records. The <code class="email">sharedService</code> defines a factory provider that performs utility functions for the application, and, finally, <code class="email">isoCountries</code> defines another provider that holds a list of the ISO passport countries.</p><p class="calibre7">AngularJS framework has a fluent API for defining modules, controllers, and providers; therefore, we could write an almost declarative JavaScript like the following code extract shows:</p><div class="informalexample"><pre class="programlisting">angular.module('myApp', [ 'depend1', 'depend2'])
  .controller( 'controller1', function( depend1, depend2 ) {
      /* ... */
  })
  .controller( 'controller2', function( depend1 ) {
      /* ... */   
  })
  .filter('greet', function() {
   return function(name) {
      return 'Hello, ' + name + '!';
    };
  }) 
  .service( 'our-factory', function( ... ) {
      /* ... */   
  })
  .directive( 'my-directive', function( ... ) {
      /* ... */   
});</pre></div><p class="calibre7">The preceding coding style is a matter of taste and the disadvantage is that all your modules are lumped together. A lot of professional developers prefer to assign the actual Angular module objects to global module variables.</p><p class="calibre7">The body tag element in the view defines a controller:</p><div class="informalexample"><pre class="programlisting">&lt;body ng-controller="CaseRecordController"&gt;</pre></div><p class="calibre7">The following<a id="id872" class="calibre1"/> extract shows the controller <code class="email">CaseRecordController</code> that binds the user interface to a client-side data model:</p><div class="informalexample"><pre class="programlisting">myApp.controller('CaseRecordController',  function ($scope, $http, $log, UpdateTaskStatusFactory, sharedService, isoCountries ) {
  var self = this;
  $scope.caseRecords = [{sex: "F", firstName: "Angela", lastName: "Devonshire", dateOfBirth: "1982-04-15", expirationDate: "2018-11-21", country: "Australia", passportNo: "123456789012", currentState: "Start"},];

  $scope.isoCountries = isoCountries;

  $scope.getCaseRecords = function () {
    $http.get('rest/caseworker/list').success(function(data) {
      $scope.caseRecords = data;
    });
  }

  $scope.$on('handleBroadcastMessage', function() {
    var message = sharedService.getBroadcastMessage();
    if ( message !== "showTasksCaseRecord")  {
      $scope.getCaseRecords();
    }
  })

  // Retrieve the initial list of case records
  $scope.getCaseRecords();

  $scope.connect = function() {
    UpdateTaskStatusFactory.connect();
  }

  $scope.send = function( msg ) {
    UpdateTaskStatusFactory.send(msg);
  }

  $scope.updateProjectTaskCompleted = function( task ) {
    var message = { 'caseRecordId': task.caseRecordId, 'taskId': task.id, 'completed': task.completed }
    $scope.connect()
    var jsonMessage = JSON.stringify(message)
    $scope.send(jsonMessage)
  }
});</pre></div><p class="calibre7">The controller method in the AngularJS object accepts the first parameter as the name. The second argument is the function object and as conventional wisdom, we pass in an anonymous JavaScript function with arguments.</p><div class="informalexample"><pre class="programlisting">function ($scope, $http, $log, UpdateTaskStatusFactory, sharedService, isoCountries ) { /* ... */ }</pre></div><p class="calibre7">The parameters <a id="id873" class="calibre1"/>are all object modules that AngularJS injects to the controller. AngularJS defines standard modules beginning with the dollar character (<code class="email">$</code>). The module <code class="email">$scope</code> is a special parameter that denotes the current scope. The module <code class="email">$http</code> represents a core AngularJS service with methods that communicate with a remote HTTP server. The module <code class="email">$log</code> is another core service for logging to the console. The other parameters <code class="email">UpdateTaskStatusFactory</code>, <code class="email">sharedService</code>, and <code class="email">isoCountries</code> are factories and services that our application provides. AngularJS, like many JavaScript modern digital frameworks, encourages modular programming and avoids polluting the global scope as much as possible.</p><p class="calibre7">So what does this controller do? First, for demonstration purposes, the controller initializes a dummy JSON record, <code class="email">$scope.caseRecord</code>, just in case the server is not available by the time the page view loads. Next, we define a property for the list of records, <code class="email">$scope.caseRecords</code>. Yes, adding custom properties to the AngularJS <code class="email">$scope</code> is the way to communicate from the data model to the user interface.</p><p class="calibre7">We define properties for the controller, <code class="email">$scope.isoCountries</code>.</p><p class="calibre7">We define our first function, <code class="email">getCaseRecords()</code>, which is as follows:</p><div class="informalexample"><pre class="programlisting">$scope.getCaseRecords = function () {
  $http.get('rest/caseworker/list').success(function(data) {
    $scope.caseRecords = data;
  });
}</pre></div><p class="calibre7">This function makes a RESTful GET request to the remote server from the same host that serves the page view. The URL would be something like this: <code class="email">http://localhost:8080/xen-national-force/rest/caseworker/list</code>.</p><p class="calibre7">We leverage the fluent API to perform an action once the server returns a JSON result. The anonymous function overwrites the <code class="email">$scope.caseRecords</code> property with the latest data.</p><p class="calibre7">Incidentally, as we construct the function object <code class="email">CaseRecordController</code>, we invoke the method <code class="email">getCaseRecords()</code> in order to kick start the application.</p><p class="calibre7">In AngularJS, we can pass information from one controller to another using a factory service that our application creates or by making an HTTP request to the server. It is also possible to listen to the events that AngularJS publishes on a broadcast channel.</p><p class="calibre7">The following <a id="id874" class="calibre1"/>code in <code class="email">CaseRecordController</code> demonstrates how to update the user interface on all messages but one:</p><div class="informalexample"><pre class="programlisting">  $scope.$on('handleBroadcastMessage', function() {
    var message = sharedService.getBroadcastMessage();
    if ( message !== "showTasksCaseRecord")  {
      $scope.getCaseRecords();
    }
  })</pre></div><p class="calibre7">Here, we register an event handler on the AngularJS scope in order to retrieve a notification from our <code class="email">SharedService</code> provider. The <code class="email">$on()</code> method registers a listener on a specific event type. The first parameter is the message type, and the second parameter is the callback. Inside the function callback, we make an HTTP request to retrieve the entire set of case records from the server side if the message, and therefore the custom event, is not <code class="email">showTasksCaseRecord</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip37" class="calibre1"/>Tip</h3><p class="calibre7">Inside the handler callback, we read the entire the dataset, which could be thousands of case records in a real enterprise application. Therefore, we can improve the performance of the REST call-and-response code. We should, however, resist the urge to descend down the path of too early optimization. You should prefer to just get the user story working.</p></div><p class="calibre7">The other methods in the controller, <code class="email">connect()</code> and <code class="email">send()</code>, establish a WebSocket channel to the server and send a JSON message down to the server respectively. We will examine the <code class="email">UpdateTaskStatusFactory</code> module, and the final method, <code class="email">updateProjectTaskCompleted()</code>, in a later section.</p><p class="calibre7">If you've never developed, professionally, any JavaScript before, then this chapter might appear very daunting initially. However, please persevere as it is really only about having enough patience to succeed. In this regard, I have prepared a simplistic diagram of the AngularJS scopes as they appear in our caseworker application.</p><div class="mediaobject"><img src="../Images/image00422.jpeg" alt="Application main controller" class="calibre10"/><div class="caption"><p class="calibre24">AngularJS scopes in the caseworker application</p></div></div><p class="calibre11"> </p><p class="calibre7">This preceding<a id="id875" class="calibre1"/> diagram charts the journey of the progress and helps us understand where we are going. It also establishes the concept of how AngularJS binds scopes in an hierarchical fashion resembling the DOM itself. Behind the scenes, AngularJS creates internal scopes to handle the repeatable DOM elements that render the HTML <code class="email">table</code> element, which is the list of the case records. Developers cannot access these internal data except by programming with expressions, and we should treat them as opaque objects.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip38" class="calibre1"/>Tip</h3><p class="calibre7">At the time <a id="id876" class="calibre1"/>of writing, there is a Google Chrome plugin called <a id="id877" class="calibre1"/>Batarang (<a class="calibre1" href="https://chrome.google.com/webstore/detail/angularjs-batarang-stable/">https://chrome.google.com/webstore/detail/angularjs-batarang-stable/</a>), which I would have strongly recommended to examine the AngularJS scope inside the browser. Sadly, it seems that the tool is no longer maintained. It is still worth checking if someone has adopted it.</p></div></div>
<div class="book" title="New case record controller" id="aid-2C9D01"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch08lvl1sec73" class="calibre1"/>New case record controller</h1></div></div></div><p class="calibre7">We have placed the code to create and edit the case records in a separate file called <code class="email">newcaserecord-modal.js</code>, which contains the user-defined AngularJS module <code class="email">newcaserecord</code>. This module has dependencies on other modules, some of them mentioned before. The <code class="email">ui.bootstrap.modal</code> is a special module from the AngularJS UI Bootstrap<a id="id878" class="calibre1"/> third-party framework. The module defines the Bootstrap components written by the AngularJS team. In particular, it has a helpful modal dialog extension, which we use throughout the caseworker application.</p><p class="calibre7">The following is the shortened code for the <code class="email">newcaserecord</code> module and the <code class="email">NewCaseRecordModalController</code>:</p><div class="informalexample"><pre class="programlisting">var newcaserecord = angular.module('newcaserecord', ['ui.bootstrap.modal', 'sharedService','isoCountries'])

newcaserecord.controller('NewCaseRecordModalController', function($scope, $modal, $http, $log, sharedService, isoCountries ) {
  $scope.caseRecord = {
    sex: "F", firstName: "", lastName: "", country: "", passportNo: "", dateOfBirth: "", expirationDate: "", country: "", currentState: "", showTasks: false};
  $scope.returnedData = null;
  $scope.isoCountries = isoCountries;

  $scope.openCreateCaseRecordDialog = function () {
    var modalInstance = $modal.open({
      templateUrl: 'newCaseRecordContent.html', controller: newCaseRecordModalInstanceController, isoCountries: isoCountries, resolve: {
            caseRecord: function () {
              return $scope.caseRecord;
            }
      }
    });

    modalInstance.result.then(function (data) {
      $scope.selected = data;
      $http.post('rest/caseworker/item', $scope.caseRecord).success(function(data) {
        $scope.returnedData = data;
        sharedService.setBroadcastMessage("newCaseRecord");
      });

    }, function () {
      $log.info('Modal dismissed at: ' + new Date());
    });
  };
  // . . .
);</pre></div><p class="calibre7">The controller<a id="id879" class="calibre1"/> function object accepts injected parameters such as <code class="email">$http</code>, <code class="email">$log</code>, and <code class="email">sharedService</code>. We also inject the <code class="email">$modal</code> instance, which allows us to open modal dialogs in the controller.</p><p class="calibre7">Since each controller has its own scope injected into it, we need to provide elements of the data model in order to be accessible to the view. So we create an empty case record in the scope as <code class="email">$scope.caseRecord</code>. We also set up return data and the ISO countries list.</p><p class="calibre7">The function <code class="email">$scope.openCreateCaseRecordDialog()</code> generates a modal dialog, so the user is allowed to enter a master case record.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip39" class="calibre1"/>Tip</h3><p class="calibre7">Allowing a user to create arbitrary application passport records would be probably forbidden and restricted to any employee except to the administrators and managers. Our demonstration application has no concept of roles and permissions at all. Developers should be careful to avoid introducing zero-day exploits into their digital applications.</p></div><p class="calibre7">The UI Bootstrap extension accepts several parameters. The first parameter is a reference to the HTML template directive. The second parameter refers to another controller called <code class="email">newCaseRecordModalInstanceController</code>, which is responsible for handling the interaction with the dialog. The third argument is a resolver and it permits the library code to find the reference data in the user's modal inside the enclosing scope:</p><div class="informalexample"><pre class="programlisting">var modalInstance = $modal.open({
  templateUrl: 'newCaseRecordContent.html',
    controller: newCaseRecordModalInstanceController,
      resolve: {
        caseRecord: function () {
          return $scope.caseRecord;
        }
      }
});</pre></div><p class="calibre7">The next part of the controller, <code class="email">NewCaseRecordModalController</code> handles the callback after the modal dialog completes successfully, because the user entered the data and pressed the confirm button. We register two function objects as parameters on the object called <code class="email">then</code>.</p><div class="informalexample"><pre class="programlisting">    modalInstance.result.then(function (data) {...},
       function () { /* modal dismissed */ });</pre></div><p class="calibre7">The first function is the callback handler that contains the code to make a REST POST request to<a id="id880" class="calibre1"/> the server with the case record data. The second function is reserved for when the dialog is dismissed. You will notice that AngularJS employs fluent interfaces. The code should be fairly understandable even if you don't happen to know everything about JavaScript and the framework.</p><p class="calibre7">So let's look at the code for the modal dialog instance, namely the object <code class="email">newCaseRecordModalInstanceController</code>:</p><div class="informalexample"><pre class="programlisting">var newCaseRecordModalInstanceController = function ($scope, $modalInstance, caseRecord ) {
  caseRecord.showTasks = true; // Convenience for the user
  $scope.caseRecord = caseRecord;

  $scope.ok = function () {
    $modalInstance.close(true);
  };

  $scope.cancel = function () {
    $modalInstance.dismiss('cancel');
  };
};</pre></div><p class="calibre7">If you notice, this variable is not quite an encapsulated module in JavaScript; rather, the <code class="email">newCaseRecordModalInstanceController</code> function is declared in the global scope. I suppose there are always exceptions to the rule. The UI Bootstrap code invokes this controller function through the <code class="email">$modalInstance.open()</code> call. The framework supplies the three arguments, the scope <code class="email">$scope</code>, the modal instance <code class="email">$modalInstance</code>, and the case record <code class="email">caseRecord</code> to the function. We assign the case record to the supplied scope in order to write-back the data from the modal dialog. There, the function object implements two methods, <code class="email">ok()</code> and <code class="email">cancel()</code>, that handle the confirmation and cancellation of the dialog respectively.</p><p class="calibre7">We only need to write the HTML directive for the dialog.</p><div class="book" title="The case record modal view template"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch08lvl2sec94" class="calibre1"/>The case record modal view template</h2></div></div></div><p class="calibre7">As we know, all the content for the site is inside a single page application. HTML directives are also found in the view, <code class="email">index.html</code>. How do you write a directive into the page content without it appearing in the view? Is the secret sauce something to do with CSS?</p><p class="calibre7">Although<a id="id881" class="calibre1"/> styling is a good idea, it is not the correct answer. The AngularJS designers take advantage of the formal definition for the HTML Script tag, which is the element that embeds or references the executable script.</p><p class="calibre7">The following is the HTML directive for inserting a new case record into the application:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/ng-template" id="newCaseRecordContent.html"&gt;
  &lt;div class="modal-header"&gt;
    &lt;h3&gt;New Case Record &lt;/h3&gt;
  &lt;/div&gt;
  &lt;div class="modal-body"&gt;
    &lt;form name="newCaseRecordForm" class="css-form" novalidate&gt;
      Sex:&lt;br /&gt;
      &lt;select ng-model="caseRecord.sex" required&gt;
        &lt;option value="F" ng-option="selected caseRecord.sex === 'F'"&gt;Female&lt;/option&gt;
        &lt;option value="M" ng-option="selected caseRecord.sex === 'M'"&gt;Male&lt;/option&gt;
      &lt;/select&gt;
      &lt;br/&gt;
      First Name:&lt;br /&gt;
      &lt;input type="text" ng-model="caseRecord.firstName" required /&gt;&lt;br /&gt;
      Last Name:&lt;br /&gt;
      &lt;input type="text" ng-model="caseRecord.lastName" required /&gt;&lt;br /&gt;
      Date of Birth:&lt;br /&gt;
      &lt;input type="text" ng-model="caseRecord.dateOfBirth" datepicker-popup="yyyy-MM-dd" required /&gt;&lt;br /&gt;
      Country:&lt;br /&gt;
      &lt;select ng-model="caseRecord.country" required ng-options="item.code as item.country for item in isoCountries.countryToCodeArrayMap"&gt;
      &lt;/select&gt;
      &lt;br /&gt;
      Passport Number:&lt;br /&gt;
      &lt;input type="text" ng-model="caseRecord.passportNo" required /&gt;&lt;br /&gt;
      Expiration Date:&lt;br /&gt;
      &lt;input type="text" ng-model="caseRecord.expirationDate" datepicker-popup="yyyy-MM-dd" required /&gt;&lt;br /&gt;
    &lt;/form&gt;
  &lt;/div&gt;
  &lt;div class="modal-footer"&gt;
    &lt;button class="btn btn-primary" ng-click="ok()" ng-disabled="newCaseRecordForm.$invalid" &gt;OK&lt;/button&gt;
    &lt;button class="btn btn-warning" ng-click="cancel()"&gt;Cancel&lt;/button&gt;
  &lt;/div&gt;
&lt;/script&gt;</pre></div><p class="calibre7">The preceding HTML directive defines a UI Bootstrap modal dialog, because the HTML <code class="email">script</code> tag is denoted with the type attribute of <code class="email">text/ng-template</code>. All AngularJS directives require an identifier. This directive contains a header, footer, and main as we can see<a id="id882" class="calibre1"/> from the CSS. The main <code class="email">div</code> layer is an HTML form.</p><p class="calibre7">Each input field in the form is bound to the data model in the instance of <code class="email">newCaseRecordModalInstanceController</code>. The case record was assigned to the scope as soon as the UI Bootstrap invoked the function object. Hence, the <code class="email">ng-model</code> data model, <code class="email">$scope.caseRecord.firstName</code> is available to the HTML text input element reserved for first names.</p><p class="calibre7">AngularJS has an elegant additional markup for validating the form input elements. You can see the additional required attribute on almost all of the inputs. Unfortunately, as this book cannot delve into deeper details of validation checking, I want to draw your attention to two subtle validation checks.</p><p class="calibre7">The data input exploits the UI Bootstrap date picker component to allow the case worker to easily enter dates:</p><div class="informalexample"><pre class="programlisting">&lt;input type="text" ng-model="caseRecord.dateOfBirth" datepicker-popup="yyyy-MM-dd" required /&gt;</pre></div><p class="calibre7">The format of the date is defined by the attribute, <code class="email">datepicker-popup</code>.</p><p class="calibre7">Lastly, we display a drop-down list of the ISO passport country names in an HTML <code class="email">select</code> element. The code for this part is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;select ng-model="caseRecord.country" required
  ng-options="item.code as item.country for item in
    isoCountries.countryToCodeArrayMap"&gt;
&lt;/select&gt;</pre></div><p class="calibre7">The <code class="email">isoCountries</code> is a service instance, which we will see later. Since that module was injected into the <code class="email">NewCaseRecordModalController</code> module and the scope of the latter happens to enclose the modal instance scope, AngularJS allow us to access the service. The <code class="email">isoCountries</code> instance contains a list of the passport countries in a key and value dictionary. The code allows us to associate the ISO code <code class="email">AUS</code> with the country name Australia. The <code class="email">ng-option</code> attribute accepts an expression, which resembles an SQL query. We declaratively inform AngularJS how to derive the display name (<code class="email">item.country</code>) and the input form value (<code class="email">item.code</code>) for each HTML <code class="email">option</code> element.</p><p class="calibre7">The<a id="id883" class="calibre1"/> following is a screenshot of the create case record modal dialog with the date picker:</p><div class="mediaobject"><img src="../Images/image00423.jpeg" alt="The case record modal view template" class="calibre10"/><div class="caption"><p class="calibre24">A screenshot of the create case record modal dialog with date picker in full effect</p></div></div><p class="calibre11"> </p><p class="calibre7">Let's <a id="id884" class="calibre1"/>move onto the task record controller that is similar to the case record controller.</p></div></div>
<div class="book" title="New task record controller" id="aid-2D7TI1"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch08lvl1sec74" class="calibre1"/>New task record controller</h1></div></div></div><p class="calibre7">As a<a id="id885" class="calibre1"/> caseworker uses the system, he or she is able to expand and collapse the task record associated with the case record. The user can create, edit, and amend tasks, and can also change the state of the case.</p><p class="calibre7">The AngularJS module <code class="email">newtask</code> is defined thus:</p><div class="informalexample"><pre class="programlisting">var newtask = angular.module('newtask', ['ui.bootstrap.modal', 'sharedService'])
newtask.config(function($httpProvider) {
  $httpProvider.defaults.headers["delete"] = {
    'Content-Type': 'application/json;charset=utf-8'
  };
})</pre></div><p class="calibre7">We add a configuration change to AngularJS around the HTTP remoting. There is a subtle bug with the HTTP DELETE request. The JAX-RS reference implementation, Jersey, which is present in the GlassFish and Payara application server, raises an HTTP error with a response code 415: <code class="email">Unsupported Media Type</code>. This forces AngularJS to send the MIME type, as JSON on the DELETE requests solves the issue.</p><p class="calibre7">Since the code for the task controller is so similar, only the create part of CRUD will be revealed in this book. Refer to the source for the other methods. The following is the source code for <code class="email">NewTaskModalController</code>:</p><div class="informalexample"><pre class="programlisting">newtask.controller('NewTaskModalController', function($scope, $modal, $http, $log, sharedService ) {
  $scope.selected = false;
  $scope.task = {
      id: 0, name: '', targetDate: null, completed: false, caseRecordId: 0
  };
  $scope.returnedData = null;
  $scope.openNewTaskDialog = function(caseRecordId) {
    var modalInstance = $modal.open({
      templateUrl: 'newTaskContent.html',
      controller: newTaskModalInstanceController,
      resolve: {
        task: function () {
          return $scope.task;
        }
      }
    });

    modalInstance.result.then(function (data) {
      $scope.selected = data;
      $http.post('rest/caseworker/item/'+caseRecordId+'/task', $scope.task).success(function(data) {
        $scope.returnedData = data;
        sharedService.setBroadcastMessage("newTask");
        // Reset Task in this scope for better UX affordance.
        $scope.task = {
          id: 0, name: '', targetDate: null, completed: false, caseRecordId: 0
        };
      });
    }, function () {
        $log.info('Modal dismissed at: ' + new Date());
    });
  };

  $scope.openEditTaskDialog = function(taskItem) {
    // ...
  };

  $scope.openDeleteTaskDialog = function(taskItem) {
    // ...
  };
});</pre></div><p class="calibre7">In this <a id="id886" class="calibre1"/>controller, instead of <code class="email">$scope.caseRecord</code>, we have an empty, default <code class="email">$scope.task</code> object. Every <code class="email">Task</code> object has a reference to the parent through the property, <code class="email">caseRecordId</code>.</p><p class="calibre7">The function, <code class="email">openNewTaskDialog()</code> opens a UI Bootstrap modal dialog that allows the user to enter a brand task. The method wires up the modal dialog with the AngularJS scope of the current <code class="email">Task</code> object. The big difference is the REST URL endpoint, which is in the form of <code class="email">rest/caseworker/item/'+caseRecordId+'/task</code>.</p><p class="calibre7">We use the UI Bootstrap <code class="email">$modal</code> object and create a modal dialog instance as before, except that we now pass different arguments. The arguments are the HTML directive ID, which is <code class="email">newTaskContent.html</code>; the controller is called <code class="email">newTaskModalInstanceController</code>,and the resolver function. AngularJS invokes the resolver function, which is defined as an anonymous function, in order to reference the enclosing <code class="email">Task</code> object.</p><p class="calibre7">In the callback function for the <code class="email">modalInstance</code> object, we conveniently reset the <code class="email">Task</code> object so that the user is not surprised by stale form data when the dialog is raised again. We set the broadcast message in <code class="email">sharedService</code>.</p><p class="calibre7">The code <a id="id887" class="calibre1"/>to handle the modal instance in the task dialog is almost the same:</p><div class="informalexample"><pre class="programlisting">var newTaskModalInstanceController = function ($scope, $modalInstance, task) {
  $scope.task = task;

  $scope.ok = function () {
      $modalInstance.close(true);
  };

  $scope.cancel = function () {
    $modalInstance.dismiss('cancel');
  };
};</pre></div><p class="calibre7">The function <code class="email">newTaskModalInstanceController</code> accepts three arguments: the <code class="email">$scope</code> that binds the modal instance dialog, <code class="email">$modalInstance</code> itself, and the <code class="email">Task</code> object. The last argument, the <code class="email">Task</code> object, is resolved and we set it as a property on the scope in order to easily render the view in the template.</p><div class="book" title="The task modal view template"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch08lvl2sec95" class="calibre1"/>The task modal view template</h2></div></div></div><p class="calibre7">The AngularJS directive <code class="email">newTaskContent.html</code> renders the view for the modal dialog that lets the <a id="id888" class="calibre1"/>user enter a new task. There are only four properties, so this view is shorter than the case record.</p><p class="calibre7">The definition for this view is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/ng-template" id="newTaskContent.html"&gt;
  &lt;div class="modal-header"&gt;
    &lt;h3&gt;New Task&lt;/h3&gt;
  &lt;/div&gt;
  &lt;div class="modal-body"&gt;
    &lt;form name="newTaskForm" class="css-form" novalidate&gt;
      Task Name:&lt;br /&gt;
      &lt;textarea ng-model="task.name" rows="3" required /&gt;&lt;br /&gt;
      Target Date:  &lt;br /&gt;
      &lt;input type="text" datepicker-popup="yyyy-MM-dd" ng-model="task.targetDate" required /&gt;&lt;br /&gt;
      Task Completed: &lt;br /&gt;
      Done &lt;input type="checkbox" ng-model="task.completed" /&gt;
        &lt;br /&gt;
    &lt;/form&gt;
  &lt;/div&gt;
  &lt;div class="modal-footer"&gt;
    &lt;button class="btn btn-primary" ng-click="ok()" ng-disabled="newTaskForm.$invalid" &gt;OK&lt;/button&gt;
    &lt;button class="btn btn-warning" ng-click="cancel()"&gt;Cancel&lt;/button&gt;
  &lt;/div&gt;
&lt;/script&gt;</pre></div><p class="calibre7">This view<a id="id889" class="calibre1"/> also follows the UI Bootstrap CSS style for modal dialogs. We demonstrate an HTML <code class="email">text area</code> element associated with a data model, which is the <code class="email">Task</code> object. Each form field has an <code class="email">ng-model</code> association. For the target date, we reuse the date picker and we illustrate how to use the HTML <code class="email">checkbox</code> element.</p><p class="calibre7">The code for editing and deleting task records looks roughly the same. However, for editing, we don't reset the task record after the user confirms the modal dialog, and for deletion, we show only a read-only view of the task record; the modal dialog is simply a confirmation.</p><p class="calibre7">Let's see how we handle the change of state.</p></div></div>
<div class="book" title="State change"><div class="book" id="aid-2E6E42"><div class="book"><div class="book"><h1 class="title"><a id="ch08lvl1sec75" class="calibre1"/>State change</h1></div></div></div><p class="calibre7">A case<a id="id890" class="calibre1"/> record<a id="id891" class="calibre1"/> exists in the following states:</p><div class="informalexample"><table border="1" class="blockquote1"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre14">State</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre14">Description</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">Start</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Every new applicant in the system begins at this initial state</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">End</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">At the end of the process, the applicant's case finishes in this end state</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">Reviewing</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">The case worker is reviewing the applicant's record</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">Decision</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">The case has been reviewed and the business is taking a decision</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">Accepted</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">The case has been accepted and the applicant is being notified</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">Rejected</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">The case has been rejected and the applicant is being rejected</p>
</td></tr></tbody></table></div><p class="calibre7">All these business requirements are captured in Finite State Machine.</p><div class="book" title="Controller code"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch08lvl2sec9600" class="calibre1"/>Controller code</h2></div></div></div><p class="calibre7">By now the <a id="id892" class="calibre1"/>code should be familiar to you. The controller method <code class="email">changeStateCaseRecordDialog()</code> in <code class="email">NewTaskModalController</code> is as follows:</p><div class="informalexample"><pre class="programlisting">$scope.changeStateCaseRecordDialog = function (caseRecordItem) {
    /* Copy  */
  $scope.caseRecord = {
    id: caseRecordItem.id,
    firstName: caseRecordItem.firstName,
    lastName: caseRecordItem.lastName,
    dateOfBirth: caseRecordItem.dateOfBirth,
    country: caseRecordItem.country,
    passportNo: caseRecordItem.passportNo,
    expirationDate: caseRecordItem.expirationDate,
    currentState: caseRecordItem.currentState,
    nextStates: caseRecordItem.nextStates,
    showTask: caseRecordItem.showTasks
  };

  $scope.caseRecord.nextStates.push( caseRecordItem.currentState );
  $scope.saveCurrentState = caseRecordItem.currentState;

  var modalInstance = $modal.open({
    templateUrl: 'changeStateCaseRecordContent.html', controller: moveStateRecordModalInstanceController, resolve: {
          caseRecord: function () {
            return $scope.caseRecord;
          }
      }
  });

  modalInstance.result.then(function (data) {
      $scope.selected = data;
      if ( $scope.saveCurrentState !== $scope.caseRecord.currentState ) {
          $http.put('rest/caseworker/state/'+$scope.caseRecord.id, $scope.caseRecord).success(function(data) {
            $scope.returnedData = data;
            sharedService.setBroadcastMessage("editCaseRecord");
          });
      }
  }, function () { $log.info('Modal dismissed."); } );
};</pre></div><p class="calibre7">Since we are<a id="id893" class="calibre1"/> just editing an existing case record, we copy the properties of <code class="email">CaseRecord</code> from the enclosing scope into the controller scope. Remember, the outside scope is the main module.</p><p class="calibre7">Every JSON case record sent by the server (as we will see later) has a property called <code class="email">nextStates</code>, which is a list of the next possible states that the user can move a record to. To take an example, the <code class="email">Start</code> state has only one possible next state, which is called <code class="email">Reviewing</code>.</p><p class="calibre7">Each case<a id="id894" class="calibre1"/> record object has a <code class="email">currentState</code> property. We push the current state on to the list of subsequent states stored in the current scope. This array <code class="email">$scope.nextStates</code> allows the dialog HTML directive to render a drop-down menu in the view.</p><p class="calibre7">You can see that this function, <code class="email">changeStateCaseRecordDialog()</code>, opens a UI Bootstrap modal dialog.</p></div><div class="book" title="The template view code"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch08lvl2sec96" class="calibre1"/>The template view code</h2></div></div></div><p class="calibre7">So let's <a id="id895" class="calibre1"/>inspect the HTML directive for the state change:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/ng-template" id="changeStateCaseRecordContent.html"&gt;
  &lt;div class="modal-header"&gt;
    &lt;h3&gt;Change State of Case Record&lt;/h3&gt;
  &lt;/div&gt;
  &lt;div class="modal-body"&gt;
    &lt;p&gt;
      &lt;table class="table table-bordered"&gt;
        &lt;tr&gt;
          &lt;th&gt; Field &lt;/th&gt; &lt;th&gt; Value &lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;

          &lt;td&gt; Case Record Id&lt;/td&gt; &lt;td&gt; {{caseRecord.id }}&lt;/td&gt;
        &lt;/tr&gt;
          ...
      &lt;/table&gt;
    &lt;/p&gt;
      &lt;form name="moveStateCaseRecordForm" class="css-form" novalidate&gt;
      Next States:&lt;br /&gt;
      &lt;select ng-model="caseRecord.currentState" ng-options="state for state in caseRecord.nextStates"&gt;
      &lt;/select&gt;
      &lt;/form&gt;
  &lt;/div&gt;
  &lt;div class="modal-footer"&gt;
    &lt;button class="btn btn-primary" ng-click="ok()" ng-disabled="moveStateCaseRecordForm.$invalid" &gt;OK&lt;/button&gt;
    &lt;button class="btn btn-warning" ng-click="cancel()"&gt;Cancel&lt;/button&gt;
  &lt;/div&gt;
&lt;/script&gt;</pre></div><p class="calibre7">The preceding<a id="id896" class="calibre1"/> directive, identified as <code class="email">changeStateCaseRecordContent.html</code>, is essentially a read-only view of the entire case record. The only modifiable part is the HTML <code class="email">select</code> element that displays the next possible states for the case record. In order to generate the HTML <code class="email">option</code> element, there is a different form of expression for the attribute <code class="email">ng-options</code>, which is declared as <code class="email">state for state in caseRecord.nextStates</code>. This expression implies that the option name and the value are the same for the array String, which is as follows:</p><div class="mediaobject"><img src="../Images/image00424.jpeg" alt="The template view code" class="calibre10"/><div class="caption"><p class="calibre24">Change state for a case record</p></div></div><p class="calibre11"> </p><p class="calibre7">The modal instance code is essentially the same. The corresponding function associated with the dialog is called <code class="email">moveStateRecordModalInstanceController()</code>.</p><div class="informalexample"><pre class="programlisting">var moveStateRecordModalInstanceController = function ($scope, $modalInstance, caseRecord) {
  $scope.caseRecord = caseRecord;
  $scope.ok = function () { $modalInstance.close(true); };
  $scope.cancel = function () { $modalInstance.dismiss('cancel'); };
};</pre></div><p class="calibre7">Before we<a id="id897" class="calibre1"/> finish off this long example of AngularJS and the client side, we shall cover a couple of more functions. These functions are part of the module that defines <code class="email">NewCaseRecordModalController</code>.</p></div><div class="book" title="Toggling the task display state"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch08lvl2sec97" class="calibre1"/>Toggling the task display state</h2></div></div></div><p class="calibre7">The first<a id="id898" class="calibre1"/> function <code class="email">showOrHideTasks()</code>, toggles the display property <code class="email">showTasks</code> in the case record. It also invokes an HTTP PUT request with the case record JSON data to the server. The code is as follows:</p><div class="informalexample"><pre class="programlisting">$scope.showOrHideTasks = function(caseRecord) {
  caseRecord.showTasks = !caseRecord.showTasks;
  $http.put('rest/caseworker/showtasks/'+caseRecord.id, caseRecord).success(function(data) {
    sharedService.setBroadcastMessage("showTasksCaseRecord");
  });
}</pre></div><p class="calibre7">The second function <code class="email">getIconClass()</code> is a bit of cheat mode. It returns the Bootstrap CSS glyph selector depending on the display state. AngularJS does have a conditional expression for <code class="email">ng-class</code>; however, at the time of writing, the author could not get it to work for the array of case record elements. Therefore, this function exists in the code base as a work around.</p><div class="informalexample"><pre class="programlisting">$scope.getIconClass = function(caseRecord) {
  if ( caseRecord.showTasks)
    return "glyphicon-minus"
  else
    return "glyphicon-plus"
}</pre></div><p class="calibre7">If you are interested, the correct code for the client-side that should work is the following:</p><div class="informalexample"><pre class="programlisting">&lt;i class="glyphicon" ng-class="{true: 'glyphicon-minus', false: 'glyphicon-plus'}[caseRecord.showTasks]"&gt;</pre></div><p class="calibre7">We will jump over to the server-side now.</p></div></div>
<div class="book" title="Server-side Java"><div class="book" id="aid-2F4UM2"><div class="book"><div class="book"><h1 class="title"><a id="ch08lvl1sec76" class="calibre1"/>Server-side Java</h1></div></div></div><p class="calibre7">Our<a id="id899" class="calibre1"/> Java EE application for the caseworker<a id="id900" class="calibre1"/> system is built around RESTful services, Java WebSocket, JSON-P, and Java Persistence.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip40" class="calibre1"/>Tip</h3><p class="calibre7">This section of the book relies on a prior understanding of Java EE development from the elementary level. I recommend that you read the sister book <span class="strong"><em class="calibre9">Java EE 7 Development Handbook</em></span>, especially if you find some of these topics difficult to follow.</p></div><div class="book" title="Entity objects"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch08lvl2sec98" class="calibre1"/>Entity objects</h2></div></div></div><p class="calibre7">The server-side would be nothing without a couple of domain objects. It should not be surprising<a id="id901" class="calibre1"/> that these are called <code class="email">CaseRecord</code> and <code class="email">Task</code>.</p><p class="calibre7">The following is the extracted <code class="email">CaseRecord</code> entity object with full annotations:</p><div class="informalexample"><pre class="programlisting">@NamedQueries({
  @NamedQuery(name="CaseRecord.findAllCases",
    query = "select c from CaseRecord c order by c.lastName, c.firstName"),
    /* ... */
})
@Entity
@Table(name = "CASE_RECORD")
public class CaseRecord {
  @Id @GeneratedValue(strategy = GenerationType.AUTO)
  private Integer id;
  @NotEmpty @Size(max=64) private String lastName;
  @NotEmpty @Size(max=64) private String firstName;
  @NotEmpty @Size(max=1) private String sex;
  @NotEmpty @Size(max=16) private String passportNo;
  @NotEmpty @Size(max=32) private String country;
  @Past @NotNull @Temporal(TemporalType.DATE) private Date dateOfBirth;
  @Future @NotNull @Temporal(TemporalType.DATE) private Date expirationDate;
  @NotEmpty private String currentState;
  private boolean showTasks;
  @OneToMany(cascade = CascadeType.ALL, mappedBy = "caseRecord", fetch = FetchType.EAGER)
  private List&lt;Task&gt; tasks = new ArrayList&lt;&gt;();

  // Required by JPA
  public CaseRecord() {}
  /*  ... */
}</pre></div><p class="calibre7">For these entities, we<a id="id902" class="calibre1"/> leverage the popular Hibernate Validator annotations to ensure that the information is correctly saved into the database. The detailed entity <code class="email">Task</code> is as follows:</p><div class="informalexample"><pre class="programlisting">@Entity
public class Task {
  @Id @GeneratedValue(strategy = GenerationType.AUTO)
  @Column(name="TASK_ID") private Integer id;
  @NotEmpty @Size(max=256) private String name;
  @Temporal(TemporalType.DATE)
  @Column(name="TARGET_NAME") @Future
  private Date targetDate;
  private boolean completed;
  @ManyToOne(cascade = CascadeType.ALL)
  @JoinColumn(name="CASE_RECORD_ID")
  private CaseRecord caseRecord;

  public Task() { /* Required by JPA */ }
  /*  ... */
}</pre></div><p class="calibre7">The entities map very closely to the JavaScript objects that we have seen on the client side. In practice, a business application in a different domain might choose an alternative design such as a facade, aggregation, or projection of the data model.</p><p class="calibre7">Of course, these entities have a persistence layer in order to retrieve and store information into the database. In the source code, there is a <code class="email">CaseRecordTaskService</code> that has the responsibility to persist the <code class="email">CaseRecord</code> and <code class="email">Task</code> records.</p></div><div class="book" title="RESTful communication"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch08lvl2sec99" class="calibre1"/>RESTful communication</h2></div></div></div><p class="calibre7">The stateless <a id="id903" class="calibre1"/>session <a id="id904" class="calibre1"/>EJB class <code class="email">CaseWorkerRESTServerEndpoint</code> serves as our RESTful endpoint:</p><div class="informalexample"><pre class="programlisting">package uk.co.xenonique.nationalforce.control;
/* ... */
import javax.json.*;
import javax.json.stream.*;
import javax.ws.rs.*;
import javax.ws.rs.container.*;
import javax.ws.rs.core.*;
import static javax.ws.rs.core.MediaType.*;

@Path("/caseworker/")
@Stateless
public class CaseWorkerRESTServerEndpoint {
  static JsonGeneratorFactory jsonGeneratorFactory = Json.createGeneratorFactory(new HashMap&lt;String, Object&gt;() {{
        put(JsonGenerator.PRETTY_PRINTING, true);
      }});

  @Inject
  CaseRecordTaskService service;
/* ... */
}</pre></div><p class="calibre7">This class<a id="id905" class="calibre1"/> is annotated <a id="id906" class="calibre1"/>with <code class="email">@Path</code> with the initial URI for this endpoint. This relative URI <code class="email">/caseworker/</code> matches the AngularJS client side. We inject the persistent stateful session EJB <code class="email">CaseRecordTaskService</code> into this endpoint, and we also set up a JSON generator factory that will print the JSON output. We use the standard Java EE 7 JSON generator factory throughout.</p><div class="book" title="Retrieval of case records"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec39" class="calibre1"/>Retrieval of case records</h3></div></div></div><p class="calibre7">To handle the retrieval of caseworker records, I shall demonstrate how to handle an asynchronous<a id="id907" class="calibre1"/> operation with JAX-RS. We need a managed executor from the application server and also to ensure that the web application supports the <code class="email">async</code> operations after deployment.</p><p class="calibre7">For Java EE 7, it is crucially important to enable the asynchronous support in the Web XML deployment descriptor (<code class="email">src/main/web-app/WEB/web.xml</code>). This file is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app  ...
         version="3.1" ... &gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;javax.ws.rs.core.Application&lt;/servlet-name&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;async-supported&gt;true&lt;/async-supported&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;javax.ws.rs.core.Application&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
  &lt;resource-env-ref&gt;
    &lt;resource-env-ref-name&gt;
      concurrent/LongRunningTasksExecutor
    &lt;/resource-env-ref-name&gt;
    &lt;resource-env-ref-type&gt;
      javax.enterprise.concurrent.ManagedExecutorService
    &lt;/resource-env-ref-type&gt;
  &lt;/resource-env-ref&gt;
&lt;/web-app&gt;</pre></div><p class="calibre7">The important XML element is <code class="email">&lt;async-supported&gt;</code> and we set its body content to true. We also<a id="id908" class="calibre1"/> set the URI for receiving the REST queries for the entire application, as <code class="email">/rest</code>. So taking the class <code class="email">CaseWorkerRESTServerEndpoint</code> together, the full relative URI, so far, is <code class="email">/rest/caseworker</code>. Finally, we declare to the Java EE 7 application server that our application requires a managed executor with the addition of XML elements around <code class="email">&lt;resource-env-ref&gt;</code>. This managed executor is referred to by the name, <code class="email">concurrent/LongRunningTasksExecutor</code> (the JNDI lookup name).</p><p class="calibre7">We shall use it now in the first REST query method:</p><div class="informalexample"><pre class="programlisting">  @Resource(name="concurrent/LongRunningTasksExecutor")
  ManagedExecutorService executor;

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Path("/list")
  public void getCaseRecordList(
    @Suspended final AsyncResponse asyncResponse) {
    executor.submit(new Runnable() {
      @Override
      public void run() {
        final List&lt;CaseRecord&gt; caseRecords = service.findAllCases();
        final StringWriter swriter = new StringWriter();
        final JsonGenerator generator = jsonGeneratorFactory.createGenerator(swriter);
          CaseRecordHelper.generateCaseRecordAsJson(generator, caseRecords).close();
          final Response response = Response.ok(swriter.toString()).build();
          asyncResponse.resume(response);
      }
    });
  }</pre></div><p class="calibre7">We annotate the method <code class="email">getCaseRecordList()</code> with <code class="email">@GET</code> to handle the HTTP GET request from the full relative URI, <code class="email">/rest/caseworker/list</code>. This method works asynchronously. It relies on the injected <code class="email">ManagedExecutorService</code> instance, which is a thread pool<a id="id909" class="calibre1"/> executor that Java EE 7 manages. In order to participate in the service, we supplied a method argument, the <code class="email">AsyncResponse</code> object, that is annotated with <code class="email">@Suspended</code>.</p><p class="calibre7">The body of our <code class="email">getCaseRecordList()</code> method submits a worker instance (<code class="email">java.lang.Runnable</code>) to the managed executor service. The worker retrieves a list of case records from the persistence service and turns them into a JSON output. The output is converted into a String and we ask the <code class="email">AsyncResponse</code> instance, through its <code class="email">resume()</code> method, to start sending data down the output channel to the client. We annotate the method <code class="email">getCaseRecordList()</code> with the JAX RS <code class="email">@Produces</code> to declare the MIME type <code class="email">application.json</code> of the output content.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip41" class="calibre1"/>Tip</h3><p class="calibre7">Incidentally, there are two <code class="email">@Produces</code> annotations in Java EE 7. One is a part of JAX-RS and the other is a CDI.</p></div><p class="calibre7">We also have a REST endpoint for the retrieval of a specific case record by its ID. Let's take a look at how we can achieve this:</p><div class="informalexample"><pre class="programlisting">  @GET
  @Path("/item/{id}")
  @Produces(APPLICATION_JSON)
  public String retrieveCase(
      @PathParam("id") int caseId ) {
    List&lt;CaseRecord&gt; caseRecords = service.findCaseById( caseId );
    StringWriter swriter = new StringWriter();
    JsonGenerator generator = jsonGeneratorFactory.createGenerator(swriter);
    CaseRecordHelper.writeCaseRecordAsJson(generator, caseRecords.get(0)).close();
    return swriter.toString();
  }</pre></div><p class="calibre7">The method <code class="email">retrieveCase()</code> is annotated with <code class="email">@GET</code> for an HTTP GET request. It has the relative URI of <code class="email">/rest/caseworker/item/{id}</code>. The method searches for the case record by ID and creates a JSON representation of it. It sends the output to the client synchronously. Just a quick note: we removed the sanity checking code in these extracts in order to save space.</p></div><div class="book" title="Creating a case record"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec40" class="calibre1"/>Creating a case record</h3></div></div></div><p class="calibre7">We've covered the retrieval side and now we move onto creational REST endpoints. In our system, a <a id="id910" class="calibre1"/>web client may create a case record using REST calls. The following code inserts a new case record into the application. The relative URI for creating a new case record is <code class="email">/rest/caseworker/item</code>.</p><div class="informalexample"><pre class="programlisting">  @POST
  @Path("/item")
  @Consumes(APPLICATION_JSON)
  @Produces(APPLICATION_JSON)
  public String createCase( JsonObject json )
    throws Exception {
    CaseRecord caseRecord = new CaseRecord();
    caseRecord.setSex(json.getString("sex"));
    caseRecord.setFirstName(json.getString("firstName"));
    caseRecord.setLastName(json.getString("lastName"));
    caseRecord.setCountry(json.getString("country"));
    caseRecord.setPassportNo(json.getString("passportNo"));
    caseRecord.setDateOfBirth( CaseRecordHelper.FMT2.parse(json.getString("dateOfBirth")));
    caseRecord.setExpirationDate( CaseRecordHelper.FMT2.parse(json.getString("expirationDate")));
    caseRecord.setCurrentState( BasicStateMachine.FSM_START.toString());
    caseRecord.setShowTasks(json.getBoolean("showTasks", false));

    JsonArray tasksArray = json.getJsonArray("tasks");
    if ( tasksArray != null ) {
      for ( int j=0; j&lt;tasksArray.size(); ++j ) {
        JsonObject taskObject = tasksArray.getJsonObject(j);
        Task task = new Task(taskObject.getString("name"), ( taskObject.containsKey("targetDate") ?
              CaseRecordHelper.FMT.parse(taskObject.getString("targetDate")) : null ), taskObject.getBoolean("completed"));
            caseRecord.addTask(task);
            task.setCaseRecord(caseRecord);
        }
    }

    service.saveCaseRecord(caseRecord);
    StringWriter swriter = new StringWriter();
    JsonGenerator generator = jsonGeneratorFactory.createGenerator(swriter);
    CaseRecordHelper.writeCaseRecordAsJson(generator, caseRecord).close();
    return swriter.toString();
}</pre></div><p class="calibre7">The method <code class="email">createCase()</code> is longer, because it transfers the data inside the JSON-P object<a id="id911" class="calibre1"/> instance to a <code class="email">CaseRecord</code> entity. We annotate the method with <code class="email">@POST</code> to denote that this endpoint handles HTTP POST requests. This is a long-winded boilerplate, which is solved through <a id="id912" class="calibre1"/>data-type binding on other non-Java EE 7 frameworks like GSON (<a class="calibre1" href="https://code.google.com/p/google-gson/">https://code.google.com/p/google-gson/</a>) or Faster Jackson Processing API<a id="id913" class="calibre1"/> for JSON (<a class="calibre1" href="http://wiki.fasterxml.com/JacksonInFiveMinutes">http://wiki.fasterxml.com/JacksonInFiveMinutes</a>), but I must demonstrate the standard approach here. We will have to wait until the specification body delivers JSON-B (Java JSON Binding API) before we can streamline this code.</p></div><div class="book" title="Updating a case record"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec41" class="calibre1"/>Updating a case record</h3></div></div></div><p class="calibre7">Updating a <a id="id914" class="calibre1"/>case record, is very similar to creating a new record, except that we first search for a record by its ID and then update the record field by field from the JSON input.</p><p class="calibre7">The method <code class="email">updateCase()</code> is as follows:</p><div class="informalexample"><pre class="programlisting">@PUT
@Path("/item/{caseId}")
@Consumes(APPLICATION_JSON)
@Produces(APPLICATION_JSON)
public String updateCase(
  @PathParam("caseId") int caseId, JsonObject json ) throws Exception {
  final List&lt;CaseRecord&gt; caseRecords = service.findCaseById(caseId);
  CaseRecord caseRecord = caseRecords.get(0);
  caseRecord.setSex(json.getString("sex"));
  /* ... omitted */
  caseRecord.setDateOfBirth( FMT2.parse( json.getString("dateOfBirth")));
  caseRecord.setExpirationDate( FMT2.parse(json.getString("expirationDate")));
  caseRecord.setCurrentState( BasicStateMachine.retrieveCurrentState( json.getString("currentState", BasicStateMachine.FSM_START.toString())).toString());
  caseRecord.setShowTasks(json.getBoolean("showTasks", false));
  service.saveCaseRecord(caseRecord);
  final StringWriter swriter = new StringWriter();
  final JsonGenerator generator = jsonGeneratorFactory.createGenerator(swriter);
  CaseRecordHelper.writeCaseRecordAsJson(generator, caseRecord).close();
  return swriter.toString();
}</pre></div><p class="calibre7">This RESTful<a id="id915" class="calibre1"/> endpoint is annotated with <code class="email">@PUT</code> in order to handle an HTTP PUT request. This time, the relative URI is <code class="email">/rest/caseworker/item/{id}</code> that denotes that the client must supply a case record ID. Again, we copy the values from the JSON object and overwrite the properties in the <code class="email">CaseRecord</code> that was retrieved from persistence; then we save the record. We generate a JSON representation of the record and set that as a response that JAX-RS will send back to the client.</p><p class="calibre7">The static instance FMT2 is a <code class="email">java.text.SimpleDateFormat</code>, which translates between the expiration date and date-of-birth String and the <code class="email">java.util.Date</code> instances. The pattern format is yyyy-MM-dd. The <code class="email">BasicStateMachine</code> instance is the implementation of the finite state machine. The <code class="email">FSM_START</code> is a singleton instance of one of the possible states. Refer to the book's source code in order to see how it is implemented.</p></div><div class="book" title="Creating a task record"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec42" class="calibre1"/>Creating a task record</h3></div></div></div><p class="calibre7">We shall now <a id="id916" class="calibre1"/>examine the create, update, and delete endpoints for the task record in quick succession. Retrieval has already been settled because every <code class="email">CaseRecord</code> instance has a collection of zero or more <code class="email">Task</code> entities, which fulfilled the master detail arrangement.</p><p class="calibre7">Creating and updating a task record are very similar operations. So let's study the create method first:</p><div class="informalexample"><pre class="programlisting">@POST
@Path("/item/{caseId}/task")
@Consumes(APPLICATION_JSON)
@Produces(APPLICATION_JSON)
public String createNewTaskOnCase(
  @PathParam("caseId") int caseId, JsonObject taskObject ) throws Exception
{
  final List&lt;CaseRecord&gt; caseRecords =
    service.findCaseById(caseId);
  final CaseRecord caseRecord = caseRecords.get(0);
  final Task task = new Task(
    taskObject.getString("name"),
    ( taskObject.containsKey("targetDate") ?
      CaseRecordHelper.convertToDate(
      taskObject.getString("targetDate")) :
      null ),
    ( taskObject.containsKey("completed")) ?
        taskObject.getBoolean("completed") : false );
  caseRecord.addTask(task);
  service.saveCaseRecord(caseRecord);
  final StringWriter swriter = new StringWriter();
  JsonGenerator generator =
    jsonGeneratorFactory.createGenerator(swriter);
  CaseRecordHelper.writeCaseRecordAsJson(
    generator, caseRecord).close();
  return swriter.toString();
}</pre></div><p class="calibre7">We annotate <a id="id917" class="calibre1"/>the method <code class="email">createNewTaskOnCase()</code> with <code class="email">@POST</code>. The relative URI is <code class="email">/rest/caseworker/item/{caseId}/task</code>. The client submits the parent case record and the method uses this ID to retrieve the appropriate <code class="email">CaseRecord</code>. It's probably a good idea to cross-reference with the AngularJS client side from the new task record controller. Inside the <code class="email">createNewTaskOnCase()</code>, we removed the sanity checking code again in order to concentrate on the substance. The next part of the code is mapping JSON to the Java entity. Afterwards, we add the <code class="email">Task</code> entity to <code class="email">CaseRecord</code> and then persist the master record. The method is complete once we write the response.</p></div><div class="book" title="Updating a task record"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec43" class="calibre1"/>Updating a task record</h3></div></div></div><p class="calibre7">The method <code class="email">updateTaskOnCase()</code> performs an update of the task. We annotate this method <a id="id918" class="calibre1"/>with <code class="email">@PUT</code> and with two RESTful arguments. The relative URI is <code class="email">/rest/caseworker/item/{caseId}/task/{taskId}</code>. The code for updating a task record is as follows:</p><div class="informalexample"><pre class="programlisting">@PUT
@Path("/item/{caseRecordId}/task/{taskId}")
@Consumes(APPLICATION_JSON)
@Produces(APPLICATION_JSON)
public String updateTaskOnCase(
  @PathParam("caseRecordId") int caseRecordId,
  @PathParam("taskId") int taskId,
  JsonObject taskObject ) throws Exception
{
  final List&lt;CaseRecord&gt; caseRecords =
    service.findCaseById(caseRecordId);
  final CaseRecord caseRecord = caseRecords.get(0);
  caseRecord.getTasks().stream().filter(
    task -&gt; task.getId().equals(taskId)).forEach(
      task -&gt; {
        task.setName( taskObject.getString("name") );
        task.setTargetDate(
          taskObject.containsKey("targetDate") ?
          CaseRecordHelper.convertToDate(
            taskObject.getString("targetDate")) : null );
        task.setCompleted(taskObject.containsKey("completed") ?
            taskObject.getBoolean("completed") : false );
    }); 
  service.saveCaseRecord(caseRecord);
  final StringWriter swriter = new StringWriter();
  final JsonGenerator generator =
    jsonGeneratorFactory.createGenerator(swriter);
  CaseRecordHelper.writeCaseRecordAsJson(
    generator, caseRecord).close();
  return swriter.toString();
}</pre></div><p class="calibre7">With <a id="id919" class="calibre1"/>our two coordinates <code class="email">caseRecordId</code> and <code class="email">TaskId</code>, we locate the appropriate <code class="email">Task</code> entity and then update the properties from the JSON input. Here, we take advantage of the Java 8 Lambdas and Stream API for a functional approach. We save the entity and render the JSON response from the current <code class="email">CaseRecord</code> entity.</p></div><div class="book" title="Deleting a task record"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec44" class="calibre1"/>Deleting a task record</h3></div></div></div><p class="calibre7">Last, but<a id="id920" class="calibre1"/> not the least, we provide the client side frontend a means to removing the task records from the case records. The code it as follows:</p><div class="informalexample"><pre class="programlisting">@DELETE
@Path("/item/{caseRecordId}/task/{taskId}")
@Consumes( { APPLICATION_JSON, APPLICATION_XML, TEXT_PLAIN })
@Produces(APPLICATION_JSON)
public String removeTaskFromCase(
  @PathParam("caseRecordId") int caseRecordId,
  @PathParam("taskId") int taskId,
  JsonObject taskObject )
  throws Exception
{
  final List&lt;CaseRecord&gt; caseRecords =
    service.findCaseById(caseRecordId);
  final CaseRecord caseRecord = caseRecords.get(0);
  caseRecord.getTasks().stream().filter(
    task -&gt; task.getId().equals(taskId))
    .forEach( task -&gt; caseRecord.removeTask(task) );
  service.saveCaseRecord(caseRecord);
  final StringWriter swriter = new StringWriter();
  final JsonGenerator generator =
          jsonGeneratorFactory.createGenerator(swriter);
  CaseRecordHelper.writeCaseRecordAsJson(generator, caseRecord).close();
  return swriter.toString();
}</pre></div><p class="calibre7">For an HTTP DELETE request, we annotate the method <code class="email">deleteTaskFromCase()</code> with <code class="email">@DELETE</code>. The relative URI for this method is the strictly RESTful service endpoint of <code class="email">/rest/caseworker/item/{caseId}/task/{taskId}</code>.</p><p class="calibre7">In this<a id="id921" class="calibre1"/> method, the tricky part is to search for the actual <code class="email">Task</code> record. Here, Java 8 Lambda and the stream functions make this a very comprehensive and pleasant task. With the <code class="email">Task</code> entity correctly identified, we remove it from the parent <code class="email">CaseRecord</code> and then save the master record with persistence. At the end of the message, we send a JSON response of <code class="email">CaseRecord</code>.</p><p class="calibre7">This covers the JAX-RS side of the application; we shall now move on to the Java EE WebSocket support.</p></div></div><div class="book" title="WebSocket communication"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch08lvl2sec100" class="calibre1"/>WebSocket communication</h2></div></div></div><p class="calibre7">WebSocket is <a id="id922" class="calibre1"/>an HTML protocol extension that allows a client and server to participate in full <a id="id923" class="calibre1"/>duplex asynchronous communication across a network. It works by an initial handshake between two endpoints across backwards-compatible HTTP before switching to the faster TCP/IP streams. The <a id="id924" class="calibre1"/>WebSocket specification (RFC 6455) is part of the conglomerate of the HTML5 technologies <a id="id925" class="calibre1"/>driven by <span class="strong"><strong class="calibre8">Web Hypertext Application Technology Working Group</strong></span> (<span class="strong"><strong class="calibre8">WHATWG</strong></span>) (<a class="calibre1" href="https://whatwg.org">https://whatwg.org</a>) and <span class="strong"><strong class="calibre8">Internet Engineering Task Force</strong></span> (<span class="strong"><strong class="calibre8">IETF</strong></span>) (<a class="calibre1" href="https://www.ietf.org">https://www.ietf.org</a>).</p><p class="calibre7">WebSocket support has been available since the Java EE 7 release, and the related JSCP specification is JSR 356 (<a class="calibre1" href="https://jcp.org/en/jsr/detail?id=356">https://jcp.org/en/jsr/detail?id=356</a>). We can develop <a id="id926" class="calibre1"/>JavaEE WebSocket with either annotations or directly against the API. It is easier to write with annotations, as we will see.</p><div class="book" title="AngularJS client side"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec45" class="calibre1"/>AngularJS client side</h3></div></div></div><p class="calibre7">It is helpful to review again the AngularJS client side around the new task record controller and the application main controller. Let's examine the method <code class="email">updateProjectTaskCompleted()</code> in the controller <code class="email">CaseRecordController</code>. Whenever the user decides the task is complete by selecting or deselecting the HTML <code class="email">checkbox</code> element, we wire up the frontend to send a WebSocket message via the <code class="email">send()</code> method:</p><div class="informalexample"><pre class="programlisting">  $scope.updateProjectTaskCompleted = function( task ) {
      var message = { 'caseRecordId': task.caseRecordId, 'taskId': task.id, 'completed': task.completed }
      $scope.connect()
      var jsonMessage = JSON.stringify(message)
      $scope.send(jsonMessage)
  }</pre></div><p class="calibre7">The entire local JavaScript task record is sent over as JSON.</p><p class="calibre7">In order to provide the WebSocket communication generally across to other modules on the client side, AngularJS recommends that we define a factory or service. A factory is usually initialized only once. A service, on the other hand, adds functionality and returns different instances depending on the calling context.</p><p class="calibre7">The following is the missing factory:</p><div class="informalexample"><pre class="programlisting">myApp.factory('UpdateTaskStatusFactory', function( $log ) {
  var service = {};

  service.connect = function() {
    if (service.ws) { return; }
    var ws = new WebSocket("ws://localhost:8080/
      xen-force-angularjs-1.0-SNAPSHOT/update-task-status");
    ws.onopen = function() {
      $log.log("WebSocket connect was opened"); };
    ws.onclose = function() {
      $log.log("WebSocket connection was closed"); }
    ws.onerror = function() {
      $log.log("WebSocket connection failure"); }
    ws.onmessage = function(message) {
      $log.log("message received ["+message+"]"); };
    service.ws = ws;
  }

  service.send = function(message) {
      service.ws.send(message);
  }

  return service;
});</pre></div><p class="calibre7">The idiom for defining an AngularJS factory resembles the defining of a controller or a module, strongly. With the main module <code class="email">myApp</code>, we invoke the library <code class="email">factory()</code> method with two arguments: the name of the factory and the function callback that defines the service. The factory has only one dependency on the default logging module, <code class="email">$log</code>.</p><p class="calibre7">This <code class="email">connect()</code> method initializes an HTML5 WebSocket with the URL by instantiating a WebSocket instance. With the handle, we register optional callbacks to deal with events: when the WebSocket is opened, closed, receives a message, or there is an error. Each<a id="id927" class="calibre1"/> callback dumps a message to the web browser's console log.</p><p class="calibre7">We define a couple of <code class="email">send()</code> methods that send the message body content down the WebSocket to the peer. In WebSocket parlance, the remote endpoint is known as the peer, because there is no distinction between the client and server endpoints. Both sides can start a connection to the other and begin communicating; hence the term full duplex.</p></div><div class="book" title="Server-side WebSocket endpoints"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec46" class="calibre1"/>Server-side WebSocket endpoints</h3></div></div></div><p class="calibre7">As mentioned earlier, in Java EE 7 we can quickly develop WebSocket endpoints using the standard<a id="id928" class="calibre1"/> annotations. The Java WebSocket API closely follows the IETF specification, and you will recognize the similarities with the many JavaScript implementations inside a web browser. There is far too much to the configuration and to the different approaches of annotation and programming directly to the library that can be reasonably squeezed in this digital Java EE book.</p><p class="calibre7">Nevertheless, the essential Java class is actually annotated as a stateless session EJB as well as a WebSocket. This should not be surprising, because the Java EE specification allows this mixture of annotations in certain cases.</p><p class="calibre7">The following is the endpoint in <code class="email">CaseRecordUpdateTaskWebSocketEndpoint</code>:</p><div class="informalexample"><pre class="programlisting">package uk.co.xenonique.nationalforce.control;
/* ... */
import javax.websocket.*;
import javax.websocket.server.ServerEndpoint;

@ServerEndpoint("/update-task-status")
@Stateless
public class CaseRecordUpdateTaskWebSocketEndpoint {
  @Inject
  CaseRecordTaskService service;

  static JsonGeneratorFactory jsonGeneratorFactory =
    Json.createGeneratorFactory(...);

  @OnMessage
  public String updateTaskStatus(String message) {
    final StringReader stringReader = new StringReader(message);
    final JsonReader reader = Json.createReader(stringReader);
    final JsonObject obj = reader.readObject();
    final int projectId = obj.getInt("caseRecordId");
    final int taskId = obj.getInt("taskId");
    final boolean completed = obj.getBoolean("completed");
    final List&lt;CaseRecord&gt; projects =
      service.findCaseById(projectId);
    if ( !projects.isEmpty()) {
      projects.get(0).getTasks().stream()
        .filter(task -&gt; task.getId() == taskId).
        forEach(task -&gt; {
            task.setCompleted(completed);
            service.saveCaseRecord(task.getCaseRecord());
        });
      return "OK";
    }
    return "NOT FOUND";
  }

  @OnOpen
  public void open( Session session ) { ... }
  @OnClose
  public void close( Session session ) { ... }
  @OnError
  public void error( Session session, Throwable err ){
      err.printStackTrace(System.err);
  }
}</pre></div><p class="calibre7">We <a id="id929" class="calibre1"/>annotate the bean with <code class="email">@ServerEndpoint</code> to denote a server-side endpoint. The notion of <span class="strong"><em class="calibre9">server-side</em></span> is essentially a Java EE nomenclature to declare an intention that this endpoint lives on an application server. There are also such things as <code class="email">@ClientEndpoint</code> connections.</p><p class="calibre7">Instead of callbacks, Java EE uses annotated methods to handle the opening, closing, and failure events around the WebSocket with <code class="email">@OnOpen</code>, <code class="email">@OnClose</code>, and <code class="email">@OnError</code> respectively.</p><p class="calibre7">To handle the receiving of a message on WebSocket correctly, a POJO or bean must only have one method annotated with <code class="email">@Message</code>. Behind the scenes, the library framework transforms the message into a String for the simplest case as we have here. It is possible to send binary and complex data types down and across the wire.</p><p class="calibre7">Inside<a id="id930" class="calibre1"/> the <code class="email">updateTaskStatus()</code> method, we leverage the JSON-P API to parse the text into the salient properties of a task. From the input text message, we require the case record ID, the task ID and the completion properties of the task. We retrieve the matching <code class="email">CaseRecord</code> entity from persistence and filter the collection of the <code class="email">Task</code> objects for the correct item. Once we have it, we set the completed property and persist the entire record back to persistence.</p><p class="calibre7">WebSockets are permitted to return a response back to the peer. We send the response synchronously, as we do here, with a text message like <code class="email">OK</code> or <code class="email">NOT FOUND</code>. Readers should be aware that it also possible to send responses asynchronously.</p><p class="calibre7">We have reached the end of the server-side discussion.</p></div></div></div>
<div class="book" title="Consider your design requirements" id="aid-2G3F81"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch08lvl1sec77" class="calibre1"/>Consider your design requirements</h1></div></div></div><p class="calibre7">AngularJS is a powerful JavaScript MVC framework for the client side. Developers, designers, and digital managers are always looking at the next exciting technology. People often tend to gauge the impact of a new framework. It is fair to say that AngularJS is a game changer because of the ease of the developing components that are bound to the model. The effort for not implementing such potential error-prone code with jQuery, by default, is huge!</p><p class="calibre7">We know that <a id="id931" class="calibre1"/>AngularJS is suited for single-page applications. Does that mean that your next enterprise application must be a SPA? Well, the practicing consultant's answer is that it always depends on your goals. SPA is suited to limited customer journeys and in cases where the experience happens mostly in one place. The caseworker application is of this type, because the person is assessing the passport applicants on a case-by-case basis, and therefore, they stay in and work on one web page most of the time during their working day.</p><p class="calibre7">The caseworker application demonstrates a master-detail relationship. Your next enterprise application may probably require the involvement of a more complicated set of use stories. Your domain might require an extensive set of entities. A single SPA might not cover all the areas. For one thing, you will need many more JavaScript modules, controllers and factories, and HTML directives to fully surround the bounded context of the system.</p><p class="calibre7">So what to do with these complicated requirements? One approach is to bundle all of the JavaScript logic on the client script into one download. Tools for this such as GruntJS, which we briefly covered in the last chapter, can then merge, compress, and optimize files. We can<a id="id932" class="calibre1"/> take advantage of the Java EE strengths with more than one web page and navigation.</p><div class="book" title="Array collection of single-page applications"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch08lvl2sec101" class="calibre1"/>Array collection of single-page applications</h2></div></div></div><p class="calibre7">We can structure an SPA into a linear sequence so that the customer journey of the system almost<a id="id933" class="calibre1"/> follows a workflow. There are domains such as warehouse order management, engineering, and financial trading where such an approach might make sense. In such domains, the business user works in a series of complex steps in order to process bulk units of work from A to B. The advantages of an array of SPAs are won if they have a short linear sequence consisting of, perhaps, three or four steps, but will be lost if the length of the chain is greater than or equal to seven.</p></div><div class="book" title="Hierarchical collection of single-page applications"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch08lvl2sec102" class="calibre1"/>Hierarchical collection of single-page applications</h2></div></div></div><p class="calibre7">The other approach is to descend fully from a linear sequence into the hierarchical tree structure of SPA. This approach is extremely specialized, and it is advisable to seek some architectural <a id="id934" class="calibre1"/>assurance that this path is sustainable for your business. Why would a business want to organize SPA in this fashion? Your stakeholder may want to sustain the organizational function in a way that mirrors the domain exactly. The design approach is a risky procedure because it introduces inflexibility in the overall model, and in my humble opinion, appears to be authority power led by the management rather than being organic. If the hierarchy tree is organized in a length by breadth manner rather than length by depth, ask yourself why?</p><p class="calibre7">In these times, where engineers and architects are looking at micro-services in order to scale and have a single business function in an elegant box, an HSPA might indeed be useful. The tree structure size should be around 10 nodes.</p></div></div>
<div class="book" title="Summary" id="aid-2H1VQ1"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch08lvl1sec78" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this long chapter, we covered client-side AngularJS development with a caseworker application. We learned how the AngularJS framework manipulates the DOM and how it provides the binding between the data and the rendering of the elements using the MVC. We also learned some AngularJS concepts like scopes, modules, controllers, and factories.</p><p class="calibre7">Using the study example, we illustrated how AngularJS communicates to a remote server using RESTful service invocations from the client side. We also studied the WebSocket interaction briefly. On the client side of JavaScript, we went through the entire CRUD idiom in the caseworker application.</p><p class="calibre7">On the server side, we saw the implementation of the RESTful services with JAX-RS, which covered the four standard HTTP method requests. We also learnt about the Java WebSocket implementation.</p><p class="calibre7">AngularJS fits the mode of applications that single page applications need. However, this may or may not be appropriate to your business requirements. Adopting AngularJS requires full stack knowledge of both JavaScript programming and Java EE development. Moving to a framework like AngularJS exposes your business to the risk of hiring, retaining, and learning more technologies.</p><p class="calibre7">There is also another side of the triangle to consider: organizational dynamics. Apple Inc., USA famously divided their then agile teams that worked on the online shopping store into a pure server and client division. The only communication allowed between them was an agreed upon programming interface. This division happened when the iPhone was being developed (circa 2005-2007), which obviously predates AngularJS. Your team might operate differently, but the concept of design-by-contract is still relevant, because it showed what can be achieved, especially in terms of RESTful services.</p><p class="calibre7">I will leave you with a second quote from Misko Hevery, co-creator of AngularJS. He said:</p><div class="blockquote"><blockquote class="blockquote2"><p class="calibre27"><span class="strong"><em class="calibre9">"Limited – You can't really show more than 2000 pieces of information to a human on a single page. Anything more than that is really bad UI, and humans can't process this anyway."</em></span></p></blockquote></div></div>
<div class="book" title="Exercises" id="aid-2I0GC1"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch08lvl1sec79" class="calibre1"/>Exercises</h1></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem">Download the source code for the xen-national-force caseworker application and study the implementation for a few hours. What do you notice? Compile the code and deploy the resultant WAR to your application server of choice.</li><li class="listitem">With the material from this chapter, create your CRUD AngularJS application with just one simple entity, <code class="email">EMPLOYEE</code>. This entity should have an employee ID, name, and social security number. Build the client side with AngularJS and the server side with JAX-RS. (In the book's source code, there is a blank project that will help you get started.)</li><li class="listitem">While building the EMPLOYEE CRUD from the previous question in AngularJS and JavaEE, did you use the modal dialog from UI Bootstrap? If not, investigate other means of rendering the view to insert, update, and delete records. (Hint: One possible way is dynamically showing and hiding different <code class="email">DIV</code> elements.)</li><li class="listitem">There is an obvious design flaw with the caseworker application. Did you find it? When the caseworker shows and hides a task view, it updates the persistence database; explain why is this a problem?</li><li class="listitem">Imagine that from today, you have become the project lead for the entire xen-national-force team, and suddenly, the business decides that they want instant notifications to be broadcast to other caseworkers once a state has been changed. Explain at a technical level how this user story might be achieved. Think about the challenges on the AngularJS client side. How might you build the Java EE server side?</li><li class="listitem">Study the factory module (<code class="email">iso-countries.js</code>) in xen-national-force that is responsible for the maintaining a collection of the ISO passport country names and their codes. How is this module used in the frontend? Where does it get used?</li><li class="listitem">Instead of using a dedicated Boolean property in the <code class="email">CaseRecord</code> JPA entity to denote if the task view is shown or not, write an AngularJS factory module that stores this information for all the case records locally on the client side.</li><li class="listitem">The sample caseworker application retrieves every record in the database and returns it to the user. Suppose the real system had 1,000 case records. What could be an issue with this functionality? How would you solve it?  If the caseworker is not able to see all the records, explain how do you ensure that they get to see relevant cases? What do you need to implement on both the AngularJS client and the Java EE server side?</li></ol><div class="calibre25"/></div></div></body></html>