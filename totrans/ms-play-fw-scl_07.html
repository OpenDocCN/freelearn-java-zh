<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Playing with Globals"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Playing with Globals</h1></div></div></div><p>Sometimes web applications require application-wide objects that live beyond the request-response life cycle, such as database connections, application configuration, shared objects, and cross-cutting concerns (authentication, error handling, and so on). Consider the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Ensuring that the database used by the application is defined and accessible.</li><li class="listitem" style="list-style-type: disc">Notify through e-mail or any other service when the application is receiving unexpected heavy traffic.</li><li class="listitem" style="list-style-type: disc">Logging the different requests served by the application. These logs can later be used to analyze user behavior.</li><li class="listitem" style="list-style-type: disc">Restricting certain facilities on the web application by time. For example, some food ordering apps take orders only between 11 a.m. to 8 p.m., while all requests to build orders at any other time will be blocked and a message about the timings will be displayed.</li><li class="listitem" style="list-style-type: disc">Generally, when a user sends an e-mail and the recipient's email ID is incorrect or not in use, the sender is notified about the failure in delivering the e-mail only after 12 to 24 hrs. In this duration, further attempts are made to send the e-mail.</li></ul></div><p>Applications with in-app sales allow users to retry with the same or different payment options when payment has been declined for various reasons.</p><p>In a Play Framework app, by convention, all of these various concerns can be managed through GlobalSettings.</p><p>In this chapter, we will discuss the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">GlobalSettings</li><li class="listitem" style="list-style-type: disc">Application life cycle</li><li class="listitem" style="list-style-type: disc">Request-response life cycle</li></ul></div><div class="section" title="GlobalSettings"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec47"/>GlobalSettings</h1></div></div></div><p>Every Play application <a id="id239" class="indexterm"/>has a global object which can be used to define application-wide objects. It can also be used to customize the application's life cycle and the request-response life cycle.</p><p>The global object for an application can be defined by extending the trait <code class="literal">GlobalSettings</code>. By default, the name of the object is expected to be <code class="literal">Global</code> and it is assumed to be in the <code class="literal">app</code> directory. This can be changed by updating <code class="literal">application.global</code> in the <code class="literal">conf/application.conf</code> property. For example, if we wish to use a file with <code class="literal">AppSettings</code> in the <code class="literal">app/com/org</code> name:</p><div class="informalexample"><pre class="programlisting">application.global=app.com.org.AppSettings</pre></div><p>The <code class="literal">GlobalSettings</code> trait has methods that can be used to interrupt both the application's life cycle and the request-response life cycle. We will see its methods as and when required in the following sections.</p><p>Now, let's see how this works.</p><p>An app developed through the Play Framework is represented by an instance of the <code class="literal">Application</code> trait, since its creation and the build is to be handled by the framework itself.</p><p>The <code class="literal">Application</code> trait is extended by <code class="literal">DefaultApplication</code> and <code class="literal">FakeApplication</code>. <code class="literal">FakeApplication</code> is a helper that tests Play applications and we will see more of it in <a class="link" href="ch09.html" title="Chapter 9. Testing">Chapter 9</a>, <span class="emphasis"><em>Testing</em></span>. <code class="literal">DefaultApplication</code> is defined as follows:</p><div class="informalexample"><pre class="programlisting">class DefaultApplication(
  override val path: File,
  override val classloader: ClassLoader,
  override val sources: Option[SourceMapper],
  override val mode: Mode.Mode) extends Application with WithDefaultConfiguration with WithDefaultGlobal with WithDefaultPlugins</pre></div><p>The <code class="literal">WithDefaultConfiguration</code> and <code class="literal">WithDefaultPlugins</code> traits are used to initialize the application's configuration and plugin objects, respectively. The <code class="literal">WithDefaultGlobal</code> trait is the one responsible for setting the correct global object for the application. It is defined as follows:</p><div class="informalexample"><pre class="programlisting">trait WithDefaultGlobal { 
  self: Application with WithDefaultConfiguration =&gt; 

  <span class="strong"><strong>private lazy val globalClass = initialConfiguration.getString("application.global").getOrElse(initialConfiguration.getString("global").map { g =&gt; </strong></span>
<span class="strong"><strong>    Play.logger.warn("`global` key is deprecated, please change `global` key to `application.global`") </strong></span>
<span class="strong"><strong>    g </strong></span>
<span class="strong"><strong>  }.getOrElse("Global")) </strong></span>

  lazy private val javaGlobal: Option[play.GlobalSettings] = try { 
    Option(self.classloader.loadClass(globalClass).newInstance().asInstanceOf[play.GlobalSettings]) 
  } catch { 
    case e: InstantiationException =&gt; None 
    case e: ClassNotFoundException =&gt; None 
  } 

  lazy private val scalaGlobal: GlobalSettings = try { 
    self.classloader.loadClass(globalClass + "$").getDeclaredField("MODULE$").get(null).asInstanceOf[GlobalSettings] 
  } catch { 
   <span class="strong"><strong> case e: ClassNotFoundException if !initialConfiguration.getString("application.global").isDefined =&gt; DefaultGlobal </strong></span>
    case e if initialConfiguration.getString("application.global").isDefined =&gt; { 
      throw initialConfiguration.reportError("application.global", s"Cannot initialize the custom Global object ($globalClass) (perhaps it's a wrong reference?)", Some(e)) 
    } 
  } 

  <span class="strong"><strong>private lazy val globalInstance: GlobalSettings = Threads.withContextClassLoader(self.classloader) { </strong></span>
<span class="strong"><strong>    try { </strong></span>
<span class="strong"><strong>      javaGlobal.map(new j.JavaGlobalSettingsAdapter(_)).getOrElse(scalaGlobal) </strong></span>
<span class="strong"><strong>    } catch { </strong></span>
<span class="strong"><strong>      case e: PlayException =&gt; throw e </strong></span>
<span class="strong"><strong>      case e: ThreadDeath =&gt; throw e </strong></span>
<span class="strong"><strong>      case e: VirtualMachineError =&gt; throw e </strong></span>
<span class="strong"><strong>      case e: Throwable =&gt; throw new PlayException( </strong></span>
<span class="strong"><strong>        "Cannot init the Global object", </strong></span>
<span class="strong"><strong>        e.getMessage, </strong></span>
<span class="strong"><strong>        e </strong></span>
<span class="strong"><strong>      ) </strong></span>
<span class="strong"><strong>    } </strong></span>
<span class="strong"><strong>  } </strong></span>

  def global: GlobalSettings = { 
    globalInstance 
  } 
}</pre></div><p>The <code class="literal">globalInstance</code> object is the <code class="literal">global</code> object to be used for this application. It is set to <code class="literal">javaGlobal</code> or <code class="literal">scalaGlobal</code>, whichever is applicable to the application. If the application does not have <a id="id240" class="indexterm"/>custom Global object configured for the application, the application's <code class="literal">global</code> is set to <code class="literal">DefaultGlobal</code>. It is defined as:</p><div class="informalexample"><pre class="programlisting">object DefaultGlobal extends GlobalSettings</pre></div></div></div>
<div class="section" title="The life cycle of an application"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec48"/>The life cycle of an application</h1></div></div></div><p>An application's life <a id="id241" class="indexterm"/>cycle has two states: <span class="strong"><strong>running</strong></span> and <span class="strong"><strong>stopped</strong></span>. These <a id="id242" class="indexterm"/>are times when the state of the application <a id="id243" class="indexterm"/>changes. At times, we need to perform some operations right before or after a state change has occurred or is about to occur.</p><p>Play applications use a Netty server. For this, a class with the same name is used. It is defined as follows:</p><div class="informalexample"><pre class="programlisting">class NettyServer(appProvider: ApplicationProvider, port: Option[Int], sslPort: Option[Int] = None, address: String = "0.0.0.0", val mode: Mode.Mode = Mode.Prod) extends Server with ServerWithStop { … }</pre></div><p>This class is responsible for binding or bootstrapping the application to the server.</p><p>The <code class="literal">ApplicationProvider</code> trait is defined as follows:</p><div class="informalexample"><pre class="programlisting">trait ApplicationProvider {
  def path: File
  def get: Try[Application]
  def handleWebCommand(requestHeader: play.api.mvc.RequestHeader): Option[Result] = None
}</pre></div><p>An implementation of <code class="literal">ApplicationProvider</code> must create and initialize an application. Currently, there are three <a id="id244" class="indexterm"/>different implementations of <code class="literal">ApplicationProvider</code>. They are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">StaticApplication</code>: This <a id="id245" class="indexterm"/>is to be used in the production mode (the mode where code changes do not affect an already running application).</li><li class="listitem" style="list-style-type: disc"><code class="literal">ReloadableApplication</code>: This is to be used in the development mode (this is a mode <a id="id246" class="indexterm"/>where continuous compilation is enabled so that developers can see the impact of changes in an application as and when they are saved, if the application is up and running).</li><li class="listitem" style="list-style-type: disc"><code class="literal">TestApplication</code>: This is to be used in the testing mode (the mode where a fake application is <a id="id247" class="indexterm"/>started <a id="id248" class="indexterm"/>through the tests).</li></ul></div><p>
<code class="literal">StaticApplication</code> and <code class="literal">ReloadableApplication</code> both initialize a <code class="literal">DefaultApplication</code>. <code class="literal">StaticApplication</code> is used in the production mode and is defined as follows:</p><div class="informalexample"><pre class="programlisting">class StaticApplication(applicationPath: File) extends ApplicationProvider {

  <span class="strong"><strong>val application = new DefaultApplication(applicationPath, this.getClass.getClassLoader, None, Mode.Prod)</strong></span>

  Play.start(application)

  def get = Success(application)
  def path = applicationPath
}</pre></div><p>
<code class="literal">ReloadableApplication</code> is used in the development mode but, since the class definition is huge, let's see the <a id="id249" class="indexterm"/>relevant lines of code where <a id="id250" class="indexterm"/>
<code class="literal">DefaultApplication</code> is used:</p><div class="informalexample"><pre class="programlisting">class ReloadableApplication(buildLink: BuildLink, buildDocHandler: BuildDocHandler) extends ApplicationProvider {
...
// First, stop the old application if it exists
    Play.stop()

    val newApplication = new DefaultApplication(reloadable.path, projectClassloader, Some(new SourceMapper {
        def sourceOf(className: String, line: Option[Int]) = {
          Option(buildLink.findSource(className, line.map(_.asInstanceOf[java.lang.Integer]).orNull)).flatMap {
            case Array(file: java.io.File, null) =&gt; Some((file, None))
            case Array(file: java.io.File, line: java.lang.Integer) =&gt; Some((file, Some(line)))
            case _ =&gt; None
            }
          }
              }), Mode.Dev) with DevSettings {
                import scala.collection.JavaConverters._
                lazy val devSettings: Map[String, String] = buildLink.settings.asScala.toMap
              }

              Play.start(newApplication)
...
}</pre></div><p>For <code class="literal">StaticApplication</code>, the application is created and started just once whereas, in the case of <code class="literal">ReloadableApplication</code>, the existing application is stopped and a new one is created and started. The <code class="literal">ReloadableApplication</code> is for the development mode, so as to allow developers to make changes and see them reflected without the hassle of reloading the application manually every time.</p><p>The usage of <a id="id251" class="indexterm"/>
<code class="literal">ApplicationProvider</code> and <code class="literal">NettyServer</code> is similar to this:</p><div class="informalexample"><pre class="programlisting">val appProvider = new ReloadableApplication(buildLink, buildDocHandler)
val server = new NettyServer(appProvider, httpPort, httpsPort, mode = Mode.Dev)</pre></div><p>In the following section, we will discuss the methods available in GlobalSettings, which enable us to hook into the application's life cycle.</p><div class="section" title="Meddling with an application's life cycle"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec29"/>Meddling with an application's life cycle</h2></div></div></div><p>Consider that our <a id="id252" class="indexterm"/>application has the following specifications:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Prior to starting the application, we need to ensure that the <code class="literal">/opt/dev/appName</code> directory exists and is accessible by the application. A method in our application called <code class="literal">ResourceHandler.initialize</code> does this task.</li><li class="listitem" style="list-style-type: disc">Create the required schema on startup using the <code class="literal">DBHandler.createSchema</code> method. This method does not drop the schema if it already exists. This ensures that the application's data is not lost on restarting the application and the schema is generated only when the application is first started.</li><li class="listitem" style="list-style-type: disc">Create e-mail application logs when the application is stopped using the <code class="literal">Mailer.sendLogs</code> method. This method sends the application logs as an attachment in an e-mail to the <code class="literal">emailId</code> set in a configuration file as <code class="literal">adminEmail</code>. This is used to track the cause for the application's shutdown.</li></ul></div><p>Play provides methods that allow us to hook into the application's life cycle and complete such tasks. The <code class="literal">GlobalSettings</code> trait has methods that assist in doing so. These can be overridden by the <code class="literal">Global</code> object, if required.</p><p>To cater to the specifications of the application described earlier, all we need to do in a Play application is define a <code class="literal">Global</code> object, as shown here:</p><div class="informalexample"><pre class="programlisting">object Global extends GlobalSettings {

  override def beforeStart(app: Application): Unit = {
    ResourceHandler.initialize
  }
  
  override def onStart(app: Application):Unit={
    DBHandler.createSchema
  }

  override def onStop(app: Application): Unit = {
    Mailer.sendLogs
  }
}</pre></div><p>The <code class="literal">ResourceHandler.initialize</code>, <code class="literal">DBHandler.createSchema</code>, and <code class="literal">Mailer.sendLogs</code> methods are specific to our application and are defined by us, not provided by Play.</p><p>Now that we know how to hook into the application's life cycle, let's scrutinize how it works.</p><p>Digging deeper into the <a id="id253" class="indexterm"/>application's life cycle we can see that all the implementations of <code class="literal">ApplicationProvider</code> use the <code class="literal">Play.start</code> method to initialize an application. The <code class="literal">Play.start</code> method is defined as follows:</p><div class="informalexample"><pre class="programlisting">def start(app: Application) {

    // First stop previous app if exists
    stop()

    _currentApp = app

    // Ensure routes are eagerly loaded, so that the reverse routers are correctly
    // initialized before plugins are started.
    app.routes
    Threads.withContextClassLoader(classloader(app)) {
     <span class="strong"><strong> app.plugins.foreach(_.onStart())</strong></span>
    }

    app.mode match {
      case Mode.Test =&gt;
      case mode =&gt; logger.info("Application started (" + mode + ")")
    }

  }</pre></div><p>This method ensures that each plugin's <code class="literal">onStart</code> method is called right after the application is set as <code class="literal">_currentApp</code>. <code class="literal">GlobalPlugin</code>, is added by default to all the Play applications, and is <a id="id254" class="indexterm"/>defined as:</p><div class="informalexample"><pre class="programlisting">class GlobalPlugin(app: Application) extends Plugin {

  // Call before start now
  app.global.beforeStart(app)

  // Called when the application starts.
  override def onStart() {
    app.global.onStart(app)
  }

  //Called when the application stops.
  override def onStop() {
    app.global.onStop(app)
  }

}</pre></div><p>In the preceding snippet, <code class="literal">app.global</code> refers to the GlobalSettings defined for the application. Therefore, the GlobalPlugin ensures that the appropriate methods of the application's GlobalSettings are called.</p><p>The <code class="literal">beforeStart</code> method is called on initialization of the plugin.</p><p>Now, we just need to figure out how <code class="literal">onStop</code> is called. Once an application is stopped, <code class="literal">ApplicationProvider</code> does not have control, so the Java runtime shutdown hook is used to ensure that certain tasks are executed once the application is stopped. Here is a look at the relevant lines from the <code class="literal">NettyServer.createServer</code> method:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Runtime.getRuntime.addShutdownHook(new Thread { </strong></span>
<span class="strong"><strong>        override def run { </strong></span>
<span class="strong"><strong>          server.stop() </strong></span>
<span class="strong"><strong>        } </strong></span>
<span class="strong"><strong>      })</strong></span>
</pre></div><p>Here, runtime is <a id="id255" class="indexterm"/>java.lang.Runtime (Java docs for the same are available at <a class="ulink" href="http://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html">http://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html</a>) and the <code class="literal">server</code> is an instance of NettyServer. NettyServer's <code class="literal">stop</code> method is defined as:</p><div class="informalexample"><pre class="programlisting">override def stop() {

    try {
      Play.stop()
    } catch {
      case NonFatal(e) =&gt; Play.logger.error("Error while stopping the application", e)
    }

    try {
      super.stop()
    } catch {
      case NonFatal(e) =&gt; Play.logger.error("Error while stopping logger", e)
    }

    mode match {
      case Mode.Test =&gt;
      case _ =&gt; Play.logger.info("Stopping server...")
    }

    // First, close all opened sockets
    allChannels.close().awaitUninterruptibly()

    // Release the HTTP server
    HTTP.foreach(_._1.releaseExternalResources())

    // Release the HTTPS server if needed
    HTTPS.foreach(_._1.releaseExternalResources())

    mode match {
      case Mode.Dev =&gt;
        Invoker.lazySystem.close()
        Execution.lazyContext.close()
      case _ =&gt; ()
    }
  }</pre></div><p>Here, the <code class="literal">Invoker.lazySystem.close()</code> call is used to shut down the ActorSystem used internally within a <a id="id256" class="indexterm"/>Play application. The <code class="literal">Execution.lazyContext.close()</code> call is to shut down Play's internal <code class="literal">ExecutionContext</code>.</p><p>The <code class="literal">Play.stop</code> method is defined as follows:</p><div class="informalexample"><pre class="programlisting"> def stop() {
    Option(_currentApp).map { app =&gt;
      Threads.withContextClassLoader(classloader(app)) {
        <span class="strong"><strong>app.plugins.reverse.foreach { p =&gt;</strong></span>
<span class="strong"><strong>          try {</strong></span>
<span class="strong"><strong>            p.onStop()</strong></span>
<span class="strong"><strong>          } catch { case NonFatal(e) =&gt; logger.warn("Error stopping plugin", e) }</strong></span>
<span class="strong"><strong>        }</strong></span>
      }
    }
    _currentApp = null
  }</pre></div><p>This method calls the <code class="literal">onStop</code> method of all the registered plugins in reverse order, so the GlobalPlugin's <code class="literal">onStop</code> method is called and it eventually calls the <code class="literal">onStop</code> method of the <code class="literal">GlobalSetting</code> defined for the application. Any errors encountered in this process are logged as warnings since the <a id="id257" class="indexterm"/>application is going to be stopped.</p><p>We can now add any task within the application's life cycle, such as creating database schemas before starting, initializing global objects, or scheduling jobs (using Akka Scheduler or Quartz, and so on) on starting and cleaning temporary data when stopping.</p><p>We've covered the application's life cycle, now let's look into the request-response life cycle.</p></div></div>
<div class="section" title="The request-response life cycle"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec49"/>The request-response life cycle</h1></div></div></div><p>The Play Framework <a id="id258" class="indexterm"/>uses Netty by default, so requests are received by NettyServer.</p><p>Netty allows a variety of actions including custom coding through handlers. We can define a handler that transforms a request into a desired response and provides it to Netty when bootstrapping the application. To integrate a Play app with Netty, <code class="literal">PlayDefaultUpstreamHandler</code> is used.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>For additional <a id="id259" class="indexterm"/>information on requests used in Netty, refer to Netty docs at <a class="ulink" href="http://netty.io/wiki/user-guide-for-4.x.html">http://netty.io/wiki/user-guide-for-4.x.html</a> and Netty ChannelPipeline <a id="id260" class="indexterm"/>docs at <a class="ulink" href="http://netty.io/4.0/api/io/netty/channel/ChannelPipeline.html">http://netty.io/4.0/api/io/netty/channel/ChannelPipeline.html</a>.</p></div></div><p>
<code class="literal">PlayDefaultUpstreamHandler</code> extends <code class="literal">org.jboss.netty.channel.SimpleChannelUpstreamHandler</code> to handle both HTTP and WebSocket requests. It is used when bootstrapping the application to Netty in the following way:</p><div class="informalexample"><pre class="programlisting">val defaultUpStreamHandler = new PlayDefaultUpstreamHandler(this, allChannels)</pre></div><p>The <code class="literal">messageReceived</code> method of <code class="literal">SimpleChannelUpStreamHandler</code> is responsible for acting on the received request. <code class="literal">PlayDefaultUpstreamHandler</code> overwrites this so that requests are sent to our application. This method is too long (around 260 lines, including comments and blank lines), so we will only look at relevant blocks here.</p><p>First, a Play <code class="literal">RequestHeader</code> is created for the message received and its corresponding action is found:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>val (requestHeader, handler: Either[Future[Result], (Handler, Application)]) </strong></span>= Exception.allCatch[RequestHeader].either {
    <span class="strong"><strong>val rh = tryToCreateRequest</strong></span>
            // Force parsing of uri
            rh.path
            rh
          }.fold(
            e =&gt; {
              //Exception Handling
              ...
            },
            rh =&gt; <span class="strong"><strong>server.getHandlerFor(rh)</strong></span> match {
              case directResult @ Left(_) =&gt; (rh, directResult)
              <span class="strong"><strong>case Right((taggedRequestHeader, handler, application)) =&gt; (taggedRequestHeader, Right((handler, application)))</strong></span>
            }
          )</pre></div><p>In the preceding snippet, the <code class="literal">tryToCreateRequest</code> method results in <code class="literal">RequestHeader</code> and any exceptions encountered in this process are handled. The action for the <code class="literal">RequestHeader rh</code> is then fetched through <code class="literal">server.getHandlerFor(rh)</code>. Here, a <code class="literal">server</code> is an instance of the <a id="id261" class="indexterm"/>server trait and the <code class="literal">getHandlerFor</code> method utilizes the application's <code class="literal">global</code> object and its <code class="literal">onRequestReceived</code> method:</p><div class="informalexample"><pre class="programlisting">try {
        <span class="strong"><strong>applicationProvider.get.map { application =&gt;</strong></span>
<span class="strong"><strong>          application.global.onRequestReceived(request) match {</strong></span>
<span class="strong"><strong>            case (requestHeader, handler) =&gt; (requestHeader, handler, application)</strong></span>
<span class="strong"><strong>          }</strong></span>
<span class="strong"><strong>        }</strong></span>
      } catch {
  //Exception Handling
...
}</pre></div><p>In the  <code class="literal">messageReceived</code> method of <code class="literal">PlayDefaultUpstreamHandler</code>, the action obtained from <code class="literal">server.getHandlerFor</code> is eventually called, resulting in a response.</p><p>Most of the interactions of <code class="literal">PlayDefaultUpStreamHandler</code> with the application are through its global object. In the following section, we will see the methods available in GlobalSettings related to the request-response life cycle.</p><div class="section" title="Fiddling with the request-response life cycle"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec30"/>Fiddling with the request-response life cycle</h2></div></div></div><p>The <code class="literal">GlobalSettings</code> <a id="id262" class="indexterm"/>trait has methods related to different stages of the application's life cycle as well as its request-response life cycle. Using the request-related hooks, we can define business logic when a request is received, when an action is not found for the request, and so on.</p><p>The request-related <a id="id263" class="indexterm"/>methods are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">onRouteRequest</code>: This <a id="id264" class="indexterm"/>uses a router to identify the action for a given <code class="literal">RequestHeader</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">onRequestReceived</code>: This <a id="id265" class="indexterm"/>results in <code class="literal">RequestHeader</code> and its action. Internally, it calls the <code class="literal">onRouteRequest</code> method</li><li class="listitem" style="list-style-type: disc"><code class="literal">doFilter</code>: This <a id="id266" class="indexterm"/>adds a filter to the application</li><li class="listitem" style="list-style-type: disc"><code class="literal">onError</code>: This is a <a id="id267" class="indexterm"/>method that handles exceptions when processing</li><li class="listitem" style="list-style-type: disc"><code class="literal">onHandlerNotFound</code>: This <a id="id268" class="indexterm"/>is used when a RequestHeader's corresponding action cannot be found</li><li class="listitem" style="list-style-type: disc"><code class="literal">onBadRequest</code>: This is <a id="id269" class="indexterm"/>used internally <a id="id270" class="indexterm"/>when the request body is incorrect</li><li class="listitem" style="list-style-type: disc"><code class="literal">onRequestCompletion</code>: This is used to perform operations after a request has been <a id="id271" class="indexterm"/>processed successfully</li></ul></div><div class="section" title="Manipulating requests and their responses"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec06"/>Manipulating requests and their responses</h3></div></div></div><p>In some <a id="id272" class="indexterm"/>applications, it is mandatory to filter, modify, redirect requests, and their responses. Consider these examples:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Requests for <a id="id273" class="indexterm"/>any service must have headers that contain session details and user identities except for instances, such as logins, registers, and forgetting passwords</li><li class="listitem" style="list-style-type: disc">All requests made for a path starting with <code class="literal">admin</code> must be restricted by the user role</li><li class="listitem" style="list-style-type: disc">Redirect requests to regional sites if possible (such as Google)</li><li class="listitem" style="list-style-type: disc">Add additional fields to the request or response</li></ul></div><p>The <code class="literal">onRequestReceived</code>, <code class="literal">onRouteRequest</code>, <code class="literal">doFilter</code>, and <code class="literal">onRequestCompletion</code> methods can be used to intercept the request or its response and manipulate them as per requirements.</p><p>Let's look at the <code class="literal">onRequestReceived</code> method:</p><div class="informalexample"><pre class="programlisting">def onRequestReceived(request: RequestHeader): (RequestHeader, Handler) = {
    val notFoundHandler = Action.async(BodyParsers.parse.empty)(this.onHandlerNotFound)
    val (routedRequest, handler) = onRouteRequest(request) map {
      case handler: RequestTaggingHandler =&gt; (handler.tagRequest(request), handler)
      case otherHandler =&gt; (request, otherHandler)
    } getOrElse {
    // We automatically permit HEAD requests against any GETs without the need to
      // add an explicit mapping in Routes
      val missingHandler: Handler = request.method match {
        case HttpVerbs.HEAD =&gt;
          new HeadAction(onRouteRequest(request.copy(method = HttpVerbs.GET)).getOrElse(notFoundHandler))
        case _ =&gt;
          notFoundHandler
      }
      (request, missingHandler)
    }

    (routedRequest, doFilter(rh =&gt; handler)(routedRequest))
  }</pre></div><p>It fetches the <a id="id274" class="indexterm"/>corresponding handler for a <a id="id275" class="indexterm"/>given <code class="literal">RequestHeader</code> using the <code class="literal">onRouteRequest</code> and <code class="literal">doFilter</code> methods. If no handler is found, the result from <code class="literal">onHandlerNotFound</code> is sent.</p><p>Since the <code class="literal">onRequestReceived</code> method plays a critical role in how the requests are processed, sometimes it may be simpler to override the <code class="literal">onRouteRequest</code> method.</p><p>The <code class="literal">onRouteRequest</code> method is defined as follows:</p><div class="informalexample"><pre class="programlisting">def onRouteRequest(request: RequestHeader): Option[Handler] = Play.maybeApplication.flatMap(_.routes.flatMap {
    router =&gt;
      router.handlerFor(request)
  })</pre></div><p>Here, the router is the application's <code class="literal">router</code> object. By default, it is the generated object created from <code class="literal">conf/routes</code> on compilation. A router extends the <code class="literal">Router.Routes</code> trait and the <code class="literal">handlerFor</code> method is defined in this trait.</p><p>Let's try to implement <a id="id276" class="indexterm"/>a solution for blocking <a id="id277" class="indexterm"/>requests to services other than <code class="literal">login</code>, <code class="literal">forgotPassword</code>, and <code class="literal">register</code> if the request header does not have the session and user details. We can do so by overriding <code class="literal">onRouteRequest</code>:</p><div class="informalexample"><pre class="programlisting">override def onRouteRequest(requestHeader: RequestHeader) = {
    val path = requestHeader.path

    val pathConditions = path.equals("/") ||
      path.startsWith("/register") ||
      path.startsWith("/login") ||
      path.startsWith("/forgot")

   if (!pathConditions) {
      val tokenId = requestHeader.headers.get("Auth-Token")
      val userId = requestHeader.headers.get("Auth-User")
      if (tokenId.isDefined &amp;&amp; userId.isDefined) {
        val isValidSession = SessionDetails.validateSession(SessionDetails(userId.get.toLong, tokenId.get))
        if (isValidSession) {
          super.onRouteRequest(request)
        }
        else Some(controllers.SessionController.invalidSession)
      }
      else {
        Some(controllers.SessionController.invalidSession)
      }
    }
    else {
      super.onRouteRequest(request)
    }
  }</pre></div><p>First, we check if the requested path has restricted access. If so, we check if the necessary headers are available and valid. Only then is the corresponding <code class="literal">Handler</code> returned, else <code class="literal">Handler</code> for an invalid session is returned. A similar approach can be followed if we need to control the access based on the user's role.</p><p>We can also use the <code class="literal">onRouteRequest</code> method to provide compatibility for older deprecated services. For example, if the older version of the application had a <code class="literal">GET /user/:userId</code> service that has now been modified to <code class="literal">/api/user/:userId</code>, and there are other applications that rely on this application, our application should support requests for both the paths. However, the routes file only lists the new paths and services, which means that we should handle these before attempting to access the application's supported routes:</p><div class="informalexample"><pre class="programlisting">override def onRouteRequest(requestHeader: RequestHeader) = {
  val path = requestHeader.path

  val actualPath = getSupportedPath(path)
  val customRequestHeader = requestHeader.copy(path = actualPath)
   
  super.onRouteRequest(customRequestHeader)
}</pre></div><p>The <code class="literal">getSupportedPath</code> is a custom method that gives a new path for a given old path. We create a new <code class="literal">RequestHeader</code> with the updated fields and forward this to the following methods instead of the original <code class="literal">RequestHeader</code>.</p><p>Similarly, we could <a id="id278" class="indexterm"/>add/modify the headers or any other field(s) of <code class="literal">RequestHeader</code>.</p><p>The <code class="literal">doFilter</code> <a id="id279" class="indexterm"/>method can be used to add filters, similar to those shown in <a class="link" href="ch02.html" title="Chapter 2. Defining Actions">Chapter 2</a>, <span class="emphasis"><em>Defining Actions</em></span>:</p><div class="informalexample"><pre class="programlisting">object Global extends GlobalSettings {
  override def doFilter(action: EssentialAction): EssentialAction = HeadersFilter.noCache(action)
}</pre></div><p>Alternatively, we can extend the <code class="literal">WithFilters</code> class instead of <code class="literal">GlobalSettings</code>:</p><div class="informalexample"><pre class="programlisting">object Global extends WithFilters(new CSRFFilter()) with GlobalSettings</pre></div><p>The <code class="literal">WithFilters</code> class extends <code class="literal">GlobalSettings</code> and overrides the <code class="literal">doFilter</code> method with the <code class="literal">Filter</code> passed in its constructor. It is defined as follows:</p><div class="informalexample"><pre class="programlisting">class WithFilters(filters: EssentialFilter*) extends GlobalSettings {
  override def doFilter(a: EssentialAction): EssentialAction = {
    Filters(super.doFilter(a), filters: _*)
  }
}</pre></div><p>The <code class="literal">onRequestCompletion</code> method can be used to perform specific tasks after a request has been processed. For example, suppose that the application needs a requirement to persist data from specific GET requests, such as Search. This can come in handy to understand and analyze what the users are looking for in our application. Persisting information from requests prior to fetching data can considerably increase the response time and hamper user experience. Therefore, it will be better if this is done after the response has been sent:</p><div class="informalexample"><pre class="programlisting">override def onRequestCompletion(requestHeader: RequestHeader) {
  if(requestHeader.path.startsWith("/search")){
    //code to persist request parameters, time, etc
  }}</pre></div></div><div class="section" title="Tackling errors and exceptions"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec07"/>Tackling errors and exceptions</h3></div></div></div><p>An application <a id="id280" class="indexterm"/>cannot exist without handling <a id="id281" class="indexterm"/>errors and exceptions. Based on the business logic, the way they are handled may differ from application to application. Play provides certain standard implementations which can be overridden in the application's global object. The <code class="literal">onError</code> method is called when an exception occurs and is defined as follows:</p><div class="informalexample"><pre class="programlisting">  def onError(request: RequestHeader, ex: Throwable): Future[Result] = {
    def devError = views.html.defaultpages.devError(Option(System.getProperty("play.editor"))) _
    def prodError = views.html.defaultpages.error.f
    try {
      Future.successful(InternalServerError(Play.maybeApplication.map {
        case app if app.mode == Mode.Prod =&gt; prodError
        case app =&gt; devError
      }.getOrElse(devError) {
        ex match {
          case e: UsefulException =&gt; e
          case NonFatal(e) =&gt; UnexpectedException(unexpected = Some(e))
        }
      }))
    } catch {
      case NonFatal(e) =&gt; {
        Logger.error("Error while rendering default error page", e)
        Future.successful(InternalServerError)
      }
    }
  }</pre></div><p>
<code class="literal">UsefulException</code> is <a id="id282" class="indexterm"/>an abstract class, which extends <code class="literal">RuntimeException</code>. It is extended by the <code class="literal">PlayException</code> helper. The default implementation of <code class="literal">onError</code> (in the previous code snippet) simply checks whether the application <a id="id283" class="indexterm"/>is in the production mode or in the development mode and sends the corresponding view as <code class="literal">Result</code>. This method results in the <code class="literal">defaultpages.error</code> or <code class="literal">defaultpages.devError</code> view.</p><p>Suppose we want to send a response with a status 500 and the exception instead. We can easily do so by overriding the <code class="literal">onError</code> method:</p><div class="informalexample"><pre class="programlisting">override def onError(request: RequestHeader, ex: Throwable) = {
  log.error(ex)
  InternalServerError(ex.getMessage)
}</pre></div><p>The <code class="literal">onHandlerNotFound</code> method is called when a user sends a request with a path that is not defined in <code class="literal">conf/routes</code>. It is defined as follows:</p><div class="informalexample"><pre class="programlisting">def onHandlerNotFound(request: RequestHeader): Future[Result] = {
  Future.successful(NotFound(Play.maybeApplication.map {
    case app if app.mode != Mode.Prod =&gt; views.html.defaultpages.devNotFound.f
    case app =&gt; views.html.defaultpages.notFound.f
  }.getOrElse(views.html.defaultpages.devNotFound.f)(request, Play.maybeApplication.flatMap(_.routes))))
  }</pre></div><p>It sends a view as a response, depending on the mode in which the application was started. In the development mode, the view contains an error message, which tells us that an action is defined for the route and the list of supported paths with the request type. We can override this, if required.</p><p>The <code class="literal">onBadRequest</code> method is called in the following situations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The request is sent and its corresponding action has a different content type</li><li class="listitem" style="list-style-type: disc">Some of the parameters are missing in the request sent and, when parsing, the request throws an exception</li></ul></div><p>It is defined as follows:</p><div class="informalexample"><pre class="programlisting">def onBadRequest(request: RequestHeader,
  error: String): Future[Result] = {
    Future.successful(BadRequest(views.html.defaultpages.badRequest(request, error)))
}</pre></div><p>This method also sends a view in response but, in most applications, we would like to send <code class="literal">BadRequest</code> with <a id="id284" class="indexterm"/>the error message and not the <a id="id285" class="indexterm"/>view. This can be achieved by overriding the default implementation, as follows:</p><div class="informalexample"><pre class="programlisting">import play.api.mvc.{Result, RequestHeader,Results}
 override def onBadRequest(request: RequestHeader,
                           error: String): Future[Result] = {
    Future{
      Results.BadRequest(error)
    }
  }</pre></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec50"/>Summary</h1></div></div></div><p>In this chapter, we saw the features provided to a Play application through a global plugin. By extending <code class="literal">GlobalSettings</code>, we can hook into the application's life cycle and perform various tasks at different phases. Apart from hooks used for the application life cycle, we have also discussed hooks for the request-response life cycle, through which we can intercept requests and responses and modify them, if required.</p></div></body></html>