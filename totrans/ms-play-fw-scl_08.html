<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;WebSockets and Actors"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. WebSockets and Actors</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introduction to WebSockets</li><li class="listitem" style="list-style-type: disc">Actor Model and Akka Actors</li><li class="listitem" style="list-style-type: disc">WebSockets in Play: using Iteratees and Actors</li><li class="listitem" style="list-style-type: disc">FrameFormatters</li></ul></div><div class="section" title="An introduction to WebSockets"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec51"/>An introduction to WebSockets</h1></div></div></div><p>Picture this:</p><p>A moviegoer is <a id="id286" class="indexterm"/>trying to purchase movie tickets online. He or she has selected the seats, entered the payment details, and submitted. He or she gets an error message saying that the tickets they tried to book have sold out.</p><p>Consider an application, which gives detailed information about the stock market and allows purchasing/selling stocks. When someone enters payment details and submits these details, they get an error saying that the purchase has been rejected as the price of the stock has now changed.</p><p>Initially, in applications where real-time data was required over HTTP, developers realized that they needed bidirectional communication between the client side and server side. It was generally implemented using one of the following approaches:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Polling</strong></span>: Requests are <a id="id287" class="indexterm"/>sent from the client side at fixed and regular intervals. The server responds within a short span (less than 1 second or so) with a result for each request made.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Long-polling</strong></span>: When a <a id="id288" class="indexterm"/>request is sent, the server does not respond with a result unless there has been a change in the state within a specified time period. A request is fired after a response is received from the server. Therefore, the client side makes repeated requests as and when it gets the response for the previous one.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Streaming</strong></span>: A <a id="id289" class="indexterm"/>request to the server results in an open response, which is continuously updated and kept open indefinitely.</li></ul></div><p>Although these approaches worked, using them led to some problems:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It led to an increase in the number of TCP connections per client</li><li class="listitem" style="list-style-type: disc">There was a high overhead of HTTP Header Overhead while mapping a response to its corresponding request on the client side</li></ul></div><p>In 2011, a protocol that uses a single TCP connection for bidirectional traffic, WebSocket (RFC6455), was standardized by the <span class="strong"><strong>Internet Engineering Task Force</strong></span> (<span class="strong"><strong>IETF</strong></span>). By September 20, 2012, the <span class="strong"><strong>World Wide Web Consortium</strong></span> (<span class="strong"><strong>W3C</strong></span>) came up with the specifications for a WebSocket API.</p><p>Unlike HTTP, there is no request-response cycle in a WebSocket. Once connected, the client and server can send messages to each other. The communication can be by server and by client, that is, a two-way full duplex communication.</p><p>According to the <a id="id290" class="indexterm"/>WebSocket API:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A WebSocket connection can be established by invoking the constructor, such as <code class="literal">WebSocket(url, protocols)</code></li><li class="listitem" style="list-style-type: disc">Data can be sent to the server via a connection using the <code class="literal">send(data)</code> method</li><li class="listitem" style="list-style-type: disc">Calling <code class="literal">close()</code> will result in closing the connection</li><li class="listitem" style="list-style-type: disc">The following event handlers can be defined on the client side:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">onopen</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">onmessage</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">onerror</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">onclose</code></li></ul></div></li></ul></div><p>A snippet using JavaScript is shown here:</p><div class="informalexample"><pre class="programlisting">var webSocket = new WebSocket('ws://localhost:9000');
webSocket.onopen = function () {
  webSocket.send("hello");
};
webSocket.onmessage = function (event) {
  console.log(event.data);
};
webSocket.onclose = function () {
  alert("oops!! Disconnected")
}</pre></div></div></div>
<div class="section" title="WebSockets in Play"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec52"/>WebSockets in Play</h1></div></div></div><p>
<span class="strong"><strong>WebSockets</strong></span> cannot be <a id="id291" class="indexterm"/>defined using Action since they should be bidirectional. Play <a id="id292" class="indexterm"/>provides a helper to assist with WebSockets, which is documented at <a class="ulink" href="https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.mvc.WebSocket$">https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.mvc.WebSocket$</a>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>WebSockets, which <a id="id293" class="indexterm"/>are defined using the helper, use the Play server's underlying TCP port.</p></div></div><p>WebSockets can be defined similarly to Actions in Play applications. Starting from Play 2.3, a WebSocket helper finds a method to define WebSocket interactions using an Actor. However, before we learn more about the methods provided by the helper, let's take a small detour and get a little familiar with the <span class="strong"><strong>Actor Model</strong></span> and <span class="strong"><strong>Akka Actors</strong></span>.</p></div>
<div class="section" title="Actor Model"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec53"/>Actor Model</h1></div></div></div><p>Concurrency in <a id="id294" class="indexterm"/>programming can be achieved by using <span class="emphasis"><em>Threads</em></span> which may include the risk of a lost update or a deadlock. The Actor Model facilitates concurrency by utilizing asynchronous communication.</p><p>According to the Actor Model, an actor is the fundamental unit of computation. It cannot exist independently, that is, it is always part of a specific actor system. An actor can send messages to one or more actors within its actor system if it knows the address of the other actor. It can also send messages to itself. The order in which the messages are sent or received cannot be guaranteed since the communication is asynchronous.</p><p>When an actor receives a message, it can do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Forward it to another actor whose address is known to it</li><li class="listitem" style="list-style-type: disc">Create more actors</li><li class="listitem" style="list-style-type: disc">Designate the action it will take for the next message</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>The Actor Model was first described in August 1973 in a publication by Carl Hewitt, Peter Bishop and Richard Steiger in the paper <span class="emphasis"><em>A Universal Modular ACTOR Formalism for Artificial Intelligence</em></span>, which was a part of the International Joint Conference on Artificial Intelligence (IJCAI'73).</p></div></div></div>
<div class="section" title="Introducing Akka Actors"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec54"/>Introducing Akka Actors</h1></div></div></div><p>
<span class="strong"><strong>Akka</strong></span> is a part of the <a id="id295" class="indexterm"/>Typesafe Reactive Platform, which is similar to the Play Framework. According to their website:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Akka is a toolkit and runtime used to build highly concurrent, distributed, and fault-tolerant event-driven applications on the JVM.</em></span></p></blockquote></div><p>Akka implements a version of the Actor Model, which is commonly called Akka Actors and is available for both Java and Scala. According to the Akka documentation, Actors give you:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Simple and high-level abstractions for concurrency and parallelism</li><li class="listitem" style="list-style-type: disc">Asynchronous, nonblocking, and highly performant event-driven programming model</li><li class="listitem" style="list-style-type: disc">Very lightweight event-driven processes (several million actors per GB of heap memory)</li></ul></div><p>Akka Actors are available as <a id="id296" class="indexterm"/>a library and can be used within a project by adding them into the dependencies:</p><div class="informalexample"><pre class="programlisting">libraryDependencies ++= Seq(
  "com.typesafe.akka" %% "akka-actor" % "2.3.4"
)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>Adding a dependency in Akka explicitly is not required in a Play project as Play uses Akka internally.</p></div></div><p>We can then define an actor by extending the Actor trait and defining the behavior in the <code class="literal">receive</code> method. Let's build an Actor, which reverses any string message it receives:</p><div class="informalexample"><pre class="programlisting">class Reverser extends Actor {

  def receive = {
    case s:String =&gt; println( s.reverse)
    case _ =&gt; println("Sorry, didn't quite understand that. I can only process a String.")
  }
}

object Reverser {
  def props = Props(classOf[Reverser])
}</pre></div><p>To use the actor, we first need to initialize <code class="literal">ActorSystem</code>:</p><div class="informalexample"><pre class="programlisting">val system = ActorSystem("demoSystem")</pre></div><p>Now we can get a reference of the actor by using the <code class="literal">actorOf</code> method:</p><div class="informalexample"><pre class="programlisting">val demoActor = system.actorOf(Reverser.props, name = "demoActor")</pre></div><p>This reference can then be used to send messages:</p><div class="informalexample"><pre class="programlisting">demoActor ! "Hello, How do u do?"
demoActor ! "Been Long since we spoke"
demoActor ! 12345</pre></div><p>Now let's run the application and see what the actor does:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; run</strong></span>
<span class="strong"><strong>[info] Compiling 1 Scala source to /AkkaActorDemo/target/scala-2.10/classes...</strong></span>
<span class="strong"><strong>[info] Running com.demo.Main</strong></span>
<span class="strong"><strong>?od u od woH ,olleH</strong></span>
<span class="strong"><strong>ekops ew ecnis gnoL neeB</strong></span>
<span class="strong"><strong>Sorry, didn't quite understand that I can only process a String.</strong></span>
</pre></div><p>Suppose we wanted to <a id="id297" class="indexterm"/>define an Actor that accepted <code class="literal">minLength</code> and <code class="literal">MaxLength</code> as arguments, we would need to modify the <code class="literal">Reverser</code> class and its companion as follows:</p><div class="informalexample"><pre class="programlisting">class ReverserWithLimit(min:Int,max:Int) extends Actor {

  def receive = {
    case s:String if (s.length&gt; min &amp; s.length&lt;max)=&gt; println( s.reverse)
    case _ =&gt; println(s"Sorry, didn't quite understand that. I can only process a String of length $min-$max.")  }
}

object ReverserWithLimit {
  def props(min:Int,max:Int) = Props(classOf[Reverser],min,max)
}</pre></div><p>For more details on Akka <a id="id298" class="indexterm"/>actors, refer to <a class="ulink" href="http://akka.io/docs/">http://akka.io/docs/</a>.</p></div>
<div class="section" title="WebSocket using Iteratee"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec55"/>WebSocket using Iteratee</h1></div></div></div><p>Let's define a WebSocket <a id="id299" class="indexterm"/>connection, which accepts strings and <a id="id300" class="indexterm"/>sends back the reverse of a string using <span class="strong"><strong>Iteratee</strong></span>:</p><div class="informalexample"><pre class="programlisting"> def websocketBroadcast = WebSocket.using[String] {
    request =&gt;
      val (out, channel) = Concurrent.broadcast[String]
      val in = Iteratee.foreach[String] {
        word =&gt; channel.push(word.reverse)
      }
      (in, out)
  }</pre></div><p>The <code class="literal">WebSocket.using</code> method creates a WebSocket of a specific type using an Iteratee (inbound channel) and its corresponding enumerator (outbound channel). In the preceding code snippet, we return a tuple of the Iteratee in and the Enumerator out.</p><p>The <code class="literal">Concurrent</code> object is also a helper, which provides utilities to use Iteratees, Enumerators, and Enumeratees concurrently. The <code class="literal">broadcast[E]</code> method creates an Enumerator and a channel and returns a <code class="literal">(Enumerator[E], Channel[E])</code> tuple. The Enumerator and channel, thus obtained, can be used to broadcast data to multiple Iteratees.</p><p>After this, we need to bind it to a path in the routes file, which is similar to what we do for an Action:</p><div class="informalexample"><pre class="programlisting">GET        /ws                  controllers.Application.websocketBroadcast</pre></div><p>Now, using a browser plugin, such as <a id="id301" class="indexterm"/>simple WebSocket client for Chrome (refer to <a class="ulink" href="https://chrome.google.com/webstore/detail/simple-websocket-client/pfdhoblngboilpfeibdedpjgfnlcodoo">https://chrome.google.com/webstore/detail/simple-websocket-client/pfdhoblngboilpfeibdedpjgfnlcodoo</a>), we can send messages through the WebSocket when an <a id="id302" class="indexterm"/>application is running, as shown here:</p><div class="mediaobject"><img src="graphics/3803OS_08_01.jpg" alt="WebSocket using Iteratee"/></div><p>Since we do not use multiple Iteratees in our application, we can use <code class="literal">Concurrent.unicast</code>. This will require us to modify our code slightly:</p><div class="informalexample"><pre class="programlisting"> def websocketUnicast = WebSocket.using[String] {
    request =&gt;
      var channel: Concurrent.Channel[String] = null
      val out = Concurrent.unicast[String] {
        ch =&gt;
          channel = ch
      }
      val in = Iteratee.foreach[String] {
        word =&gt; channel.push(word.reverse)
      }
      (in, out)
  }</pre></div><p>Notice that, unlike the <code class="literal">broadcast</code> method, the <code class="literal">unicast</code> method does not return a tuple of enumerators and channels, but instead only provides an enumerator. We have to declare a channel variable and <a id="id303" class="indexterm"/>initialize it with null, so that it is accessible within the <a id="id304" class="indexterm"/>Iteratee. When the <code class="literal">unicast</code> method is called, it is set to the channel generated within the <code class="literal">unicast</code> method.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>The <code class="literal">unicast</code> method also allows us to define the <code class="literal">onComplete</code> and <code class="literal">onError</code> methods, but they are not aware of the Iteratee, that is, we cannot refer to the Iteratee within these methods.</p></div></div><p>This example is overtly simple and does not highlight the complications involved in defining and using Iteratees. Let's try a more challenging use case. Now, we might need to build a web application that lets users connect to their database and load/view data over a WebSocket. Given this condition, the frontend sends JSON messages.</p><p>Now the WebSocket can get any of the following messages:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Connection request</strong></span>: It is a message that shows the information required to connect to a database (such as a host, port, user ID, and password)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Query string</strong></span>: It is the query to be executed in the database</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Disconnect request</strong></span>: It is a message that closes a connection with the database</li></ul></div><p>After this, the message is translated and sent to the <span class="strong"><strong>DBActor</strong></span>, which sends back a status message or a result with row data, and is then translated to JSON and sent back by the WebSocket.</p><p>The response received from the DBActor can be one of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A successful connection</li><li class="listitem" style="list-style-type: disc">Connection failure</li><li class="listitem" style="list-style-type: disc">Query result</li><li class="listitem" style="list-style-type: disc">Invalid query</li><li class="listitem" style="list-style-type: disc">Disconnected<div class="informalexample"><pre class="programlisting">def dbWebsocket = WebSocket.using[JsValue] {
    request =&gt;
      WebSocketChannel.init
  }</pre></div></li></ul></div><p>We can define a WebSocket handler for this scenario in the following manner:</p><p>Here, <code class="literal">WebSocketChannel</code> <a id="id305" class="indexterm"/>is an actor, which communicates with the <a id="id306" class="indexterm"/>DBActor and its companion object and is defined as follows:</p><div class="informalexample"><pre class="programlisting">object WebSocketChannel {
  def props(channel: Concurrent.Channel[JsValue]): Props =
    Props(classOf[WebSocketChannel], channel)

  def init: (Iteratee[JsValue, _], Enumerator[JsValue]) = {

    var actor: ActorRef = null
    val out = Concurrent.unicast[JsValue] {
      channel =&gt;
        actor = Akka.system.actorOf(WebSocketChannel.props(channel))
    }

    val in = Iteratee.foreach[JsValue] {
      jsReq =&gt; actor ! jsReq
    }
    (in, out)
  }
}</pre></div><p>
<code class="literal">WebSocketChannel</code> is defined as follows:</p><div class="informalexample"><pre class="programlisting">class WebSocketChannel(wsChannel: Concurrent.Channel[JsValue])
  extends Actor with ActorLogging {

  val backend = Akka.system.actorOf(Props(classOf[DBActor]))

  def receive: Actor.Receive = {
    case jsRequest: JsValue =&gt;
      backend ! convertJson(jsRequest)
    case x: DBResponse =&gt;
      wsChannel.push(x.toJson)
  }
}</pre></div><p>In the preceding code, <code class="literal">convertJson</code> translates <code class="literal">JsValue</code> to the format that is understood by the DBActor.</p><p>In the following section, we <a id="id307" class="indexterm"/>will implement the same application using the new <a id="id308" class="indexterm"/>WebSocket methods available in Play since the 2.3.x version.</p></div>
<div class="section" title="WebSocket using Actors without Iteratees"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec56"/>WebSocket using Actors without Iteratees</h1></div></div></div><p>The Play <a id="id309" class="indexterm"/>WebSocket API allows the use of Actors <a id="id310" class="indexterm"/>to define the behavior. Let's build the WebSocket application that replies with the reverse of a given String once it's connected. We can do this by slightly modifying our Reverser Actor to have an argument as the reference of the Actor to which it can/must send messages, as shown here:</p><div class="informalexample"><pre class="programlisting">class Reverser(outChannel: ActorRef) extends Actor {

    def receive = {
      case s: String =&gt; outChannel ! s.reverse
    }
  }

object Reverser {
  def props(outChannel: ActorRef) = Props(classOf[Reverser], outChannel)
}</pre></div><p>The <code class="literal">websocket</code> can then be defined in a controller as follows:</p><div class="informalexample"><pre class="programlisting">def websocket = WebSocket.acceptWithActor[String, String] {
  request =&gt; out =&gt;
    Reverser.props(out)
}</pre></div><p>Finally, we make an entry in the routes file:</p><div class="informalexample"><pre class="programlisting">GET        /wsActor                  controllers.Application.websocket</pre></div><p>We can now send messages through the WebSocket when the application is running using a browser plugin.</p><p>Now, lets try to implement <code class="literal">dbWebSocket</code> using this method:</p><div class="informalexample"><pre class="programlisting"> def dbCommunicator = WebSocket.acceptWithActor[JsValue, JsValue] {
    request =&gt; out =&gt;
      WebSocketChannel.props(out)
  }</pre></div><p>Here, <code class="literal">WebSocketChannel</code> is defined as follows:</p><div class="informalexample"><pre class="programlisting">class WebSocketChannel(out: ActorRef)
  extends Actor with ActorLogging {

  <span class="strong"><strong>val backend = Akka.system.actorOf(DBActor.props)</strong></span>
  def receive: Actor.Receive = {
    case jsRequest: JsValue =&gt;
      backend ! convertJsonToMsg(jsRequest)
    case x:DBResponse =&gt;
      out ! x.toJson
  }
}

object WebSocketChannel {
  def props(out: ActorRef): Props =
    Props(classOf[WebSocketChannel], out)
}</pre></div><p>The <a id="id311" class="indexterm"/>
<code class="literal">convertJsonToMsg</code> method is responsible for <a id="id312" class="indexterm"/>translating JSON to a format that is accepted by the DBActor.</p></div>
<div class="section" title="Closing a WebSocket"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec57"/>Closing a WebSocket</h1></div></div></div><p>When the <a id="id313" class="indexterm"/>WebSocket is closed, Play automatically stops the actor bound to it. This binding works in two ways: the WebSocket connection is closed when the underlying actor is killed. If there is a need to free any resources once the connection is closed, we can do so by overriding the actor's <code class="literal">postStop</code> method. In our example, we have initialized a DBActor within <code class="literal">WebSocketChannel</code>. We will need to ensure that it's killed once the WebSocket is closed, since each connection to the WebSocket will lead to the initialization of a DBActor. We can do so by sending it a poison pill, as shown here:</p><div class="informalexample"><pre class="programlisting">override def postStop() = {
  backend ! PoisonPill
}</pre></div><div class="section" title="Using FrameFormatter"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec31"/>Using FrameFormatter</h2></div></div></div><p>Suppose that an <a id="id314" class="indexterm"/>incoming JSON has the same fields for every request, instead of <a id="id315" class="indexterm"/>parsing it every time; we can define an equivalent class in this way:</p><div class="informalexample"><pre class="programlisting">case class WebsocketRequest(reqType:String, message:String)</pre></div><p>Now, we can define our WebSocket to translate the JSON message to a <code class="literal">WebSocketRequest</code> automatically. This is possible by specifying the data type for the <code class="literal">acceptWithActor</code> method:</p><div class="informalexample"><pre class="programlisting">def websocketFormatted = WebSocket.acceptWithActor[WebsocketRequest, JsValue]{
  request =&gt; out =&gt;
  SomeActor.props(out)
}</pre></div><p>However, for this to work as expected, we need two implicit values. The first is for translating incoming frames to <code class="literal">WebsocketRequest</code>, which requires a <code class="literal">JsValue</code> to the <code class="literal">WebSocketRequest</code> formatter:</p><div class="informalexample"><pre class="programlisting">implicit val requestFormat = Json.format[WebsocketRequest]
implicit val requestFrameFormatter = FrameFormatter.jsonFrame[WebsocketRequest]</pre></div><p>Similarly, we can specify the types of the outgoing messages as well:</p><p>
<code class="literal">FrameFormatter</code> is <a id="id316" class="indexterm"/>a helper and can convert <code class="literal">org.jboss.netty.handler.codec.http.websocketx.WebSocketFrame</code> to <code class="literal">play.core.server.websocket.Frames</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>The WebSocket methods do not validate the format of data received automatically in the same manner as Action parsers. We will need to do this additionally, if required.</p></div></div></div></div>
<div class="section" title="Troubleshooting"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec58"/>Troubleshooting</h1></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What is the equivalent <a id="id317" class="indexterm"/>of interrupting <code class="literal">Actions</code> in <code class="literal">GlobalSettings</code> for <code class="literal">WebSockets</code>? What if we want to refuse a WebSocket connection when certain headers are missing? Something similar to the following code snippet didn't work as expected:<div class="informalexample"><pre class="programlisting">override def onRouteRequest(request: RequestHeader): Option[Handler] = {
    if(request.path.startsWith("/ws")){
      Option(controllers.Default.error)
    } else
      super.onRouteRequest(request)
  }</pre></div><p>Interrupting WebSocket from the global object does not work as it does for Actions. However, there are other means of doing so: by using the <code class="literal">tryAccept</code> and <code class="literal">tryAcceptWithActor</code> methods. A WebSocket definition can be replaced by the following code:</p><div class="informalexample"><pre class="programlisting">def wsWithHeader = WebSocket.tryAccept[String] {
    rh =&gt;
      Future.successful(rh.headers.get("token") match {
        case Some(x) =&gt;
          var channel: Concurrent.Channel[String] = null
          val out = Concurrent.unicast[String] {
            ch =&gt;
              channel = ch
          }
          val in = Iteratee.foreach[String] {
            word =&gt; channel.push(word.reverse)
          }
          Right(in, out)
        case _ =&gt; Left(Forbidden)
      })
  }</pre></div><p>When using an Actor, define a WebSocket with the <code class="literal">tryAcceptWithActor</code> method:</p><div class="informalexample"><pre class="programlisting">def wsheaders = WebSocket.tryAcceptWithActor[String, String] {
    request =&gt;
      Future.successful(request.headers.get("token") match {
        case Some(x) =&gt; Right(out =&gt; Reverser.props(out))
        case _ =&gt; Left(Forbidden)
      })
  }</pre></div><p>In the preceding examples, we are only checking to see if there is a token header, but this can be updated to any other criteria.</p></li><li class="listitem" style="list-style-type: disc">Does Play support wss?<p>As of 2.3.x, there is no built-in support for wss. However, it's possible to use proxies, such as Nginx or HAProxy as the secure WebSocket (wss) endpoint and forward to an internal Play app with an insecure WebSocket endpoint.</p></li></ul></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec59"/>Summary</h1></div></div></div><p>We have learned a couple of things in this chapter. This chapter briefly covered the Actor Model and usage of Akka Actors in an application. In addition to this, we defined a WebSocket connection in a Play application with various constraints and requirements using two different approaches: the first one where we use Iteratees and Enumerators, and the second where we use Akka Actors.</p><p>In the next chapter, we will see the different ways in which we can test a Play application using <span class="strong"><strong>Specs2</strong></span> and <span class="strong"><strong>ScalaTest</strong></span>.</p></div></body></html>