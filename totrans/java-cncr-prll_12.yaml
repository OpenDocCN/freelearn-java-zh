- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Horizon Ahead
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As cloud technologies continue to evolve at a rapid pace, it is crucial for
    developers and organizations to stay ahead of the curve and prepare for the next
    wave of innovations. This chapter will explore the emerging trends and advancements
    in the cloud computing landscape, with a particular focus on Java’s role in shaping
    these future developments.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by examining the evolution of serverless Java, where frameworks
    such as Quarkus and Micronaut are redefining the boundaries of **functions as
    a service**. These tools leverage innovative techniques, such as native image
    compilation, to deliver unprecedented performance and efficiency in serverless
    environments. Additionally, we will delve into the concept of serverless containers,
    which allow for the deployment of entire Java applications in a serverless fashion,
    harnessing the benefits of container orchestration platforms such as Kubernetes
    and **Amazon Web Services** (**AWS**) Fargate.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore the role of Java in the emerging paradigm of edge computing.
    As data processing and decision-making move closer to the source, Java’s platform
    independence, performance, and extensive ecosystem make it an ideal candidate
    for building edge applications. We will discuss the key frameworks and tools that
    enable Java developers to leverage the power of edge computing architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we will investigate Java’s evolving position in the integration
    of **artificial intelligence** (**AI**) and **machine learning** (**ML**) within
    cloud-based ecosystems. From serverless AI/ML workflows to the seamless integration
    of Java with cloud-based AI services, we will explore the opportunities and challenges
    that this convergence presents.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will delve into the captivating realm of **quantum computing**,
    a field that promises to revolutionize various industries. While still in its
    early stages, understanding the fundamental principles of quantum computing, such
    as qubits, quantum gates, and algorithms, can prepare developers for future advancements
    and their potential integration with Java-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a comprehensive understanding of the
    emerging trends in cloud computing and Java’s pivotal role in shaping these innovations.
    You will be equipped with the knowledge and practical examples to position your
    applications and infrastructure for success in the rapidly evolving cloud landscape.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the key topics that will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Future trends in cloud computing and Java’s role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edge computing and Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AI and ML integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emerging concurrency and parallel processing tools in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing for the next wave of cloud innovations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To fully engage with [*Chapter 12*](B20937_12.xhtml#_idTextAnchor295)’s content
    and examples, ensure the following are installed and configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Development Kit** **or JDK**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Quarkus requires a JDK to run. If you don’t have one, download and install
    a recent version (JDK 17 or newer is recommended) from the official source:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AdoptOpenJDK**: [https://adoptium.net/](https://adoptium.net/)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenJDK**: [https://openjdk.org/](https://openjdk.org/)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`choco install quarkus`) or Scoop (`scoop` `install quarkus`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, use JBang (`jbang app install --``fresh quarkus@quarkusio`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quarkus CLI installation** **guide**: [https://quarkus.io/guides/cli-tooling](https://quarkus.io/guides/cli-tooling)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GRAALVM_HOME` environment variable to the GraalVM installation directory.*   Add
    `%GRAALVM_HOME%\bin` to your PATH environment variable.*   **Docker Desktop**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download and install Docker Desktop for Windows from [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the installation wizard and configure Docker as needed.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code in this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
  prefs: []
  type: TYPE_NORMAL
- en: Future trends in cloud computing and Java’s role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As cloud computing continues to evolve, several emerging trends are shaping
    the future of this technology landscape. Innovations such as edge computing, AI
    and ML integration, and serverless architectures are at the forefront, driving
    new possibilities and efficiencies. Java, with its robust ecosystem and continuous
    advancements, is playing a pivotal role in these developments. This section will
    explore the latest trends in cloud computing, how Java is adapting to and facilitating
    these changes, and provide real-world examples of Java’s adoption in cutting-edge
    cloud technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Emerging trends in cloud computing – serverless Java beyond function as a service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Emerging trends in cloud computing are reshaping the landscape of serverless
    Java, extending beyond the traditional functions-as-a-service model. Innovations
    in serverless Java frameworks such as Quarkus and Micronaut are driving this evolution.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Quarkus**, recognized for its strengths in microservices, is now making a
    substantial impact in serverless environments. It empowers developers to build
    serverless functions that adhere to microservice principles, seamlessly merging
    these two architectural approaches. A standout feature is Quarkus’ native integration
    with GraalVM, enabling the compilation of Java applications into native executables.
    This is a game-changer for serverless computing, as it tackles the long-standing
    issue of cold start latency. By harnessing GraalVM, Quarkus dramatically reduces
    startup times for Java applications, often from seconds to mere milliseconds,
    compared to traditional **Java virtual machine** (**JVM**) based alternatives.
    Moreover, the resulting native binaries are more memory efficient, facilitating
    optimized scaling and resource utilization in the dynamic world of serverless
    environments. These advancements are revolutionizing serverless Java, providing
    developers with a powerful toolkit to create high-performance, cloud-native applications
    that are both efficient and responsive.'
  prefs: []
  type: TYPE_NORMAL
- en: Micronaut
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Micronaut** is another innovative framework making significant progress in
    the serverless Java space. It is designed to optimize the performance of microservices
    and serverless applications through several key features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compile-time dependency injection**: Unlike traditional frameworks that resolve
    dependencies at runtime, Micronaut performs this task during compilation. This
    approach eliminates the need for runtime reflection, resulting in faster startup
    times and reduced memory consumption.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aspect-oriented programming (AOP)**: AOP is a programming paradigm that increases
    modularity by allowing the separation of cross-cutting concerns. In Micronaut,
    AOP is implemented at compile time rather than runtime. This means that features
    such as transaction management, security, and caching are woven into the bytecode
    during compilation, eliminating the need for runtime proxies and further reducing
    memory usage and startup time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These compile-time techniques make Micronaut an ideal choice for building lightweight,
    fast, and efficient serverless applications. The framework’s design is particularly
    well suited to environments where rapid startup and low resource consumption are
    crucial.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, Micronaut supports the creation of GraalVM native images. This
    feature further enhances its suitability for serverless environments by minimizing
    cold start times and resource usage, as native images can start almost instantaneously
    and consume less memory compared to traditional JVM-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless containers and Java applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Serverless containers represent another dimension of serverless computing, enabling
    the deployment of entire Java applications rather than individual functions. This
    approach leverages container orchestration platforms such as Kubernetes and AWS
    Fargate to run containers in a serverless fashion. Java applications packaged
    as containers benefit from the same serverless advantages of automatic scaling
    and pay-per-use pricing, but with more control over the runtime environment compared
    to traditional serverless functions. Developers can ensure consistency across
    different environments by packaging the application with its dependencies. Full
    control over the runtime environment allows for the inclusion of necessary libraries
    and tools, providing flexibility that is sometimes lacking in traditional serverless
    functions. Additionally, serverless containers can scale automatically based on
    demand, offering the benefits of serverless computing while maintaining the robustness
    of containerized applications.
  prefs: []
  type: TYPE_NORMAL
- en: By combining the innovations in serverless Java frameworks such as Quarkus and
    Micronaut with the flexibility of serverless containers, developers can create
    highly scalable, efficient, and responsive Java applications that meet the demands
    of modern cloud-native environments. These advancements are paving the way for
    the next generation of serverless Java, moving beyond simple functions to encompass
    full-fledged applications and services.
  prefs: []
  type: TYPE_NORMAL
- en: Example use-case – building a serverless REST API with Quarkus and GraalVM
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Objective**: Create a serverless REST API for product management and deploy
    it on AWS Lambda using Quarkus, demonstrating key Quarkus features and integration
    with AWS services.'
  prefs: []
  type: TYPE_NORMAL
- en: This example covers key concepts and elements of Quarkus. The full application
    will be available in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: '**Set up the project**: Use Quarkus CLI or Maven to bootstrap a new project.
    For this example, we’ll use Maven. Run the following Maven command to create the
    Quarkus project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@Path("/api/products")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Produces(MediaType.APPLICATION_JSON)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Consumes(MediaType.APPLICATION_JSON)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Tag(name = "Product",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: description = "Product management operations")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public class ProductResource {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Inject'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ProductRepository productRepository;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@GET'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Counted(name = "getAllProductsCount",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: description = "How many times getAllProducts has been         invoked")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Timed(name = "getAllProductsTimer",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: description = "A measure of how long it takes to perform         getAllProducts",
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: unit = MetricUnits.MILLISECONDS)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Operation(summary = "Get all products",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: description = "Returns a list of all products with         pagination and sorting")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public Response getAllProducts(@QueryParam(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"page") @DefaultValue("0") int page,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@QueryParam("size") @DefaultValue("20") int size,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@QueryParam("sort") @DefaultValue("name") String             sort) {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Implementation omitted for brevity
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@POST'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Operation(summary = "Create a new product",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: description = "Creates a new product and returns the         created product")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public Response createProduct(Product product) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Implementation omitted for brevity
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Additional CRUD methods omitted for brevity
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ProductRepository`: The `ProductRepository` class acts as the data access
    layer, managing interactions with *AWS DynamoDB* for product data persistence.
    It demonstrates Quarkus’ seamless integration with AWS `DynamoDbClient`, showcasing
    how Quarkus simplifies cloud service integration. It implements methods for **create,
    read, update, and delete** (**CRUD**) operations, translating between Java objects
    and DynamoDB item representations, thus demonstrating how Quarkus applications
    can efficiently work with NoSQL databases in a cloud environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ImageAnalysisCoordinator`: The `ImageAnalysisCoordinator` class showcases
    Quarkus’ ability to create AWS Lambda functions that interact with multiple AWS
    services. It demonstrates handling **Simple Storage Service** (**S3**) events
    and triggering **Elastic Container Service** (**ECS**) tasks, illustrating how
    Quarkus can be used to build complex, event-driven architectures. This class uses
    dependency injection for AWS clients (ECS and S3), showing how Quarkus simplifies
    working with multiple cloud services in a single component. It’s an excellent
    example of using Quarkus for serverless applications that orchestrate other AWS
    services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ProductHealthCheck`: The `ProductHealthCheck` class implements Quarkus’ health
    check mechanism, which is crucial for maintaining application reliability in cloud
    environments. It demonstrates the use of Microprofile Health, allowing the application
    to report its status to orchestration systems such as Kubernetes. The class checks
    the accessibility of the DynamoDB table, showcasing how Quarkus applications can
    provide meaningful health information about external dependencies. This component
    is essential for implementing robust microservices that can self-report their
    operational status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`pom.xml` file includes a profile for native builds. This will specify the
    necessary dependencies and plugins for GraalVM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Dockerfile.native`: The provided Dockerfile is essential for building and
    packaging a Quarkus application with GraalVM for deployment on AWS Lambda. It
    starts by using a GraalVM image to compile the application into a native executable,
    ensuring optimal performance and minimal startup time. The build stage includes
    copying the project files and running the Maven build process. Subsequently, the
    runtime stage uses a minimal base image to keep the final image lightweight. The
    compiled native executable is copied from the build stage to the runtime stage,
    where it is set as the entry point for the container. This setup guarantees a
    streamlined and efficient deployment process for serverless environments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This Dockerfile describes a two-stage build process for a Quarkus native application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build stage**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uses a GraalVM-based image to compile the application
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Copies project files and builds a native executable
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime stage**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uses a minimal Red Hat UBI as the base image
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Copies the native executable from the build stage
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the executable as the entry point
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multi-stage builds have the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Smaller image size**: The final image is lean, containing only the necessary
    runtime dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved security**: Reduces the attack surface by including fewer tools
    and packages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clear separation**: Simplifies maintenance by separating the build environment
    from the runtime environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note for Apple Silicon Users
  prefs: []
  type: TYPE_NORMAL
- en: When building Docker images on Apple Silicon (M1 or M2) devices, you might encounter
    compatibility issues due to the default **Advance RISC Machine** (**ARM**) architecture.
    Most cloud environments, including AWS, Azure, and Google Cloud, use AMD64 (x86_64)
    architecture. To avoid these issues, specify the target platform when building
    Docker images to ensure compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Specify the `--platform` argument when building Docker images on Apple Silicon
    devices to ensure compatibility with cloud environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, use the following command to build an image compatible with AMD64
    architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'While the `application.properties` file is not directly used for enabling native
    builds, you can include properties to optimize the application for running as
    a native image. Here is a sample `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Deploy to** **AWS Lambda:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`Template.yaml`: An AWS **Serverless Application Model** (**SAM**) template
    that defines the infrastructure for our Quarkus-based Lambda function, specifying
    its runtime environment, handler, resource allocations, and necessary permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`.``jar` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Deploy with SAM CLI**: Use the AWS SAM CLI to package and deploy our Quarkus-based
    Lambda function: the first command packages the application and uploads it to
    an Amazon S3 bucket, while the second command deploys the packaged application
    to AWS, creating or updating a CloudFormation stack with the necessary resources
    and permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By following these steps, you will have successfully built a serverless REST
    API using Quarkus, packaged it as a native image with GraalVM, and deployed it
    to AWS Lambda. This setup ensures optimal performance and reduces cold start times
    for your serverless application.
  prefs: []
  type: TYPE_NORMAL
- en: The serverless paradigm continues to evolve, with Java frameworks such as Quarkus
    leading the charge in optimizing for cloud-native, serverless environments. As
    we’ve seen, modern serverless Java applications can leverage advanced features
    such as rapid startup times, low memory footprints, and seamless integration with
    cloud services. This enables developers to build complex, scalable applications
    that go far beyond simple function executions, encompassing full-fledged microservices
    architectures.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the cloud computing landscape continues to evolve, another emerging trend
    is gaining significant traction: edge computing. Let’s explore how Java is adapting
    to meet the unique challenges and opportunities presented by edge computing environments.'
  prefs: []
  type: TYPE_NORMAL
- en: Edge computing and Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Edge computing represents a paradigm shift in how data is processed, with computation
    occurring at or near the data source instead of relying solely on centralized
    cloud data centers. This approach reduces latency, optimizes bandwidth usage,
    and improves response times for critical applications.
  prefs: []
  type: TYPE_NORMAL
- en: Java’s role in edge computing architectures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java, with its mature ecosystem and robust performance, is increasingly becoming
    a pivotal player in edge computing architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Java’s versatility and platform independence make it an ideal candidate for
    edge computing environments, which often consist of heterogeneous hardware and
    **operating systems** (**OSs**). Java’s ability to run on various devices, from
    powerful servers to constrained **internet of things** (**IoT**) devices, ensures
    that developers can leverage a consistent programming model across the entire
    edge-to-cloud continuum. Additionally, the extensive set of libraries and frameworks
    available in the Java ecosystem enables rapid development and deployment of edge
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key benefits of using Java in edge computing include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cross-platform compatibility**: Java’s “write once, run anywhere” philosophy
    allows edge applications to be deployed across diverse hardware platforms without
    modification'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance and scalability**: Java’s robust performance and efficient memory
    management are critical for handling the resource-constrained environments often
    found in edge devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: Java provides a strong security model, which is essential for
    safeguarding sensitive data processed at the edge'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These advantages make Java a compelling choice for edge computing. To further
    empower developers, several frameworks and tools have been developed to streamline
    Java-based edge application development and deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks and tools for Java-based edge applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To effectively leverage Java in edge computing, developers can utilize a variety
    of frameworks and tools specifically designed for building and managing edge applications.
    Some of the prominent frameworks and tools include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Eclipse Foundation’s** **IoT initiative**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eclipse Kura**: An open-source framework for building IoT gateways. It provides
    a set of Java APIs for accessing hardware interfaces, managing network configurations,
    and interacting with cloud services.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eclipse Kapua**: A modular IoT cloud platform that works in conjunction with
    Eclipse Kura to provide end-to-end IoT solutions. It offers features such as device
    management, data management, and application integration.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apache Edgent**: Apache Edgent (formerly known as Quarks) is a lightweight,
    embeddable programming model and runtime for edge devices. It allows developers
    to create analytics applications that can run on small-footprint devices and integrate
    with central data systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vert.x**: Vert.x is a toolkit for building reactive applications on the JVM.
    Its event-driven architecture and lightweight nature make it well suited for edge-computing
    scenarios where low latency and high concurrency are essential.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS IoT Greengrass**: AWS IoT Greengrass extends AWS capabilities to edge
    devices, enabling them to act locally on the data they generate while still using
    the cloud for management, analytics, and durable storage. Java developers can
    create Greengrass Lambda functions to process and respond to local events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure IoT Edge**: Azure IoT Edge allows developers to deploy and run containerized
    applications at the edge. Java applications can be packaged in Docker containers
    and deployed using Azure IoT Edge runtime, enabling seamless integration with
    Azure cloud services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Cloud IoT Edge**: Google Cloud IoT Edge brings Google Cloud’s ML and
    data processing capabilities to edge devices. Java developers can utilize TensorFlow
    Lite and other Google Cloud services to create intelligent edge applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java’s robust ecosystem, platform independence, and extensive library support
    make it a strong contender for edge computing. By leveraging frameworks and tools
    designed for edge environments, Java developers can build efficient, scalable,
    and secure edge applications that harness the full potential of edge computing
    architectures. As edge computing continues to evolve, Java is well positioned
    to play a critical role in shaping the future of distributed and decentralized
    data processing.
  prefs: []
  type: TYPE_NORMAL
- en: AI and ML integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we look toward the future of Java in cloud computing, the integration of
    AI and ML presents exciting opportunities and challenges. While [*Chapter 7*](B20937_07.xhtml#_idTextAnchor187)
    focused on Java’s concurrency mechanisms for ML workflows, this section explores
    Java’s evolving role in cloud-based AI/ML ecosystems and its integration with
    advanced cloud AI services.
  prefs: []
  type: TYPE_NORMAL
- en: Java’s position in cloud-based AI/ML workflows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some of Java’s evolving roles in cloud-based AI/ML ecosystems:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Serverless AI/ML with Java**: The future of Java in cloud-based AI/ML workflows
    is increasingly serverless. Frameworks such as AWS Lambda and Google Cloud Functions
    allow developers to deploy AI/ML models as serverless functions. This trend is
    expected to grow, enabling more efficient and scalable AI/ML operations without
    the need for managing infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java as an orchestrator**: Java is positioning itself as a powerful orchestrator
    for complex AI/ML pipelines in the cloud. Its robustness and extensive ecosystem
    make it ideal for managing workflows that involve multiple AI/ML services, data
    sources, and processing steps. Expect to see more Java-based tools and frameworks
    designed specifically for AI/ML pipeline orchestration in cloud environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edge AI with Java**: As edge computing gains prominence, Java’s *write once,
    run anywhere* philosophy becomes increasingly valuable. Java is being adapted
    for edge AI applications, allowing models trained in the cloud to be deployed
    and run on edge devices. This trend will likely accelerate, with Java serving
    as a bridge between cloud-based training and edge-based inference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let’s explore Java’s integration with advanced cloud-based AI services.
  prefs: []
  type: TYPE_NORMAL
- en: Integration of Java with cloud AI services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Integrating Java applications with cloud-based AI services opens up a world
    of possibilities for developers, enabling the creation of intelligent and adaptive
    software solutions. Cloud AI services offer pre-trained models, scalable infrastructure,
    and APIs that make it easier to implement advanced ML and AI capabilities without
    the need for extensive in-house expertise. The following is a list of popular
    cloud AI services that can be integrated with Java applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Native Java SDKs for cloud AI services**: Major cloud providers are investing
    in developing a robust **Java Development Kit** (**JDK**) for their AI services.
    For example, AWS has released the AWS SDK for Java 2.0, which provides streamlined
    access to services such as Amazon SageMaker. Google Cloud has also enhanced its
    Java client libraries for AI and ML services. This trend is expected to continue,
    making it easier for Java developers to integrate cloud AI services into their
    applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java-friendly AutoML platforms**: Cloud providers are developing AutoML platforms
    that are increasingly Java friendly. For instance, Google Cloud AutoML now offers
    Java client libraries, allowing Java applications to easily train and deploy custom
    ML models without extensive ML expertise. This trend is likely to expand, making
    advanced AI capabilities more accessible to Java developers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containerized Java AI/ML deployments**: The future of Java in cloud AI/ML
    workflows is closely tied to containerization. Platforms such as Kubernetes are
    becoming the de facto standard for deploying and managing AI/ML workloads in the
    cloud. Java’s compatibility with containerization technologies positions it well
    for this trend. Expect to see more tools and best practices emerge for deploying
    Java-based AI/ML applications in containerized environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java in federated learning**: Federated learning is an ML technique that
    trains algorithms across multiple decentralized edge devices or servers holding
    local data samples, without exchanging them. This approach addresses growing privacy
    concerns by allowing model training on distributed datasets without centrally
    pooling the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As privacy concerns grow, federated learning is gaining traction. Java’s robust
    security features and its wide adoption in enterprise environments make it a strong
    candidate for implementing federated learning systems. Cloud providers are likely
    to offer more support for Java in their federated learning offerings, enabling
    models to be trained across decentralized data sources without compromising privacy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Java for Machine Learning Operations (MLOps)**: The emerging field of MLOps
    is seeing increased adoption of Java. Its stability and extensive tooling make
    Java well suited for building robust MLOps pipelines in the cloud. Expect to see
    more Java-based MLOps tools and integrations with cloud CI/CD services specifically
    designed for AI/ML workflows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, Java’s role in cloud-based AI/ML is evolving beyond just a language
    for implementing algorithms. It’s becoming a crucial part of the broader AI/ML
    ecosystem in the cloud, from serverless deployments to edge computing, and from
    AutoML to MLOps. As cloud AI services continue to mature, Java’s integration with
    these services will deepen, offering developers powerful new ways to build intelligent,
    scalable applications in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Use case – serverless AI image analysis with AWS Lambda and Fargate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This use case demonstrates a scalable, serverless architecture for AI-powered
    image analysis using AWS Lambda and Fargate. AWS Fargate is AWS’s implementation
    of serverless containers. This technology allows for the deployment of entire
    Java applications in a serverless fashion, leveraging container orchestration
    platforms such as Kubernetes and AWS Fargate. By packaging Java applications as
    containers, developers can enjoy the benefits of serverless computing – such as
    automatic scaling and pay-per-use pricing – while maintaining control over the
    runtime environment. This approach ensures consistency across different environments,
    provides flexibility with the inclusion of necessary libraries and tools, and
    offers robust scalability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The system consists of two main components, each built as a separate Quarkus
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ImageAnalysisCoordinator`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built as a native executable for optimal performance in a serverless environment
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggered when an image is uploaded to an S3 bucket
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Performs quick analysis using Amazon Rekognition
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Initiates a more detailed analysis by launching an AWS Fargate task
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FargateImageAnalyzer`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built as a JVM-based application and containerized using Docker
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Runs as a task in AWS Fargate when triggered by the Lambda function
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Performs in-depth image processing using advanced AI techniques
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Stores detailed analysis results back in S3
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This two-component architecture allows for efficient resource utilization:
    the lightweight Lambda function handles the initial processing and orchestration,
    while the Fargate container manages the more intensive computational tasks. Together,
    they form a robust, scalable solution for serverless AI-powered image analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1: Create a** **Fargate container**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dockerfile.jvm`: The `Dockerfile.jvm` is used to build the Docker image for
    the Fargate container component of the serverless AI image analysis architecture.
    Unlike the Lambda function, which is built as a native executable, the Fargate
    container runs the `FargateImageAnalyzer` application as a JVM-based Quarkus application.
    This choice is due to the Fargate container being responsible for the more computationally
    intensive image processing tasks, where the benefits of the Quarkus framework
    can outweigh the potential performance advantages of a native executable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This Dockerfile defines the steps to build a Docker image for a Quarkus application.
    The image is designed to run within a Red Hat **Universal Base Image** (**UBI**)
    environment with OpenJDK 17:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`FargateImageAnalyzer.java` performs in-depth image processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `FargateImageAnalyzer` class is the main application that runs inside the
    Fargate container as part of the serverless AI image analysis architecture. It
    is designed as a Quarkus application and implements the `QuarkusApplication` interface.
    The class is responsible for extracting the S3 bucket and object key information,
    using the AWS Rekognition client to perform image analysis, generating a detailed
    analysis result, and storing it back in the same S3 bucket. It is designed to
    run as a standalone Quarkus application within the Fargate task, leveraging the
    benefits of running in a containerized environment and the ease of deployment
    and scaling that Fargate provides.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2: Create a** **Lambda function**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dockerfile.native`: This Dockerfile is used to build the Docker image for
    the native executable of the Lambda function component in the serverless AI image
    analysis architecture. This Dockerfile follows the Quarkus convention for building
    native executables by using the `quay.io/quarkus/ubi-quarkus-native-image` base
    image and performing the necessary build steps. By using `Dockerfile.native`,
    the Lambda function can be packaged as a native executable, which provides improved
    performance and reduced cold start times compared to a JVM-based deployment. This
    is particularly beneficial for serverless applications where rapid response times
    are crucial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`ImageAnalysisCoordinator.java`: This is an AWS Lambda function that gets triggered
    when a new image is uploaded to an S3 bucket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ImageAnalysisCoordinator` class is an AWS Lambda function that serves
    as the entry point for the serverless AI image analysis architecture. Its primary
    responsibilities are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the S3 bucket and object key information from the incoming S3 event
    that triggers the Lambda function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initiating a Fargate task to perform the computationally intensive image analysis
    by launching an ECS task and passing the necessary environment variables (bucket
    and key)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling any errors that occur during the Fargate task launch process and returning
    appropriate status messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This Lambda function acts as a lightweight coordinator, responsible for orchestrating
    the overall image analysis workflow. It triggers the more resource-intensive processing
    to be performed by the Fargate container, which runs the `FargateImageAnalyzer`
    application. By separating the responsibilities in this way, the architecture
    achieves efficient resource utilization and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3: Build** **the projects**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the Lambda function, run the following command to package the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For the Fargate container, run the following command to build the Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Step** **4: Deploy**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To streamline the deployment of the serverless AI infrastructure, an AWS CloudFormation
    template has been prepared. This template automates the entire deployment process,
    including the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the necessary AWS resources, such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: S3 bucket for storing the images and analysis results
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ECS cluster and task definition for the Fargate container
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda function for the `ImageAnalysisCoordinator` class
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Upload the built artifacts (Lambda function `.jar` file and Docker image) to
    the appropriate locations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the necessary permissions and triggers for the Lambda function to
    be invoked when an image is uploaded to the S3 bucket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the Fargate task definition and set up the necessary network configurations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To use the CloudFormation template, you can find it in the book’s accompanying
    GitHub repository alongside the source code. Simply download the template, fill
    in any necessary parameters, and deploy it using the AWS CloudFormation service.
    This will set up the entire serverless AI infrastructure for you, streamlining
    the deployment process and ensuring consistency across different environments.
  prefs: []
  type: TYPE_NORMAL
- en: Emerging concurrency and parallel processing tools in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Java continues to evolve, new tools and frameworks are being developed to
    address the growing demands of concurrent and parallel programming. These advancements
    aim to simplify development, improve performance, and enhance scalability in modern
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Project Loom – virtual threads for efficient concurrency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Project Loom** is an ambitious initiative by the OpenJDK community to enhance
    Java’s concurrency model. The primary goal is to simplify writing, maintaining,
    and observing high-throughput concurrent applications by introducing virtual threads
    (also known as **fibers**).'
  prefs: []
  type: TYPE_NORMAL
- en: Virtual threads are lightweight and are managed by the Java runtime rather than
    the OS. Unlike traditional threads, which are limited by the number of OS threads,
    virtual threads can scale to handle millions of concurrent operations without
    overwhelming system resources. They allow developers to write code in a synchronous
    style while achieving the scalability of asynchronous models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its key features include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lightweight nature**: Virtual threads are much lighter than traditional OS
    threads, reducing memory and context-switching overhead'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blocking calls**: They handle blocking calls efficiently, suspending only
    the virtual thread while keeping the underlying OS thread available for other
    tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity**: Developers can write straightforward, readable code using familiar
    constructs such as loops and conditionals without resorting to complex asynchronous
    paradigms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To illustrate the practical application of Project Loom and virtual threads,
    let’s explore a code example that demonstrates implementing a high-concurrency
    microservice using Project Loom and Akka within an AWS cloud environment.
  prefs: []
  type: TYPE_NORMAL
- en: Code example – implementing a high-concurrency microservice using Project Loom
    and Akka for the AWS cloud environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will demonstrate how to implement a high-concurrency microservice
    using Project Loom and Akka, designed to run in an AWS cloud environment. This
    example will showcase how to leverage virtual threads from Project Loom and the
    actor model provided by Akka to build a scalable and efficient microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pom.xml` dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Step 2:** **Code implementation**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HighConcurrencyService.java`: The main entry point for the service, which
    sets up `ActorSystem` and uses `ExecutorService` to manage virtual threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `HighConcurrencyService` class serves as the entry point for a high-concurrency
    microservice application designed to handle numerous requests efficiently. Utilizing
    Akka’s actor model and Java’s concurrency features, this class demonstrates how
    to manage thousands of concurrent tasks effectively. The main function initializes
    `ActorSystem` for creating and managing actors, sets up an S3 client for interacting
    with AWS S3 services, and employs an executor service to submit multiple tasks.
    Each task involves creating a new actor instance to handle a specific request,
    showcasing how to leverage virtual threads and actors for scalable and concurrent
    processing in a cloud environment.
  prefs: []
  type: TYPE_NORMAL
- en: '`RequestHandlerActor.java`: This actor handles individual requests to process
    data and interact with AWS S3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `RequestHandlerActor` class defines the behavior of an actor responsible
    for handling individual requests in the high-concurrency microservice. It processes
    requests to store data in AWS S3 by utilizing the S3 client. The `HandleRequest`
    inner class encapsulates the details of a request, including the S3 bucket name,
    key, and content to be stored. The actor’s behavior is defined as receiving these
    `HandleRequest` messages, processing the request by interacting with the S3 service,
    and logging the result. This class exemplifies the use of Akka’s actor model to
    manage and process concurrent tasks efficiently, ensuring scalability and robustness
    in cloud-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3: Deployment** **to AWS**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dockerfile**: The Dockerfile should be created and saved in the root directory
    of your application project. This is the standard location for the Dockerfile,
    as it allows the Docker build process to access all the necessary files and resources
    without requiring additional context switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The key points about this Dockerfile are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It uses the `amazoncorretto: 17-alpine` base image, which provides the Java
    17 runtime environment based on the Alpine Linux distribution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It follows a two-stage build process:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *builder* stage compiles the application and packages it into a JAR file
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The final stage copies the packaged JAR file and sets the entry point to run
    the application
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deploy using** **AWS ECS/Fargate**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also prepared a CloudFormation template for these processes, which
    can be found in the code repository. Follow these steps to deploy:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create an ECS cluster and task definition in AWS**: Set up your ECS cluster
    and define the task that will run your Docker container.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Upload the Docker image to Amazon Elastic Container Registry (ECR)**: Push
    the Docker image to Amazon ECR for easy deployment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Configure ECS service to use Fargate and run the container**: Configure your
    ECS service to use AWS Fargate, a serverless compute engine, to run the containerized
    application.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This streamlined process ensures that your high-concurrency microservice is
    efficiently deployed in a scalable cloud environment.
  prefs: []
  type: TYPE_NORMAL
- en: This high-concurrency microservice example demonstrates the power of leveraging
    Project Loom’s virtual threads and Akka’s actor model to build scalable, efficient,
    and cloud-ready applications. By harnessing these advanced concurrency tools,
    developers can simplify their code, improve resource utilization, and enhance
    the overall performance and responsiveness of their services, particularly in
    the context of the AWS cloud environment. This lays the foundation for exploring
    the next wave of cloud innovations, where emerging technologies such as AWS Graviton
    processors and Google Cloud Spanner can further enhance the scalability and capabilities
    of cloud-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for the next wave of cloud innovations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As cloud technologies continue to evolve rapidly, developers and organizations
    must stay ahead of the curve. Anticipating advancements in cloud services, here’s
    how you can prepare for upcoming advancements in cloud services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS Graviton**: AWS Graviton is a family of ARM-based processors designed
    by AWS to offer improved price performance compared to traditional x86-based processors,
    particularly for workloads that can take advantage of the parallel processing
    capabilities of ARM architecture. The latest **Graviton3** iteration can provide
    up to 25% better performance and 60% better price performance than previous-generation
    Intel-based EC2 instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Corretto**: On the other hand, Amazon Corretto is a no-cost, multiplatform,
    production-ready distribution of the OpenJDK, a free and open-source implementation
    of the Java platform. Corretto is available for both x86-based and ARM-based (including
    Graviton) architectures, providing a certified, tested, and supported version
    of the JDK for AWS customers. The ARM-based Corretto JDK is optimized to run on
    AWS Graviton-powered instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider using the Amazon Corretto JDK. Here is a code snippet to build a Docker
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and push run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**Google Cloud Spanner**: Cloud Spanner is a fully managed, scalable, relational
    database service offering strong consistency and high availability:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global distribution**: Spanner supports multi-regional and global deployment,
    providing high availability and low-latency access to data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strong consistency**: Unlike many NoSQL databases, Spanner maintains strong
    consistency, making it suitable for applications that require transactional integrity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Seamless scaling**: Spanner automatically handles horizontal scaling, allowing
    applications to grow without compromising performance or availability'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example**: Using Java with Cloud Spanner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet demonstrates the use of the Java client library to interact
    with Google Cloud Spanner. The code first creates a Spanner client using the `SpannerOptions`
    builder and retrieves the service instance. It then gets a `DatabaseClient` instance,
    which is used to interact with a specific Spanner database identified by the `projectId`,
    `instanceId`, and `databaseId` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Within a try-with-resources block, the code creates a single-use, read-only
    transaction using the `singleUse()` method and executes a `SQL SELECT` query to
    retrieve all records from the `Users` table. The results are then iterated through,
    and the `UserId` and `Name` columns are printed for each user record.
  prefs: []
  type: TYPE_NORMAL
- en: This example showcases the basic usage of the Google Cloud Spanner Java client
    library, including establishing a connection to the database, executing a query,
    and processing the results, while ensuring proper resource management and cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum computing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Quantum computing**, though still in its early stages, promises to revolutionize
    various industries by solving complex problems that are infeasible for classical
    computers. Quantum computers leverage the principles of quantum mechanics, such
    as superposition and entanglement, to perform computations in parallel.'
  prefs: []
  type: TYPE_NORMAL
- en: While not immediately practical for most applications, it’s beneficial to start
    learning about quantum computing principles and how they might apply to your domain.
    Key concepts to explore include qubits, quantum gates, and quantum algorithms
    such as Shor’s algorithm for factoring large numbers and Grover’s algorithm for
    search problems.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding these principles will prepare you for future advancements and
    potential integration of quantum computing into your workflows. By familiarizing
    yourself with the foundational concepts now, you’ll be better positioned to take
    advantage of quantum computing as it becomes more accessible and applicable to
    real-world problems.
  prefs: []
  type: TYPE_NORMAL
- en: Staying informed and exploring these technologies, even at an introductory level,
    will help ensure your organization is ready to adapt and thrive in the rapidly
    evolving cloud landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the final chapter of this book, we now stand at the precipice of the future,
    where cloud technologies continue to evolve at a breathtaking pace. In this concluding
    section, we explored the emerging trends and advancements that are poised to reshape
    the way we develop and deploy applications in the cloud, with a particular emphasis
    on Java’s pivotal role in shaping these innovations.
  prefs: []
  type: TYPE_NORMAL
- en: We began by delving into the evolution of serverless Java, where we saw how
    frameworks such as Quarkus and Micronaut are redefining the boundaries of function
    as a service. These cutting-edge tools leverage techniques such as native image
    compilation to deliver unprecedented performance and efficiency in serverless
    environments, while also enabling the deployment of full-fledged Java applications
    as serverless containers. This represents a significant shift, empowering developers
    to create highly scalable, responsive, and cloud-native applications that go beyond
    simple function executions.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we turned our attention to the edge computing landscape, where data processing
    and decision-making are moving closer to the source. Java’s platform independence,
    performance, and extensive ecosystem make it an ideal choice for building edge
    applications. We introduced the key frameworks and tools that enable Java developers
    to leverage the power of edge computing, ensuring their applications can seamlessly
    integrate with this rapidly advancing paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we explored Java’s evolving role in the integration of AI and ML
    within cloud-based ecosystems. From serverless AI/ML workflows to the seamless
    integration of Java with cloud-based AI services, we uncovered the opportunities
    and challenges that this convergence presents, equipping you with the knowledge
    to harness the power of these technologies in your Java-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we ventured into the captivating realm of quantum computing, a field
    that promises to revolutionize various industries. While still in its early stages,
    understanding the fundamental principles of quantum computing, such as qubits,
    quantum gates, and algorithms, can prepare developers for future advancements
    and their potential integration with Java-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: As we conclude this book, you now possess a comprehensive understanding of the
    emerging trends in cloud computing and Java’s pivotal role in shaping these innovations.
    Armed with this knowledge, you are poised to position your applications and infrastructure
    for success in the rapidly evolving cloud landscape, ensuring your organization
    can adapt and thrive in the years to come.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a key benefit of using Quarkus and GraalVM for building serverless Java
    applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Improved startup time and reduced memory usage
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Easier integration with cloud-based AI/ML services
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Seamless deployment across multiple cloud providers
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is a key advantage of using Java in edge computing environments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Platform independence
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Extensive library support
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Robust security model
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which cloud AI service allows Java developers to easily train and deploy custom
    ML models without extensive ML expertise?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS SageMaker
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Google Cloud AutoML
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Microsoft Azure Cognitive Services
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: IBM Watson Studio
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which quantum computing concept is demonstrated in the provided code example
    that puts a qubit into superposition and measures the outcome?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quantum entanglement
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Quantum teleportation
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Quantum superposition
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Quantum tunneling
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a key benefit of using serverless containers for Java applications in
    the cloud?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reduced operational overhead for managing infrastructure
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Increased cold start times for serverless functions
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Inability to include custom libraries and dependencies
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Limited control over the runtime environment
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Appendix A: Setting up a Cloud-Native Java Environment'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Appendix A*](B20937_AppA.xhtml#_idTextAnchor321), you will learn how to
    set up a cloud-native environment for Java applications. This comprehensive guide
    covers everything from building and packaging Java applications to deploying them
    on popular cloud platforms like **Amazon Web Services** (**AWS**), **Microsoft
    Azure**, and **Google Cloud Platform** (**GCP**). Key topics include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Building and packaging**: Step-by-step instructions on using build tools
    like Maven and Gradle to create and manage Java projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ensuring cloud-readiness**: Best practices for making your Java applications
    stateless and configurable to thrive in cloud environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containerization**: How to create Docker images for your Java applications
    and deploy them using Docker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud deployments**: Detailed procedures for deploying Java applications
    on AWS, Azure, and GCP, including setting up the necessary cloud environments,
    creating and managing cloud resources, and using specific cloud services like
    Elastic Beanstalk, Kubernetes, and serverless functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this appendix, you will have a solid understanding of how to effectively
    build, package, containerize, and deploy Java applications in a cloud-native environment.
  prefs: []
  type: TYPE_NORMAL
- en: General approach – build and package Java applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section provides a detailed guide on the essential steps required to build
    and package your Java applications, ensuring they are ready for deployment in
    a cloud environment.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure your app is cloud-ready
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`application.properties` or `application.yaml` files, or by using a configuration
    management tool. Here is an example:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Use a Build tool like Maven or Gradle
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pom.xml` file in your project root directory if it doesn’t already exist.
    Add the necessary dependencies. Here is an example of `pom.xml`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`build.gradle` file in your project root directory if it doesn’t already exist.
    Add the necessary dependencies, here is an example of `build.gradle`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '**Build the JAR file**: Build the JAR file using Maven or Gradle.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Maven**: Run the following command:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This command will generate a JAR file in the target directory, typically named
    `myapp-1.0-SNAPSHOT.jar`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Gradle**: Run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This command will generate a JAR file in the build/libs directory, typically
    named `myapp-1.0-SNAPSHOT.jar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are not using containers, you can stop here. The JAR file located in
    the target or build/libs directory can now be used to run your application directly.
  prefs: []
  type: TYPE_NORMAL
- en: Containerize your application using Docker
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Create a Dockerfile**: Create a Dockerfile in your project root directory
    with the following content:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to adjust the COPY instruction if your JAR file is located in a different
    directory or has a different name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Build the** **Docker Image**:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Build the Docker image using the Docker build command. Run this command in
    the directory where your Dockerfile is located:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This command will create a Docker image named `myapp` with the tag `1.0`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Run the Docker Container**: Run the Docker container using the docker run
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This command will start a container from the `myapp:1.0` image and map port
    `8080` of the container to port 8080 on your host machine.
  prefs: []
  type: TYPE_NORMAL
- en: This section provides a detailed guide on the essential steps required to build
    and package your Java applications, ensuring they are ready for deployment in
    a cloud environment.
  prefs: []
  type: TYPE_NORMAL
- en: After learning how to build and package your Java applications, the next step
    is to explore the specific procedures for deploying these applications on popular
    cloud platforms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step-by-step guides for deploying Java applications on popular** **cloud
    platforms:**'
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the AWS environment
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`aws configure` and enter your AWS Access Key, Secret Key, region, and output
    format.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`trust-policy.json`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Deploy your Java application to AWS using WAS CLI: Elastic Beanstalk (PaaS)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the IAM role:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Attach the required policies to the role:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the instance profile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the role to the instance profile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Deploying to Elastic Beanstalk
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an Elastic Beanstalk Application:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Create a new Elastic Beanstalk environment using the latest Corretto 21 version
    on Amazon Linux 2023.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Uploads `my-application.jar` to the deployments folder in the my-bucket S3 bucket.
    Adjust the parameters as needed for your specific use case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Create a new application version in Elastic Beanstalk
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Update the Elastic Beanstalk environment to use the new application version
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Check the environment health
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploy your Java application: ECS (Containers)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Push the Docker image to Amazon **Elastic Container Registry** (**ECR**): First,
    create an ECR repository:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Authenticate Docker to your ECR:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Tag your Docker image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Push your Docker image to ECR:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up `task-definition.json` with the task definition configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Register the task definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a Cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '**Create a Service**: Create a service using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Important notes
  prefs: []
  type: TYPE_NORMAL
- en: Replace subnet-XXXXXXXXXXXXXXXXX with the actual ID of the subnet where you
    want to run your tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Replace sg-XXXXXXXXXXXXXXXXX with the actual ID of the security group you want
    to associate with your tasks.
  prefs: []
  type: TYPE_NORMAL
- en: This command uses forward slashes (\) for line continuation, which is appropriate
    for Unix-like environments (Linux, macOS, Git Bash on Windows).
  prefs: []
  type: TYPE_NORMAL
- en: For Windows Command Prompt, replace the backslashes (\) with caret symbols (^)
    for line continuation.
  prefs: []
  type: TYPE_NORMAL
- en: For PowerShell, use backticks (`) at the end of each line instead of backslashes
    for line continuation.
  prefs: []
  type: TYPE_NORMAL
- en: The --desired-count 1 parameter specifies that you want one task running at
    all times.
  prefs: []
  type: TYPE_NORMAL
- en: The --launch-type FARGATE parameter specifies that this service will use AWS
    Fargate, which means you don’t need to manage the underlying EC2 instances.
  prefs: []
  type: TYPE_NORMAL
- en: Deploy your Java serverless Lambda function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an AWS Lambda function role:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Attach the `AWSLambdaBasicExecutionRole` policy to the role:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the Lambda function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '**Invoke the Lambda function**: When using the aws lambda invoke command to
    test your AWS Lambda function, it’s important to update the --payload parameter
    to match the expected input format of your specific Lambda function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have an understanding of how to set up a cloud-native Java environment
    and deploy your applications on various cloud platforms, you may want to dive
    deeper into specific cloud services. The following links provide additional resources
    and documentation to help you further your knowledge and skills in deploying and
    managing Java applications in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Useful links for further information on AWS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon EC2**: Getting Started with Amazon EC2 ([https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EC2_GetStarted.html](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EC2_GetStarted.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS Elastic Beanstalk**: Getting Started with AWS Elastic Beanstalk ([https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/GettingStarted.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/GettingStarted.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon ECS**: Getting Started with Amazon ECS ([https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_GetStarted.html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_GetStarted.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS Lambda**: Getting Started with AWS Lambda ([https://docs.aws.amazon.com/lambda/latest/dg/getting-started.html](https://docs.aws.amazon.com/lambda/latest/dg/getting-started.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Managing environment variables**: Best practices for managing environment
    variables in AWS Lambda ([https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn the steps required to deploy Java applications
    on Microsoft Azure. This includes setting up the Azure environment, deploying
    applications on virtual machines and containers, and utilizing **Azure Kubernetes
    Service** (**AKS**) for containerized applications. Additionally, you will explore
    how to deploy Java functions on Azure Functions, enabling you to leverage serverless
    computing for your Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up the Azure environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Download and install Azure CLI**: Follow the official installation instructions
    for your operating system from the Azure CLI installation guide ([https://learn.microsoft.com/en-us/cli/azure/install-azure-cli](https://learn.microsoft.com/en-us/cli/azure/install-azure-cli)).'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Configure Azure CLI**: Open your terminal or command prompt and run the following
    command to log in to your Azure account:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Follow the instructions to log in to your Azure account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will learn how to deploy a regular Java application on Azure Virtual
    Machines.
  prefs: []
  type: TYPE_NORMAL
- en: '**Deploying a Regular Java Application on Azure** **Virtual Machines**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Resource Group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a Virtual Machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Open port 8080:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'SSH into the VM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Install Java on the VM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Transfer and Run the JAR File:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Once you have successfully deployed your Java application on an Azure Virtual
    Machine, you can manage and scale your application as needed using the Azure portal
    and CLI tools. This approach provides a solid foundation for running traditional
    Java applications in a cloud environment.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will learn how to deploy a Java application in containers using AKS,
    which offers a more flexible and scalable solution for containerized applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**Deploying a Java Application in Containers** **on AKS**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an **Azure Container** **Registry** (**ACR**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Login to ACR:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Tag and push Docker image to ACR:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Create AKS Cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Get AKS Credentials:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploy the application to AKS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a Deployment YAML file (`deployment.yaml`):'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Apply the deployment:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Expose the deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This completes the process of deploying a containerized Java application to
    AKS. However, for scenarios where you need more granular control over your application’s
    execution or want to build serverless microservices, Azure Functions provides
    an excellent alternative. Next, you will learn how to deploy Java functions on
    Azure Functions, enabling you to take advantage of serverless computing for event-driven
    applications and microservices.
  prefs: []
  type: TYPE_NORMAL
- en: '**Deploying Java Functions on** **Azure Functions**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Azure functions core tools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Windows**: Use MSI installer ([https://learn.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=windows%2Cisolated-process%2Cnode-v4%2Cpython-v2%2Chttp-trigger%2Ccontainer-apps&pivots=programming-language-csharp#v2](https://learn.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=windows%2Cisolated-process%2Cnode-v4%2Cpython-v2%2Chttp-trigger%2Ccontainer-apps&pivots=programming-language-csharp#v2))'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**macOS**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new function app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploy to Azure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Replace placeholders like <vm-ip-address>, <your-region>, <FunctionAppName>,
    etc., with your actual values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For detailed information on configuring environment variables and managing
    configurations specifically for Azure environments, you can refer to the official
    Azure documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure App Service configuration**: Configure apps in Azure App Service ([https://learn.microsoft.com/en-us/azure/app-service/configure-common?tabs=portal](https://learn.microsoft.com/en-us/azure/app-service/configure-common?tabs=portal))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AKS configuration**: Best practices for cluster and node pool configuration
    in AKS ([https://learn.microsoft.com/en-us/azure/aks/operator-best-practices-scheduler](https://learn.microsoft.com/en-us/azure/aks/operator-best-practices-scheduler))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure functions configuration**: Configure function app settings in Azure
    functions ([https://learn.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings?tabs=azure-portal%2Cto-premium](https://learn.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings?tabs=azure-portal%2Cto-premium))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you’ve learned how to deploy Java applications on various Azure services,
    including virtual machines, AKS, and Azure Functions, let’s explore another major
    cloud provider. The following section will guide you through similar deployment
    processes on GCP, allowing you to broaden your cloud deployment skills across
    different environments.
  prefs: []
  type: TYPE_NORMAL
- en: Google Cloud Platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you’ll learn how to deploy Java applications on **Google Cloud
    Platform** or **GCP**, one of the leading cloud service providers. GCP offers
    a wide range of services that cater to various deployment needs, from virtual
    machines to containerized environments and serverless functions. We’ll cover the
    setup process for GCP and guide you through deploying Java applications using
    different GCP services, including **Google Compute Engine** (**GCE**), **Google
    Kubernetes Engine** (**GKE**), and Google Cloud Functions. This knowledge will
    empower you to leverage GCP’s robust infrastructure and services for your Java
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Google Cloud Environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a Google Cloud account if you don’t have one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the Google Cloud SDK. Follow the instructions for your operating system
    from the official Google Cloud SDK documentation ([https://cloud.google.com/sdk/docs/install](https://cloud.google.com/sdk/docs/install))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Initialize the Google Cloud SDK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Follow the prompts to log in and select your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set your project ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: With your Google Cloud environment successfully set up, you are now prepared
    to deploy and manage Java applications using GCP’s robust infrastructure. In the
    next sections, you will explore specific methods for deploying Java applications
    on GCE, GKE, and Google Cloud Functions.
  prefs: []
  type: TYPE_NORMAL
- en: Deploy your Java application to Google Cloud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**GCE for regular** **Java Applications**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a VM instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'SSH into the VM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Install Java on the VM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Transfer your JAR file to the VM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your Java application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: By following these steps, you can efficiently deploy and manage your Java applications
    on Google Cloud, leveraging the various services and tools provided by GCP. With
    your Java application successfully deployed to Google Cloud, you are now ready
    to explore containerized deployments using GKE, which offers powerful orchestration
    capabilities for managing containers at scale.
  prefs: []
  type: TYPE_NORMAL
- en: GKE for containerized applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you will learn how to deploy Java applications in containers
    using GKE. GKE provides a managed environment for deploying, managing, and scaling
    containerized applications using Kubernetes. You will be guided through setting
    up a GKE cluster, deploying your Docker images, and managing your containerized
    applications efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a GKE cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Get credentials for the cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Push your Docker image to **Google Container** **Registry** (**GCR**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a Kubernetes deployment: Create a file named deployment.yaml:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Apply the deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Expose the deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: By leveraging GKE, you can take full advantage of Kubernetes’ robust features
    to ensure your containerized Java applications are highly available, scalable,
    and easy to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Google Cloud Functions for serverless Java functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you will learn how to deploy Java functions using Google Cloud
    Functions, enabling you to run event-driven code in a fully managed serverless
    environment. You will be guided through setting up your development environment,
    creating and deploying your Java functions, and managing them effectively using
    Google Cloud’s powerful serverless tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory for your function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize a new Maven project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the necessary dependencies to your `pom.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create your function class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Deploy the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: These instructions provide a basic setup for deploying Java applications to
    Google Cloud using different services. Remember to adjust the commands and configurations
    based on your specific application requirements and Google Cloud project settings.
  prefs: []
  type: TYPE_NORMAL
- en: Useful links for further information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Google Compute Engine**: Get started creating and managing virtual machines
    in GCP with the Compute Engine quickstart guide: [https://cloud.google.com/compute/docs/quickstart](https://cloud.google.com/compute/docs/quickstart)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Kubernetes Engine**: Dive into container orchestration with GKE and
    deploy your first Kubernetes cluster using the GKE quickstart: [https://cloud.google.com/kubernetes-engine/docs/quickstart](https://cloud.google.com/kubernetes-engine/docs/quickstart)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Cloud Functions**: Develop and deploy serverless functions that respond
    to events with the Cloud Functions deployment guide: [https://cloud.google.com/functions/docs/deploying](https://cloud.google.com/functions/docs/deploying)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Managing environment** **variables**: [https://cloud.google.com/run/docs/configuring/services/environment-variables](https://cloud.google.com/run/docs/configuring/services/environment-variables)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Appendix B: Resources and Further Reading'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recommended books, articles, and online courses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapters 1–3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Books
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Cloud Native Java: Designing Resilient Systems with Spring Boot, Spring Cloud,
    and Cloud Foundry* by Josh Long and Kenny Bastani. This comprehensive guide offers
    practical insights into building scalable, resilient Java applications for cloud
    environments, covering Spring Boot, Spring Cloud, and Cloud Foundry technologies.
    Link: [https://www.amazon.com/Cloud-Native-Java-Designing-Resilient/dp/1449374646](https://www.amazon.com/Cloud-Native-Java-Designing-Resilient/dp/1449374646)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Java Concurrency in Practice* by Brian Goetz et al. A seminal work on Java
    concurrency, this book provides in-depth coverage of concurrent programming techniques,
    best practices, and pitfalls to avoid when developing multi-threaded applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Parallel and Concurrent Programming in Haskell* by Simon Marlow. While focused
    on Haskell, this book offers valuable insights into parallel programming concepts
    that can be applied to Java, providing a broader perspective on concurrent and
    parallel application design. Link: [https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/](https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Designing Distributed Systems: Patterns and Paradigms for Scalable, Reliable
    Services* by Brendan Burns (Microsoft Azure). This explores essential patterns
    for building scalable and reliable distributed systems, offering insights from
    Microsoft Azure’s experience in cloud computing. Link: [https://www.amazon.com/Designing-Distributed-Systems-Patterns-Paradigms/dp/1491983647](https://www.amazon.com/Designing-Distributed-Systems-Patterns-Paradigms/dp/1491983647)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Articles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Microservices Patterns* by Chris Richardson (microservices.io). A comprehensive
    guide to microservices architecture patterns, this article helps developers understand
    and implement effective microservices-based systems. Link: [https://microservices.io/patterns/index.html](https://microservices.io/patterns/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A Java Fork/Join Framework* by Doug Lea. An in-depth look at the Fork/Join
    framework by its creator, providing valuable insights into its design and implementation
    for parallel processing in Java. Link: [http://gee.cs.oswego.edu/dl/papers/fj.pdf](http://gee.cs.oswego.edu/dl/papers/fj.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Amdahl’s Law in the Multicore Era* by Mark D. Hill and Michael R. Marty. This
    article offers a modern perspective on Amdahl’s Law and its implications for parallel
    computing, helping developers understand the limits and potential of parallel
    processing in contemporary systems. Link: [https://research.cs.wisc.edu/multifacet/papers/ieeecomputer08_amdahl_multicore.pdf](https://research.cs.wisc.edu/multifacet/papers/ieeecomputer08_amdahl_multicore.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Online courses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Java Multithreading, Concurrency & Performance Optimization* by Udemy. This
    comprehensive course covers Java multithreading, concurrency, and performance
    optimization techniques, providing practical examples and hands-on exercises to
    master advanced Java programming concepts. Link:[https://www.udemy.com/course/java-multithreading-concurrency-performance-optimization/](https://www.udemy.com/course/java-multithreading-concurrency-performance-optimization/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Concurrency in Java* by Coursera (offered by Rice University). Focusing on
    the foundational principles of concurrency in Java, this course offers practical
    exercises to solidify understanding of concurrent programming concepts and techniques.
    Link: [https://www.coursera.org/learn/concurrent-programming-in-java](https://www.coursera.org/learn/concurrent-programming-in-java)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reactive Programming in Modern Java using Project Reactor* by Udemy. A comprehensive
    course on reactive programming in Java using Project Reactor, teaching developers
    how to build reactive applications for better scalability and resilience in modern
    software architectures. Link: [https://www.udemy.com/course/reactive-programming-in-modern-java-using-project-reactor/](https://www.udemy.com/course/reactive-programming-in-modern-java-using-project-reactor/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Parallel, Concurrent, and Distributed Programming in Java Specialization*
    on Coursera by Rice University. This specialization offers a comprehensive coverage
    of advanced concurrency topics in Java, including parallel, concurrent, and distributed
    programming techniques for developing high-performance applications. Link: [https://www.coursera.org/specializations/pcdp](https://www.coursera.org/specializations/pcdp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key blogs and websites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Baeldung* offers comprehensive tutorials and articles on Java, Spring, and
    related technologies, including in-depth content on concurrency and parallelism.
    Their concurrency section is particularly valuable for learning advanced Java
    threading concepts. Link: [https://www.baeldung.com/java-concurrency](https://www.baeldung.com/java-concurrency)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*DZone Java Zone* is a community-driven platform, offering a wealth of articles,
    tutorials, and guides on Java and cloud-native development. The Java Zone is an
    excellent resource for staying up-to-date with the latest trends and best practices
    in Java development. Link: [https://dzone.com/java-jdk-development-tutorials-tools-news](https://dzone.com/java-jdk-development-tutorials-tools-news)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*InfoQ Java* provides news, articles, and interviews on software development,
    with a strong focus on Java, concurrency, and cloud-native technologies. InfoQ
    is particularly useful for gaining insights into industry trends and emerging
    technologies in the Java ecosystem. Link: [https://www.infoq.com/java/](https://www.infoq.com/java/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapters 4–6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Books
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Patterns for Distributed Systems* by Unmesh Joshi (InfoQ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This book provides an overview of common patterns used in distributed systems,
    offering practical advice for designing robust and scalable architectures. Link:
    [https://www.amazon.com/Patterns-Distributed-Systems-Addison-Wesley-Signature/dp/0138221987](https://www.amazon.com/Patterns-Distributed-Systems-Addison-Wesley-Signature/dp/0138221987)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Articles and blogs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Martin Fowler’s blog on microservices and distributed systems. This blog is
    a treasure trove of information on microservices and distributed systems, offering
    in-depth articles and thought leadership on modern software architecture. Link:
    [https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*LMAX Disruptor documentation and performance guide* is a high-performance
    inter-thread messaging library for Java. This resource provides documentation
    and performance guides for implementing low-latency, high-throughput systems.
    Link: [https://lmax-exchange.github.io/disruptor/](https://lmax-exchange.github.io/disruptor/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Online courses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Microservices Architecture* by the University of Alberta. This course provides
    a comprehensive introduction to microservices architecture, covering design principles,
    implementation strategies, and best practices for building scalable and maintainable
    systems. Link: [https://www.coursera.org/specializations/software-design-architecture](https://www.coursera.org/specializations/software-design-architecture)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Building Scalable Java Microservices with Spring Boot and Spring Cloud* on
    Coursera by Google Cloud Offered by Google Cloud, this course teaches how to build
    scalable Java microservices using Spring Boot and Spring Cloud, with a focus on
    cloud-native development practices. Link: [https://www.coursera.org/learn/google-cloud-java-spring](https://www.coursera.org/learn/google-cloud-java-spring)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapters 7–9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Books
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Serverless Architectures on AWS* by Peter Sbarski This book provides comprehensive
    coverage of serverless concepts and practical implementations on AWS, offering
    valuable insights for developers looking to build scalable and cost-effective
    applications. Link: [https://www.amazon.com/Serverless-Architectures-AWS-Peter-Sbarski/dp/1617295426](https://www.amazon.com/Serverless-Architectures-AWS-Peter-Sbarski/dp/1617295426)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Articles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Serverless Computing: One Step Forward, Two Steps Back* by Joseph M. Hellerstein
    et al. This article provides a critical analysis of serverless computing, discussing
    its advantages and limitations, and offering a balanced perspective on its place
    in modern architecture. Link: [https://arxiv.org/abs/1812.03651](https://arxiv.org/abs/1812.03651)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Serverless Architecture Patterns and Best Practices* by freeCodeCamp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This article provides an overview of key serverless patterns like messaging,
    function focus, and event-driven architecture, emphasizing the benefits of decoupling
    and scalability. Link: [https://www.freecodecamp.org/news/serverless-architecture-patterns-and-best-practices/](https://www.freecodecamp.org/news/serverless-architecture-patterns-and-best-practices/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Online courses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Developing Serverless Solutions on AWS* by the AWS training team. This includes
    comprehensive coverage of AWS Lambda, best practices, frameworks, and hands-on
    labs. Link: [https://aws.amazon.com/training/classroom/developing-serverless-solutions-on-aws/](https://aws.amazon.com/training/classroom/developing-serverless-solutions-on-aws/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical papers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Serverless Computing: Current Trends and Open Problems* by Ioana Baldini et
    al. This academic paper provides a thorough examination of serverless computing,
    discussing current trends, challenges, and future directions in this rapidly evolving
    field. Link: [https://arxiv.org/abs/1706.03178](https://arxiv.org/abs/1706.03178)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Online resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'AWS Lambda Developer Guide: [https://docs.aws.amazon.com/lambda/latest/dg/welcome.html](https://docs.aws.amazon.com/lambda/latest/dg/welcome.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Functions Java developer guide: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference-java](https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference-java)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Google Cloud Functions Java Tutorials: [https://codelabs.developers.google.com/codelabs/cloud-starting-cloudfunctions#](https://codelabs.developers.google.com/codelabs/cloud-starting-cloudfunctions#)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapters 10–12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Books
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Quantum Computing for Developers* by Johan Vos. This groundbreaking book offers
    a developer-friendly introduction to quantum computing, bridging the gap between
    theoretical concepts and practical implementation. It provides clear explanations
    of quantum principles and includes hands-on examples using Java-based frameworks,
    preparing software developers for the emerging quantum computing landscape. The
    author, Johan Vos, expertly guides readers through quantum algorithms, quantum
    gates, and quantum circuits, demonstrating how to leverage existing programming
    skills in this cutting-edge field. Link: [https://www.manning.com/books/quantum-computing-for-developers](https://www.manning.com/books/quantum-computing-for-developers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Articles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Transitioning your service or application* by Amazon Web Services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This article explores optimizing Java applications to provide more details
    regarding the individual steps involved in transitioning an application to Graviton2\.
    Link: [https://docs.aws.amazon.com/whitepapers/latest/aws-graviton2-for-isv/transitioning-your-service-or-application.html](https://docs.aws.amazon.com/whitepapers/latest/aws-graviton2-for-isv/transitioning-your-service-or-application.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Java in the Era of Cloud Computing* by Cogent University. This article focuses
    on the cloud-native advancements in Java, with frameworks like Spring Boot and
    Quarkus facilitating cloud-based development. It also mentions tools like Maven,
    Gradle, and JUnit for enhancing productivity and ensuring code quality. Link:
    [https://www.cogentuniversity.com/post/java-in-the-era-of-cloud-computing](https://www.cogentuniversity.com/post/java-in-the-era-of-cloud-computing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Online courses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Parallel, Concurrent, and Distributed Programming in Java Specialization*
    by Rice University on Coursera. This specialization covers advanced concurrency
    topics in Java, which apply to cloud computing environments and auto-scaling scenarios.
    Link: [https://www.coursera.org/specializations/pcdp](https://www.coursera.org/specializations/pcdp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Serverless Machine Learning with Tensorflow on Google Cloud Platform* by Google
    Cloud on Coursera. This course explores the intersection of serverless computing
    and machine learning, aligning with discussions on AI/ML integration in cloud
    environments and future trends in cloud computing. Link: [https://www.coursera.org/learn/serverless-machine-learning-gcp-br](https://www.coursera.org/learn/serverless-machine-learning-gcp-br)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This appendix provides a curated selection of resources, including books, articles,
    and online courses, to deepen your understanding of concurrency, parallelism,
    and cloud-native development in Java. Leveraging these materials will enhance
    your knowledge and skills, enabling you to build robust, scalable, and efficient
    cloud-native Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Answers to the end-of-chapter multiple-choice questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Chapter 1: Concurrency, Parallelism, and the Cloud: Navigating the Cloud-Native
    Landscape'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: B) Easier to scale and maintain individual services
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Synchronization
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: D) Stream API
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) Automatic scaling and management of resources
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Data consistency and synchronization
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 2: Introduction to Java’s Concurrency Foundations: Threads, Processes,
    and Beyond'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C) Threads share a memory space, while processes are independent and have their
    own memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) It offers a set of classes and interfaces for managing threads and processes
    efficiently.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Allowing multiple threads to read a resource concurrently but requiring exclusive
    access for writing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) It allows a set of threads to wait for a series of events to occur.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) It allows for lock-free thread-safe operations on a single integer value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 3: Mastering Parallelism in Java'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: B) To enhance parallel processing by recursively splitting and executing tasks
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) `RecursiveTask` returns a value, while `RecursiveAction` does not
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) It allows idle threads to take over tasks from busy threads
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Balancing task granularity and parallelism level
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) The task’s nature, resource availability, and team expertise
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 4: Java Concurrency Utilities and Testing in the Cloud Era'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C) To efficiently manage thread execution and resource allocation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) `CopyOnWriteArrayList`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Enables asynchronous programming and non-blocking operations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) They enable efficient data handling and reduce locking overhead in concurrent
    access scenarios
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) By offering more control over lock management and reducing lock contention
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 5: Mastering Concurrency Patterns in Cloud Computing'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C) To prevent failures in one service from affecting other services
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Employing a lock-free ring buffer to minimize contention
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) It isolates services to prevent failures in one from cascading to others.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Scatter-Gather pattern
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: D) Resilience and data flow management
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 6: Java and Big Data – a Collaborative Odyssey'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: B) Volume, velocity, and variety
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) **Hadoop Distributed File** **System** (**HDFS**)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) Spark offers faster in-memory data processing capabilities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) Spark can only process structured data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) It helps to break down large datasets into smaller, manageable chunks for
    processing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 7: Concurrency in Java for Machine Learning'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C) To optimize computational efficiency
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) Parallel Streams
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) They improve scalability and manage large-scale computations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) To perform data preprocessing and model training more efficiently
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Combining Java concurrency with generative AI
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 8: Microservices in the Cloud and Java’s Concurrency'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C) Independent deployment and scalability
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) CompletableFuture
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Distributing incoming network traffic across multiple instances
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) Circuit breaker pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) Assigning a separate managed database instance for each microservice
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 9: Serverless Computing and Java’s Concurrent Capabilities'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C) Automatic scaling and reduced operational overhead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) CompletableFuture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) Managing recursive tasks by dividing them into smaller subtasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Optimize function size and use provisioned concurrency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Improved performance through concurrent data processing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 10: Synchronizing Java’s Concurrency with Cloud Auto-Scaling Dynamics'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C) Dynamic resource allocation based on demand
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) `CompletableFuture`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) Managing a fixed number of threads
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) Implementing stateless services
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) Improving performance through concurrent data processing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 11: Advanced Java Concurrency Practices in Cloud Computing'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: D) User interface design
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) Improved performance for parallel tasks
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) VisualVM
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Minimize data loss and improve availability
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) Difficulty in obtaining a cohesive view of distributed operations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 12: The Horizon Ahead'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A) Improved startup time and reduced memory usage
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: D) All of the above
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Google Cloud AutoML
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) Quantum superposition
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) Reduced operational overhead for managing infrastructure
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
