- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: The Horizon Ahead
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前方的地平线
- en: As cloud technologies continue to evolve at a rapid pace, it is crucial for
    developers and organizations to stay ahead of the curve and prepare for the next
    wave of innovations. This chapter will explore the emerging trends and advancements
    in the cloud computing landscape, with a particular focus on Java’s role in shaping
    these future developments.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云计算技术以快速的速度不断发展，开发者和组织必须保持领先，为下一波创新做好准备。本章将探讨云计算领域的兴起趋势和进步，特别关注Java在塑造这些未来发展中扮演的角色。
- en: We will begin by examining the evolution of serverless Java, where frameworks
    such as Quarkus and Micronaut are redefining the boundaries of **functions as
    a service**. These tools leverage innovative techniques, such as native image
    compilation, to deliver unprecedented performance and efficiency in serverless
    environments. Additionally, we will delve into the concept of serverless containers,
    which allow for the deployment of entire Java applications in a serverless fashion,
    harnessing the benefits of container orchestration platforms such as Kubernetes
    and **Amazon Web Services** (**AWS**) Fargate.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探讨无服务器Java的演变，其中像Quarkus和Micronaut这样的框架正在重新定义**函数即服务**的边界。这些工具利用创新技术，如原生图像编译，以在无服务器环境中提供前所未有的性能和效率。此外，我们还将深入研究无服务器容器的概念，它允许以无服务器的方式部署整个Java应用程序，利用Kubernetes和**亚马逊网络服务**（**AWS**）Fargate等容器编排平台的优势。
- en: Next, we will explore the role of Java in the emerging paradigm of edge computing.
    As data processing and decision-making move closer to the source, Java’s platform
    independence, performance, and extensive ecosystem make it an ideal candidate
    for building edge applications. We will discuss the key frameworks and tools that
    enable Java developers to leverage the power of edge computing architectures.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨Java在新兴的边缘计算范式中的作用。随着数据处理和决策越来越接近源头，Java的平台独立性、性能和广泛的生态系统使其成为构建边缘应用的理想选择。我们将讨论使Java开发者能够利用边缘计算架构的强大功能的键框架和工具。
- en: Furthermore, we will investigate Java’s evolving position in the integration
    of **artificial intelligence** (**AI**) and **machine learning** (**ML**) within
    cloud-based ecosystems. From serverless AI/ML workflows to the seamless integration
    of Java with cloud-based AI services, we will explore the opportunities and challenges
    that this convergence presents.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将调查Java在云生态系统内人工智能（**AI**）和机器学习（**ML**）集成中的演变位置。从无服务器AI/ML工作流到Java与基于云的AI服务的无缝集成，我们将探讨这种融合带来的机会和挑战。
- en: Finally, we will delve into the captivating realm of **quantum computing**,
    a field that promises to revolutionize various industries. While still in its
    early stages, understanding the fundamental principles of quantum computing, such
    as qubits, quantum gates, and algorithms, can prepare developers for future advancements
    and their potential integration with Java-based applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将深入探讨迷人的**量子计算**领域，这个领域承诺将彻底改变各个行业。虽然仍处于早期阶段，但了解量子计算的基本原理，如量子比特、量子门和算法，可以为开发者准备未来的进步及其与基于Java的应用程序的潜在集成。
- en: By the end of this chapter, you will have a comprehensive understanding of the
    emerging trends in cloud computing and Java’s pivotal role in shaping these innovations.
    You will be equipped with the knowledge and practical examples to position your
    applications and infrastructure for success in the rapidly evolving cloud landscape.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将全面了解云计算的兴起趋势以及Java在塑造这些创新中的关键作用。你将具备知识和实际示例，以定位你的应用程序和基础设施，在快速发展的云计算领域中取得成功。
- en: 'The following are the key topics that will be covered in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下关键主题：
- en: Future trends in cloud computing and Java’s role
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云计算的未来趋势和Java的角色
- en: Edge computing and Java
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘计算和Java
- en: AI and ML integration
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工智能和机器学习集成
- en: Emerging concurrency and parallel processing tools in Java
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java中新兴的并发和并行处理工具
- en: Preparing for the next wave of cloud innovations
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备迎接下一波云计算创新
- en: So, let’s get started!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To fully engage with [*Chapter 12*](B20937_12.xhtml#_idTextAnchor295)’s content
    and examples, ensure the following are installed and configured:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分参与[*第12章*](B20937_12.xhtml#_idTextAnchor295)的内容和示例，请确保以下内容已安装并配置：
- en: '**Java Development Kit** **or JDK**:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java开发工具包**（**JDK**）：'
- en: 'Quarkus requires a JDK to run. If you don’t have one, download and install
    a recent version (JDK 17 or newer is recommended) from the official source:'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quarkus需要JDK来运行。如果您没有，请从官方源下载并安装最新版本（推荐使用JDK 17或更高版本）：
- en: '**AdoptOpenJDK**: [https://adoptium.net/](https://adoptium.net/)'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AdoptOpenJDK**: [https://adoptium.net/](https://adoptium.net/)'
- en: '**OpenJDK**: [https://openjdk.org/](https://openjdk.org/)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenJDK**: [https://openjdk.org/](https://openjdk.org/)'
- en: '`choco install quarkus`) or Scoop (`scoop` `install quarkus`)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`choco install quarkus`) 或 Scoop (`scoop` `install quarkus`)'
- en: Alternatively, use JBang (`jbang app install --``fresh quarkus@quarkusio`)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，使用JBang (`jbang app install --``fresh quarkus@quarkusio`)
- en: '**Quarkus CLI installation** **guide**: [https://quarkus.io/guides/cli-tooling](https://quarkus.io/guides/cli-tooling)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Quarkus CLI安装** **指南**: [https://quarkus.io/guides/cli-tooling](https://quarkus.io/guides/cli-tooling)'
- en: '`GRAALVM_HOME` environment variable to the GraalVM installation directory.*   Add
    `%GRAALVM_HOME%\bin` to your PATH environment variable.*   **Docker Desktop**:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`GRAALVM_HOME`环境变量设置为GraalVM安装目录。*   将`%GRAALVM_HOME%\bin`添加到您的PATH环境变量中。*   **Docker
    Desktop**：
- en: Download and install Docker Desktop for Windows from [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)下载并安装Windows版的Docker
    Desktop。
- en: Follow the installation wizard and configure Docker as needed.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照安装向导进行操作，并根据需要配置Docker。
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
- en: Future trends in cloud computing and Java’s role
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云计算的未来趋势及Java的角色
- en: As cloud computing continues to evolve, several emerging trends are shaping
    the future of this technology landscape. Innovations such as edge computing, AI
    and ML integration, and serverless architectures are at the forefront, driving
    new possibilities and efficiencies. Java, with its robust ecosystem and continuous
    advancements, is playing a pivotal role in these developments. This section will
    explore the latest trends in cloud computing, how Java is adapting to and facilitating
    these changes, and provide real-world examples of Java’s adoption in cutting-edge
    cloud technologies.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云计算的持续发展，几个新兴趋势正在塑造这一技术领域的未来。边缘计算、AI和ML的集成以及无服务器架构等创新处于前沿，推动新的可能性和效率。Java凭借其强大的生态系统和持续进步，在这些发展中扮演着关键角色。本节将探讨云计算的最新趋势，Java如何适应并促进这些变化，并提供Java在尖端云计算技术中的实际应用案例。
- en: Emerging trends in cloud computing – serverless Java beyond function as a service
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云计算的新兴趋势 – 无服务器Java超越函数即服务
- en: Emerging trends in cloud computing are reshaping the landscape of serverless
    Java, extending beyond the traditional functions-as-a-service model. Innovations
    in serverless Java frameworks such as Quarkus and Micronaut are driving this evolution.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算的新兴趋势正在重塑无服务器Java的格局，超越了传统的函数即服务模型。Quarkus和Micronaut等无服务器Java框架的创新正在推动这一演变。
- en: Quarkus
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Quarkus
- en: '**Quarkus**, recognized for its strengths in microservices, is now making a
    substantial impact in serverless environments. It empowers developers to build
    serverless functions that adhere to microservice principles, seamlessly merging
    these two architectural approaches. A standout feature is Quarkus’ native integration
    with GraalVM, enabling the compilation of Java applications into native executables.
    This is a game-changer for serverless computing, as it tackles the long-standing
    issue of cold start latency. By harnessing GraalVM, Quarkus dramatically reduces
    startup times for Java applications, often from seconds to mere milliseconds,
    compared to traditional **Java virtual machine** (**JVM**) based alternatives.
    Moreover, the resulting native binaries are more memory efficient, facilitating
    optimized scaling and resource utilization in the dynamic world of serverless
    environments. These advancements are revolutionizing serverless Java, providing
    developers with a powerful toolkit to create high-performance, cloud-native applications
    that are both efficient and responsive.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**Quarkus**，因其微服务方面的优势而闻名，现在正在无服务器环境中产生重大影响。它赋予开发者构建遵循微服务原则的无服务器函数的能力，无缝地融合了这两种架构方法。一个突出的特性是
    Quarkus 与 GraalVM 的原生集成，使得可以将 Java 应用程序编译成原生可执行文件。这对于无服务器计算来说是一个变革，因为它解决了长期存在的冷启动延迟问题。通过利用
    GraalVM，Quarkus 显著减少了 Java 应用程序的启动时间，通常从秒级减少到仅仅毫秒级，与传统 **Java 虚拟机**（**JVM**）基于的替代方案相比。此外，生成的原生二进制文件更节省内存，有助于在无服务器环境的动态世界中实现优化的扩展和资源利用。这些进步正在改变无服务器
    Java，为开发者提供了一套强大的工具集，用于创建高效、响应迅速的高性能云原生应用程序。'
- en: Micronaut
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Micronaut
- en: '**Micronaut** is another innovative framework making significant progress in
    the serverless Java space. It is designed to optimize the performance of microservices
    and serverless applications through several key features:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**Micronaut** 是另一个在无服务器 Java 领域取得显著进展的创新框架。它通过几个关键特性设计用于优化微服务和无服务器应用程序的性能：'
- en: '**Compile-time dependency injection**: Unlike traditional frameworks that resolve
    dependencies at runtime, Micronaut performs this task during compilation. This
    approach eliminates the need for runtime reflection, resulting in faster startup
    times and reduced memory consumption.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译时依赖注入**：与在运行时解决依赖的传统框架不同，Micronaut 在编译时执行这项任务。这种方法消除了运行时反射的需求，从而实现了更快的启动时间和更低的内存消耗。'
- en: '**Aspect-oriented programming (AOP)**: AOP is a programming paradigm that increases
    modularity by allowing the separation of cross-cutting concerns. In Micronaut,
    AOP is implemented at compile time rather than runtime. This means that features
    such as transaction management, security, and caching are woven into the bytecode
    during compilation, eliminating the need for runtime proxies and further reducing
    memory usage and startup time.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向方面编程（AOP**）：AOP 是一种编程范式，通过允许分离横切关注点来提高模块化。在 Micronaut 中，AOP 是在编译时而不是在运行时实现的。这意味着事务管理、安全性和缓存等特性在编译期间被编织到字节码中，消除了运行时代理的需求，并进一步减少了内存使用和启动时间。'
- en: These compile-time techniques make Micronaut an ideal choice for building lightweight,
    fast, and efficient serverless applications. The framework’s design is particularly
    well suited to environments where rapid startup and low resource consumption are
    crucial.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些编译时技术使 Micronaut 成为构建轻量级、快速和高效无服务器应用程序的理想选择。该框架的设计特别适合于快速启动和低资源消耗至关重要的环境。
- en: Additionally, Micronaut supports the creation of GraalVM native images. This
    feature further enhances its suitability for serverless environments by minimizing
    cold start times and resource usage, as native images can start almost instantaneously
    and consume less memory compared to traditional JVM-based applications.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Micronaut 支持创建 GraalVM 原生镜像。这一特性通过最小化冷启动时间和资源使用，进一步增强了其在无服务器环境中的适用性，因为原生镜像可以几乎瞬间启动，并且相比传统的基于
    JVM 的应用程序消耗更少的内存。
- en: Serverless containers and Java applications
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无服务器容器和 Java 应用程序
- en: Serverless containers represent another dimension of serverless computing, enabling
    the deployment of entire Java applications rather than individual functions. This
    approach leverages container orchestration platforms such as Kubernetes and AWS
    Fargate to run containers in a serverless fashion. Java applications packaged
    as containers benefit from the same serverless advantages of automatic scaling
    and pay-per-use pricing, but with more control over the runtime environment compared
    to traditional serverless functions. Developers can ensure consistency across
    different environments by packaging the application with its dependencies. Full
    control over the runtime environment allows for the inclusion of necessary libraries
    and tools, providing flexibility that is sometimes lacking in traditional serverless
    functions. Additionally, serverless containers can scale automatically based on
    demand, offering the benefits of serverless computing while maintaining the robustness
    of containerized applications.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: By combining the innovations in serverless Java frameworks such as Quarkus and
    Micronaut with the flexibility of serverless containers, developers can create
    highly scalable, efficient, and responsive Java applications that meet the demands
    of modern cloud-native environments. These advancements are paving the way for
    the next generation of serverless Java, moving beyond simple functions to encompass
    full-fledged applications and services.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Example use-case – building a serverless REST API with Quarkus and GraalVM
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Objective**: Create a serverless REST API for product management and deploy
    it on AWS Lambda using Quarkus, demonstrating key Quarkus features and integration
    with AWS services.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: This example covers key concepts and elements of Quarkus. The full application
    will be available in the GitHub repository.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '**Set up the project**: Use Quarkus CLI or Maven to bootstrap a new project.
    For this example, we’ll use Maven. Run the following Maven command to create the
    Quarkus project:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '@Path("/api/products")'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Produces(MediaType.APPLICATION_JSON)'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Consumes(MediaType.APPLICATION_JSON)'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Tag(name = "Product",'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: description = "Product management operations")
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public class ProductResource {
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Inject'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ProductRepository productRepository;
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@GET'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Counted(name = "getAllProductsCount",'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: description = "How many times getAllProducts has been         invoked")
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Timed(name = "getAllProductsTimer",'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: description = "A measure of how long it takes to perform         getAllProducts",
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: unit = MetricUnits.MILLISECONDS)
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Operation(summary = "Get all products",'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: description = "Returns a list of all products with         pagination and sorting")
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public Response getAllProducts(@QueryParam(
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"page") @DefaultValue("0") int page,'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@QueryParam("size") @DefaultValue("20") int size,'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@QueryParam("sort") @DefaultValue("name") String             sort) {'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Implementation omitted for brevity
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@POST'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Operation(summary = "Create a new product",'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: description = "Creates a new product and returns the         created product")
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: description = "创建一个新的产品并返回创建的产品")
- en: public Response createProduct(Product product) {
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public Response createProduct(Product product) {
- en: // Implementation omitted for brevity
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 省略实现以节省篇幅
- en: '}'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: // Additional CRUD methods omitted for brevity
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 省略其他 CRUD 方法以节省篇幅
- en: '}'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE1]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`ProductRepository`: The `ProductRepository` class acts as the data access
    layer, managing interactions with *AWS DynamoDB* for product data persistence.
    It demonstrates Quarkus’ seamless integration with AWS `DynamoDbClient`, showcasing
    how Quarkus simplifies cloud service integration. It implements methods for **create,
    read, update, and delete** (**CRUD**) operations, translating between Java objects
    and DynamoDB item representations, thus demonstrating how Quarkus applications
    can efficiently work with NoSQL databases in a cloud environment:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ProductRepository`：`ProductRepository` 类充当数据访问层，管理与 *AWS DynamoDB* 的交互以实现产品数据持久化。它展示了
    Quarkus 与 AWS `DynamoDbClient` 的无缝集成，展示了 Quarkus 如何简化云服务集成。它实现了 **创建、读取、更新和删除**
    （**CRUD**） 操作的方法，在 Java 对象和 DynamoDB 项目表示之间进行转换，从而展示了 Quarkus 应用程序如何在云环境中高效地与
    NoSQL 数据库协同工作：'
- en: '[PRE2]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`ImageAnalysisCoordinator`: The `ImageAnalysisCoordinator` class showcases
    Quarkus’ ability to create AWS Lambda functions that interact with multiple AWS
    services. It demonstrates handling **Simple Storage Service** (**S3**) events
    and triggering **Elastic Container Service** (**ECS**) tasks, illustrating how
    Quarkus can be used to build complex, event-driven architectures. This class uses
    dependency injection for AWS clients (ECS and S3), showing how Quarkus simplifies
    working with multiple cloud services in a single component. It’s an excellent
    example of using Quarkus for serverless applications that orchestrate other AWS
    services:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ImageAnalysisCoordinator`：`ImageAnalysisCoordinator` 类展示了 Quarkus 创建与多个 AWS
    服务交互的 AWS Lambda 函数的能力。它展示了处理 **简单存储服务** （**S3**） 事件和触发 **弹性容器服务** （**ECS**） 任务，说明了
    Quarkus 可以用于构建复杂的事件驱动架构。该类使用依赖注入来处理 AWS 客户端（ECS 和 S3），展示了 Quarkus 如何简化在单个组件中与多个云服务协同工作。它是使用
    Quarkus 为无服务器应用程序编排其他 AWS 服务的优秀示例：'
- en: '[PRE3]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`ProductHealthCheck`: The `ProductHealthCheck` class implements Quarkus’ health
    check mechanism, which is crucial for maintaining application reliability in cloud
    environments. It demonstrates the use of Microprofile Health, allowing the application
    to report its status to orchestration systems such as Kubernetes. The class checks
    the accessibility of the DynamoDB table, showcasing how Quarkus applications can
    provide meaningful health information about external dependencies. This component
    is essential for implementing robust microservices that can self-report their
    operational status:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ProductHealthCheck`：`ProductHealthCheck` 类实现了 Quarkus 的健康检查机制，这对于在云环境中维护应用程序可靠性至关重要。它展示了
    Microprofile Health 的使用，允许应用程序向编排系统（如 Kubernetes）报告其状态。该类检查 DynamoDB 表的可访问性，展示了
    Quarkus 应用程序如何提供有关外部依赖的有意义健康信息。该组件对于实现能够自我报告其操作状态的健壮微服务至关重要：'
- en: '[PRE4]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`pom.xml` file includes a profile for native builds. This will specify the
    necessary dependencies and plugins for GraalVM:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pom.xml` 文件包含一个用于原生构建的配置文件。这将指定 GraalVM 所需的依赖项和插件：'
- en: '[PRE5]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`Dockerfile.native`: The provided Dockerfile is essential for building and
    packaging a Quarkus application with GraalVM for deployment on AWS Lambda. It
    starts by using a GraalVM image to compile the application into a native executable,
    ensuring optimal performance and minimal startup time. The build stage includes
    copying the project files and running the Maven build process. Subsequently, the
    runtime stage uses a minimal base image to keep the final image lightweight. The
    compiled native executable is copied from the build stage to the runtime stage,
    where it is set as the entry point for the container. This setup guarantees a
    streamlined and efficient deployment process for serverless environments:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Dockerfile.native`：提供的 Dockerfile 对于使用 GraalVM 构建和打包 Quarkus 应用程序以部署到 AWS
    Lambda 是必需的。它首先使用 GraalVM 镜像将应用程序编译成原生可执行文件，确保最佳性能和最短的启动时间。构建阶段包括复制项目文件和运行 Maven
    构建过程。随后，运行时阶段使用最小的基础镜像以保持最终镜像轻量。编译后的原生可执行文件从构建阶段复制到运行时阶段，在那里它被设置为容器的入口点。这种设置确保了在无服务器环境中的部署过程流畅且高效：'
- en: '[PRE6]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This Dockerfile describes a two-stage build process for a Quarkus native application:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此 Dockerfile 描述了一个用于 Quarkus 原生应用程序的两个阶段构建过程：
- en: '**Build stage**:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构建阶段**:'
- en: Uses a GraalVM-based image to compile the application
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于 GraalVM 的镜像来编译应用程序
- en: Copies project files and builds a native executable
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制项目文件并构建原生可执行文件
- en: '**Runtime stage**:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行时阶段**：'
- en: Uses a minimal Red Hat UBI as the base image
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最小化的 Red Hat UBI 作为基础镜像
- en: Copies the native executable from the build stage
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从构建阶段复制原生可执行文件
- en: Sets the executable as the entry point
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可执行文件设置为入口点
- en: 'Multi-stage builds have the following benefits:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段构建有以下优点：
- en: '**Smaller image size**: The final image is lean, containing only the necessary
    runtime dependencies'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**较小的镜像大小**：最终镜像精简，仅包含必要的运行时依赖项'
- en: '**Improved security**: Reduces the attack surface by including fewer tools
    and packages'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进安全性**：通过包含更少的工具和包来减少攻击面'
- en: '**Clear separation**: Simplifies maintenance by separating the build environment
    from the runtime environment'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清晰的分离**：通过将构建环境与运行时环境分离来简化维护'
- en: Note for Apple Silicon Users
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果硅用户注意事项
- en: When building Docker images on Apple Silicon (M1 or M2) devices, you might encounter
    compatibility issues due to the default **Advance RISC Machine** (**ARM**) architecture.
    Most cloud environments, including AWS, Azure, and Google Cloud, use AMD64 (x86_64)
    architecture. To avoid these issues, specify the target platform when building
    Docker images to ensure compatibility.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当在苹果硅（M1 或 M2）设备上构建 Docker 镜像时，您可能会遇到由于默认的 **高级精简指令集架构**（**ARM**）导致的兼容性问题。大多数云环境，包括
    AWS、Azure 和 Google Cloud，使用 AMD64（x86_64）架构。为了避免这些问题，在构建 Docker 镜像时指定目标平台，以确保兼容性。
- en: Specify the `--platform` argument when building Docker images on Apple Silicon
    devices to ensure compatibility with cloud environments.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在苹果硅设备上构建 Docker 镜像时指定 `--platform` 参数，以确保与云环境兼容。
- en: 'For example, use the following command to build an image compatible with AMD64
    architecture:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用以下命令构建与 AMD64 架构兼容的镜像：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'While the `application.properties` file is not directly used for enabling native
    builds, you can include properties to optimize the application for running as
    a native image. Here is a sample `application.properties` file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `application.properties` 文件不是直接用于启用原生构建，但您可以包含属性以优化应用程序作为原生镜像运行。以下是一个示例 `application.properties`
    文件：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Deploy to** **AWS Lambda:**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**部署到** **AWS Lambda**：'
- en: '`Template.yaml`: An AWS **Serverless Application Model** (**SAM**) template
    that defines the infrastructure for our Quarkus-based Lambda function, specifying
    its runtime environment, handler, resource allocations, and necessary permissions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Template.yaml`：一个 AWS **无服务器应用程序模型**（**SAM**）模板，它定义了基于 Quarkus 的 Lambda 函数的基础设施，指定其运行时环境、处理程序、资源分配和必要的权限：'
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`.``jar` file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`.``jar` 文件：'
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Deploy with SAM CLI**: Use the AWS SAM CLI to package and deploy our Quarkus-based
    Lambda function: the first command packages the application and uploads it to
    an Amazon S3 bucket, while the second command deploys the packaged application
    to AWS, creating or updating a CloudFormation stack with the necessary resources
    and permissions:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 SAM CLI 部署**：使用 AWS SAM CLI 打包和部署基于 Quarkus 的 Lambda 函数：第一个命令打包应用程序并将其上传到
    Amazon S3 桶，而第二个命令将打包的应用程序部署到 AWS，创建或更新一个包含必要资源和权限的 CloudFormation 堆栈：'
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By following these steps, you will have successfully built a serverless REST
    API using Quarkus, packaged it as a native image with GraalVM, and deployed it
    to AWS Lambda. This setup ensures optimal performance and reduces cold start times
    for your serverless application.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些步骤，您将成功构建一个使用 Quarkus 的无服务器 REST API，将其打包为带有 GraalVM 的原生镜像，并部署到 AWS Lambda。这种设置确保了最佳性能，并减少了无服务器应用程序的冷启动时间。
- en: The serverless paradigm continues to evolve, with Java frameworks such as Quarkus
    leading the charge in optimizing for cloud-native, serverless environments. As
    we’ve seen, modern serverless Java applications can leverage advanced features
    such as rapid startup times, low memory footprints, and seamless integration with
    cloud services. This enables developers to build complex, scalable applications
    that go far beyond simple function executions, encompassing full-fledged microservices
    architectures.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器范式正在不断发展，Java 框架如 Quarkus 领先于优化云原生、无服务器环境。正如我们所见，现代无服务器 Java 应用程序可以利用快速启动时间、低内存占用和与云服务无缝集成的先进功能。这使开发者能够构建复杂、可扩展的应用程序，这些应用程序远远超出了简单函数执行的范围，涵盖了完整的微服务架构。
- en: 'As the cloud computing landscape continues to evolve, another emerging trend
    is gaining significant traction: edge computing. Let’s explore how Java is adapting
    to meet the unique challenges and opportunities presented by edge computing environments.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云计算领域的持续演变，另一个新兴趋势正在获得显著的吸引力：边缘计算。让我们探讨Java如何适应边缘计算环境所提出的独特挑战和机遇。
- en: Edge computing and Java
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边缘计算与Java
- en: Edge computing represents a paradigm shift in how data is processed, with computation
    occurring at or near the data source instead of relying solely on centralized
    cloud data centers. This approach reduces latency, optimizes bandwidth usage,
    and improves response times for critical applications.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘计算代表了数据处理范式的一次转变，计算发生在数据源附近或数据源处，而不是仅仅依赖于集中的云数据中心。这种方法减少了延迟，优化了带宽使用，并提高了关键应用的响应时间。
- en: Java’s role in edge computing architectures
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java在边缘计算架构中的作用
- en: Java, with its mature ecosystem and robust performance, is increasingly becoming
    a pivotal player in edge computing architectures.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Java，凭借其成熟的生态系统和强大的性能，正日益成为边缘计算架构中的关键玩家。
- en: Java’s versatility and platform independence make it an ideal candidate for
    edge computing environments, which often consist of heterogeneous hardware and
    **operating systems** (**OSs**). Java’s ability to run on various devices, from
    powerful servers to constrained **internet of things** (**IoT**) devices, ensures
    that developers can leverage a consistent programming model across the entire
    edge-to-cloud continuum. Additionally, the extensive set of libraries and frameworks
    available in the Java ecosystem enables rapid development and deployment of edge
    applications.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Java的通用性和平台独立性使其成为边缘计算环境的理想选择，这些环境通常由异构硬件和**操作系统**（**OSs**）组成。Java能够在各种设备上运行，从强大的服务器到受限的**物联网**（**IoT**）设备，确保开发者可以在整个边缘到云的连续体上利用一致的编程模型。此外，Java生态系统中可用的广泛库和框架使得边缘应用的快速开发和部署成为可能。
- en: 'Key benefits of using Java in edge computing include the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在边缘计算中使用Java的关键优势包括以下内容：
- en: '**Cross-platform compatibility**: Java’s “write once, run anywhere” philosophy
    allows edge applications to be deployed across diverse hardware platforms without
    modification'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台兼容性**：Java的“一次编写，到处运行”理念允许边缘应用在多种硬件平台上部署而无需修改'
- en: '**Performance and scalability**: Java’s robust performance and efficient memory
    management are critical for handling the resource-constrained environments often
    found in edge devices'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能和可伸缩性**：Java强大的性能和高效的内存管理对于处理边缘设备中常见的资源受限环境至关重要'
- en: '**Security**: Java provides a strong security model, which is essential for
    safeguarding sensitive data processed at the edge'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：Java提供强大的安全模型，这对于保护边缘处理敏感数据至关重要'
- en: These advantages make Java a compelling choice for edge computing. To further
    empower developers, several frameworks and tools have been developed to streamline
    Java-based edge application development and deployment.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些优势使Java成为边缘计算的有力选择。为了进一步赋能开发者，已经开发出几个框架和工具，以简化基于Java的边缘应用的开发和部署。
- en: Frameworks and tools for Java-based edge applications
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于基于Java的边缘应用的框架和工具
- en: 'To effectively leverage Java in edge computing, developers can utilize a variety
    of frameworks and tools specifically designed for building and managing edge applications.
    Some of the prominent frameworks and tools include the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地利用Java进行边缘计算，开发者可以利用专门为构建和管理边缘应用而设计的各种框架和工具。以下是一些突出的框架和工具：
- en: '**Eclipse Foundation’s** **IoT initiative**:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eclipse基金会**的**物联网倡议**：'
- en: '**Eclipse Kura**: An open-source framework for building IoT gateways. It provides
    a set of Java APIs for accessing hardware interfaces, managing network configurations,
    and interacting with cloud services.'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eclipse Kura**：一个用于构建物联网网关的开源框架。它提供了一套Java API，用于访问硬件接口、管理网络配置以及与云服务交互。'
- en: '**Eclipse Kapua**: A modular IoT cloud platform that works in conjunction with
    Eclipse Kura to provide end-to-end IoT solutions. It offers features such as device
    management, data management, and application integration.'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eclipse Kapua**：一个模块化的物联网云平台，与Eclipse Kura协同工作，提供端到端的物联网解决方案。它提供设备管理、数据管理和应用集成等功能。'
- en: '**Apache Edgent**: Apache Edgent (formerly known as Quarks) is a lightweight,
    embeddable programming model and runtime for edge devices. It allows developers
    to create analytics applications that can run on small-footprint devices and integrate
    with central data systems.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apache Edgent**：Apache Edgent（之前称为Quarks）是一个轻量级、可嵌入的编程模型和运行时，适用于边缘设备。它允许开发者创建可以在小尺寸设备上运行并集成到中央数据系统的分析应用程序。'
- en: '**Vert.x**: Vert.x is a toolkit for building reactive applications on the JVM.
    Its event-driven architecture and lightweight nature make it well suited for edge-computing
    scenarios where low latency and high concurrency are essential.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vert.x**：Vert.x是一个用于在JVM上构建反应式应用程序的工具包。其事件驱动架构和轻量级特性使其非常适合需要低延迟和高并发的边缘计算场景。'
- en: '**AWS IoT Greengrass**: AWS IoT Greengrass extends AWS capabilities to edge
    devices, enabling them to act locally on the data they generate while still using
    the cloud for management, analytics, and durable storage. Java developers can
    create Greengrass Lambda functions to process and respond to local events.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS IoT Greengrass**：AWS IoT Greengrass将AWS的能力扩展到边缘设备，使它们能够在本地处理它们生成的数据，同时仍然使用云进行管理、分析和持久存储。Java开发者可以创建Greengrass
    Lambda函数来处理和响应本地事件。'
- en: '**Azure IoT Edge**: Azure IoT Edge allows developers to deploy and run containerized
    applications at the edge. Java applications can be packaged in Docker containers
    and deployed using Azure IoT Edge runtime, enabling seamless integration with
    Azure cloud services.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure IoT Edge**：Azure IoT Edge允许开发者将容器化应用程序部署和运行在边缘。Java应用程序可以打包在Docker容器中，并使用Azure
    IoT Edge运行时进行部署，从而实现与Azure云服务的无缝集成。'
- en: '**Google Cloud IoT Edge**: Google Cloud IoT Edge brings Google Cloud’s ML and
    data processing capabilities to edge devices. Java developers can utilize TensorFlow
    Lite and other Google Cloud services to create intelligent edge applications.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Cloud IoT Edge**：Google Cloud IoT Edge将Google Cloud的ML和数据处理能力带到边缘设备。Java开发者可以利用TensorFlow
    Lite和其他Google Cloud服务来创建智能边缘应用程序。'
- en: Java’s robust ecosystem, platform independence, and extensive library support
    make it a strong contender for edge computing. By leveraging frameworks and tools
    designed for edge environments, Java developers can build efficient, scalable,
    and secure edge applications that harness the full potential of edge computing
    architectures. As edge computing continues to evolve, Java is well positioned
    to play a critical role in shaping the future of distributed and decentralized
    data processing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Java的强大生态系统、平台独立性和广泛的库支持使其成为边缘计算的强劲竞争者。通过利用为边缘环境设计的框架和工具，Java开发者可以构建高效、可扩展且安全的边缘应用程序，充分利用边缘计算架构的潜力。随着边缘计算不断演进，Java在塑造分布式和去中心化数据处理未来方面处于有利位置。
- en: AI and ML integration
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AI和ML集成
- en: As we look toward the future of Java in cloud computing, the integration of
    AI and ML presents exciting opportunities and challenges. While [*Chapter 7*](B20937_07.xhtml#_idTextAnchor187)
    focused on Java’s concurrency mechanisms for ML workflows, this section explores
    Java’s evolving role in cloud-based AI/ML ecosystems and its integration with
    advanced cloud AI services.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们展望Java在云计算的未来时，AI和ML的集成带来了令人兴奋的机会和挑战。虽然[第7章](B20937_07.xhtml#_idTextAnchor187)专注于Java在ML工作流程中的并发机制，但本节探讨了Java在基于云的AI/ML生态系统中的演变角色及其与高级云AI服务的集成。
- en: Java’s position in cloud-based AI/ML workflows
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java在基于云的AI/ML工作流程中的位置
- en: 'Here are some of Java’s evolving roles in cloud-based AI/ML ecosystems:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Java在基于云的AI/ML生态系统中的演变角色：
- en: '**Serverless AI/ML with Java**: The future of Java in cloud-based AI/ML workflows
    is increasingly serverless. Frameworks such as AWS Lambda and Google Cloud Functions
    allow developers to deploy AI/ML models as serverless functions. This trend is
    expected to grow, enabling more efficient and scalable AI/ML operations without
    the need for managing infrastructure.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无服务器AI/ML与Java**：Java在基于云的AI/ML工作流程中的未来越来越趋向于无服务器。如AWS Lambda和Google Cloud
    Functions之类的框架允许开发者将AI/ML模型作为无服务器函数部署。这一趋势预计将增长，使AI/ML操作更加高效和可扩展，无需管理基础设施。'
- en: '**Java as an orchestrator**: Java is positioning itself as a powerful orchestrator
    for complex AI/ML pipelines in the cloud. Its robustness and extensive ecosystem
    make it ideal for managing workflows that involve multiple AI/ML services, data
    sources, and processing steps. Expect to see more Java-based tools and frameworks
    designed specifically for AI/ML pipeline orchestration in cloud environments.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 作为编排器**：Java 正在将自己定位为云中复杂 AI/ML 管道的高效编排器。其稳健性和广泛的生态系统使其非常适合管理涉及多个 AI/ML
    服务、数据源和处理步骤的工作流程。预计将出现更多针对云环境中 AI/ML 管道编排设计的基于 Java 的工具和框架。'
- en: '**Edge AI with Java**: As edge computing gains prominence, Java’s *write once,
    run anywhere* philosophy becomes increasingly valuable. Java is being adapted
    for edge AI applications, allowing models trained in the cloud to be deployed
    and run on edge devices. This trend will likely accelerate, with Java serving
    as a bridge between cloud-based training and edge-based inference.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 与边缘 AI**：随着边缘计算的兴起，Java 的“一次编写，到处运行”的理念变得越来越有价值。Java 正在适应边缘 AI 应用程序，允许在云中训练的模型部署并在边缘设备上运行。这一趋势可能会加速，Java
    将作为云端训练和边缘端推理之间的桥梁。'
- en: Next, let’s explore Java’s integration with advanced cloud-based AI services.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索 Java 与高级基于云的 AI 服务的集成。
- en: Integration of Java with cloud AI services
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 与云 AI 服务的集成
- en: 'Integrating Java applications with cloud-based AI services opens up a world
    of possibilities for developers, enabling the creation of intelligent and adaptive
    software solutions. Cloud AI services offer pre-trained models, scalable infrastructure,
    and APIs that make it easier to implement advanced ML and AI capabilities without
    the need for extensive in-house expertise. The following is a list of popular
    cloud AI services that can be integrated with Java applications:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Java 应用程序与基于云的 AI 服务集成，为开发者打开了无限可能，使他们能够创建智能和自适应的软件解决方案。云 AI 服务提供预训练模型、可扩展的基础设施和
    API，使得在不需大量内部专业知识的情况下实现高级机器学习和 AI 功能变得更加容易。以下是可以与 Java 应用程序集成的流行云 AI 服务列表：
- en: '**Native Java SDKs for cloud AI services**: Major cloud providers are investing
    in developing a robust **Java Development Kit** (**JDK**) for their AI services.
    For example, AWS has released the AWS SDK for Java 2.0, which provides streamlined
    access to services such as Amazon SageMaker. Google Cloud has also enhanced its
    Java client libraries for AI and ML services. This trend is expected to continue,
    making it easier for Java developers to integrate cloud AI services into their
    applications.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云 AI 服务的原生 Java SDK**：主要云服务提供商正在投资开发用于其 AI 服务的强大 **Java 开发工具包**（**JDK**）。例如，AWS
    已经发布了 AWS SDK for Java 2.0，它提供了对 Amazon SageMaker 等服务的简化访问。Google Cloud 也增强了其
    AI 和 ML 服务的 Java 客户端库。这一趋势预计将持续，使 Java 开发者更容易将云 AI 服务集成到他们的应用程序中。'
- en: '**Java-friendly AutoML platforms**: Cloud providers are developing AutoML platforms
    that are increasingly Java friendly. For instance, Google Cloud AutoML now offers
    Java client libraries, allowing Java applications to easily train and deploy custom
    ML models without extensive ML expertise. This trend is likely to expand, making
    advanced AI capabilities more accessible to Java developers.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 友好的 AutoML 平台**：云服务提供商正在开发越来越友好的 AutoML 平台。例如，Google Cloud AutoML 现在提供
    Java 客户端库，允许 Java 应用程序轻松训练和部署定制的 ML 模型，而无需广泛的 ML 专业知识。这一趋势可能会扩展，使高级 AI 功能更容易为
    Java 开发者所获取。'
- en: '**Containerized Java AI/ML deployments**: The future of Java in cloud AI/ML
    workflows is closely tied to containerization. Platforms such as Kubernetes are
    becoming the de facto standard for deploying and managing AI/ML workloads in the
    cloud. Java’s compatibility with containerization technologies positions it well
    for this trend. Expect to see more tools and best practices emerge for deploying
    Java-based AI/ML applications in containerized environments.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器化的 Java AI/ML 部署**：Java 在云 AI/ML 工作流程中的未来与容器化紧密相连。Kubernetes 等平台正在成为在云中部署和管理
    AI/ML 工作负载的事实标准。Java 与容器化技术的兼容性使其非常适合这一趋势。预计将出现更多工具和最佳实践，用于在容器化环境中部署基于 Java 的
    AI/ML 应用程序。'
- en: '**Java in federated learning**: Federated learning is an ML technique that
    trains algorithms across multiple decentralized edge devices or servers holding
    local data samples, without exchanging them. This approach addresses growing privacy
    concerns by allowing model training on distributed datasets without centrally
    pooling the data.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As privacy concerns grow, federated learning is gaining traction. Java’s robust
    security features and its wide adoption in enterprise environments make it a strong
    candidate for implementing federated learning systems. Cloud providers are likely
    to offer more support for Java in their federated learning offerings, enabling
    models to be trained across decentralized data sources without compromising privacy.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Java for Machine Learning Operations (MLOps)**: The emerging field of MLOps
    is seeing increased adoption of Java. Its stability and extensive tooling make
    Java well suited for building robust MLOps pipelines in the cloud. Expect to see
    more Java-based MLOps tools and integrations with cloud CI/CD services specifically
    designed for AI/ML workflows.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, Java’s role in cloud-based AI/ML is evolving beyond just a language
    for implementing algorithms. It’s becoming a crucial part of the broader AI/ML
    ecosystem in the cloud, from serverless deployments to edge computing, and from
    AutoML to MLOps. As cloud AI services continue to mature, Java’s integration with
    these services will deepen, offering developers powerful new ways to build intelligent,
    scalable applications in the cloud.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Use case – serverless AI image analysis with AWS Lambda and Fargate
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This use case demonstrates a scalable, serverless architecture for AI-powered
    image analysis using AWS Lambda and Fargate. AWS Fargate is AWS’s implementation
    of serverless containers. This technology allows for the deployment of entire
    Java applications in a serverless fashion, leveraging container orchestration
    platforms such as Kubernetes and AWS Fargate. By packaging Java applications as
    containers, developers can enjoy the benefits of serverless computing – such as
    automatic scaling and pay-per-use pricing – while maintaining control over the
    runtime environment. This approach ensures consistency across different environments,
    provides flexibility with the inclusion of necessary libraries and tools, and
    offers robust scalability.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'The system consists of two main components, each built as a separate Quarkus
    project:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '`ImageAnalysisCoordinator`:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built as a native executable for optimal performance in a serverless environment
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggered when an image is uploaded to an S3 bucket
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Performs quick analysis using Amazon Rekognition
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Initiates a more detailed analysis by launching an AWS Fargate task
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FargateImageAnalyzer`:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built as a JVM-based application and containerized using Docker
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Runs as a task in AWS Fargate when triggered by the Lambda function
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Performs in-depth image processing using advanced AI techniques
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Stores detailed analysis results back in S3
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This two-component architecture allows for efficient resource utilization:
    the lightweight Lambda function handles the initial processing and orchestration,
    while the Fargate container manages the more intensive computational tasks. Together,
    they form a robust, scalable solution for serverless AI-powered image analysis.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1: Create a** **Fargate container**:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '`Dockerfile.jvm`: The `Dockerfile.jvm` is used to build the Docker image for
    the Fargate container component of the serverless AI image analysis architecture.
    Unlike the Lambda function, which is built as a native executable, the Fargate
    container runs the `FargateImageAnalyzer` application as a JVM-based Quarkus application.
    This choice is due to the Fargate container being responsible for the more computationally
    intensive image processing tasks, where the benefits of the Quarkus framework
    can outweigh the potential performance advantages of a native executable.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'This Dockerfile defines the steps to build a Docker image for a Quarkus application.
    The image is designed to run within a Red Hat **Universal Base Image** (**UBI**)
    environment with OpenJDK 17:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`FargateImageAnalyzer.java` performs in-depth image processing:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `FargateImageAnalyzer` class is the main application that runs inside the
    Fargate container as part of the serverless AI image analysis architecture. It
    is designed as a Quarkus application and implements the `QuarkusApplication` interface.
    The class is responsible for extracting the S3 bucket and object key information,
    using the AWS Rekognition client to perform image analysis, generating a detailed
    analysis result, and storing it back in the same S3 bucket. It is designed to
    run as a standalone Quarkus application within the Fargate task, leveraging the
    benefits of running in a containerized environment and the ease of deployment
    and scaling that Fargate provides.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2: Create a** **Lambda function**:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '`Dockerfile.native`: This Dockerfile is used to build the Docker image for
    the native executable of the Lambda function component in the serverless AI image
    analysis architecture. This Dockerfile follows the Quarkus convention for building
    native executables by using the `quay.io/quarkus/ubi-quarkus-native-image` base
    image and performing the necessary build steps. By using `Dockerfile.native`,
    the Lambda function can be packaged as a native executable, which provides improved
    performance and reduced cold start times compared to a JVM-based deployment. This
    is particularly beneficial for serverless applications where rapid response times
    are crucial:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`ImageAnalysisCoordinator.java`: This is an AWS Lambda function that gets triggered
    when a new image is uploaded to an S3 bucket:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `ImageAnalysisCoordinator` class is an AWS Lambda function that serves
    as the entry point for the serverless AI image analysis architecture. Its primary
    responsibilities are as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the S3 bucket and object key information from the incoming S3 event
    that triggers the Lambda function
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initiating a Fargate task to perform the computationally intensive image analysis
    by launching an ECS task and passing the necessary environment variables (bucket
    and key)
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling any errors that occur during the Fargate task launch process and returning
    appropriate status messages
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This Lambda function acts as a lightweight coordinator, responsible for orchestrating
    the overall image analysis workflow. It triggers the more resource-intensive processing
    to be performed by the Fargate container, which runs the `FargateImageAnalyzer`
    application. By separating the responsibilities in this way, the architecture
    achieves efficient resource utilization and scalability.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3: Build** **the projects**:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'For the Lambda function, run the following command to package the function:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For the Fargate container, run the following command to build the Docker image:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Step** **4: Deploy**:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'To streamline the deployment of the serverless AI infrastructure, an AWS CloudFormation
    template has been prepared. This template automates the entire deployment process,
    including the following steps:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the necessary AWS resources, such as the following:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: S3 bucket for storing the images and analysis results
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ECS cluster and task definition for the Fargate container
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda function for the `ImageAnalysisCoordinator` class
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Upload the built artifacts (Lambda function `.jar` file and Docker image) to
    the appropriate locations.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the necessary permissions and triggers for the Lambda function to
    be invoked when an image is uploaded to the S3 bucket.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the Fargate task definition and set up the necessary network configurations.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To use the CloudFormation template, you can find it in the book’s accompanying
    GitHub repository alongside the source code. Simply download the template, fill
    in any necessary parameters, and deploy it using the AWS CloudFormation service.
    This will set up the entire serverless AI infrastructure for you, streamlining
    the deployment process and ensuring consistency across different environments.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Emerging concurrency and parallel processing tools in Java
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Java continues to evolve, new tools and frameworks are being developed to
    address the growing demands of concurrent and parallel programming. These advancements
    aim to simplify development, improve performance, and enhance scalability in modern
    applications.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Project Loom – virtual threads for efficient concurrency
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Project Loom** is an ambitious initiative by the OpenJDK community to enhance
    Java’s concurrency model. The primary goal is to simplify writing, maintaining,
    and observing high-throughput concurrent applications by introducing virtual threads
    (also known as **fibers**).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Virtual threads are lightweight and are managed by the Java runtime rather than
    the OS. Unlike traditional threads, which are limited by the number of OS threads,
    virtual threads can scale to handle millions of concurrent operations without
    overwhelming system resources. They allow developers to write code in a synchronous
    style while achieving the scalability of asynchronous models.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Its key features include the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '**Lightweight nature**: Virtual threads are much lighter than traditional OS
    threads, reducing memory and context-switching overhead'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blocking calls**: They handle blocking calls efficiently, suspending only
    the virtual thread while keeping the underlying OS thread available for other
    tasks'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity**: Developers can write straightforward, readable code using familiar
    constructs such as loops and conditionals without resorting to complex asynchronous
    paradigms'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To illustrate the practical application of Project Loom and virtual threads,
    let’s explore a code example that demonstrates implementing a high-concurrency
    microservice using Project Loom and Akka within an AWS cloud environment.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Code example – implementing a high-concurrency microservice using Project Loom
    and Akka for the AWS cloud environment
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will demonstrate how to implement a high-concurrency microservice
    using Project Loom and Akka, designed to run in an AWS cloud environment. This
    example will showcase how to leverage virtual threads from Project Loom and the
    actor model provided by Akka to build a scalable and efficient microservice:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '`pom.xml` dependencies:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Step 2:** **Code implementation**:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '`HighConcurrencyService.java`: The main entry point for the service, which
    sets up `ActorSystem` and uses `ExecutorService` to manage virtual threads:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `HighConcurrencyService` class serves as the entry point for a high-concurrency
    microservice application designed to handle numerous requests efficiently. Utilizing
    Akka’s actor model and Java’s concurrency features, this class demonstrates how
    to manage thousands of concurrent tasks effectively. The main function initializes
    `ActorSystem` for creating and managing actors, sets up an S3 client for interacting
    with AWS S3 services, and employs an executor service to submit multiple tasks.
    Each task involves creating a new actor instance to handle a specific request,
    showcasing how to leverage virtual threads and actors for scalable and concurrent
    processing in a cloud environment.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '`RequestHandlerActor.java`: This actor handles individual requests to process
    data and interact with AWS S3:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `RequestHandlerActor` class defines the behavior of an actor responsible
    for handling individual requests in the high-concurrency microservice. It processes
    requests to store data in AWS S3 by utilizing the S3 client. The `HandleRequest`
    inner class encapsulates the details of a request, including the S3 bucket name,
    key, and content to be stored. The actor’s behavior is defined as receiving these
    `HandleRequest` messages, processing the request by interacting with the S3 service,
    and logging the result. This class exemplifies the use of Akka’s actor model to
    manage and process concurrent tasks efficiently, ensuring scalability and robustness
    in cloud-based applications.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3: Deployment** **to AWS**:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '**Dockerfile**: The Dockerfile should be created and saved in the root directory
    of your application project. This is the standard location for the Dockerfile,
    as it allows the Docker build process to access all the necessary files and resources
    without requiring additional context switches:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The key points about this Dockerfile are as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'It uses the `amazoncorretto: 17-alpine` base image, which provides the Java
    17 runtime environment based on the Alpine Linux distribution'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It follows a two-stage build process:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *builder* stage compiles the application and packages it into a JAR file
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The final stage copies the packaged JAR file and sets the entry point to run
    the application
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deploy using** **AWS ECS/Fargate**:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also prepared a CloudFormation template for these processes, which
    can be found in the code repository. Follow these steps to deploy:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '**Create an ECS cluster and task definition in AWS**: Set up your ECS cluster
    and define the task that will run your Docker container.'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Upload the Docker image to Amazon Elastic Container Registry (ECR)**: Push
    the Docker image to Amazon ECR for easy deployment.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Configure ECS service to use Fargate and run the container**: Configure your
    ECS service to use AWS Fargate, a serverless compute engine, to run the containerized
    application.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This streamlined process ensures that your high-concurrency microservice is
    efficiently deployed in a scalable cloud environment.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: This high-concurrency microservice example demonstrates the power of leveraging
    Project Loom’s virtual threads and Akka’s actor model to build scalable, efficient,
    and cloud-ready applications. By harnessing these advanced concurrency tools,
    developers can simplify their code, improve resource utilization, and enhance
    the overall performance and responsiveness of their services, particularly in
    the context of the AWS cloud environment. This lays the foundation for exploring
    the next wave of cloud innovations, where emerging technologies such as AWS Graviton
    processors and Google Cloud Spanner can further enhance the scalability and capabilities
    of cloud-based applications.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for the next wave of cloud innovations
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As cloud technologies continue to evolve rapidly, developers and organizations
    must stay ahead of the curve. Anticipating advancements in cloud services, here’s
    how you can prepare for upcoming advancements in cloud services:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS Graviton**: AWS Graviton is a family of ARM-based processors designed
    by AWS to offer improved price performance compared to traditional x86-based processors,
    particularly for workloads that can take advantage of the parallel processing
    capabilities of ARM architecture. The latest **Graviton3** iteration can provide
    up to 25% better performance and 60% better price performance than previous-generation
    Intel-based EC2 instances.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Corretto**: On the other hand, Amazon Corretto is a no-cost, multiplatform,
    production-ready distribution of the OpenJDK, a free and open-source implementation
    of the Java platform. Corretto is available for both x86-based and ARM-based (including
    Graviton) architectures, providing a certified, tested, and supported version
    of the JDK for AWS customers. The ARM-based Corretto JDK is optimized to run on
    AWS Graviton-powered instances.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider using the Amazon Corretto JDK. Here is a code snippet to build a Docker
    image:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Build and push run the following command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Google Cloud Spanner**: Cloud Spanner is a fully managed, scalable, relational
    database service offering strong consistency and high availability:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '**Global distribution**: Spanner supports multi-regional and global deployment,
    providing high availability and low-latency access to data'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strong consistency**: Unlike many NoSQL databases, Spanner maintains strong
    consistency, making it suitable for applications that require transactional integrity'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Seamless scaling**: Spanner automatically handles horizontal scaling, allowing
    applications to grow without compromising performance or availability'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example**: Using Java with Cloud Spanner:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code snippet demonstrates the use of the Java client library to interact
    with Google Cloud Spanner. The code first creates a Spanner client using the `SpannerOptions`
    builder and retrieves the service instance. It then gets a `DatabaseClient` instance,
    which is used to interact with a specific Spanner database identified by the `projectId`,
    `instanceId`, and `databaseId` parameters.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Within a try-with-resources block, the code creates a single-use, read-only
    transaction using the `singleUse()` method and executes a `SQL SELECT` query to
    retrieve all records from the `Users` table. The results are then iterated through,
    and the `UserId` and `Name` columns are printed for each user record.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: This example showcases the basic usage of the Google Cloud Spanner Java client
    library, including establishing a connection to the database, executing a query,
    and processing the results, while ensuring proper resource management and cleanup.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Quantum computing
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Quantum computing**, though still in its early stages, promises to revolutionize
    various industries by solving complex problems that are infeasible for classical
    computers. Quantum computers leverage the principles of quantum mechanics, such
    as superposition and entanglement, to perform computations in parallel.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: While not immediately practical for most applications, it’s beneficial to start
    learning about quantum computing principles and how they might apply to your domain.
    Key concepts to explore include qubits, quantum gates, and quantum algorithms
    such as Shor’s algorithm for factoring large numbers and Grover’s algorithm for
    search problems.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Understanding these principles will prepare you for future advancements and
    potential integration of quantum computing into your workflows. By familiarizing
    yourself with the foundational concepts now, you’ll be better positioned to take
    advantage of quantum computing as it becomes more accessible and applicable to
    real-world problems.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Staying informed and exploring these technologies, even at an introductory level,
    will help ensure your organization is ready to adapt and thrive in the rapidly
    evolving cloud landscape.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the final chapter of this book, we now stand at the precipice of the future,
    where cloud technologies continue to evolve at a breathtaking pace. In this concluding
    section, we explored the emerging trends and advancements that are poised to reshape
    the way we develop and deploy applications in the cloud, with a particular emphasis
    on Java’s pivotal role in shaping these innovations.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: We began by delving into the evolution of serverless Java, where we saw how
    frameworks such as Quarkus and Micronaut are redefining the boundaries of function
    as a service. These cutting-edge tools leverage techniques such as native image
    compilation to deliver unprecedented performance and efficiency in serverless
    environments, while also enabling the deployment of full-fledged Java applications
    as serverless containers. This represents a significant shift, empowering developers
    to create highly scalable, responsive, and cloud-native applications that go beyond
    simple function executions.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Next, we turned our attention to the edge computing landscape, where data processing
    and decision-making are moving closer to the source. Java’s platform independence,
    performance, and extensive ecosystem make it an ideal choice for building edge
    applications. We introduced the key frameworks and tools that enable Java developers
    to leverage the power of edge computing, ensuring their applications can seamlessly
    integrate with this rapidly advancing paradigm.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we explored Java’s evolving role in the integration of AI and ML
    within cloud-based ecosystems. From serverless AI/ML workflows to the seamless
    integration of Java with cloud-based AI services, we uncovered the opportunities
    and challenges that this convergence presents, equipping you with the knowledge
    to harness the power of these technologies in your Java-based applications.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we ventured into the captivating realm of quantum computing, a field
    that promises to revolutionize various industries. While still in its early stages,
    understanding the fundamental principles of quantum computing, such as qubits,
    quantum gates, and algorithms, can prepare developers for future advancements
    and their potential integration with Java-based applications.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: As we conclude this book, you now possess a comprehensive understanding of the
    emerging trends in cloud computing and Java’s pivotal role in shaping these innovations.
    Armed with this knowledge, you are poised to position your applications and infrastructure
    for success in the rapidly evolving cloud landscape, ensuring your organization
    can adapt and thrive in the years to come.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a key benefit of using Quarkus and GraalVM for building serverless Java
    applications?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Improved startup time and reduced memory usage
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Easier integration with cloud-based AI/ML services
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Seamless deployment across multiple cloud providers
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is a key advantage of using Java in edge computing environments?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Platform independence
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Extensive library support
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Robust security model
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which cloud AI service allows Java developers to easily train and deploy custom
    ML models without extensive ML expertise?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS SageMaker
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Google Cloud AutoML
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Microsoft Azure Cognitive Services
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: IBM Watson Studio
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which quantum computing concept is demonstrated in the provided code example
    that puts a qubit into superposition and measures the outcome?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quantum entanglement
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Quantum teleportation
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Quantum superposition
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Quantum tunneling
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a key benefit of using serverless containers for Java applications in
    the cloud?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reduced operational overhead for managing infrastructure
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Increased cold start times for serverless functions
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Inability to include custom libraries and dependencies
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Limited control over the runtime environment
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Appendix A: Setting up a Cloud-Native Java Environment'
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Appendix A*](B20937_AppA.xhtml#_idTextAnchor321), you will learn how to
    set up a cloud-native environment for Java applications. This comprehensive guide
    covers everything from building and packaging Java applications to deploying them
    on popular cloud platforms like **Amazon Web Services** (**AWS**), **Microsoft
    Azure**, and **Google Cloud Platform** (**GCP**). Key topics include:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '**Building and packaging**: Step-by-step instructions on using build tools
    like Maven and Gradle to create and manage Java projects.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ensuring cloud-readiness**: Best practices for making your Java applications
    stateless and configurable to thrive in cloud environments.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containerization**: How to create Docker images for your Java applications
    and deploy them using Docker.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud deployments**: Detailed procedures for deploying Java applications
    on AWS, Azure, and GCP, including setting up the necessary cloud environments,
    creating and managing cloud resources, and using specific cloud services like
    Elastic Beanstalk, Kubernetes, and serverless functions.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this appendix, you will have a solid understanding of how to effectively
    build, package, containerize, and deploy Java applications in a cloud-native environment.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: General approach – build and package Java applications
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section provides a detailed guide on the essential steps required to build
    and package your Java applications, ensuring they are ready for deployment in
    a cloud environment.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Ensure your app is cloud-ready
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`application.properties` or `application.yaml` files, or by using a configuration
    management tool. Here is an example:'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Use a Build tool like Maven or Gradle
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pom.xml` file in your project root directory if it doesn’t already exist.
    Add the necessary dependencies. Here is an example of `pom.xml`:'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`build.gradle` file in your project root directory if it doesn’t already exist.
    Add the necessary dependencies, here is an example of `build.gradle`:'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Build the JAR file**: Build the JAR file using Maven or Gradle.'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Maven**: Run the following command:'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This command will generate a JAR file in the target directory, typically named
    `myapp-1.0-SNAPSHOT.jar`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '**Gradle**: Run the following command:'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This command will generate a JAR file in the build/libs directory, typically
    named `myapp-1.0-SNAPSHOT.jar`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Note:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: If you are not using containers, you can stop here. The JAR file located in
    the target or build/libs directory can now be used to run your application directly.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Containerize your application using Docker
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Create a Dockerfile**: Create a Dockerfile in your project root directory
    with the following content:'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Make sure to adjust the COPY instruction if your JAR file is located in a different
    directory or has a different name.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Build the** **Docker Image**:'
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Build the Docker image using the Docker build command. Run this command in
    the directory where your Dockerfile is located:'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This command will create a Docker image named `myapp` with the tag `1.0`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '**Run the Docker Container**: Run the Docker container using the docker run
    command:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This command will start a container from the `myapp:1.0` image and map port
    `8080` of the container to port 8080 on your host machine.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: This section provides a detailed guide on the essential steps required to build
    and package your Java applications, ensuring they are ready for deployment in
    a cloud environment.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: After learning how to build and package your Java applications, the next step
    is to explore the specific procedures for deploying these applications on popular
    cloud platforms.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '**Step-by-step guides for deploying Java applications on popular** **cloud
    platforms:**'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the AWS environment
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`aws configure` and enter your AWS Access Key, Secret Key, region, and output
    format.'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`trust-policy.json`'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Deploy your Java application to AWS using WAS CLI: Elastic Beanstalk (PaaS)'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the IAM role:'
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Attach the required policies to the role:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create the instance profile:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the role to the instance profile:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Deploying to Elastic Beanstalk
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an Elastic Beanstalk Application:'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Create a new Elastic Beanstalk environment using the latest Corretto 21 version
    on Amazon Linux 2023.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Uploads `my-application.jar` to the deployments folder in the my-bucket S3 bucket.
    Adjust the parameters as needed for your specific use case.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Create a new application version in Elastic Beanstalk
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Update the Elastic Beanstalk environment to use the new application version
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Check the environment health
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Deploy your Java application: ECS (Containers)'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Push the Docker image to Amazon **Elastic Container Registry** (**ECR**): First,
    create an ECR repository:'
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Authenticate Docker to your ECR:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Tag your Docker image:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Push your Docker image to ECR:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Set up `task-definition.json` with the task definition configuration:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Register the task definition:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create a Cluster:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**Create a Service**: Create a service using the following command:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Important notes
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Replace subnet-XXXXXXXXXXXXXXXXX with the actual ID of the subnet where you
    want to run your tasks.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Replace sg-XXXXXXXXXXXXXXXXX with the actual ID of the security group you want
    to associate with your tasks.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: This command uses forward slashes (\) for line continuation, which is appropriate
    for Unix-like environments (Linux, macOS, Git Bash on Windows).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: For Windows Command Prompt, replace the backslashes (\) with caret symbols (^)
    for line continuation.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: For PowerShell, use backticks (`) at the end of each line instead of backslashes
    for line continuation.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: The --desired-count 1 parameter specifies that you want one task running at
    all times.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: The --launch-type FARGATE parameter specifies that this service will use AWS
    Fargate, which means you don’t need to manage the underlying EC2 instances.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Deploy your Java serverless Lambda function
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an AWS Lambda function role:'
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Attach the `AWSLambdaBasicExecutionRole` policy to the role:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create the Lambda function:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**Invoke the Lambda function**: When using the aws lambda invoke command to
    test your AWS Lambda function, it’s important to update the --payload parameter
    to match the expected input format of your specific Lambda function.'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Check the response:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now that you have an understanding of how to set up a cloud-native Java environment
    and deploy your applications on various cloud platforms, you may want to dive
    deeper into specific cloud services. The following links provide additional resources
    and documentation to help you further your knowledge and skills in deploying and
    managing Java applications in the cloud.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Useful links for further information on AWS
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon EC2**: Getting Started with Amazon EC2 ([https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EC2_GetStarted.html](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EC2_GetStarted.html))'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS Elastic Beanstalk**: Getting Started with AWS Elastic Beanstalk ([https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/GettingStarted.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/GettingStarted.html))'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon ECS**: Getting Started with Amazon ECS ([https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_GetStarted.html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_GetStarted.html))'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS Lambda**: Getting Started with AWS Lambda ([https://docs.aws.amazon.com/lambda/latest/dg/getting-started.html](https://docs.aws.amazon.com/lambda/latest/dg/getting-started.html))'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Managing environment variables**: Best practices for managing environment
    variables in AWS Lambda ([https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html))'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Azure
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn the steps required to deploy Java applications
    on Microsoft Azure. This includes setting up the Azure environment, deploying
    applications on virtual machines and containers, and utilizing **Azure Kubernetes
    Service** (**AKS**) for containerized applications. Additionally, you will explore
    how to deploy Java functions on Azure Functions, enabling you to leverage serverless
    computing for your Java applications.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up the Azure environment:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Download and install Azure CLI**: Follow the official installation instructions
    for your operating system from the Azure CLI installation guide ([https://learn.microsoft.com/en-us/cli/azure/install-azure-cli](https://learn.microsoft.com/en-us/cli/azure/install-azure-cli)).'
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Configure Azure CLI**: Open your terminal or command prompt and run the following
    command to log in to your Azure account:'
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Follow the instructions to log in to your Azure account.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will learn how to deploy a regular Java application on Azure Virtual
    Machines.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '**Deploying a Regular Java Application on Azure** **Virtual Machines**'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Resource Group:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create a Virtual Machine:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Open port 8080:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'SSH into the VM:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Install Java on the VM:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Transfer and Run the JAR File:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Once you have successfully deployed your Java application on an Azure Virtual
    Machine, you can manage and scale your application as needed using the Azure portal
    and CLI tools. This approach provides a solid foundation for running traditional
    Java applications in a cloud environment.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will learn how to deploy a Java application in containers using AKS,
    which offers a more flexible and scalable solution for containerized applications.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '**Deploying a Java Application in Containers** **on AKS**'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an **Azure Container** **Registry** (**ACR**):'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Login to ACR:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Tag and push Docker image to ACR:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Create AKS Cluster:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Get AKS Credentials:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Deploy the application to AKS:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a Deployment YAML file (`deployment.yaml`):'
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Apply the deployment:'
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Expose the deployment:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This completes the process of deploying a containerized Java application to
    AKS. However, for scenarios where you need more granular control over your application’s
    execution or want to build serverless microservices, Azure Functions provides
    an excellent alternative. Next, you will learn how to deploy Java functions on
    Azure Functions, enabling you to take advantage of serverless computing for event-driven
    applications and microservices.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '**Deploying Java Functions on** **Azure Functions**'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Azure functions core tools:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Windows**: Use MSI installer ([https://learn.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=windows%2Cisolated-process%2Cnode-v4%2Cpython-v2%2Chttp-trigger%2Ccontainer-apps&pivots=programming-language-csharp#v2](https://learn.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=windows%2Cisolated-process%2Cnode-v4%2Cpython-v2%2Chttp-trigger%2Ccontainer-apps&pivots=programming-language-csharp#v2))'
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**macOS**:'
  id: totrans-448
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Create a new function app:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Build the function:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Deploy to Azure:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Notes
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Replace placeholders like <vm-ip-address>, <your-region>, <FunctionAppName>,
    etc., with your actual values.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'For detailed information on configuring environment variables and managing
    configurations specifically for Azure environments, you can refer to the official
    Azure documentation:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure App Service configuration**: Configure apps in Azure App Service ([https://learn.microsoft.com/en-us/azure/app-service/configure-common?tabs=portal](https://learn.microsoft.com/en-us/azure/app-service/configure-common?tabs=portal))'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AKS configuration**: Best practices for cluster and node pool configuration
    in AKS ([https://learn.microsoft.com/en-us/azure/aks/operator-best-practices-scheduler](https://learn.microsoft.com/en-us/azure/aks/operator-best-practices-scheduler))'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure functions configuration**: Configure function app settings in Azure
    functions ([https://learn.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings?tabs=azure-portal%2Cto-premium](https://learn.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings?tabs=azure-portal%2Cto-premium))'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you’ve learned how to deploy Java applications on various Azure services,
    including virtual machines, AKS, and Azure Functions, let’s explore another major
    cloud provider. The following section will guide you through similar deployment
    processes on GCP, allowing you to broaden your cloud deployment skills across
    different environments.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: Google Cloud Platform
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you’ll learn how to deploy Java applications on **Google Cloud
    Platform** or **GCP**, one of the leading cloud service providers. GCP offers
    a wide range of services that cater to various deployment needs, from virtual
    machines to containerized environments and serverless functions. We’ll cover the
    setup process for GCP and guide you through deploying Java applications using
    different GCP services, including **Google Compute Engine** (**GCE**), **Google
    Kubernetes Engine** (**GKE**), and Google Cloud Functions. This knowledge will
    empower you to leverage GCP’s robust infrastructure and services for your Java
    applications.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Google Cloud Environment
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a Google Cloud account if you don’t have one.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the Google Cloud SDK. Follow the instructions for your operating system
    from the official Google Cloud SDK documentation ([https://cloud.google.com/sdk/docs/install](https://cloud.google.com/sdk/docs/install))
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Initialize the Google Cloud SDK:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Follow the prompts to log in and select your project.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set your project ID:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: With your Google Cloud environment successfully set up, you are now prepared
    to deploy and manage Java applications using GCP’s robust infrastructure. In the
    next sections, you will explore specific methods for deploying Java applications
    on GCE, GKE, and Google Cloud Functions.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: Deploy your Java application to Google Cloud
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**GCE for regular** **Java Applications**:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a VM instance:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'SSH into the VM:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Install Java on the VM:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Transfer your JAR file to the VM:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Run your Java application:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: By following these steps, you can efficiently deploy and manage your Java applications
    on Google Cloud, leveraging the various services and tools provided by GCP. With
    your Java application successfully deployed to Google Cloud, you are now ready
    to explore containerized deployments using GKE, which offers powerful orchestration
    capabilities for managing containers at scale.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: GKE for containerized applications
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you will learn how to deploy Java applications in containers
    using GKE. GKE provides a managed environment for deploying, managing, and scaling
    containerized applications using Kubernetes. You will be guided through setting
    up a GKE cluster, deploying your Docker images, and managing your containerized
    applications efficiently.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a GKE cluster:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Get credentials for the cluster:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Push your Docker image to **Google Container** **Registry** (**GCR**):'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Create a Kubernetes deployment: Create a file named deployment.yaml:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Apply the deployment:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Expose the deployment:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: By leveraging GKE, you can take full advantage of Kubernetes’ robust features
    to ensure your containerized Java applications are highly available, scalable,
    and easy to maintain.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: Google Cloud Functions for serverless Java functions
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you will learn how to deploy Java functions using Google Cloud
    Functions, enabling you to run event-driven code in a fully managed serverless
    environment. You will be guided through setting up your development environment,
    creating and deploying your Java functions, and managing them effectively using
    Google Cloud’s powerful serverless tools.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory for your function:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Initialize a new Maven project:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Add the necessary dependencies to your `pom.xml`:'
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Create your function class:'
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Deploy the function:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: These instructions provide a basic setup for deploying Java applications to
    Google Cloud using different services. Remember to adjust the commands and configurations
    based on your specific application requirements and Google Cloud project settings.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: Useful links for further information
  id: totrans-515
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Google Compute Engine**: Get started creating and managing virtual machines
    in GCP with the Compute Engine quickstart guide: [https://cloud.google.com/compute/docs/quickstart](https://cloud.google.com/compute/docs/quickstart)'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Kubernetes Engine**: Dive into container orchestration with GKE and
    deploy your first Kubernetes cluster using the GKE quickstart: [https://cloud.google.com/kubernetes-engine/docs/quickstart](https://cloud.google.com/kubernetes-engine/docs/quickstart)'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Cloud Functions**: Develop and deploy serverless functions that respond
    to events with the Cloud Functions deployment guide: [https://cloud.google.com/functions/docs/deploying](https://cloud.google.com/functions/docs/deploying)'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Managing environment** **variables**: [https://cloud.google.com/run/docs/configuring/services/environment-variables](https://cloud.google.com/run/docs/configuring/services/environment-variables)'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Appendix B: Resources and Further Reading'
  id: totrans-520
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recommended books, articles, and online courses
  id: totrans-521
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapters 1–3
  id: totrans-522
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Books
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Cloud Native Java: Designing Resilient Systems with Spring Boot, Spring Cloud,
    and Cloud Foundry* by Josh Long and Kenny Bastani. This comprehensive guide offers
    practical insights into building scalable, resilient Java applications for cloud
    environments, covering Spring Boot, Spring Cloud, and Cloud Foundry technologies.
    Link: [https://www.amazon.com/Cloud-Native-Java-Designing-Resilient/dp/1449374646](https://www.amazon.com/Cloud-Native-Java-Designing-Resilient/dp/1449374646)'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Java Concurrency in Practice* by Brian Goetz et al. A seminal work on Java
    concurrency, this book provides in-depth coverage of concurrent programming techniques,
    best practices, and pitfalls to avoid when developing multi-threaded applications.'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Parallel and Concurrent Programming in Haskell* by Simon Marlow. While focused
    on Haskell, this book offers valuable insights into parallel programming concepts
    that can be applied to Java, providing a broader perspective on concurrent and
    parallel application design. Link: [https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/](https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/)'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Designing Distributed Systems: Patterns and Paradigms for Scalable, Reliable
    Services* by Brendan Burns (Microsoft Azure). This explores essential patterns
    for building scalable and reliable distributed systems, offering insights from
    Microsoft Azure’s experience in cloud computing. Link: [https://www.amazon.com/Designing-Distributed-Systems-Patterns-Paradigms/dp/1491983647](https://www.amazon.com/Designing-Distributed-Systems-Patterns-Paradigms/dp/1491983647)'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Articles
  id: totrans-528
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Microservices Patterns* by Chris Richardson (microservices.io). A comprehensive
    guide to microservices architecture patterns, this article helps developers understand
    and implement effective microservices-based systems. Link: [https://microservices.io/patterns/index.html](https://microservices.io/patterns/index.html)'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A Java Fork/Join Framework* by Doug Lea. An in-depth look at the Fork/Join
    framework by its creator, providing valuable insights into its design and implementation
    for parallel processing in Java. Link: [http://gee.cs.oswego.edu/dl/papers/fj.pdf](http://gee.cs.oswego.edu/dl/papers/fj.pdf)'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Amdahl’s Law in the Multicore Era* by Mark D. Hill and Michael R. Marty. This
    article offers a modern perspective on Amdahl’s Law and its implications for parallel
    computing, helping developers understand the limits and potential of parallel
    processing in contemporary systems. Link: [https://research.cs.wisc.edu/multifacet/papers/ieeecomputer08_amdahl_multicore.pdf](https://research.cs.wisc.edu/multifacet/papers/ieeecomputer08_amdahl_multicore.pdf)'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Online courses
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Java Multithreading, Concurrency & Performance Optimization* by Udemy. This
    comprehensive course covers Java multithreading, concurrency, and performance
    optimization techniques, providing practical examples and hands-on exercises to
    master advanced Java programming concepts. Link:[https://www.udemy.com/course/java-multithreading-concurrency-performance-optimization/](https://www.udemy.com/course/java-multithreading-concurrency-performance-optimization/)'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Concurrency in Java* by Coursera (offered by Rice University). Focusing on
    the foundational principles of concurrency in Java, this course offers practical
    exercises to solidify understanding of concurrent programming concepts and techniques.
    Link: [https://www.coursera.org/learn/concurrent-programming-in-java](https://www.coursera.org/learn/concurrent-programming-in-java)'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reactive Programming in Modern Java using Project Reactor* by Udemy. A comprehensive
    course on reactive programming in Java using Project Reactor, teaching developers
    how to build reactive applications for better scalability and resilience in modern
    software architectures. Link: [https://www.udemy.com/course/reactive-programming-in-modern-java-using-project-reactor/](https://www.udemy.com/course/reactive-programming-in-modern-java-using-project-reactor/)'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Parallel, Concurrent, and Distributed Programming in Java Specialization*
    on Coursera by Rice University. This specialization offers a comprehensive coverage
    of advanced concurrency topics in Java, including parallel, concurrent, and distributed
    programming techniques for developing high-performance applications. Link: [https://www.coursera.org/specializations/pcdp](https://www.coursera.org/specializations/pcdp)'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key blogs and websites
  id: totrans-537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Baeldung* offers comprehensive tutorials and articles on Java, Spring, and
    related technologies, including in-depth content on concurrency and parallelism.
    Their concurrency section is particularly valuable for learning advanced Java
    threading concepts. Link: [https://www.baeldung.com/java-concurrency](https://www.baeldung.com/java-concurrency)'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*DZone Java Zone* is a community-driven platform, offering a wealth of articles,
    tutorials, and guides on Java and cloud-native development. The Java Zone is an
    excellent resource for staying up-to-date with the latest trends and best practices
    in Java development. Link: [https://dzone.com/java-jdk-development-tutorials-tools-news](https://dzone.com/java-jdk-development-tutorials-tools-news)'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*InfoQ Java* provides news, articles, and interviews on software development,
    with a strong focus on Java, concurrency, and cloud-native technologies. InfoQ
    is particularly useful for gaining insights into industry trends and emerging
    technologies in the Java ecosystem. Link: [https://www.infoq.com/java/](https://www.infoq.com/java/)'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapters 4–6
  id: totrans-541
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Books
  id: totrans-542
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Patterns for Distributed Systems* by Unmesh Joshi (InfoQ)'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This book provides an overview of common patterns used in distributed systems,
    offering practical advice for designing robust and scalable architectures. Link:
    [https://www.amazon.com/Patterns-Distributed-Systems-Addison-Wesley-Signature/dp/0138221987](https://www.amazon.com/Patterns-Distributed-Systems-Addison-Wesley-Signature/dp/0138221987)'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Articles and blogs
  id: totrans-545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Martin Fowler’s blog on microservices and distributed systems. This blog is
    a treasure trove of information on microservices and distributed systems, offering
    in-depth articles and thought leadership on modern software architecture. Link:
    [https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html)'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*LMAX Disruptor documentation and performance guide* is a high-performance
    inter-thread messaging library for Java. This resource provides documentation
    and performance guides for implementing low-latency, high-throughput systems.
    Link: [https://lmax-exchange.github.io/disruptor/](https://lmax-exchange.github.io/disruptor/)'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Online courses
  id: totrans-548
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Microservices Architecture* by the University of Alberta. This course provides
    a comprehensive introduction to microservices architecture, covering design principles,
    implementation strategies, and best practices for building scalable and maintainable
    systems. Link: [https://www.coursera.org/specializations/software-design-architecture](https://www.coursera.org/specializations/software-design-architecture)'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Building Scalable Java Microservices with Spring Boot and Spring Cloud* on
    Coursera by Google Cloud Offered by Google Cloud, this course teaches how to build
    scalable Java microservices using Spring Boot and Spring Cloud, with a focus on
    cloud-native development practices. Link: [https://www.coursera.org/learn/google-cloud-java-spring](https://www.coursera.org/learn/google-cloud-java-spring)'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapters 7–9
  id: totrans-551
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Books
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Serverless Architectures on AWS* by Peter Sbarski This book provides comprehensive
    coverage of serverless concepts and practical implementations on AWS, offering
    valuable insights for developers looking to build scalable and cost-effective
    applications. Link: [https://www.amazon.com/Serverless-Architectures-AWS-Peter-Sbarski/dp/1617295426](https://www.amazon.com/Serverless-Architectures-AWS-Peter-Sbarski/dp/1617295426)'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Articles
  id: totrans-554
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Serverless Computing: One Step Forward, Two Steps Back* by Joseph M. Hellerstein
    et al. This article provides a critical analysis of serverless computing, discussing
    its advantages and limitations, and offering a balanced perspective on its place
    in modern architecture. Link: [https://arxiv.org/abs/1812.03651](https://arxiv.org/abs/1812.03651)'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Serverless Architecture Patterns and Best Practices* by freeCodeCamp'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This article provides an overview of key serverless patterns like messaging,
    function focus, and event-driven architecture, emphasizing the benefits of decoupling
    and scalability. Link: [https://www.freecodecamp.org/news/serverless-architecture-patterns-and-best-practices/](https://www.freecodecamp.org/news/serverless-architecture-patterns-and-best-practices/)'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Online courses
  id: totrans-558
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Developing Serverless Solutions on AWS* by the AWS training team. This includes
    comprehensive coverage of AWS Lambda, best practices, frameworks, and hands-on
    labs. Link: [https://aws.amazon.com/training/classroom/developing-serverless-solutions-on-aws/](https://aws.amazon.com/training/classroom/developing-serverless-solutions-on-aws/)'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical papers
  id: totrans-560
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Serverless Computing: Current Trends and Open Problems* by Ioana Baldini et
    al. This academic paper provides a thorough examination of serverless computing,
    discussing current trends, challenges, and future directions in this rapidly evolving
    field. Link: [https://arxiv.org/abs/1706.03178](https://arxiv.org/abs/1706.03178)'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Online resources
  id: totrans-562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'AWS Lambda Developer Guide: [https://docs.aws.amazon.com/lambda/latest/dg/welcome.html](https://docs.aws.amazon.com/lambda/latest/dg/welcome.html)'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Functions Java developer guide: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference-java](https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference-java)'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Google Cloud Functions Java Tutorials: [https://codelabs.developers.google.com/codelabs/cloud-starting-cloudfunctions#](https://codelabs.developers.google.com/codelabs/cloud-starting-cloudfunctions#)'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapters 10–12
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Books
  id: totrans-567
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Quantum Computing for Developers* by Johan Vos. This groundbreaking book offers
    a developer-friendly introduction to quantum computing, bridging the gap between
    theoretical concepts and practical implementation. It provides clear explanations
    of quantum principles and includes hands-on examples using Java-based frameworks,
    preparing software developers for the emerging quantum computing landscape. The
    author, Johan Vos, expertly guides readers through quantum algorithms, quantum
    gates, and quantum circuits, demonstrating how to leverage existing programming
    skills in this cutting-edge field. Link: [https://www.manning.com/books/quantum-computing-for-developers](https://www.manning.com/books/quantum-computing-for-developers)'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Articles
  id: totrans-569
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Transitioning your service or application* by Amazon Web Services'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This article explores optimizing Java applications to provide more details
    regarding the individual steps involved in transitioning an application to Graviton2\.
    Link: [https://docs.aws.amazon.com/whitepapers/latest/aws-graviton2-for-isv/transitioning-your-service-or-application.html](https://docs.aws.amazon.com/whitepapers/latest/aws-graviton2-for-isv/transitioning-your-service-or-application.html)'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Java in the Era of Cloud Computing* by Cogent University. This article focuses
    on the cloud-native advancements in Java, with frameworks like Spring Boot and
    Quarkus facilitating cloud-based development. It also mentions tools like Maven,
    Gradle, and JUnit for enhancing productivity and ensuring code quality. Link:
    [https://www.cogentuniversity.com/post/java-in-the-era-of-cloud-computing](https://www.cogentuniversity.com/post/java-in-the-era-of-cloud-computing)'
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Online courses
  id: totrans-573
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Parallel, Concurrent, and Distributed Programming in Java Specialization*
    by Rice University on Coursera. This specialization covers advanced concurrency
    topics in Java, which apply to cloud computing environments and auto-scaling scenarios.
    Link: [https://www.coursera.org/specializations/pcdp](https://www.coursera.org/specializations/pcdp)'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Serverless Machine Learning with Tensorflow on Google Cloud Platform* by Google
    Cloud on Coursera. This course explores the intersection of serverless computing
    and machine learning, aligning with discussions on AI/ML integration in cloud
    environments and future trends in cloud computing. Link: [https://www.coursera.org/learn/serverless-machine-learning-gcp-br](https://www.coursera.org/learn/serverless-machine-learning-gcp-br)'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This appendix provides a curated selection of resources, including books, articles,
    and online courses, to deepen your understanding of concurrency, parallelism,
    and cloud-native development in Java. Leveraging these materials will enhance
    your knowledge and skills, enabling you to build robust, scalable, and efficient
    cloud-native Java applications.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: Answers to the end-of-chapter multiple-choice questions
  id: totrans-577
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Chapter 1: Concurrency, Parallelism, and the Cloud: Navigating the Cloud-Native
    Landscape'
  id: totrans-578
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: B) Easier to scale and maintain individual services
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Synchronization
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: D) Stream API
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) Automatic scaling and management of resources
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Data consistency and synchronization
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 2: Introduction to Java’s Concurrency Foundations: Threads, Processes,
    and Beyond'
  id: totrans-584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C) Threads share a memory space, while processes are independent and have their
    own memory.
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) It offers a set of classes and interfaces for managing threads and processes
    efficiently.
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Allowing multiple threads to read a resource concurrently but requiring exclusive
    access for writing.
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) It allows a set of threads to wait for a series of events to occur.
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) It allows for lock-free thread-safe operations on a single integer value.
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 3: Mastering Parallelism in Java'
  id: totrans-590
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: B) To enhance parallel processing by recursively splitting and executing tasks
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) `RecursiveTask` returns a value, while `RecursiveAction` does not
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) It allows idle threads to take over tasks from busy threads
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Balancing task granularity and parallelism level
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) The task’s nature, resource availability, and team expertise
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 4: Java Concurrency Utilities and Testing in the Cloud Era'
  id: totrans-596
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C) To efficiently manage thread execution and resource allocation
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) `CopyOnWriteArrayList`
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Enables asynchronous programming and non-blocking operations
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) They enable efficient data handling and reduce locking overhead in concurrent
    access scenarios
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) By offering more control over lock management and reducing lock contention
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 5: Mastering Concurrency Patterns in Cloud Computing'
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C) To prevent failures in one service from affecting other services
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Employing a lock-free ring buffer to minimize contention
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) It isolates services to prevent failures in one from cascading to others.
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Scatter-Gather pattern
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: D) Resilience and data flow management
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 6: Java and Big Data – a Collaborative Odyssey'
  id: totrans-608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: B) Volume, velocity, and variety
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) **Hadoop Distributed File** **System** (**HDFS**)
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) Spark offers faster in-memory data processing capabilities.
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) Spark can only process structured data.
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) It helps to break down large datasets into smaller, manageable chunks for
    processing.
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 7: Concurrency in Java for Machine Learning'
  id: totrans-614
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C) To optimize computational efficiency
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) Parallel Streams
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) They improve scalability and manage large-scale computations.
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) To perform data preprocessing and model training more efficiently
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Combining Java concurrency with generative AI
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 8: Microservices in the Cloud and Java’s Concurrency'
  id: totrans-620
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C) Independent deployment and scalability
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) CompletableFuture
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Distributing incoming network traffic across multiple instances
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) Circuit breaker pattern.
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) Assigning a separate managed database instance for each microservice
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 9: Serverless Computing and Java’s Concurrent Capabilities'
  id: totrans-626
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C) Automatic scaling and reduced operational overhead.
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) CompletableFuture.
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) Managing recursive tasks by dividing them into smaller subtasks.
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Optimize function size and use provisioned concurrency.
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Improved performance through concurrent data processing.
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 10: Synchronizing Java’s Concurrency with Cloud Auto-Scaling Dynamics'
  id: totrans-632
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C) Dynamic resource allocation based on demand
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) `CompletableFuture`
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) Managing a fixed number of threads
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) Implementing stateless services
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) Improving performance through concurrent data processing
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 11: Advanced Java Concurrency Practices in Cloud Computing'
  id: totrans-638
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: D) User interface design
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) Improved performance for parallel tasks
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) VisualVM
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Minimize data loss and improve availability
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) Difficulty in obtaining a cohesive view of distributed operations
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 12: The Horizon Ahead'
  id: totrans-644
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A) Improved startup time and reduced memory usage
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: D) All of the above
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B) Google Cloud AutoML
  id: totrans-647
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C) Quantum superposition
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) Reduced operational overhead for managing infrastructure
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
