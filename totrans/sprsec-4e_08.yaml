- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Client Certificate Authentication with TLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although username and password authentication are extremely common, as we discussed
    in [*Chapter 1*](B21757_01.xhtml#_idTextAnchor015), *Anatomy of an Unsafe Application*,
    and in [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043), *Getting Started with
    Spring Security*, forms of authentication exist that allow users to present different
    types of credentials. Spring Security caters to these requirements as well. In
    this chapter, we’ll move beyond form-based authentication to explore authentication
    using trusted client-side certificates.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the course of this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning how client certificate authentication is negotiated between the user’s
    browser and a compliant server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Spring Security to authenticate users with client certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the architecture of client certificate authentication in Spring
    Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring advanced configuration options related to client certificate authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing pros, cons, and common troubleshooting steps when dealing with client
    certificate authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter’s code in action link is here: [https://packt.link/XgAQ7](https://packt.link/XgAQ7).'
  prefs: []
  type: TYPE_NORMAL
- en: How does client certificate authentication work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Client certificate authentication requires a request for information from the
    server and a response from the browser to negotiate a trusted authentication relationship
    between the client (that is, a user’s browser) and the server application. This
    trusted relationship is built through the use of the exchange of trusted and verifiable
    credentials, known as **certificates**.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike much of what we have seen up to this point, with client certificate authentication,
    the Servlet container or application server itself is typically responsible for
    negotiating the trust relationship between the browser and server by requesting
    a certificate, evaluating it, and accepting it as valid.
  prefs: []
  type: TYPE_NORMAL
- en: Client certificate authentication is also known as **mutual authentication**
    and is part of the **Secure Sockets Layer** (**SSL**) protocol and its successor,
    **Transport Layer Security** (**TLS**). As mutual authentication is part of the
    SSL and TLS protocols, it follows that an HTTPS connection (secured with SSL or
    TLS) is required in order to make use of client certificate authentication. For
    more details on SSL/TLS support in Spring Security, please refer to the *Generating
    a server certificate* section in the [*Appendix*](B21757_20.xhtml#_idTextAnchor642),
    *Additional Reference Material*. Setting up SSL/TLS is required to implement client
    certificate authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sequence diagram illustrates the interaction between the client
    browser and the web server when negotiating an SSL connection and validating the
    trust of a client certificate used for mutual authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Client certificate authentication](img/B21757_08_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Client certificate authentication
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that the exchange of two certificates, the server and client certificates,
    provides the authentication that both parties are known and can be trusted to
    continue their conversation securely. In the interest of clarity, we omit some
    details of the SSL handshake and trust the checking of the certificates themselves;
    however, you are encouraged to do further reading in the area of the SSL and TLS
    protocols, and certificates in general, as many good reference guides on these
    subjects exist. *RFC 8446*, *The Transport Layer Security (TLS) Protocol Version
    1.3* ([https://datatracker.ietf.org/doc/html/rfc8446](https://datatracker.ietf.org/doc/html/rfc8446)),
    is a good place to begin reading about client certificate presentation, and if
    you’d like to get into more detail, *SL and TLS: Designing and Building Secure
    Systems, Eric Rescorla, Addison-Wesley* ([https://www.amazon.com/SSL-TLS-Designing-Building-Systems/dp/0201615983](https://www.amazon.com/SSL-TLS-Designing-Building-Systems/dp/0201615983))
    has an incredibly detailed review of the protocol and its implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative name for client certificate-based authentication is **X.509 authentication**.
    The term X.509 is derived from the X.509 standard, originally published by the
    **International Telecommunication Union Telecommunication** (**ITU-T**) organization
    for use in directories based on the X.500 standard (the origins of **Lightweight
    Directory Access Protocol** (**LDAP**), as you may recall from [*Chapter 6*](B21757_06.xhtml#_idTextAnchor180),
    *LDAP Directory Services*). Later, this standard was adapted for use in securing
    internet communications.
  prefs: []
  type: TYPE_NORMAL
- en: We mention this here because many of the classes in Spring Security related
    to this subject refer to X.509\. Remember that X.509 doesn’t define the mutual
    authentication protocol itself, but defines the format and structure of the certificates
    and the encompassing trusted certificate authorities instead.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the client certificate authentication infrastructure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately for you as an individual developer, being able to experiment with
    client certificate authentication requires some non-trivial configuration and
    setup prior to the relatively easy integration with Spring Security. As these
    setup steps tend to cause a lot of problems for first-time developers, we feel
    it is important to walk you through them.
  prefs: []
  type: TYPE_NORMAL
- en: We assume that you are using a local, self-signed server certificate, self-signed
    client certificates, and Apache Tomcat. This is typical of most development environments;
    however, it’s possible that you may have access to a valid server certificate,
    a **certificate authority** (**CA**), or another application server. If this is
    the case, you may use these setup instructions as guidelines and configure your
    environment in an analogous manner. Please refer to the SSL setup instructions
    in the [*Appendix*](B21757_20.xhtml#_idTextAnchor642), *Additional Reference Material*,
    for assistance in configuring Tomcat and Spring Security to work with SSL in a
    standalone environment.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the purpose of a public key infrastructure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter focuses on setting up a self-contained development environment
    for the purposes of learning and education. However, in most cases where you are
    integrating Spring Security into an existing client certificate-secured environment,
    there will be a significant amount of infrastructure (usually a combination of
    hardware and software) in place to provide functionality, such as certificate
    granting and management, user self-service, and revocation. Environments of this
    type define a public key infrastructure—a combination of hardware, software, and
    security policies that result in a highly secure authentication-driven network
    ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to being used for web application authentication, certificates or
    hardware devices in these environments can be used for secure, non-repudiated
    email (using `S/MIME`), network authentication, and even physical building access
    (using `PKCS 11`-based hardware devices).
  prefs: []
  type: TYPE_NORMAL
- en: While the management overhead of such an environment can be high (and requires
    both IT and process excellence to implement well), it is arguably one of the most
    secure operating environments possible for technology professionals.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a client certificate key pair
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The self-signed client certificate is created in the same way as the self-signed
    server certificate is created—by generating a key pair using the `keytool` command.
    A client certificate key pair differs in that it requires the key store to be
    available to the web browser and requires the client’s public key to be loaded
    into the server’s trust store (we’ll explain what this is in a moment).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not wish to generate your own key right now, you may skip to the
    next section and use the sample certificates in the `./src/main/resources/keys`
    folder in the sample chapter. Otherwise, create the client key pair, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find additional information about `keytool`, along with all of the
    configuration options, at Oracle’s site, here: [https://docs.oracle.com/en/java/javase/17/docs/specs/man/keytool.xhtml](https://docs.oracle.com/en/java/javase/17/docs/specs/man/keytool.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the arguments to `keytool` are fairly arbitrary for this use case.
    However, when prompted to set up the first and last name (the `admin1@example.com`
    is an appropriate value since we have the `admin1@example.com` user setup in Spring
    Security. An example of the command-line interaction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We’ll see why this is important when we configure Spring Security to access
    the information from the certificate-authenticated user. We have one final step
    before we can set up certificate authentication within Tomcat, which is explained
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Tomcat trust store
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall that the definition of a key pair includes both a private and public
    key. Similar to SSL certificates verifying and securing server communication,
    the validity of the client certificate needs to be verified by the certifying
    authority that created it.
  prefs: []
  type: TYPE_NORMAL
- en: As we have created our own self-signed client certificate using the `keytool`
    command, the **Java Virtual Machine** (**JVM**) will not implicitly trust it as
    having been assigned by a trusted certificate authority.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We will need to force Tomcat to recognize the certificate as a trusted certificate.
    We do this by exporting the public key from the key pair and adding it to the
    Tomcat trust store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, if you do not wish to perform this step now, you can use the existing
    trust store in `.src/main/resources/keys` and skip to where we configure `server.xml`
    later in this section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We’ll export the public key to a standard certificate file named `jbcp_clientauth.cer`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll import the certificate into the trust store (this will create the
    trust store, but in a typical deployment scenario you’d probably already have
    some other certificates in the trust store):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Owner: CN=admin1@example.com, OU=JBCP Calendar, O=JBCP, L=Park City, ST=UT,
    C=US'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Issuer: CN=admin1@example.com, OU=JBCP Calendar, O=JBCP, L=Park City, ST=UT,
    C=US'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Serial number: 464fc10c'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Valid from: Fri Jun 23 11:10:19 MDT 2017 until: Thu Feb 12 10:10:19'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: MST 2043
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '//Certificate fingerprints:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'MD5: 8D:27:CE:F7:8B:C3:BD:BD:64:D6:F5:24:D8:A1:8B:50'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'SHA1: C1:51:4A:47:EC:9D:01:5A:28:BB:59:F5:FC:10:87:EA:68:24:E3:1F'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'SHA256: 2C:F6:2F:29:ED:09:48:FD:FE:A5:83:67:E0:A0:B9:DA:C5:3B: FD:CF:4F:95:50:3A:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2C:B8:2B:BD:81:48:BB:EF
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Signature algorithm name: SHA256withRSA Version: 3'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //Extensions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#1: ObjectId: 2.5.29.14 Criticality=false SubjectKeyIdentifier ['
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: KeyIdentifier [
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '0000: 29 F3 A7 A1 8F D2 87 4B'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: EA 74 AC 8A 4B BC 4B 5D
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: K.t..K.K]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '0010: 7C 9B 44 4A'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ..DJ
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tomcat.truststore file, as we will need to reference it in our Tomcat configuration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What’s the difference between a key store and a trust store?
  prefs: []
  type: TYPE_NORMAL
- en: The `keystoreFile` and `truststoreFile` attributes of the connector). The format
    of the files themselves can be exactly the same. Really, each file can be any
    JSSE-supported keystore format, including `PKCS 12`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, we assume you have already configured the SSL Connector,
    as outlined in the [*Appendix*](B21757_20.xhtml#_idTextAnchor642), *Additional
    Reference Material*. If you do not see the `keystoreFile` or `keystorePass` attributes
    in `server.xml`, it means you should visit the [*Appendix*](B21757_20.xhtml#_idTextAnchor642),
    *Additional Reference Material*, to get SSL set up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we’ll need to point Tomcat at the trust store and enable client certificate
    authentication. This is done by adding three additional attributes to the SSL
    connector in the Tomcat `server.xml` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should be the remaining configuration required to trigger Tomcat to request
    a client certificate when an SSL connection is made. Of course, you will want
    to ensure you replace both `<CERT_PATH>` and `<KEYSTORE_PATH>` with the full paths.
    For example, on a Unix-based `/home/packt/chapter8/keys/tomcat.keystore`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go ahead and try to start up Tomcat to ensure that the server starts up without
    any errors in the logs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: There’s also a way to configure Tomcat to optionally use client certificate
    authentication—we’ll enable this later in the chapter. For now, we require the
    use of client certificates to even connect to the Tomcat server in the first place.
    This makes it easier to diagnose whether or not you have set this up correctly!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Tomcat in Spring Boot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also configure the embedded Tomcat instance within Spring Boot, which
    is how we will be working with Tomcat for the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuring Spring Boot to use our newly created certificates is as straightforward
    as configuring the properties of the YAML entry, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The final step is to import the certificate into the client browser.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the certificate key pair into a browser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Depending on what browser you are using, the process of importing a certificate
    may differ. We will provide instructions for installations of Firefox, Chrome,
    and Internet Explorer here, but if you are using another browser, please consult
    its help section or your favorite search engine for assistance.
  prefs: []
  type: TYPE_NORMAL
- en: Using Mozilla Firefox
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Perform the following steps to import the key store containing the client certificate
    key pair in Firefox:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Edit** | **Preferences**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Advanced** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Encryption** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **View Certificates** button. The **Certificate Manager** window
    should open up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Your** **Certificates** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Import...** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse to the location where you saved the `jbcp_clientauth.p12` file and select
    it. You will need to enter the password (that is, `changeit`) that you used when
    you created the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client certificate should be imported, and you should see it on the list.
  prefs: []
  type: TYPE_NORMAL
- en: Using Google Chrome
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Perform the following steps to import the key store containing the client certificate
    key pair in Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the wrench icon on the browser toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Show** **advanced settings...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **HTTPS/SSL** section, click on the **Manage** **certificates...** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Personal** tab click on the **Import...** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse to the location where you saved the `jbcp_clientauth.p12` file and select
    it (Ensure that you utilize the .p12 extension for the certificate).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will need to enter the password (that is, `changeit`) that you used when
    you created the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Microsoft Edge
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s take a look at the steps of using Microsoft Edge with Windows OS:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the `jbcp_clientauth.p12` file in Windows Explorer. The **Certificate
    Import Wizard** window should open (Ensure that you utilize the .p12 extension
    for the certificate).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Next** and accept the default values until you are prompted for the
    certificate password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the certificate password (that is, `changeit`) and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept the default **Automatically select the certificate store** option and
    click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To verify that the certificate was installed correctly, you will need to perform
    another series of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Settings** menu in Microsoft Edge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Privacy, search** **and services**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down to **Security** and
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Manage certificates**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Personal** tab, if it is not already selected. You should see
    the certificate listed here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wrapping up testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You should now be able to connect to the `https://localhost:8443/`, taking
    care to use **HTTPS** and **8443**. If all is set up correctly, you should be
    prompted for a certificate when you attempt to access the site—in Chrome, the
    certificate is displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Client certificate details in Chrome](img/B21757_08_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Client certificate details in Chrome
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice, however, that if you attempt to access a protected section of
    the site, such as the **My Events** section, you’ll be redirected to the login
    page. This is because we haven’t yet configured Spring Security to recognize the
    information in the certificate—at this point, the negotiation between the client
    and server has stopped at the Tomcat server itself.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter08.00-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting client certificate authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately, if we said that getting client certificate authentication configured
    correctly for the first time—without anything going wrong—was easy, we’d be lying
    to you. The fact is, although this is a great and very powerful security apparatus,
    it is poorly documented by both the browser and web server manufacturers, and
    the error messages, when present, can be confusing at best and misleading at worst.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that, at this point, we have not involved Spring Security in the equation
    at all, so a debugger will most likely not help you (unless you have the Tomcat
    source code handy). There are some common errors and things to check.
  prefs: []
  type: TYPE_NORMAL
- en: 'You aren’t prompted for a certificate when you access the site. There are many
    possible causes for this, and this can be the most puzzling problem to try to
    solve. Here are some things to check:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the certificate has been installed in the browser client you are
    using. Sometimes, you need to restart the whole browser (close all windows) if
    you attempted to access the site previously and were rejected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure you are accessing the SSL port for the server (typically `8443` in a
    development setup), and have selected the HTTPS protocol in your URL. The client
    certificates are not presented in insecure browser connections. Make sure the
    browser also trusts the server SSL certificate, even if you have to force it to
    trust a self-signed certificate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure you have added the `clientAuth` directive to your Tomcat configuration
    (or the equivalent for whatever application server you are using).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all else fails, use a network analyzer or packet sniffer, such as Wireshark
    ([http://www.wireshark.org/](http://www.wireshark.org/)) or Fiddler2 ([http://www.fiddler2.com/](http://www.fiddler2.com/)),
    to review the traffic and SSL key exchange over the wire (check with your IT department
    first—many companies do not allow tools of this kind on their networks).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using a self-signed client certificate, make sure the public key
    has been imported into the server’s trust store. If you are using a CA-assigned
    certificate, make sure the CA is trusted by the **Java Virtual Machine** (**JVM**)
    or that the CA certificate is imported into the server’s trust store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Internet Explorer, in particular, does not report details of client certificate
    failures at all (it simply reports a generic **Page Cannot be Displayed** error).
    Use Firefox to diagnose whether an issue you are seeing is related to client certificates
    or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following JVM option will enable SSL handshake level logging: `-Djavax.net.debug=ssl:handshake`.
    This debugging flag can produce a large amount of output but can be very helpful
    in diagnosing underlying SSL connectivity issues.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring client certificate authentication in Spring Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike the authentication mechanisms that we have utilized thus far, the use
    of client certificate authentication results in the user’s request being pre-authenticated
    by the server. As the server (Tomcat) has already established that the user has
    provided a valid and trustworthy certificate, Spring Security can simply trust
    this assertion of validity.
  prefs: []
  type: TYPE_NORMAL
- en: An important component of the secure login process is still missing, which is
    the authorization of the authenticated user. This is where our configuration of
    Spring Security comes in—we must add a component to Spring Security that will
    recognize the certificate authentication information from the user’s HTTP session
    (populated by Tomcat), and then validate the presented credentials against the
    Spring Security `UserDetailsService` invocation. The invocation of `UserDetailsService`
    will result in the determination of whether the user declared in the certificate
    is known to Spring Security at all, and then it will assign `GrantedAuthority`
    as per the usual login rules.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring client certificate authentication using the security namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With all of the complexity of LDAP configuration, configuring client certificate
    authentication is a welcome reprieve. If we are using the security namespace style
    of configuration, the addition of client certificate authentication is a simple
    one-line configuration change, added within the `HttpSecurity` declaration. Go
    ahead and make the following changes to the provided `SecurityConfig.java` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Observe that the `.x509()` method references our existing `userDetailsService()`
    configuration. For simplicity, we use the `UserDetailsServiceImpl` implementation
    covered in [*Chapter 5*](B21757_05.xhtml#_idTextAnchor150), *Authentication with
    Spring Data*. However, we could easily swap this out with any other implementation
    (that is, the LDAP or JDBC-based implementation covered in [*Chapter 4*](B21757_04.xhtml#_idTextAnchor106),
    *JDBC-based Authentication*).
  prefs: []
  type: TYPE_NORMAL
- en: After restarting the application, you’ll again be prompted for a client certificate,
    but this time, you should be able to access areas of the site requiring authorization.
    You can see from the logs (if you have them enabled) that you have been logged
    in as the `admin1@example.com` user.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should look like `chapter08.01-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: How does Spring Security use certificate information?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As previously discussed, Spring Security’s involvement in certificate exchange
    is to pick up information from the presented certificate and map the user’s credentials
    to a user service. What we did not see in the use of the `.x509()` method was
    the magic that makes this happen. Recall that when we set the client certificate
    up, a DN similar to an LDAP DN was associated with the certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Spring Security uses the information in this DN to determine the actual username
    of the principal and it will look for this information in `UserDetailsService`.
    In particular, it allows for the specification of a regular expression, which
    is used to match a portion of the DN established with the certificate, and the
    utilization of this portion of the DN as the principal name. The implicit, default
    configuration for the `.x509()` method would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can see that this regular expression would match the `admin1@example.com`
    value as the principal’s name. This regular expression must contain a single matching
    group, but it can be configured to support the username and DN issuance requirements
    of your application. For example, if the DNs for your organization’s certificates
    include the `email` or `userid` fields, the regular expression can be modified
    to use these values as the authenticated principal’s name.
  prefs: []
  type: TYPE_NORMAL
- en: How Spring Security certificate authentication works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s review the various actors involved in the review and evaluation of the
    client certificates and translation into a Spring-Security-authenticated session,
    with the help of the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Spring Security certificate authentication workflow](img/B21757_08_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Spring Security certificate authentication workflow
  prefs: []
  type: TYPE_NORMAL
- en: We can see that `o.s.s.web.authentication.preauth.x509.X509AuthenticationFilter`
    is responsible for examining the request of an unauthenticated user for the presentation
    of client certificates. If it sees that the request includes a valid client certificate,
    it will extract the principal using `o.s.s.web.authentication.preauth.x509.SubjectDnX509PrincipalExtractor`,
    using a regular expression matching the certificate owner’s DN, as previously
    described.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that although the preceding diagram indicates that examination of the
    certificate occurs for unauthenticated users, a check can also be performed when
    the presented certificate identifies a different user than the one that was previously
    authenticated. This would result in a new authentication request using the newly
    provided credentials. The reason for this should be clear—any time a user presents
    a new set of credentials, the application must be aware of this and react in a
    responsible fashion by ensuring that the user is still able to access it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the certificate has been accepted (or rejected/ignored), as with other
    authentication mechanisms, an `Authentication` token is built and passed along
    to `AuthenticationManager` for authentication. We can now review the very brief
    illustration of the `o.s.s.web.authentication.preauth.PreAuthenticatedAuthenticationProvider`
    handling of the authentication token:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – The Spring Security PreAuthenticatedAuthenticationProvider workflow](img/B21757_08_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – The Spring Security PreAuthenticatedAuthenticationProvider workflow
  prefs: []
  type: TYPE_NORMAL
- en: Though we will not go over them in detail, there are a number of other pre-authenticated
    mechanisms supported by Spring Security. Some examples include Java EE role mapping
    (`J2eePreAuthenticatedProcessingFilter`), WebSphere integration (`WebSpherePreAuthenticatedProcessingFilter`),
    and SiteMinder-style authentication (`RequestHeaderAuthenticationFilter`). If
    you understand the process flow of client certificate authentication, understanding
    these other authentication types is significantly easier.
  prefs: []
  type: TYPE_NORMAL
- en: Handling unauthenticated requests with AuthenticationEntryPoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since `X509AuthenticationFilter` will continue processing the request if authentication
    fails, we’ll need to handle situations where the user does not authenticate successfully
    and has requested a protected resource. The way that Spring Security allows developers
    to customize this is by plugging in a custom `o.s.s.web.AuthenticationEntryPoint`
    implementation. In a default form login scenario, `LoginUrlAuthenticationEntryPoint`
    is used to redirect the user to a login page if they have been denied access to
    a protected resource and are not authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, in typical client certificate authentication environments, alternative
    methods of authentication are simply not supported (remember that Tomcat expects
    the certificate well before the Spring Security form login takes place anyway).
    As such, it doesn’t make sense to retain the default behavior of redirection to
    a form login page. Instead, we’ll modify the entry point to simply return an `HTTP
    403 Forbidden` message, using `o.s.s.web.authentication.Http403ForbiddenEntryPoint`.
    Go ahead and make the following updates in your `SecurityConfig.java` file, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if a user tries to access a protected resource and is unable to provide
    a valid certificate, they will be presented with the following page, instead of
    being redirected to the login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Spring Security forbidden error](img/B21757_08_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Spring Security forbidden error
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: We have removed the username of `admin1@example.com`, to make sure there is
    no matching user with the certificate CN.
  prefs: []
  type: TYPE_NORMAL
- en: Your code should look like `chapter08.02-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other configuration or application flow adjustments that are commonly performed
    with client certificate authentication are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Removal of the form-based login page altogether
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removal of the logout link (as there’s no reason to log out because the browser
    will always present the user’s certificate)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removal of the functionality to rename the user account and change the password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removal of the user registration functionality (unless you are able to tie it
    into the issuance of a new certificate)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting dual-mode authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is also possible that some environments may support both certificate-based
    and form-based authentication. If this is the case in your environment, it is
    also possible (and trivial) to support it with Spring Security. We can simply
    leave the default `AuthenticationEntryPoint` interface (redirecting to the form-based
    login page) intact and allow the user to log in using the standard login form
    if they do not supply a client certificate.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you choose to configure your application this way, you’ll need to adjust
    the Tomcat SSL settings (change as appropriate for your application server). Simply
    change the `clientAuth` directive to `want`, instead of `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We’ll also need to remove the `authenticationEntryPoint()` method that we configured
    in the previous exercise so that the standard form-based authentication workflow
    takes over if the user isn’t able to supply a valid certificate upon the browser
    first being queried.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this is convenient, there are a few things to keep in mind about dual-mode
    (form-based and certificate-based) authentication, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Most browsers will not re-prompt the user for a certificate if they have failed
    certificate authentication once, so make sure that your users are aware that they
    may need to reenter the browser to present their certificate again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recall that a password is not required to authenticate users with certificates;
    however, if you are still using `UserDetailsService` to support your form-based
    authenticated users, this may be the same `UserDetailsService` object that you
    use to give the `PreAuthenticatedAuthenticationProvider` information about your
    users. This presents a potential security risk, as users who you intend to sign
    in only with certificates could potentially authenticate using form login credentials.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several ways to solve this problem, and they are described in the
    following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the users authenticating with certificates have an appropriately
    strong password in your user store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider customizing your user store to clearly identify users who are enabled
    for form-based login. This can be tracked with an additional field in the table
    holding user account information, and with minor adjustments to the SQL queries
    used by the `JpaDaoImpl` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure a separate user details store altogether for users who are logging
    in as certificate-authenticated users, to completely segregate them from users
    that are allowed to use form-based login.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dual-mode authentication can be a powerful addition to your site and can be
    deployed effectively and securely, provided that you keep in mind the situations
    under which users will be granted access to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring client certificate authentication using Spring beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we reviewed the flow of the classes involved in client
    certificate authentication. As such, it should be straightforward for us to configure
    the JBCP calendar using explicit beans. By using the explicit configuration, we
    will have additional configuration options at our disposal. Let’s take a look
    and see how to use explicit configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll also need to remove the `x509()` method, add `x509Filter` to our filter
    chain, and add our `AuthenticationProvider` implementation to `AuthenticationManger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, give the application a try. Nothing much has changed from a user perspective,
    but as developers, we have opened the door to a number of additional configuration
    options.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should look like `chapter08.03-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Additional capabilities of bean-based configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of Spring-bean-based configuration provides us with additional capabilities
    through the exposure of bean properties that aren’t exposed via the security namespace
    style of configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional properties available on `X509AuthenticationFilter` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** | **Default** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `continueFilterChainOn` `UnsuccessfulAuthentication` | If false, a failed
    authentication will throw an exception rather than allow the request to continue.
    This would typically be set in cases where a valid certificate is expected and
    required to access the secured site. If true, the filter chain will proceed, even
    if there is a failed authentication. | `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `checkForPrincipalChanges` | If true, the filter will check to see whether
    the currently authenticated username differs from the username presented in the
    client certificate. If so, authentication against the new certificate will be
    performed and the HTTP session will be invalidated (optionally, see the next attribute).
    If false, once the user is authenticated, they will remain authenticated even
    if they present different credentials. | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `invalidateSessionOn` `PrincipalChange` | If true, and the principal in the
    request changes, the user’s HTTP session will be invalidated prior to being reauthenticated.
    If false, the session will remain—note that this may introduce security risks.
    | `true` |'
  prefs: []
  type: TYPE_TB
- en: Table 8.1 – Properties available on X509AuthenticationFilter
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PreAuthenticatedAuthenticationProvider` implementation has a couple of
    interesting properties available to us, which are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** | **Default** |'
  prefs: []
  type: TYPE_TB
- en: '| `preAuthenticated UserDetailsService` | This property is used to build a
    full `UserDetails` object from the username extracted from the certificate. |
    None |'
  prefs: []
  type: TYPE_TB
- en: '| `throwExceptionWhen` `TokenRejected` | If true, a `BadCredentialsException`
    exception will be thrown when the token is not constructed properly (does not
    contain a username or certificate). It is typically set to `true` in environments
    where certificates are used exclusively. | None |'
  prefs: []
  type: TYPE_TB
- en: Table 8.2 – Properties available on PreAuthenticatedAuthenticationProvider
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these properties, there are a number of other opportunities for
    implementing interfaces or extending classes involved in certificate authentication
    to further customize your implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Considerations when implementing client certificate authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Client certificate authentication, while highly secure, isn’t for everyone and
    isn’t appropriate for every situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pros of client certificate authentication are listed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Certificates establish a framework of mutual trust and verifiability that both
    parties (client and server) are who they say they are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Certificate-based authentication, if implemented properly, is much more difficult
    to spoof or tamper with than other forms of authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a well-supported browser is used and configured correctly, client certificate
    authentication can effectively act as a single sign-on solution, enabling transparent
    login to all certificate-secured applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cons of client certificate authentication are listed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The use of certificates typically requires the entire user population to have
    them. This can lead to both a user training burden and an administrative burden.
    Most organizations deploying certificate-based authentication on a large scale
    must have sufficient self-service and helpdesk support for certificate maintenance,
    expiration tracking, and user assistance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of certificates is generally an all-or-nothing affair, meaning that
    mixed-mode authentication and offering support for non-certificated users is not
    provided due to the complexity of web server configuration or poor application
    support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of certificates may not be well supported by all users in your user
    population, including the ones who use mobile devices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The correct configuration of the infrastructure required to support certificate-based
    authentication may require advanced IT knowledge.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, there are both benefits and drawbacks to client certificate
    authentication. When implemented correctly, it can be a very convenient mode of
    access for your users and has extremely attractive security and non-repudiation
    properties. You will need to determine your particular situation to see whether
    or not this type of authentication is appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined the architecture, flow, and Spring Security support
    for client certificate-based authentication. We have covered the concepts and
    overall flow of client certificate (mutual) authentication. We explored the important
    steps required to configure Apache Tomcat for a self-signed SSL and client certificate
    scenario.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about configuring Spring Security to understand certificate-based
    credentials presented by clients. We covered the architecture of Spring Security
    classes related to certificate authentication. We also know how to configure a
    Spring bean-style client certificate environment. We also covered the pros and
    cons of this type of authentication.
  prefs: []
  type: TYPE_NORMAL
- en: It’s quite common for developers unfamiliar with client certificates to be confused
    by many of the complexities of this type of environment. We hope that this chapter
    has made this complicated subject a bit easier to understand and implement!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss **Open Authorization** (**OAuth 2**) protocol
    and how you can accomplish single sign-on with **OpenID** **Connect** (**OIDC**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Exploring OAuth 2 and SAML 2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part focuses on OAuth 2, which is a widely adopted method for trusted identity
    management, empowering users to centrally manage their identities through a single
    trusted provider. Users benefit from the convenience of securely storing their
    passwords and personal information with the trusted OAuth 2 provider while retaining
    the option to disclose personal information as needed. Websites implementing OAuth
    2 authentication can trust that users presenting OAuth 2 credentials are authenticated
    individuals.
  prefs: []
  type: TYPE_NORMAL
- en: In the exploration of SAML 2 support, we delve into the intricacies of integrating
    **Security Assertion Markup Language** (**SAML 2.0**) into Spring Security applications.
    SAML 2.0, an XML-based standard, facilitates the exchange of authentication and
    authorization data between **Identity Providers** (**IdP**) and **Service Providers**
    (**SP**), offering seamless integration within Spring Security frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B21757_09.xhtml#_idTextAnchor295), *Opening* *up* *to OAuth 2*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B21757_10.xhtml#_idTextAnchor314), *SAML 2 Support*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
