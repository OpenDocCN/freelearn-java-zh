<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">RESTful Web Services Using Spring Boot</h1>
                </header>
            
            <article>
                
<p>In this chapter, we are going to cover the following recipes:</p>
<ul>
<li>Creating a simple Spring Boot application</li>
<li>Interacting with the database</li>
<li>Creating a RESTful web service</li>
<li>Creating multiple profiles for Spring Boot</li>
<li>Deploying RESTful web services to Heroku</li>
<li>Containerizing the RESTful web service using Docker</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>In recent years, the drive for microservice-based architecture has gained wide adoption, thanks to the simplicity and ease of maintenance it provides when done the right way. A lot of companies, such as Netflix, Amazon, and the like, have moved from monolithic systems to more focused and lighter systems, all talking with each other via RESTful web services. The advent of RESTful web services and its straightforward approach to creating web services using the known HTTP protocol has made it easier for communication between applications than the older SOAP-based web services.   </p>
<p>In this chapter, we will look at the <strong>Spring Boot</strong> framework, which provides a convenient way to create production-ready microservices using Spring libraries. Using Spring Boot, we will develop a simple RESTful web service and deploy the same on the cloud.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a simple Spring Boot application</h1>
                </header>
            
            <article>
                
<p>Spring Boot helps in creating production-ready Spring-based applications easily. It provides support for working with almost all Spring libraries, without any need for configuring them explicitly. There are autoconfiguration classes provided for easy integration with most commonly used libraries, databases, message queues, and the likes.</p>
<p>In this recipe, we will look at creating a simple Spring Boot application with a controller that prints a message when opened in the browser. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Spring Boot supports Maven and Gradle as the build tools and we will be using Maven in our recipes. The URL, <a href="http://start.spring.io/">http://start.spring.io/</a>, provides a convenient way to create an empty project with the required dependencies. We will use it to download an empty project. Follow these steps to create and download an empty Spring Boot-based project:</p>
<ol>
<li>Navigate to <a href="http://start.spring.io/">http://start.spring.io/</a> to see something similar to the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="237" width="707" class="image-border" src="assets/e495acd3-651c-446e-af0c-a1ef90f6010b.png"/></div>
<ol start="2">
<li>You can select the dependency management and build tool, selecting the appropriate option in the dropdown after the text, <strong><span class="packt_screen">Generate a</span></strong>.</li>
<li>Spring Boot supports Java, Kotlin, and Groovy. You can choose the language by changing the dropdown after the text, <strong><span class="packt_screen">with</span></strong>.</li>
</ol>
<p> </p>
<ol start="4">
<li>Select the Spring Boot version by choosing its value from the dropdown after the text, <span class="packt_screen">and Spring Boot</span>. For this recipe, we'll use the latest milestone edition of Spring Boot 2 I.E 2.0.0 M2.</li>
<li>On the left-hand side, under <span class="packt_screen">Project Metadata</span>, we have to provide Maven-related information, that is, the group ID and artifact ID. We'll use <span class="packt_screen">Group</span> as <kbd>com.packt</kbd> and <span class="packt_screen">Artifact</span> as <kbd>boot_demo</kbd>.</li>
<li>On the right-hand side, under <span class="packt_screen">Dependencies</span>, you can search for the dependencies you want to add. For this recipe, we need web and Thymeleaf dependencies. This means that we want to create a web application which uses Thymeleaf UI templates and would want all the dependencies, such as Spring MVC, Embedded Tomcat, and others, to be part of the application. </li>
<li>Then, click on the <span class="packt_screen">Generate Project</span> button to download the empty project. You can load this empty project in any IDE of your choice, just like any other Maven project.</li>
</ol>
<p>At this point, you will have your empty project loaded into an IDE of your choice and ready to explore further. In this recipe, we will make use of the Thymeleaf template engine to define our web pages and create a simple controller to render the web page.</p>
<p>The complete code for this recipe can be found at the location, <kbd>chp10/1_boot_demo</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>If you have followed the group ID and artifact ID naming as mentioned in the <em>Getting ready</em> section, you will have a package structure, <kbd>com.packt.boot_demo</kbd>, and a <kbd>BootDemoApplication.java</kbd> main class already created for you. There will be an equivalent package structure and a <kbd>BootDemoApplicationTests.java</kbd> main class under the <kbd>tests</kbd> folder.</li>
<li>Create a new class, <kbd>SimpleViewController</kbd>, under the <kbd>com.packt.boot_demo</kbd> package, with the following code:</li>
</ol>
<pre>        @Controller<br/><span>        public</span><span> </span><span>class</span><span> </span><span>SimpleViewController{<br/></span><span>          @GetMapping</span><span>(</span><span>"/message"</span><span>)<br/></span><span>          public</span><span> </span><span>String</span><span> </span><span>message</span><span>(){<br/></span><span>            return</span><span> </span><span>"message";<br/></span><span>          }  <br/></span><span>        }</span></pre>
<ol start="3">
<li>Create a web page, <kbd>message.html</kbd>, under the location, <kbd>src/main/resources/templates</kbd>, with the following code:</li>
</ol>
<pre class="mce-root">        &lt;<span>h1</span><span>&gt;</span><span>Hello, this is a message from the Controller</span><span>&lt;/</span><span>h1</span><span>&gt;<br/></span><span>        &lt;</span><span>h2</span><span>&gt;</span><span>The time now is [[${#dates.createNow()}]]</span><span>&lt;/</span><span>h2</span><span>&gt;</span></pre>
<ol start="4">
<li>From the command prompt, navigate to the project root folder and issue the command, <kbd>mvn spring-boot:run</kbd>; you'll see the application being launched. Once it completes the initialization and starts, it would be running on the default port, <kbd>8080</kbd>. Navigate to <kbd>http://localhost:8080/message</kbd> to see the message.</li>
</ol>
<p>We are using Spring Boot's Maven plugin, which provides us with convenient tools to launch the application during development. But for production, we will create a fat JAR, that is, a JAR comprising all the dependencies, and deploy it as a Linux or Windows service. We can even run the fat JAR using the <kbd>java -jar</kbd> command.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We will not go into the working of Spring Boot or the other Spring libraries. But to state in brief, Spring Boot creates an embedded Tomcat running on the default port, that is, <kbd>8080</kbd>. It then registers all the controllers, components, and services that are available in the packages and sub packages of the class with the annotation, <kbd>@SpringBootApplication</kbd>.</p>
<p>In our recipe, the <kbd>BootDemoApplication</kbd> class in the <kbd>com.packt.boot_demo</kbd> package is annotated with <kbd>@SpringBootApplication</kbd>. So, all the classes that are annotated with <kbd>@Controller</kbd>, <kbd>@Service</kbd>, <kbd>@Configuration</kbd>, <kbd>@Component</kbd>, and the likes of it get registered with the Spring framework as beans and are managed by it. Now, these can be injected into the code by using the <kbd>@Autowired</kbd> annotation. </p>
<p>There are two ways we can create a web controller:</p>
<ol>
<li>Annotating with <kbd>@Controller</kbd></li>
<li>Annotating with <kbd>@RestController</kbd></li>
</ol>
<p>In the first approach, we create a controller that can serve both raw data and HTML data (generated by template engines such as Thymeleaf, Freemarker, JSP, and others). In the second approach, the controller supports endpoints that can only serve raw data in the form of JSON or XML. In our recipe, we used the former approach, as follows:</p>
<pre>@Controller<br/>public class SimpleViewController{<br/>  @GetMapping("/message")<br/>  public String message(){<br/>    return "message";<br/>  }<br/>}</pre>
<p>We can annotate the class with <kbd>@RequestMapping</kbd> with, say, <kbd>@RequestMapping("/api")</kbd>. In this case, any HTTP endpoints exposed in the controller are prepended by <kbd>/api</kbd>. There is a specialized annotation mapping for HTTP <kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>DELETE</kbd>, and <kbd>PUT</kbd> methods, namely <kbd>@GetMapping</kbd>, <kbd>@PostMapping</kbd>, <kbd>@DeleteMapping</kbd>, and <kbd>@PutMapping</kbd>, respectively. We can also rewrite our controller class as follows:</p>
<pre>@Controller<br/>@RequestMapping("/message")<br/>public class SimpleViewController{<br/>  @GetMapping<br/>  public String message(){<br/>    return "message";<br/>  }<br/>}</pre>
<p>We can modify the port by providing <kbd>server.port = 9090</kbd> in the <kbd>application.properties</kbd> file. This file can be found in the location, <kbd>src/main/resources/application.properties</kbd>. There is a whole set of properties (<a href="http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html">http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html</a>) that we can use to customize and connect with different components. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interacting with the database</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will look at how to integrate with a database to create, read, modify, and delete the data. For this, we will set up a MySQL database with the required table. Subsequently, we will update the data in a table from our Spring Boot application. </p>
<p>We will be using Windows as the platform of development for this recipe. You can perform a similar action on Linux as well, but you would first have to set up your MySQL database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Before we start integrating our application with the database, we need to set up the database locally on our development machines. In the subsequent sections, we will download and install MySQL tools and then create a sample table with some data, which we will use with our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing MySQL tools</h1>
                </header>
            
            <article>
                
<p>First, download the MySQL installer from <a href="https://dev.mysql.com/downloads/windows/installer/5.7.html">https://dev.mysql.com/downloads/windows/installer/5.7.html</a>. This MySQL bundle is for Windows only. Follow the onscreen instructions to successfully install MySQL along with other tools such as MySQL Workbench. To confirm that the MySQL daemon (<kbd>mysqld</kbd>) is running, open the task manager and you should be able to see a process similar to the one shown in the following image:</p>
<div class="CDPAlignCenter CDPAlign"><img height="41" width="481" class="image-border" src="assets/808e253f-61e7-4001-8276-dd89038c5ea2.png"/></div>
<div class="packt_tip">You should remember the password you set for the root user. </div>
<p>Let's run the MySQL workbench; on starting up, you should be able to see something similar to the following image, among other things provided by the tool:</p>
<div class="CDPAlignCenter CDPAlign"><img height="176" width="280" class="image-border" src="assets/1209d7ad-07ef-481f-9787-121d25f3adcf.png"/></div>
<p>If you don't find a connection like the preceding image, you can add one using the (<span class="packt_screen">+</span>) sign. On clicking on (+), you will see the following dialog. Fill it up and click on <span class="packt_screen">Test Connection</span> to get a success message:</p>
<div class="CDPAlignCenter CDPAlign"><img height="381" width="607" class="image-border" src="assets/f17690ad-740e-40a6-9821-292b79e0144f.png"/></div>
<p>A successful <span class="packt_screen">Test Connection</span> will result in the following message:</p>
<div class="CDPAlignCenter CDPAlign"><img height="195" width="280" class="image-border" src="assets/2ad5d683-ac9c-48a7-9742-5f6b73ef038a.png"/></div>
<p>Double-click on the connection to connect to the database, and you should see a list of DBs on the left-hand side, an empty area on the right-hand side, and menu and toolbars on the top. From the <span class="packt_screen">File</span> menu, click on <span class="packt_screen">New Query Tab</span> or, alternatively, press <em>Ctrl</em> + <em>T</em> to get a new query window. Here, we will write our queries to create a database and create a table within that database.</p>
<div class="packt_infobox">The bundled installer downloaded from <a href="https://dev.mysql.com/downloads/windows/installer/5.7.html">https://dev.mysql.com/downloads/windows/installer/5.7.html</a> is for Windows only. Linux users have to download the MySQL Server and MySQL Workbench (GUI for interacting with DB) separately. <br/>
The MySQL server can be downloaded from <a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a>.<br/>
The MySQL Workbench can be downloaded from <a href="https://dev.mysql.com/downloads/workbench/">https://dev.mysql.com/downloads/workbench/</a>.  </div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a sample database</h1>
                </header>
            
            <article>
                
<p>Run the following SQL statement to create a database:</p>
<pre>create database sample;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a person table</h1>
                </header>
            
            <article>
                
<p>Run the following SQL statements to use the newly created database and create a simple person table:</p>
<pre>create table person( <br/>  id int not null auto_increment,    <br/>  first_name varchar(255),    <br/>  last_name varchar(255),<br/>  place varchar(255),    <br/>  primary key(id)<br/>);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Populating sample data</h1>
                </header>
            
            <article>
                
<p>Let's go ahead and insert some sample data in the table we just created:</p>
<pre>insert into person(first_name, last_name, place) <br/>values('Raj', 'Singh', 'Bangalore');<br/><br/>insert into person(first_name, last_name, place) <br/>values('David', 'John', 'Delhi');</pre>
<p>Now that we have our database ready, we will go ahead and download the empty Spring Boot project from <a href="http://start.spring.io/">http://start.spring.io/</a> with the following options:</p>
<div class="CDPAlignCenter CDPAlign"><img height="254" width="782" class="image-border" src="assets/ce36c8dc-a4b2-4bb7-b329-59e87c0807ac.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a model class, <kbd>com.packt.boot_db_demo.Person</kbd>, for representing a person. We will make use of Lombok annotations to generate the getters and setters for us:</li>
</ol>
<pre><span>        @Data<br/></span><span>        public class </span>Person{<br/>          <span>private </span>Integer <span>id</span>;<br/>          <span>private </span>String <span>firstName</span>;<br/>          <span>private </span>String <span>lastName</span>;<br/>          <span>private </span>String <span>place</span>;<br/>        }</pre>
<ol start="2">
<li>Let's create <kbd>com.packt.boot_db_demo.PersonMapper</kbd> to map the data from the database into our model class, <kbd>Person</kbd>:</li>
</ol>
<pre>        @Mapper<br/>        public interface PersonMapper {<br/>        }</pre>
<ol start="3">
<li>Let's add a method to get all the rows from the table. Note that the next few methods will be written inside the <kbd>PersonMapper</kbd> interface:</li>
</ol>
<pre>        @Select("SELECT * FROM person")<br/>        public List&lt;Person&gt; getPersons();</pre>
<ol start="4">
<li>Another method to get the details of a single person identified by ID is as follows:</li>
</ol>
<pre>        @Select("SELECT * FROM person WHERE id = #{id}")<br/>        public Person getPerson(Integer id);</pre>
<ol start="5">
<li>The method to create a new row in the table is as follows:</li>
</ol>
<pre>        @Insert("INSERT INTO person(first_name, last_name, place) " +<br/>                " VALUES (#{firstName}, #{lastName}, #{place})")<br/><span>        @Options</span>(useGeneratedKeys = <span>true</span>)<br/>        public void insert(Person person);</pre>
<ol start="6">
<li>The method to update an existing row in the table, identified by the ID is as follows:</li>
</ol>
<pre>        @Update("UPDATE person SET first_name = #{firstName}, last_name = <br/>                #{lastName}, "+ "place = #{place}  WHERE id = #{id} ")<br/>        public void save(Person person);</pre>
<ol start="7">
<li>Finally, the method to delete a row from the table, identified by the ID is as follows:</li>
</ol>
<pre>        @Delete("DELETE FROM person WHERE id = #{id}")<br/>        public void delete(Integer id);</pre>
<ol start="8">
<li>Let's create a <kbd>com.packt.boot_db_demo.PersonController</kbd> class, which we will use to write our web endpoints:</li>
</ol>
<pre>        @Controller<br/>        @RequestMapping("/persons")<br/>        public class PersonContoller {<br/>          @Autowired PersonMapper personMapper;<br/>        }</pre>
<ol start="9">
<li>Let's create an endpoint to list all the entries in the <kbd>person</kbd> table:</li>
</ol>
<pre>        @GetMapping<br/>        public String list(ModelMap model){<br/>          List&lt;Person&gt; persons = personMapper.getPersons();<br/>          model.put("persons", persons);<br/>          return "list";<br/>        }</pre>
<ol start="10">
<li>Let's create an endpoint to add a new row in the <kbd>person</kbd> table:</li>
</ol>
<pre>        @GetMapping("/{id}")<br/>        public String detail(ModelMap model, @PathVariable Integer id){<br/>          System.out.println("Detail id: " + id);<br/>          Person person = personMapper.getPerson(id);<br/>          model.put("person", person);<br/>          return "detail";<br/>        }</pre>
<ol start="11">
<li>Let's create an endpoint to add a new row or edit an existing row in the <kbd>person</kbd> table:</li>
</ol>
<pre>        @PostMapping("/form")<br/>        public String submitForm(Person person){<br/>          System.out.println("Submiting form person id: " + <br/>                             person.getId());<br/>          if ( person.getId() != null ){<br/>            personMapper.save(person);<br/>          }else{<br/>            personMapper.insert(person);<br/>          }<br/>          return "redirect:/persons/";<br/>        }  </pre>
<ol start="12">
<li>Let's create an endpoint to delete a row from the <kbd>person</kbd> table:</li>
</ol>
<pre>        @GetMapping("/{id}/delete")<br/>        public String deletePerson(@PathVariable Integer id){<br/>          personMapper.delete(id);<br/>          return "redirect:/persons";<br/>        }</pre>
<ol start="13">
<li>Finally, we need to update the <kbd>src/main/resources/application.properties</kbd> file to provide the configuration related to our data source, that is, our MySQL database:</li>
</ol>
<pre>        spring.datasource.driver-class-name=com.mysql.jdbc.Driver<br/>        spring.datasource.url=jdbc:mysql://localhost/sample?useSSL=false<br/>        spring.datasource.username=root<br/>        spring.datasource.password=mohamed<br/><span>        mybatis.configuration.map-underscore-to-camel-case</span>=<span>true</span></pre>
<p>You can run the application from the command line using <kbd>mvn spring-boot:run</kbd>. This application starts up on the default port, that is, <kbd>8080</kbd>. Navigate to <kbd>http://localhost:8080/persons</kbd> in your browser. </p>
<p>The complete code for this recipe can be found at the location, <kbd>chp10/2_boot_db_demo</kbd>.</p>
<p>On visiting <kbd>http://localhost:8080/persons</kbd>, this is what you will find:</p>
<div class="CDPAlignCenter CDPAlign"><img height="126" width="226" class="image-border" src="assets/9d1e94e0-7e9a-44a9-ba09-f1865e9c311f.png"/></div>
<p>On clicking on <strong><span class="packt_screen">New Person</span></strong>, you'll get the following:</p>
<div class="CDPAlignCenter CDPAlign"><img height="114" width="183" class="image-border" src="assets/a17f99f6-e99f-44bf-9782-cb5ced34c31f.png"/></div>
<p>On clicking on <strong><span class="packt_screen">Edit</span></strong>, you'll get the following:</p>
<div class="CDPAlignCenter CDPAlign"><img height="125" width="184" class="image-border" src="assets/d5c693af-c327-4da1-93ba-28a03bc5cf08.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Firstly, <kbd>com.packt.boot_db_demo.PersonMapper</kbd> annotated with <kbd>org.apache.ibatis.annotations.Mapper</kbd> knows how to execute the query provided within the <kbd>@Select</kbd>, <kbd>@Update</kbd>, or <kbd>@Delete</kbd> annotations and to return relevant results. This is all managed by the MyBatis and Spring Data libraries. </p>
<p>You must be wondering how the connection to database was achieved. One of the Spring Boot autoconfiguration classes, <kbd>DataSourceAutoConfiguration</kbd>, does the work of setting up by making use of the <kbd>spring.datasource.*</kbd> properties defined in your <kbd>application.properties</kbd> file to give us an instance of <kbd>javax.sql.DataSource</kbd>. This <kbd>javax.sql.DataSource</kbd> object is then used by the MyBatis library to provide you with an instance of <kbd>SqlSessionTemplate</kbd>, which is what is used by our <kbd>PersonMapper</kbd> under the hood.</p>
<p>Then, we make use of <kbd>com.packt.boot_db_demo.PersonMapper</kbd> by injecting it into the <kbd>com.packt.boot_db_demo.PersonController</kbd> class by using <kbd>@AutoWired</kbd>. The <kbd>@AutoWired</kbd> annotation looks for any Spring managed beans, which are either instances of the exact type or its implementation. Take a look at the <em>Creating a simple Spring Boot application</em> recipe in this chapter to understand the <kbd>@Controller</kbd> annotation.</p>
<p>With very little configuration, we have been able to quickly set up simple CRUD operations. This is the flexibility and agility that Spring Boot provides to developers!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a RESTful web service</h1>
                </header>
            
            <article>
                
<p>In our previous recipe, we interacted with data using web forms. In this recipe, we will see how to interact with data using RESTful web services. These web services are a means to interact with other applications using the known HTTP protocol and its methods, namely GET, POST, PUT, and others. The data can be exchanged in the form of XML, JSON, or even plain text. We will be using JSON in our recipe. </p>
<p>So, we will create RESTful APIs to support retrieving data, creating new data, editing data, and deleting data. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>As usual, download the starter project from <a href="http://start.spring.io/">http://start.spring.io/</a> by selecting the dependencies as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="258" width="811" class="image-border" src="assets/65375392-107e-43d6-89f2-7bb3c66a35f2.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>We will copy the <kbd>Person</kbd> class from the previous recipe:</li>
</ol>
<pre>        public class Person {<br/>          private Integer id;<br/>          private String firstName;<br/>          private String lastName;<br/>          private String place;<br/>          //required getters and setters<br/>        }</pre>
<ol start="2">
<li>We will do the <kbd>PersonMapper</kbd> part in a different way. We will write all our SQL queries in a mapper XML file and then refer to them from the <kbd>PersonMapper</kbd> interface. We will place the mapper XML under the <kbd>src/main/resources/mappers</kbd> folder. We'll set the value of the <kbd>mybatis.mapper-locations</kbd> property to <kbd>classpath*:mappers/*.xml</kbd>. This way, the <kbd>PersonMapper</kbd> interface can discover the SQL queries corresponding to its methods.</li>
<li>First, let's create the <kbd>com.packt.boot_rest_demo.PersonMapper</kbd> interface:</li>
</ol>
<pre>        @Mapper<br/>        public interface PersonMapper {<br/>          public List&lt;Person&gt; getPersons();<br/>          public Person getPerson(Integer id);<br/>          public void save(Person person);<br/>          public void insert(Person person);<br/>          public void delete(Integer id);<br/>        }</pre>
<ol start="4">
<li>Now, let's create the SQL in <kbd>PersonMapper.xml</kbd>. One thing to make sure of is that the <kbd>namespace</kbd> attribute of the <kbd>&lt;mapper&gt;</kbd> tag should be the same as the fully qualified name of the <kbd>PersonMapper</kbd> mapper interface:</li>
</ol>
<pre>        &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"<br/>          "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;<br/>        &lt;mapper namespace="com.packt.boot_rest_demo.PersonMapper"&gt;<br/>          &lt;select id="getPersons"<br/>           resultType="com.packt.boot_rest_demo.Person"&gt;<br/>            SELECT id, first_name firstname, last_name lastname, place<br/>            FROM person<br/>          &lt;/select&gt;<br/> <br/>          &lt;select id="getPerson"<br/>           resultType="com.packt.boot_rest_demo.Person"<br/>           parameterType="long"&gt;<br/>            SELECT id, first_name firstname, last_name lastname, place<br/>            FROM person<br/>            WHERE id = #{id}<br/>          &lt;/select&gt;<br/>    <br/>          &lt;update id="save"<br/>           parameterType="com.packt.boot_rest_demo.Person"&gt;<br/>            UPDATE person SET<br/>              first_name = #{firstName},<br/>              last_name = #{lastName},<br/>              place = #{place}<br/>            WHERE id = #{id}<br/>          &lt;/update&gt;<br/><br/>          &lt;insert id="insert" <br/>           parameterType="com.packt.boot_rest_demo.Person"<br/>           useGeneratedKeys="true" keyColumn="id" keyProperty="id"&gt;<br/>            INSERT INTO person(first_name, last_name, place)<br/>            VALUES (#{firstName}, #{lastName}, #{place})<br/>          &lt;/insert&gt;<br/><br/>          &lt;delete id="delete" parameterType="long"&gt;<br/>            DELETE FROM person WHERE id = #{id}<br/>          &lt;/delete&gt;<br/>        &lt;/mapper&gt;</pre>
<ol start="5">
<li>We will define the application properties in the <kbd>src/main/resources/application.properties</kbd> file:</li>
</ol>
<pre>        spring.datasource.driver-class-name=com.mysql.jdbc.Driver<br/>        spring.datasource.url=jdbc:mysql://localhost/sample?useSSL=false<br/>        spring.datasource.username=root<br/>        spring.datasource.password=mohamed<br/>        mybatis.mapper-locations=classpath*:mappers/*.xml</pre>
<ol start="6">
<li>Create an empty controller for our REST APIs. This controller will be marked with the <kbd>@RestController</kbd> annotation because all the APIs in it are going to deal solely with data:</li>
</ol>
<pre>        @RestController<br/>        @RequestMapping("/api/persons")<br/>        public class PersonApiController {<br/>          @Autowired PersonMapper personMapper;<br/>        }</pre>
<ol start="7">
<li>Let's add an API to list all the rows in the <kbd>person</kbd> table:</li>
</ol>
<pre>        @GetMapping<br/>        public ResponseEntity&lt;List&lt;Person&gt;&gt; getPersons(){<br/>          return new ResponseEntity&lt;&gt;(personMapper.getPersons(),<br/>                                      HttpStatus.OK);<br/>        }</pre>
<ol start="8">
<li>Let's add an API to get the details of a single person:</li>
</ol>
<pre>        @GetMapping("/{id}")<br/>        public ResponseEntity&lt;Person&gt; getPerson(@PathVariable Integer id){<br/>          return new ResponseEntity&lt;&gt;(personMapper.getPerson(id),<br/>                                      HttpStatus.OK);<br/>        }</pre>
<ol start="9">
<li>Let's add an API to add new data to the table:</li>
</ol>
<pre>        @PostMapping<br/>        public ResponseEntity&lt;Person&gt; newPerson<br/>                       (@RequestBody Person person){<br/>          personMapper.insert(person);<br/>          return new ResponseEntity&lt;&gt;(person, HttpStatus.OK);<br/>        }</pre>
<ol start="10">
<li>Let's add an API to edit the data in the table:</li>
</ol>
<pre>        @PostMapping("/{id}")<br/>        public ResponseEntity&lt;Person&gt; updatePerson<br/>                       (@RequestBody Person person,<br/>          @PathVariable Integer id){<br/>            person.setId(id);<br/>            personMapper.save(person);<br/>            return new ResponseEntity&lt;&gt;(person, HttpStatus.OK);<br/>          }</pre>
<ol start="11">
<li>Let's add an API to delete the data in the table:</li>
</ol>
<pre>        @DeleteMapping("/{id}")<br/>        public ResponseEntity&lt;Void&gt; deletePerson<br/>                       (@PathVariable Integer id){<br/>          personMapper.delete(id);<br/>          return new ResponseEntity&lt;&gt;(HttpStatus.OK);<br/>        }</pre>
<p>You can find the complete code at the location, <kbd>chp10/3_boot_rest_demo</kbd>. You can launch the application by using <kbd>mvn spring-boot:run</kbd> from the project folder. Once the application has started, navigate to <kbd>http://localhost:8080/api/persons</kbd> to view all the data in the person table. </p>
<p>To test the other APIs, we will make use of the Postman REST client app for Google Chrome. </p>
<p>This is what adding a new person looks like. Look at the request body, that is, the person detail specified in JSON:</p>
<div class="CDPAlignCenter CDPAlign"><img height="528" width="676" class="image-border" src="assets/50ab051d-1b1b-441e-8166-209c9df8424e.png"/></div>
<p>This is how we edit a person's detail:</p>
<div class="CDPAlignCenter CDPAlign"><img height="487" width="624" class="image-border" src="assets/b053a527-ed07-45e2-b949-d8da14f6eab6.png"/></div>
<p>This is what deleting a person looks like:</p>
<div class="CDPAlignCenter CDPAlign"><img height="533" width="683" class="image-border" src="assets/5328fb47-7242-4ce9-b772-b04d52732a48.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>First, let's look at how the <kbd>PersonMapper</kbd> interface discovers the SQL statements to execute. If you look at <kbd>src/main/resources/mappers/PersonMapper.xml</kbd>, you will find that the <kbd>&lt;mapper&gt;</kbd> <kbd>namespace</kbd> attribute is <kbd>org.packt.boot_rest_demo.PersonMapper</kbd>. This is a requirement that the value of <kbd>namespace</kbd> attribute should be the fully qualified name of the mapper interface, which, in our case, is <kbd>org.packt.boot_rest_demo.PersonMapper</kbd>.</p>
<p>Next the <kbd>id</kbd> attributes of the individual SQL statements defined within <kbd>&lt;select&gt;</kbd>, <kbd>&lt;insert&gt;</kbd>, <kbd>&lt;update&gt;</kbd>, and <kbd>&lt;delete&gt;</kbd> should match the name of the method in the mapper interface. For example, the <kbd>getPersons()</kbd> method in the <kbd>PersonMapper</kbd> interface looks for an SQL statement with <kbd>id="getPersons"</kbd>. </p>
<p>Now the MyBatis library discovers the location of this mapper XML by reading the value of the <kbd>mybatis.mapper-locations</kbd> property.</p>
<p>Coming to the controller, we have introduced a new annotation, <kbd>@RestController</kbd>. This special annotation indicates, in addition to it being a web controller, that all the methods defined in the class return a response that is sent via the HTTP response body; so do all the REST APIs. They just work with the data. </p>
<p>As usual, you can launch your Spring Boot application either by using the Maven Spring-Boot plugin, <kbd>mvn spring-boot:run</kbd> or by executing the JAR created by the Maven package, <kbd>java -jar my_jar_name.jar</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating multiple profiles for Spring Boot</h1>
                </header>
            
            <article>
                
<p><span>Generally, web applications are deployed on different environments--first, they are run locally on a developer's machine, then deployed on test servers, and finally deployed on production servers.</span> We would have the application interacting with components located in different places for each environment. The best approach for this is to maintain different profiles for each environment. One way to do this is by creating different versions of the <kbd>application.properties</kbd> file, that is, different versions of the file that stores the application-level properties. These property files in Spring Boot can also be YML files, such as <kbd>application.yml</kbd>. Even if you create different versions, you need a mechanism to tell your applications to pick the relevant version of the file, based on the environment it has been deployed to. </p>
<p>Spring Boot provides amazing support for such a feature. It allows you to have multiple configuration files, each representing a specific profile, and then, you can launch your application in different profiles, depending on the environment it is being deployed to. Let's see this in action, and then we will explain how it works.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>For this recipe, there are two options to host another instance of your MySQL database:</p>
<ol>
<li>Use a cloud provider such as AWS and use its Amazon <strong>Relational Database Service</strong> (<strong>RDS</strong>) (<a href="https://aws.amazon.com/rds/">https://aws.amazon.com/rds/</a>). They have a certain free usage limit.</li>
<li>Use a cloud provider such as DigitalOcean (<a href="https://www.digitalocean.com/">https://www.digitalocean.com/</a>) to purchase a droplet (that is, a server) for as little as $5 per month. Then install the MySQL server on it.</li>
<li>Use VirtualBox to install Linux on your machine, assuming we are using Windows, or vice versa if you are using Linux. Then install the MySQL server on it.</li>
</ol>
<p>The options are much more right from hosted database services to servers, which give you complete root access to install the MySQL server. For this recipe, we did the following:</p>
<ol>
<li>We purchased a basic droplet from DigitalOcean.</li>
<li>We installed MySQL using <kbd>sudo apt-get install mysql-server-5.7</kbd> with a password for the root user.</li>
<li>We created another user, <kbd>springboot</kbd>, so that we can use this user to connect from our RESTful web service application:</li>
</ol>
<pre><strong>        $ mysql -uroot -p</strong><br/><strong>        Enter password: </strong><br/><strong>        mysql&gt; create user 'springboot'@'%' identified by 'springboot';</strong></pre>
<ol start="4">
<li>We modified the MySQL configuration file so that the MySQL allows remote connections. This can be done by editing the <kbd>bind-address</kbd> property in the <kbd>/etc/mysql/mysql.conf.d/mysqld.cnf</kbd> file to the IP of the server. </li>
<li>From MySQL workbench, we added the new MySQL connection by using <kbd>IP = &lt;Digital Ocean droplet IP&gt;</kbd>, <kbd>username = springboot</kbd>, and <kbd>password = springboot</kbd>.</li>
</ol>
<div class="packt_infobox">
<p>The  location for the MySQL configuration file in Ubuntu OS is <kbd>/etc/mysql/mysql.conf.d/mysqld.cnf</kbd>. One way to find out the location of a configuration file specific to your OS is to do the following:</p>
<ol>
<li>Run <kbd>mysql --help</kbd></li>
<li>In the output, search for <kbd>Default options are read from the following files in the given order:</kbd> and what follows is the possible locations for the MySQL configuration file.</li>
</ol>
</div>
<p>We will create the required table and populate some data. But before that, we will create the <kbd>sample</kbd> database as <kbd>root</kbd> and grant all privileges on it to the <kbd>springboot</kbd> user.</p>
<pre><strong>mysql -uroot</strong><br/><strong>Enter password: </strong><br/><br/><strong>mysql&gt; create database sample;</strong><br/><br/><strong>mysql&gt; GRANT ALL ON sample.* TO 'springboot'@'%';</strong><br/><strong>Query OK, 0 rows affected (0.00 sec)</strong><br/><br/><strong>mysql&gt; flush privileges;</strong></pre>
<p>Now, let's connect to the database as the <kbd>springboot</kbd> user, create the required table, and populate it with some sample data:</p>
<pre><strong>mysql -uspringboot -pspringboot</strong><br/><br/><strong>mysql&gt; use sample</strong><br/><strong>Database changed</strong><br/><strong>mysql&gt; create table person(</strong><br/><strong>-&gt; id int not null auto_increment,</strong><br/><strong>-&gt; first_name varchar(255),</strong><br/><strong>-&gt; last_name varchar(255),</strong><br/><strong>-&gt; place varchar(255),</strong><br/><strong>-&gt; primary key(id)</strong><br/><strong>-&gt; );</strong><br/><strong>Query OK, 0 rows affected (0.02 sec)</strong><br/><br/><strong>mysql&gt; INSERT INTO person(first_name, last_name, place) VALUES('Mohamed', 'Sanaulla', 'Bangalore');</strong><br/><strong>mysql&gt; INSERT INTO person(first_name, last_name, place) VALUES('Nick', 'Samoylov', 'USA');</strong><br/><br/><strong>mysql&gt; SELECT * FROM person;</strong><br/><strong>+----+------------+-----------+-----------+</strong><br/><strong>| id | first_name | last_name | place     |</strong><br/><strong>+----+------------+-----------+-----------+</strong><br/><strong>| 1  | Mohamed    | Sanaulla  | Bangalore |</strong><br/><strong>| 2  | Nick       | Samoylov  | USA       |</strong><br/><strong>+----+------------+-----------+-----------+</strong><br/><strong>2 rows in set (0.00 sec)</strong></pre>
<p>Now we have our cloud instance of the MySQL DB ready. Let's look at how to manage the information of two different connections based on the profile the application is running in.</p>
<p>The initial sample app required for this recipe can be found at the location, <kbd>chp10/4_boot_multi_profile_incomplete</kbd>. We will convert this app to make it run on different environments.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>In the <kbd>src/main/resources/application.properties</kbd> file, add a new <kbd>springboot</kbd> property, <kbd>spring.profiles.active = local</kbd>.</li>
<li>Create a new file, <kbd>application-local.properties</kbd>, at the location, <kbd>src/main/resources/</kbd>. </li>
<li>Add the following properties to <kbd>application-local.properties</kbd> and remove them from the <kbd>application.properties</kbd> file:<span><br/></span></li>
</ol>
<pre>        spring.datasource.url=jdbc:mysql://localhost/sample?useSSL=false<br/>        spring.datasource.username=root<br/>        spring.datasource.password=mohamed</pre>
<ol start="4">
<li>Create another file, <kbd>application-cloud.properties</kbd>, at <kbd>src/main/resources/</kbd>.</li>
<li>Add the following properties to <kbd>application-cloud.properties</kbd>:</li>
</ol>
<pre>        spring.datasource.url=jdbc:mysql://&lt;digital_ocean_ip&gt;/sample?                                useSSL=false<br/>        spring.datasource.username=springboot<br/>        spring.datasource.password=springboot</pre>
<p>The complete code for the complete application can be found at <kbd>chp10/4_boot_multi_profile_incomplete</kbd><strong>.</strong> You can run the application by using the <kbd>mvn spring-boot:run</kbd> command. Spring Boot reads the <kbd>spring.profiles.active</kbd> property from the <kbd>application.properties</kbd> file and runs the application in a local profile. Open the URL, <kbd>http://localhost:8080/api/persons</kbd>, in the browser to find the following data: </p>
<pre><span class="b">[ <br/></span><span class="blockInner"><span class="kvov arrElem"><span class="b">  {<br/></span><span class="kvov objProp">    "<span class="k">id</span>": <span class="n">1</span>,<br/></span><span class="kvov objProp">    "<span class="k">firstName</span>": <span class="s">"<span>David</span> "</span>,<br/></span><span class="kvov objProp">    "<span class="k">lastName</span>": <span class="s">"<span>John</span>"</span>,<br/></span><span class="kvov objProp">    "<span class="k">place</span>": <span class="s">"<span>Delhi</span>"<br/></span></span><span class="b">  }</span>,<br/></span><span class="kvov arrElem"><span class="b">  {<br/></span><span class="kvov objProp">    "<span class="k">id</span>": <span class="n">2</span>,<br/></span><span class="kvov objProp">    "<span class="k">firstName</span>": <span class="s">"<span>Raj</span>"</span>,<br/></span><span class="kvov objProp">    "<span class="k">lastName</span>": <span class="s">"<span>Singh</span>"</span>,<br/></span><span class="kvov objProp">    "<span class="k">place</span>": <span class="s">"<span>Bangalore</span>"<br/></span></span><span class="b">  }<br/></span></span></span><span class="b">]</span></pre>
<p>Now, run the application on the cloud profile by using the <kbd>mvn spring-boot:run -Dspring.profiles.active=cloud</kbd> command. Then open <kbd>http://localhost:8080/api/persons</kbd> in the browser to find the following data:</p>
<pre><span class="b">[<br/></span><span class="blockInner"><span class="kvov arrElem"><span class="b">  {<br/></span><span class="kvov objProp">    "<span class="k">id</span>": <span class="n">1</span>,<br/></span><span class="kvov objProp">    "<span class="k">firstName</span>": <span class="s">"<span>Mohamed</span>"</span>,<br/></span><span class="kvov objProp">    "<span class="k">lastName</span>": <span class="s">"<span>Sanaulla</span>"</span>,<br/></span><span class="kvov objProp">    "<span class="k">place</span>": <span class="s">"<span>Bangalore</span>"<br/></span></span><span class="b">  }</span>,<br/></span><span class="kvov arrElem"><span class="b">  {<br/></span><span class="kvov objProp">    "<span class="k">id</span>": <span class="n">2</span>,<br/></span><span class="kvov objProp">    "<span class="k">firstName</span>": <span class="s">"<span>Nick</span>"</span>,<br/></span><span class="kvov objProp">    "<span class="k">lastName</span>": <span class="s">"<span>Samoylov</span>"</span>,<br/></span><span class="kvov objProp">    "<span class="k">place</span>": <span class="s">"<span>USA</span>"<br/></span></span><span class="b">  }<br/></span></span></span><span class="b">]</span></pre>
<p>You can see that there is a different set of data returned by the same API and the preceding data was inserted in our MySQL database running on the cloud. So, we have been able to successfully run the app in two different profiles: local and cloud.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>There are multiple ways Spring Boot can read the configuration for the application. Some significant ones are listed here in the order of their relevance (the property defined in the earlier source overrides the property defined in the later sources):</p>
<ul>
<li>From the command line. The properties are specified using the <kbd>-D</kbd> option, like we did while launching the app in the cloud profile, <kbd>mvn spring-boot:run -Dspring.profiles.active=cloud</kbd>. Or, if you are using JAR, then it would be <kbd>java -Dspring.profiles.active=cloud -jar myappjar.jar</kbd>.</li>
<li>From the Java system properties, using <kbd>System.getProperties()</kbd>.</li>
<li>OS Environment variables.</li>
<li>Profile-specific application properties, <kbd>application-{profile}.properties</kbd>, or the <kbd>application-{profile}.yml</kbd> files, outside of the packaged JAR.</li>
<li>Profile-specific application properties <kbd>application-{profile}.properties</kbd> or <kbd>application-{profile}.yml</kbd> files, packaged within the JAR.</li>
<li>Application properties, <kbd>application.properties</kbd>, or <kbd>application.yml</kbd> defined outside of the packaged JAR.</li>
<li>Application properties, <kbd>application.properties</kbd>, or <kbd>application.yml</kbd> packaged within the JAR.</li>
<li>Configuration classes (that is, annotated with <kbd>@Configuration</kbd>) serving as property sources (annotated with <kbd>@PropertySource</kbd>).</li>
<li>Spring Boot's default properties.</li>
</ul>
<p>In our recipe, we specified all the generic properties such as the following in the <kbd>application.properties</kbd> file, and any profile-specific property were specified in the profile-specific application properties file:</p>
<pre><span>spring.profiles.active</span>=<span>local<br/></span><span>spring.datasource.driver-class-name</span>=<span>com.mysql.jdbc.Driver<br/></span><span><br/></span><span>mybatis.mapper-locations</span>=<span>classpath*:mappers/*.xml<br/></span><span>mybatis.configuration.map-underscore-to-camel-case</span>=<span>true</span>  </pre>
<p>From the preceding list, we can find that the <kbd>application.properties</kbd> or <kbd>application-{profile}.properties</kbd> file can be defined outside the application JAR. There are default locations where Spring Boot will search for the properties file, and one such path is the <kbd>config</kbd> sub directory of the current directory the app is running from.</p>
<p>The complete list of Spring Boot-supported application properties can be found at <a href="http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html">http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html</a>. In addition to these, we can create our own properties required for our application.</p>
<p>The complete code for this can be found at the location, <kbd>chp10/4_boot_multi_profile_complete</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>We can create a configuration server using Spring Boot, which will act as a repository for all the properties for all the apps in all the profiles. The client apps can then connect with the configuration server to read the relevant properties based on the app name and the app profile. </p>
<p>In the configuration server, the application properties can be read from the filesystem using the classpath or a GitHub repository. The advantage of using a GitHub repository is that the property files can be versioned. The property files in the configuration server can be updated, and these updates can be pushed to the client apps by setting up a message queue to relay the changes downstream. Also, another way is to use the <kbd>@RefreshScope</kbd> beans and then invoke the <kbd>/refresh</kbd> API whenever we need the client apps to pull the configuration changes. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying RESTful web services to Heroku</h1>
                </header>
            
            <article>
                
<p><strong>Platform as a Service</strong> (<strong>Paas</strong>) is one of the cloud computing models (the other two being <strong>Software as a Service</strong> (<strong>SaaS</strong>) and <strong>Infrastructure as a Service</strong> (<strong>IaaS</strong>)) where the cloud computing provider provides managed computing platforms, which includes OS, programming language runtime, database, and other add ons such as queues, log management, and alerting. They also provide you tools to ease the deployment and dashboards to monitor your applications.</p>
<p>Heroku is one of the earliest players in the field of PaaS providers. It supports the following programming languages: Ruby, Node.js, Java, Python, Clojure, Scala, Go, and PHP. Heroku supports multiple data stores, such as MySQL, MongoDB, Redis, and Elastic search. It provides integration with logging tools, network utils, email services, and monitoring tools. </p>
<p>Heroku provides a command-line tool called heroku-cli (<a href="http://cli.heroku.com">cli.heroku.com</a>), which can be used to create Heroku applications, deploy, monitor, add resources, and more. The functionality provided from their web dashboard is supported by the CLI as well. It uses Git to store the application's source code. So, when you push the application code to Heroku's Git repository, it triggers a build, based on the build pack you are using. Then, it either uses the default way to spawn the application or <kbd>ProcFile</kbd> to execute your application. </p>
<p>In this recipe, we will deploy our Spring Boot-based RESTful web service to Heroku. We will continue to use the database we created on another cloud provider in the previous recipe, <em>Creating multiple profiles for Spring Boot</em>. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready </h1>
                </header>
            
            <article>
                
<p>Before we proceed with deploying our sample application on Heroku, we need to sign up for a Heroku account and install its tools, which will enable us to work from the command line. In the subsequent sections, we will guide you through the sign up process, creating a sample app via the web UI, and via the Heroku <strong>command-line interface</strong> (<strong>CLI</strong>). </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up a Heroku account</h1>
                </header>
            
            <article>
                
<p>Visit <a href="http://www.heroku.com">http://www.heroku.com</a> and sign up if you don't have an account. If you have an account, then you can log in. For signing up, the URL is <a href="https://signup.heroku.com">https://signup.heroku.com</a>:</p>
<div class="CDPAlignCenter CDPAlign"><img height="421" width="203" class="image-border" src="assets/da58d677-a96c-42fb-a3e0-0281b942f753.png"/></div>
<p>For login, the URL is <a href="https://id.heroku.com/login">https://id.heroku.com/login</a>:</p>
<div class="CDPAlignCenter CDPAlign"><img height="238" width="276" class="image-border" src="assets/89fc20f7-51c7-4073-bc36-413f39c821c0.png"/></div>
<p>Once you log in successfully, you will see a dashboard with the list of apps, if you have any:</p>
<div class="CDPAlignCenter CDPAlign"><img height="181" width="438" class="image-border" src="assets/2c284855-7193-4bfd-a460-02e6b2f1aa63.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a new app from the UI</h1>
                </header>
            
            <article>
                
<p>Click on <span class="packt_screen">New</span> | <span class="packt_screen">Create new app</span>, and fill in the details, as shown in the following screenshot, and click on <span class="packt_screen">Create App</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img height="312" width="361" class="image-border" src="assets/024a1459-63ea-47ea-9d2e-ecf78d12fb5b.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a new app from the CLI</h1>
                </header>
            
            <article>
                
<p>Perform the following steps to create a new app from the CLI:</p>
<ol>
<li>Install the Heroku CLI from <a href="https://cli.heroku.com">https://cli.heroku.com</a>.</li>
<li>Once installed, Heroku should be in your system's <kbd>PATH</kbd> variable. </li>
<li>Open a command prompt and run <kbd>heroku create</kbd>. You will see output similar to the following:</li>
</ol>
<pre><strong>        Creating app... done, glacial-beyond-27911</strong><br/><strong>        https://glacial-beyond-27911.herokuapp.com/ |</strong><br/><strong>        https://git.heroku.com/glacial-beyond-27911.git</strong></pre>
<ol start="4">
<li>The app name is generated dynamically and a remote Git repository is created. You can specify the app name and region (as done via the UI) by running the command: </li>
</ol>
<pre><strong>      $ heroku create test-app-9812 --region us</strong><br/><strong>      Creating test-app-9812... done, region is us</strong><br/><strong>      https://test-app-9812.herokuapp.com/ |<br/>      https://git.heroku.com/test-app-9812.git</strong></pre>
<p>The deployment to Heroku is done via <kbd>git push</kbd> to the remote Git repository created on Heroku. We will see this in the next section.</p>
<p>We have the source code for the app at <kbd>chp10/5_boot_on_heroku</kbd>. So, copy this application and go ahead and deploy on Heroku.</p>
<div class="packt_infobox">You have to log in to the Heroku account before running any of the commands in Heroku's cli. You can log in by running the command, <kbd>heroku login</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Run the following command to create a Heroku application:</li>
</ol>
<pre><strong>      $ heroku create &lt;app_name&gt; -region us</strong></pre>
<ol start="2">
<li>Initialize the Git repository in the project folder:</li>
</ol>
<pre><strong>      $ git init</strong></pre>
<ol start="3">
<li>Add the Heroku Git repository as a remote to your local Git repository:</li>
</ol>
<pre><strong>      $ heroku git:remote -a &lt;app_name_you_chose&gt;</strong></pre>
<ol start="4">
<li>Push the source code, that is, the master branch, to the Heroku Git repository:</li>
</ol>
<pre><strong>      $ git add .</strong><br/><strong>      $ git commit -m "deploying to heroku"</strong><br/><strong>      $ git push heroku master</strong></pre>
<ol start="5">
<li>When the code is pushed to the Heroku Git repository, it triggers a build. As we are using Maven, it runs the following command:</li>
</ol>
<pre><strong>      ./mvnw -DskipTests clean dependency:list install</strong></pre>
<ol start="6">
<li>Once the code has completed the build and deployed, you can open the application by using the <kbd>heroku open</kbd> command. This will open the application in a browser.</li>
<li>You can monitor the logs of the application using the <kbd>heroku logs --tail</kbd> command.</li>
</ol>
<p>Once the app has been successfully deployed, and after you run the <kbd>heroku open</kbd> command, you should see the URL being loaded by the browser:</p>
<div class="CDPAlignCenter CDPAlign"><img height="101" width="231" class="image-border" src="assets/98ed28ee-931f-402f-ac8c-667b5258c5ea.png"/></div>
<p>Clicking on the <span class="packt_screen">Persons</span> link will display the following information:</p>
<pre>[<br/>  {<br/>    "id":1,<br/>    "firstName":"Mohamed",<br/>    "lastName":"Sanaulla",<br/>    "place":"Bangalore"<br/>  },<br/>  {<br/>    "id":2,<br/>    "firstName":"Nick",<br/>    "lastName":"Samoylov",<br/>    "place":"USA"<br/>  }<br/>]</pre>
<p>The interesting thing here is that we have our app running on Heroku, which is connecting to a MySQL database on a DigitalOcean server. We can even provision a database along with the Heroku app and connect to that database. Check out how to do this in the <em>There's more...</em> section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<ol>
<li>Add a new DB add-on to the application:</li>
</ol>
<pre><strong>      $ heroku addons:create jawsdb:kitefin</strong></pre>
<p style="padding-left: 60px">Here, <kbd>addons:create</kbd> takes the add-on name and the service plan name, both separated by a colon (<kbd>:</kbd>). You can know more about the add-on details and plans at <a href="https://elements.heroku.com/addons/jawsdb-maria">https://elements.heroku.com/addons/jawsdb-maria</a>. Also, the Heroku CLI command to add the add-on to your application is given towards the end of the add-on details page for all add-ons.</p>
<ol start="2">
<li>Open the <span class="packt_screen">DB</span> dashboard to view the connection details, such as URL, username, password, and the database name:</li>
</ol>
<pre><strong>      $ heroku addons:open jawsdb</strong></pre>
<p style="padding-left: 60px">The <kbd>jawsdb</kbd> dashboard looks something similar to as shown below:</p>
<div class="CDPAlignCenter CDPAlign"><img height="469" width="824" class="image-border" src="assets/cc9b5188-5489-4840-926b-344dbd518a8d.png"/></div>
<ol start="3">
<li>You can even get the MySQL connection string from the <kbd>JAWSDB_URL</kbd> configuration property. You can list the configuration for your app by using the following command:</li>
</ol>
<pre><strong>      $ heroku config</strong><br/><strong>      === rest-demo-on-cloud Config Vars</strong><br/><strong>      JAWSDB_URL: &lt;URL&gt;</strong></pre>
<ol start="4">
<li>Copy the connection details and create a new connection in MySQL Workbench and connect to this connection. The database name is also created by the add-on. Run the following SQL statements after connecting to the database:</li>
</ol>
<pre>        use x81mhi5jwesjewjg;<br/>        create table person( <br/>          id int not null auto_increment, <br/>          first_name varchar(255), <br/>          last_name varchar(255), <br/>          place varchar(255), <br/>          primary key(id)<br/>        );<br/><br/>        INSERT INTO person(first_name, last_name, place) <br/>        VALUES('Heroku First', 'Heroku Last', 'USA');<br/><br/>        INSERT INTO person(first_name, last_name, place) <br/>        VALUES('Jaws First', 'Jaws Last', 'UK');</pre>
<ol start="5">
<li>Create a new properties file for the Heroku profile, <kbd>application-heroku.properties</kbd> at  <kbd>src/main/resources</kbd>, with the following properties:</li>
</ol>
<pre><span>        spring.datasource.url</span>=<span>jdbc:mysql://<br/>        &lt;URL DB&gt;:3306/x81mhi5jwesjewjg?useSSL=false<br/></span><span>        spring.datasource.username</span>=<span>zzu08pc38j33h89q<br/></span><span>        spring.datasource.password</span>=<span>&lt;DB password&gt;<br/></span></pre>
<p style="padding-left: 60px">You can find the connection related details from the add-on dashboard.</p>
<ol start="6">
<li>Update the <kbd>src/main/resources/application.properties</kbd> file to replace the value of the <kbd>spring.profiles.active</kbd> property to <kbd>heroku</kbd></li>
<li>Commit and push the changes to Heroku remote:</li>
</ol>
<pre><strong>      $ git commit -am"using heroky mysql addon"</strong><br/><strong>      $ git push heroku master</strong></pre>
<ol start="8">
<li>Once the deployment succeeds, run the <kbd>heroku open</kbd> command. Then, once the page loads in the browser, click on the <span class="packt_screen">Persons</span> link. This time, you will see a different set of data, the one which we entered in our Heroku add-on:</li>
</ol>
<pre>        [<br/>          {<br/>            "id":1,<br/>            "firstName":"Heroku First",<br/>            "lastName":"Heroku Last",<br/>            "place":"USA"<br/>          },<br/>          {<br/>            "id":2,<br/>            "firstName":"Jaws First",<br/>            "lastName":"Jaws Last",<br/>            "place":"UK"<br/>          }<br/>        ]</pre>
<p>With this, we have integrated with a database created on Heroku.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Containerizing the RESTful web service using Docker</h1>
                </header>
            
            <article>
                
<p>We have advanced a lot from the time where an app would be installed across servers to each server being virtualized and the app then being installed on these smaller virtual machines. Scalability issues for the applications were resolved by adding more virtual machines, with the app running to the load balancer.</p>
<p>In virtualization, a large server is divided into multiple virtual machines by allocating the computing power, memory, and storage among the multiple virtual machines. This way, each of the virtual machines is in itself capable of all those things that a server was, albeit on a smaller scale. This way, virtualization has helped us a lot in judiciously making use of the server's computing, memory, and storage resources. </p>
<p>However, virtualization needs some setup, that is, you need to create the virtual machine, install the required dependencies, and then run the app. Moreover, you may not be 100% sure if the app would run successfully. The reason for failure may be due to the incompatible OS versions or even due to some configuration missed while setting up or some missing dependency. This setup also leads to some difficulty in horizontal scaling because there is some time spent in the provisioning of the virtual machine and then deploying the app.</p>
<p>Using tools such as Puppet and Chef does help in provisioning, but then the setting up of the app can often result in issues that might be due to a missing or wrong configuration. This led to the introduction of another concept called containerization.</p>
<p>In the world of virtualization, we have the host OS and then a virtualization software, that is, the hypervisor. We then end up creating multiple machines, where each machine has its own OS on which apps are deployed. However, in containerization, we don't divide the resources of the server. Instead, we have the server with its host OS, and above that, we have a containerization layer which is a software abstraction layer. We package apps as containers, where a container is packaged with just enough OS functions required to run the app, the software dependencies for the app, and then the app itself. The following image taken from <a href="https://docs.docker.com/get-started/#containers-vs-virtual-machines">https://docs.docker.com/get-started/#container-diagram</a> best depicts this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="187" width="208" class="image-border" src="assets/c0758437-eabe-43d7-a5fd-51e22c3b6d35.png"/></div>
<p>The preceding image illustrates a typical architecture of virtualization systems. The following image illustrates a typical architecture of containerization systems:</p>
<div class="CDPAlignCenter CDPAlign"><img height="166" width="186" class="image-border" src="assets/838f967c-db09-46d6-9846-cc003b135e3c.png"/></div>
<p>The biggest advantage of containerization is that you bundle all the dependencies of the app into a container image. This image is then run on the containerization platform, leading to the creation of a container. We can have multiple containers running simultaneously on the server. If there is a need to add more instances, we can just deploy the image, and this deployment can be automated to support high scalability in an easy way.</p>
<p>Docker is the world's most popular software containerization platform. In this recipe, we will package our sample app found at the location into a Docker image and run the Docker image to launch our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>For this recipe, we will use a Linux server running Ubuntu 16.04.2 x64. </p>
<ol>
<li>Download the latest <kbd>.deb</kbd> file from <a href="https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/">https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/</a>. For other Linux distros, you can find the packages at <a href="https://download.docker.com/linux/">https://download.docker.com/linux/</a>:</li>
</ol>
<pre><strong>        $ wget https://download.docker.com/linux/ubuntu/dists/xenial<br/>        /pool/stable/amd64/docker-ce_17.03.2~ce-0~ubuntu-xenial_amd64.deb</strong></pre>
<ol start="2">
<li>Install the Docker package using the <kbd>dpkg</kbd> package manager:</li>
</ol>
<pre><strong>      $  sudo dpkg -i docker-ce_17.03.2~ce-0~ubuntu-xenial_amd64.deb</strong></pre>
<p style="padding-left: 60px">The name of the package will vary based on the version you have downloaded. </p>
<ol start="3">
<li>After successful installation, the Docker service starts running. You can verify this by using the <kbd>service</kbd> command:</li>
</ol>
<pre class="mce-root"><strong>      $ service docker status</strong><br/><strong>        docker.service - Docker Application Container Engine</strong><br/><strong>        Loaded: loaded (/lib/systemd/system/docker.service; enabled;<br/>        vendor preset: enabled)</strong><br/><strong>      Active: active (running) since Fri 2017-07-28 13:46:50 UTC;<br/>              2min 3s ago</strong><br/><strong>      Docs: https://docs.docker.com</strong><br/><strong>      Main PID: 22427 (dockerd)</strong></pre>
<p>The application to be dockerized is available at the location, <kbd>chp10/6_boot_with_docker</kbd>, of the source code downloaded for this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create <kbd>Dockerfile</kbd> at the root of the application with the following content:</li>
</ol>
<pre><strong>      FROM ubuntu:17.10<br/>      FROM openjdk:9-b177-jdk</strong><br/><strong>      VOLUME /tmp</strong><br/><strong>      ADD target/boot_docker-1.0.jar restapp.jar</strong><br/><strong>      ENV JAVA_OPTS="-Dspring.profiles.active=cloud"<br/>      ENTRYPOINT [ "sh", "-c", "java $JAVA_OPTS -jar /restapp.jar" ]</strong></pre>
<ol start="2">
<li>Run the following command to build a Docker image using <kbd>Dockerfile</kbd> created in the preceding step:</li>
</ol>
<pre><strong>      $ docker build --tag restapp-image .</strong><br/><br/><strong>      Sending build context to Docker daemon 18.45 MB</strong><br/><strong>      Step 1/6 : FROM ubuntu:17.10</strong><br/><strong>      ---&gt; c8cdcb3740f8</strong><br/><strong>      Step 2/6 : FROM openjdk:9-b177-jdk</strong><br/><strong>      ---&gt; 38d822ff5025</strong><br/><strong>      Step 3/6 : VOLUME /tmp</strong><br/><strong>      ---&gt; Using cache</strong><br/><strong>      ---&gt; 38367613d375</strong><br/><strong>      Step 4/6 : ADD target/boot_docker-1.0.jar restapp.jar</strong><br/><strong>      ---&gt; Using cache</strong><br/><strong>      ---&gt; 54ad359f53f7</strong><br/><strong>      Step 5/6 : ENV JAVA_OPTS "-Dspring.profiles.active=cloud"</strong><br/><strong>      ---&gt; Using cache</strong><br/><strong>      ---&gt; dfa324259fb1</strong><br/><strong>      Step 6/6 : ENTRYPOINT sh -c java $JAVA_OPTS -jar /restapp.jar</strong><br/><strong>      ---&gt; Using cache</strong><br/><strong>      ---&gt; 6af62bd40afe</strong><br/><strong>      Successfully built 6af62bd40afe</strong></pre>
<ol start="3">
<li>You can view the images installed by using the command:</li>
</ol>
<pre><strong>      $ docker images<br/><br/><br/>      REPOSITORY     TAG        IMAGE ID     CREATED     SIZE</strong><br/><strong>      restapp-image  latest     6af62bd40afe 4 hours ago 606 MB</strong><br/><strong>      openjdk        9-b177-jdk 38d822ff5025 6 days ago  588 MB</strong><br/><strong>      ubuntu         17.10      c8cdcb3740f8 8 days ago  93.9 MB</strong></pre>
<p style="padding-left: 60px">You will see that there are OpenJDK and Ubuntu images as well. These were downloaded to build the image for our app, which is listed first.</p>
<ol start="4">
<li>Now, we need to run the image to create a container that contains our running application:</li>
</ol>
<pre><strong>      docker run -p 8090:8080 -d --name restapp restapp-image</strong><br/><strong>      d521b9927cec105d8b69995ef6d917121931c1d1f0b1f4398594bd1f1fcbee55</strong></pre>
<p style="padding-left: 60px">The large string printed after the <kbd>run</kbd> command is the identifier of the container. You can use the initial few characters to uniquely identify the container. Alternatively, you can use the container name, <kbd>restapp</kbd>.</p>
<ol start="5">
<li>The app will have already started. You can view the logs by running the following command:</li>
</ol>
<pre><strong>      docker logs restapp</strong></pre>
<ol start="6">
<li>You can view the Docker containers created by using the following command:</li>
</ol>
<pre><strong>      docker ps</strong></pre>
<p style="padding-left: 60px">The output for the above command looks similar to as shown below:</p>
<div class="CDPAlignCenter CDPAlign"><img height="41" width="1251" class="image-border" src="assets/630227a1-3af6-4221-9225-daca31800a1d.png"/></div>
<ol start="7">
<li>You can manage the container by using the following command:</li>
</ol>
<pre><strong>      $ docker stop restapp</strong><br/><strong>      $ docker start restapp</strong></pre>
<p>Once the app is running, open <kbd>http://&lt;hostname&gt;:8090/api/persons</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You define the container structure and its contents by defining <kbd>Dockerfile</kbd>. <kbd>Dockerfile</kbd> follows a structure, where each line is of the form, <kbd>INSTRUCTION arguments</kbd>. There is a predefined set of instructions, namely <kbd>FROM</kbd>, <kbd>RUN</kbd>, <kbd>CMD</kbd>, <kbd>LABEL</kbd>, <kbd>ENV</kbd>, <kbd>ADD</kbd>, <kbd>COPY</kbd>, and others. A complete list can be found at <a href="https://docs.docker.com/engine/reference/builder/#from">https://docs.docker.com/engine/reference/builder/#from</a>. Let's look at our defined <kbd>Dockerfile</kbd>:</p>
<pre><strong>FROM ubuntu:17.10<br/>FROM openjdk:9-b177-jdk</strong><br/><strong>VOLUME /tmp</strong><br/><strong>ADD target/boot_docker-1.0.jar restapp.jar</strong><br/><strong>ENV JAVA_OPTS="-Dspring.profiles.active=cloud"<br/>ENTRYPOINT [ "sh", "-c", "java $JAVA_OPTS -jar /restapp.jar" ]</strong></pre>
<p>The first two lines using the <kbd>FROM</kbd> instruction specified the base image for our Docker image. We use the Ubuntu OS image as the base image and then combine it with the OpenJDK 9 image. The <kbd>VOLUME</kbd> instruction is used to specify the mount point for the image. This is usually a path in the host OS. </p>
<p>The <kbd>ADD</kbd> instruction is used to copy the file from the source to the destination directory under the working directory. The <kbd>ENV</kbd> instruction is used for defining the environment variables. </p>
<p>The <span><kbd>ENTRYPOINT</kbd> instruction is used to configure the container to run as an executable. For this instruction, we pass an array of arguments, which we would otherwise have executed directly from the command line. In our scenario, we are using the bash shell to run <kbd>java -$JAVA_OPTS -jar &lt;jar name&gt;</kbd></span>.</p>
<p><span>Once we have defined <kbd>Dockerfile</kbd>, we instruct the Docker tool to build an image using <kbd>Dockerfile</kbd>. We also provide a name for the image using the <kbd>--tag</kbd> option. When building our app image, it will download the required based images, which, in our case, are Ubuntu and OpenJDK images. So, if you list the Docker images, then you will see the base images along with our app image. </span></p>
<p>This Docker image is a reusable entity. If we need more instances of the app, we spawn a new container using the <kbd>docker run</kbd> command. When we run the Docker image, we have multiple options, where one of them is a <kbd>-p</kbd> option, which maps the ports from within the container to the host OS. In our case, we map the <kbd>8080</kbd> port of our Spring Boot app to <kbd>8090</kbd> of the host OS. </p>
<p>Now, to check the status of our running app, we can check the logs using <kbd>docker logs restapp</kbd>. Apart from this, the <kbd>docker</kbd> tool supports multiple commands. It's highly recommended to run <kbd>docker help</kbd> and explore the commands supported. </p>
<p>Docker, the company behind Docker has created a set of base images, which can be used to create containers. For example, there are images for MySQL DB, Couchbase, Ubuntu, and other operating systems. You can explore the packages at <a href="https://store.docker.com/">https://store.docker.com/</a>.</p>


            </article>

            
        </section>
    </body></html>