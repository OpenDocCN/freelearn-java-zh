<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Parallel and Reactive Streams</h1>
            

            <article>
                
<p class="calibre4">In this chapter, we will cover the following recipes:</p>
<ul class="calibre17">
<li class="calibre18">Creating streams from different sources</li>
<li class="calibre18">Reducing the elements of a stream</li>
<li class="calibre18">Collecting the elements of a stream</li>
<li class="calibre18">Applying an action to every element of a stream</li>
<li class="calibre18">Filtering the elements of a stream</li>
<li class="calibre18">Transforming the elements of a stream</li>
<li class="calibre18">Sorting the elements of a stream</li>
<li class="calibre18">Verifying conditions in the elements of a stream</li>
<li class="calibre18">Reactive programming with reactive streams</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Introduction</h1>
            

            <article>
                
<p class="calibre4">A <strong class="calibre1">stream</strong> in <span>Java </span><span>is a sequence of elements that can be processed (mapped, filtered, transformed, reduced, and collected) in a pipeline of declarative operations using</span> <strong class="calibre1">lambda expressions</strong> <span>in a sequential or parallel way. It was introduced in </span>Java 8 and was one of the most significant new features of that version, together with lambda expressions. They have changed the way you can process big sets of elements in Java, optimizing the way the language processes those elements.</p>
<p class="calibre4">Streams <span>have</span> introduced the <kbd class="calibre15">Stream</kbd>, <kbd class="calibre15">DoubleStream</kbd>, <kbd class="calibre15">IntStream</kbd> and <kbd class="calibre15">LongStream</kbd> interfaces, some utility classes such as <kbd class="calibre15">Collectors</kbd> or <kbd class="calibre15">StreamSupport</kbd>, some functional-like interfaces such as <kbd class="calibre15">Collector</kbd>, and a lot of methods in different classes such as the <kbd class="calibre15">stream()</kbd> or <kbd class="calibre15">parallelStream()</kbd> methods in the <kbd class="calibre15">Collection</kbd> interface or the <kbd class="calibre15">lines()</kbd> method in the <kbd class="calibre15">Files</kbd> class.</p>
<p class="calibre4">Through the recipes of this chapter, you will learn how to effectively use streams in your application, but before that let's see the most important <span>characteristics</span> of streams:</p>
<ul class="calibre17">
<li class="calibre18">A stream is a sequence of data, not a data structure. Elements of data are processed by the stream but not stored in it.</li>
<li class="calibre18">You can create streams from different sources, such as collections (lists, arrays and so on), files, and strings, or by creating a class that provides the elements of the stream.</li>
<li class="calibre18">You can't access an individual element of the streams. You define the source of the stream and the operations you want to apply to its elements. Stream operations are defined in a functional way, and you can use lambda expressions in intermediate and terminal operations to define the actions you want to execute.</li>
<li class="calibre18">You can't modify the source of the stream. If, for example, you filter some elements of the stream, you are skipping the elements on the stream and not in its source.</li>
<li class="calibre18">Streams define two kinds of operations:</li>
</ul>
<div class="calibre26">
<ul class="calibre17">
<li class="calibre18"><strong class="calibre1">Intermediate operations</strong>: These operations always produce a new stream with their results. They can be used to transform, filter, and sort the elements of the stream.</li>
<li class="calibre18"><strong class="calibre1">Terminal operations</strong>: These operations process all the elements of the stream to generate a result or a side-effect. After their execution, the stream can't be used again.</li>
</ul>
</div>
<ul class="calibre17">
<li class="calibre18">A stream pipeline is formed by zero or more <span>intermediate</span> operations and a final operation.</li>
<li class="calibre18">Intermediate operations can be as follows:</li>
</ul>
<div class="calibre27">
<ul class="calibre17">
<li class="calibre18"><strong class="calibre1">Stateless</strong>: Processing an element of the stream is independent of the other elements. For example, filtering an element based on a condition.</li>
<li class="calibre18"><strong class="calibre1">Stateful</strong>: Processing an element of the <span>stream</span> depends on the other elements of the stream. For example, sorting the elements of the stream. </li>
</ul>
</div>
<ul class="calibre17">
<li class="calibre18"><strong class="calibre1">Laziness</strong>: Intermediate <span>operations</span> are lazy. They're not executed until the terminal operation begins its execution. Java can avoid the execution of an intermediate operation over an element or a set of elements of the stream if it detects that it doesn't affect the final result of the operation.</li>
<li class="calibre18"><kbd class="calibre15">Stream</kbd> can have an infinite number of elements. There are operations such as <kbd class="calibre15">limit()</kbd> or <kbd class="calibre15">findFirst()</kbd> that can be used to limit the elements used in the final computation. As the intermediate operations are lazy, an unbounded stream can finish its execution in a finite time.</li>
<li class="calibre18">Streams can only be used once. As we mentioned before, when the terminal operation of a stream is executed, the stream is considered consumed, and it can't be used again. If you need to process the same data again to generate different results, you have to create a new <kbd class="calibre15">Stream</kbd> object from the same source. If you try to use a consumed stream, you will get an exception.</li>
<li class="calibre18">You can process the elements of a stream sequentially or in a parallel way without any extra effort. You can specify the mode of execution of a stream more than once, but only the last time will be taken into account. You have to be careful with the selected mode. Stateful intermediate operations won't use all the possibilities of concurrency.</li>
</ul>
<p class="calibre4">Java 9 has included a new kind of streams-the reactive streams-that allow you to communicate information to producers and consumers in an asynchronous way. This chapter presents nine recipes that will teach you how to create streams and use all their intermediate and terminal operations to process big collections of data in a parallel and functional way.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Creating streams from different sources</h1>
            

            <article>
                
<p class="calibre4">In this recipe, you will learn how to create streams from different sources. You have different options, as the following:</p>
<ul class="calibre17">
<li class="calibre18">The <kbd class="calibre15">parallelStream()</kbd> method of the <kbd class="calibre15">Collection</kbd> interface</li>
<li class="calibre18">The <kbd class="calibre15">Supplier</kbd> interface</li>
<li class="calibre18">A predefined set of elements</li>
<li class="calibre18"><kbd class="calibre15">File</kbd> and a directory</li>
<li class="calibre18">An array</li>
<li class="calibre18">A random number generator</li>
<li class="calibre18">The concatenation of two different streams</li>
</ul>
<p class="calibre4">You can create a <kbd class="calibre15">Stream</kbd> object from other sources (that will be described in the <em class="calibre14">There's more</em> section), but we think that these are the more useful.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">In this recipe we'll implement an example where you will learn how to create streams from the sources described earlier. Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">First, we'll implement some auxiliary classes that we will use in the example. Create a class named <kbd class="calibre15">Person</kbd> with six attributes of different types: <kbd class="calibre15">String</kbd>, <kbd class="calibre15">int</kbd>, <kbd class="calibre15">double</kbd> and <kbd class="calibre15">Date</kbd>:</li>
</ol>
<pre class="calibre23">
        public class Person implements Comparable&lt;Person&gt; { <br class="title-page-name"/> <br class="title-page-name"/>          private int id; <br class="title-page-name"/>          private String firstName; <br class="title-page-name"/>          private String lastName; <br class="title-page-name"/>          private Date birthDate; <br class="title-page-name"/>          private int salary; <br class="title-page-name"/>          private double coeficient;
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Create the methods to set and get the values of these attributes. Implement the <kbd class="calibre15">comparteTo()</kbd> method to compare two <kbd class="calibre15">Person</kbd> objects. Let's consider that two persons are the same it they have the same <kbd class="calibre15">firstName</kbd> and the same <kbd class="calibre15">lastName</kbd></li>
</ol>
<pre class="calibre23">
          public int compareTo(Person otherPerson) { <br class="title-page-name"/>            int compareLastNames = this.getLastName().compareTo<br class="title-page-name"/>                                        (otherPerson.getLastName()); <br class="title-page-name"/>            if (compareLastNames != 0) { <br class="title-page-name"/>              return compareLastNames; <br class="title-page-name"/>            } else { <br class="title-page-name"/>            return this.getFirstName().compareTo<br class="title-page-name"/>                                        (otherPerson.getFirstName()); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Then, create a class named <kbd class="calibre15">PersonGenerator</kbd> to create a random list of <kbd class="calibre15">Person</kbd> objects. Implement a static method named <kbd class="calibre15">generatePersonList()</kbd> in this class , which receives the number of persons you want to generate and returns a <kbd class="calibre15">List&lt;Person&gt;</kbd> object with the number of persons. Here, we include a version of this method, but feel free to change it:</li>
</ol>
<pre class="calibre23">
        public class PersonGenerator { <br class="title-page-name"/> <br class="title-page-name"/>          public static List&lt;Person&gt; generatePersonList (int size) { <br class="title-page-name"/>            List&lt;Person&gt; ret = new ArrayList&lt;&gt;(); <br class="title-page-name"/>          <br class="title-page-name"/>            String firstNames[] = {"Mary","Patricia","Linda",<br class="title-page-name"/>                                   "Barbara","Elizabeth","James",<br class="title-page-name"/>                                   "John","Robert","Michael",<br class="title-page-name"/>                                   "William"}; <br class="title-page-name"/>            String lastNames[] = {"Smith","Jones","Taylor",<br class="title-page-name"/>                                  "Williams","Brown","Davies",<br class="title-page-name"/>                                  "Evans","Wilson","Thomas",<br class="title-page-name"/>                                  "Roberts"}; <br class="title-page-name"/>          <br class="title-page-name"/>            Random randomGenerator=new Random(); <br class="title-page-name"/>            for (int i=0; i&lt;size; i++) { <br class="title-page-name"/>              Person person=new Person(); <br class="title-page-name"/>              person.setId(i); <br class="title-page-name"/>              person.setFirstName(firstNames[randomGenerator<br class="title-page-name"/>                                             .nextInt(10)]); <br class="title-page-name"/>              person.setLastName(lastNames[randomGenerator<br class="title-page-name"/>                                           .nextInt(10)]); <br class="title-page-name"/>              person.setSalary(randomGenerator.nextInt(100000)); <br class="title-page-name"/>              person.setCoeficient(randomGenerator.nextDouble()*10); <br class="title-page-name"/>              Calendar calendar=Calendar.getInstance(); <br class="title-page-name"/>              calendar.add(Calendar.YEAR, -randomGenerator<br class="title-page-name"/>                                                 .nextInt(30)); <br class="title-page-name"/>              Date birthDate=calendar.getTime(); <br class="title-page-name"/>              person.setBirthDate(birthDate); <br class="title-page-name"/>              ret.add(person); <br class="title-page-name"/>            } <br class="title-page-name"/>            return ret; <br class="title-page-name"/>          }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Now, create a class named <kbd class="calibre15">MySupplier</kbd> and specify that it implements the <kbd class="calibre15">Supplier</kbd> interface parameterized with the <kbd class="calibre15">String</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class MySupplier implements Supplier&lt;String&gt; {
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Declare a private <kbd class="calibre15">AtomicInteger</kbd> attribute named <kbd class="calibre15">counter</kbd> and initialize it in the constructor of the class:</li>
</ol>
<pre class="calibre23">
        private final AtomicInteger counter; <br class="title-page-name"/>        public MySupplier() { <br class="title-page-name"/>          counter=new AtomicInteger(0); <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Implement the <kbd class="calibre15">get()</kbd> method defined in the <kbd class="calibre15">Supplier</kbd> interface. This method will return the next element of the stream:</li>
</ol>
<pre class="calibre23">
          @Override <br class="title-page-name"/>          public String get() { <br class="title-page-name"/>            int value=counter.getAndAdd(1); <br class="title-page-name"/>            return "String "+value; <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Now, create a class named <kbd class="calibre15">Main</kbd> and implement the <kbd class="calibre15">main()</kbd> method in it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">First, we'll create a <kbd class="calibre15">Stream</kbd> object from a list of elements. Create the <kbd class="calibre15">PersonGenerator</kbd> class to create a list of 10,000 <kbd class="calibre15">Person</kbd> objects, and use the <kbd class="calibre15">parallelStream()</kbd> method of the <kbd class="calibre15">List</kbd> object to create the <kbd class="calibre15">Stream</kbd>. Then, use the <kbd class="calibre15">count()</kbd> method of the <kbd class="calibre15">Stream</kbd> object to get the number of elements of the <kbd class="calibre15">Stream</kbd>:</li>
</ol>
<pre class="calibre23">
        System.out.printf("From a Collection:\n"); <br class="title-page-name"/>        List&lt;Person&gt; persons=PersonGenerator.generatePersonList(10000); <br class="title-page-name"/>        Stream&lt;Person&gt; personStream=persons.parallelStream();        <br class="title-page-name"/>        System.out.printf("Number of persons: %d\n",<br class="title-page-name"/>                          personStream.count());
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Then, we'll create a <kbd class="calibre15">Stream</kbd> from a generator. Create an object of the <kbd class="calibre15">MySupplier</kbd> class. Then, use the static method <kbd class="calibre15">generate()</kbd> of the <kbd class="calibre15">Stream</kbd> class, passing the created object as a parameter to create the stream. Finally, use the <kbd class="calibre15">parallel()</kbd> method to convert the stream created to a parallel stream, the <kbd class="calibre15">limit()</kbd> method to get the first ten elements of the stream, and the <kbd class="calibre15">forEach()</kbd> method to print the elements of the stream:</li>
</ol>
<pre class="calibre23">
        System.out.printf("From a Supplier:\n"); <br class="title-page-name"/>        Supplier&lt;String&gt; supplier=new MySupplier(); <br class="title-page-name"/>        Stream&lt;String&gt; generatorStream=Stream.generate(supplier); <br class="title-page-name"/>        generatorStream.parallel().limit(10).forEach(s-&gt;<br class="title-page-name"/>                                           System.out.printf("%s\n",s));
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Then, we'll create a stream from a predefined list of elements. Use the static <kbd class="calibre15">of()</kbd> method of the <kbd class="calibre15">Stream</kbd> class to create the <kbd class="calibre15">Stream</kbd>. This method receives a variable list of parameters. In this case, we'll pass three <kbd class="calibre15">String</kbd> objects. Then, use the <kbd class="calibre15">parallel()</kbd> method of the stream to convert it to a parallel one and the <kbd class="calibre15">forEach()</kbd> method to print the values in the console:</li>
</ol>
<pre class="calibre23">
        System.out.printf("From a predefined set of elements:\n"); <br class="title-page-name"/>        Stream&lt;String&gt; elementsStream=Stream.of("Peter","John","Mary"); <br class="title-page-name"/>        elementsStream.parallel().forEach(element -&gt;<br class="title-page-name"/>                                    System.out.printf("%s\n", element));
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Now, we'll create a stream to read the lines of a file. First, create a <kbd class="calibre15">BufferedReader</kbd> object to read the file you want to read. Then, use the <kbd class="calibre15">lines()</kbd> method of the <kbd class="calibre15">BufferedReader</kbd> class to get a stream of <kbd class="calibre15">String</kbd> objects. Each element of this stream will be a line from the file. Finally, use the <kbd class="calibre15">parallel()</kbd> method to get a parallel version of the stream and the <kbd class="calibre15">count()</kbd> method to get the number of elements of the <kbd class="calibre15">Stream</kbd>. We also have to close the <kbd class="calibre15">BufferedReader</kbd> object:</li>
</ol>
<pre class="calibre23">
        System.out.printf("From a File:\n"); <br class="title-page-name"/>        try (BufferedReader br = new BufferedReader(new<br class="title-page-name"/>                                 FileReader("data\\nursery.data"));) {                                    Stream&lt;String&gt; fileLines = br.lines(); <br class="title-page-name"/>          System.out.printf("Number of lines in the file: %d\n\n",<br class="title-page-name"/>                            fileLines.parallel().count()); <br class="title-page-name"/>          System.out.printf("********************************<br class="title-page-name"/>                             ************************\n"); <br class="title-page-name"/>          System.out.printf("\n"); <br class="title-page-name"/>          br.close(); <br class="title-page-name"/>        } catch (FileNotFoundException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } catch (IOException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Now, we'll create a <kbd class="calibre15">Stream</kbd> to process the contents of a folder. First, use the <kbd class="calibre15">list()</kbd> method of the <kbd class="calibre15">Files</kbd> class to get a stream of <kbd class="calibre15">Path</kbd> objects with the contents of the folder. Then, use the <kbd class="calibre15">parallel()</kbd> method of the <kbd class="calibre15">Stream</kbd> object to convert it to a parallel stream and the <kbd class="calibre15">count()</kbd> method to count its elements. Finally, in this case, we have to use the <kbd class="calibre15">close()</kbd> method to close the Stream:</li>
</ol>
<pre class="calibre23">
        System.out.printf("From a Directory:\n"); <br class="title-page-name"/>        try { <br class="title-page-name"/>          Stream&lt;Path&gt; directoryContent = Files.list(Paths.get<br class="title-page-name"/>                                    (System.getProperty("user.home"))); <br class="title-page-name"/>          System.out.printf("Number of elements (files and<br class="title-page-name"/>                             folders):%d\n\n",<br class="title-page-name"/>                            directoryContent.parallel().count()); <br class="title-page-name"/>          directoryContent.close(); <br class="title-page-name"/>          System.out.printf("********************************<br class="title-page-name"/>                             ************************\n"); <br class="title-page-name"/>          System.out.printf("\n"); <br class="title-page-name"/>        } catch (IOException e) { <br class="title-page-name"/>          e.printStackTrace();<br class="title-page-name"/>        }
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">The next source we'll use is an <kbd class="calibre15">Array</kbd>. First, create an <kbd class="calibre15">Array</kbd> of strings. Then, use the <kbd class="calibre15">stream()</kbd> method of the <kbd class="calibre15">Arrays</kbd> class to create a stream from the elements of the array. Finally, use the <kbd class="calibre15">parallel()</kbd> method to convert the stream into a parallel one and the <kbd class="calibre15">forEach()</kbd> method to print the elements of the stream to the console:</li>
</ol>
<pre class="calibre23">
        System.out.printf("From an Array:\n"); <br class="title-page-name"/>        String array[]={"1","2","3","4","5"}; <br class="title-page-name"/>        Stream&lt;String&gt; streamFromArray=Arrays.stream(array); <br class="title-page-name"/>        streamFromArray.parallel().forEach(s-&gt;System.out.printf("%s : ",<br class="title-page-name"/>                                                                s));
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Now, we'll create a stream of random double numbers. First, create a <kbd class="calibre15">Random</kbd> object. Then, use the <kbd class="calibre15">doubles()</kbd> method to create a <kbd class="calibre15">DoubleStream</kbd> object. We'll pass the number <kbd class="calibre15">10</kbd> as a parameter to that method, so the stream we're going to create will have ten elements. Finally, use the <kbd class="calibre15">parallel()</kbd> method to convert the stream into a parallel one, the <kbd class="calibre15">peek()</kbd> method to write each element to the console, the <kbd class="calibre15">average()</kbd> method to calculate the average of the values of the stream, and the <kbd class="calibre15">getAsDouble()</kbd> method to get the value stored in the <kbd class="calibre15">Optional</kbd> object returned by the <kbd class="calibre15">average()</kbd> method:</li>
</ol>
<pre class="calibre23">
        Random random = new Random(); <br class="title-page-name"/>        DoubleStream doubleStream = random.doubles(10); <br class="title-page-name"/>        double doubleStreamAverage = doubleStream.parallel().peek<br class="title-page-name"/>                                     (d -&gt; System.out.printf("%f :",d))<br class="title-page-name"/>                                     .average().getAsDouble();
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Finally, we'll create a stream concatenating two streams. First, we create two streams of <kbd class="calibre15">String</kbd> objects using the <kbd class="calibre15">of()</kbd> method of the <kbd class="calibre15">Stream</kbd> class. Then, we use the <kbd class="calibre15">concat()</kbd> method of the <kbd class="calibre15">Stream</kbd> class to concatenate those streams into a unique one. Finally, we use the <kbd class="calibre15">parallel()</kbd> method of the <kbd class="calibre15">Stream</kbd> class to convert the stream into a parallel one and the <kbd class="calibre15">forEach()</kbd> method to write all the elements to the console:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Concatenating streams:\n"); <br class="title-page-name"/>        Stream&lt;String&gt; stream1 = Stream.of("1", "2", "3", "4"); <br class="title-page-name"/>        Stream&lt;String&gt; stream2 = Stream.of("5", "6", "7", "8"); <br class="title-page-name"/>        Stream&lt;String&gt; finalStream = Stream.concat(stream1, stream2); <br class="title-page-name"/>        finalStream.parallel().forEach(s -&gt; System.out.printf("%s : ",<br class="title-page-name"/>                                                              s));
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">Let's see in detail all the methods we used in this example to create streams:</p>
<ul class="calibre17">
<li class="calibre18">First, we used the <kbd class="calibre15">parallelStream()</kbd> method of the <kbd class="calibre15">List</kbd> class. In fact, this method is defined in the <kbd class="calibre15">Collection</kbd> interface, so all the classes that implement this interface, such as the <kbd class="calibre15">ArrayList</kbd>, <kbd class="calibre15">LinkedList</kbd>, or <kbd class="calibre15">TreeSet</kbd> classes implement that method. You can use the <kbd class="calibre15">stream()</kbd> method to create a sequential stream or the <kbd class="calibre15">parallelStream()</kbd> method to create a parallel one.</li>
<li class="calibre18">Then, we used an implementation of the <kbd class="calibre15">Supplier</kbd> interface: the <kbd class="calibre15">MySupplier</kbd> class. The interface provides the <kbd class="calibre15">get()</kbd> method. This method is called each time the stream needs an element to process. You can create a stream with an infinite number of elements, so you should use a method that limits the number of elements of the stream, such as the <kbd class="calibre15">limit()</kbd> method.</li>
<li class="calibre18">Then, we used the <kbd class="calibre15">of()</kbd>method of the <kbd class="calibre15">Stream</kbd> class. This is a static method that receives a variable number of parameters and returns a <kbd class="calibre15">Stream</kbd> with those parameters as elements.</li>
<li class="calibre18">Then, we used the <kbd class="calibre15">lines()</kbd> method of the <kbd class="calibre15">BufferedStream</kbd> class. This method returns a stream where each element is a line read from the <kbd class="calibre15">BufferedStream</kbd>. We used this method to read all the lines of a file, but you can use it with other kinds of <kbd class="calibre15">BufferedReader</kbd>.</li>
<li class="calibre18">Then, we used the <kbd class="calibre15">list()</kbd> method of the <kbd class="calibre15">Files</kbd> class. This method receives a <kbd class="calibre15">Path</kbd> object representing a folder of your system and returns a <kbd class="calibre15">Stream</kbd> of <kbd class="calibre15">Path</kbd> objects with the elements into that folder. You have to take into account that this method is not recursive, so if the folder has one or more subfolders, it doesn't process their content. As you will see later in the <em class="calibre14">There's more</em> section, the <kbd class="calibre15">Files</kbd> class has other methods to work with streams.</li>
<li class="calibre18">Then, we used the <kbd class="calibre15">stream()</kbd> method of the <kbd class="calibre15">Arrays</kbd> class that receives an array and returns a <kbd class="calibre15">Stream</kbd> with the elements of the array. If the array is of the <kbd class="calibre15">double</kbd>, <kbd class="calibre15">int</kbd>, or <kbd class="calibre15">long</kbd> types, it returns a <kbd class="calibre15">DoubleStream</kbd>, <kbd class="calibre15">IntStream</kbd>, or <kbd class="calibre15">LongStream</kbd> object. These are special kinds of streams that allow you to work with such number types.</li>
<li class="calibre18">Then, we generated a stream with random numbers. We used the <kbd class="calibre15">doubles()</kbd> method of the <kbd class="calibre15">Random</kbd> class. We passed to it the size of the <kbd class="calibre15">Stream</kbd> we wanted to obtain, but you can also pass to it the minimum and maximum numbers you want to obtain.</li>
<li class="calibre18">Finally, we used the <kbd class="calibre15">concat()</kbd> method of the <kbd class="calibre15">Stream</kbd> class that takes two streams and returns one with the elements of both.</li>
</ul>
<p class="calibre4">We also used some methods of the <kbd class="calibre15">Stream</kbd> class. Most of them will be described later in more detail, but here we provide a basic introduction to them:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">count()</kbd>: This method returns the number of elements in the <kbd class="calibre15">Stream</kbd>. It's a terminal operation and returns a <kbd class="calibre15">long</kbd> number.</li>
<li class="calibre18"><kbd class="calibre15">limit()</kbd>: This method receives a number as a parameter. If the stream has fewer elements than the number, it returns a stream with all the elements. Otherwise, it returns a stream with the number of elements specified in the parameter. It's an intermediate operation.</li>
<li class="calibre18"><kbd class="calibre15">forEach()</kbd>: This method allows you to specify an action that will be applied to each of the elements of the <kbd class="calibre15">Stream</kbd>. We used this terminal operation to write some information to the console. We have used a lambda expression with this purpose.</li>
<li class="calibre18"><kbd class="calibre15">peek()</kbd>: This method is an intermediate operation that allows you to perform an action over each of the elements of the stream and returns a stream with the same elements. This method is usually used as a debugging tool. Take into account that, like all intermediate operations, this is a lazy operation, so it will only be executed over those elements that are requested by the terminal operation.</li>
<li class="calibre18"><kbd class="calibre15">average()</kbd>: This is a method that is declared in the <kbd class="calibre15">IntStream</kbd>, <kbd class="calibre15">DoubleStream</kbd>, and <kbd class="calibre15">LongStream</kbd> streams. It returns an <kbd class="calibre15">OptionalDouble</kbd> value. The <kbd class="calibre15">OptionalDouble</kbd> class represents a double number that can have a value or not. It won't generate a value for an empty <kbd class="calibre15">Stream</kbd>.</li>
<li class="calibre18"><kbd class="calibre15">parallel()</kbd>: This method converts a sequential <kbd class="calibre15">Stream</kbd> into a parallel one. Most of the streams created in this example are sequential, but we can convert them into parallel ones using this method of the <kbd class="calibre15">Stream</kbd> class.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The Java API includes other methods to create <kbd class="calibre15">Stream</kbd> objects. In this section, we enumerate some of them:</p>
<ul class="calibre17">
<li class="calibre18">The <kbd class="calibre15">Files</kbd> class provides more methods that create streams:
<ul class="calibre24">
<li class="calibre18"><kbd class="calibre15">find()</kbd>: This method returns the files contained in a folder, or in any of its subfolders, which meet the criteria specified in a lambda expression.</li>
<li class="calibre18"><kbd class="calibre15">walk()</kbd>: This method returns a stream of <kbd class="calibre15">Path</kbd> objects with the contents of a folder and all its subfolders.</li>
</ul>
</li>
<li class="calibre18">The <kbd class="calibre15">Stream</kbd> class also includes other static methods that allow you to create streams:
<ul class="calibre24">
<li class="calibre18"><kbd class="calibre15">iterate()</kbd>: This method produces a stream whose elements are generated by the application of a unary function to an initial element. The first element of the stream is the initial element, the second element, the result of applying the function to the initial element, the third, the result of applying the function to the second element, and so on.</li>
</ul>
</li>
<li class="calibre18">Finally, the <kbd class="calibre15">String</kbd> class has the <kbd class="calibre15">chars()</kbd> method. This method returns an <kbd class="calibre15">IntStream</kbd> with the values of the characters that forms the <kbd class="calibre15">String</kbd>.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<p class="calibre4">Now that you have created a stream, you have to process its elements. All the recipes in this chapter give you information about how to go about processing the elements of a stream.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Reducing the elements of a stream</h1>
            

            <article>
                
<p class="calibre4"><strong class="calibre1">MapReduce</strong> is a programming model used to process very large datasets in distributed environments using a lot of machines working in a cluster. This programming model has the following two operations:</p>
<ul class="calibre17">
<li class="calibre18"><strong class="calibre1">Map</strong>: This operation filters and transforms the original elements into a form more suitable to the reduction operation</li>
<li class="calibre18"><strong class="calibre1">Reduce</strong>: This operation generates a summary result from all the elements, for example, the sum or the average of numeric values</li>
</ul>
<p class="calibre4">This programming model has been commonly used in the functional <span>programming</span> world. In the Java ecosystem, the <strong class="calibre1">Hadoop</strong> project of the <strong class="calibre1">Apache Software Foundation</strong> provides an implementation of <span>this</span> model. The <kbd class="calibre15">Stream</kbd> class implements two different reduce operations:</p>
<ul class="calibre17">
<li class="calibre18">The pure reduce operation, implemented in the different versions of the <kbd class="calibre15">reduce()</kbd> method that process a stream of elements to obtain a value</li>
<li class="calibre18">The mutable reduction implemented in the different versions of the <kbd class="calibre15">collect()</kbd> method that process a stream of elements to generate a mutable data structure, such as <kbd class="calibre15">Collection</kbd> or a <kbd class="calibre15">StringBuilder</kbd>.</li>
</ul>
<p class="calibre4">In this recipe, you will learn how to use the different versions of the <kbd class="calibre15">reduce()</kbd> method to generate a result from a stream of values. As you may have already imagined, the <kbd class="calibre15">reduce()</kbd> method is a terminal operation in a <kbd class="calibre15">Stream</kbd>.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">First, we'll create some auxiliary classes that we will use later in the example. Review the recipe, <em class="calibre14">Creating streams from different sources</em>, and include in this example the <kbd class="calibre15">Person</kbd> and <kbd class="calibre15">PersonGenerator</kbd> classes used in it.</li>
<li value="2" class="calibre18">Then, create a class named <kbd class="calibre15">DoubleGenerator</kbd>. Implement a method named <kbd class="calibre15">generateDoubleList()</kbd> to generate a list of double numbers. It receives two parameters with the size of the list we'll generate and the highest value in the list. It will generate a list of random double numbers:</li>
</ol>
<pre class="calibre23">
        public class DoubleGenerator { <br class="title-page-name"/> <br class="title-page-name"/>          public static List&lt;Double&gt; generateDoubleList(int size,<br class="title-page-name"/>                                                        int max) { <br class="title-page-name"/>            Random random=new Random(); <br class="title-page-name"/>            List&lt;Double&gt; numbers=new ArrayList&lt;&gt;(); <br class="title-page-name"/>          <br class="title-page-name"/>            for (int i=0; i&lt;size; i++) { <br class="title-page-name"/>              double value=random.nextDouble()*max; <br class="title-page-name"/>              numbers.add(value); <br class="title-page-name"/>            } <br class="title-page-name"/>            return numbers; <br class="title-page-name"/>          }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement a method named <kbd class="calibre15">generateStreamFromList()</kbd>. This method receives a <kbd class="calibre15">List</kbd> of <kbd class="calibre15">double</kbd> numbers as a parameter and generates a <kbd class="calibre15">DoubleStream</kbd> stream with the elements of the list. For that purpose, we will use the <kbd class="calibre15">DoubleStream.Builder</kbd> class to construct the stream:</li>
</ol>
<pre class="calibre23">
        public static DoubleStream generateStreamFromList(List&lt;Double&gt;<br class="title-page-name"/>                                                          list) { <br class="title-page-name"/>          DoubleStream.Builder builder=DoubleStream.builder(); <br class="title-page-name"/>          <br class="title-page-name"/>          for (Double number : list) { <br class="title-page-name"/>            builder.add(number); <br class="title-page-name"/>          } <br class="title-page-name"/>          return builder.build(); <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Create a class named <kbd class="calibre15">Point</kbd> with two double attributes, <kbd class="calibre15">x</kbd> and <kbd class="calibre15">y</kbd>, and the methods to <kbd class="calibre15">get()</kbd> and <kbd class="calibre15">set()</kbd> its value. The code of this class is very simple, so it won't be included.</li>
</ol>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Create a class named <kbd class="calibre15">PointGenerator</kbd> with a method named <kbd class="calibre15">generatePointList()</kbd>. This method receives the size of the list you want to generate and returns a list of random <kbd class="calibre15">Point</kbd> objects:</li>
</ol>
<pre class="calibre23">
        public class PointGenerator { <br class="title-page-name"/>          public static List&lt;Point&gt; generatePointList (int size) {<br class="title-page-name"/>         <br class="title-page-name"/>            List&lt;Point&gt; ret = new ArrayList&lt;&gt;(); <br class="title-page-name"/>            Random randomGenerator=new Random(); <br class="title-page-name"/>            for (int i=0; i&lt;size; i++) { <br class="title-page-name"/>              Point point=new Point(); <br class="title-page-name"/>              point.setX(randomGenerator.nextDouble()); <br class="title-page-name"/>              point.setY(randomGenerator.nextDouble()); <br class="title-page-name"/>              ret.add(point); <br class="title-page-name"/>            } <br class="title-page-name"/>            return ret; <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Now create the <kbd class="calibre15">Main</kbd> class with the <kbd class="calibre15">main()</kbd> method. First, we'll generate a <kbd class="calibre15">List</kbd> of 10,000 double numbers using the <kbd class="calibre15">DoubleGenerator</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String args[]) { <br class="title-page-name"/>                      <br class="title-page-name"/>            List&lt;Double&gt; numbers = DoubleGenerator.generateDoubleList<br class="title-page-name"/>                                                        (10000, 1000);
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">The <kbd class="calibre15">Stream</kbd> class and the specialized <kbd class="calibre15">DoubleStream</kbd>, <kbd class="calibre15">IntStream</kbd>, and <kbd class="calibre15">LongStream</kbd> classes implement some methods that are specialized reduce operations. In this case, we'll generate a <kbd class="calibre15">DoubleStream</kbd> using the <kbd class="calibre15">DoubleGenerator</kbd> class and use <kbd class="calibre15">count()</kbd>, <kbd class="calibre15">sum()</kbd>, <kbd class="calibre15">average()</kbd>, <kbd class="calibre15">max()</kbd> and <kbd class="calibre15">min()</kbd> to obtain the number of elements, the sum of all the elements, the average of all the elements, the maximum number in the stream, and the minimum number in the stream. As we can only process the elements of a stream once, we have to create a new stream per operation. Take into account that these methods are only present in the <kbd class="calibre15">DoubleStream</kbd>, <kbd class="calibre15">IntStream</kbd>, and <kbd class="calibre15">LongStream</kbd> classes. The <kbd class="calibre15">Stream</kbd> class only has the <kbd class="calibre15">count()</kbd> method. Some of these methods return an optional object. Take into account this object could not have any value, so you should check before obtaining the value:</li>
</ol>
<pre class="calibre23">
        DoubleStream doubleStream = DoubleGenerator<br class="title-page-name"/>                                      .generateStreamFromList(numbers); <br class="title-page-name"/>        long numberOfElements = doubleStream.parallel().count(); <br class="title-page-name"/>        System.out.printf("The list of numbers has %d elements.\n",<br class="title-page-name"/>                          numberOfElements); <br class="title-page-name"/>    <br class="title-page-name"/>        doubleStream = DoubleGenerator.generateStreamFromList(numbers); <br class="title-page-name"/>        double sum = doubleStream.parallel().sum(); <br class="title-page-name"/>        System.out.printf("Its numbers sum %f.\n", sum); <br class="title-page-name"/>          <br class="title-page-name"/>        doubleStream = DoubleGenerator.generateStreamFromList(numbers); <br class="title-page-name"/>        double average = doubleStream.parallel().average()<br class="title-page-name"/>                                                   .getAsDouble(); <br class="title-page-name"/>        System.out.printf("Its numbers have an average value of %f.\n",<br class="title-page-name"/>                          average); <br class="title-page-name"/>    <br class="title-page-name"/>        doubleStream = DoubleGenerator.generateStreamFromList(numbers); <br class="title-page-name"/>        double max = doubleStream.parallel().max().getAsDouble(); <br class="title-page-name"/>        System.out.printf("The maximum value in the list is %f.\n",<br class="title-page-name"/>                          max); <br class="title-page-name"/>          <br class="title-page-name"/>        doubleStream = DoubleGenerator.generateStreamFromList(numbers); <br class="title-page-name"/>        double min = doubleStream.parallel().min().getAsDouble(); <br class="title-page-name"/>        System.out.printf("The minimum value in the list is %f.\n",<br class="title-page-name"/>                          min);
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Then, we'll use the first version of the <kbd class="calibre15">reduce()</kbd> method. This method receives as parameter an associative <kbd class="calibre15">BinaryOperator</kbd> that receives two objects of the same type and returns an object of that type. When the operation has processed all the elements of the <kbd class="calibre15">Stream</kbd>, it returns an <kbd class="calibre15">Optional</kbd> object parameterized with the same type. For example, we'll use this version to calculate the sum of both the coordinates of a random list of <kbd class="calibre15">Point</kbd> objects:</li>
</ol>
<pre class="calibre23">
        List&lt;Point&gt; points=PointGenerator.generatePointList(10000);        <br class="title-page-name"/>        Optional&lt;Point&gt; point=points.parallelStream().reduce((p1,p2) -&gt; { <br class="title-page-name"/>          Point p=new Point(); <br class="title-page-name"/>          p.setX(p1.getX()+p2.getX()); <br class="title-page-name"/>          p.setY(p1.getY()+p2.getY()); <br class="title-page-name"/>          return p; <br class="title-page-name"/>        }); <br class="title-page-name"/>        System.out.println(point.get().getX()+":"+point.get().getY());
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Then, we'll use the second version of the <kbd class="calibre15">reduce()</kbd> method. It's similar to the previous one, but in this case, in addition to the associative <kbd class="calibre15">BinaryOperator</kbd> object, it receives the identity value for that operator (for example <kbd class="calibre15">0</kbd> for a sum or <kbd class="calibre15">1</kbd> for a product) and returns an element of the type we're working with. If the stream has no values, the identity value will be returned. In this case, we use this version of the <kbd class="calibre15">reduce()</kbd> method to calculate the total amount of money we need to spend in salaries. We use the <kbd class="calibre15">map()</kbd> method to convert each <kbd class="calibre15">Person</kbd> object in an <kbd class="calibre15">int</kbd> value (its salary) so our <kbd class="calibre15">Stream</kbd> object will have <kbd class="calibre15">int</kbd> values when it executes the <kbd class="calibre15">reduce()</kbd> method. You will get more information about the <kbd class="calibre15">map()</kbd> method in the <em class="calibre14">Transforming the elements of a stream</em> recipe:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Reduce, second version\n"); <br class="title-page-name"/>        List&lt;Person&gt; persons = PersonGenerator.generatePersonList<br class="title-page-name"/>                                                               (10000); <br class="title-page-name"/>        long totalSalary=persons.parallelStream().map<br class="title-page-name"/>                         (p -&gt; p.getSalary()).reduce(0, (s1,s2) -&gt; s1+s2); <br class="title-page-name"/>        System.out.printf("Total salary: %d\n",totalSalary);
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Finally, we'll use the third version of the <kbd class="calibre15">reduce()</kbd> method. This version is used when the type of result of the reduce operation is different from the type of stream elements. We have to provide the identity value of the return type, an accumulator that implements the <kbd class="calibre15">BiFunction</kbd> interfaces and will receive an object of the return type, an element of the stream to generate a value of the return type, and a combiner function that implements the <kbd class="calibre15">BinaryOperator</kbd> interface and receives two objects of the return type to generate an object of that type. In this case, we have used this version of the method to calculate the number of persons with a salary higher than 50,000 in a list of random persons:</li>
</ol>
<pre class="calibre23">
        Integer value=0; <br class="title-page-name"/>        value=persons.parallelStream().reduce(value, (n,p) -&gt; { <br class="title-page-name"/>          if (p.getSalary() &gt; 50000) { <br class="title-page-name"/>            return n+1; <br class="title-page-name"/>          } else { <br class="title-page-name"/>            return n; <br class="title-page-name"/>          } <br class="title-page-name"/>        }, (n1,n2) -&gt; n1+n2); <br class="title-page-name"/>        System.out.printf("The number of people with a salary bigger<br class="title-page-name"/>                           that 50,000 is %d\n",value);
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this example, you learned how to use the different reduce operations provided by Java streams. First, we used some specialized reduce operations provided by the <kbd class="calibre15">DoubleStream</kbd>, <kbd class="calibre15">IntStream</kbd> and <kbd class="calibre15">LongStream</kbd> classes. These operations allow you to count the number of elements of the stream, calculate the sum of all the elements of the stream, calculate the average value of the elements of the stream, and calculate the highest and lowest value of the elements of the stream. If you work with a generic Stream, you will only have the <kbd class="calibre15">count()</kbd> method to count the elements of the stream.</p>
<p class="calibre4">Then we <span>used</span> the three <span>versions</span> of the <kbd class="calibre15">reduce()</kbd> method provided by the <kbd class="calibre15">Stream</kbd> class. The first one receives only one parameter, a <kbd class="calibre15">BinaryOperator</kbd>. We specified that operator as a lambda expression and you will normally do that, but you can also use an object of a class that implements the <kbd class="calibre15">BinaryOperator</kbd> interface. That operator will receive two elements of the stream and will have to generate a new element of the same type. For example, we receive two <kbd class="calibre15">Point</kbd> objects and generate a new <kbd class="calibre15">Point</kbd> object. The operation implemented by that <kbd class="calibre15">BinaryOperator</kbd> has to be associative, that is to say, the following expression must be true:</p>
<p class="calibre4"><em class="calibre14">(a op b) op c = a op (b op c)</em></p>
<p class="calibre4">Here <kbd class="calibre15">op</kbd> is our <kbd class="calibre15">BinaryOperator</kbd>.</p>
<p class="calibre4">This version of the <kbd class="calibre15">reduce()</kbd> method returns an <kbd class="calibre15">Optional</kbd> object; <kbd class="calibre15">Optional</kbd> because if the stream has no elements, there won't be a result value to return and the <kbd class="calibre15">Optional</kbd> object will be empty.</p>
<p class="calibre4">The second version of the <kbd class="calibre15">reduce()</kbd> method receives an <em class="calibre14">identity</em> value and a <kbd class="calibre15">BinaryOperator</kbd>. The <kbd class="calibre15">BinaryOperator</kbd> has to be associative as in the other version of the <kbd class="calibre15">reduce()</kbd> method. For the <em class="calibre14">identity</em> value, it has to be a <kbd class="calibre15">true</kbd> expression:</p>
<p class="calibre4"><em class="calibre14">identity op a = a op identity = a</em></p>
<p class="calibre4">In this case, the <kbd class="calibre15">reduce()</kbd> method returns an element of the same type of elements of the stream. If the stream has no elements, the identity value will be returned.</p>
<p class="calibre4">The last version of the <kbd class="calibre15">reduce()</kbd> method is used when we want to return a value of a type different from the elements of the stream. In this case, the method has three parameters, an <em class="calibre14">identity</em> value, an <em class="calibre14">accumulator</em> operator, and a <em class="calibre14">combiner</em> operator. The <em class="calibre14">accumulator</em> operator receives a value of the return type and an element of the stream and generates a new object of the return type.</p>
<p class="calibre4">The <em class="calibre14">combiner</em> function receives two objects of the return type to calculate a new object of the return type. The <em class="calibre14">identity</em> value is the <em class="calibre14">identity</em> value of the return type, and it has to verify the following expression:</p>
<p class="calibre4"><em class="calibre14">combiner (u, accumulator(identity, t)) == accumulator(u, t)</em></p>
<p class="calibre4">Here, <em class="calibre14">u</em> is an object of the return type and <em class="calibre14">t</em> an element of the stream.</p>
<p class="calibre4">The following <span>screenshot</span> shows the output of an <span>execution</span> of the example:</p>
<div class="cdpaligncenter"><img class="alignnone22" src="../images/00038.jpeg"/></div>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">We have implemented all the parameters of the <kbd class="calibre15">reduce()</kbd> method as lambda expressions. The first two versions of the <kbd class="calibre15">reduce()</kbd> method receive a <kbd class="calibre15">BinaryOperator</kbd> and the third version receives a <kbd class="calibre15">BiFunction</kbd> and a <kbd class="calibre15">BinaryOperator</kbd>. If you want to reuse a complex operator, you can implement a class that implements the necessary interface and use an object of that class as the parameter to these and to the other methods of the <kbd class="calibre15">Stream</kbd> class.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating streams from different sources</em> recipe in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Collecting the elements of a stream</h1>
            

            <article>
                
<p class="calibre4">Java streams allow you to process a sequence of elements in a sequential or parallel way. You can create a stream from different data sources, as a <kbd class="calibre15">Collection</kbd>, a <kbd class="calibre15">File</kbd> or an <kbd class="calibre15">Array</kbd> and apply to its elements a sequence of operations normally defined with lambda expressions. Those operations can be divided into two different classes:</p>
<ul class="calibre17">
<li class="calibre18"><strong class="calibre1">Intermediate operations</strong>: These operations return other <kbd class="calibre15">Stream</kbd> as a result and allow you to filter, transform, or sort the elements of the stream</li>
<li class="calibre18"><strong class="calibre1">Terminal operations</strong>: These operations return a result after processing the elements of the stream</li>
</ul>
<p class="calibre4">A stream has a source, zero or more intermediate operations, and a terminal operation. The two most important terminal operations are:</p>
<ul class="calibre17">
<li class="calibre18">The reduce operation, which allows you to obtain a unique result after processing the elements of the stream. This result usually is a summary of the processed data. The <em class="calibre14">Reducing the elements of a stream</em> recipe explains you how to use reduce operations in Java.</li>
<li class="calibre18">The collect operation that allows you to generate a data structure with the results of processing the elements of the stream. This is also called a mutable reduction operation as the result is a mutable data structure.</li>
</ul>
<p class="calibre4">In this recipe, we will learn how to execute collect operations in Java streams with the different versions of the <kbd class="calibre15">collect()</kbd> method and the auxiliary <kbd class="calibre15">Collectors</kbd> class.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">First, let's implement some auxiliary classes we will use in the example. Implement the <kbd class="calibre15">Person</kbd> class to store some basic data about a person and the <kbd class="calibre15">PersonGenerator</kbd> class to generate a random list of persons. You can check the <em class="calibre14">Creating streams from different sources</em> recipe to see the source code of both the classes.</li>
<li value="2" class="calibre18">In that class, override the <kbd class="calibre15">toString()</kbd> method with the following code, which returns the first name and the last name of the person:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public String toString() { <br class="title-page-name"/>          return firstName + " " + lastName; <br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Then, create a class named <kbd class="calibre15">Counter</kbd> with two attributes: a <kbd class="calibre15">String</kbd> attribute named <kbd class="calibre15">value</kbd> and an <kbd class="calibre15">int</kbd> attribute named <kbd class="calibre15">counter</kbd>. Generate the methods to <kbd class="calibre15">get()</kbd> and <kbd class="calibre15">set()</kbd> the values of both attributes. The source code of this class is very simple, so it won't be included.</li>
<li value="4" class="calibre18">Now, create the <kbd class="calibre15">Main</kbd> class with the <kbd class="calibre15">main()</kbd> method. Then, create a random <kbd class="calibre15">List</kbd> of <kbd class="calibre15">Person</kbd> objects using the <kbd class="calibre15">PersonGenerator</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/> <br class="title-page-name"/>          public static void main(String args[]) { <br class="title-page-name"/>            List&lt;Person&gt; persons = PersonGenerator.generatePersonList<br class="title-page-name"/>                                                                (100);
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">The first collect operation we will implement will generate a <kbd class="calibre15">Map</kbd> where the keys will be first name of the person and the values will be a list with all the persons with that first name. To implement this, we use the <kbd class="calibre15">collect()</kbd> method of the <kbd class="calibre15">Stream</kbd> class and the <kbd class="calibre15">Collectors.groupingByConcurrent</kbd> collector. Then, we process all the keys (first names) of the map using the <kbd class="calibre15">forEach()</kbd> method and print in the console the number of persons with that key: As parameter of the <kbd class="calibre15">groupingByConcurrent()</kbd> method we pass a method reference. We can use this mechanism in a lambda expression if it only calls to an existing method as in this case.</li>
</ol>
<pre class="calibre23">
        Map&lt;String, List&lt;Person&gt;&gt; personsByName = persons<br class="title-page-name"/>                        .parallelStream().collect(Collectors<br class="title-page-name"/>                        .groupingByConcurrent(Person::getFirstName)); <br class="title-page-name"/>        personsByName.keySet().forEach(key -&gt; { <br class="title-page-name"/>          List&lt;Person&gt; listOfPersons = personsByName.get(key); <br class="title-page-name"/>          System.out.printf("%s: There are %d persons with that name\n",<br class="title-page-name"/>                            key, listOfPersons.size());
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">The second collect operation we will implement will concatenate all the names of all the persons in the stream. To implement this operation, we use the <kbd class="calibre15">toString()</kbd> method of the <kbd class="calibre15">Person</kbd> object, the <kbd class="calibre15">collect()</kbd> method, of the <kbd class="calibre15">Stream</kbd> class, and the <kbd class="calibre15">joining()</kbd> method of the <kbd class="calibre15">Collectors</kbd> class that concatenates all the elements of the stream separated by the specified char sequence:</li>
</ol>
<pre class="calibre23">
        String message = persons.parallelStream().map<br class="title-page-name"/>                  (p -&gt; p.toString()).collect(Collectors.joining(",")); <br class="title-page-name"/>        System.out.printf("%s\n", message);
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">With the next collect operation we'll implement, we will separate the persons on the stream in two groups. The first one will have the persons with a salary greater than 50,000 and the second one will have the others. The result of the operation will be a <kbd class="calibre15">Map</kbd> object with a <kbd class="calibre15">Boolean</kbd> value as the key and a <kbd class="calibre15">List</kbd> of persons as the value. To implement this, we will use the <kbd class="calibre15">collect()</kbd> method of the <kbd class="calibre15">Stream</kbd> class and the <kbd class="calibre15">partitionBy()</kbd> method of the <kbd class="calibre15">Collectors</kbd> class that receives as a parameter a <kbd class="calibre15">Boolean</kbd> expression that allows you two divide the elements of the stream in <kbd class="calibre15">true</kbd> or <kbd class="calibre15">false</kbd>. Then we use the <kbd class="calibre15">forEach()</kbd> method to write the number of elements in the generated lists:</li>
</ol>
<pre class="calibre23">
        Map&lt;Boolean, List&lt;Person&gt;&gt; personsBySalary = persons<br class="title-page-name"/>                        .parallelStream().collect(Collectors<br class="title-page-name"/>                        .partitioningBy(p -&gt; p.getSalary() &gt; 50000));
</pre>
<pre class="calibre23">
        personsBySalary.keySet().forEach(key -&gt; { <br class="title-page-name"/>          List&lt;Person&gt; listOfPersons = personsBySalary.get(key); <br class="title-page-name"/>          System.out.printf("%s: %d \n", key, listOfPersons.size()); <br class="title-page-name"/>        });
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Then, we'll implement a collect operation that will generate another <kbd class="calibre15">Map</kbd>. In this case, the keys will be the first name of the persons and the value will be the last names of the people with the same first name concatenated in one <kbd class="calibre15">String</kbd>. To implement this behavior, we have use the <kbd class="calibre15">collect()</kbd> method of the <kbd class="calibre15">Stream</kbd> class and the <kbd class="calibre15">toConcurrentMap()</kbd> method of the <kbd class="calibre15">Collectors</kbd> class. We pass as parameters to that method a lambda expression to obtain the key, a lambda expression to obtain the value, and a lambda expression to resolve the situations where the key exists in the final <kbd class="calibre15">Map</kbd>. Then, we use the <kbd class="calibre15">forEach()</kbd> method to process all the keys and write its associated values:</li>
</ol>
<pre class="calibre23">
        ConcurrentMap&lt;String, String&gt; nameMap = persons<br class="title-page-name"/>                        .parallelStream().collect(Collectors<br class="title-page-name"/>                        .toConcurrentMap(p -&gt; p.getFirstName(),<br class="title-page-name"/>                                         p -&gt; p.getLastName(),<br class="title-page-name"/>                                         (s1, s2) -&gt; s1 + ", " + s2)); <br class="title-page-name"/>        nameMap.forEach((key, value) -&gt; { <br class="title-page-name"/>          System.out.printf("%s: %s \n", key, value); <br class="title-page-name"/>        });
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Until now, in all the examples of the <kbd class="calibre15">collect()</kbd> method we have implemented, we used the version of that method that receives an implementation of the <kbd class="calibre15">Collector</kbd> interface. But there's another version of the <kbd class="calibre15">collect()</kbd> method. With this version of the <kbd class="calibre15">collect()</kbd> method, we will implement a collect operation that generates a <kbd class="calibre15">List</kbd> with the persons who have a salary greater than 50,000. We pass to the <kbd class="calibre15">collect()</kbd> method an expression to create the <kbd class="calibre15">List</kbd> (the <kbd class="calibre15">List::new</kbd> method), a lambda expression to process a list and an element of the stream, and an expression to process the two lists (the <kbd class="calibre15">List::addAll</kbd> method):</li>
</ol>
<pre class="calibre23">
        List&lt;Person&gt; highSalaryPeople = persons<br class="title-page-name"/>                        .parallelStream().collect(<br class="title-page-name"/>          ArrayList::new, (list, person) -&gt; {  <br class="title-page-name"/>            if (person.getSalary() &gt; 50000) { <br class="title-page-name"/>              list.add(person); <br class="title-page-name"/>            } <br class="title-page-name"/>          }, <br class="title-page-name"/>          ArrayList::addAll <br class="title-page-name"/>        ); <br class="title-page-name"/>        System.out.printf("High Salary People: %d\n",<br class="title-page-name"/>                          highSalaryPeople.size());
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Finally, we'll implement an example that generates a <kbd class="calibre15">ConcurrentHashMap</kbd> with the first names that appears in the list of <kbd class="calibre15">People</kbd> objects and the number of times that each name appears. We will use the first name of the persons as key and <kbd class="calibre15">Counter</kbd> objects as values. The first parameter of the collect method will create a new <kbd class="calibre15">ConcurrentHashMap</kbd> object. The second parameter is an implementation of the <kbd class="calibre15">BiConsumer</kbd> interface that receives as parameters a <kbd class="calibre15">ConcurrentHashMap</kbd> and a <kbd class="calibre15">Person</kbd>. First, we use the <kbd class="calibre15">computeIfPresent()</kbd> method of the hash to increment the <kbd class="calibre15">Counter</kbd> of the person if the person exists. Then, we use the <kbd class="calibre15">computeIfAbsent()</kbd> method of the hash to insert a new person name if it doesn't exists. The third argument of the <kbd class="calibre15">collect()</kbd> method is an implementation of the <kbd class="calibre15">BiConsumer</kbd> interface that receives two <kbd class="calibre15">ConcurrentHashMap</kbd> objects and we use the <kbd class="calibre15">merge()</kbd> method to process all the elements of the second hash and insert them in the first hash if they are not present or increment the counters if they are.</li>
</ol>
<pre class="calibre23">
        System.out.printf("Collect, second example\n"); <br class="title-page-name"/>        ConcurrentHashMap&lt;String, Counter&gt; peopleNames = persons<br class="title-page-name"/>                                .parallelStream().collect( <br class="title-page-name"/>          ConcurrentHashMap::new, (hash, person) -&gt; { <br class="title-page-name"/>            hash.computeIfPresent(person.getFirstName(), (name,<br class="title-page-name"/>                                                          counter) -&gt; { <br class="title-page-name"/>              counter.increment(); <br class="title-page-name"/>              return counter; <br class="title-page-name"/>            }); <br class="title-page-name"/>            hash.computeIfAbsent(person.getFirstName(), name -&gt; { <br class="title-page-name"/>              Counter c=new Counter(); <br class="title-page-name"/>              c.setValue(name); <br class="title-page-name"/>              return c; <br class="title-page-name"/>            }); <br class="title-page-name"/>          }, <br class="title-page-name"/>          (hash1, hash2) -&gt; { <br class="title-page-name"/>            hash2.forEach (10, (key, value) -&gt; { <br class="title-page-name"/>              hash1.merge(key, value, (v1,v2) -&gt; { <br class="title-page-name"/>                v1.setCounter(v1.getCounter()+v2.getCounter()); <br class="title-page-name"/>                return v1; <br class="title-page-name"/>              }); <br class="title-page-name"/>            }); <br class="title-page-name"/>          }); <br class="title-page-name"/>          <br class="title-page-name"/>          peopleNames.forEach((name, counter) -&gt; { <br class="title-page-name"/>            System.out.printf("%s: %d\n", name, counter.getCounter()); <br class="title-page-name"/>          });
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">As we mentioned in the introduction of this recipe, the <kbd class="calibre15">collect()</kbd> method allows you to do a mutable reduction of the elements of a <kbd class="calibre15">Stream</kbd>. We call it a mutable reduction because the final result of the stream will be a mutable data structure, such as <kbd class="calibre15">Map</kbd> or <kbd class="calibre15">List</kbd>. The <kbd class="calibre15">Stream</kbd> class of the Java Concurrency API provides two versions of the <kbd class="calibre15">collect()</kbd> method.</p>
<p class="calibre4">The first one receives only one parameter that is an implementation of the <kbd class="calibre15">Collector</kbd> interface. This interface has seven methods, so you normally won't implement your own collectors. Instead of this, you will use the utility class <kbd class="calibre15">Collectors</kbd>, which has a lot of methods that return ready-to-use <kbd class="calibre15">Collector</kbd> objects for your reduce operations. In our example, we have used the following methods of the <kbd class="calibre15">Collectors</kbd> class:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">groupingByConcurrent()</kbd>: This method returns a <kbd class="calibre15">Collector</kbd> object that implements a group by operating with the elements of <kbd class="calibre15">Stream</kbd> in a concurrent way, generating <kbd class="calibre15">Map</kbd> as the resultant data structure. It receives as parameter an expression to obtain the value of the key used in the map from the element of the stream. It generates <kbd class="calibre15">Map</kbd> where the keys will be of the type returned by the parameter expression and the value will be a <kbd class="calibre15">List</kbd> of elements of the stream.</li>
<li class="calibre18"><kbd class="calibre15">joining()</kbd>: This method returns <kbd class="calibre15">Collector</kbd> that concatenates the elements of the stream into <kbd class="calibre15">String</kbd>. You can specify three <kbd class="calibre15">CharSequence</kbd> objects with a separator for the elements, a prefix of the final <kbd class="calibre15">String</kbd>, and a suffix of the final <kbd class="calibre15">String</kbd>.</li>
<li class="calibre18"><kbd class="calibre15">partitioningBy()</kbd>: This method returns <kbd class="calibre15">Collector</kbd> similar to the first one. It receives as parameter a <kbd class="calibre15">Boolean</kbd> expression with the elements of <kbd class="calibre15">Stream</kbd> and organizes the elements of the stream in two groups: the ones that meet the expressions and the ones that don't. The final result will be <kbd class="calibre15">Map</kbd> with a <kbd class="calibre15">Boolean</kbd> key and <kbd class="calibre15">List</kbd> of the type of elements of the stream as value.</li>
<li class="calibre18"><kbd class="calibre15">toConcurrentMap()</kbd>: This method returns <kbd class="calibre15">Collector</kbd> that generates <kbd class="calibre15">ConcurrentMap</kbd> in a concurrent way. It receives three parameters:
<ul class="calibre24">
<li class="calibre18">An expression to generate the key from an element of the stream</li>
<li class="calibre18">An expression to generate the value from an element of the stream</li>
<li class="calibre18">An expression to generate a value from two values when there are two or more elements with the same key</li>
</ul>
</li>
</ul>
<p class="calibre4"><kbd class="calibre15">Collector</kbd> has a set of <kbd class="calibre15">Characteristics</kbd> that define its behavior and can be defined or not for a specific collector. For us, the most important is the <kbd class="calibre15">CONCURRENT</kbd> one that indicates if the collector can work in a concurrent way or not. In this case, we can't take advantage of our multicore processor by creating only a parallel stream. If we use a collect operation with <kbd class="calibre15">Collector</kbd>, we have to also take into account the value of the <kbd class="calibre15">CONCURRENT</kbd> characteristic of that <kbd class="calibre15">Collector</kbd>. We will only have a concurrent reduction if the next three conditions are true:</p>
<ul class="calibre17">
<li class="calibre18">The <kbd class="calibre15">Stream</kbd> is parallel (we have used <kbd class="calibre15">parallelStream()</kbd> of the <kbd class="calibre15">parallel()</kbd> methods in the stream)</li>
<li class="calibre18">The collector has the <kbd class="calibre15">CONCURRENT</kbd> characteristic</li>
<li class="calibre18">Either the stream is unordered, or the collector has the <kbd class="calibre15">UNORDERED</kbd> characteristic</li>
</ul>
<p class="calibre4">In our case, <kbd class="calibre15">groupingByConcurrent()</kbd> and <kbd class="calibre15">toConcurrentMap()</kbd> return collectors which have the <kbd class="calibre15">CONCURRENT</kbd> characteristic and the <kbd class="calibre15">joining()</kbd> and <kbd class="calibre15">partitionBy()</kbd> methods return collectors that don't have such characteristics.</p>
<p class="calibre4">However, there's another version of the <kbd class="calibre15">collect()</kbd> method that can be used with parallel streams. This version of the <kbd class="calibre15">collect()</kbd> method receives the following three parameters:</p>
<ul class="calibre17">
<li class="calibre18">A supplier function that generates a data structure of the type of the final result of the collect operation. With parallel streams, this function will be called as many times as there are threads executing the operation.</li>
<li class="calibre18">An accumulator function that receives a data structure and an element of the stream and makes the process of the element.</li>
<li class="calibre18">A combiner function that receives two data structures and generates a unique data structure of the same type.</li>
</ul>
<p class="calibre4">You can use lambda expressions to implement these functions, but you can also implement the <kbd class="calibre15">Supplier</kbd> interface for the supplier function or the <kbd class="calibre15">BiConsumer</kbd> interface for the accumulator and combiner functions (always parameterized with the adequate data types). You can also use method references (<kbd class="calibre15">Class::Method</kbd>) if the input and output parameters are adequate. For example, we have used the <kbd class="calibre15">List::new</kbd> reference as the supplier function and the <kbd class="calibre15">List::addAll</kbd> method as the combiner function. We could use the <kbd class="calibre15">List::add</kbd> method as the accumulator function. There are more methods you can use as parameters to the <kbd class="calibre15">collect()</kbd> method.</p>
<p class="calibre4">The following screenshot shows the output of the <kbd class="calibre15">groupingByConcurrent()</kbd> operation:</p>
<div class="cdpaligncenter"><img class="alignnone23" src="../images/00039.jpeg"/></div>
<p class="calibre4">The following screenshot shows the output of the <kbd class="calibre15">toConcurrentMap()</kbd> operation:</p>
<div class="cdpaligncenter"><img class="alignnone24" src="../images/00040.jpeg"/></div>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">Collectors</kbd> class has many more methods that return <kbd class="calibre15">Collector</kbd> objects that can be used in the <kbd class="calibre15">collect()</kbd> method. The following are the most interesting:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">toList()</kbd>: This method returns <kbd class="calibre15">Collector</kbd> that groups all the elements of <kbd class="calibre15">Stream</kbd> into <kbd class="calibre15">List</kbd>.</li>
<li class="calibre18"><kbd class="calibre15">toCollection()</kbd>: This method returns <kbd class="calibre15">Collector</kbd> that groups all the elements of <kbd class="calibre15">Stream</kbd> into <kbd class="calibre15">Collection</kbd>. This method returns as parameter an expression that creates <kbd class="calibre15">Collection</kbd>, which will be used internally by <kbd class="calibre15">Collector</kbd> and returned at the end of its execution.</li>
<li class="calibre18"><kbd class="calibre15">averagingInt()</kbd>, <kbd class="calibre15">averagingLong()</kbd>, and <kbd class="calibre15">averagingDouble()</kbd>: These methods return <kbd class="calibre15">Collector</kbd> that calculates the average of <kbd class="calibre15">int</kbd>, <kbd class="calibre15">long</kbd>, and <kbd class="calibre15">double</kbd> values, respectively. They receive as parameters an expression to convert an element of the stream into <kbd class="calibre15">int</kbd>, <kbd class="calibre15">long</kbd>, or <kbd class="calibre15">double</kbd>. The three methods return a double value.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating streams from different sources</em> and <em class="calibre14">Reducing the elements of a stream </em>recipes in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Applying an action to every element of a stream</h1>
            

            <article>
                
<p class="calibre4">In this recipe, you will learn how to apply an action to all the elements of the stream. We will use three methods: two terminal operations, the <kbd class="calibre15">forEach()</kbd> and <kbd class="calibre15">forEachOrdered()</kbd>, and an intermediate operation, the <kbd class="calibre15">peek()</kbd> method.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">First, we will implement some auxiliary classes we will use in the example. Create a class named <kbd class="calibre15">Person</kbd> with the basic characteristics of a person. Check the <em class="calibre14">Creating streams from different sources</em> recipe to see the source code of this class.</li>
<li value="2" class="calibre18">As we'll work with methods that depend on the order of the elements of the stream, we have to override some methods in the <kbd class="calibre15">Person</kbd> class. First, we'll override the <kbd class="calibre15">compareTo()</kbd> method that compares two persons. We'll create a static <kbd class="calibre15">Comparator</kbd> object using the <kbd class="calibre15">Comparator</kbd> interface to compare two <kbd class="calibre15">Person</kbd> objects using their first name and last name. Then, we'll use that comparator in the <kbd class="calibre15">compareTo()</kbd> method:</li>
</ol>
<pre class="calibre23">
        private static Comparator&lt;Person&gt; comparator=Comparator<br class="title-page-name"/>                                .comparing(Person::getLastName)<br class="title-page-name"/>                                .thenComparing(Person::getFirstName); <br class="title-page-name"/> <br class="title-page-name"/>        @Override <br class="title-page-name"/>        public int compareTo(Person otherPerson) { <br class="title-page-name"/>          return comparator.compare(this, otherPerson); <br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Then, we override the <kbd class="calibre15">equals()</kbd> method that determines if two <kbd class="calibre15">Person</kbd> objects are equal. As we made in the <kbd class="calibre15">compareTo()</kbd> method, we use the <kbd class="calibre15">Comparator</kbd> static object we have created before.</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public boolean equals(Object object) { <br class="title-page-name"/>          return this.compareTo((Person)object)==0; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Finally, we override the <kbd class="calibre15">hashCode()</kbd> method that calculates a hash value for a <kbd class="calibre15">Person</kbd> object. In Java, equal objects must produce the same hash code, so we have to override this method and generate the hash code of a <kbd class="calibre15">Person</kbd> object using the first name and last name attributes and the <kbd class="calibre15">hash()</kbd> method of the <kbd class="calibre15">Objects</kbd> class:</li>
</ol>
<pre class="calibre23">
        public int hashCode() { <br class="title-page-name"/>          String sequence=this.getLastName()+this.getFirstName(); <br class="title-page-name"/>          return sequence.hashCode(); <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">In this example, we will also use the <kbd class="calibre15">PersonGenerator</kbd> and <kbd class="calibre15">DoubleGenerator</kbd> classes used in the <em class="calibre14">Creating streams from different sources</em> recipe.</li>
<li value="6" class="calibre18">Now, create the <kbd class="calibre15">Main</kbd> class with the <kbd class="calibre15">main()</kbd> method. First, we create a <kbd class="calibre15">List</kbd> of ten random <kbd class="calibre15">Person</kbd> objects:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/> <br class="title-page-name"/>          public static void main(String[] args) { <br class="title-page-name"/>            List&lt;Person&gt; persons=PersonGenerator.generatePersonList(10);
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Then, we'll use the <kbd class="calibre15">forEach()</kbd> method to write the names of all the persons of the generated list. The <kbd class="calibre15">forEach()</kbd> method receives as parameter the expression we want to apply to each element. In our case, we use a lambda expression to write the information to the console:</li>
</ol>
<pre class="calibre23">
        persons.parallelStream().forEach(p -&gt; { <br class="title-page-name"/>           System.out.printf("%s, %s\n", p.getLastName(),<br class="title-page-name"/>                             p.getFirstName()); <br class="title-page-name"/>        });
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Then, you'll learn how to apply an action to each element in an ordered way. First, we create a list of random <kbd class="calibre15">Double</kbd> numbers using the <kbd class="calibre15">DoubleGenerator</kbd> class. Then, we create a parallel stream, sort the elements of the stream using the <kbd class="calibre15">sorted()</kbd> method, and then use the <kbd class="calibre15">forEachOrdered()</kbd> method to write the numbers to the console in an ordered way:</li>
</ol>
<pre class="calibre23">
        List&lt;Double&gt; doubles= DoubleGenerator.generateDoubleList(10, 100); <br class="title-page-name"/>        System.out.printf("Parallel forEachOrdered() with numbers\n"); <br class="title-page-name"/>        doubles.parallelStream().sorted().forEachOrdered(n -&gt; { <br class="title-page-name"/>          System.out.printf("%f\n",n); <br class="title-page-name"/>        });
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Now, let's see what happens if you sort the elements of the stream but don't use the <kbd class="calibre15">forEachOrdered()</kbd> method. Repeat the same sentence as before but use the <kbd class="calibre15">forEach()</kbd> method instead:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Parallel forEach() after sorted()<br class="title-page-name"/>                           with numbers\n"); <br class="title-page-name"/>        doubles.parallelStream().sorted().forEach(n -&gt; { <br class="title-page-name"/>          System.out.printf("%f\n",n); <br class="title-page-name"/>        });
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Then, we'll test how the <kbd class="calibre15">forEachOrdered()</kbd> method works with a stream of <kbd class="calibre15">Person</kbd> objects:</li>
</ol>
<pre class="calibre23">
        persons.parallelStream().sorted().forEachOrdered( p -&gt; { <br class="title-page-name"/>          System.out.printf("%s, %s\n", p.getLastName(),<br class="title-page-name"/>                            p.getFirstName()); <br class="title-page-name"/>        });
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Finally, let's test the <kbd class="calibre15">peek()</kbd> method. This method is similar to the <kbd class="calibre15">forEach()</kbd> method, but it's an intermediate operation. It's normally used for log purposes:</li>
</ol>
<pre class="calibre23">
        doubles <br class="title-page-name"/>          .parallelStream() <br class="title-page-name"/>          .peek(d -&gt; System.out.printf("Step 1: Number: %f\n",d)) <br class="title-page-name"/>          .peek(d -&gt; System.out.printf("Step 2: Number: %f\n",d)) <br class="title-page-name"/>          .forEach(d -&gt; System.out.printf("Final Step: Number: %f\n",d));
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe you learnt how to use three methods to process all the elements of a stream and apply an action to them. These methods are:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">forEach()</kbd>: This is a terminal operation that applies an action to all the elements of <kbd class="calibre15">Stream</kbd> and returns a <kbd class="calibre15">void</kbd> value. It receives as parameter the action to apply to the elements defined as a lambda expression or as an implementation of the <kbd class="calibre15">Consumer</kbd> interface. There's no guarantee about the order in which the action will be applied to the elements of a parallel stream.</li>
<li class="calibre18"><kbd class="calibre15">forEachOrdered()</kbd>: This is a terminal operation that applies an action to all the elements of <kbd class="calibre15">Stream</kbd> in the order of the stream, if the stream is an ordered stream, and returns a void value. You can use this method after the <kbd class="calibre15">sorted()</kbd> method. You first sort the elements of the stream with the <kbd class="calibre15">sorted()</kbd> method and then apply the action in an ordered way using the <kbd class="calibre15">forEachOrdered()</kbd> method. This behavior is guaranteed with parallel streams too, but its performance will be worse than the <kbd class="calibre15">forEach()</kbd> method with unordered streams.</li>
<li class="calibre18"><kbd class="calibre15">peek()</kbd>: This is an intermediate operation that returns <kbd class="calibre15">Stream</kbd> with the same elements of the stream that call the method and applies the action specified as a parameter to all the elements consumed from the stream. The action applied to the elements is specified as a lambda expression or as an implementation of the <kbd class="calibre15">Consumer</kbd> interface. Take into account that, as the intermediate operations are lazy, the operation will only be applied to the elements consumed by the stream when the terminal operation is executed.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">Take into account that if you use the sorted method, you have to provide <kbd class="calibre15">Comparator</kbd> that can be applied to the elements you want to sort or the elements of the stream must implement the <kbd class="calibre15">Comparable</kbd> interface. In our case, the <kbd class="calibre15">Person</kbd> class implements that interface and the <kbd class="calibre15">compareTo()</kbd> method to sort the elements of the stream according to their first and last names.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating streams from different sources</em>, <em class="calibre14">Reducing the elements of a stream</em> and <em class="calibre14">Sorting the elements of a stream</em> recipes in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Filtering the elements of a stream</h1>
            

            <article>
                
<p class="calibre4">One of the most commons actions you will apply to a stream will be the filtering operation that selects the elements that continue with the processing. In this recipe, you will learn the different methods provided by the <kbd class="calibre15">Stream</kbd> class to select the elements of a stream.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">First, we'll implement some auxiliary classes we will use in the example. First, implement the <kbd class="calibre15">Person</kbd> class that stores the basic attributes of a person, and the <kbd class="calibre15">PersonGenerator</kbd> class that generates a <kbd class="calibre15">List</kbd> of random <kbd class="calibre15">Person</kbd> objects. Please, check the recipe <em class="calibre14">Apply an action to all the elements of a stream</em> to see the source code of both the classes.</li>
<li value="2" class="calibre18">Then, we'll implement the <kbd class="calibre15">Main</kbd> class with the <kbd class="calibre15">main()</kbd> method. First, create a <kbd class="calibre15">List</kbd> of random <kbd class="calibre15">Person</kbd> objects using the <kbd class="calibre15">PersonGenerator</kbd> class. Use the <kbd class="calibre15">forEach()</kbd> method to print the generated elements:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) { <br class="title-page-name"/>            List&lt;Person&gt; persons=PersonGenerator<br class="title-page-name"/>                                        .generatePersonList(10); <br class="title-page-name"/>            persons.parallelStream().forEach(p-&gt; { <br class="title-page-name"/>              System.out.printf("%s, %s\n", p.getLastName(),<br class="title-page-name"/>                                p.getFirstName()); <br class="title-page-name"/>            });
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Then, we'll eliminate the duplicate objects using the <kbd class="calibre15">distinct()</kbd> method. Use the <kbd class="calibre15">forEach()</kbd> method to write the elements that pass the filter:</li>
</ol>
<pre class="calibre23">
        persons.parallelStream().distinct().forEach(p-&gt; { <br class="title-page-name"/>          System.out.printf("%s, %s\n", p.getLastName(),<br class="title-page-name"/>                            p.getFirstName()); <br class="title-page-name"/>        });
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Then, we'll test the <kbd class="calibre15">distinct()</kbd> method with an <kbd class="calibre15">Array</kbd> of numbers. Create an array of numbers repeating some of them. Convert them to a <kbd class="calibre15">List</kbd> using the <kbd class="calibre15">asList()</kbd> method of the <kbd class="calibre15">Arrays</kbd> class. Create a parallel stream with the <kbd class="calibre15">parallelStream()</kbd> method, convert the stream into an <kbd class="calibre15">IntStream</kbd> stream with the <kbd class="calibre15">mapToInt()</kbd> method, use the <kbd class="calibre15">distinct()</kbd> method to delete the repeated elements, and finally use the <kbd class="calibre15">forEach()</kbd> method to write the final elements to the console:</li>
</ol>
<pre class="calibre23">
        Integer[] numbers={1,3,2,1,2,2,1,3,3,1,1,3,2,1}; <br class="title-page-name"/>        Arrays.asList(numbers).parallelStream().mapToInt(n -&gt; n)<br class="title-page-name"/>                                        .distinct().forEach( n -&gt; { <br class="title-page-name"/>          System.out.printf("Number: %d\n", n); <br class="title-page-name"/>        });
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Now, we'll get the persons of the random person list with a salary lower than 3,000 using the filter method and a predicate expressed as a lambda expression with that condition. As with the other examples, use the <kbd class="calibre15">forEach()</kbd> method to write the resultant elements:</li>
</ol>
<pre class="calibre23">
        persons.parallelStream().filter(p -&gt; p.getSalary() &lt; 30000)<br class="title-page-name"/>                                                .forEach( p -&gt; { <br class="title-page-name"/>          System.out.printf("%s, %s\n", p.getLastName(),<br class="title-page-name"/>                        <strong class="calibre1">    </strong>p.getFirstName()); <br class="title-page-name"/>        });
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Then, we'll test the <kbd class="calibre15">filter()</kbd> method with an <kbd class="calibre15">IntStream</kbd> getting the numbers less than two:</li>
</ol>
<pre class="calibre23">
        Arrays.asList(numbers).parallelStream().mapToInt(n -&gt; n)<br class="title-page-name"/>                                .filter( n -&gt; n&lt;2).forEach(  n-&gt; { <br class="title-page-name"/>          System.out.printf("%d\n", n); <br class="title-page-name"/>        });
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Now, we'll use the <kbd class="calibre15">limit()</kbd> method to limit the number of elements in the stream. For example, create a parallel stream from the random list of persons, convert them into a <kbd class="calibre15">DoubleStream</kbd> with the <kbd class="calibre15">mapToDouble()</kbd> method, and get the first five elements using the <kbd class="calibre15">limit()</kbd> method:</li>
</ol>
<pre class="calibre23">
        persons.parallelStream().mapToDouble(p -&gt; p.getSalary())<br class="title-page-name"/>                                       .sorted().limit(5).forEach(s-&gt; { <br class="title-page-name"/>          System.out.printf("Limit: %f\n",s); <br class="title-page-name"/>        });
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Finally, we'll use the <kbd class="calibre15">skip()</kbd> method to ignore a number of elements of the stream. Create a parallel stream from the random list of persons, convert them into a <kbd class="calibre15">DoubleStream</kbd> with the <kbd class="calibre15">mapToDouble()</kbd> method, and ignore the first five elements using the <kbd class="calibre15">skip()</kbd> method:</li>
</ol>
<pre class="calibre23">
        persons.parallelStream().mapToDouble(p -&gt; p.getSalary())<br class="title-page-name"/>                                        .sorted().skip(5).forEach(s-&gt; { <br class="title-page-name"/>          System.out.printf("Skip: %f\n",s); <br class="title-page-name"/>        });
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe we have used four methods to filter the elements in a stream. These methods are:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">distinct()</kbd>: This method returns a stream with the distinct elements of the current stream according to the <kbd class="calibre15">equals()</kbd> method of the elements of the <kbd class="calibre15">Stream</kbd> class. In our case, we have tested this method with <kbd class="calibre15">Person</kbd> objects and <kbd class="calibre15">int</kbd> numbers. We have implemented the <kbd class="calibre15">equals()</kbd> and <kbd class="calibre15">hashCode()</kbd> methods in the <kbd class="calibre15">Person</kbd> class. If we don't do this, the <kbd class="calibre15">equals()</kbd> method will only return <kbd class="calibre15">true</kbd> if the two compared objects hold the same reference. Take into account that this operation is a stateful operation, so it won't get a good performance with parallel streams (as the Java documentation reflects, '... under parallel computation, some pipelines containing stateful intermediate operations may require multiple passes on the data or may need to buffer significant data...').</li>
<li class="calibre18"><kbd class="calibre15">filter()</kbd>: This method receives a <kbd class="calibre15">Predicate</kbd> as parameter. This predicate can be expressed as a lambda expression that returns a <kbd class="calibre15">boolean</kbd> value. The <kbd class="calibre15">filter()</kbd> method returns a stream with the elements that make the <kbd class="calibre15">Predicate</kbd> true.</li>
<li class="calibre18"><kbd class="calibre15">limit()</kbd>: This method receives an <kbd class="calibre15">int</kbd> value as a parameter and returns a stream with no more than as many number of elements. The performance of this method can also be bad with ordered parallel streams, especially when the number of elements you want to get is big, because the method will return the first elements of the stream and that will imply additional computation. This circumstance doesn't occur with unordered streams because in that case, it doesn't matter what elements are returned.</li>
<li class="calibre18"><kbd class="calibre15">skip()</kbd>: This method returns a stream with the elements of the original stream after discarding the first elements. The number of discarded elements is specified as the parameter of this method. This method has the same performance problems as with the <kbd class="calibre15">limit()</kbd> method.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The stream class also has other two methods that can be used to filter the elements of a stream:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">dropWhile()</kbd>: This method receives a <kbd class="calibre15">Predicate</kbd> expression as the parameter. It has a different behavior with ordered and unordered streams. With ordered streams, the method deletes the first elements that match the predicate from the stream. It deletes elements when the elements match the predicate. When it finds an element that doesn't match the predicate, it stops deleting the elements and returns the rest of the stream. With unordered streams, its behavior is not deterministic. It deletes a subset of elements that match the predicate but is not specified what subset of elements it will delete. As with the other methods, it may have a bad performance with parallel ordered streams.</li>
<li class="calibre18"><kbd class="calibre15">takeWhile()</kbd>: This method is equivalent to the previous one, but it takes the elements instead of deleting them.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating streams from different sources</em>, <em class="calibre14">Reducing the elements of a stream</em> and <em class="calibre14">Collecting the elements of a stream</em> recipes in <span>this chapter</span></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Transforming the elements of a stream</h1>
            

            <article>
                
<p class="calibre4">Some of the most useful intermediate operations you can use with streams are those that allow you to transform the elements of the stream. These operations receive elements of a class and return the elements of a different class. You can even change the type of stream and generate an <kbd class="calibre15">IntStream</kbd>, <kbd class="calibre15">LongStream</kbd>, or <kbd class="calibre15">DoubleStream</kbd> from <kbd class="calibre15">Stream</kbd>.</p>
<p class="calibre4">In this recipe, you will learn how to use the transforming intermediate operations provided by the <kbd class="calibre15">Stream</kbd> class to convert its elements into a different class.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">First, we'll implement some auxiliary classes we will use in the example. First, implement the <kbd class="calibre15">Person</kbd> class, which stores the basic attributes of a person, and the <kbd class="calibre15">PersonGenerator</kbd> class, which generates a <kbd class="calibre15">List</kbd> of random <kbd class="calibre15">Person</kbd> objects. Please, check the recipe <em class="calibre14">Apply an action to all the elements of a stream</em> to see the source code of both the classes.</li>
<li value="2" class="calibre18">Create a class named <kbd class="calibre15">BasicPerson</kbd>. This class will have a <kbd class="calibre15">String</kbd> attribute named <kbd class="calibre15">name</kbd> and a <kbd class="calibre15">long</kbd> attribute named <kbd class="calibre15">age</kbd>. Create the methods to get and set the value of both the attributes. As the source code of this class is very simple, it won't be included here.</li>
<li value="3" class="calibre18">Create another auxiliary class named <kbd class="calibre15">FileGenerator</kbd>. This class will have a method named <kbd class="calibre15">generateFile()</kbd> that receives the number of lines in the simulated file and returns its content as a <kbd class="calibre15">List</kbd> of <kbd class="calibre15">String</kbd>:</li>
</ol>
<pre class="calibre23">
        public class FileGenerator { <br class="title-page-name"/>          public static List&lt;String&gt; generateFile(int size) { <br class="title-page-name"/>            List&lt;String&gt; file=new ArrayList&lt;&gt;(); <br class="title-page-name"/>            for (int i=0; i&lt;size; i++) { <br class="title-page-name"/>              file.add("Lorem ipsum dolor sit amet,<br class="title-page-name"/>                        consectetur adipiscing elit. Morbi lobortis<br class="title-page-name"/>                        cursus venenatis. Mauris tempus elit ut <br class="title-page-name"/>                        malesuada luctus. Interdum et malesuada fames<br class="title-page-name"/>                        ac ante ipsum primis in faucibus. Phasellus<br class="title-page-name"/>                        laoreet sapien eu pulvinar rhoncus. Integer vel<br class="title-page-name"/>                        ultricies leo. Donec vel sagittis nibh.<br class="title-page-name"/>                        Maecenas eu quam non est hendrerit pu"); <br class="title-page-name"/>            } <br class="title-page-name"/>            return file; <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Then, create the <kbd class="calibre15">Main</kbd> class with the <kbd class="calibre15">main()</kbd> method. First, create a list of random <kbd class="calibre15">Person</kbd> objects using the <kbd class="calibre15">PersonGenerator</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/> <br class="title-page-name"/>          public static void main(String[] args) { <br class="title-page-name"/> <br class="title-page-name"/>            // Create list of persons <br class="title-page-name"/>            List&lt;Person&gt; persons = PersonGenerator.generatePersonList(100);
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Then, we'll use the <kbd class="calibre15">mapToDouble()</kbd> method to convert the stream of <kbd class="calibre15">Person</kbd> objects into <kbd class="calibre15">DoubleStream</kbd> of double values. Create a parallel stream using the <kbd class="calibre15">parallelStream()</kbd> method and then use the <kbd class="calibre15">mapToDouble()</kbd> method, passing as parameter a lambda expression that receives a <kbd class="calibre15">Person</kbd> object and returns its salary, which is a double number. Then use the <kbd class="calibre15">distinct()</kbd> method to get the unique values and the <kbd class="calibre15">forEach()</kbd> method to write them to the console. We also get the number of different elements written using the <kbd class="calibre15">count()</kbd> method:</li>
</ol>
<pre class="calibre23">
        DoubleStream ds = persons.parallelStream().mapToDouble<br class="title-page-name"/>                                                (p -&gt; p.getSalary()); <br class="title-page-name"/>        ds.distinct().forEach(d -&gt; { <br class="title-page-name"/>          System.out.printf("Salary: %f\n", d); <br class="title-page-name"/>        }); <br class="title-page-name"/>        ds = persons.parallelStream().mapToDouble(p -&gt; p.getSalary()); <br class="title-page-name"/>        long size = ds.distinct().count(); <br class="title-page-name"/>        System.out.printf("Size: %d\n", size);
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Now, we'll transform the <kbd class="calibre15">Person</kbd> objects of the stream into <kbd class="calibre15">BasicPerson</kbd> objects. Create the stream using the <kbd class="calibre15">parallelStream()</kbd> method and use the <kbd class="calibre15">map()</kbd> method to transform the objects. This method receives as parameter a lambda expression that receives a <kbd class="calibre15">Person</kbd> object, creates a new <kbd class="calibre15">BasicPerson</kbd> object, and establishes the value of its attributes. Then, we write the values of the attributes of the <kbd class="calibre15">BasicPerson</kbd> object using the <kbd class="calibre15">forEach()</kbd> method:</li>
</ol>
<pre class="calibre23">
        List&lt;BasicPerson&gt; basicPersons = persons.parallelStream().map<br class="title-page-name"/>                                                                (p -&gt; { <br class="title-page-name"/>          BasicPerson bp = new BasicPerson(); <br class="title-page-name"/>          bp.setName(p.getFirstName() + " " + p.getLastName()); <br class="title-page-name"/>          bp.setAge(getAge(p.getBirthDate())); <br class="title-page-name"/>          return bp; <br class="title-page-name"/>        }).collect(Collectors.toList()); <br class="title-page-name"/> <br class="title-page-name"/>        basicPersons.forEach(bp -&gt; { <br class="title-page-name"/>          System.out.printf("%s: %d\n", bp.getName(), bp.getAge()); <br class="title-page-name"/>        });
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Finally, we'll learn how to manage the situations where an intermediate operation returns <kbd class="calibre15">Stream</kbd>. In this case, we'll work with a  <kbd class="calibre15">Stream</kbd> of streams, but we can concatenate all these <kbd class="calibre15">Stream</kbd> objects into a unique <kbd class="calibre15">Stream</kbd> using the <kbd class="calibre15">flatMap()</kbd> method. Generate <kbd class="calibre15">List&lt;String&gt;</kbd> with 100 elements using the <kbd class="calibre15">FileGenerator</kbd> class. Then, create a parallel stream with the <kbd class="calibre15">parallelStream()</kbd> method. We'll split each line to get its words using the <kbd class="calibre15">split()</kbd> method, and with the <kbd class="calibre15">of()</kbd> method of the <kbd class="calibre15">Stream</kbd> class, we convert the resultant <kbd class="calibre15">Array</kbd> into <kbd class="calibre15">Stream</kbd>. If we use the <kbd class="calibre15">map()</kbd> method, we are generating a <kbd class="calibre15">Stream</kbd> of streams, but using the <kbd class="calibre15">flatMap()</kbd> method we'll get a unique <kbd class="calibre15">Stream</kbd> of <kbd class="calibre15">String</kbd> objects with all the words of the whole List. Then, we get the words with a length greater than zero with the <kbd class="calibre15">filter()</kbd> method, sort the stream with the <kbd class="calibre15">sorted()</kbd> method, and collect it to <kbd class="calibre15">Map</kbd> using the <kbd class="calibre15">groupingByConcurrent()</kbd> method where the keys are the words and the values are the number of times each word appears in the stream:</li>
</ol>
<pre class="calibre23">
        List&lt;String&gt; file = FileGenerator.generateFile(100); <br class="title-page-name"/>        Map&lt;String, Long&gt; wordCount = file.parallelStream()<br class="title-page-name"/>          .flatMap(line -&gt; Stream.of(line.split("[ ,.]"))) <br class="title-page-name"/>          .filter(w -&gt; w.length() &gt; 0).sorted()<br class="title-page-name"/>          .collect(Collectors.groupingByConcurrent(e -&gt; e, Collectors<br class="title-page-name"/>            .counting())); <br class="title-page-name"/> <br class="title-page-name"/>        wordCount.forEach((k, v) -&gt; { <br class="title-page-name"/>          System.out.printf("%s: %d\n", k, v); <br class="title-page-name"/>        });
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Finally, we have to implement the <kbd class="calibre15">getAge()</kbd> method used previously in the code. This method receives the date of birth of a <kbd class="calibre15">Person</kbd> object and returns its age:</li>
</ol>
<pre class="calibre23">
        private static long getAge(Date birthDate) { <br class="title-page-name"/>          LocalDate start = birthDate.toInstant()<br class="title-page-name"/>                        .atZone(ZoneId.systemDefault()).toLocalDate(); <br class="title-page-name"/>          LocalDate now = LocalDate.now(); <br class="title-page-name"/>          long ret = ChronoUnit.YEARS.between(start, now); <br class="title-page-name"/>          return ret; <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe you learnt how to convert the elements of the stream using an intermediate operation and an expression that makes the conversion between the source and the destination types. We used three different methods in our example:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">mapToDouble()</kbd>: We used this method to convert <kbd class="calibre15">Stream</kbd> of objects into <kbd class="calibre15">DoubleStream</kbd> with double numbers as elements. This method receives as parameter a lambda expression or an implementation of the <kbd class="calibre15">ToDoubleFunction</kbd> interface. This expression receives an element of <kbd class="calibre15">Stream</kbd> and has to return a double value.</li>
<li class="calibre18"><kbd class="calibre15">map()</kbd>: We can use this method when we have to convert the elements of <kbd class="calibre15">Stream</kbd> to a different class. For example, in our case, we convert the <kbd class="calibre15">Person</kbd> class to a <kbd class="calibre15">BasicPerson</kbd> class. This method receives as parameter a lambda expression or an implementation of the <kbd class="calibre15">Function</kbd> interface. This expression must create the new object and initialize its attributes.</li>
<li class="calibre18"><kbd class="calibre15">flatMap()</kbd>: This method is useful in a more complex situation when you have to work with a <kbd class="calibre15">Stream</kbd> of <kbd class="calibre15">Stream</kbd> objects and you want to convert them to a unique <kbd class="calibre15">Stream</kbd>. This method receives as parameter a lambda expression or an implementation of the <kbd class="calibre15">Function</kbd> interface as the <kbd class="calibre15">map()</kbd> function, but in this case, this expression has to return a <kbd class="calibre15">Stream</kbd> object. The <kbd class="calibre15">flatMap()</kbd> method will automatically concatenate all those streams into a unique <kbd class="calibre15">Stream</kbd>.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">Stream</kbd> class provides other methods to transform the elements of a <kbd class="calibre15">Stream</kbd>:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">mapToInt()</kbd>, <kbd class="calibre15">mapToLong()</kbd>: These methods are identical to the <kbd class="calibre15">mapToDouble()</kbd> method, but they generate <kbd class="calibre15">IntStream</kbd> and <kbd class="calibre15">LongStream</kbd> objects, respectively.</li>
<li class="calibre18"><kbd class="calibre15">flatMapToDouble()</kbd>, <kbd class="calibre15">flatMapToInt()</kbd>, <kbd class="calibre15">flatMapToLong()</kbd>: These methods are identical to the <kbd class="calibre15">flatMap()</kbd> method, but they work with <kbd class="calibre15">DoubleStream</kbd>, <kbd class="calibre15">IntStream</kbd>, and <kbd class="calibre15">LongStream</kbd>, respectively.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating streams from different sources</em>, <em class="calibre14">Reducing the elements of a stream</em> and <em class="calibre14">Collecting the elements of a stream recipes</em> <span>in </span><span>this chapter</span></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Sorting the elements of a stream</h1>
            

            <article>
                
<p class="calibre4">Another typical operation you will want to do with a <kbd class="calibre15">Stream</kbd> is sorting its elements. For example, you may want to sort the elements of the <kbd class="calibre15">Stream</kbd> by name, postal code, or any other numeric value.</p>
<p class="calibre4">With streams, we have other considerations with the so-called encounter order. Some streams may have a defined encounter order (it depends on the source of the <kbd class="calibre15">Stream</kbd>). Some operations work with the elements of the stream in its encountered ordered, such as <kbd class="calibre15">limit()</kbd>, <kbd class="calibre15">skip()</kbd>, and others. This makes that parallel computation for this methods doesn't give us good performance. In these cases, you can speed-up the execution of these methods by deleting the ordering constraint.</p>
<p class="calibre4">In this recipe, you will learn how to sort the elements of <kbd class="calibre15">Stream</kbd> and how to delete the ordering constraint in situations where we don't need the encounter order of <kbd class="calibre15">Stream</kbd>.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">First, we'll implement some auxiliary classes we will use in the example. First, implement the <kbd class="calibre15">Person</kbd> class, which stores the basic attributes of a person, and the <kbd class="calibre15">PersonGenerator</kbd> class, which generates a <kbd class="calibre15">List</kbd> of random <kbd class="calibre15">Person</kbd> objects. Please, check the recipe <em class="calibre14">Apply an action to all the elements of a stream</em> to see the source code of both the classes.</li>
<li value="2" class="calibre18">Now, implement the <kbd class="calibre15">Main</kbd> class with the <kbd class="calibre15">main()</kbd> method. First, we'll create an <kbd class="calibre15">Array</kbd> of <kbd class="calibre15">int</kbd> numbers. Then, we'll create a parallel stream with the <kbd class="calibre15">parallelStream()</kbd> method from this array, use the <kbd class="calibre15">sorted()</kbd> method to sort the elements of the array, and use the <kbd class="calibre15">forEachOrdered()</kbd> method to write the elements in an ordered way. Take into account that this operation won't use all the power of our multi-core processor as it has to write the elements in the specified order:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String args[]) { <br class="title-page-name"/>            int[] numbers={9,8,7,6,5,4,3,2,1,2,3,4,5,6,7,8,9}; <br class="title-page-name"/>            Arrays.stream(numbers).parallel().sorted().forEachOrdered<br class="title-page-name"/>                                                                (n -&gt; { <br class="title-page-name"/>            System.out.printf("%d\n", n); <br class="title-page-name"/>          });
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Now, let's try the same principles with a <kbd class="calibre15">Stream</kbd> of <kbd class="calibre15">Person</kbd> objects. Create a list of 10 random <kbd class="calibre15">Person</kbd> objects using the <kbd class="calibre15">PersonGenerator</kbd> class and use the same methods, <kbd class="calibre15">sorted()</kbd> and <kbd class="calibre15">forEachOrdered()</kbd>, to see how the persons are written in an ordered way:</li>
</ol>
<pre class="calibre23">
        List&lt;Person&gt; persons=PersonGenerator.generatePersonList(10); <br class="title-page-name"/>        persons.parallelStream().sorted().forEachOrdered(p -&gt; { <br class="title-page-name"/>          System.out.printf("%s, %s\n",p.getLastName(),p.getFirstName()); <br class="title-page-name"/>        });
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Finally, we'll see how to eliminate the encounter order of a data structure using the <kbd class="calibre15">unordered()</kbd> method. First, we'll create <kbd class="calibre15">TreeSet</kbd> from our <kbd class="calibre15">List</kbd> of random <kbd class="calibre15">Person</kbd> objects. We use <kbd class="calibre15">TreeSet</kbd> because it orders the elements internally. Then, we make a loop to repeat the operations ten times and see how there's a difference between the ordered and the unordered operations:</li>
</ol>
<pre class="calibre23">
        TreeSet&lt;Person&gt; personSet=new TreeSet&lt;&gt;(persons); <br class="title-page-name"/>        for (int i=0; i&lt;10; i++) {
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Then, we create a stream from <kbd class="calibre15">PersonSet</kbd> using the <kbd class="calibre15">stream()</kbd> method, convert it to parallel with the <kbd class="calibre15">parallel()</kbd> method, get the first element with the <kbd class="calibre15">limit()</kbd> method, and return the <kbd class="calibre15">Person</kbd> object, collecting it to a list and getting the first element:</li>
</ol>
<pre class="calibre23">
        Person person= personSet.stream().parallel().limit(1)<br class="title-page-name"/>                                .collect(Collectors.toList()).get(0); <br class="title-page-name"/>        System.out.printf("%s %s\n", person.getFirstName(),<br class="title-page-name"/>                          person.getLastName());
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Now, we perform the same operation but remove the ordered constraint with the <kbd class="calibre15">unordered()</kbd> method between the <kbd class="calibre15">stream()</kbd> and <kbd class="calibre15">parallel()</kbd> methods:</li>
</ol>
<pre class="calibre23">
        person=personSet.stream().unordered().parallel().limit(1)<br class="title-page-name"/>                                .collect(Collectors.toList()).get(0); <br class="title-page-name"/>        System.out.printf("%s %s\n", person.getFirstName(),<br class="title-page-name"/>                          person.getLastName());
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">There are <kbd class="calibre15">Stream</kbd> objects that may have an encounter order depending on its source and the intermediate operations you have applied before. This encounter order imposes a restriction about the order in which the elements must be processed by certain methods. For example, if you use the <kbd class="calibre15">limit()</kbd> or <kbd class="calibre15">skip()</kbd> methods in <kbd class="calibre15">Stream</kbd> with an encounter order, they will get and ignore the first elements according to that encounter order. There are other operations, such as the <kbd class="calibre15">forEach()</kbd> method, that don't take into account the encounter order. If you apply the same operations to a stream with an encounter order, the result will always be the same. If the stream doesn't have an encounter order, the results may vary.</p>
<p class="calibre4">When you work with sequential streams, the encounter order doesn't have any impact on the performance of the application, but with parallel streams it can affect it greatly. Depending on the operations, it would be necessary to process more than once the elements of <kbd class="calibre15">Stream</kbd> or to store in a buffer a big amount of data. In this case, removing the encounter order using the <kbd class="calibre15">unordered()</kbd> method, as we did in this recipe, will significantly increase the performance of the application.</p>
<p class="calibre4">On the other hand, the <kbd class="calibre15">sorted()</kbd> method sorts the elements of the <kbd class="calibre15">Stream</kbd>. If you use this method, the elements of <kbd class="calibre15">Stream</kbd> must implement the <kbd class="calibre15">Comparable</kbd> interface. Otherwise, you can pass a <kbd class="calibre15">Comparator</kbd> as a parameter that will be used to sort the elements. If you use this method, you are creating an ordered stream, so all the things explained before to the streams with an encounter order are applicable to the resultant stream.</p>
<p class="calibre4">Finally, the <kbd class="calibre15">forEach()</kbd> method doesn't take into account the encounter order of the stream. If you want to take this encounter order into account, say, to write the elements of the stream order after sorting them, you can use the <kbd class="calibre15">forEachOrdered()</kbd> method.</p>
<p class="calibre4">The following screenshot shows part of the output of the example:</p>
<div class="cdpaligncenter"><img class="alignnone25" src="../images/00041.jpeg"/></div>
<p class="calibre4">You can see that when you call the <kbd class="calibre15">limit(1)</kbd> method in the parallel stream generated from <kbd class="calibre15">TreeSet</kbd>, you always obtain the same result because the Stream API respects the encounter order of that structure. But when we include a call to the <kbd class="calibre15">unordered()</kbd> method, the encounter order is not taken into account and the result obtained should vary, as in this case.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">When you use the <kbd class="calibre15">unordered()</kbd> method, you're not executing any code that internally changes the order of the elements in the data structure. You're only deleting a condition that would be taken into account for some methods otherwise. It's possible that the results of a stream with the <kbd class="calibre15">unordered()</kbd> method and the results of the same stream without the method are equal. Its use may have consequences in possibly giving different processing results for parallel streams. For example, if you try our example using a <kbd class="calibre15">List</kbd> of <kbd class="calibre15">Person</kbd> objects instead of <kbd class="calibre15">personSet</kbd> a <kbd class="calibre15">TreeSet</kbd>, you will always obtain the same result in both the cases.</p>
<p class="calibre4">As we mentioned before, the main purpose of the <kbd class="calibre15">unordered()</kbd> method is to delete a constraint that limits the performance of parallel streams.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating streams from different sources</em>, <em class="calibre14">Reducing the elements of a stream</em> and <em class="calibre14">Collecting the elements of a stream</em> recipes <span>in </span><span>this chapter</span></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Verifying conditions in the elements of a stream</h1>
            

            <article>
                
<p class="calibre4">One interesting option provided by the <kbd class="calibre15">Stream</kbd> class is the possibility to check if the elements of the stream verify a condition or not. This functionality is provided by the terminal operations that return a <kbd class="calibre15">Boolean</kbd> value.</p>
<p class="calibre4">In this recipe, you will learn which methods provide the <kbd class="calibre15">Stream</kbd> class to check conditions in the elements of a stream and how to use them.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">First, we'll implement some auxiliary classes we will use in the example. First, implement the <kbd class="calibre15">Person</kbd> class, which stores the basic attributes of a person, and the <kbd class="calibre15">PersonGenerator</kbd> class, which generates a <kbd class="calibre15">List</kbd> of random <kbd class="calibre15">Person</kbd> objects. Please, check the recipe <em class="calibre14">Apply an action to all the elements of a stream</em> to see the source code of both classes.</li>
<li value="2" class="calibre18">Then, create the <kbd class="calibre15">Main</kbd> class with the <kbd class="calibre15">main()</kbd> method. First, we'll create a <kbd class="calibre15">List</kbd> of random <kbd class="calibre15">Person</kbd> objects using the <kbd class="calibre15">PersonGenerator</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) { <br class="title-page-name"/>            List&lt;Person&gt; persons=PersonGenerator.generatePersonList(10);
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Then, calculate the maximum and minimum values of the salary field to verify that all our calculations are correct. We use two streams for the calculation, the first one with the <kbd class="calibre15">map()</kbd> and <kbd class="calibre15">max()</kbd> methods and the second one with the <kbd class="calibre15">mapToInt()</kbd> and <kbd class="calibre15">min()</kbd> methods:</li>
</ol>
<pre class="calibre23">
        int maxSalary = persons.parallelStream().map(p -&gt; p.getSalary())<br class="title-page-name"/>                                        .max(Integer::compare).get(); <br class="title-page-name"/>        int minSalary = persons.parallelStream().mapToInt(p -&gt; p<br class="title-page-name"/>                                        .getSalary()).min().getAsInt(); <br class="title-page-name"/>        System.out.printf("Salaries are between %d and %d\n", minSalary,<br class="title-page-name"/>                          maxSalary);
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Now, we'll test some conditions. First, let's verify that all the <kbd class="calibre15">Person</kbd> objects generated have a salary greater than zero with the <kbd class="calibre15">allMatch()</kbd> method and the corresponding lambda expression:</li>
</ol>
<pre class="calibre23">
        boolean condition; <br class="title-page-name"/>        condition=persons.parallelStream().allMatch<br class="title-page-name"/>                                              (p -&gt; p.getSalary() &gt; 0); <br class="title-page-name"/>        System.out.printf("Salary &gt; 0: %b\n", condition);
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">We repeat the condition to test if all the salaries are greater than 10,000 and 30,000.</li>
</ol>
<pre class="calibre23">
        condition=persons.parallelStream().allMatch<br class="title-page-name"/>                                          (p -&gt; p.getSalary() &gt; 10000); <br class="title-page-name"/>        System.out.printf("Salary &gt; 10000: %b\n",condition); <br class="title-page-name"/>        condition=persons.parallelStream().allMatch<br class="title-page-name"/>                                          (p -&gt; p.getSalary() &gt; 30000); <br class="title-page-name"/>        System.out.printf("Salary &gt; 30000: %b\n",condition);
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Then, we'll use the <kbd class="calibre15">anyMatch()</kbd> method to test if there is someone with a salary greater than 50,000 and 100,000:</li>
</ol>
<pre class="calibre23">
        condition=persons.parallelStream().anyMatch<br class="title-page-name"/>                                         (p -&gt; p.getSalary() &gt; 50000); <br class="title-page-name"/>        System.out.printf("Any with salary &gt; 50000: %b\n",condition); <br class="title-page-name"/>        condition=persons.parallelStream().anyMatch<br class="title-page-name"/>                                         (p -&gt; p.getSalary() &gt; 100000); <br class="title-page-name"/>        System.out.printf("Any with salary &gt; 100000: %b\n",condition);
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">To finish this block of tests, we use the <kbd class="calibre15">noneMatch()</kbd> method to verify that there's none with a salary greater than 100,000</li>
</ol>
<pre class="calibre23">
        condition=persons.parallelStream().noneMatch<br class="title-page-name"/>                                         (p -&gt; p.getSalary() &gt; 100000); <br class="title-page-name"/>        System.out.printf("None with salary &gt; 100000: %b\n",condition);
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">After that, we use the <kbd class="calibre15">findAny()</kbd> method to get a random element of the stream of <kbd class="calibre15">Person</kbd> objects:</li>
</ol>
<pre class="calibre23">
        Person person = persons.parallelStream().findAny().get(); <br class="title-page-name"/>        System.out.printf("Any: %s %s: %d\n", person.getFirstName(),<br class="title-page-name"/>                          person.getLastName(), person.getSalary());
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Then, we use the <kbd class="calibre15">findFirst()</kbd> method to get the first element of the stream of Person objects:</li>
</ol>
<pre class="calibre23">
        person = persons.parallelStream().findFirst().get(); <br class="title-page-name"/>        System.out.printf("First: %s %s: %d\n", person.getFirstName(),<br class="title-page-name"/>                          person.getLastName(), person.getSalary());
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Finally, we sort the stream by salary using the <kbd class="calibre15">sorted()</kbd> method, passing <kbd class="calibre15">Comparator</kbd> expressed as a lambda expression, and use the <kbd class="calibre15">findFirst()</kbd> method to obtain, in this case, the <kbd class="calibre15">Person</kbd> object with the lowest salary:</li>
</ol>
<pre class="calibre23">
        person = persons.parallelStream().sorted((p1,p2) -&gt; {  <br class="title-page-name"/>          return p1.getSalary() - p2.getSalary(); <br class="title-page-name"/>        }).findFirst().get(); <br class="title-page-name"/>        System.out.printf("First Sorted: %s %s: %d\n",<br class="title-page-name"/>                          person.getFirstName(), person.getLastName(),<br class="title-page-name"/>                          person.getSalary());
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, we used three different methods to verify conditions over the elements of a Stream:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">allMatch()</kbd>: This method is a terminal operation that receives as parameter an implementation of the <kbd class="calibre15">Predicate</kbd> interface expressed as a lambda expression or as an object that implements it and returns a <kbd class="calibre15">Boolean</kbd> value. It returns <kbd class="calibre15">true</kbd> if the <kbd class="calibre15">Predicate</kbd> introduced is true for all the elements of the <kbd class="calibre15">Stream</kbd> and <kbd class="calibre15">false</kbd> otherwise.</li>
<li class="calibre18"><kbd class="calibre15">anyMatch()</kbd>: This method is a terminal operation that receives as parameter an implementation of the <kbd class="calibre15">Predicate</kbd> interface expressed as a lambda expression or as an object that implements it and returns a <kbd class="calibre15">Boolean</kbd> value. It returns <kbd class="calibre15">true</kbd> if the <kbd class="calibre15">Predicate</kbd> introduced is <kbd class="calibre15">true</kbd> for at least one of the elements of the <kbd class="calibre15">Stream</kbd> and <kbd class="calibre15">false</kbd> otherwise.</li>
<li class="calibre18"><kbd class="calibre15">noneMatch()</kbd>: This method is a terminal operation that receives as parameter a <kbd class="calibre15">Predicate</kbd> expressed as a lambda expression or as an implementation of interface and returns a <kbd class="calibre15">Boolean</kbd> value. It returns <kbd class="calibre15">true</kbd> if the <kbd class="calibre15">Predicate</kbd> introduced is false for all the elements of the Stream and <kbd class="calibre15">false</kbd> otherwise.</li>
</ul>
<p class="calibre4">We also used two methods to obtain the elements of <kbd class="calibre15">Stream</kbd>:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">findAny()</kbd>: This method is a terminal operation that doesn't receive parameters and returns an <kbd class="calibre15">Optional</kbd> object parameterized with the class of the elements of <kbd class="calibre15">Stream</kbd> with some element of <kbd class="calibre15">Stream</kbd>. There's no guarantee about the element returned by this method. If <kbd class="calibre15">Stream</kbd> has no elements, the <kbd class="calibre15">Optional</kbd> object returned will be empty.</li>
<li class="calibre18"><kbd class="calibre15">findFirst()</kbd>: This method is a terminal operation that doesn't receive parameters and returns an <kbd class="calibre15">Optional</kbd> parameterized with the class of the elements of <kbd class="calibre15">Stream</kbd>. It returns the first element of <kbd class="calibre15">Stream</kbd> if the stream has a determined encounter order or any element if the stream has no encounter order. If <kbd class="calibre15">Stream</kbd> has no elements, the <kbd class="calibre15">Optional</kbd> returned will be empty.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">In this recipe we used an interface and a class provided by the Java API. The <kbd class="calibre15">Predicate</kbd> interface is a functional interface that is usually expressed as a lambda expression. This expression will receive an element of <kbd class="calibre15">Stream</kbd> and return a <kbd class="calibre15">Boolean</kbd> value. If you want to implement a class that implements this interface, you only have to implement the <kbd class="calibre15">test()</kbd> method that receives an object of the parameterized type and returns a <kbd class="calibre15">Boolean</kbd> value. The interface defines more methods, but they have a default implementation.</p>
<p class="calibre4">The <kbd class="calibre15">Optional</kbd> class is used when a terminal operation of <kbd class="calibre15">Stream</kbd> may or may not return a value. In this way, Java guarantees that the operation will always return a value, the <kbd class="calibre15">Optional</kbd> object, that may have a value we obtain using the <kbd class="calibre15">get()</kbd> method or may be an empty object, the condition we can check with the <kbd class="calibre15">isPresent()</kbd> method. If you use the <kbd class="calibre15">get()</kbd> method with an empty <kbd class="calibre15">Optional</kbd> object, a <kbd class="calibre15">NoSuchElementException</kbd> will be thrown.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating streams from different sources</em>, <em class="calibre14">Reducing the elements of a stream</em> and <em class="calibre14">Collecting the elements of a stream</em> recipes <span>in </span><span>this chapter</span></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Reactive programming with reactive streams</h1>
            

            <article>
                
<p class="calibre4"><strong class="calibre1">Reactive streams</strong> (<a href="http://www.reactive-streams.org/" class="calibre9"><span>http://www.reactive-streams.org/</span></a>) define a mechanism to provide asynchronous stream processing with non-blocking back pressure.</p>
<p class="calibre4">Reactive streams are based on the following three elements:</p>
<ul class="calibre17">
<li class="calibre18">A publisher of information</li>
<li class="calibre18">One or more subscribers of that information</li>
<li class="calibre18">A subscription between the publisher and a consumer</li>
</ul>
<p class="calibre4">The reactive streams specification determines how these classes should interact among them, according to the following rules:</p>
<ul class="calibre17">
<li class="calibre18">The publisher will add the subscribers that want to be notified</li>
<li class="calibre18">The subscriber receives a notification when they're added to a publisher</li>
<li class="calibre18">The subscribers request one or more elements from the publisher in an asynchronous way, that is to say, the subscriber requests the element and continues with the execution</li>
<li class="calibre18">When the publisher has an element to publish, it sends it to all its subscribers that have requested an element</li>
</ul>
<p class="calibre4">As we mentioned before, all this communication is asynchronous, so we can take advantage of all the power of our multi-core processor.</p>
<p class="calibre4">Java 9 has included three interfaces, the <kbd class="calibre15">Flow.Publisher</kbd>, the <kbd class="calibre15">Flow.Subscriber</kbd>, and the <kbd class="calibre15">Flow.Subscription</kbd>, and a utility class, the <kbd class="calibre15">SubmissionPublisher</kbd> class, to allow us to implement reactive stream applications. In this recipe, you will learn how to use all these elements to implement a basic reactive stream application.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Item</kbd> that will represent the items of information sent from the publisher to the subscribers. This class has two <kbd class="calibre15">String</kbd> attributes, named <kbd class="calibre15">title</kbd> and <kbd class="calibre15">content</kbd>, and the methods to <kbd class="calibre15">get()</kbd> and <kbd class="calibre15">set()</kbd> their values. Its source code is very simple, so it won't be included here.</li>
<li value="2" class="calibre18">Then, create a class named <kbd class="calibre15">Consumer1</kbd> and specify that it implements the <kbd class="calibre15">Subscriber</kbd> interface parameterized with the <kbd class="calibre15">Item</kbd> class. We have to implement four methods. First, we implement the <kbd class="calibre15">onComplete()</kbd> method. It simply writes a message to the console:</li>
</ol>
<pre class="calibre23">
        public class Consumer1 implements Flow.Subscriber&lt;Item&gt; { <br class="title-page-name"/> <br class="title-page-name"/>          @Override <br class="title-page-name"/>          public void onComplete() { <br class="title-page-name"/>            System.out.printf("%s: Consumer 1: Completed\n",<br class="title-page-name"/>                              Thread.currentThread().getName()); <br class="title-page-name"/>          <br class="title-page-name"/>          }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Then, we implement the <kbd class="calibre15">onError()</kbd> method. It simply writes information about the error to the console:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void onError(Throwable exception) { <br class="title-page-name"/>          System.out.printf("%s: Consumer 1: Error\n",<br class="title-page-name"/>                            Thread.currentThread().getName()); <br class="title-page-name"/>          exception.printStackTrace(System.err); <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Then, we implement the <kbd class="calibre15">onNext()</kbd> method. It simply writes information about the received item to the console:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void onNext(Item item) { <br class="title-page-name"/>          System.out.printf("%s: Consumer 1: Item received\n",<br class="title-page-name"/>                            Thread.currentThread().getName()); <br class="title-page-name"/>          System.out.printf("%s: Consumer 1: %s\n",<br class="title-page-name"/>                            Thread.currentThread().getName(),<br class="title-page-name"/>                            item.getTitle()); <br class="title-page-name"/>          System.out.printf("%s: Consumer 1: %s\n",<br class="title-page-name"/>                            Thread.currentThread().getName(),<br class="title-page-name"/>                            item.getContent()); <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">And finally, we implement the <kbd class="calibre15">onSubscribe()</kbd> method. It simply writes a message to the console and doesn't request any item using the <kbd class="calibre15">request()</kbd> method of the <kbd class="calibre15">Subscription</kbd> object:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void onSubscribe(Flow.Subscription subscription) { <br class="title-page-name"/>          System.out.printf("%s: Consumer 1: Subscription received\n",<br class="title-page-name"/>                            Thread.currentThread().getName()); <br class="title-page-name"/>          System.out.printf("%s: Consumer 1: No Items requested\n",<br class="title-page-name"/>                            Thread.currentThread().getName()); <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Now, it's time for the <kbd class="calibre15">Consumer2</kbd> class. Specify that it also implements the <kbd class="calibre15">Subscriber</kbd> interface parameterized with the <kbd class="calibre15">Item</kbd> class. In this case, we have a private <kbd class="calibre15">Subscription</kbd> attribute to store the subscription object. The <kbd class="calibre15">onComplete()</kbd> and <kbd class="calibre15">onError()</kbd> methods are equivalent to the ones of the <kbd class="calibre15">Consumer1</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class Consumer2 implements Flow.Subscriber&lt;Item&gt; { <br class="title-page-name"/>    <br class="title-page-name"/>          private Subscription subscription; <br class="title-page-name"/> <br class="title-page-name"/>          @Override <br class="title-page-name"/>          public void onComplete() { <br class="title-page-name"/>            System.out.printf("%s: Consumer 2: Completed\n",<br class="title-page-name"/>                              Thread.currentThread().getName());      <br class="title-page-name"/>          }
</pre>
<pre class="calibre23">
          @Override <br class="title-page-name"/>          public void onError(Throwable exception) { <br class="title-page-name"/>            System.out.printf("%s: Consumer 2: Error\n",<br class="title-page-name"/>                              Thread.currentThread().getName()); <br class="title-page-name"/>            exception.printStackTrace(System.err); <br class="title-page-name"/>          }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">The <kbd class="calibre15">onNext()</kbd> method has an additional line to request another element:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void onNext(Item item) { <br class="title-page-name"/>          System.out.printf("%s: Consumer 2: Item received\n",<br class="title-page-name"/>                            Thread.currentThread().getName()); <br class="title-page-name"/>          System.out.printf("%s: Consumer 2: %s\n",<br class="title-page-name"/>                            Thread.currentThread().getName(),<br class="title-page-name"/>                            item.getTitle()); <br class="title-page-name"/>          System.out.printf("%s: Consumer 2: %s\n",<br class="title-page-name"/>                            Thread.currentThread().getName(),<br class="title-page-name"/>                            item.getContent()); <br class="title-page-name"/>          subscription.request(1); <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">The <kbd class="calibre15">onSubscribe()</kbd> method also has an additional line to request the first element:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void onSubscribe(Flow.Subscription subscription) { <br class="title-page-name"/>          System.out.printf("%s: Consumer 2: Subscription received\n",<br class="title-page-name"/>                            Thread.currentThread().getName()); <br class="title-page-name"/>          this.subscription=subscription; <br class="title-page-name"/>          subscription.request(1); <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Now, implement a class called <kbd class="calibre15">Consumer3</kbd> and specify that it implements the <kbd class="calibre15">Subscriber</kbd> interface parameterized with the <kbd class="calibre15">Item</kbd> class. The <kbd class="calibre15">onComplete()</kbd> and <kbd class="calibre15">onError()</kbd> methods are equivalent to those of the previous classes:</li>
</ol>
<pre class="calibre23">
        public class Consumer3 implements Flow.Subscriber&lt;Item&gt; { <br class="title-page-name"/> <br class="title-page-name"/>          @Override <br class="title-page-name"/>          public void onComplete() { <br class="title-page-name"/>            System.out.printf("%s: Consumer 3: Completed\n",<br class="title-page-name"/>                              Thread.currentThread().getName()); <br class="title-page-name"/>          <br class="title-page-name"/>          }
</pre>
<pre class="calibre23">
  <br class="title-page-name"/>          @Override <br class="title-page-name"/>          public void onError(Throwable exception) { <br class="title-page-name"/>            System.out.printf("%s: Consumer 3: Error\n",<br class="title-page-name"/>                              Thread.currentThread().getName()); <br class="title-page-name"/>            exception.printStackTrace(System.err); <br class="title-page-name"/>          }
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">The <kbd class="calibre15">onNext()</kbd> method, in this case, writes information about the item to the console but doesn't request any element:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void onNext(Item item) { <br class="title-page-name"/>          System.out.printf("%s: Consumer 3: Item received\n",<br class="title-page-name"/>                            Thread.currentThread().getName()); <br class="title-page-name"/>          System.out.printf("%s: Consumer 3: %s\n",<br class="title-page-name"/>                            Thread.currentThread().getName(),<br class="title-page-name"/>                            item.getTitle()); <br class="title-page-name"/>          System.out.printf("%s: Consumer 3: %s\n",<br class="title-page-name"/>                            Thread.currentThread().getName(),<br class="title-page-name"/>                            item.getContent()); <br class="title-page-name"/>        }
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">In the <kbd class="calibre15">onSubscribe()</kbd>, method we request three items:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void onSubscribe(Flow.Subscription subscription) { <br class="title-page-name"/>          System.out.printf("%s: Consumer 3: Subscription received\n",<br class="title-page-name"/>                            Thread.currentThread().getName()); <br class="title-page-name"/>          System.out.printf("%s: Consumer 3: Requested three items\n",<br class="title-page-name"/>                            Thread.currentThread().getName()); <br class="title-page-name"/>          subscription.request(3); <br class="title-page-name"/>        }
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Finally, implement the <kbd class="calibre15">Main</kbd> class with the <kbd class="calibre15">main()</kbd> method. First, create three consumers, one of each class:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) { <br class="title-page-name"/> <br class="title-page-name"/>            Consumer1 consumer1=new Consumer1(); <br class="title-page-name"/>            Consumer2 consumer2=new Consumer2(); <br class="title-page-name"/>            Consumer3 consumer3=new Consumer3();
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Now, create a <kbd class="calibre15">SubmissionPublisher</kbd> object parameterized with the <kbd class="calibre15">Item</kbd> class and add the three consumers using the <kbd class="calibre15">subscribe()</kbd> method:</li>
</ol>
<pre class="calibre23">
        SubmissionPublisher&lt;Item&gt; publisher=new SubmissionPublisher&lt;&gt;(); <br class="title-page-name"/>          <br class="title-page-name"/>        publisher.subscribe(consumer1); <br class="title-page-name"/>        publisher.subscribe(consumer2); <br class="title-page-name"/>        publisher.subscribe(consumer3);
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Now, create ten <kbd class="calibre15">Item</kbd> objects and publish them using the <kbd class="calibre15">submit()</kbd> method of the <kbd class="calibre15">SubmissionPublisher</kbd> object. Wait a second between each item:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;10; i++) { <br class="title-page-name"/>          Item item =new Item(); <br class="title-page-name"/>          item.setTitle("Item "+i); <br class="title-page-name"/>          item.setContent("This is the item "+i); <br class="title-page-name"/>          publisher.submit(item); <br class="title-page-name"/>          try { <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Finally, close the publisher with the <kbd class="calibre15">close()</kbd> method:</li>
</ol>
<pre class="calibre23">
            publisher.close(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The main goal of reactive streams is provide a mechanism to process asynchronous stream of data with non-blocking back pressure. We want that the receivers of information optimize their resources. As the mechanism is asynchronous, receivers don't need to use their resources to look for new elements. They will be called when a new element comes in. The non-blocking back pressure allows receivers to consume new elements only when the receivers are ready, so they can use a bounded queue to store the incoming elements and they won't be saturated by producers of new elements.</p>
<p class="calibre4">The reactive streams in Java are based on three interfaces:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">Flow.Publisher</kbd>: This interface has only one method:
<ul class="calibre24">
<li class="calibre18"><kbd class="calibre15">subscribe()</kbd>: This method receives a <kbd class="calibre15">Subscriber</kbd> object as parameter. The publisher should take this subscriber into account when it publishes an Item.</li>
</ul>
</li>
<li class="calibre18"><kbd class="calibre15">Flow.Subscriber</kbd>: This interface has four methods:
<ul class="calibre24">
<li class="calibre18"><kbd class="calibre15">onComplete()</kbd>: This method will be called when the <kbd class="calibre15">Publisher</kbd> has finished its execution</li>
<li class="calibre18"><kbd class="calibre15">onError()</kbd>: This method will be called when there is an error that must be notified to the subscribers</li>
<li class="calibre18"><kbd class="calibre15">onNext()</kbd>: This method will be called when the <kbd class="calibre15">Publisher</kbd> has a new element</li>
<li class="calibre18"><kbd class="calibre15">onSubscribe()</kbd>: This method will be called when the publisher has added the subscriber with the <kbd class="calibre15">subscribe()</kbd> method</li>
</ul>
</li>
<li class="calibre18"><kbd class="calibre15">Flow.Subscription</kbd>: This interface has one methods:
<ul class="calibre24">
<li class="calibre18"><kbd class="calibre15">request()</kbd>: This method is used by the <kbd class="calibre15">Subscriber</kbd> to request an element from the publisher</li>
</ul>
</li>
</ul>
<p class="calibre4">Take into account that these are only interfaces and you can implement them and use them as you want. The supposed flow is as follows:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Someone calls the <kbd class="calibre15">subscribe()</kbd> method of a <kbd class="calibre15">Publisher</kbd>, sending it a <kbd class="calibre15">Subscriber</kbd>.</li>
<li value="2" class="calibre18">The <kbd class="calibre15">Publisher</kbd> creates a <kbd class="calibre15">Subscription</kbd> object and sends it to the <kbd class="calibre15">onSubscribe()</kbd> method of the <kbd class="calibre15">Subscriber</kbd>.</li>
<li value="3" class="calibre18">The <kbd class="calibre15">Subscriber</kbd> uses the <kbd class="calibre15">request()</kbd> method of the <kbd class="calibre15">Subscription</kbd> to request elements to the <kbd class="calibre15">Publisher</kbd>.</li>
<li value="4" class="calibre18">When the publisher has an element to publish, it sends them to all <kbd class="calibre15">Subscribers</kbd> that have requested elements, calling their <kbd class="calibre15">onNext()</kbd> method.</li>
<li value="5" class="calibre18">When the publisher ends its execution, it calls the <kbd class="calibre15">onComplete()</kbd> method of the subscribers.</li>
</ol>
<p class="calibre4">Java API provides the <kbd class="calibre15">SubmissionPublisher</kbd> class that implements the Publisher interface and implements this behavior.</p>
<p class="calibre4">The following screenshot shows the output of the example and you can see how the behavior of the reactive streams is as expected:</p>
<div class="cdpaligncenter"><img class="alignnone26" src="../images/00042.jpeg"/></div>
<p class="calibre4">The three <kbd class="calibre15">Subscriber</kbd> objects receive their <kbd class="calibre15">Subscription</kbd>. As <kbd class="calibre15">Consumer1</kbd> doesn't request any <kbd class="calibre15">Item</kbd>, it won't receive them. <kbd class="calibre15">Consumer3</kbd> has requested three, so you will see in the output of the example that it will receive those three <kbd class="calibre15">Item</kbd> objects. Finally, the <kbd class="calibre15">Consumer2</kbd> object will receive the ten <kbd class="calibre15">Item</kbd> objects and the notification about the end of execution of the <kbd class="calibre15">Publisher</kbd>.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">There is an additional interface that should be used with reactive streams. It's the <kbd class="calibre15">Flow.Processor</kbd> interface and groups the <kbd class="calibre15">Flow.Publisher</kbd> and the <kbd class="calibre15">Flow.Subscriber</kbd> interfaces. Its main purpose is to be an element between a publisher and a subscriber to transform the elements produced by the first one into a format that can be processed by the second one. You can have more than one processors in a chain so the output of one of them could be processed by the next one.</p>
<p class="calibre4">Java also defines the <kbd class="calibre15">Flow</kbd> class that includes the four interfaces explained before.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    </body></html>