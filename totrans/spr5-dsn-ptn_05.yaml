- en: Understanding the Bean Life Cycle and Used Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you saw how Spring creates beans in the container.
    You also learned how to configure the dependency injection pattern using XML,
    Java, and Annotation. In this chapter, we will go into more detail, beyond injecting
    beans and the configuration of dependencies in a Spring application. Here, you
    will explore the life and scope of beans in the container, and learn how the Spring
    container works on the defined Spring bean configuration with XML, Annotation,
    and Java. Spring allows us to control not only the various configurations for
    the DI pattern and dependency values that are to be injected into the object created
    from a particular bean definition, but also the life and scope of the beans created
    from a particular bean definition.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: When I was writing this chapter, my two and a half year old son, Arnav, came
    to me and started playing a video game on my mobile. He was wearing a T-Shirt,
    which had an interesting quote on it, and these lines described his whole day.
    The lines went like this--
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '*My Perfect Day: Wake up, Play Video Games, Eat, Play Video Games, Eat, Play
    Video Games, and Sleep*.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Actually, these lines perfectly reflected his life cycle for each day, as he
    woke up, played, ate, and played again before, finally, going to sleep. With this
    example, I just wanted to demonstrate that everything has a life cycle. We could
    discuss the life cycle of a butterfly, a star, a frog, or a plant. But let's talk
    about something more interesting--the life cycle of a bean!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'Every bean in the Spring container has a life cycle and its own scope. The
    Spring container manages the life of the beans in a Spring application. We can
    customize it in some phases by using Spring-aware interfaces. This chapter will
    talk about the life of a bean in the container, and how it is managed using design
    patterns in the various phases of its life. By the end of this chapter, you would
    have a fair idea of the bean life cycle and its various phases in the container.
    You will also learn about the many types of bean scope in Spring. This chapter
    will cover the following points:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'The Spring bean life cycle, and its phases, which are listed as follows:'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initialization phase
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Use phase
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The destruction phase
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring callbacks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding bean scopes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Singleton pattern
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototype pattern
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom scopes
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Other bean scopes
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's take a moment to see how Spring manages the life cycle of a bean from
    creation to destruction in the Spring application
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The Spring bean life cycle and its phases
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a Spring application, the term life cycle applies to any class of application--Standalone
    Java, Spring Boot application, or Integration/System Test. Also, life cycle applies
    to all three dependency injection styles--XML, Annotations, and Java configuration.
    You define the configuration for beans as per business goals. But Spring creates
    these beans and manages the life cycle of the Spring beans. Spring loads the bean
    configurations either in Java or XML through `ApplicationContext`. After loading
    these beans, the Spring container handles the creation and instantiation of these
    beans as per your configuration. Let''s divide the Spring application life cycle
    into three phases as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The initialization phase
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Use phase
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The destruction phase
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Please refer to the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ca661ad-4883-4927-b755-08a69c8efffe.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding diagram, each Spring bean goes through these
    three phases in the complete life cycle. Each phase has some set of operations
    to be performed for each Spring bean (depending on the configuration). Spring
    fits in to manage your application life cycle. It plays an important role in all
    three phases.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Now let's take a moment to see how Spring works in the first, initialization
    phase.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The initialization phase
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this phase, first of all Spring loads all the configuration files of any
    style-XML, Annotations, and Java configuration. This phase prepares the beans
    for use. The application is not usable until this phase is complete. This phase,
    actually, creates the application services for use, and it allocates the system
    resources to the bean. Spring provides `ApplicationContext` to load the bean configurations;
    once the application context is created, the initialization phase completes. Let's
    see how Spring loads the configuration files in Java or XML.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Creating the application context from configuration
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring provides multiple implementations of `ApplicationContext` to load the
    various styles of configuration file. These are listed next:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'For Java configuration, the following is used:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For XML configuration, the implementation is as follows:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding codes, Spring loads the Java configuration files by using
    the `AnnotationConfigApplicationContext` class, and the XML configuration files
    by using the `ClassPathXmlApplicationContext` class for the Spring container.
    Spring behaves the same for all types of configuration. It does not matter what
    configuration styles you use in your application. The following diagram shows
    what exactly happens in this phase:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/646b0215-c1dc-4108-b1bc-edd9726445ec.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding diagram, the initialization phase is divided
    into these two steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Load bean definitions
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize bean instances
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load bean definitions
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this step, all the configuration files--`@Configuration` classes or XML
    files-are processed. For Annotation-based configuration, all the classes annotated
    with `@Components` are scanned to load the bean definitions. All XML files are
    parsed, and the bean definitions are added to a `BeanFactory`. Each bean is indexed
    under its `id`. Spring provides multiple `BeanFactoryPostProcessor` beans, so,
    it is invoked to resolve runtime dependencies such as reading values from external
    property files. In a Spring application, `BeanFactoryPostProcessor` can modify
    the definition of any bean. The following diagram describes this step:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ecea9112-8d34-49fa-8e2a-60cbfed386f0.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding diagram, Spring first loads the bean definitions,
    and then calls `BeanFactoryProcessor` for some beans to modify its definitions
    accordingly. Let''s see this with an example. We have two configuration files--`AppConfig.java`
    and `InfraConfig.java`, which are defined as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `AppConfig.java` file:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Following is the `InfraConfig.java` file:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These Java configuration files are loaded by the **ApplicationContext** to
    the container, and indexed with its `id`, as shown in the following diagram:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/923a2b5d-4f0d-4bd2-9c25-852474ea7221.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: 'In the last diagram, Spring beans are indexed under its IDs into Spring''s
    `BeanFactory`, and then, that `BeanFactory` object is passed as an argument to
    the `postProcess()` method of `BeanFactoryPostProcessor`. The `BeanFactoryPostProcessor`
    can modify the bean definition for some beans; this depends on the bean configurations
    provided by the developer. Let''s see how `BeanFactoryPostProcessor` works, and
    how to override it in our application:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '`BeanFactoryPostProcessor` works on the bean definitions or the configuration
    metadata of the bean before the beans are actually created.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spring provides several useful implementations of `BeanFactoryPostProcessor`,
    such as reading properties and registering a custom scope.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can write your own implementation of the `BeanFactoryPostProcessor` interface.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you define a `BeanFactoryPostProcessor` in one container, it will only be
    applied to the bean definitions in that container.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the code snippet for `BeanFactoryPostProcessor`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s now see the following examples of the `BeanFactoryPostProcessor` extension
    point:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '**Reading external property files (**`database.properties`**)**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we''ll use the `DataSource` bean to be configured with the database values
    such as `username`, `password`, `db url`, and `driver`, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following is the `DataSource` bean definition in the configuration file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So, in the preceding code, how do we resolve the `@Value` and `${..}` variables?
    We need a `PropertySourcesPlaceholderConfigurer` to evaluate them. This is a `BeanFactoryPostProcessor`.
    If you are using the XML configuration, the `<context:property-placeholder/>`
    namespace creates a `PropertySourcesPlaceholderConfigurer` for you.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Loading the bean definition is a one-time process at the time of loading the
    configuration file, but the initializing phase for bean instances is executed
    for each bean in the container. Let's have a look at the initialization of bean
    instances in the application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载配置文件时，加载Bean定义是一个一次性过程，但Bean实例的初始化阶段会在容器中的每个Bean上执行。让我们看看应用中Bean实例的初始化过程。
- en: Initializing bean instances
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化Bean实例
- en: 'After loading the bean definitions into the `BeanFactory`, the Spring IoC container
    instantiates the beans for the application; the following diagram shows the process
    flow:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在将Bean定义加载到`BeanFactory`之后，Spring IoC容器为应用实例化Bean；以下图显示了流程：
- en: '![](img/88a156a9-9afc-4c41-8377-8f645f4257eb.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/88a156a9-9afc-4c41-8377-8f645f4257eb.png)'
- en: 'As you can see in the preceding diagram, the bean initialization step is executed
    for each bean in the container. We can summarize the bean creation process as
    follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，容器中的每个Bean都会执行Bean初始化步骤。我们可以将Bean创建过程总结如下：
- en: Each bean is eagerly instantiated by default. It is created in the right order
    with its dependencies injected unless marked as lazy.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，每个Bean都会被急切地实例化。除非标记为懒加载，否则它会按照正确的顺序创建，并注入其依赖项。
- en: Spring provides multiple `BeanPostProcessor`, so, each bean goes through a post-processing
    phase such as `BeanFactoryPostProcessor`, which can modify the bean definition.
    However, the `BeanPostProcessor` can change the instance of the bean.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring提供了多个`BeanPostProcessor`，因此，每个Bean都会经历一个后处理阶段，例如`BeanFactoryPostProcessor`，它可以修改Bean定义。然而，`BeanPostProcessor`可以改变Bean的实例。
- en: After execution of this phase, the bean is fully initialized and ready for use.
    It is tracked by its `id` till the context is destroyed, except for the prototype
    beans.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个阶段执行完成后，Bean就完全初始化并准备好使用。它通过其`id`被跟踪，直到上下文被销毁，除了原型Bean。
- en: In the next section, we'll discuss how to customize the Spring container by
    using a `BeanPostProcessor`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何通过使用`BeanPostProcessor`来自定义Spring容器的行为。
- en: Customizing beans using a BeanPostProcessor
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用BeanPostProcessor自定义Bean
- en: 'The `BeanPostProcessor` is an important extension point in Spring. It can modify
    bean instances in any way. It is used to enable a powerful feature such as the
    AOP proxy. You can write your own `BeanPostProcessor` in your application to create
    a custom `post-processor`--the class must implement the `BeanPostProcessor` interface.
    Spring provides several implementations of `BeanPostProcessor`. In Spring, the
    `BeanPostProcessor` interface has two callback methods, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeanPostProcessor`是Spring中的一个重要扩展点。它可以以任何方式修改Bean实例。它用于启用如AOP代理等强大功能。你可以在你的应用中编写自己的`BeanPostProcessor`来创建自定义的`post-processor`--该类必须实现`BeanPostProcessor`接口。Spring提供了`BeanPostProcessor`的几个实现。在Spring中，`BeanPostProcessor`接口有两个回调方法，如下：'
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can implement these two methods of the `BeanPostProcessor` interface to
    provide your own custom logic for bean instantiation, dependency-resolution, and
    so on. You can configure multiple `BeanPostProcessor` implementations to add custom
    logic to the Spring container. You can also manage the order of execution of these
    `BeanPostProcessor` by setting the order property. `BeanPostProcessor` work on
    Spring bean instances after instantiation of the bean by the Spring container.
    The scope of the `BeanPostProcessor` is within the Spring container, which means
    that beans that are defined in one container are not post-processed by a `BeanPostProcessor`
    defined in another container.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过实现`BeanPostProcessor`接口的这两种方法来提供自己的自定义逻辑，用于Bean实例化、依赖解析等。你可以配置多个`BeanPostProcessor`实现来向Spring容器添加自定义逻辑。你还可以通过设置order属性来管理这些`BeanPostProcessor`的执行顺序。`BeanPostProcessor`在Spring容器实例化Bean之后工作。`BeanPostProcessor`的作用域在Spring容器内，这意味着在一个容器中定义的Bean不会被另一个容器中定义的`BeanPostProcessor`后处理。
- en: Any class in a Spring application is registered as a `post-processor` with the
    container; it is created for each bean instance by the Spring container. And the
    Spring container calls the `postProcessBeforeInitialization()` method before the
    container initialization methods (Initializing Bean's `afterPropertiesSet()` and
    the bean's `init` method). It also calls the `postProcessAfterInitialization()`
    method after any bean initialization callbacks. The Spring AOP uses the `post-processor`
    to provide proxy-wrapping logic (Proxy design pattern) although we can take any
    action by using the `post-processor`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Spring应用程序中的任何类都被注册为容器的`后处理器`；它由Spring容器为每个bean实例创建。Spring容器在容器初始化方法（初始化Bean的`afterPropertiesSet()`和bean的`init`方法）之前调用`postProcessBeforeInitialization()`方法。它还在任何bean初始化回调之后调用`postProcessAfterInitialization()`方法。Spring
    AOP使用`后处理器`提供代理包装逻辑（代理设计模式），尽管我们可以通过使用`后处理器`执行任何操作。
- en: Spring's `ApplicationContext` automatically detects those beans which implement
    the `BeanPostProcessor` interface, and registers these beans as `post-processors`.
    These beans are called at the time of any other bean creation. Let's explore the
    following example of `BeanPostProcessor`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Spring的`ApplicationContext`自动检测实现`BeanPostProcessor`接口的bean，并将这些bean注册为`后处理器`。这些bean在创建任何其他bean时被调用。让我们探索以下`BeanPostProcessor`的示例。
- en: 'Let''s create a custom bean `post-processor` as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式创建一个自定义的`后处理器`：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This example illustrates basic usage, here this example shows a `post-processor`
    prints the string to the system console for each bean registered with the container.
    This `MyBeanPostProcessor` class annotated with `@Component` that means this class
    same as other bean class in the application context, now run the following demo
    class. Please refer to the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例说明了基本用法，这里此示例显示一个`后处理器`将字符串打印到系统控制台，对于容器中注册的每个bean。此`MyBeanPostProcessor`类使用`@Component`注解，这意味着此类与应用程序上下文中的其他bean类相同，现在运行以下演示类。请参考以下代码：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is the output that we''ll get on the console:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将在控制台上获得的输出：
- en: '![](img/b3eaae71-6091-4bcc-ab41-40d10793f1e8.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3eaae71-6091-4bcc-ab41-40d10793f1e8.png)'
- en: 'As you can see in the preceding output, a string of both the callback methods
    is printed for each bean method in the Spring container. Spring provides many
    pre-implemented `BeanPostProcessor` for some specific features, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的输出所示，Spring容器中每个bean的方法都会打印出回调方法的字符串。Spring为一些特定功能提供了许多预实现的`BeanPostProcessor`，如下所示：
- en: '`RequiredAnnotationBeanPostProcessor`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RequiredAnnotationBeanPostProcessor`'
- en: '`AutowiredAnnotationBeanPostProcessor`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AutowiredAnnotationBeanPostProcessor`'
- en: '`CommonAnnotationBeanPostProcessor`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CommonAnnotationBeanPostProcessor`'
- en: '`PersistenceAnnotationBeanPostProcessor`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PersistenceAnnotationBeanPostProcessor`'
- en: The namespace `<context:annotation-config/>` in the XML configuration enables
    several `post-processor` in the same application context in which it is defined.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: XML配置中的`<context:annotation-config/>`命名空间启用了在同一应用程序上下文中定义的多个`后处理器`。
- en: Let us now move on to our next section, and see how we can enable the Initializer
    extension point by using `BeanPostProcessor`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一节，看看我们如何通过使用`BeanPostProcessor`来启用初始化器扩展点。
- en: The Initializer extension point
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化器扩展点
- en: This special case of a bean `post-processor` causes `init` (`@PostConstruct`)
    methods to be called. Internally, Spring uses several **BeanPostProcessors** (**BPPs**)
    `CommonAnnotationBeanPostProcessor` to enable initialization. The following diagram
    illustrates the relationship between initializer and BPPs.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特殊的“后处理器”情况会导致调用`init`（`@PostConstruct`）方法。内部，Spring使用多个**BeanPostProcessors**（**BPPs**）`CommonAnnotationBeanPostProcessor`来启用初始化。以下图表展示了初始化器和BPPs之间的关系。
- en: '![](img/187db208-db73-4cb0-a955-49a0ec79b4da.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/187db208-db73-4cb0-a955-49a0ec79b4da.png)'
- en: 'Now let''s see the following example for the Initializer extension point in
    XML:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看以下XML中初始化器扩展点的示例：
- en: 'Namespace `<context:annotation-config/>` explicitly enables many `post-processor`,
    let see the following configuration file in XML:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`<context:annotation-config/>`命名空间明确启用了许多`后处理器`，让我们看看以下XML配置文件：'
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding configuration code, you can see that I have defined some beans
    out of which one of the bean `accountRepository` repository has the `init` method
    attribute of the bean tag; this attribute has a value, `populateCache`. This is
    nothing but an `initializer` method of the `accountRepository` bean. It is called
    by the container at the time of bean initialization if the `post-processor` is
    explicitly enabled by the `<context:annotation-config/>` namespace. Let''s see
    the `JdbcAccountRepository` class, shown as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the Java configuration, we can use `initMethod` attribute of the `@Bean`
    annotation as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the Annotation-based configuration, we can use the *JSR-250* annotation,
    `@PostConstruct` as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We have seen the first phase of a bean life cycle, where Spring loads the bean
    definitions by using XML-, Java-, and Annotation-based configuration, and after
    that, the Spring container initializes each bean in the correct order in the Spring
    application. The next diagram gives an overview of the first phase of the configuration
    life cycle:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a7e9ec4-ad6c-40c7-acad-1c76bec040ff.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: The last diagram shows Spring bean metadata in any style-XML, Annotation, or
    Java-loaded by the respective implementation of `ApplicationContext`. All XML
    files are parsed, and loaded with the bean definitions. In Annotation configuration,
    Spring scans all the components, and loads the bean definitions. In the Java configuration,
    Spring reads all the `@Bean` methods to load the bean definitions. After loading
    the bean definitions from all styles of configurations, `BeanFactoryPostProcessor`
    comes into the picture to modify the definition of some beans, and then the container
    instantiates the beans. Finally, `BeanPostProcessor` works on the beans, and it
    can modify and change the bean object. This is the initialization phase. Now let's
    see the next Use phase of a bean in its life cycle.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: The Use phase of beans
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a Spring application, all Spring beans spend 99.99% of their time in this
    phase. If the initialization phase is completed successfully, then the Spring
    beans come into this phase. Here, beans are used by clients as application services.
    These beans process client requests, and carry out application behaviors. In the
    Use phase, let''s see how to invoke a bean obtained from the context **in the
    application where it is used**. Please refer to the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Suppose the `return` service returns a raw object, then it is simply invoked
    directly; nothing special here. But if your bean has been wrapped in a proxy,
    then things become more interesting. Let''s explore the following diagram to understand
    this more clearly:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15ae37a0-4d43-4ca2-8e19-da8ca4ad7976.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, you can see the `service` method call through the
    `Proxy` class; it is created in the `init` phase by dedicated `BeanPostProcessor`.
    It wraps your beans in a dynamic proxy, which adds behavior to your bean transparently.
    It is an implementation of the Decorator Design pattern and Proxy Design pattern.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how Spring creates a proxy for your bean in the Spring application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Decorator and Proxy patterns in Spring using Proxies
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring uses two types of proxy in a Spring application. The following are the
    kind of proxies used by Spring:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '**JDK Proxy**: This is also known as a dynamic proxy. Its API is built into
    the JDK. For this proxy, the `Java` interface is required.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CGLib Proxy**: This is *NOT* built into JDK. However, it is included in Spring
    JARS, and is used when the interface is not available. It cannot be applied to
    final classes or methods.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the features of both the proxies in the following diagram:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff68c3d1-47fb-49d9-bd87-440a6ed7a481.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: This is all about the Use Phase of the Spring Bean life cycle. Now let's move
    to the next phase of life cycle, that is, the destruction phase.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The destruction phase of the beans
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this phase, Spring releases any system resource acquired by the application
    services. These are eligible for garbage collection. When you close an application
    context, the destruction phase completes. Let''s see the following lines of code
    in this phase:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code, what do you think happens when we call the `applicationContext.close()`
    method in this phase? The process that takes place is given as follows :'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Any bean implementing the `org.springframework.beans.factory.DisposableBean`
    interface gets a callback from the container when it is destroyed. The `DisposableBean`
    interface specifies a single method:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `bean` instances are destroyed if instructed to call their `destroy` methods.
    Beans must have a `destroy` method defined, that is, a `no-arg` method returning
    `void`.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The context then destroys itself, and this context is not usable again.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only GC actually destroys objects and remember, it is called only when the `ApplicationContext`/JVM
    exit normally. It is not called for prototype beans.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see how to implement it with the XML Configuration:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the configuration, the `accountRepository` bean has a `destroy` method named
    `clearCache`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s see the same configuration with Java. In the Java configuration, we
    can use the `destroyMethod` attribute of the `@Bean` annotation as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can do the same using Annotations. Annotations require `annotation-config`
    or the component scanner to be activated by using `<context:component-scan ...
    />``, as seen in the following`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You have now seen the Spring bean life cycle in all its phases. In the initialization
    phase, Bean Post Processors for initialization and proxies. In the Use phase,
    Spring beans use the magic of proxy. Finally, in the destruction phase, it allows
    the application to terminate cleanly.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了Spring bean生命周期的所有阶段。在初始化阶段，有初始化和代理的Bean后处理器。在使用阶段，Spring beans使用了代理的魔法。最后，在销毁阶段，它允许应用程序干净地终止。
- en: Now that you have seen the bean life cycle, let's learn about bean scopes, and
    how to create custom bean scopes in the Spring container.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了bean的生命周期，让我们来学习bean的作用域，以及如何在Spring容器中创建自定义bean作用域。
- en: Understanding bean scopes
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解bean作用域
- en: In Spring, each bean has one scope in the container. You can control not only
    the bean metadata and its life, but also the scope of that bean. You can create
    a custom scope of the bean, and register it with the container. You can decide
    the scope of the bean by configuring it with the bean definition with the XML-,
    Annotations-, or Java-based configuration.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring中，每个bean在容器中都有一个作用域。你可以控制不仅bean元数据和其生命周期，还可以控制该bean的作用域。你可以创建一个自定义的bean作用域，并将其注册到容器中。你可以通过配置基于XML、注解或Java的bean定义来决定bean的作用域。
- en: The Spring application context *creates* all beans *by using* a singleton scope.
    That means, it is always the same bean each time; it doesn't matter how many times
    it is injected into another bean or called by other services. Because of this
    singleton behavior, the scope reduces the cost of instantiating. It is suitable
    for stateless objects in the application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Spring应用程序上下文通过使用单例作用域来创建所有bean。这意味着每次都是同一个bean；无论它被注入到另一个bean中多少次或被其他服务调用多少次，都不会改变。正因为这种单例行为，作用域减少了实例化的成本。它适用于应用中的无状态对象。
- en: In a Spring application, sometimes it is required to save the state of some
    objects that aren't safe for reuse. For such a requirement, declaring the bean
    scope as a singleton is not safe, because it may cause unexpected problems when
    reused later. Spring provides another scope for such a requirement, which is known
    as the prototype scope of the Spring bean.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring应用程序中，有时需要保存某些对象的状态，这些对象不适合重用。对于这种需求，将bean作用域声明为单例是不安全的，因为它可能在稍后重用时引起意外问题。Spring为这种需求提供了另一个作用域，这被称为Spring
    bean的原型作用域。
- en: 'Spring defines several scopes under which a bean can be created, and these
    are as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Spring定义了多个作用域，bean可以在这些作用域下创建，如下所示：
- en: The singleton bean scope
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例bean作用域
- en: 'In Spring, any bean that has a singleton scope has only one instance of the
    bean created for an application context, where it is defined for the entire application.
    This is the default behavior of the Spring container. But it is different from
    the singleton pattern as defined in the **Gang of Four** (**GoF**) patterns book.
    In Java, singleton means per object of a particular class per Classloader in the
    JVM. But in Spring, it implies per instance of a bean per bean definition per
    Spring IoC container. This is explained in the following diagram:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring中，任何具有单例作用域的bean，在应用程序上下文中只创建一个bean实例，它在整个应用程序中定义。这是Spring容器的默认行为。但它与**Gang
    of Four**（**GoF**）模式书籍中定义的单例模式不同。在Java中，单例意味着在JVM中每个特定类的每个对象。但在Spring中，它意味着每个Spring
    IoC容器中每个bean定义的每个bean实例。这将在以下图中解释：
- en: '![](img/4c743f7e-3f0c-4c38-890c-7bd06953c578.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c743f7e-3f0c-4c38-890c-7bd06953c578.png)'
- en: As you can see in the preceding diagram, the same instance of the object is
    defined by the bean definition, `accountRepository`, injected to other collaborating
    beans in the same IoC container. Spring stores all singleton bean instances in
    a cache, and all collaborating beans fetch the dependency of that object returned
    by the cache.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前图所示，相同的对象实例由bean定义`accountRepository`注入到同一IoC容器中的其他协作bean。Spring将所有单例bean实例存储在缓存中，所有协作bean都会从缓存中获取该对象依赖项。
- en: The prototype bean scope
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型bean作用域
- en: 'In Spring, any bean defined with the prototype scope has one instance of the
    bean created for every time the bean is injected into other collaborating beans.
    The following figure illustrates the Spring prototype scope:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在春季，任何定义为原型范围的bean，每次被注入到其他协作bean时，都会为其创建一个bean实例。以下图示说明了Spring的原型范围：
- en: '![](img/57c51044-2bd1-4043-97c9-ae928ac05bc7.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57c51044-2bd1-4043-97c9-ae928ac05bc7.png)'
- en: As you can see in the preceding diagram, an `accountRepository` class is configured
    as a prototype bean, and the container creates a brand new instance for each time
    that bean is injected into other beans.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: The session bean scope
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A new instance is created once for every user session in the web environment
    only.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following XML configuration for a bean definition:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The request bean scope
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A new instance is created once for every request in the web environment only.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following XML configuration for a bean definition:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Other scopes in Spring
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring has other more specialized scopes, which are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket scope
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refresh scope
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread scope (defined, but not registered by default)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring also supports the creation of your own custom scope for a bean. We'll
    discuss this in the following section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Custom scopes
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can create a custom scope of any bean, and register this scope with the application
    context. Let's see how to create a custom bean scope with the following example.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom scopes
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For creating your customer scope in the Spring IoC container, Spring provides
    the `org.springframework.beans.factory.config.Scope` interface. You have to implement
    this interface to create your own custom scopes. Take a look at the following
    `MyThreadScope` class as a custom scope in the Spring IoC container:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding code, we have overridden multiple methods of the `Scope` interface
    as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**Object get(String name, ObjectFactory objectFactory)**: This method returns
    the object from the underlying scope'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object remove(String name)**: This method removes the object from the underlying
    scope'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**void registerDestructionCallback(String name, Runnable destructionCallback)**:
    This method registers the destruction callbacks, and is executed when the specified
    object with this custom scope is destroyed'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's see how to register this custom scope with the Spring IoC container,
    and how to use it in the Spring application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'You can register this custom bean scope with the Spring IoC container declaratively
    by using the `CustomScopeConfigurer` class as follows :'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see in the preceding configuration file, I have registered my custom
    bean scope named `myThreadScope` with the application context by using the `CustomScopeConfigurer`
    class. This custom scope that I am using is similar to the singleton or prototype
    scope through the scope attribute of the bean tag in the XML configuration.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you should now have a good idea about the Spring
    bean life cycle in the container, and the several types of bean scope in a container.
    You now know that there are three phases of the Spring bean life cycle in the
    container. The first is the initialization phase. In this phase, Spring loads
    the bean definitions from XML, Java, or Annotation configurations. After loading
    these beans, the container constructs each bean, and applies the post-process
    logic on that bean.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The next is the Use phase, in which the Spring beans are ready to be used, and
    Spring shows the magic of the proxy pattern.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last phase is the destruction phase. In this phase, when the application
    calls the `close()` method of Spring's `ApplicationContext`, the container calls
    the clean-up method of each bean to release resources.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: In Spring, you can control not only the bean life cycle but also the scope of
    the bean in the container. The default scope of a bean in the Spring IoC container
    is the Singleton, but you can override the default scope by defining other scope
    prototypes with the bean using the scope attribute of the bean tag in XML or the
    `@Scope` annotation in Java. You can also create your own custom scope, and register
    it with the container.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Now we'll turn to the magic chapter of this book, that is, Spring **Aspect-Oriented
    Programming** (**AOP**). Much as dependency injection helps decouple components
    from the other components they collaborate with, AOP helps decouple your application
    components from tasks that span multiple components in an application. Let's move
    on to the next chapter, covering Spring Aspect Oriented Programming with Proxy
    and Decorator Design Pattern.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
