- en: Understanding the Bean Life Cycle and Used Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you saw how Spring creates beans in the container.
    You also learned how to configure the dependency injection pattern using XML,
    Java, and Annotation. In this chapter, we will go into more detail, beyond injecting
    beans and the configuration of dependencies in a Spring application. Here, you
    will explore the life and scope of beans in the container, and learn how the Spring
    container works on the defined Spring bean configuration with XML, Annotation,
    and Java. Spring allows us to control not only the various configurations for
    the DI pattern and dependency values that are to be injected into the object created
    from a particular bean definition, but also the life and scope of the beans created
    from a particular bean definition.
  prefs: []
  type: TYPE_NORMAL
- en: When I was writing this chapter, my two and a half year old son, Arnav, came
    to me and started playing a video game on my mobile. He was wearing a T-Shirt,
    which had an interesting quote on it, and these lines described his whole day.
    The lines went like this--
  prefs: []
  type: TYPE_NORMAL
- en: '*My Perfect Day: Wake up, Play Video Games, Eat, Play Video Games, Eat, Play
    Video Games, and Sleep*.'
  prefs: []
  type: TYPE_NORMAL
- en: Actually, these lines perfectly reflected his life cycle for each day, as he
    woke up, played, ate, and played again before, finally, going to sleep. With this
    example, I just wanted to demonstrate that everything has a life cycle. We could
    discuss the life cycle of a butterfly, a star, a frog, or a plant. But let's talk
    about something more interesting--the life cycle of a bean!
  prefs: []
  type: TYPE_NORMAL
- en: 'Every bean in the Spring container has a life cycle and its own scope. The
    Spring container manages the life of the beans in a Spring application. We can
    customize it in some phases by using Spring-aware interfaces. This chapter will
    talk about the life of a bean in the container, and how it is managed using design
    patterns in the various phases of its life. By the end of this chapter, you would
    have a fair idea of the bean life cycle and its various phases in the container.
    You will also learn about the many types of bean scope in Spring. This chapter
    will cover the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Spring bean life cycle, and its phases, which are listed as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initialization phase
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Use phase
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The destruction phase
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding bean scopes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Singleton pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototype pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom scopes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Other bean scopes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's take a moment to see how Spring manages the life cycle of a bean from
    creation to destruction in the Spring application
  prefs: []
  type: TYPE_NORMAL
- en: The Spring bean life cycle and its phases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a Spring application, the term life cycle applies to any class of application--Standalone
    Java, Spring Boot application, or Integration/System Test. Also, life cycle applies
    to all three dependency injection styles--XML, Annotations, and Java configuration.
    You define the configuration for beans as per business goals. But Spring creates
    these beans and manages the life cycle of the Spring beans. Spring loads the bean
    configurations either in Java or XML through `ApplicationContext`. After loading
    these beans, the Spring container handles the creation and instantiation of these
    beans as per your configuration. Let''s divide the Spring application life cycle
    into three phases as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The initialization phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Use phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The destruction phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Please refer to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ca661ad-4883-4927-b755-08a69c8efffe.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding diagram, each Spring bean goes through these
    three phases in the complete life cycle. Each phase has some set of operations
    to be performed for each Spring bean (depending on the configuration). Spring
    fits in to manage your application life cycle. It plays an important role in all
    three phases.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's take a moment to see how Spring works in the first, initialization
    phase.
  prefs: []
  type: TYPE_NORMAL
- en: The initialization phase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this phase, first of all Spring loads all the configuration files of any
    style-XML, Annotations, and Java configuration. This phase prepares the beans
    for use. The application is not usable until this phase is complete. This phase,
    actually, creates the application services for use, and it allocates the system
    resources to the bean. Spring provides `ApplicationContext` to load the bean configurations;
    once the application context is created, the initialization phase completes. Let's
    see how Spring loads the configuration files in Java or XML.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the application context from configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring provides multiple implementations of `ApplicationContext` to load the
    various styles of configuration file. These are listed next:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Java configuration, the following is used:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For XML configuration, the implementation is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding codes, Spring loads the Java configuration files by using
    the `AnnotationConfigApplicationContext` class, and the XML configuration files
    by using the `ClassPathXmlApplicationContext` class for the Spring container.
    Spring behaves the same for all types of configuration. It does not matter what
    configuration styles you use in your application. The following diagram shows
    what exactly happens in this phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/646b0215-c1dc-4108-b1bc-edd9726445ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding diagram, the initialization phase is divided
    into these two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Load bean definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize bean instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load bean definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this step, all the configuration files--`@Configuration` classes or XML
    files-are processed. For Annotation-based configuration, all the classes annotated
    with `@Components` are scanned to load the bean definitions. All XML files are
    parsed, and the bean definitions are added to a `BeanFactory`. Each bean is indexed
    under its `id`. Spring provides multiple `BeanFactoryPostProcessor` beans, so,
    it is invoked to resolve runtime dependencies such as reading values from external
    property files. In a Spring application, `BeanFactoryPostProcessor` can modify
    the definition of any bean. The following diagram describes this step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ecea9112-8d34-49fa-8e2a-60cbfed386f0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding diagram, Spring first loads the bean definitions,
    and then calls `BeanFactoryProcessor` for some beans to modify its definitions
    accordingly. Let''s see this with an example. We have two configuration files--`AppConfig.java`
    and `InfraConfig.java`, which are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `AppConfig.java` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the `InfraConfig.java` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'These Java configuration files are loaded by the **ApplicationContext** to
    the container, and indexed with its `id`, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/923a2b5d-4f0d-4bd2-9c25-852474ea7221.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the last diagram, Spring beans are indexed under its IDs into Spring''s
    `BeanFactory`, and then, that `BeanFactory` object is passed as an argument to
    the `postProcess()` method of `BeanFactoryPostProcessor`. The `BeanFactoryPostProcessor`
    can modify the bean definition for some beans; this depends on the bean configurations
    provided by the developer. Let''s see how `BeanFactoryPostProcessor` works, and
    how to override it in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BeanFactoryPostProcessor` works on the bean definitions or the configuration
    metadata of the bean before the beans are actually created.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spring provides several useful implementations of `BeanFactoryPostProcessor`,
    such as reading properties and registering a custom scope.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can write your own implementation of the `BeanFactoryPostProcessor` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you define a `BeanFactoryPostProcessor` in one container, it will only be
    applied to the bean definitions in that container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the code snippet for `BeanFactoryPostProcessor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now see the following examples of the `BeanFactoryPostProcessor` extension
    point:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reading external property files (**`database.properties`**)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we''ll use the `DataSource` bean to be configured with the database values
    such as `username`, `password`, `db url`, and `driver`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the `DataSource` bean definition in the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So, in the preceding code, how do we resolve the `@Value` and `${..}` variables?
    We need a `PropertySourcesPlaceholderConfigurer` to evaluate them. This is a `BeanFactoryPostProcessor`.
    If you are using the XML configuration, the `<context:property-placeholder/>`
    namespace creates a `PropertySourcesPlaceholderConfigurer` for you.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the bean definition is a one-time process at the time of loading the
    configuration file, but the initializing phase for bean instances is executed
    for each bean in the container. Let's have a look at the initialization of bean
    instances in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing bean instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After loading the bean definitions into the `BeanFactory`, the Spring IoC container
    instantiates the beans for the application; the following diagram shows the process
    flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88a156a9-9afc-4c41-8377-8f645f4257eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding diagram, the bean initialization step is executed
    for each bean in the container. We can summarize the bean creation process as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Each bean is eagerly instantiated by default. It is created in the right order
    with its dependencies injected unless marked as lazy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring provides multiple `BeanPostProcessor`, so, each bean goes through a post-processing
    phase such as `BeanFactoryPostProcessor`, which can modify the bean definition.
    However, the `BeanPostProcessor` can change the instance of the bean.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After execution of this phase, the bean is fully initialized and ready for use.
    It is tracked by its `id` till the context is destroyed, except for the prototype
    beans.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we'll discuss how to customize the Spring container by
    using a `BeanPostProcessor`.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing beans using a BeanPostProcessor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `BeanPostProcessor` is an important extension point in Spring. It can modify
    bean instances in any way. It is used to enable a powerful feature such as the
    AOP proxy. You can write your own `BeanPostProcessor` in your application to create
    a custom `post-processor`--the class must implement the `BeanPostProcessor` interface.
    Spring provides several implementations of `BeanPostProcessor`. In Spring, the
    `BeanPostProcessor` interface has two callback methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can implement these two methods of the `BeanPostProcessor` interface to
    provide your own custom logic for bean instantiation, dependency-resolution, and
    so on. You can configure multiple `BeanPostProcessor` implementations to add custom
    logic to the Spring container. You can also manage the order of execution of these
    `BeanPostProcessor` by setting the order property. `BeanPostProcessor` work on
    Spring bean instances after instantiation of the bean by the Spring container.
    The scope of the `BeanPostProcessor` is within the Spring container, which means
    that beans that are defined in one container are not post-processed by a `BeanPostProcessor`
    defined in another container.
  prefs: []
  type: TYPE_NORMAL
- en: Any class in a Spring application is registered as a `post-processor` with the
    container; it is created for each bean instance by the Spring container. And the
    Spring container calls the `postProcessBeforeInitialization()` method before the
    container initialization methods (Initializing Bean's `afterPropertiesSet()` and
    the bean's `init` method). It also calls the `postProcessAfterInitialization()`
    method after any bean initialization callbacks. The Spring AOP uses the `post-processor`
    to provide proxy-wrapping logic (Proxy design pattern) although we can take any
    action by using the `post-processor`.
  prefs: []
  type: TYPE_NORMAL
- en: Spring's `ApplicationContext` automatically detects those beans which implement
    the `BeanPostProcessor` interface, and registers these beans as `post-processors`.
    These beans are called at the time of any other bean creation. Let's explore the
    following example of `BeanPostProcessor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a custom bean `post-processor` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This example illustrates basic usage, here this example shows a `post-processor`
    prints the string to the system console for each bean registered with the container.
    This `MyBeanPostProcessor` class annotated with `@Component` that means this class
    same as other bean class in the application context, now run the following demo
    class. Please refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output that we''ll get on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3eaae71-6091-4bcc-ab41-40d10793f1e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding output, a string of both the callback methods
    is printed for each bean method in the Spring container. Spring provides many
    pre-implemented `BeanPostProcessor` for some specific features, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RequiredAnnotationBeanPostProcessor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AutowiredAnnotationBeanPostProcessor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CommonAnnotationBeanPostProcessor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PersistenceAnnotationBeanPostProcessor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The namespace `<context:annotation-config/>` in the XML configuration enables
    several `post-processor` in the same application context in which it is defined.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now move on to our next section, and see how we can enable the Initializer
    extension point by using `BeanPostProcessor`.
  prefs: []
  type: TYPE_NORMAL
- en: The Initializer extension point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This special case of a bean `post-processor` causes `init` (`@PostConstruct`)
    methods to be called. Internally, Spring uses several **BeanPostProcessors** (**BPPs**)
    `CommonAnnotationBeanPostProcessor` to enable initialization. The following diagram
    illustrates the relationship between initializer and BPPs.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/187db208-db73-4cb0-a955-49a0ec79b4da.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s see the following example for the Initializer extension point in
    XML:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Namespace `<context:annotation-config/>` explicitly enables many `post-processor`,
    let see the following configuration file in XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding configuration code, you can see that I have defined some beans
    out of which one of the bean `accountRepository` repository has the `init` method
    attribute of the bean tag; this attribute has a value, `populateCache`. This is
    nothing but an `initializer` method of the `accountRepository` bean. It is called
    by the container at the time of bean initialization if the `post-processor` is
    explicitly enabled by the `<context:annotation-config/>` namespace. Let''s see
    the `JdbcAccountRepository` class, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Java configuration, we can use `initMethod` attribute of the `@Bean`
    annotation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Annotation-based configuration, we can use the *JSR-250* annotation,
    `@PostConstruct` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We have seen the first phase of a bean life cycle, where Spring loads the bean
    definitions by using XML-, Java-, and Annotation-based configuration, and after
    that, the Spring container initializes each bean in the correct order in the Spring
    application. The next diagram gives an overview of the first phase of the configuration
    life cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a7e9ec4-ad6c-40c7-acad-1c76bec040ff.png)'
  prefs: []
  type: TYPE_IMG
- en: The last diagram shows Spring bean metadata in any style-XML, Annotation, or
    Java-loaded by the respective implementation of `ApplicationContext`. All XML
    files are parsed, and loaded with the bean definitions. In Annotation configuration,
    Spring scans all the components, and loads the bean definitions. In the Java configuration,
    Spring reads all the `@Bean` methods to load the bean definitions. After loading
    the bean definitions from all styles of configurations, `BeanFactoryPostProcessor`
    comes into the picture to modify the definition of some beans, and then the container
    instantiates the beans. Finally, `BeanPostProcessor` works on the beans, and it
    can modify and change the bean object. This is the initialization phase. Now let's
    see the next Use phase of a bean in its life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: The Use phase of beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a Spring application, all Spring beans spend 99.99% of their time in this
    phase. If the initialization phase is completed successfully, then the Spring
    beans come into this phase. Here, beans are used by clients as application services.
    These beans process client requests, and carry out application behaviors. In the
    Use phase, let''s see how to invoke a bean obtained from the context **in the
    application where it is used**. Please refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose the `return` service returns a raw object, then it is simply invoked
    directly; nothing special here. But if your bean has been wrapped in a proxy,
    then things become more interesting. Let''s explore the following diagram to understand
    this more clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15ae37a0-4d43-4ca2-8e19-da8ca4ad7976.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, you can see the `service` method call through the
    `Proxy` class; it is created in the `init` phase by dedicated `BeanPostProcessor`.
    It wraps your beans in a dynamic proxy, which adds behavior to your bean transparently.
    It is an implementation of the Decorator Design pattern and Proxy Design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how Spring creates a proxy for your bean in the Spring application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Decorator and Proxy patterns in Spring using Proxies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring uses two types of proxy in a Spring application. The following are the
    kind of proxies used by Spring:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JDK Proxy**: This is also known as a dynamic proxy. Its API is built into
    the JDK. For this proxy, the `Java` interface is required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CGLib Proxy**: This is *NOT* built into JDK. However, it is included in Spring
    JARS, and is used when the interface is not available. It cannot be applied to
    final classes or methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the features of both the proxies in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff68c3d1-47fb-49d9-bd87-440a6ed7a481.png)'
  prefs: []
  type: TYPE_IMG
- en: This is all about the Use Phase of the Spring Bean life cycle. Now let's move
    to the next phase of life cycle, that is, the destruction phase.
  prefs: []
  type: TYPE_NORMAL
- en: The destruction phase of the beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this phase, Spring releases any system resource acquired by the application
    services. These are eligible for garbage collection. When you close an application
    context, the destruction phase completes. Let''s see the following lines of code
    in this phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, what do you think happens when we call the `applicationContext.close()`
    method in this phase? The process that takes place is given as follows :'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any bean implementing the `org.springframework.beans.factory.DisposableBean`
    interface gets a callback from the container when it is destroyed. The `DisposableBean`
    interface specifies a single method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `bean` instances are destroyed if instructed to call their `destroy` methods.
    Beans must have a `destroy` method defined, that is, a `no-arg` method returning
    `void`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The context then destroys itself, and this context is not usable again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only GC actually destroys objects and remember, it is called only when the `ApplicationContext`/JVM
    exit normally. It is not called for prototype beans.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see how to implement it with the XML Configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the configuration, the `accountRepository` bean has a `destroy` method named
    `clearCache`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the same configuration with Java. In the Java configuration, we
    can use the `destroyMethod` attribute of the `@Bean` annotation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do the same using Annotations. Annotations require `annotation-config`
    or the component scanner to be activated by using `<context:component-scan ...
    />``, as seen in the following`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You have now seen the Spring bean life cycle in all its phases. In the initialization
    phase, Bean Post Processors for initialization and proxies. In the Use phase,
    Spring beans use the magic of proxy. Finally, in the destruction phase, it allows
    the application to terminate cleanly.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have seen the bean life cycle, let's learn about bean scopes, and
    how to create custom bean scopes in the Spring container.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding bean scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Spring, each bean has one scope in the container. You can control not only
    the bean metadata and its life, but also the scope of that bean. You can create
    a custom scope of the bean, and register it with the container. You can decide
    the scope of the bean by configuring it with the bean definition with the XML-,
    Annotations-, or Java-based configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring application context *creates* all beans *by using* a singleton scope.
    That means, it is always the same bean each time; it doesn't matter how many times
    it is injected into another bean or called by other services. Because of this
    singleton behavior, the scope reduces the cost of instantiating. It is suitable
    for stateless objects in the application.
  prefs: []
  type: TYPE_NORMAL
- en: In a Spring application, sometimes it is required to save the state of some
    objects that aren't safe for reuse. For such a requirement, declaring the bean
    scope as a singleton is not safe, because it may cause unexpected problems when
    reused later. Spring provides another scope for such a requirement, which is known
    as the prototype scope of the Spring bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring defines several scopes under which a bean can be created, and these
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The singleton bean scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Spring, any bean that has a singleton scope has only one instance of the
    bean created for an application context, where it is defined for the entire application.
    This is the default behavior of the Spring container. But it is different from
    the singleton pattern as defined in the **Gang of Four** (**GoF**) patterns book.
    In Java, singleton means per object of a particular class per Classloader in the
    JVM. But in Spring, it implies per instance of a bean per bean definition per
    Spring IoC container. This is explained in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c743f7e-3f0c-4c38-890c-7bd06953c578.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding diagram, the same instance of the object is
    defined by the bean definition, `accountRepository`, injected to other collaborating
    beans in the same IoC container. Spring stores all singleton bean instances in
    a cache, and all collaborating beans fetch the dependency of that object returned
    by the cache.
  prefs: []
  type: TYPE_NORMAL
- en: The prototype bean scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Spring, any bean defined with the prototype scope has one instance of the
    bean created for every time the bean is injected into other collaborating beans.
    The following figure illustrates the Spring prototype scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57c51044-2bd1-4043-97c9-ae928ac05bc7.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding diagram, an `accountRepository` class is configured
    as a prototype bean, and the container creates a brand new instance for each time
    that bean is injected into other beans.
  prefs: []
  type: TYPE_NORMAL
- en: The session bean scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A new instance is created once for every user session in the web environment
    only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following XML configuration for a bean definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The request bean scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A new instance is created once for every request in the web environment only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following XML configuration for a bean definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Other scopes in Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring has other more specialized scopes, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refresh scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread scope (defined, but not registered by default)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring also supports the creation of your own custom scope for a bean. We'll
    discuss this in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Custom scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can create a custom scope of any bean, and register this scope with the application
    context. Let's see how to create a custom bean scope with the following example.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For creating your customer scope in the Spring IoC container, Spring provides
    the `org.springframework.beans.factory.config.Scope` interface. You have to implement
    this interface to create your own custom scopes. Take a look at the following
    `MyThreadScope` class as a custom scope in the Spring IoC container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have overridden multiple methods of the `Scope` interface
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Object get(String name, ObjectFactory objectFactory)**: This method returns
    the object from the underlying scope'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object remove(String name)**: This method removes the object from the underlying
    scope'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**void registerDestructionCallback(String name, Runnable destructionCallback)**:
    This method registers the destruction callbacks, and is executed when the specified
    object with this custom scope is destroyed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's see how to register this custom scope with the Spring IoC container,
    and how to use it in the Spring application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can register this custom bean scope with the Spring IoC container declaratively
    by using the `CustomScopeConfigurer` class as follows :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding configuration file, I have registered my custom
    bean scope named `myThreadScope` with the application context by using the `CustomScopeConfigurer`
    class. This custom scope that I am using is similar to the singleton or prototype
    scope through the scope attribute of the bean tag in the XML configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you should now have a good idea about the Spring
    bean life cycle in the container, and the several types of bean scope in a container.
    You now know that there are three phases of the Spring bean life cycle in the
    container. The first is the initialization phase. In this phase, Spring loads
    the bean definitions from XML, Java, or Annotation configurations. After loading
    these beans, the container constructs each bean, and applies the post-process
    logic on that bean.
  prefs: []
  type: TYPE_NORMAL
- en: The next is the Use phase, in which the Spring beans are ready to be used, and
    Spring shows the magic of the proxy pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last phase is the destruction phase. In this phase, when the application
    calls the `close()` method of Spring's `ApplicationContext`, the container calls
    the clean-up method of each bean to release resources.
  prefs: []
  type: TYPE_NORMAL
- en: In Spring, you can control not only the bean life cycle but also the scope of
    the bean in the container. The default scope of a bean in the Spring IoC container
    is the Singleton, but you can override the default scope by defining other scope
    prototypes with the bean using the scope attribute of the bean tag in XML or the
    `@Scope` annotation in Java. You can also create your own custom scope, and register
    it with the container.
  prefs: []
  type: TYPE_NORMAL
- en: Now we'll turn to the magic chapter of this book, that is, Spring **Aspect-Oriented
    Programming** (**AOP**). Much as dependency injection helps decouple components
    from the other components they collaborate with, AOP helps decouple your application
    components from tasks that span multiple components in an application. Let's move
    on to the next chapter, covering Spring Aspect Oriented Programming with Proxy
    and Decorator Design Pattern.
  prefs: []
  type: TYPE_NORMAL
