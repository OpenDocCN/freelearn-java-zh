<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Miscellaneous Improvements in JDK 12</h1>
                </header>
            
            <article>
                
<p>Java 12 is the latest <strong>Short Term Support</strong> (<strong>STS</strong>) release by Oracle. However, the industry is still warming to migrating to the latest <strong>Long-Term-Support</strong> (<strong>LTS</strong>) Java release by Oracle, that is, Java 11.</p>
<p>The notable features in JDK 12 are the addition of Shenandoah GC and <kbd>switch</kbd> expressions. We covered <kbd>switch</kbd> expressions in <a href="7d0cca79-35c9-4912-9414-12db320d684d.xhtml" target="_blank">Chapter 11</a>, <em>Switch Expressions</em>. Since a detailed coverage of Shenandoah GC is beyond the scope of this book, I'm covering it in this chapter with the remaining additions and updates to Java 12.</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>Shenandoah—a low-pause-time GC </li>
<li>The microbenchmark suite</li>
<li>The <strong>Java Virtual Machine</strong> (<strong>JVM</strong>) Constants API</li>
<li>One <span>AArch</span>64 port, not two</li>
<li>Default CDS archives</li>
<li>Abortable mixed collections for G1</li>
<li>Promptly return unused committed memory from G1</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To use the features that are included in this chapter, you should have JDK 12 or a later version on your system.</p>
<p>Since this chapter covers multiple features in Java 12, let's quickly map the features with their <strong>JDK Enhancement Proposal</strong> (<strong>JEP</strong>) number and scope.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mapping features of JDK 12 scope and JEP</h1>
                </header>
            
            <article>
                
<p>The following table lists the JDK 12 features covered in this chapter, their corresponding JEP number, and their scope:</p>
<table border="1" style="border-collapse: collapse;width: 90%">
<tbody>
<tr>
<td>
<p><strong>JEP</strong></p>
</td>
<td>
<p><strong>Scope</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p>189</p>
</td>
<td>
<p>Implementation</p>
</td>
<td>
<p>Shenandoah—a low-pause-time GC</p>
</td>
</tr>
<tr>
<td>
<p>230</p>
</td>
<td>
<p>JDK</p>
</td>
<td>
<p>The microbenchmark suite</p>
</td>
</tr>
<tr>
<td>
<p>334</p>
</td>
<td>
<p>SE</p>
</td>
<td>
<p>The JVM constants API</p>
</td>
</tr>
<tr>
<td>
<p>340</p>
</td>
<td>
<p>JDK</p>
</td>
<td>
<p>One <span>AArch</span>64 port, not two</p>
</td>
</tr>
<tr>
<td>
<p>341</p>
</td>
<td>
<p>JDK</p>
</td>
<td>
<p>Default CDS archives</p>
</td>
</tr>
<tr>
<td>
<p>344</p>
</td>
<td>
<p>Implementation</p>
</td>
<td>
<p>Abortable mixed collections for G1</p>
</td>
</tr>
<tr>
<td>
<p>346</p>
</td>
<td>
<p>Implementation</p>
</td>
<td>
<p>Promptly return unused committed memory from G1</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Let's get started with the first feature.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Shenandoah – a low-pause-time GC</h1>
                </header>
            
            <article>
                
<p>Proposed and developed by engineers at Red Hat, Shenandoah GC promises significantly low pauses. It is a region-based GC that collects garbage in a parallel and concurrent manner. It is interesting to note that the pause times are independent of the application's live data.</p>
<p>With hardware engineering and lower costs, servers have more memory and processing power than ever before. Modern applications are increasingly demanding lower pause times<span>—</span>with <strong>Service Level Agreement</strong> (<strong>SLA</strong>) applications that guarantee response times of 10 to 500 ms. To meet the lower end of this range, a GC should be able to accomplish multiple tasks, including the following:</p>
<ul>
<li>Use algorithms that enable programs to execute with the given memory</li>
<li>Keep the pause times low (that is, below 10 ms)</li>
</ul>
<p>Is this attainable with, say, a Java application that uses 200 GB memory? This isn't possible with the compacting algorithms, which will exceed the limit of 10 ms, even for compacting 10% of this memory. Shenandoah uses an algorithm that compacts the memory concurrently while the Java threads are running. In this case, objects are moved during a concurrent GC cycle and all of its references immediately access the newer copy.</p>
<p class="mce-root"/>
<p>Concurrent compaction isn't simple. When GC moves a live object, it must <strong>atomically</strong> update all references to the object, pointing to the new object. However, to find all of the references, the entire heap should be scanned; this sounds infeasible. To get around this, the Shenandoah GC adds a <strong>forwarding pointer</strong> to each object, with each use of that object going through that pointer. This simplifies the process of moving around objects. The Shenandoah GC thread or application thread can copy an object and use compare and swap to update the forwarding pointer. In case of contention, only one compare and swap will succeed. With the addition of the forwarding pointer, Shenandoah GC uses more space than other GC algorithms.</p>
<p>Each Shenandoah GC cycle consists of four phases. A Shenandoah GC cycle begins with <strong>Initial Marking</strong>, in which it <em>stops the world</em> and scans the root set. In phase two, that is, <strong>Concurrent Marking</strong>, it marks the live objects and updates references, concurrently. In the third phase, <strong>Final Marking</strong>, it <em>stops the world</em> and scans the root set again, copying and updating roots to updated copies. The last phase, <strong>Concurrent Compaction</strong>, evacuates live objects from the targeted regions.</p>
<p>Shenandoah is a region-based GC. It isn't a generational GC that focuses on collecting the youngest objects. This is based on the hypothesis that most objects die young. However, applications with caches hold on to the objects long enough, and so generational GC algorithms don't work with them. To get around this, Shenandoah uses the <strong>Least Recently Used</strong> (<strong>LRU</strong>) cache benchmark that enables it to keep its pause time low.</p>
<p>Shenandoah never compacts humongous objects (that is, objects that can't fit in one region and require multiple regions). If the Shenandoah GC cycle determines that a humongous object is no longer live, its region is immediately reclaimed.</p>
<p>The main target of Shenandoah GC is to increase the responsiveness of the JVM by lowering the count and duration of GC cycles.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The microbenchmark suite</h1>
                </header>
            
            <article>
                
<p>Based on <strong>Java Microbenchmark Harness</strong> (<strong>JMH</strong>), this feature adds a basic suite of microbenchmarks to the JDK source code, with the following proposed directory structure:</p>
<pre>jdk/jdk<br/>    .../make/test<br/>    .../test<br/>       .../micro/org/openjdk/bench<br/>           .../java<br/>                .../vm</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Since the microbenchmark suite will be located with the JDK source code, it will make it simpler for developers to locate and run existing microbenchmarks, and create new ones. As existing features are updated or removed from a JDK version, it will be simple to update a microbenchmark. Also, when developers run a microbenchmark they can use JMH's powerful filtering to run selected benchmarks.</p>
<p>Although the microbenchmark suite and its building will be integrated with JDK and its build system, it will have a separate target. Developers will need to specify additional parameters to execute it to keep the build time for normal JDK low.</p>
<p>As the name suggests, with benchmarking you can compare builds or releases. Hence, the microbenchmarks support JDK (<em>N</em>) for the new JDK and JDK (<em>N-1</em>) for the previous release. The benchmarks depend on JMH in the same way that unit tests depend on TestNG or <kbd>jtreg</kbd>. JMH is used during the build process and is packaged as part of the resulting JAR file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The JVM constants API</h1>
                </header>
            
            <article>
                
<p>This JEP introduces an API to standardize the description and loading of class constants.</p>
<p>Every Java class has a constant pool. It either stores simple values such as strings and integers or values to represent classes or methods. Class constant pool values are used as operand values for the <strong>ldc</strong> (<strong>load constant</strong>) <span>bytecode instruction</span>. These constants can also be used by the <strong>invokedynamic</strong> <span>bytecode </span>instruction<span>—</span>in the static argument list of a bootstrap method.</p>
<p>When either an ldc or invokedynamic instruction executes, it represents the constant value as a Java data type value, a class, an integer, or a string. Until now, the responsibility of modeling bytecode instructions and loading constants was on the class that wanted to manipulate class files. This usually takes the focus of these classes off their business logic, moving it to the specifics of how to model bytecode instructions and load class constants. This is clearly a good candidate to separate the concerns and define the API to work with the <em>how</em> part.</p>
<p>Also, it isn't easy for classes to implement this functionality by themselves, because loading class constants isn't a simple process for non-string and non-integer values. Class loading is a complex process and has multiple points of failure. Class loading is dependent on the host environment, including the existence of classes, the ability to gain access to them, and their relevant permissions. Class loading could also fail during the linking process.</p>
<p class="mce-root"/>
<p>An absence of a standardized library to handle these functions of loading constants also results in mismatched expectations between programs.</p>
<p>JDK 12 defines a new package, <kbd>java.lang.invoke.constant</kbd>, which defines a family of value-based symbolic reference types. It can be used to describe all types of loadable constants. A symbolic constant uses a nominal form and essentially excludes a constant from its loading or accessibility context. The package includes types such as <kbd>ClassDesc</kbd>, <kbd>MethodTypeDesc</kbd>, <kbd>MethodHandleDesc</kbd>, and <kbd>DynamicConstantDes</kbd> to describe various constants. Data types such as <kbd>String</kbd>, <kbd>Integer</kbd>, <kbd>Long</kbd>, <kbd>Float</kbd>, and <kbd>Double</kbd> are also used to represent simple class constants.</p>
<p>There are varied use cases of this package. Libraries that parse or generate bytecodes need to describe classes and method handles in a symbolic manner. Bootstraps for invokedynamic will get simpler because they will be able to work with symbolic representation, rather than working with live classes and method handles. It will be simpler for the compiler and offline transformers to describe classes and their members, which can't be loaded into the running <strong>Virtual Machine</strong> (<strong>VM</strong>). Compiler plugins, such as annotation processors, also need to describe uses classes and their members in symbolic terms.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">One AArch64 port, not two</h1>
                </header>
            
            <article>
                
<p>Until version 12, JDK had two 64-bit ARM ports, even though both produce an <span>AArch</span>64 implementation. As a maintenance feature, this JEP removes all sources related to the 64-bit 64-bit ARM platform and retains the 64-bit ARM AArch64 port. It will prevent the duplication of work to maintain two ports. As part of the process, the option to build this port will also be removed from JDK. It will also validate that the 32-bit ARM port continues to work as expected and that it isn't affected by these changes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Default CDS archives</h1>
                </header>
            
            <article>
                
<p>To understand the enhancements to CDS archives with JDK 12, let's quickly recap what CDS is and how it impacts your applications. I covered this briefly in <a href="210b06d5-c434-43dd-90a7-23c1d83d69bf.xhtml">Chapter 2</a>, <em>AppCDS</em>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is CDS?</h1>
                </header>
            
            <article>
                
<p>A commercial feature with Oracle JVM since Java 8, CDS helps to reduce the start up time of a Java application and its memory footprint. This is especially notable when you are working with multiple JVMs.</p>
<p>On startup, JVM prepares the environment for execution. It includes bytecode loading, verification, linking, and initializing of the core classes and interfaces. The classes and interfaces are combed into the runtime state of the JVM so that they can be executed. It also includes method areas and constant pools.</p>
<p>These set of core classes and interfaces don't change unless you update your JVM. So, every time you start your JVM, it performs the <em>same</em> steps to get the environment up for execution. Imagine that you could dump the result to a file, which could be read by your JVM at startup. The subsequent startups could get the environment up and running without performing the intermediate steps of loading, verification, linking, and initialization; welcome to CDS.</p>
<p>When you install JRE, CDS creates a shared archive file from a predefined set of classes from the system JAR file. Classes are verified by the class loaders before they can be used and this process applies to all of the classes. To speed up this process, the installation process loads these classes into an internal representation and then dumps that representation to <kbd>classes.jsa</kbd>—the shared archive file. When the JVM starts or restarts, the shared archive file is memory mapped to save the loading of those classes.</p>
<p>When the JVM's metadata is shared among multiple JVM processes, it results in a smaller memory footprint. Loading classes from a populated cache are faster than loading them from the disk; they are also partially verified. This feature is also beneficial for Java applications that start new JVM instances.</p>
<p>Using CDS archives have reportedly resulted in the reduction of the application start up time by more than 30% on basic programs such as <kbd>HelloWorld</kbd> with JDK 11. This number is even higher on numerous 64-bit platforms.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enhancing CDS</h1>
                </header>
            
            <article>
                
<p>Often, developers end up not using a feature that could enhance the performance of their application—out of ignorance—by just missing a step. Or should we call it a usability issue?</p>
<p class="mce-root"/>
<p>At present, even though the JDK includes a default class list, it can be used with the following command:</p>
<pre><strong>java -Xshare:dump</strong></pre>
<p>Even though this behavior is documented, developers miss reading the document, and hence, can't use this feature.</p>
<p>JDK 12 modifies the build process. It runs the <kbd>java -Xshare:dump</kbd> command after linking it to the class list. To ensure that the CDS archive file is part of the JDK image, the shared archive file is placed in the <kbd>lib/server</kbd> directory.</p>
<p>The shared archive file is used <strong>automatically</strong> during application startup, since <kbd>-Xshare:auto</kbd> is the default option with the <span>server VM</span><span> in JDK 11. So, unless it is specifically turned off using the</span> <kbd>-Xshare:off</kbd> <span>option, developers and applications will continue using it without executing any additional commands or set up.</span></p>
<p>CDS includes a predefined list of classes and interfaces from the core Java API. For the inclusion of specific API or application classes, or for specific GC behavior, developers can create and use a custom archive file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Abortable mixed collections for G1</h1>
                </header>
            
            <article>
                
<p>Developers are increasingly demanding more definite behavior from GCs. For instance, wouldn't you prefer to execute your application with a GC that guarantees an upper limit to its pause timings?</p>
<p>When working with G1 GC in Java 12, you can abort <em>mixed collections</em> if they exceed your specified limit. Note that you can't abort <em>all</em> categories of G1 GC pauses.</p>
<p>A mixed collection includes both <em>young</em> and <em>old</em> memory regions for G1 to clean. An analysis system selects the set of regions, collectively called a <strong>collection set</strong>, for G1 GC to work on. Prior to JDK 12, G1 GC could exceed the maximum pause time when the collection set was too large, the collection set included too many old regions, or the collection set included regions with <em>stale</em> data.</p>
<p>With JDK 12, when G1 collects live objects from mixed collections, it can do so in an incremental manner, so that it doesn't exceed the maximum pause timings. This process splits the collection set into mandatory and optional parts. After G1 completes collecting live objects from the mandatory collection, it collects objects from the optional set, if time permits.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Promptly return unused committed memory from G1</h1>
                </header>
            
            <article>
                
<p>An additional enhancement to G1 GC—to return the Java heap memory to the <strong>Operating System</strong> (<strong>OS</strong>) when idle. This enhancement is most likely to be triggered by the increase in container environments that are used to run applications on the JVM.</p>
<p>Prior to Java 12, G1 returned memory from the Java heap in two cases—while performing a full GC or during a concurrent cycle. However, neither of these instances happen very often. In fact, G1 performs a full GC as its last resort to free up memory. A concurrent cycle is subjected to the Java heap allocation and occupancy.</p>
<p>This GC behavior has multiple disadvantages—organizations pay more for the memory even though it isn't used in an efficient manner in container environments, and service providers under-utilize their resources. In this enhancement, the JVM determines the <em>idle</em> times for an application and returns the memory to the OS. This makes a lot of sense since the usage of applications isn't the same across the days of the week or even hours of a day. This enhancement can save organizations a lot of money when deploying their application to environments that provide resources as a service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we browsed through the various additions and modifications to JDK 12, barring one of its preview language features of <kbd>switch</kbd> expressions.</p>
<p>The features covered in this chapter were mostly related to the JDK and its implementation. We covered one of the newest additions to the growing GC family—Shenandoah. A concurrent GC, <span>Shenandoah </span>promises ultra-low pause times for modern Java applications, irrespective of their memory sizes. The other two GC features mentioned<span>—</span>abortable mixed collections for G1 and promptly return unused committed memory from G1<span>—</span>also enhance the existing G1 GC.</p>
<p>The JVM constants API introduces a new package and classes to represent class constraints symbolically. Apart from easing its usage across libraries and classes, the JVM constant API will standardize the constants. Default CDS archives improve the process of the creation of archive files. The removal of the source for an <span>AArch</span>64 ARM port is more related to housekeeping.</p>
<p>In the next chapter, we will look into the details and features of Project Amber.</p>


            </article>

            
        </section>
    </body></html>