- en: '*Chapter 8*: GraalVM Polyglot – Java on Truffle, Python, and R'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*: GraalVM多语言支持 – 在Truffle、Python和R上运行的Java'
- en: 'In the previous chapter, we covered JavaScript and Node.js interpreters and
    interoperability between languages. In this chapter, we will cover other language
    implementations such as the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了JavaScript和Node.js解释器以及语言间的互操作性。在本章中，我们将介绍其他语言实现，例如以下内容：
- en: 'Java on Truffle (also called Espresso): Java implementation on Truffle'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java on Truffle（也称为Espresso）：在Truffle上运行的Java实现
- en: 'GraalPython: Python language interpreter implementation'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalPython：Python语言解释器实现
- en: 'FastR: R language interpreter implementation'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FastR：R语言解释器实现
- en: All of these language implementations are still in the *experimental* phase
    so are not released for production at the time of writing the book. However, we
    will explore the features and build some code to understand the various concepts.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些语言实现目前都处于*实验性*阶段，因此在撰写本书时并未发布用于生产的版本。然而，我们将探讨其功能和构建一些代码来理解各种概念。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding Python, R, and Java/Truffle interpreters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Python、R和Java/Truffle解释器
- en: Learning about and exploring language interoperability
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解和探索语言互操作性
- en: Understanding the compatibility and limitations of these various language interpreters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解这些各种语言解释器的兼容性和限制
- en: By the end of this chapter, you will have hands-on experience in building polyglot
    applications with Python, R, and Java/Truffle interpreters.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将获得使用Python、R和Java/Truffle解释器构建多语言应用程序的实践经验。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires the following to follow along with the various coding/hands-on
    sections:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要以下内容才能跟随各种编码/实践部分：
- en: The latest version of GraalVM.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM的最新版本。
- en: Various language Graal runtimes. We will cover in the chapter how to install
    and run these runtimes.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种语言的Graal运行时。我们将在本章中介绍如何安装和运行这些运行时。
- en: 'Access to GitHub: There are some sample code snippets, which are available
    in a Git repository. The code can be downloaded from the following link: [https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter08](https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter08).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问GitHub：有一些示例代码片段，可在Git仓库中找到。代码可以从以下链接下载：[https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter08](https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter08)。
- en: The Code in Action video for this chapter can be found at [https://bit.ly/3fj2iIr](https://bit.ly/3fj2iIr).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的“代码实战”视频可以在[https://bit.ly/3fj2iIr](https://bit.ly/3fj2iIr)找到。
- en: Understanding Espresso (Java on Truffle)
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Espresso（Java on Truffle）
- en: GraalVM 21.0 is a major release that introduces a new guest language runtime
    called Java on Truffle. Before this, we had the option to run Java using HotSpot
    (which we covered in detail in [*Chapter 2*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028),
    *JIT, Hotspot, and GraalJIT*), on Graal JIT (which we covered in [*Chapter 4*](B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077),
    *Graal Just-In-Time Compiler*), or as a native image with Graal AOT (which we
    covered in [*Chapter 5*](B16878_05_Final_SK_ePub.xhtml#_idTextAnchor097), *Graal
    Ahead-of-Time Compiler and Native Image*). With GraalVM 21.0, Java on Truffle
    is the new runtime, which can run Java. It is codenamed Espresso. This is still
    in the *experimental* phase and is not production-ready at the time of writing
    this book. In this section, we will understand how to run Java applications with
    this new runtime, and how this can help polyglot programming.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 21.0是一个重大版本，引入了一个名为Java on Truffle的新客机语言运行时。在此之前，我们有选择使用HotSpot（我们在[*第2章*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028)，*JIT、HotSpot和GraalJIT*）运行Java，在Graal
    JIT（我们在[*第4章*](B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077)，*Graal即时编译器*）上运行，或者使用Graal
    AOT（我们在[*第5章*](B16878_05_Final_SK_ePub.xhtml#_idTextAnchor097)，*Graal预编译器及原生图像*）作为原生图像运行Java。在GraalVM
    21.0中，Java on Truffle是新的运行时，可以运行Java。它的代号为Espresso。这仍然处于*实验性*阶段，在撰写本书时并未准备好用于生产。在本节中，我们将了解如何使用这个新的运行时运行Java应用程序，以及这如何有助于多语言编程。
- en: 'Espresso is a cut-down version of JVM but implements all the core components
    of JVM, such as the bytecode interpreter, bytecode verifier, Java Native Interface,
    the Java Debug Wire Protocol, and so on. Espresso reuses all the classes and native
    libraries from GraalVM. Espresso implements the `libjvm. so` APIs. The following
    figure shows the Espresso stack architecture:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Espresso 是 JVM 的简化版本，但实现了 JVM 的所有核心组件，如字节码解释器、字节码验证器、Java 本地接口、Java 调试协议等。Espresso
    重新使用了 GraalVM 中的所有类和本地库。Espresso 实现了 `libjvm.so` API。以下图显示了 Espresso 栈架构：
- en: '![Figure 8.1 – Espresso stack architecture'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – Espresso 栈架构](img/Figure_8.1_B16878.jpg)'
- en: '](img/Figure_8.1_B16878.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – Espresso 栈架构](img/Figure_8.1_B16878.jpg)'
- en: Figure 8.1 – Espresso stack architecture
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – Espresso 栈架构
- en: The figure shows how Espresso is implemented on top of Truffle.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了 Espresso 在 Truffle 之上的实现方式。
- en: Why do we need Java on Java?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我们需要在 Java 上使用 Java？
- en: 'Running Java on Truffle (Espresso) is counter-intuitive, and you might wonder
    about the advantage of running Java on Truffle, which adds an additional layer
    on top of Graal. The following are some of the advantages of running Espresso:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Truffle（Espresso）上运行 Java 是反直觉的，你可能会想知道在 Graal 上添加额外层运行 Java 的优势。以下是一些运行 Espresso
    的优势：
- en: '**Hotswap methods, lambdas, and access modifiers at runtime/debug time**: Espresso
    provides a way to hot-swap methods, lambdas, and access modifiers at runtime during
    debugging. This is a great feature for developers as it allows them to change
    the code completely while debugging, and without stopping the runtime and recompiling,
    the changes take effect at runtime. This speeds up the developer''s workflow and
    increases productivity. It also helps the developers experiment and try things
    out before committing the code.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**热插拔方法、lambda 表达式和运行时/调试时的访问修饰符**：Espresso 提供了一种在调试期间运行时热插拔方法、lambda 表达式和访问修饰符的方式。这对于开发者来说是一个非常好的特性，因为它允许他们在调试过程中完全更改代码，而无需停止运行时和重新编译，更改将在运行时生效。这加快了开发者的工作流程并提高了生产力。同时，它还帮助开发者在进行代码提交前进行实验和尝试。'
- en: '**A sandbox to run untrusted Java code**: Espresso runs like a sandbox on top
    of Truffle, which can run with access restrictions. This is a great way to run
    untrusted Java code, by providing specific access. Please refer to the *JavaScript
    embedded code in Java* section in [*Chapter 7*](B16878_07_Final_SK_ePub.xhtml#_idTextAnchor138),
    *GraalVM Polyglot - JavaScript and Node.js,* to understand more about how to configure
    the access restrictions.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行不受信任的 Java 代码的沙盒**：Espresso 在 Truffle 上运行，类似于沙盒，可以运行时具有访问限制。这是一种通过提供特定访问权限来运行不受信任的
    Java 代码的绝佳方式。请参阅[*第 7 章*](B16878_07_Final_SK_ePub.xhtml#_idTextAnchor138)中的[*“Java
    中嵌入 JavaScript 代码”*](B16878_07_Final_SK_ePub.xhtml#_idTextAnchor138)部分，*GraalVM
    多语言 - JavaScript 和 Node.js*，以了解更多关于如何配置访问限制的信息。'
- en: '**Interoperability between JVM and non-JVM using the same memory space**: Before
    Espresso, passing data between Java applications and non-JVM dynamic guest languages
    was not done in the same memory space. This might be because of the performance
    impact. With Espresso, we can pass data between Java and non-JVM guest languages
    in the same memory space. This increases the performance of the application.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用相同的内存空间在 JVM 和非 JVM 之间实现互操作性**：在 Espresso 之前，Java 应用程序和非 JVM 动态客户端语言之间的数据传递不是在相同的内存空间中完成的。这可能是由于性能影响。使用
    Espresso，我们可以在相同的内存空间中在 Java 和非 JVM 客户端语言之间传递数据。这提高了应用程序的性能。'
- en: '**Leveraging Truffle tools and instrumentation**: Running Java on Truffle will
    help in using all the analysis, diagnosis, and debugging tools developed with
    Truffle instrumentation. (Refer to the *Understanding Truffle instrumentation*
    section of [*Chapter 6*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120), *Truffle
    – An Overview*.)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利用 Truffle 工具和仪器**：在 Truffle 上运行 Java 将有助于使用所有使用 Truffle 仪器开发的分析、诊断和调试工具。（请参阅[*第
    6 章*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120)中的[*“理解 Truffle 仪器”*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120)部分，*Truffle
    – 概述*。）'
- en: '`native-image`.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`native-image`。'
- en: '**Running mixed versions of Java**: Espresso provides the required isolation
    layer to run Java code that is written in Java 8 to run on Java 11\. The Java
    8 code can be run on Espresso, which might be running on GraalVM Java 11\. This
    helps in running older code, without changing it, and could be a step in carefully
    modernizing the code, instead of the big-bang modernization approach that we adopt
    when we move from the older version of Java to the newer version of Java.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行混合版本的 Java**：Espresso 提供了所需的隔离层，以便运行用 Java 8 编写的代码，使其能够在 Java 11 上运行。Java
    8 代码可以在 Espresso 上运行，而 Espresso 可能正在运行 GraalVM Java 11。这有助于在不更改代码的情况下运行旧代码，并且可能是谨慎地现代化代码的步骤，而不是我们在从旧版本的
    Java 迁移到新版本的 Java 时采用的爆炸式现代化方法。'
- en: Let's now install and run simple Java code on Espresso.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来安装和运行简单的 Java 代码在 Espresso 上。
- en: Installing and running Espresso
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和运行 Espresso
- en: 'Espresso is an optional runtime; it has to be downloaded and installed separately
    using the Graal Updater tool. Here is the command to install Espresso:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Espresso 是一个可选的运行时环境；它必须通过 Graal Updater 工具单独下载和安装。以下是安装 Espresso 的命令：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To test whether Espresso is installed, let''s execute a simple `HelloEspresso.java`
    application. It is a very simple `Hello World` program, which prints a message.
    Check out the following code for `HelloEspresso.java`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试 Espresso 是否已安装，让我们执行一个简单的 `HelloEspresso.java` 应用程序。这是一个非常简单的 `Hello World`
    程序，它打印一条消息。查看以下 `HelloEspresso.java` 的代码：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s compile this application using `javac` and run it with the following
    command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `javac` 编译这个应用程序，并使用以下命令运行它：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To run Java on Truffle, we just have to pass `-truffle` as a command-line argument
    to `java`. After running this, we should see the following output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Truffle 上运行 Java，我们只需将 `-truffle` 作为命令行参数传递给 `java`。运行此命令后，我们应该看到以下输出：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This validates the installation. We can also use the `-jar` argument along with
    `-truffle` to run a JAR file. Now let's explore the polyglot capabilities of Espresso.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这验证了安装。我们还可以使用 `-jar` 参数与 `-truffle` 一起运行 JAR 文件。现在让我们探索 Espresso 的多语言功能。
- en: Exploring polyglot interoperability with Espresso
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 Espresso 与其他 Truffle 语言的互操作性
- en: Espresso is built on Truffle and implements the Truffle polyglot and interoperability
    APIs. In this section, we will explore these features.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Espresso 是基于 Truffle 构建的，并实现了 Truffle 多语言和互操作性 API。在本节中，我们将探索这些功能。
- en: Before we start using the polyglot features, we have to install Espresso polyglot
    features. To install Espresso polyglot features, we may have to download the Espresso
    JAR file. You can find the latest version at [https://www.oracle.com/downloads/graalvm-downloads.html](https://www.oracle.com/downloads/graalvm-downloads.html).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 polyglot 功能之前，我们必须安装 Espresso polyglot 功能。要安装 Espresso polyglot 功能，我们可能需要下载
    Espresso JAR 文件。您可以在 [https://www.oracle.com/downloads/graalvm-downloads.html](https://www.oracle.com/downloads/graalvm-downloads.html)
    找到最新版本。
- en: 'The following screenshot shows the JAR file that we will have to download,
    at the time of writing the book:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在撰写本书时我们需要下载的 JAR 文件：
- en: '![Figure 8.2 – Java on Truffe JAR file download'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – Java 在 Truffe JAR 文件下载'
- en: '](img/Figure_8.2_B16878.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.2_B16878.jpg]'
- en: Figure 8.2 – Java on Truffe JAR file download
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – Java 在 Truffe JAR 文件下载
- en: 'Once we download this file, we can install it by running the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下载此文件后，我们可以通过运行以下命令来安装它：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once the installation is successful, we have to rebuild the `libpolyglot` native
    image, to include Espresso libraries. This library is required to run polyglot
    support:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 安装成功后，我们必须重新构建 `libpolyglot` 本地镜像，以包含 Espresso 库。这个库是运行 polyglot 支持所必需的：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will rebuild the `libpolyglot` native image. We are now ready to use the
    polyglot capabilities of Espresso. Let's explore these features in the following
    section.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将重新构建 `libpolyglot` 本地镜像。我们现在可以使用 Espresso 的多语言功能了。让我们在下一节中探索这些功能。
- en: Exploring Espresso interoperability with other Truffle languages
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 Espresso 与其他 Truffle 语言的互操作性
- en: 'As you''re now aware, Espresso implements the Truffle implementation framework
    and the `com.oracle.truffle.espresso.polyglot.Polyglot` class implements the polyglot
    in Espresso. Like any other guest language, we use `-polyglot` in the command-line
    argument to let Truffle know how to create the polyglot context. Espresso injects
    a `Polyglot` object into the code, which can be used to interoperate with other
    languages. Let''s explore polyglot programming with Espresso by running the following
    code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Espresso 实现了 Truffle 实现框架，而 `com.oracle.truffle.espresso.polyglot.Polyglot`
    类实现了 Espresso 中的多语言支持。像任何其他客户端语言一样，我们在命令行参数中使用 `-polyglot` 来让 Truffle 知道如何创建多语言上下文。Espresso
    将一个 `Polyglot` 对象注入到代码中，可以用来与其他语言进行交互。让我们通过运行以下代码来探索使用 Espresso 的多语言编程：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s understand the preceding code. The `Polyglot` object provides context
    for running dynamic languages. The `Polyglot.eval()` method runs foreign language
    code. The first parameter suggests that it is JavaScript code, and the second
    parameter is the actual JavaScript code that we want to execute. Let''s compile
    this code with the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解前面的代码。`Polyglot` 对象为运行动态语言提供上下文。`Polyglot.eval()` 方法运行外语言代码。第一个参数表明它是 JavaScript
    代码，第二个参数是我们想要执行的实际的 JavaScript 代码。让我们使用以下命令来编译此代码：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this command, we are explicitly passing the `polyglot.jar` file in the `-cp`
    argument (`CLASSPATH`). `polyglot.jar` has all the polyglot implementation of
    Espresso, including the `com.oracle.truffle.espresso.polyglot.Polyglot` import.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在此命令中，我们明确地将 `polyglot.jar` 文件传递到 `-cp` 参数（`CLASSPATH`）中。`polyglot.jar` 包含了
    Espresso 的所有多语言实现，包括 `com.oracle.truffle.espresso.polyglot.Polyglot` 的导入。
- en: 'Let''s now run the Java application on Espresso. We should pass the `-truffle`
    argument to run it on Espresso, if we don''t do that, it runs on Host JVM. We
    can see the following output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在 Espresso 上运行 Java 应用程序。如果我们想在 Espresso 上运行它，应该传递 `-truffle` 参数，如果不这样做，它将在主机
    JVM 上运行。我们可以看到以下输出：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Similarly, we can call other language code. Java is a typed language, unlike
    other dynamically typed languages on Truffle. When we exchange data between Espresso
    (Java on Truffle) and other dynamically typed languages such as JavaScript, Python,
    and so on, we need a way to cast the data types. The `polyglot` object provides
    a way to cast the data with the `Polyglot.cast()` method. Let''s use a simple
    application to understand how to cast the data, with the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以调用其他语言代码。Java 是一种强类型语言，与 Truffle 上的其他动态类型语言不同。当我们交换 Espresso（Truffle
    上的 Java）和其他动态类型语言（如 JavaScript、Python 等）之间的数据时，我们需要一种方法来转换数据类型。`polyglot` 对象提供了使用
    `Polyglot.cast()` 方法转换数据的方式。让我们通过以下代码使用一个简单的应用程序来理解如何转换数据：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Import the `Polyglot` and `Interop` classes. The `Polyglot` class helps us
    to run guest languages and the `Interop` class implements the Truffle interoperability
    API, which abstracts the data types between guest languages. Truffle defines an
    interoperability protocol that provides a clear specification on how the data
    and message (method calls) exchange happens between Truffle languages, tools,
    and embedders:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 `Polyglot` 和 `Interop` 类。`Polyglot` 类帮助我们运行客户端语言，而 `Interop` 类实现了 Truffle
    互操作性 API，它抽象了客户端语言之间的数据类型。Truffle 定义了一个互操作性协议，它对 Truffle 语言、工具和嵌入器之间如何进行数据和消息（方法调用）交换提供了明确的规范：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code snippet, we are evaluating various JavaScript code snippets
    that return a string, integer, double, an `array` of integers and a `boolean`
    value. These values are assigned to a generic `Object`, and then later cast to
    the respective Java type `String`, `Integer`, `Double`, `Integer[]`, and `Boolean`
    objects using `Polyglot.cast()`, as observed in the following code snippet:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们正在评估各种返回字符串、整数、双精度浮点数、整数数组和一个布尔值的 JavaScript 代码片段。这些值被分配给一个通用的 `Object`，然后稍后使用
    `Polyglot.cast()` 方法转换为相应的 Java 类型 `String`、`Integer`、`Double`、`Integer[]` 和 `Boolean`
    对象，如以下代码片段所示：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we''ll print the values. To handle arrays, let''s use the `Interop` class
    to get information about the array object, such as the size of the array with
    `Interop.getArraySize()`, and iterate through the array with `Interop.readArrayElement()`.
    `Interop` also provides a way to check the type of the object and extract the
    value in a specific data type. In our example, we have evaluated a JavaScript
    array that has a sequence of integer, double, and string objects. We will use
    `Interop.fitsInInt()`, `Interop.fitsInDouble()`, and `Interop.isString()` methods
    to check the types, and accordingly extract the values using `Interop.asInt()`,
    `Interop.asDouble()`, and `Interop.asString()` methods. The following is the code
    snippet:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将打印这些值。为了处理数组，让我们使用 `Interop` 类来获取数组对象的信息，例如使用 `Interop.getArraySize()`
    获取数组的大小，并使用 `Interop.readArrayElement()` 遍历数组。`Interop` 还提供了一种检查对象类型并提取特定数据类型值的方法。在我们的例子中，我们评估了一个包含整数、双精度浮点数和字符串对象的
    JavaScript 数组。我们将使用 `Interop.fitsInInt()`、`Interop.fitsInDouble()` 和 `Interop.isString()`
    方法来检查类型，并相应地使用 `Interop.asInt()`、`Interop.asDouble()` 和 `Interop.asString()` 方法提取值。以下是一个代码片段：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'These values are then printed. Let''s compile and run this application. The
    following is the output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值随后被打印出来。让我们编译并运行这个应用程序。以下是其输出：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the output, we can see how a dynamically cast language (JavaScript) is captured
    in a generic `Object` and later cast to specific types. We can also use `Polyglot.isForeignObject(<object>)`
    to check whether the passed object is a local object or a foreign object.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们可以看到如何将动态类型语言（JavaScript）捕获在通用的 `Object` 中，然后将其转换为特定类型。我们还可以使用 `Polyglot.isForeignObject(<object>)`
    来检查传递的对象是本地对象还是外部对象。
- en: We saw how we can call other Truffle languages from Espresso, the same way other
    languages are invoked with `Context polyglot = Context.newBuilder().allowAllAccess(true).build()`
    and using bindings (refer to the *Bindings* section of [*Chapter 7*](B16878_07_Final_SK_ePub.xhtml#_idTextAnchor138),
    *GraalVM Polyglot - JavaScript and Node.js*) to exchange data and invoke methods.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何从 Espresso 中调用其他 Truffle 语言，就像使用 `Context polyglot = Context.newBuilder().allowAllAccess(true).build()`
    调用其他语言一样，并使用绑定（参考 [*第 7 章*](B16878_07_Final_SK_ePub.xhtml#_idTextAnchor138)，*GraalVM
    Polyglot - JavaScript 和 Node.js*) 交换数据和调用方法。
- en: Java on Truffle Espresso is in very early releases and is at an experimental
    stage at the time of writing this book. There are a lot of limitations at present,
    such as a lack of support for the JVM Tool Interface and Java Management Extensions.
    There are even a lot of performance issues at this point. Please refer to [https://www.graalvm.org/reference-manual/java-on-truffle/](https://www.graalvm.org/reference-manual/java-on-truffle/)
    for the latest updates.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Java on Truffle Espresso 目前处于非常早期的版本，并且在撰写本书时处于实验阶段。目前存在许多限制，例如不支持 JVM 工具接口和
    Java 管理扩展。在此阶段甚至存在许多性能问题。请参阅 [https://www.graalvm.org/reference-manual/java-on-truffle/](https://www.graalvm.org/reference-manual/java-on-truffle/)
    获取最新更新。
- en: Let's now look at two of the most important languages for machine learning –
    Python and R.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看机器学习中最重要的两种语言 – Python 和 R。
- en: Understanding GraalPython – the Python Truffle interpreter
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 GraalPython – Python Truffle 解释器
- en: GraalVM provides a Python runtime. The Python runtime is 3.8 version-compliant
    and is still in the *experimental* phase at the time of writing this book. In
    this section, we will install and understand how Python runs on Truffle and Graal.
    We will also build some sample code, to understand the interoperability features
    of Graal Python.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 提供了一个 Python 运行时环境。Python 运行时环境符合 3.8 版本，并且在撰写本书时仍处于 *实验* 阶段。在本节中，我们将安装并理解
    Python 在 Truffle 和 Graal 上的运行方式。我们还将构建一些示例代码，以了解 Graal Python 的互操作性功能。
- en: Installing Graal Python
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Graal Python
- en: 'Graal Python is an optional runtime and is not installed by default along with
    GraalVM. To download it, you have to use the Graal Updater tool. The following
    command downloads and installs Graal Python:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Graal Python 是一个可选的运行时环境，并且默认情况下不会与 GraalVM 一起安装。要下载它，您必须使用 Graal Updater 工具。以下命令下载并安装
    Graal Python：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To validate the installation, let''s run simple Python code. The following
    is the source code of `HelloGraalPython.py`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证安装，让我们运行简单的 Python 代码。以下是 `HelloGraalPython.py` 的源代码：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It''s a very simple Hello World application where we are printing the message.
    Let''s run this application using `graalpython`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的 Hello World 应用程序，其中我们正在打印消息。让我们使用 `graalpython` 运行这个应用程序：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we execute the preceding command, we should see the output shown next:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行前面的命令时，我们应该看到下面的输出：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding output shows that the application is running, and `graalpython`
    is working.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示应用程序正在运行，`graalpython`正在工作。
- en: '`graalpython` also supports a virtual environment. The following command will
    create a virtual environment:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`graalpython`也支持虚拟环境。以下命令将创建一个虚拟环境：'
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This command will create a virtual environment directory, which will be an
    isolated environment. GraalPython also comes with `ginstall`, a tool to install
    supported libraries. The following command will install `numpy` for `graalpython`.
    `pip` can also be used to install libraries:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将创建一个虚拟环境目录，这将是一个隔离的环境。GraalPython还附带`ginstall`工具，用于安装支持的库。以下命令将为`graalpython`安装`numpy`。也可以使用`pip`安装库：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's now understand how the GraalPython compilation and interpreter pipeline
    works.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们了解GraalPython的编译和解释器管道是如何工作的。
- en: Understanding the graalpython compilation and interpreter pipeline
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解graalpython编译和解释器管道
- en: 'Graalpython is a slightly different compilation/interpreter pipeline. To improve
    the performance of parsing, Graalpython uses an intermediate representation called
    `.pyc` file, after the parsing. This is done to speed up the parsing. The next
    time we run the Python program, `Graalpython` looks for the `.pyc` file and validates
    whether the file exists, and if it matches the Python source code, then it will
    deserialize that to build the SST and ST. Otherwise, it will do a full parsing
    using ANTLR. The following figure shows the full flow. The diagram does not capture
    all the details. Refer to the *Exploring the Truffle Interpreter/Compiler pipeline*
    section in [*Chapter 6*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120), *Truffle
    – An Overview,* for a more detailed explanation on how Truffle interpreters and
    Graal JIT execute the code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Graalpython的编译/解释器管道略有不同。为了提高解析性能，解析后，Graalpython使用一个名为`.pyc`文件的中间表示形式，这样做是为了加快解析速度。下次我们运行Python程序时，`Graalpython`会查找`.pyc`文件并验证文件是否存在，以及它是否与Python源代码匹配；如果是，它将反序列化该文件以构建SST和ST。否则，它将使用ANTLR进行完整解析。以下图显示了完整流程。该图并未捕捉所有细节。请参阅*第6章*中“探索Truffle解释器/编译器管道”部分[*第6章*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120)，*Truffle
    – 概述*，以获取关于Truffle解释器和Graal JIT如何执行代码的更详细解释：
- en: '![Figure 8.3 – Graalpython compilation/interpreter pipeline'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 – Graalpython编译/解释器管道'
- en: '](img/Figure_8.3_B16878.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.3_B16878.jpg)'
- en: Figure 8.3 – Graalpython compilation/interpreter pipeline
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – Graalpython编译/解释器管道
- en: Once the SST and ST are created, they are then converted to an AST intermediate
    representation and optimized. The final specialized AST is submitted to GraalJIT
    for further execution after partial evaluation, and the usual flow continues,
    as explained in *Exploring the Truffle interpreter/compiler pipeline* section
    of [*Chapter 6*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120), *Truffle – An
    Overview*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了SST和ST，它们随后将被转换为AST中间表示形式并进行优化。在部分评估之后，最终的专用AST将被提交给GraalJIT进行进一步执行，然后继续常规流程，如*第6章*中“探索Truffle解释器/编译器管道”部分所述[*第6章*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120)，*Truffle
    – 概述*。
- en: So far, we have learned how to run Python programs with GraalPython and how
    GraalPython optimizes the parsing and optimizes the code using Truffle and GraalJIT.
    Let's now explore the polyglot interoperability features of GraalPython.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何使用GraalPython运行Python程序以及GraalPython如何使用Truffle和GraalJIT优化解析和代码优化。现在让我们探索GraalPython的多语言互操作性功能。
- en: Exploring interoperability between Java and Python
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索Java和Python之间的互操作性
- en: 'In this section, we will explore the interoperability between Java and Python
    with sample Java code. The following code calculates the sum of Fibonacci numbers.
    This class has a `findFibonacci()` method, which takes in the number of Fibonacci
    numbers we need and returns an array of those Fibonacci numbers:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过示例Java代码探索Java和Python之间的互操作性。以下代码计算斐波那契数的和。此类有一个`findFibonacci()`方法，它接受我们需要计算的斐波那契数的数量，并返回这些斐波那契数的数组：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s now call the `findFibonacci()` method from Python code. The following
    is the Python code for calling the method and iterating through the array that
    is returned by the Java class:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从Python代码中调用`findFibonacci()`方法。以下是从Java类返回的数组中调用该方法并迭代的Python代码：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code, we are using `java.type()` to load the Java class, and
    we are directly using the returned value as a Python object to call the `findFibonacci()`
    method, by passing a parameter. We are then able to parse through the result that
    is returned by the method. Let''s compile the Java code and run the Python code.
    The following shows the terminal output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `java.type()` 加载 Java 类，并直接使用返回的值作为 Python 对象来调用 `findFibonacci()`
    方法，通过传递一个参数。然后我们能够解析方法返回的结果。让我们编译 Java 代码并运行 Python 代码。以下显示了终端输出：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can see that we are able to call the Java method and get an array of integers
    and iterate through that, without any extra code for conversion.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们能够调用 Java 方法并获取一个整数数组，然后遍历它，而不需要任何额外的转换代码。
- en: Now let's create a simple Python function that uses NumPy to do some quick analysis
    on a dataset. NumPy is a high-performing Python library for array/matrix manipulations
    and is widely used in machine learning. To appreciate the value of Graal polyglot,
    imagine a use case where we have a dataset that has information about various
    heart attack cases, organized by age, sex, cholesterol levels, chest pain level,
    and so on, and we want to understand what the average age of the people who had
    a heart attack after level 3 (high) chest pain is. That is what we will build
    in this section, to understand the polyglot interoperability between Java and
    Python, and how we can use the NumPy Python library.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个简单的 Python 函数，该函数使用 NumPy 对数据集进行快速分析。NumPy 是一个用于数组/矩阵操作的高性能 Python
    库，在机器学习中得到广泛应用。为了欣赏 Graal 多语言的价值，想象一个用例，其中我们有一个包含各种心脏病病例信息的数据集，按年龄、性别、胆固醇水平、胸痛程度等组织，我们想了解在胸痛程度达到
    3 级（高）后心脏病发作的人的平均年龄。这就是本节我们将要构建的内容，以了解 Java 和 Python 之间的多语言互操作性，以及我们如何使用 NumPy
    Python 库。
- en: 'We will use the dataset that is provided on Kaggle on heart attack analysis
    ([https://www.kaggle.com/rashikrahmanpritom/heart-attack-analysis-prediction-dataset](https://www.kaggle.com/rashikrahmanpritom/heart-attack-analysis-prediction-dataset)).
    This dataset has information about the various heart attack cases, with age, cholesterol
    levels, sex, chest pain levels, and so on. Here is the Python code to perform
    the analysis:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Kaggle 上提供的用于心脏病分析的数据集（[https://www.kaggle.com/rashikrahmanpritom/heart-attack-analysis-prediction-dataset](https://www.kaggle.com/rashikrahmanpritom/heart-attack-analysis-prediction-dataset)）。这个数据集包含了各种心脏病病例的信息，包括年龄、胆固醇水平、性别、胸痛程度等。以下是执行分析的
    Python 代码：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, we are loading the CSV file into a matrix. Here, we are
    particularly interested in the third column (indexed as `2`). We are loading all
    the rows where the third column value is greater than 2, and storing it in another
    variable. We are then averaging that matrix and returning it. This would have
    taken a lot of code if we had to do the same in Java. Now, let's call this code
    from Java.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将 CSV 文件加载到一个矩阵中。在这里，我们特别关注第三列（索引为 `2`）。我们正在加载所有第三列值大于 2 的行，并将其存储在另一个变量中。然后我们计算这个矩阵的平均值并返回它。如果我们不得不在
    Java 中做同样的事情，这将需要大量的代码。现在，让我们从 Java 中调用这段代码。
- en: 'In the following Java code, we will be importing the function definition using
    the key through the `Binding` object. Here''s the complete Java code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的 Java 代码中，我们将通过 `Binding` 对象使用键导入函数定义。以下是完整的 Java 代码：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the previous Java code, we are creating a `Context` object and evaluating
    the Python code in `numpy-example.py`. We are then accessing the function definition
    through binding and invoking the Python function and are able to get the value.
    We are printing the value that is returned. The following is the output of running
    this Java code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 Java 代码中，我们创建了一个 `Context` 对象，并在 `numpy-example.py` 中评估 Python 代码。然后我们通过绑定访问函数定义，调用
    Python 函数并能够获取值。我们打印返回的值。以下是运行此 Java 代码的输出：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding output, we can see that the first call took time, however,
    the subsequent calls took almost no time at all to execute. This not only demonstrates
    how we can interoperate with Python code from Java code but also how Truffle and
    Graal optimize the execution.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到第一次调用花费了时间，然而，随后的调用几乎不需要时间就能执行。这不仅展示了我们如何从 Java 代码中与 Python 代码进行互操作，还展示了
    Truffle 和 Graal 如何优化执行。
- en: In this section, we explored Java and Python interoperability. In the next section,
    we will explore interoperability between dynamic languages with Python.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了 Java 和 Python 的互操作性。在下一节中，我们将探讨 Python 与动态语言之间的互操作性。
- en: Exploring interoperability between Python and other dynamic languages
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 Python 与其他动态语言之间的互操作性
- en: To explore interoperability between Python and other dynamic languages, let's
    use the same `numpy-example.py` that we used in the previous section. Let's call
    this method from JavaScript.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索 Python 与其他动态语言之间的互操作性，让我们使用上一节中使用的相同 `numpy-example.py` 文件。让我们从 JavaScript
    中调用此方法。
- en: 'The following is the JavaScipt that calls the Python code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 JavaScript 中调用 Python 代码的示例：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the previous code, we can see how we are importing the Python `heartAnalysis()`
    function in JavaScript using the `Polyglot.import()` function. This returns the
    average value that we are printing. Let''s run this code, and we can see the following
    result:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们是如何使用 `Polyglot.import()` 函数在 JavaScript 中导入 Python 的 `heartAnalysis()`
    函数的。这返回了我们打印的平均值。让我们运行此代码，我们可以看到以下结果：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s now create JavaScript code, which will have functions to calculate squares.
    To demonstrate how JavaScript code can be called from Python, here''s the JavaScript
    code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来创建 JavaScript 代码，它将包含计算平方的函数。为了演示如何从 Python 调用 JavaScript 代码，以下是 JavaScript
    代码：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It's a very simple JavaScript function that returns the square of the passed
    value. We are also exporting the `square()` function and a variable message, which
    carries the value of the `helloMathMessage` variable.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的 JavaScript 函数，它返回传入值的平方。我们还导出了 `square()` 函数和一个变量 `message`，它携带 `helloMathMessage`
    变量的值。
- en: 'Now let''s invoke this method from Python code. The following is the Python
    code that will import and invoke the preceding JavaScript methods:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从 Python 代码中调用此方法。以下是将导入和调用前面 JavaScript 方法的 Python 代码：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this code, we are using the Python `polyglot` object to evaluate the JavaScript
    file. We then imported all the exported functions/variables by calling the `polyglot.import_value()`
    function, by using the same key used by JavaScript to export functions or variables.
    We are then able to invoke those functions and access the `message` variable and
    print the values. The following output is what you get after you run the preceding
    code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用 Python 的 `polyglot` 对象来评估 JavaScript 文件。然后我们通过调用 `polyglot.import_value()`
    函数导入所有导出的函数/变量，使用 JavaScript 导出函数或变量时使用的相同键。然后我们能够调用这些函数并访问 `message` 变量并打印值。以下是在运行前面的代码后得到的输出：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We can see how Python code is importing and invoking JavaScript code. This demonstrates
    two-way interoperability. The code is very similar to other languages, such as
    R and Ruby.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 Python 代码是如何导入和调用 JavaScript 代码的。这证明了双向互操作性。代码与其他语言，如 R 和 Ruby，非常相似。
- en: In this section, we explored and gained a good understanding of how the Python
    interpreter works with Truffle to run optimally on GraalVM. Let's now explore
    and understand the R language interpreter on GraalVM.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了 Python 解释器如何与 Truffle 一起在 GraalVM 上运行以实现最佳性能。现在让我们探索并理解 GraalVM 上的
    R 语言解释器。
- en: Understanding FastR – the R Truffle interpreter
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 FastR – R Truffle 解释器
- en: GraalVM provides an R Truffle interpreter for a GNU-compatible R runtime. This
    runtime supports R programs and **REPL** (**read-eval-print-loop**) mode, where
    we can rapidly test the code while we write the code interactively. FastR is the
    project that developed this R runtime.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 为兼容 GNU 的 R 运行时提供了一个 R Truffle 解释器。此运行时支持 R 程序和 **REPL**（**读取-评估-打印循环**）模式，在此模式下，我们可以在编写代码的同时快速测试代码。FastR
    是开发此 R 运行时的项目。
- en: Installing and running R
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和运行 R
- en: 'Just like Graal Python, the R runtime does not come with GraalVM by default.
    We have to download and install it using Graal Updater. Use the following command
    to download and install R and Rscript:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Graal Python 一样，R 运行时默认不包含在 GraalVM 中。我们必须使用 Graal Updater 下载和安装它。使用以下命令下载和安装
    R 和 Rscript：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To run R, we need the OpenMP runtime library. This can be installed using `apt-get
    install libcomp1` on Ubuntu and `yum install libcomp` on Oracle Linux. The library
    is installed in macOS by default. Apart from this, you will need C/C++/Fortran,
    if the R code has C/C++/Fortran code. R is also in the experimental phase at the
    time of writing this book, so not everything is supported yet. Please refer to
    the GraalVM documentation ([https://docs.oracle.com/en/graalvm/enterprise/20/docs/reference-manual/r/](https://docs.oracle.com/en/graalvm/enterprise/20/docs/reference-manual/r/))
    for the latest information.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行R，我们需要OpenMP运行时库。在Ubuntu上可以使用`apt-get install libcomp1`安装，在Oracle Linux上使用`yum
    install libcomp`安装。在macOS上默认已安装该库。除此之外，如果R代码中有C/C++/Fortran代码，您还需要C/C++/Fortran。在撰写本书时，R还处于实验阶段，因此并非所有功能都得到支持。请参阅GraalVM文档（[https://docs.oracle.com/en/graalvm/enterprise/20/docs/reference-manual/r/](https://docs.oracle.com/en/graalvm/enterprise/20/docs/reference-manual/r/)）以获取最新信息。
- en: 'Let''s now test R. To explore the R interpreter, let''s run it in interactive
    mode. The following terminal output shows the interactive mode to test R installation:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来测试R。为了探索R解释器，让我们以交互式模式运行它。以下终端输出显示了测试R安装的交互式模式：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We see that we are using the FastR GraalVM version from the version numbers
    listed in the preceding output. Let''s now test whether our FastR interpreter
    is working by running some Python commands as shown next:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们正在使用先前的输出中列出的FastR GraalVM版本。现在让我们通过运行一些Python命令来测试我们的FastR解释器是否正常工作，如下所示：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can see that it is interactively providing the results. Let''s now just
    plot a simple example. The best way is to call `example()`, which will show the
    plot, as shown next:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它正在交互式地提供结果。现在让我们绘制一个简单的示例。最好的方法是调用`example()`，这将显示图表，如下所示：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will result in a pop-up window with the plotted graph. The following figure
    shows a screenshot of the graph that popped up:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这将弹出一个包含绘制图表的窗口。以下图显示了弹出的图表截图：
- en: '![](img/Figure_8.4_B16878.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_8.4_B16878.jpg)'
- en: Figure 8.4 – R Plot output screenshot
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – R绘图输出截图
- en: 'At the time of writing this book, some warnings appeared while running the
    preceding `plot` commands. These warnings list some of the limitations of FastR.
    However, this might change in upcoming versions. The following are the warnings
    that popped up:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，运行先前的`plot`命令时出现了一些警告。这些警告列出了FastR的一些限制。然而，这可能在未来的版本中发生变化。以下为出现的警告：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now that we can see R is working fine, let's now explore the interoperability
    features of FastR.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到R运行正常，现在让我们探索FastR的互操作性功能。
- en: Exploring the interoperability of R
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索R的互操作性
- en: 'In this section, to explore polyglot and interoperability with R, we will run
    some inline JavaScript and also load sample JavaScript code and import the exported
    functions and variables. We will use R interactive mode to do this so that it''s
    easy to understand. To run R in polyglot mode, we have to pass the `--polyglot`
    argument. The following is the command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，为了探索多语言与R的互操作性，我们将运行一些内联JavaScript，并加载示例JavaScript代码以及导入导出的函数和变量。我们将使用R交互式模式来完成此操作，以便更容易理解。要在多语言模式下运行R，我们必须传递`--polyglot`参数。以下为命令：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This will start the R runtime in interactive mode with the following output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动R的交互式运行时，并输出以下内容：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let''s start with simple inline JavaScript:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从简单的内联JavaScript开始：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the preceding interactive session, we are calling the `eval.polyglot()`
    function, with the language ID and the expression. In this case, we are specifying
    it as JavaScript with a language ID of `js` and then passing an array of elements.
    Then we are printing the array and the third element in the array. The `eval.polyglot()`
    function provides the polyglot context and runs other language code. Now let''s
    load a simple JavaScript code file. The following is the code for `math.js`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的交互会话中，我们正在调用`eval.polyglot()`函数，其中包含语言ID和表达式。在这种情况下，我们将其指定为JavaScript，语言ID为`js`，然后传递一个元素数组。然后我们打印数组及其第三个元素。`eval.polyglot()`函数提供多语言上下文并运行其他语言代码。现在让我们加载一个简单的JavaScript代码文件。以下为`math.js`的代码：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding code is very straightforward. We have defined the `add()`, `subtract()`,
    and `multiply()` functions and a simple variable, `message`, which has a string
    value, `Hello Math.js`. We are then using `Polyglot.export()` to export it for
    other languages to have access to these functions and the variable.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码非常直接。我们定义了`add()`、`subtract()`和`multiply()`函数以及一个简单的变量`message`，它有一个字符串值`Hello
    Math.js`。然后我们使用`Polyglot.export()`将其导出，以便其他语言可以访问这些函数和变量。
- en: 'Now let''s load this JavaScript file and execute the exported code; we will
    be running the instructions in interactive mode. You''ll find the interactive
    session here, with an explanation of what we are doing:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们加载这个JavaScript文件并执行导出的代码；我们将在交互模式下运行指令。你将在这里找到交互会话，其中解释了我们正在做什么：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This instruction loads the JavaScript file. Make sure that the path is updated
    with the exact path where you have the JavaScript file. Now let''s import the
    exported functions and variable into R:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令加载JavaScript文件。确保路径已更新为包含JavaScript文件的精确路径。现在让我们将导出的函数和变量导入R：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the preceding instructions, we are using the `import()` function to import
    the exported functions and variables. It is very important to use the same string
    that we used to export in the JavaScript file. These imports are assigned to a
    variable. Now let''s call these functions and print the variable:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的说明中，我们正在使用`import()`函数导入导出的函数和变量。使用与JavaScript文件中导出时相同的字符串非常重要。这些导入被分配给一个变量。现在让我们调用这些函数并打印变量：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As you can see, we can call the JavaScript functions and print the variable.
    This demonstrates how we can use JavaScript but we can similarly use all other
    Truffle languages. Let''s now explore how to access a Java class from R. Here
    is the code for the `HelloRPolyglot` class, which we will be calling from R:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以调用JavaScript函数并打印变量。这展示了我们可以如何使用JavaScript，但我们同样可以使用所有其他Truffle语言。现在让我们探索如何从R访问Java类。以下是`HelloRPolyglot`类的代码，我们将从R调用它：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Let's understand the preceding code. We have a static method, `helloStatic()`,
    that calls inline JavaScript, which prints a message, and we have another method,
    `hello()`, that takes an argument and prints a `hello` message.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解前面的代码。我们有一个静态方法`helloStatic()`，它调用内联JavaScript，打印一条消息，我们还有一个另一个方法`hello()`，它接受一个参数并打印一条`hello`消息。
- en: 'Let''s compile and run the Java class to test whether it works fine. The following
    shows the console output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译并运行Java类以测试它是否运行正常。以下显示了控制台输出：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now that the class is working fine, let''s start the R interactive mode. This
    time, we have to pass the `--jvm` argument to let the R runtime know that we will
    be using Java, and also pass the `--vm` argument, to set `CLASSPATH` to the current
    directory where we have the Java class file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在类运行正常，让我们开始R交互模式。这次，我们必须传递`--jvm`参数，让R运行时知道我们将使用Java，并且还需要传递`--vm`参数，将`CLASSPATH`设置为包含Java类文件的当前目录：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now that the R is loaded, let''s run the instructions to call the `hello()`
    method in the Java class. We use the `java.type()` function to load the class.
    The following is the interactive session:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在R已加载，让我们运行调用Java类中`hello()`方法的指令。我们使用`java.type()`函数来加载类。以下是在线会话：
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the preceding interactive session, we can see that the class is loaded successfully,
    and when we print the class, we see that it lists the various methods in it. Now
    let''s create an instance of this class. We use the `new()` function to do that.
    The following is the output of the interactive session with the `new()` function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的交互会话中，我们可以看到类已成功加载，当我们打印类时，我们看到它列出了其中的各种方法。现在让我们创建这个类的实例。我们使用`new()`函数来做这件事。以下是在使用`new()`函数的交互会话的输出：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the preceding code, we can see that the object is successfully created,
    as it prints all the methods in the class. Now let''s call these methods. We will
    use the class to call the static method and object to call `hello()`, by passing
    a parameter. The following is the output of the interactive session:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到对象已成功创建，因为它打印了类中的所有方法。现在让我们调用这些方法。我们将使用类来调用静态方法，并通过传递参数来调用`hello()`方法。以下是在线会话的输出：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the preceding session, we can see the output of calling both the methods.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的会话中，我们可以看到调用两个方法的输出。
- en: Let's take a real-life example of how we can use the power of plotting a graph
    using R and use the plotted graph in Node.js. Earlier in the chapter, we used
    a dataset that we got from Kaggle that has heart attack data. Let's use that dataset
    to plot a graph comparing the ages of people and their cholesterol levels on a
    web page that is generated by Node.js.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个现实生活中的例子来说明我们如何使用 R 绘制图表的强大功能，并在 Node.js 生成的网页中使用绘制的图表。在本书的早期章节中，我们使用了一个从
    Kaggle 获取的数据集，其中包含心脏病数据。让我们使用这个数据集在由 Node.js 生成的网页上绘制一个比较人们年龄和胆固醇水平的图表。
- en: 'Let''s initialize a Node.js project with npm init. The following is the output
    console where we are providing the name of the project and other project parameters:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 npm init 初始化一个 Node.js 项目。以下是在控制台输出的输出，其中我们提供了项目的名称和其他项目参数：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This should generate a Node.js boilerplate. We will need the Express.js library
    to expose a REST endpoint. Let''s now install the express library and use `--save`
    to update the `package.json` file with the dependency. Here''s the output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成一个 Node.js 模板。我们需要 Express.js 库来公开 REST 端点。现在让我们安装 express 库并使用 `--save`
    来更新 `package.json` 文件，添加依赖项。以下是输出：
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Let's now write the Node.js code to load the dataset (`heart.csv`) and render
    a bar chart as a `scalar vector graph` (`SVG`). To plot, we will be using the
    Lattice package (you can find more details about this library at [https://www.statmethods.net/advgraphs/trellis.html](https://www.statmethods.net/advgraphs/trellis.html)).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来编写 Node.js 代码来加载数据集（`heart.csv`）并将条形图渲染为 `scalar vector graph`（SVG）。为了绘图，我们将使用
    Lattice 包（你可以在 [https://www.statmethods.net/advgraphs/trellis.html](https://www.statmethods.net/advgraphs/trellis.html)
    找到更多关于这个库的详细信息）。
- en: 'So, here''s the Node.js code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，以下是 Node.js 代码：
- en: '[PRE51]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Let's go through the code to understand it. We are loading `Express.js` and
    defining a `'/plot'` endpoint. We are using `Polyglot.eval()` to run our R code.
    We are initializing the SVG and loading the Lattice package. We are then loading
    the `heart.csv` file and rendering the graph as a bar chart, and then adding the
    SVG response, generated to the HTML as a response for the `/plot` endpoint.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析代码来理解它。我们正在加载 `Express.js` 并定义一个 `'/plot'` 端点。我们使用 `Polyglot.eval()` 来运行我们的
    R 代码。我们初始化 SVG 并加载 Lattice 包。然后我们加载 `heart.csv` 文件并将图表渲染为条形图，然后将生成的 SVG 响应添加到
    HTML 响应中，作为 `/plot` 端点的响应。
- en: 'Let''s now run this code. The following shows the output after running the
    code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来运行这段代码。以下是运行代码后的输出：
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Go to http://locahost:3000/plot to invoke the endpoint, on a browser. The following
    figure shows a screenshot of the output:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 http://locahost:3000/plot 来调用端点，在浏览器中。以下是一个输出截图：
- en: '![Figure 8.5 – Output of calling /plot'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.5 – 调用 /plot 的输出]'
- en: '](img/Figure_8.5_B16878.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.5_B16878.jpg)'
- en: Figure 8.5 – Output of calling /plot
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 调用 /plot 的输出
- en: R is a very powerful language for statistical computations and machine learning.
    This opens up opportunities for us to embed R code or call R code within the same
    runtime, from various other languages. If we had to do the same logic in Java,
    it might take a lot of effort.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: R 是一种非常强大的用于统计计算和机器学习的语言。这为我们提供了在多种其他语言中嵌入 R 代码或调用 R 代码的机会。如果我们不得不在 Java 中执行相同的逻辑，可能需要付出很多努力。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went into the details of how Python, R, and Java on Truffle
    interpreters are implemented in Truffle. We also explored the polyglot interoperability
    features that these languages provide, along with coding examples. We understood
    the differences in the way each of these languages is interpreted. The chapter
    provided a hands-on walkthrough of how to run code and write polyglot applications
    in these various languages. We used very simple code so that you could easily
    understand the concepts and API to implement polyglot applications.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了 Python、R 和 Java 在 Truffle 解释器中的实现方式。我们还探讨了这些语言提供的多语言互操作性功能，并附上了编码示例。我们了解了每种语言解释方式的不同。本章提供了一个实际操作指南，说明了如何在各种语言中运行代码和编写多语言应用程序。我们使用了非常简单的代码，以便你能够轻松理解概念和
    API 以实现多语言应用程序。
- en: You should be able to use this knowledge to write polyglot applications on GraalVM.
    Though most of these languages are still in the experimental phase at the time
    of writing the book, they provide great opportunities to build high-performance
    polyglot applications.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够使用这些知识在 GraalVM 上编写多语言应用程序。尽管在撰写本书时，这些语言中的大多数仍然处于实验阶段，但它们提供了构建高性能多语言应用程序的绝佳机会。
- en: In the next chapter, you will gain good hands-on experience and understanding
    of how polyglot works, how to build Python and R applications on GraalVM, and
    how to interoperate between these programs. You will also gain a good knowledge
    of GraalVM's new runtime, Java on Truffle.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将获得丰富的实践经验和对多语言工作原理的理解，了解如何在GraalVM上构建Python和R应用程序，以及如何在这些程序之间进行交互。你还将对GraalVM的新运行时，Truffle上的Java有一个良好的了解。
- en: Questions
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is Java on Truffle?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Truffle上的Java？
- en: What are the advantages of Java on Truffle?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Truffle上的Java有什么优势？
- en: What is the use of the `Polyglot.cast()` method?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Polyglot.cast()`方法有什么用途？'
- en: What are SST and ST?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SST和ST是什么？
- en: What is a `.pyc` file?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.pyc`文件是什么？'
- en: What is the polyglot binding method used to exchange data and function definitions
    in GraalPython?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GraalPython中用于交换数据和函数定义的多语言绑定方法是什么？
- en: How can you import other language definitions in R?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在R中导入其他语言定义？
- en: How can you load a Java class in R?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在R中加载Java类？
- en: Further reading
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'GraalVM Enterprise Edition: [https://docs.oracle.com/en/graalvm/enterprise/19/index.html](https://docs.oracle.com/en/graalvm/enterprise/19/index.html)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM企业版：[https://docs.oracle.com/en/graalvm/enterprise/19/index.html](https://docs.oracle.com/en/graalvm/enterprise/19/index.html)
- en: 'GraalVM Language Reference: [https://www.graalvm.org/reference-manual/languages/](https://www.graalvm.org/reference-manual/languages/).'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM语言参考：[https://www.graalvm.org/reference-manual/languages/](https://www.graalvm.org/reference-manual/languages/).
