- en: '*Chapter 8*: GraalVM Polyglot – Java on Truffle, Python, and R'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we covered JavaScript and Node.js interpreters and
    interoperability between languages. In this chapter, we will cover other language
    implementations such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Java on Truffle (also called Espresso): Java implementation on Truffle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GraalPython: Python language interpreter implementation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FastR: R language interpreter implementation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these language implementations are still in the *experimental* phase
    so are not released for production at the time of writing the book. However, we
    will explore the features and build some code to understand the various concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Python, R, and Java/Truffle interpreters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about and exploring language interoperability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the compatibility and limitations of these various language interpreters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have hands-on experience in building polyglot
    applications with Python, R, and Java/Truffle interpreters.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires the following to follow along with the various coding/hands-on
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: The latest version of GraalVM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various language Graal runtimes. We will cover in the chapter how to install
    and run these runtimes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Access to GitHub: There are some sample code snippets, which are available
    in a Git repository. The code can be downloaded from the following link: [https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter08](https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter08).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Code in Action video for this chapter can be found at [https://bit.ly/3fj2iIr](https://bit.ly/3fj2iIr).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Espresso (Java on Truffle)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GraalVM 21.0 is a major release that introduces a new guest language runtime
    called Java on Truffle. Before this, we had the option to run Java using HotSpot
    (which we covered in detail in [*Chapter 2*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028),
    *JIT, Hotspot, and GraalJIT*), on Graal JIT (which we covered in [*Chapter 4*](B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077),
    *Graal Just-In-Time Compiler*), or as a native image with Graal AOT (which we
    covered in [*Chapter 5*](B16878_05_Final_SK_ePub.xhtml#_idTextAnchor097), *Graal
    Ahead-of-Time Compiler and Native Image*). With GraalVM 21.0, Java on Truffle
    is the new runtime, which can run Java. It is codenamed Espresso. This is still
    in the *experimental* phase and is not production-ready at the time of writing
    this book. In this section, we will understand how to run Java applications with
    this new runtime, and how this can help polyglot programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Espresso is a cut-down version of JVM but implements all the core components
    of JVM, such as the bytecode interpreter, bytecode verifier, Java Native Interface,
    the Java Debug Wire Protocol, and so on. Espresso reuses all the classes and native
    libraries from GraalVM. Espresso implements the `libjvm. so` APIs. The following
    figure shows the Espresso stack architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Espresso stack architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.1_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Espresso stack architecture
  prefs: []
  type: TYPE_NORMAL
- en: The figure shows how Espresso is implemented on top of Truffle.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need Java on Java?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Running Java on Truffle (Espresso) is counter-intuitive, and you might wonder
    about the advantage of running Java on Truffle, which adds an additional layer
    on top of Graal. The following are some of the advantages of running Espresso:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hotswap methods, lambdas, and access modifiers at runtime/debug time**: Espresso
    provides a way to hot-swap methods, lambdas, and access modifiers at runtime during
    debugging. This is a great feature for developers as it allows them to change
    the code completely while debugging, and without stopping the runtime and recompiling,
    the changes take effect at runtime. This speeds up the developer''s workflow and
    increases productivity. It also helps the developers experiment and try things
    out before committing the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A sandbox to run untrusted Java code**: Espresso runs like a sandbox on top
    of Truffle, which can run with access restrictions. This is a great way to run
    untrusted Java code, by providing specific access. Please refer to the *JavaScript
    embedded code in Java* section in [*Chapter 7*](B16878_07_Final_SK_ePub.xhtml#_idTextAnchor138),
    *GraalVM Polyglot - JavaScript and Node.js,* to understand more about how to configure
    the access restrictions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interoperability between JVM and non-JVM using the same memory space**: Before
    Espresso, passing data between Java applications and non-JVM dynamic guest languages
    was not done in the same memory space. This might be because of the performance
    impact. With Espresso, we can pass data between Java and non-JVM guest languages
    in the same memory space. This increases the performance of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leveraging Truffle tools and instrumentation**: Running Java on Truffle will
    help in using all the analysis, diagnosis, and debugging tools developed with
    Truffle instrumentation. (Refer to the *Understanding Truffle instrumentation*
    section of [*Chapter 6*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120), *Truffle
    – An Overview*.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`native-image`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Running mixed versions of Java**: Espresso provides the required isolation
    layer to run Java code that is written in Java 8 to run on Java 11\. The Java
    8 code can be run on Espresso, which might be running on GraalVM Java 11\. This
    helps in running older code, without changing it, and could be a step in carefully
    modernizing the code, instead of the big-bang modernization approach that we adopt
    when we move from the older version of Java to the newer version of Java.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now install and run simple Java code on Espresso.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and running Espresso
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Espresso is an optional runtime; it has to be downloaded and installed separately
    using the Graal Updater tool. Here is the command to install Espresso:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To test whether Espresso is installed, let''s execute a simple `HelloEspresso.java`
    application. It is a very simple `Hello World` program, which prints a message.
    Check out the following code for `HelloEspresso.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile this application using `javac` and run it with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To run Java on Truffle, we just have to pass `-truffle` as a command-line argument
    to `java`. After running this, we should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This validates the installation. We can also use the `-jar` argument along with
    `-truffle` to run a JAR file. Now let's explore the polyglot capabilities of Espresso.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring polyglot interoperability with Espresso
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Espresso is built on Truffle and implements the Truffle polyglot and interoperability
    APIs. In this section, we will explore these features.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start using the polyglot features, we have to install Espresso polyglot
    features. To install Espresso polyglot features, we may have to download the Espresso
    JAR file. You can find the latest version at [https://www.oracle.com/downloads/graalvm-downloads.html](https://www.oracle.com/downloads/graalvm-downloads.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the JAR file that we will have to download,
    at the time of writing the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Java on Truffe JAR file download'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.2_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Java on Truffe JAR file download
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we download this file, we can install it by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the installation is successful, we have to rebuild the `libpolyglot` native
    image, to include Espresso libraries. This library is required to run polyglot
    support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will rebuild the `libpolyglot` native image. We are now ready to use the
    polyglot capabilities of Espresso. Let's explore these features in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Espresso interoperability with other Truffle languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you''re now aware, Espresso implements the Truffle implementation framework
    and the `com.oracle.truffle.espresso.polyglot.Polyglot` class implements the polyglot
    in Espresso. Like any other guest language, we use `-polyglot` in the command-line
    argument to let Truffle know how to create the polyglot context. Espresso injects
    a `Polyglot` object into the code, which can be used to interoperate with other
    languages. Let''s explore polyglot programming with Espresso by running the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand the preceding code. The `Polyglot` object provides context
    for running dynamic languages. The `Polyglot.eval()` method runs foreign language
    code. The first parameter suggests that it is JavaScript code, and the second
    parameter is the actual JavaScript code that we want to execute. Let''s compile
    this code with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this command, we are explicitly passing the `polyglot.jar` file in the `-cp`
    argument (`CLASSPATH`). `polyglot.jar` has all the polyglot implementation of
    Espresso, including the `com.oracle.truffle.espresso.polyglot.Polyglot` import.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now run the Java application on Espresso. We should pass the `-truffle`
    argument to run it on Espresso, if we don''t do that, it runs on Host JVM. We
    can see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can call other language code. Java is a typed language, unlike
    other dynamically typed languages on Truffle. When we exchange data between Espresso
    (Java on Truffle) and other dynamically typed languages such as JavaScript, Python,
    and so on, we need a way to cast the data types. The `polyglot` object provides
    a way to cast the data with the `Polyglot.cast()` method. Let''s use a simple
    application to understand how to cast the data, with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the `Polyglot` and `Interop` classes. The `Polyglot` class helps us
    to run guest languages and the `Interop` class implements the Truffle interoperability
    API, which abstracts the data types between guest languages. Truffle defines an
    interoperability protocol that provides a clear specification on how the data
    and message (method calls) exchange happens between Truffle languages, tools,
    and embedders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we are evaluating various JavaScript code snippets
    that return a string, integer, double, an `array` of integers and a `boolean`
    value. These values are assigned to a generic `Object`, and then later cast to
    the respective Java type `String`, `Integer`, `Double`, `Integer[]`, and `Boolean`
    objects using `Polyglot.cast()`, as observed in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll print the values. To handle arrays, let''s use the `Interop` class
    to get information about the array object, such as the size of the array with
    `Interop.getArraySize()`, and iterate through the array with `Interop.readArrayElement()`.
    `Interop` also provides a way to check the type of the object and extract the
    value in a specific data type. In our example, we have evaluated a JavaScript
    array that has a sequence of integer, double, and string objects. We will use
    `Interop.fitsInInt()`, `Interop.fitsInDouble()`, and `Interop.isString()` methods
    to check the types, and accordingly extract the values using `Interop.asInt()`,
    `Interop.asDouble()`, and `Interop.asString()` methods. The following is the code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'These values are then printed. Let''s compile and run this application. The
    following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the output, we can see how a dynamically cast language (JavaScript) is captured
    in a generic `Object` and later cast to specific types. We can also use `Polyglot.isForeignObject(<object>)`
    to check whether the passed object is a local object or a foreign object.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how we can call other Truffle languages from Espresso, the same way other
    languages are invoked with `Context polyglot = Context.newBuilder().allowAllAccess(true).build()`
    and using bindings (refer to the *Bindings* section of [*Chapter 7*](B16878_07_Final_SK_ePub.xhtml#_idTextAnchor138),
    *GraalVM Polyglot - JavaScript and Node.js*) to exchange data and invoke methods.
  prefs: []
  type: TYPE_NORMAL
- en: Java on Truffle Espresso is in very early releases and is at an experimental
    stage at the time of writing this book. There are a lot of limitations at present,
    such as a lack of support for the JVM Tool Interface and Java Management Extensions.
    There are even a lot of performance issues at this point. Please refer to [https://www.graalvm.org/reference-manual/java-on-truffle/](https://www.graalvm.org/reference-manual/java-on-truffle/)
    for the latest updates.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at two of the most important languages for machine learning –
    Python and R.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding GraalPython – the Python Truffle interpreter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GraalVM provides a Python runtime. The Python runtime is 3.8 version-compliant
    and is still in the *experimental* phase at the time of writing this book. In
    this section, we will install and understand how Python runs on Truffle and Graal.
    We will also build some sample code, to understand the interoperability features
    of Graal Python.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Graal Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Graal Python is an optional runtime and is not installed by default along with
    GraalVM. To download it, you have to use the Graal Updater tool. The following
    command downloads and installs Graal Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To validate the installation, let''s run simple Python code. The following
    is the source code of `HelloGraalPython.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s a very simple Hello World application where we are printing the message.
    Let''s run this application using `graalpython`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the preceding command, we should see the output shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output shows that the application is running, and `graalpython`
    is working.
  prefs: []
  type: TYPE_NORMAL
- en: '`graalpython` also supports a virtual environment. The following command will
    create a virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will create a virtual environment directory, which will be an
    isolated environment. GraalPython also comes with `ginstall`, a tool to install
    supported libraries. The following command will install `numpy` for `graalpython`.
    `pip` can also be used to install libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let's now understand how the GraalPython compilation and interpreter pipeline
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the graalpython compilation and interpreter pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Graalpython is a slightly different compilation/interpreter pipeline. To improve
    the performance of parsing, Graalpython uses an intermediate representation called
    `.pyc` file, after the parsing. This is done to speed up the parsing. The next
    time we run the Python program, `Graalpython` looks for the `.pyc` file and validates
    whether the file exists, and if it matches the Python source code, then it will
    deserialize that to build the SST and ST. Otherwise, it will do a full parsing
    using ANTLR. The following figure shows the full flow. The diagram does not capture
    all the details. Refer to the *Exploring the Truffle Interpreter/Compiler pipeline*
    section in [*Chapter 6*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120), *Truffle
    – An Overview,* for a more detailed explanation on how Truffle interpreters and
    Graal JIT execute the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Graalpython compilation/interpreter pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.3_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – Graalpython compilation/interpreter pipeline
  prefs: []
  type: TYPE_NORMAL
- en: Once the SST and ST are created, they are then converted to an AST intermediate
    representation and optimized. The final specialized AST is submitted to GraalJIT
    for further execution after partial evaluation, and the usual flow continues,
    as explained in *Exploring the Truffle interpreter/compiler pipeline* section
    of [*Chapter 6*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120), *Truffle – An
    Overview*.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have learned how to run Python programs with GraalPython and how
    GraalPython optimizes the parsing and optimizes the code using Truffle and GraalJIT.
    Let's now explore the polyglot interoperability features of GraalPython.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring interoperability between Java and Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will explore the interoperability between Java and Python
    with sample Java code. The following code calculates the sum of Fibonacci numbers.
    This class has a `findFibonacci()` method, which takes in the number of Fibonacci
    numbers we need and returns an array of those Fibonacci numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now call the `findFibonacci()` method from Python code. The following
    is the Python code for calling the method and iterating through the array that
    is returned by the Java class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are using `java.type()` to load the Java class, and
    we are directly using the returned value as a Python object to call the `findFibonacci()`
    method, by passing a parameter. We are then able to parse through the result that
    is returned by the method. Let''s compile the Java code and run the Python code.
    The following shows the terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we are able to call the Java method and get an array of integers
    and iterate through that, without any extra code for conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's create a simple Python function that uses NumPy to do some quick analysis
    on a dataset. NumPy is a high-performing Python library for array/matrix manipulations
    and is widely used in machine learning. To appreciate the value of Graal polyglot,
    imagine a use case where we have a dataset that has information about various
    heart attack cases, organized by age, sex, cholesterol levels, chest pain level,
    and so on, and we want to understand what the average age of the people who had
    a heart attack after level 3 (high) chest pain is. That is what we will build
    in this section, to understand the polyglot interoperability between Java and
    Python, and how we can use the NumPy Python library.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the dataset that is provided on Kaggle on heart attack analysis
    ([https://www.kaggle.com/rashikrahmanpritom/heart-attack-analysis-prediction-dataset](https://www.kaggle.com/rashikrahmanpritom/heart-attack-analysis-prediction-dataset)).
    This dataset has information about the various heart attack cases, with age, cholesterol
    levels, sex, chest pain levels, and so on. Here is the Python code to perform
    the analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are loading the CSV file into a matrix. Here, we are
    particularly interested in the third column (indexed as `2`). We are loading all
    the rows where the third column value is greater than 2, and storing it in another
    variable. We are then averaging that matrix and returning it. This would have
    taken a lot of code if we had to do the same in Java. Now, let's call this code
    from Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following Java code, we will be importing the function definition using
    the key through the `Binding` object. Here''s the complete Java code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous Java code, we are creating a `Context` object and evaluating
    the Python code in `numpy-example.py`. We are then accessing the function definition
    through binding and invoking the Python function and are able to get the value.
    We are printing the value that is returned. The following is the output of running
    this Java code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, we can see that the first call took time, however,
    the subsequent calls took almost no time at all to execute. This not only demonstrates
    how we can interoperate with Python code from Java code but also how Truffle and
    Graal optimize the execution.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored Java and Python interoperability. In the next section,
    we will explore interoperability between dynamic languages with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring interoperability between Python and other dynamic languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To explore interoperability between Python and other dynamic languages, let's
    use the same `numpy-example.py` that we used in the previous section. Let's call
    this method from JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the JavaScipt that calls the Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, we can see how we are importing the Python `heartAnalysis()`
    function in JavaScript using the `Polyglot.import()` function. This returns the
    average value that we are printing. Let''s run this code, and we can see the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now create JavaScript code, which will have functions to calculate squares.
    To demonstrate how JavaScript code can be called from Python, here''s the JavaScript
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It's a very simple JavaScript function that returns the square of the passed
    value. We are also exporting the `square()` function and a variable message, which
    carries the value of the `helloMathMessage` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s invoke this method from Python code. The following is the Python
    code that will import and invoke the preceding JavaScript methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we are using the Python `polyglot` object to evaluate the JavaScript
    file. We then imported all the exported functions/variables by calling the `polyglot.import_value()`
    function, by using the same key used by JavaScript to export functions or variables.
    We are then able to invoke those functions and access the `message` variable and
    print the values. The following output is what you get after you run the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We can see how Python code is importing and invoking JavaScript code. This demonstrates
    two-way interoperability. The code is very similar to other languages, such as
    R and Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored and gained a good understanding of how the Python
    interpreter works with Truffle to run optimally on GraalVM. Let's now explore
    and understand the R language interpreter on GraalVM.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding FastR – the R Truffle interpreter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GraalVM provides an R Truffle interpreter for a GNU-compatible R runtime. This
    runtime supports R programs and **REPL** (**read-eval-print-loop**) mode, where
    we can rapidly test the code while we write the code interactively. FastR is the
    project that developed this R runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and running R
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like Graal Python, the R runtime does not come with GraalVM by default.
    We have to download and install it using Graal Updater. Use the following command
    to download and install R and Rscript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: To run R, we need the OpenMP runtime library. This can be installed using `apt-get
    install libcomp1` on Ubuntu and `yum install libcomp` on Oracle Linux. The library
    is installed in macOS by default. Apart from this, you will need C/C++/Fortran,
    if the R code has C/C++/Fortran code. R is also in the experimental phase at the
    time of writing this book, so not everything is supported yet. Please refer to
    the GraalVM documentation ([https://docs.oracle.com/en/graalvm/enterprise/20/docs/reference-manual/r/](https://docs.oracle.com/en/graalvm/enterprise/20/docs/reference-manual/r/))
    for the latest information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now test R. To explore the R interpreter, let''s run it in interactive
    mode. The following terminal output shows the interactive mode to test R installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that we are using the FastR GraalVM version from the version numbers
    listed in the preceding output. Let''s now test whether our FastR interpreter
    is working by running some Python commands as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that it is interactively providing the results. Let''s now just
    plot a simple example. The best way is to call `example()`, which will show the
    plot, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in a pop-up window with the plotted graph. The following figure
    shows a screenshot of the graph that popped up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_8.4_B16878.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – R Plot output screenshot
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing this book, some warnings appeared while running the
    preceding `plot` commands. These warnings list some of the limitations of FastR.
    However, this might change in upcoming versions. The following are the warnings
    that popped up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now that we can see R is working fine, let's now explore the interoperability
    features of FastR.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the interoperability of R
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, to explore polyglot and interoperability with R, we will run
    some inline JavaScript and also load sample JavaScript code and import the exported
    functions and variables. We will use R interactive mode to do this so that it''s
    easy to understand. To run R in polyglot mode, we have to pass the `--polyglot`
    argument. The following is the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start the R runtime in interactive mode with the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s start with simple inline JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding interactive session, we are calling the `eval.polyglot()`
    function, with the language ID and the expression. In this case, we are specifying
    it as JavaScript with a language ID of `js` and then passing an array of elements.
    Then we are printing the array and the third element in the array. The `eval.polyglot()`
    function provides the polyglot context and runs other language code. Now let''s
    load a simple JavaScript code file. The following is the code for `math.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is very straightforward. We have defined the `add()`, `subtract()`,
    and `multiply()` functions and a simple variable, `message`, which has a string
    value, `Hello Math.js`. We are then using `Polyglot.export()` to export it for
    other languages to have access to these functions and the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s load this JavaScript file and execute the exported code; we will
    be running the instructions in interactive mode. You''ll find the interactive
    session here, with an explanation of what we are doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This instruction loads the JavaScript file. Make sure that the path is updated
    with the exact path where you have the JavaScript file. Now let''s import the
    exported functions and variable into R:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding instructions, we are using the `import()` function to import
    the exported functions and variables. It is very important to use the same string
    that we used to export in the JavaScript file. These imports are assigned to a
    variable. Now let''s call these functions and print the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we can call the JavaScript functions and print the variable.
    This demonstrates how we can use JavaScript but we can similarly use all other
    Truffle languages. Let''s now explore how to access a Java class from R. Here
    is the code for the `HelloRPolyglot` class, which we will be calling from R:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Let's understand the preceding code. We have a static method, `helloStatic()`,
    that calls inline JavaScript, which prints a message, and we have another method,
    `hello()`, that takes an argument and prints a `hello` message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compile and run the Java class to test whether it works fine. The following
    shows the console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the class is working fine, let''s start the R interactive mode. This
    time, we have to pass the `--jvm` argument to let the R runtime know that we will
    be using Java, and also pass the `--vm` argument, to set `CLASSPATH` to the current
    directory where we have the Java class file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the R is loaded, let''s run the instructions to call the `hello()`
    method in the Java class. We use the `java.type()` function to load the class.
    The following is the interactive session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding interactive session, we can see that the class is loaded successfully,
    and when we print the class, we see that it lists the various methods in it. Now
    let''s create an instance of this class. We use the `new()` function to do that.
    The following is the output of the interactive session with the `new()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that the object is successfully created,
    as it prints all the methods in the class. Now let''s call these methods. We will
    use the class to call the static method and object to call `hello()`, by passing
    a parameter. The following is the output of the interactive session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding session, we can see the output of calling both the methods.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a real-life example of how we can use the power of plotting a graph
    using R and use the plotted graph in Node.js. Earlier in the chapter, we used
    a dataset that we got from Kaggle that has heart attack data. Let's use that dataset
    to plot a graph comparing the ages of people and their cholesterol levels on a
    web page that is generated by Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s initialize a Node.js project with npm init. The following is the output
    console where we are providing the name of the project and other project parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This should generate a Node.js boilerplate. We will need the Express.js library
    to expose a REST endpoint. Let''s now install the express library and use `--save`
    to update the `package.json` file with the dependency. Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Let's now write the Node.js code to load the dataset (`heart.csv`) and render
    a bar chart as a `scalar vector graph` (`SVG`). To plot, we will be using the
    Lattice package (you can find more details about this library at [https://www.statmethods.net/advgraphs/trellis.html](https://www.statmethods.net/advgraphs/trellis.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here''s the Node.js code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Let's go through the code to understand it. We are loading `Express.js` and
    defining a `'/plot'` endpoint. We are using `Polyglot.eval()` to run our R code.
    We are initializing the SVG and loading the Lattice package. We are then loading
    the `heart.csv` file and rendering the graph as a bar chart, and then adding the
    SVG response, generated to the HTML as a response for the `/plot` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now run this code. The following shows the output after running the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to http://locahost:3000/plot to invoke the endpoint, on a browser. The following
    figure shows a screenshot of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Output of calling /plot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.5_B16878.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – Output of calling /plot
  prefs: []
  type: TYPE_NORMAL
- en: R is a very powerful language for statistical computations and machine learning.
    This opens up opportunities for us to embed R code or call R code within the same
    runtime, from various other languages. If we had to do the same logic in Java,
    it might take a lot of effort.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went into the details of how Python, R, and Java on Truffle
    interpreters are implemented in Truffle. We also explored the polyglot interoperability
    features that these languages provide, along with coding examples. We understood
    the differences in the way each of these languages is interpreted. The chapter
    provided a hands-on walkthrough of how to run code and write polyglot applications
    in these various languages. We used very simple code so that you could easily
    understand the concepts and API to implement polyglot applications.
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to use this knowledge to write polyglot applications on GraalVM.
    Though most of these languages are still in the experimental phase at the time
    of writing the book, they provide great opportunities to build high-performance
    polyglot applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will gain good hands-on experience and understanding
    of how polyglot works, how to build Python and R applications on GraalVM, and
    how to interoperate between these programs. You will also gain a good knowledge
    of GraalVM's new runtime, Java on Truffle.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Java on Truffle?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of Java on Truffle?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the use of the `Polyglot.cast()` method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are SST and ST?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a `.pyc` file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the polyglot binding method used to exchange data and function definitions
    in GraalPython?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you import other language definitions in R?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you load a Java class in R?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GraalVM Enterprise Edition: [https://docs.oracle.com/en/graalvm/enterprise/19/index.html](https://docs.oracle.com/en/graalvm/enterprise/19/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GraalVM Language Reference: [https://www.graalvm.org/reference-manual/languages/](https://www.graalvm.org/reference-manual/languages/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
