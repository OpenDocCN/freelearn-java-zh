- en: Online Shopping - Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next four chapters, we will write a project using the most common libraries
    and framework from the Scala ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to implement the cart management of an online shopping website,
    from the front-end to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the database, we are going to implement a persistence layer. The
    responsibility of this layer is to persist in a relational database the content
    of the cart, for that purpose we are going to use a relational persistence framework
    named Slick.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we are going to spend times to define an API to access the database, this
    API will use RESTfull web services architecture and JSON as message protocol.
    The API will be fully documented and testable from a generated website.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we are going to implement the user interface layer. With this interface,
    the user can add products into its cart, remove products and update the quantity
    of a particular product in the cart. Scala.js is used to implement this interface.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explain how to persist data in a relational database.
    The data will be the contents of a cart for a shopping website.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to build a robust website accepting lots of simultaneous connection,
    special care is needed to have all of the layers of the solution to scale with
    the demand.
  prefs: []
  type: TYPE_NORMAL
- en: At the level of the persistence layer, a key point to scale would be to not
    overuse the system resources, more precisely the threads, each time data is written
    into the database. Indeed, if each request to the database is blocking a thread,
    the limit of concurrent connections will be reached quickly.
  prefs: []
  type: TYPE_NORMAL
- en: For that purpose, we will use an asynchronous framework called Slick to perform
    database actions.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use the Slick framework, an introduction to Scala `Future` will
    be necessary. `Future` is one of the basic tools to handle asynchronous code in
    Scala.
  prefs: []
  type: TYPE_NORMAL
- en: As we rarely host a website at home, we are going to deploy this layer, and
    later the whole website, to the internet by using a cloud service provider named
    Heroku. This means that the shopping cart will be accessible from all over the
    world.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heroku configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To facilitate the project creation, we are providing a template which generates
    the skeleton of the project. For that purpose, [Gitter8](http://www.foundweekends.org/giter8/) will
    help us to generate the complete project based on a template hosted in Git.
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to directly use the command line of Gitter8\. We are instead
    going to use the integration with sbt to generate the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template can be found on Github at [GitHub - scala-fundamentals/scala-play.g8:
    Template used for the online shopping](https://github.com/scala-fundamentals/scala-play.g8.git). This
    template has been forked from [https://github.com/vmunier/play-scalajs.g8.](https://github.com/vmunier/play-scalajs.g8.) We
    essentially changed the framework test from Specs2 to ScalaTest and added all
    the dependencies needed for our shopping project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the project, enter the following in your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new folder with all the files and folders needed for our
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now import this project in IntelliJ, click on Import Project select
    sbt on the first dialogue box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/634469b6-44c4-4e79-87bd-0a7946c7b245.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Next, on the next dialogue box, please check the option Use sbt shell
    for build and import (requires sbt 0.13.5+) as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0776ff8-31c5-42dd-b214-149b8232ba1a.png)'
  prefs: []
  type: TYPE_IMG
- en: That's it, we are ready for the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the context of the online shopping project, we are going to create a simple
    data model with only two tables—the cart and product tables. The product represents
    what we would like to sell. It has a name, a code, a description, and a price.
  prefs: []
  type: TYPE_NORMAL
- en: The cart what a customer is about to buy. It has an ID, which is autoincremented
    for any new cart created, and a user, representing the user identification. For
    the purpose of this book, we are going to use the username sent during the login
    process. The cart also has a quantity and a code, representing a link to the product
    table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is a representation of our model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ffbc423a-10d7-4796-a141-9f8d8f924663.png)'
  prefs: []
  type: TYPE_IMG
- en: For the purposes of this book, we will choose a database that requires no administration,
    is fast, with a small footprint, and can be deployed quickly and smoothly. The
    H2 database fulfills all of these requirements.
  prefs: []
  type: TYPE_NORMAL
- en: To access our data, we would like to take advantage of the Scala language to
    statically check our code at compile time. The Slick library is perfect for this
    task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Slick can generate SQL for multiple databases, and it supports the following
    RDBMS (with the respective JDBC driver versions):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Database | JDBC Driver |'
  prefs: []
  type: TYPE_TB
- en: '| SQLServer 2008, 2012, 2014 | jTDS - SQL Server and Sybase JDBC driver ([https://sourceforge.net/projects/jtds/](https://sourceforge.net/projects/jtds/))
    and Microsoft JDBC Driver 6.0 for SQL Server ([https://www.microsoft.com/en-gb/download/details.aspx?id=11774](https://www.microsoft.com/en-gb/download/details.aspx?id=11774))
    |'
  prefs: []
  type: TYPE_TB
- en: '| Oracle 11g | [http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html](http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| DB2 10.5 | [http://www-01.ibm.com/support/docview.wss?uid=swg21363866](http://www-01.ibm.com/support/docview.wss?uid=swg21363866)
    |'
  prefs: []
  type: TYPE_TB
- en: '| MySQL | `mysql-connector-java:5.1.23` ( [https://dev.mysql.com/downloads/connector/j/](https://dev.mysql.com/downloads/connector/j/))
    |'
  prefs: []
  type: TYPE_TB
- en: '| PostgreSQL | PostgreSQL JDBC Driver: `9.1-901.jdbc4` ([https://jdbc.postgresql.org](https://jdbc.postgresql.org))
    |'
  prefs: []
  type: TYPE_TB
- en: '| SQLite | `sqlite-jdbc:3.8.7` ([https://bitbucket.org/xerial/sqlite-jdbc/downloads/](https://bitbucket.org/xerial/sqlite-jdbc/downloads/))
    |'
  prefs: []
  type: TYPE_TB
- en: '| Derby/JavaDB | `derby:10.9.1.0` ([https://db.apache.org/derby/derby_downloads.html](https://db.apache.org/derby/derby_downloads.html))
    |'
  prefs: []
  type: TYPE_TB
- en: '| HSQLDB/HyperSQL | `hsqldb:2.2.8` ([https://sourceforge.net/projects/hsqldb/](https://sourceforge.net/projects/hsqldb/))
    |'
  prefs: []
  type: TYPE_TB
- en: '| H2 | `com.h2database.h2:1.4.187` ([http://h2database.com/html/download.html](http://h2database.com/html/download.html))
    |'
  prefs: []
  type: TYPE_TB
- en: Setting up Slick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What do we need to set up Slick? In the `build.sbt` file from the project generated
    on the *Developing a full project* chapter, the requested libraries are set in
    the server section. Slick is well integrated with Play, and the full list of dependencies
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We added Slick dependencies, as well as the Evolution module. Evolution is a
    module that simplifies schema management; we will come back to that later.
  prefs: []
  type: TYPE_NORMAL
- en: We had to add the JDBC driver as well; this is due to the fact that Slick does
    not come bundled with all of the drivers.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The database setup is done in the `conf/application.conf` file. When a database
    is needed, it must be configured in this file. Slick provides a default configuration,
    named `default`. For a new database, replace this name with the name of your database.
  prefs: []
  type: TYPE_NORMAL
- en: We will enable `evolution` and tell it to automatically run the scripts for
    database creation and deletion.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, the entry looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The complete configuration option can be found in the Play Framework documentation
    ([https://www.playframework.com/documentation/2.6.x/PlaySlick](https://www.playframework.com/documentation/2.6.x/PlaySlick)).
  prefs: []
  type: TYPE_NORMAL
- en: Database test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get started, we should check that the database created by `evolution`
    is correct, and we should define the expected behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Product test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should also verify that three product rows are inserted when the application
    is started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a test class, named `ProductDaoSpec`, which extends `PlaySpec`. Now, `PlaySpec`
    is the integration of ScalaTest in Play. The `ProductDaoSpec` class also needs
    to extend the `GuiceOneAppPerSuite` trait. This trait adds a new instance of the
    `Application` object to the ScalaTest suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Play provides a helper method to create an instance in the cache. As you can
    see, `app2dao` can create an instance of `ProductDao`, which was the type parameter
    passed to `instanceCache`.
  prefs: []
  type: TYPE_NORMAL
- en: The matcher on the `Set` is not strict, and it does not take into account the
    order of the rows received. If you would like to be stricter, ScalaTest provides
    the `theSameElementsInOrderAs` matcher, which checks the order of the elements
    in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: As the `dao.all()` function returns `Future`, ScalaTest provides the `.futureValue` helper
    to wait on `Future` to finish before testing the value.
  prefs: []
  type: TYPE_NORMAL
- en: Cart test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What about the cart? We would like to make sure that the cart is empty when
    the application is run so that we can add items to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like we did for the product, we will create a class named `CartDaoSpec`.
    The test looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `be empty on database creation` test makes sure that no carts exist upon
    creation of the application, and `accept to add new cart` makes sure that we can
    insert products into a specific cart; when the cart is read back, only the product
    of that cart is returned. This is tested by the fact that we are adding a new
    product to the cart of `user2`, instead of `user1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For consistency, we would like to have a constraint on the database where we
    only have a unique tuple `user` and `productCode`. In case we do not have a unique
    pair, we should expect an error to be thrown from the database saying that the
    cart already exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In `expected.map(dao.insert(_)) ++ noise.map(dao.insert(_))` , we are creating
    a `Set` of `Future` by adding the Futures from the expected cart insertion and
    the noise cart insertion.
  prefs: []
  type: TYPE_NORMAL
- en: To test if an error is thrown, ScalaTest provides the `recoverToSucceededIf[T]` function
    that tests if the `Future` passed as a parameter throws the type `[T]` error.
  prefs: []
  type: TYPE_NORMAL
- en: We would also like to test whether we can remove an item from the cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will perform this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First, we add an initial cart with two products, and then, we remove one product from
    the cart. Notice that we introduced a new class, named `ProductInCart`, which
    represents a product in a cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be complete, our `CartDao` should accept updating the product quantity in
    a cart; this is represented by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we first set the cart for `userUpd` with a quantity of `1` unit
    of `ALD1`, and then update it with a quantity of `5` units of `ALD1`.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, as there is no implementation, the test does not even compile; it
    is time to create the database and implement the **Data Access Objects** (**DAO**).
    Before going further, notice the piece of code with `.futureValue`. This is the
    perfect time to explain what Futures are all about.
  prefs: []
  type: TYPE_NORMAL
- en: Future
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see in the test code, `wsClient.url(testURL).get()` returns `Future`;
    more precisely, it returns `Future` of `Response` (`Future[Response]`).
  prefs: []
  type: TYPE_NORMAL
- en: '`Future` represents a piece of code executed asynchronously. The code starts
    its execution upon the creation of `Future`, without knowing when it will finish
    its execution.'
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good; but how can we get the result?
  prefs: []
  type: TYPE_NORMAL
- en: Before we answer this question, there are some important points to understand.
    What is the purpose of writing asynchronous code?
  prefs: []
  type: TYPE_NORMAL
- en: We write it to improve performance. Indeed, if the code is run in parallel,
    we can take advantage of the multiple cores that are available on modern CPUs.
    This is all fine, but in my program, I cannot parallelize every piece of code.
    Some pieces are dependent on values coming from others.
  prefs: []
  type: TYPE_NORMAL
- en: Wouldn't it be nice if I could compose my code in such a way that as soon as
    a value is finished being evaluated, the program goes ahead and uses that variable?
    That is the exact purpose of `Future`. You can compose pieces of asynchronous
    code together; the result of the composition is another `Future`, which can be
    composed with another `Future`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a concrete value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OK, we can compose Futures to have new Futures but, at some point, we will need
    to have a concrete value instead of `Future`.
  prefs: []
  type: TYPE_NORMAL
- en: When we asked to get the response of a REST call, we receive `Future` from the
    function. The particularity of `Future` is that we do not know when it is going
    to finish so in our test we need to wait until we get the concrete value of `Future`.
  prefs: []
  type: TYPE_NORMAL
- en: To get a concrete value, you can either wait for `Future` to complete or provide
    a callback. Let us go into the details of both cases.
  prefs: []
  type: TYPE_NORMAL
- en: Waiting on a Future
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Await.result` method is waiting for the result to be available. We have
    the possibility to give a timeout to the method so that it does not block forever.
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter waits for `Awaitable` (`Future` extends `Awaitable`), and
    the second is `Duration`. `Duration` is the time to wait before throwing `TimeoutException`.
  prefs: []
  type: TYPE_NORMAL
- en: This is a pretty convenient method to get the value in our test.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you add `import scala.concurrent.duration._` in the import section, you
    can use a **Domain Specific Language** (**DSL**) to express the duration in plain
    English, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1 second`'
  prefs: []
  type: TYPE_NORMAL
- en: '`2 minutes`'
  prefs: []
  type: TYPE_NORMAL
- en: Callback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way to get the result is to use a callback function. In this case,
    we stay asynchronous to get the value. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First, `Future` is created and assigned to `f`; then, we handle the success
    case, and then, the failure case.
  prefs: []
  type: TYPE_NORMAL
- en: Composing Futures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have learned how to get a concrete value out of `Future`; you will now learn
    how to compose multiple Futures.
  prefs: []
  type: TYPE_NORMAL
- en: Using for-comprehension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Future` has a `map` and a `flatMap` method. Therefore, as we saw in [Chapter
    3](f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml), *Handling Errors*, for `Either`,
    we can use `Future` in a `for`-comprehension. For instance, we can define three
    Futures, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The Futures are simply successfully returning an integer. If we would like
    to sum up all of the integers we could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `res` variable will be `Future[Int]`; hence, we can call `Await` to get
    the final value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The response would be `6`, in our case.
  prefs: []
  type: TYPE_NORMAL
- en: 'You just learned that inside the `for`-comprehension, the value from `Future`
    can be used and can be composed with other values. But there is more; you can
    also add an `if` condition inside, acting as a filter. Suppose that we would like
    to check that the three numbers from the previous example, when added together,
    are greater than five. If this is the case, then it should return a tuple with
    the three numbers; otherwise, it should return a failure. We can first define
    a function that takes an undefined number of parameters and returns their `sum`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can define multiple parameters by adding `*` after the type in the parameter
    definition; this is called a **variadic **or `varargs` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for`-comprehension, with our filter, will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can employ what we learned in the previous section, and use a callback to
    get the value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will be printed in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you set `minExpected` to `7`, you should obtain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, `Future` is a failure; its representation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'One last thing—I am sure that you noticed the following in the first piece
    of code that we imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: What is this strange import? It is the execution context, which will be covered
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Execution context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we create a `Future`, the code is executed asynchronously on the JVM,
    but what is used to execute that code? In fact, the only way to execute code in
    parallel is to use threads. A naive approach would be to suggest: I should just
    create a new thread each time I would like to execute a new piece of code. However,
    that is a really bad idea. First, the number of threads is limited by the operating
    system; you cannot spawn as many threads as you want. Secondly, you could face
    thread starvation ([https://docs.oracle.com/javase/tutorial/essential/concurrency/starvelive.html](https://docs.oracle.com/javase/tutorial/essential/concurrency/starvelive.html));
    this happens when your CPU spends all of its time switching contexts between threads,
    instead of executing real code.'
  prefs: []
  type: TYPE_NORMAL
- en: OK, but how can you manage the thread creation? That is the purpose of the execution
    context. You can set the policy that you wish to manage your threads. Scala provides
    a default policy that creates and manages a pool of threads; the number of threads
    is automatically defined by the number of processors available to the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: So, by importing `scala.concurrent.ExecutionContext.Implicits.global`, you are
    just saying that you would like to use the default policy to manage your thread,
    which should be fine for the majority of your code. You might need to define your
    own `ExecutionContext`, if, for example, you are creating `Future` that gets data
    from a legacy software blocking the call.
  prefs: []
  type: TYPE_NORMAL
- en: Rounding up Futures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic operations on `Future` are `map` and `flatMap`. In fact, when we use
    the `for`-comprehension, under the hood, the compiler transforms our loop with
    `map` and `flatMap`.
  prefs: []
  type: TYPE_NORMAL
- en: Futures are very important in Scala; we have only learned the basics of Futures;
    just enough to understand the code in this book. Let's stop here and go back to
    our shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: Database creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before discussing Futures, we were writing tests to check `Cart` and the `Product`
    behavior. But, as the classes were not defined, the code was not even compiling. Let's
    start to create the database and then implement the DAO.
  prefs: []
  type: TYPE_NORMAL
- en: We can use Evolution to automatically create the database each time the server
    starts for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we need to add a script named `1.sql` in `conf/evolutions/default/`,
    where `default` is the database name used in the `configuration` file. This file
    is an SQL file, with a couple of tags to handle the creation and destruction of
    the database upon application start and stop, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with the creation of the product table; the script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this script, we can add some default data upon database creation; this data
    will be used in our tests defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to add the cart table, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We just created the table. Notice that we added a constraint to the cart table;
    we would like to have a unique row with the same `user` and `productCode`.
  prefs: []
  type: TYPE_NORMAL
- en: We explained how table creation and data insertion is done, and we can now concentrate
    on when and how this script is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line, with a special meaning, can be seen in the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This instruction tells Play Evolution how to create the database upon application
    start.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also tell Play how to clean up the database when the application stops.
    The instruction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, when the application quits, we just delete the tables. In fact,
    as our database is in the memory, we don''t really have to delete the table; this
    is just to illustrate the point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can now start the Play application. As soon as you browse `index.html` (`http://localhost:9000/index.html`),
    you'll notice Play asking for permission to execute the script.
  prefs: []
  type: TYPE_NORMAL
- en: Click on Apply this script now!
  prefs: []
  type: TYPE_NORMAL
- en: If you make a mistake in the script, Play Evolution will notify you of an error
    and will provide a Mark it resolved button after the error is fixed.
  prefs: []
  type: TYPE_NORMAL
- en: The database is now ready to be exploited. Let's create the Slick schemas and
    the data access layer.
  prefs: []
  type: TYPE_NORMAL
- en: Data Access Object creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To access our database, we need to define the schema for Slick to perform queries
    against the database and wrap everything in a data access class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProductsDao` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The schema of our database is expressed with a private class, named `ProductsTable`.
    This class is a type definition of our table; each column (`name`, `code`, and
    `description`) is defined by using the `column` parameterized method. The name
    of the column in the database is defined by the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: H2 is case sensitive by default, and it converts all of the column names to
    uppercase. If you change the case of the column name in the `ProductTable` definition,
    you will get an error saying that the column does not exist. You can change the
    case of a selected text in IntelliJ by hitting the keys *cmd* + *Shift* + *U*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The link between this schema and our object model is established with the parameterized
    type of the extended `Table`. In our case, the `Product` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This case class is defined in the `Models.scala` file, located in the `models`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting value is `TableQuery[ProductsTable]`, assigned to `products`.
    This is an object used to create queries against this table; for example, to create
    the query to add a product into the table, the syntax is `products += product`
    (with `product` being a new `product` instance).
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute a query against the database, you will need the following two things:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you will need the query; this is built by `products` (a query object
    generated by the `TableQuery` macro). You can build a query such as `products.result`
    to get all of the rows of the table, or `products.filter(_.price > 10.0)` to get
    all of the products with a price higher than `10.0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, once you have built your query, you will need to execute it to get
    a materialized value. This is done by using the `db` variable defined in the `HasDatabaseConfigProvider`
    class. For example, to get all of the rows of the table, you can use `db.run(products.result)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For `products`, we only have the possibility to query all of the products and
    add a new `Product` to the table. This is represented by the `all()` and `insert(product:
    Product)` methods. In the `insert` method, after executing the query, we map the
    result by using `.map { _ => () } `; this is just to return `Unit` for the execution
    of the side effect.'
  prefs: []
  type: TYPE_NORMAL
- en: You will have noticed that the return type of all of the methods is `Future`;
    this means that the code is executed by Slick completely asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the cart, the code should be more involved; indeed, we need to create a
    cart, add a product to it, remove a product, and even update the quantity for
    a product, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The model of our cart is defined by the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the queries, the operators are the same as the ones used in Scala, except
    that, for the equivalence, you will need to use the `===` operator.
  prefs: []
  type: TYPE_NORMAL
- en: We can spend a little bit of time on the `update` method. As explained in the
    *Future* section, you can use a `for`-comprehension to build your query. In our
    case, we would like to update the quantity of a product in the cart for a specific
    user. We use `for`-comprehension to select the cart based on the user, and then
    update the quantity of the product using the quantity of the cart received as
    a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Running the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now created the database using Evolution, configured Slick, and implemented
    the data access objects to access the tables.
  prefs: []
  type: TYPE_NORMAL
- en: Let's execute the tests we wrote at the beginning; they should compile and should
    all be successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `DatabaseSpec` to be sure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad0b0d3f-4b0b-4c91-860c-9cb60c239412.png)'
  prefs: []
  type: TYPE_IMG
- en: Our persistence layer is now ready to be used. We can deploy this layer on the
    cloud to make sure the deployment is working smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The server is running fine on our localhost, as this application is not doing
    much. This is the perfect time to perform all of the steps to deploy it. With
    each new feature, we are going to deploy it and get used to this process. This
    way, we can tackle the deployment issues little by little, instead of solving
    everything in one shot, usually under stress.
  prefs: []
  type: TYPE_NORMAL
- en: We have decided to deploy this application on Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: Heroku is a **P**latform as a Service (**PaaS**) that supports multiple languages,
    including Scala. Thanks to its simplicity and versatility, the deployment process
    is simple and smooth.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing to do is create an account on the Heroku platform. Heroku provides
    a free account, which is perfect for our usage.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the website ([https://www.heroku.com/](https://www.heroku.com/)) and sign
    up for a free account. You will receive an email from Heroku to validate your
    account and set up a password. As soon as you set up your password, you will land
    on a page to create a new application; this is exactly what we want to do.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Create New App button and pick an application name. This name needs
    to be unique, as it will be used in the URL to reach the application on the internet.
    I am using `shopping-fs`; feel free to pick the name you wish. The name should
    be unique. If it is not, an error will tell you to change the name.
  prefs: []
  type: TYPE_NORMAL
- en: Select the region closest to your location, and click on the Create App button.
    The creation of the application is instantaneous, and you will be redirected directly
    to your Dashboard, under the Deploy tab.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the Heroku website, under the Deploy tab, at the bottom, you will see the
    instructions to deploy your application. The first thing to do is install the
    Heroku CLI; follow this link ([https://devcenter.heroku.com/articles/heroku-cli](https://devcenter.heroku.com/articles/heroku-cli))
    and pick your operating system to install the Heroku CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Once the CLI has been installed, go to IntelliJ and click on the Terminal tab
    located at the bottom of the window. IntelliJ will set the current path of the
    Terminal to the root path of the current project.
  prefs: []
  type: TYPE_NORMAL
- en: 'From inside the Terminal, log in to Heroku by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Type in your email address and password to log in.
  prefs: []
  type: TYPE_NORMAL
- en: If you are on macOS and are using Keychain Access to generate and save the password,
    for some reason, the password generated upon sign up is not saved on Keychain.
    If this is the case, just log out from the Heroku dashboard, and, on the login
    form, click on Forgot Password. You'll receive an email to change your password.
    On that page, you can use the password generation, and Keychain will remember
    it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have logged in, initialize Git with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you will need to add the Heroku reference to Git, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Replace `shopping-fs` with the application name that you picked previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the following printed in your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the file and commit it locally in Git, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is to deploy it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The deployment is executed on the Heroku server, and the log of the server is
    printed to your local console.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process takes a little bit of time. Finally, you should see the following
    in the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: That's it; your application has been compiled, packaged, and executed in the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s browse [https://shopping-fs.herokuapp.com/](https://shopping-fs.herokuapp.com/)
    to confirm it. The following page should appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cef031e8-e566-4715-ac40-c19f2afbf963.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You have deployed your application on the internet. Notice
    that your application can be reached for free on a secure HTTP protocol, with
    valid certificates.
  prefs: []
  type: TYPE_NORMAL
- en: Heroku configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does Heroku know how to execute the application?
  prefs: []
  type: TYPE_NORMAL
- en: 'Heroku knows how to execute the application by reading the instructions from
    a file named `Procfile`, located at the root of the project; the content is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The first indication in the line is the type of application. This can be anything.
    The `web` value is a special type, telling Heroku that this process only receives
    requests from HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: The second part is the path to the executable. In fact, the SBT project creates
    this executable for us during the build process.
  prefs: []
  type: TYPE_NORMAL
- en: The last part is a list of properties for the Play application, namely
  prefs: []
  type: TYPE_NORMAL
- en: '`-Dhttp.port`, which sets the port to listen to by using the Heroku variable, `$PORT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Dconfig.file`, which set the configuration file path to be used by the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we tackled the persistence layer. We created a simple model
    based on two tables, Cart and Product. We used an in-memory database named H2. We
    configured a framework named Slick to asynchrony access data from H2 and added
    a script to create the table and insert data on it. We went through the mechanism used
    by Play Evolution to create the database.
  prefs: []
  type: TYPE_NORMAL
- en: Tests have been written to define the behaviors of the cart and the product
    objects. As the data queries are done asynchrony, we spent time understanding
    how to deal with `Future`. Finally, we deployed this layer in the cloud using
    a cloud application service named Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to define a RESTful API to expose the data
    persisted in this chapter.
  prefs: []
  type: TYPE_NORMAL
