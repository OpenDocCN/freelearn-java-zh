- en: Online Shopping - Persistence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线购物 - 持久性
- en: In the next four chapters, we will write a project using the most common libraries
    and framework from the Scala ecosystem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的四章中，我们将使用Scala生态系统中最常见的库和框架来编写一个项目。
- en: We are going to implement the cart management of an online shopping website,
    from the front-end to the database.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从前端到数据库实现一个在线购物网站的购物车管理。
- en: Starting from the database, we are going to implement a persistence layer. The
    responsibility of this layer is to persist in a relational database the content
    of the cart, for that purpose we are going to use a relational persistence framework
    named Slick.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库开始，我们将实现一个持久性层。这个层的责任是将购物车的内 容持久化到关系型数据库中。为此，我们将使用一个名为Slick的关系型持久化框架。
- en: Then, we are going to spend times to define an API to access the database, this
    API will use RESTfull web services architecture and JSON as message protocol.
    The API will be fully documented and testable from a generated website.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将花费时间来定义一个访问数据库的API，这个API将使用RESTful Web服务架构和JSON作为消息协议。API将完全由生成的网站进行文档化和测试。
- en: Finally, we are going to implement the user interface layer. With this interface,
    the user can add products into its cart, remove products and update the quantity
    of a particular product in the cart. Scala.js is used to implement this interface.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将实现用户界面层。通过这个界面，用户可以将其产品添加到购物车中，移除产品，并更新购物车中特定产品的数量。Scala.js被用来实现这个界面。
- en: In this chapter, we will explain how to persist data in a relational database.
    The data will be the contents of a cart for a shopping website.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释如何在关系型数据库中持久化数据。数据将是购物网站购物车的内 容。
- en: If we want to build a robust website accepting lots of simultaneous connection,
    special care is needed to have all of the layers of the solution to scale with
    the demand.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要构建一个能够接受大量同时连接的健壮网站，就需要特别小心，确保解决方案的所有层都能随着需求进行扩展。
- en: At the level of the persistence layer, a key point to scale would be to not
    overuse the system resources, more precisely the threads, each time data is written
    into the database. Indeed, if each request to the database is blocking a thread,
    the limit of concurrent connections will be reached quickly.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在持久性层级别，一个关键点是不要过度使用系统资源，更确切地说，每次将数据写入数据库时不要过度使用线程。实际上，如果每个对数据库的请求都阻塞了一个线程，那么并发连接的限制将很快达到。
- en: For that purpose, we will use an asynchronous framework called Slick to perform
    database actions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们将使用一个名为Slick的异步框架来执行数据库操作。
- en: In order to use the Slick framework, an introduction to Scala `Future` will
    be necessary. `Future` is one of the basic tools to handle asynchronous code in
    Scala.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Slick框架，将需要介绍Scala `Future`。`Future`是Scala中处理异步代码的基本工具之一。
- en: As we rarely host a website at home, we are going to deploy this layer, and
    later the whole website, to the internet by using a cloud service provider named
    Heroku. This means that the shopping cart will be accessible from all over the
    world.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们很少在家托管网站，我们将使用名为Heroku的云服务提供商来部署这一层，以及稍后整个网站。这意味着购物车将从世界各地都可以访问。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating the project
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建项目
- en: Persistence
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久性
- en: Deploying the application
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署应用程序
- en: Heroku configuration
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Heroku配置
- en: Creating the project
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目
- en: To facilitate the project creation, we are providing a template which generates
    the skeleton of the project. For that purpose, [Gitter8](http://www.foundweekends.org/giter8/) will
    help us to generate the complete project based on a template hosted in Git.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便项目创建，我们提供了一个模板，该模板可以生成项目的骨架。为此，[Gitter8](http://www.foundweekends.org/giter8/)将帮助我们根据托管在Git中的模板生成完整的项目。
- en: We are not going to directly use the command line of Gitter8\. We are instead
    going to use the integration with sbt to generate the project.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会直接使用Gitter8的命令行。相反，我们将使用与sbt的集成来生成项目。
- en: 'The template can be found on Github at [GitHub - scala-fundamentals/scala-play.g8:
    Template used for the online shopping](https://github.com/scala-fundamentals/scala-play.g8.git). This
    template has been forked from [https://github.com/vmunier/play-scalajs.g8.](https://github.com/vmunier/play-scalajs.g8.) We
    essentially changed the framework test from Specs2 to ScalaTest and added all
    the dependencies needed for our shopping project.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '模板可以在 Github 上找到，地址为 [GitHub - scala-fundamentals/scala-play.g8: 用于在线购物的模板](https://github.com/scala-fundamentals/scala-play.g8.git)。这个模板是从
    [https://github.com/vmunier/play-scalajs.g8.](https://github.com/vmunier/play-scalajs.g8.)
    分支出来的。我们基本上将框架测试从 Specs2 更改为 ScalaTest，并添加了我们购物项目所需的全部依赖项。'
- en: 'To create the project, enter the following in your console:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建项目，请在您的控制台中输入以下内容：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will create a new folder with all the files and folders needed for our
    project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含我们项目所需的所有文件和文件夹的新文件夹。
- en: 'You can now import this project in IntelliJ, click on Import Project select
    sbt on the first dialogue box:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以将此项目导入 IntelliJ，点击导入项目，在第一个对话框中选择 sbt：
- en: '![](img/634469b6-44c4-4e79-87bd-0a7946c7b245.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/634469b6-44c4-4e79-87bd-0a7946c7b245.png)'
- en: 'Click on Next, on the next dialogue box, please check the option Use sbt shell
    for build and import (requires sbt 0.13.5+) as shown in the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 点击下一步，在下一个对话框中，请勾选使用 sbt shell 进行构建和导入（需要 sbt 0.13.5+）选项，如下所示：
- en: '![](img/c0776ff8-31c5-42dd-b214-149b8232ba1a.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0776ff8-31c5-42dd-b214-149b8232ba1a.png)'
- en: That's it, we are ready for the implementation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们为实施做好了准备。
- en: Persistence
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久性
- en: In the context of the online shopping project, we are going to create a simple
    data model with only two tables—the cart and product tables. The product represents
    what we would like to sell. It has a name, a code, a description, and a price.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在在线购物项目的背景下，我们将创建一个简单的数据模型，只包含两个表——购物车和产品表。产品代表我们想要销售的商品。它有一个名称、一个代码、一个描述和一个价格。
- en: The cart what a customer is about to buy. It has an ID, which is autoincremented
    for any new cart created, and a user, representing the user identification. For
    the purpose of this book, we are going to use the username sent during the login
    process. The cart also has a quantity and a code, representing a link to the product
    table.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车是客户即将购买的商品。它有一个 ID，任何新创建的购物车都会自动递增，还有一个用户，代表用户标识。为了本书的目的，我们将使用登录过程中发送的用户名。购物车还有一个数量和代码，代表与产品表的链接。
- en: 'The following diagram is a representation of our model:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表示我们的模型：
- en: '![](img/ffbc423a-10d7-4796-a141-9f8d8f924663.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ffbc423a-10d7-4796-a141-9f8d8f924663.png)'
- en: For the purposes of this book, we will choose a database that requires no administration,
    is fast, with a small footprint, and can be deployed quickly and smoothly. The
    H2 database fulfills all of these requirements.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本书的目的，我们将选择一个无需管理的数据库，速度快，占用空间小，并且可以快速顺利地部署的数据库。H2 数据库满足所有这些要求。
- en: To access our data, we would like to take advantage of the Scala language to
    statically check our code at compile time. The Slick library is perfect for this
    task.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问我们的数据，我们希望利用 Scala 语言在编译时静态检查我们的代码。Slick 库非常适合这项任务。
- en: 'Slick can generate SQL for multiple databases, and it supports the following
    RDBMS (with the respective JDBC driver versions):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Slick 可以为多个数据库生成 SQL，并支持以下 RDBMS（以及相应的 JDBC 驱动程序版本）：
- en: '| Database | JDBC Driver |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 数据库 | JDBC 驱动程序 |'
- en: '| SQLServer 2008, 2012, 2014 | jTDS - SQL Server and Sybase JDBC driver ([https://sourceforge.net/projects/jtds/](https://sourceforge.net/projects/jtds/))
    and Microsoft JDBC Driver 6.0 for SQL Server ([https://www.microsoft.com/en-gb/download/details.aspx?id=11774](https://www.microsoft.com/en-gb/download/details.aspx?id=11774))
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| SQLServer 2008, 2012, 2014 | jTDS - SQL Server and Sybase JDBC driver ([https://sourceforge.net/projects/jtds/](https://sourceforge.net/projects/jtds/))
    and Microsoft JDBC Driver 6.0 for SQL Server ([https://www.microsoft.com/en-gb/download/details.aspx?id=11774](https://www.microsoft.com/en-gb/download/details.aspx?id=11774))
    |'
- en: '| Oracle 11g | [http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html](http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html)
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| Oracle 11g | [http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html](http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html)
    |'
- en: '| DB2 10.5 | [http://www-01.ibm.com/support/docview.wss?uid=swg21363866](http://www-01.ibm.com/support/docview.wss?uid=swg21363866)
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| DB2 10.5 | [http://www-01.ibm.com/support/docview.wss?uid=swg21363866](http://www-01.ibm.com/support/docview.wss?uid=swg21363866)
    |'
- en: '| MySQL | `mysql-connector-java:5.1.23` ( [https://dev.mysql.com/downloads/connector/j/](https://dev.mysql.com/downloads/connector/j/))
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| MySQL | `mysql-connector-java:5.1.23` ( [https://dev.mysql.com/downloads/connector/j/](https://dev.mysql.com/downloads/connector/j/))
    |'
- en: '| PostgreSQL | PostgreSQL JDBC Driver: `9.1-901.jdbc4` ([https://jdbc.postgresql.org](https://jdbc.postgresql.org))
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| PostgreSQL | PostgreSQL JDBC Driver: `9.1-901.jdbc4` ([https://jdbc.postgresql.org](https://jdbc.postgresql.org))
    |'
- en: '| SQLite | `sqlite-jdbc:3.8.7` ([https://bitbucket.org/xerial/sqlite-jdbc/downloads/](https://bitbucket.org/xerial/sqlite-jdbc/downloads/))
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| SQLite | `sqlite-jdbc:3.8.7` ([https://bitbucket.org/xerial/sqlite-jdbc/downloads/](https://bitbucket.org/xerial/sqlite-jdbc/downloads/))
    |'
- en: '| Derby/JavaDB | `derby:10.9.1.0` ([https://db.apache.org/derby/derby_downloads.html](https://db.apache.org/derby/derby_downloads.html))
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| Derby/JavaDB | `derby:10.9.1.0` ([https://db.apache.org/derby/derby_downloads.html](https://db.apache.org/derby/derby_downloads.html))
    |'
- en: '| HSQLDB/HyperSQL | `hsqldb:2.2.8` ([https://sourceforge.net/projects/hsqldb/](https://sourceforge.net/projects/hsqldb/))
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| HSQLDB/HyperSQL | `hsqldb:2.2.8` ([https://sourceforge.net/projects/hsqldb/](https://sourceforge.net/projects/hsqldb/))
    |'
- en: '| H2 | `com.h2database.h2:1.4.187` ([http://h2database.com/html/download.html](http://h2database.com/html/download.html))
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| H2 | `com.h2database.h2:1.4.187` ([http://h2database.com/html/download.html](http://h2database.com/html/download.html))
    |'
- en: Setting up Slick
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Slick
- en: 'What do we need to set up Slick? In the `build.sbt` file from the project generated
    on the *Developing a full project* chapter, the requested libraries are set in
    the server section. Slick is well integrated with Play, and the full list of dependencies
    is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设置Slick吗？在*Developing a full project*章节中生成的项目`build.sbt`文件中，请求的库在服务器部分设置。Slick与Play集成良好，依赖项的完整列表如下：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We added Slick dependencies, as well as the Evolution module. Evolution is a
    module that simplifies schema management; we will come back to that later.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了Slick依赖项以及Evolution模块。Evolution是一个简化模式管理的模块；我们稍后会回到这一点。
- en: We had to add the JDBC driver as well; this is due to the fact that Slick does
    not come bundled with all of the drivers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还不得不添加JDBC驱动；这是因为Slick并没有捆绑所有驱动。
- en: Setting up the database
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置数据库
- en: The database setup is done in the `conf/application.conf` file. When a database
    is needed, it must be configured in this file. Slick provides a default configuration,
    named `default`. For a new database, replace this name with the name of your database.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库设置在`conf/application.conf`文件中完成。当需要数据库时，必须在文件中进行配置。Slick提供了一个默认配置，名为`default`。对于新的数据库，将此名称替换为您的数据库名称。
- en: We will enable `evolution` and tell it to automatically run the scripts for
    database creation and deletion.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将启用`evolution`并告诉它自动运行数据库创建和删除的脚本。
- en: 'In our case, the entry looks as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，条目如下：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The complete configuration option can be found in the Play Framework documentation
    ([https://www.playframework.com/documentation/2.6.x/PlaySlick](https://www.playframework.com/documentation/2.6.x/PlaySlick)).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的配置选项可以在Play框架文档中找到 ([https://www.playframework.com/documentation/2.6.x/PlaySlick](https://www.playframework.com/documentation/2.6.x/PlaySlick))。
- en: Database test
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库测试
- en: Before we get started, we should check that the database created by `evolution`
    is correct, and we should define the expected behaviors.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们应该检查`evolution`创建的数据库是否正确，并定义预期的行为。
- en: Product test
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品测试
- en: We should also verify that three product rows are inserted when the application
    is started.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该验证在应用程序启动时是否插入了三个产品行。
- en: 'Create a test class, named `ProductDaoSpec`, which extends `PlaySpec`. Now, `PlaySpec`
    is the integration of ScalaTest in Play. The `ProductDaoSpec` class also needs
    to extend the `GuiceOneAppPerSuite` trait. This trait adds a new instance of the
    `Application` object to the ScalaTest suite:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`ProductDaoSpec`的测试类，它扩展了`PlaySpec`。现在，`PlaySpec`是ScalaTest在Play中的集成。`ProductDaoSpec`类还需要扩展`GuiceOneAppPerSuite`特质。这个特质向ScalaTest套件添加了`Application`对象的新实例：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Play provides a helper method to create an instance in the cache. As you can
    see, `app2dao` can create an instance of `ProductDao`, which was the type parameter
    passed to `instanceCache`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Play提供了一个辅助方法来在缓存中创建实例。正如你所见，`app2dao`可以创建`ProductDao`的实例，这是传递给`instanceCache`的类型参数。
- en: The matcher on the `Set` is not strict, and it does not take into account the
    order of the rows received. If you would like to be stricter, ScalaTest provides
    the `theSameElementsInOrderAs` matcher, which checks the order of the elements
    in the collection.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`上的匹配器不是严格的，它不考虑接收到的行的顺序。如果你想要更严格，ScalaTest提供了`theSameElementsInOrderAs`匹配器，该匹配器检查集合中元素的顺序。'
- en: As the `dao.all()` function returns `Future`, ScalaTest provides the `.futureValue` helper
    to wait on `Future` to finish before testing the value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`dao.all()`函数返回`Future`，ScalaTest提供了`.futureValue`辅助方法，以便在测试值之前等待`Future`完成。
- en: Cart test
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购物车测试
- en: What about the cart? We would like to make sure that the cart is empty when
    the application is run so that we can add items to it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，购物车呢？我们希望确保当应用程序运行时购物车为空，这样我们就可以向其中添加项目。
- en: 'Just like we did for the product, we will create a class named `CartDaoSpec`.
    The test looks as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对产品所做的那样，我们将创建一个名为 `CartDaoSpec` 的类。测试看起来如下：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `be empty on database creation` test makes sure that no carts exist upon
    creation of the application, and `accept to add new cart` makes sure that we can
    insert products into a specific cart; when the cart is read back, only the product
    of that cart is returned. This is tested by the fact that we are adding a new
    product to the cart of `user2`, instead of `user1`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`数据库创建时为空` 测试确保在应用程序创建时没有购物车存在，而 `接受添加新购物车` 确保我们可以将产品插入到特定的购物车中；当读取购物车时，只返回该购物车的产品。这通过我们在
    `user2` 的购物车中添加新产品而不是 `user1` 来测试。'
- en: 'For consistency, we would like to have a constraint on the database where we
    only have a unique tuple `user` and `productCode`. In case we do not have a unique
    pair, we should expect an error to be thrown from the database saying that the
    cart already exists:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一致性，我们希望在数据库中有一个约束，其中只有一个唯一的元组 `user` 和 `productCode`。如果没有唯一的配对，我们应该期望数据库抛出一个错误，表示购物车已存在：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In `expected.map(dao.insert(_)) ++ noise.map(dao.insert(_))` , we are creating
    a `Set` of `Future` by adding the Futures from the expected cart insertion and
    the noise cart insertion.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `expected.map(dao.insert(_)) ++ noise.map(dao.insert(_))` 中，我们通过添加预期的购物车插入和噪声购物车插入的
    `Future` 来创建一个 `Future` 的 `Set`。
- en: To test if an error is thrown, ScalaTest provides the `recoverToSucceededIf[T]` function
    that tests if the `Future` passed as a parameter throws the type `[T]` error.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试是否抛出错误，ScalaTest 提供了 `recoverToSucceededIf[T]` 函数，该函数测试作为参数传递的 `Future` 是否抛出类型
    `[T]` 的错误。
- en: We would also like to test whether we can remove an item from the cart.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望测试是否可以从购物车中移除一个项目。
- en: 'The following code will perform this test:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将执行此测试：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, we add an initial cart with two products, and then, we remove one product from
    the cart. Notice that we introduced a new class, named `ProductInCart`, which
    represents a product in a cart.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加一个包含两个产品的初始购物车，然后，我们从购物车中移除一个产品。注意，我们引入了一个新的类，名为 `ProductInCart`，它代表购物车中的一个产品。
- en: 'To be complete, our `CartDao` should accept updating the product quantity in
    a cart; this is represented by the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整，我们的 `CartDao` 应该接受更新购物车中的产品数量；这由以下代码表示：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this test, we first set the cart for `userUpd` with a quantity of `1` unit
    of `ALD1`, and then update it with a quantity of `5` units of `ALD1`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们首先将 `userUpd` 的购物车设置为 `1` 单位的 `ALD1`，然后将其更新为 `5` 单位的 `ALD1`。
- en: Of course, as there is no implementation, the test does not even compile; it
    is time to create the database and implement the **Data Access Objects** (**DAO**).
    Before going further, notice the piece of code with `.futureValue`. This is the
    perfect time to explain what Futures are all about.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，因为没有实现，测试甚至无法编译；是时候创建数据库并实现 **数据访问对象** （**DAO**）了。在继续之前，请注意带有 `.futureValue`
    的代码片段。这是解释 Futures 是什么的完美时机。
- en: Future
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Future
- en: As you can see in the test code, `wsClient.url(testURL).get()` returns `Future`;
    more precisely, it returns `Future` of `Response` (`Future[Response]`).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在测试代码中所见，`wsClient.url(testURL).get()` 返回 `Future`；更确切地说，它返回 `Response` 的
    `Future` (`Future[Response]`)。
- en: '`Future` represents a piece of code executed asynchronously. The code starts
    its execution upon the creation of `Future`, without knowing when it will finish
    its execution.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future` 代表一个异步执行的代码片段。代码在创建 `Future` 时开始执行，并不知道何时会完成执行。'
- en: So far, so good; but how can we get the result?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利；但我们如何获取结果？
- en: Before we answer this question, there are some important points to understand.
    What is the purpose of writing asynchronous code?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们回答这个问题之前，有一些重要的观点需要理解。编写异步代码的目的是什么？
- en: We write it to improve performance. Indeed, if the code is run in parallel,
    we can take advantage of the multiple cores that are available on modern CPUs.
    This is all fine, but in my program, I cannot parallelize every piece of code.
    Some pieces are dependent on values coming from others.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其写入以提高性能。确实，如果代码以并行方式运行，我们可以利用现代 CPU 上可用的多个核心。这一切都很好，但在我程序中，我不能并行化每一块代码。有些代码依赖于来自其他代码的值。
- en: Wouldn't it be nice if I could compose my code in such a way that as soon as
    a value is finished being evaluated, the program goes ahead and uses that variable?
    That is the exact purpose of `Future`. You can compose pieces of asynchronous
    code together; the result of the composition is another `Future`, which can be
    composed with another `Future`, and so on.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我能够以这种方式组合代码，一旦值完成评估，程序就继续使用该变量，那岂不是很好？这正是`Future`的目的。你可以将异步代码片段组合在一起；组合的结果是另一个`Future`，它可以与另一个`Future`组合，依此类推。
- en: Getting a concrete value
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取具体值
- en: OK, we can compose Futures to have new Futures but, at some point, we will need
    to have a concrete value instead of `Future`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们可以组合Future以得到新的Future，但到了某个时候，我们需要一个具体的值而不是`Future`。
- en: When we asked to get the response of a REST call, we receive `Future` from the
    function. The particularity of `Future` is that we do not know when it is going
    to finish so in our test we need to wait until we get the concrete value of `Future`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们请求获取REST调用的响应时，我们从函数中收到`Future`。`Future`的特殊之处在于我们不知道它何时会完成，因此在我们的测试中我们需要等待直到我们得到`Future`的具体值。
- en: To get a concrete value, you can either wait for `Future` to complete or provide
    a callback. Let us go into the details of both cases.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取具体值，你可以等待`Future`完成或提供一个回调。让我们深入了解这两种情况。
- en: Waiting on a Future
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待Future完成
- en: The `Await.result` method is waiting for the result to be available. We have
    the possibility to give a timeout to the method so that it does not block forever.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Await.result`方法正在等待结果可用。我们可以给这个方法提供一个超时，这样它就不会永远阻塞。'
- en: 'The signature is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 签名如下：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first parameter waits for `Awaitable` (`Future` extends `Awaitable`), and
    the second is `Duration`. `Duration` is the time to wait before throwing `TimeoutException`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数等待`Awaitable`（`Future`扩展了`Awaitable`），第二个是`Duration`。`Duration`是在抛出`TimeoutException`之前等待的时间。
- en: This is a pretty convenient method to get the value in our test.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在我们的测试中获取值的一种非常方便的方法。
- en: 'If you add `import scala.concurrent.duration._` in the import section, you
    can use a **Domain Specific Language** (**DSL**) to express the duration in plain
    English, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`import scala.concurrent.duration._`添加到导入部分，你可以使用**领域特定语言**（**DSL**）用普通的英语表达持续时间，如下所示：
- en: '`1 second`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`1 second`'
- en: '`2 minutes`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`2 minutes`'
- en: Callback
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调
- en: 'Another way to get the result is to use a callback function. In this case,
    we stay asynchronous to get the value. The syntax is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种获取结果的方法是使用回调函数。在这种情况下，我们保持异步以获取值。语法如下：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First, `Future` is created and assigned to `f`; then, we handle the success
    case, and then, the failure case.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建`Future`并将其分配给`f`；然后，我们处理成功情况，然后是失败情况。
- en: Composing Futures
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合Future
- en: You have learned how to get a concrete value out of `Future`; you will now learn
    how to compose multiple Futures.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何从`Future`中获取具体值；现在你将学习如何组合多个Future。
- en: Using for-comprehension
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用for-comprehension
- en: '`Future` has a `map` and a `flatMap` method. Therefore, as we saw in [Chapter
    3](f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml), *Handling Errors*, for `Either`,
    we can use `Future` in a `for`-comprehension. For instance, we can define three
    Futures, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future`有一个`map`和`flatMap`方法。因此，正如我们在[第3章](f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml)中看到的，*处理错误*，对于`Either`，我们可以在`for`-comprehension中使用`Future`。例如，我们可以定义三个Future，如下所示：'
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The Futures are simply successfully returning an integer. If we would like
    to sum up all of the integers we could write the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些Future只是成功返回一个整数。如果我们想将所有整数相加，我们可以编写以下代码：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `res` variable will be `Future[Int]`; hence, we can call `Await` to get
    the final value:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`res`变量将是`Future[Int]`；因此，我们可以调用`Await`来获取最终值：'
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The response would be `6`, in our case.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，响应将是`6`。
- en: 'You just learned that inside the `for`-comprehension, the value from `Future`
    can be used and can be composed with other values. But there is more; you can
    also add an `if` condition inside, acting as a filter. Suppose that we would like
    to check that the three numbers from the previous example, when added together,
    are greater than five. If this is the case, then it should return a tuple with
    the three numbers; otherwise, it should return a failure. We can first define
    a function that takes an undefined number of parameters and returns their `sum`,
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚了解到在 `for`-comprehension 中，可以从 `Future` 中使用值，并且可以将这些值与其他值组合。但不仅如此；你还可以在内部添加一个
    `if` 条件，作为过滤器。假设我们想要检查前一个例子中的三个数字相加是否大于五。如果是这样，那么它应该返回一个包含三个数字的元组；否则，它应该返回一个失败。我们可以首先定义一个函数，该函数接受一个未定义数量的参数并返回它们的
    `sum`，如下所示：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can define multiple parameters by adding `*` after the type in the parameter
    definition; this is called a **variadic **or `varargs` function.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在参数定义中的类型后添加 `*` 来定义多个参数；这被称为 **可变参数** 或 `varargs` 函数。
- en: 'The `for`-comprehension, with our filter, will look as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 带有我们的过滤器的 `for`-comprehension 将如下所示：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can employ what we learned in the previous section, and use a callback to
    get the value, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以应用我们在上一节中学到的知识，并使用回调来获取值，如下所示：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following code will be printed in the console:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将在控制台打印出来：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'However, if you set `minExpected` to `7`, you should obtain the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你将 `minExpected` 设置为 `7`，你应该得到以下结果：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In fact, `Future` is a failure; its representation is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`Future` 是一个失败；其表示如下：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'One last thing—I am sure that you noticed the following in the first piece
    of code that we imported:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事——我确信你已经注意到了我们导入的第一段代码中的以下内容：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What is this strange import? It is the execution context, which will be covered
    in the next section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个奇怪的导入是什么？它是执行上下文，将在下一节中介绍。
- en: Execution context
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行上下文
- en: 'When we create a `Future`, the code is executed asynchronously on the JVM,
    but what is used to execute that code? In fact, the only way to execute code in
    parallel is to use threads. A naive approach would be to suggest: I should just
    create a new thread each time I would like to execute a new piece of code. However,
    that is a really bad idea. First, the number of threads is limited by the operating
    system; you cannot spawn as many threads as you want. Secondly, you could face
    thread starvation ([https://docs.oracle.com/javase/tutorial/essential/concurrency/starvelive.html](https://docs.oracle.com/javase/tutorial/essential/concurrency/starvelive.html));
    this happens when your CPU spends all of its time switching contexts between threads,
    instead of executing real code.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个 `Future` 时，代码在 JVM 上异步执行，但执行该代码的是什么？实际上，执行并行代码的唯一方法就是使用线程。一个简单的方法可能会建议：每次我想执行新的代码片段时，我只需创建一个新的线程。然而，这真是一个糟糕的想法。首先，线程的数量受操作系统的限制；你不能创建你想要的那么多线程。其次，你可能会遇到线程饥饿（[https://docs.oracle.com/javase/tutorial/essential/concurrency/starvelive.html](https://docs.oracle.com/javase/tutorial/essential/concurrency/starvelive.html)）；这发生在你的
    CPU 将所有时间都花在在线程之间切换上下文，而不是执行实际代码。
- en: OK, but how can you manage the thread creation? That is the purpose of the execution
    context. You can set the policy that you wish to manage your threads. Scala provides
    a default policy that creates and manages a pool of threads; the number of threads
    is automatically defined by the number of processors available to the JVM.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，但你怎么管理线程的创建？这就是执行上下文的目的。你可以设置你希望管理的线程的策略。Scala 提供了一个默认策略，该策略创建并管理一个线程池；线程的数量由
    JVM 可用的处理器数量自动定义。
- en: So, by importing `scala.concurrent.ExecutionContext.Implicits.global`, you are
    just saying that you would like to use the default policy to manage your thread,
    which should be fine for the majority of your code. You might need to define your
    own `ExecutionContext`, if, for example, you are creating `Future` that gets data
    from a legacy software blocking the call.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过导入 `scala.concurrent.ExecutionContext.Implicits.global`，你只是在说你想使用默认策略来管理你的线程，这对于你的大部分代码来说应该是可以的。如果你，例如，正在创建从阻止调用的遗留软件获取数据的
    `Future`，你可能需要定义自己的 `ExecutionContext`。
- en: Rounding up Futures
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 期货的汇总
- en: The basic operations on `Future` are `map` and `flatMap`. In fact, when we use
    the `for`-comprehension, under the hood, the compiler transforms our loop with
    `map` and `flatMap`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future` 的基本操作是 `map` 和 `flatMap`。实际上，当我们使用 `for`-comprehension 时，底层编译器会将我们的循环转换为
    `map` 和 `flatMap`。'
- en: Futures are very important in Scala; we have only learned the basics of Futures;
    just enough to understand the code in this book. Let's stop here and go back to
    our shopping cart.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，未来（Futures）非常重要；我们只学到了未来的基础知识；足够理解这本书中的代码。让我们在这里停下来，回到我们的购物车。
- en: Database creation
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库创建
- en: Before discussing Futures, we were writing tests to check `Cart` and the `Product`
    behavior. But, as the classes were not defined, the code was not even compiling. Let's
    start to create the database and then implement the DAO.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论未来（Futures）之前，我们正在编写测试来检查 `Cart` 和 `Product` 的行为。但是，由于类尚未定义，代码甚至无法编译。让我们开始创建数据库并实现
    DAO。
- en: We can use Evolution to automatically create the database each time the server
    starts for the first time.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Evolution 在服务器第一次启动时自动创建数据库。
- en: To do so, we need to add a script named `1.sql` in `conf/evolutions/default/`,
    where `default` is the database name used in the `configuration` file. This file
    is an SQL file, with a couple of tags to handle the creation and destruction of
    the database upon application start and stop, respectively.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，我们需要在 `conf/evolutions/default/` 中添加一个名为 `1.sql` 的脚本，其中 `default` 是在 `configuration`
    文件中使用的数据库名称。这是一个 SQL 文件，包含一些标签来处理应用程序启动和停止时数据库的创建和销毁。
- en: 'We will start with the creation of the product table; the script is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建产品表开始；脚本如下所示：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this script, we can add some default data upon database creation; this data
    will be used in our tests defined earlier:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本中，我们可以在数据库创建时添加一些默认数据；这些数据将用于我们之前定义的测试：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The next step is to add the cart table, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加购物车表，如下所示：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We just created the table. Notice that we added a constraint to the cart table;
    we would like to have a unique row with the same `user` and `productCode`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了表。请注意，我们在购物车表中添加了一个约束；我们希望有一个具有相同 `user` 和 `productCode` 的唯一行。
- en: We explained how table creation and data insertion is done, and we can now concentrate
    on when and how this script is executed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解释了如何进行表创建和数据插入，现在我们可以专注于何时以及如何执行此脚本。
- en: 'The following line, with a special meaning, can be seen in the script:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中可以看到具有特殊意义的以下一行：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This instruction tells Play Evolution how to create the database upon application
    start.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个说明告诉 Play Evolution 在应用程序启动时如何创建数据库。
- en: 'We can also tell Play how to clean up the database when the application stops.
    The instruction is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以告诉 Play 在应用程序停止时如何清理数据库。说明如下：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In our case, when the application quits, we just delete the tables. In fact,
    as our database is in the memory, we don''t really have to delete the table; this
    is just to illustrate the point:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，当应用程序退出时，我们只需删除表。实际上，由于我们的数据库在内存中，我们实际上并不需要删除表；这只是为了说明这一点：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can now start the Play application. As soon as you browse `index.html` (`http://localhost:9000/index.html`),
    you'll notice Play asking for permission to execute the script.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以启动 Play 应用程序。一旦您浏览 `index.html`（`http://localhost:9000/index.html`），您会注意到
    Play 正在请求执行脚本的权限。
- en: Click on Apply this script now!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“应用此脚本”现在！
- en: If you make a mistake in the script, Play Evolution will notify you of an error
    and will provide a Mark it resolved button after the error is fixed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚本中出错，Play Evolution 将通知您错误，并在错误修复后提供一个“标记为已解决”按钮。
- en: The database is now ready to be exploited. Let's create the Slick schemas and
    the data access layer.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库现在已准备好被利用。让我们创建 Slick 架构和数据访问层。
- en: Data Access Object creation
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据访问对象（DAO）创建
- en: To access our database, we need to define the schema for Slick to perform queries
    against the database and wrap everything in a data access class.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问我们的数据库，我们需要为 Slick 定义架构以对数据库进行查询，并将所有内容包装在数据访问类中。
- en: 'The `ProductsDao` class is as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductsDao` 类如下所示：'
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The schema of our database is expressed with a private class, named `ProductsTable`.
    This class is a type definition of our table; each column (`name`, `code`, and
    `description`) is defined by using the `column` parameterized method. The name
    of the column in the database is defined by the parameter.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们数据库的架构是通过一个名为 `ProductsTable` 的私有类来表达的。这个类是我们表的类型定义；每个列（`name`、`code` 和 `description`）都是通过使用
    `column` 参数化方法定义的。数据库中列的名称由参数定义。
- en: H2 is case sensitive by default, and it converts all of the column names to
    uppercase. If you change the case of the column name in the `ProductTable` definition,
    you will get an error saying that the column does not exist. You can change the
    case of a selected text in IntelliJ by hitting the keys *cmd* + *Shift* + *U*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: H2默认是区分大小写的，并且它将所有列名转换为大写。如果你在`ProductTable`定义中更改列名的大小写，你会得到一个错误，表明该列不存在。你可以在IntelliJ中通过按*cmd*
    + *Shift* + *U*键来更改所选文本的大小写。
- en: 'The link between this schema and our object model is established with the parameterized
    type of the extended `Table`. In our case, the `Product` class is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式与我们的对象模型之间的联系是通过扩展`Table`的参数化类型建立的。在我们的例子中，`Product`类如下所示：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This case class is defined in the `Models.scala` file, located in the `models`
    package.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个case类是在`models`包中的`Models.scala`文件中定义的。
- en: Another interesting value is `TableQuery[ProductsTable]`, assigned to `products`.
    This is an object used to create queries against this table; for example, to create
    the query to add a product into the table, the syntax is `products += product`
    (with `product` being a new `product` instance).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的价值是`TableQuery[ProductsTable]`，赋值给`products`。这是一个用于对此表创建查询的对象；例如，要创建将产品添加到表中的查询，语法是`products
    += product`（其中`product`是一个新的`product`实例）。
- en: 'To execute a query against the database, you will need the following two things:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要对数据库执行查询，你需要以下两个东西：
- en: First, you will need the query; this is built by `products` (a query object
    generated by the `TableQuery` macro). You can build a query such as `products.result`
    to get all of the rows of the table, or `products.filter(_.price > 10.0)` to get
    all of the products with a price higher than `10.0`.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，你需要查询；这是通过`products`（由`TableQuery`宏生成的查询对象）构建的。你可以构建一个查询，如`products.result`来获取表的所有行，或者`products.filter(_.price
    > 10.0)`来获取价格高于`10.0`的所有产品。
- en: Secondly, once you have built your query, you will need to execute it to get
    a materialized value. This is done by using the `db` variable defined in the `HasDatabaseConfigProvider`
    class. For example, to get all of the rows of the table, you can use `db.run(products.result)`.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，一旦你构建了查询，你需要执行它以获取一个具体化的值。这是通过使用在`HasDatabaseConfigProvider`类中定义的`db`变量来完成的。例如，要获取表的所有行，你可以使用`db.run(products.result)`。
- en: 'For `products`, we only have the possibility to query all of the products and
    add a new `Product` to the table. This is represented by the `all()` and `insert(product:
    Product)` methods. In the `insert` method, after executing the query, we map the
    result by using `.map { _ => () } `; this is just to return `Unit` for the execution
    of the side effect.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '对于`products`，我们只有查询所有产品并将新的`Product`添加到表中的可能性。这由`all()`和`insert(product: Product)`方法表示。在`insert`方法中，在执行查询后，我们通过使用`.map
    { _ => () }`来映射结果；这只是为了返回`Unit`以执行副作用。'
- en: You will have noticed that the return type of all of the methods is `Future`;
    this means that the code is executed by Slick completely asynchronously.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到所有方法的返回类型都是`Future`；这意味着代码是由Slick完全异步执行的。
- en: 'For the cart, the code should be more involved; indeed, we need to create a
    cart, add a product to it, remove a product, and even update the quantity for
    a product, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于购物车，代码应该更加复杂；实际上，我们需要创建一个购物车，向其中添加产品，从购物车中移除产品，甚至更新产品的数量，如下所示：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The model of our cart is defined by the following class:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的购物车模型由以下类定义：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the queries, the operators are the same as the ones used in Scala, except
    that, for the equivalence, you will need to use the `===` operator.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询中，运算符与Scala中使用的相同，只是对于等价运算，你需要使用`===`运算符。
- en: We can spend a little bit of time on the `update` method. As explained in the
    *Future* section, you can use a `for`-comprehension to build your query. In our
    case, we would like to update the quantity of a product in the cart for a specific
    user. We use `for`-comprehension to select the cart based on the user, and then
    update the quantity of the product using the quantity of the cart received as
    a parameter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以花一点时间来讲解一下`update`方法。正如在*未来*部分所解释的，你可以使用`for`-comprehension来构建你的查询。在我们的例子中，我们希望更新特定用户的购物车中某个产品的数量。我们使用`for`-comprehension根据用户选择购物车，然后使用接收到的购物车数量作为参数来更新产品的数量。
- en: Running the test
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: We have now created the database using Evolution, configured Slick, and implemented
    the data access objects to access the tables.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经使用Evolution创建了数据库，配置了Slick，并实现了数据访问对象以访问表。
- en: Let's execute the tests we wrote at the beginning; they should compile and should
    all be successful.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行我们最初编写的测试；它们应该能编译，并且应该全部成功。
- en: 'Run `DatabaseSpec` to be sure, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`DatabaseSpec`以确保，如下所示：
- en: '![](img/ad0b0d3f-4b0b-4c91-860c-9cb60c239412.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ad0b0d3f-4b0b-4c91-860c-9cb60c239412.png)'
- en: Our persistence layer is now ready to be used. We can deploy this layer on the
    cloud to make sure the deployment is working smoothly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据持久层现在已准备好使用。我们可以将这一层部署到云上，以确保部署工作顺利。
- en: Deploying the application
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署应用程序
- en: The server is running fine on our localhost, as this application is not doing
    much. This is the perfect time to perform all of the steps to deploy it. With
    each new feature, we are going to deploy it and get used to this process. This
    way, we can tackle the deployment issues little by little, instead of solving
    everything in one shot, usually under stress.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器在我们的本地主机上运行良好，因为这个应用没有做什么。这正是执行所有部署步骤的完美时机。随着每个新功能的加入，我们将部署它并熟悉这个过程。这样，我们可以逐步解决部署问题，而不是一次性解决所有问题，通常是在压力之下。
- en: We have decided to deploy this application on Heroku.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经决定在Heroku上部署这个应用。
- en: Heroku is a **P**latform as a Service (**PaaS**) that supports multiple languages,
    including Scala. Thanks to its simplicity and versatility, the deployment process
    is simple and smooth.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku是一个**平台即服务（PaaS**）平台，支持多种语言，包括Scala。由于其简单性和多功能性，部署过程简单且流畅。
- en: Setting up an account
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置账户
- en: The first thing to do is create an account on the Heroku platform. Heroku provides
    a free account, which is perfect for our usage.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的事情是在Heroku平台上创建一个账户。Heroku提供了一个免费账户，非常适合我们的使用。
- en: Go to the website ([https://www.heroku.com/](https://www.heroku.com/)) and sign
    up for a free account. You will receive an email from Heroku to validate your
    account and set up a password. As soon as you set up your password, you will land
    on a page to create a new application; this is exactly what we want to do.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 前往网站([https://www.heroku.com/](https://www.heroku.com/))并注册一个免费账户。您将收到来自Heroku的电子邮件以验证账户并设置密码。一旦您设置了密码，您将进入一个创建新应用的页面；这正是我们想要做的。
- en: Click on the Create New App button and pick an application name. This name needs
    to be unique, as it will be used in the URL to reach the application on the internet.
    I am using `shopping-fs`; feel free to pick the name you wish. The name should
    be unique. If it is not, an error will tell you to change the name.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 点击创建新应用按钮并选择一个应用名称。这个名称必须是唯一的，因为它将被用于在互联网上访问应用的URL。我使用的是`shopping-fs`；请随意选择您想要的名称。名称应该是唯一的。如果不是，错误信息会告诉您更改名称。
- en: Select the region closest to your location, and click on the Create App button.
    The creation of the application is instantaneous, and you will be redirected directly
    to your Dashboard, under the Deploy tab.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 选择离您位置最近的区域，然后点击创建应用按钮。应用的创建是瞬时的，您将被直接重定向到部署选项卡下的仪表板。
- en: Deploying your application
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署您的应用程序
- en: On the Heroku website, under the Deploy tab, at the bottom, you will see the
    instructions to deploy your application. The first thing to do is install the
    Heroku CLI; follow this link ([https://devcenter.heroku.com/articles/heroku-cli](https://devcenter.heroku.com/articles/heroku-cli))
    and pick your operating system to install the Heroku CLI.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在Heroku网站上的部署选项卡底部，您将看到部署应用的说明。首先要做的是安装Heroku CLI；遵循此链接([https://devcenter.heroku.com/articles/heroku-cli](https://devcenter.heroku.com/articles/heroku-cli))并选择您的操作系统来安装Heroku
    CLI。
- en: Once the CLI has been installed, go to IntelliJ and click on the Terminal tab
    located at the bottom of the window. IntelliJ will set the current path of the
    Terminal to the root path of the current project.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了CLI，前往IntelliJ并点击窗口底部的终端标签。IntelliJ会将终端的当前路径设置为当前项目的根路径。
- en: 'From inside the Terminal, log in to Heroku by using the following command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端内部，使用以下命令登录Heroku：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Type in your email address and password to log in.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 输入您的电子邮件地址和密码以登录。
- en: If you are on macOS and are using Keychain Access to generate and save the password,
    for some reason, the password generated upon sign up is not saved on Keychain.
    If this is the case, just log out from the Heroku dashboard, and, on the login
    form, click on Forgot Password. You'll receive an email to change your password.
    On that page, you can use the password generation, and Keychain will remember
    it!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have logged in, initialize Git with the following command:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, you will need to add the Heroku reference to Git, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Replace `shopping-fs` with the application name that you picked previously.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the following printed in your console:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s add the file and commit it locally in Git, as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The final step is to deploy it with the following command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The deployment is executed on the Heroku server, and the log of the server is
    printed to your local console.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'The process takes a little bit of time. Finally, you should see the following
    in the log:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That's it; your application has been compiled, packaged, and executed in the
    server.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s browse [https://shopping-fs.herokuapp.com/](https://shopping-fs.herokuapp.com/)
    to confirm it. The following page should appear:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cef031e8-e566-4715-ac40-c19f2afbf963.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You have deployed your application on the internet. Notice
    that your application can be reached for free on a secure HTTP protocol, with
    valid certificates.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Heroku configuration
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does Heroku know how to execute the application?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Heroku knows how to execute the application by reading the instructions from
    a file named `Procfile`, located at the root of the project; the content is as
    follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first indication in the line is the type of application. This can be anything.
    The `web` value is a special type, telling Heroku that this process only receives
    requests from HTTP.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The second part is the path to the executable. In fact, the SBT project creates
    this executable for us during the build process.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: The last part is a list of properties for the Play application, namely
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '`-Dhttp.port`, which sets the port to listen to by using the Heroku variable, `$PORT`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Dconfig.file`, which set the configuration file path to be used by the application.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we tackled the persistence layer. We created a simple model
    based on two tables, Cart and Product. We used an in-memory database named H2. We
    configured a framework named Slick to asynchrony access data from H2 and added
    a script to create the table and insert data on it. We went through the mechanism used
    by Play Evolution to create the database.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Tests have been written to define the behaviors of the cart and the product
    objects. As the data queries are done asynchrony, we spent time understanding
    how to deal with `Future`. Finally, we deployed this layer in the cloud using
    a cloud application service named Heroku.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to define a RESTful API to expose the data
    persisted in this chapter.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
