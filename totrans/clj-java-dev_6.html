<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;6.&#xA0;Concurrency" id="19UOO1-f3eee9b8c89a4c399520b72f8d890ddc"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06" class="calibre1"/>Chapter 6. Concurrency</h1></div></div></div><p class="calibre7">Programming has changed, in the past we could just rely on computers getting faster year after year. This is proving to be more and more difficult; so, hardware manufacturers are taking a different approach. Now, they are embedding more processors into computers. Nowadays, it's not uncommon to see phones with just or four cores.</p><p class="calibre7">This calls for a different way of writing software, one in which we are able to execute some tasks in other processes, explicitly. The modern languages are trying to make this task feasible and easier for modern developers, and Clojure is no exception.</p><p class="calibre7">In this chapter, we will see how Clojure enables you to write simple concurrent programs by reviewing Clojure's core concepts and primitives; in particular, we need to understand the concept of identity and value that Clojure has embedded into the language. In this chapter, we will cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Using your Java knowledge</li><li class="listitem">The Clojure model of state and identity</li><li class="listitem">Promises</li><li class="listitem">Futures</li><li class="listitem">Software transactional memory and refs</li><li class="listitem">Atoms</li><li class="listitem">Agents</li><li class="listitem">Validators</li><li class="listitem">Watchers</li></ul></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Concurrency" id="19UOO1-f3eee9b8c89a4c399520b72f8d890ddc">
<div class="book" title="Using your Java knowledge"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch06lvl1sec38" class="calibre1"/>Using your Java knowledge</h1></div></div></div><p class="calibre7">Knowing<a id="id196" class="calibre1"/> Java and your way around Java's threading APIs gives you a great advantage, since Clojure relies on the tools that you already know.</p><p class="calibre7">Here, you'll see how to use threads and you can extend everything you see here to execute other services.</p><p class="calibre7">Before going any further, let's create a new project that we'll use as a sandbox for all of our tests.</p><p class="calibre7">Create it, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00017.jpeg" alt="Using your Java knowledge" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Modify<a id="id197" class="calibre1"/> the <code class="email">clojure-concurrency.core</code> namespace, so that it looks similar to the following code snippet:</p><div class="informalexample"><pre class="programlisting">(ns clojure-concurrency.core)

(defn start-thread [func]
  (.start (Thread. func)))</pre></div><p class="calibre7">It's easy to understand what's happening here. We are creating a thread with our function and then starting it; so that we can use it in the REPL, as follows:</p><div class="mediaobject"><img src="../images/00018.jpeg" alt="Using your Java knowledge" class="calibre10"/></div><p class="calibre11"> </p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip18" class="calibre1"/>Tip</h3><p class="calibre7">
<code class="email">java.lang.Thread</code> has <a id="id198" class="calibre1"/>a constructor, which receives an object implementing the runnable interface. You can just pass a Clojure function because every function in Clojure implements runnable and callable interfaces. This means that you can also use the executors transparently in Clojure!</p></div><p class="calibre7">We'll see a <code class="email">nil</code> and <code class="email">Hello threaded world</code> values in any random order. The <code class="email">nil</code> value is what the start thread returns.</p><p class="calibre7">The <code class="email">Hello threaded world</code> is <a id="id199" class="calibre1"/>a message from another thread. With this, we now have the basic tools to get to know and understand how threads work in Clojure.</p></div></div>
<div class="book" title="The Clojure model of state and identity" id="1AT9A1-f3eee9b8c89a4c399520b72f8d890ddc"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec39" class="calibre1"/>The Clojure model of state and identity</h1></div></div></div><p class="calibre7">Clojure has <a id="id200" class="calibre1"/>very strong opinions about concurrency, in order to take it in a simpler way it redefines what state and identity mean. Let's explore the meaning of this concepts in Clojure.</p><p class="calibre7">When talking about state in Java, you probably think about the values of the attributes of your Java classes. The state in Clojure is similar to Java, it refers to the values of objects but there are very important differences that allow simpler concurrency.</p><p class="calibre7">In Clojure, identity<a id="id201" class="calibre1"/> is an <a id="id202" class="calibre1"/>entity that might have different values over time. Consider the following examples:</p><div class="book"><ul class="itemizedlist"><li class="listitem">I have an identity; I will be and continue being this particular individual, my opinions, ideas, and appearance might change over time but I am the same individual with the same identity.</li><li class="listitem">You have a bank account; it has a particular number and is run by a particular bank. The amount of money you have in it changes over time, but it is the same bank account.</li><li class="listitem">Consider a ticker symbol (such as GOOG), it identifies a stock in the stock market; the value associated with it changes over time, but not its identity.</li></ul></div><p class="calibre7">
<span class="strong"><strong class="calibre8">State</strong></span> is a <a id="id203" class="calibre1"/>value<a id="id204" class="calibre1"/> that an identity took at some point in time. One of its important features is that it is immutable. State is a snapshot of an identity's value at some given time.</p><p class="calibre7">So, in the previous examples:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Who you are right now, how you feel, how you look, and what you think is your current state</li><li class="listitem">The money you currently have in your bank account is its current state</li><li class="listitem">The value of the GOOG stock is its current state</li></ul></div><p class="calibre7">All of these states are immutable; it doesn't matter who you are tomorrow or how much you win or spend. It is true and it will always be true that in this particular moment in time you have a certain state.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip19" class="calibre1"/>Tip</h3><p class="calibre7">Rich Hickey, Clojure's author, is a great talker and has several talks in which he explains the ideas and philosophy behind Clojure. In one of them, (Are We There Yet?) he explains this idea of state, identity, and time very extensively.</p></div><p class="calibre7">Let's now explain the two key concepts in Clojure:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">Identity</strong></span>: Throughout<a id="id205" class="calibre1"/> your whole life, you have a single identity; you never stop being you, even if you keep changing throughout your whole life.</li><li class="listitem"><span class="strong"><strong class="calibre8">State</strong></span>: At <a id="id206" class="calibre1"/>any given moment in your life, you are a certain person with likes, dislikes, and some beliefs. We call this way of being at a moment of your life, the state. If you look at a particular moment in your life, you will see a fixed value. Nothing will change the fact that you were the way you were in that moment in time. That particular state is immutable; over time, you have different states or values, but each of those states is immutable.</li></ul></div><p class="calibre7">We use this fact to write simpler concurrent programs. Whenever you want to interact with an identity, you look at it and you get its current value (a snapshot at the time), and then you operate with what you have.</p><p class="calibre7">In imperative programming, you normally have a guarantee that you have the latest value but it is very difficult to keep it in a consistent state. The reason for this is that you are relying on a shared mutable state.</p><p class="calibre7">A shared mutable state is the reason why you need to use a synchronized code, locks, and mutexes. It is also the reason for very complex programs, with difficult bugs to track.</p><p class="calibre7">Nowadays, Java is learning the lessons from other programming languages and now it has primitives that allow simpler concurrent programming. These ideas are taken from other languages and newer ideas, so there is a good chance that someday you'll see similar concepts to what you'll study here in other mainstream programming languages.</p><p class="calibre7">There is no guarantee that you'll always have the latest value, but don't worry, you just have to think about things differently and use the concurrency primitives that Clojure gives you.</p><p class="calibre7">This is similar to how you work in real life, you don't know exactly what's happening with all of your friends or co-workers when you do something for them; you talk to them, get the current facts, and then go and get working. While you are at it, something needs to change; in this case we need a coordination mechanism.</p><p class="calibre7">Clojure has various such coordination mechanisms, let's have a look at them.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Promises" id="1BRPS1-f3eee9b8c89a4c399520b72f8d890ddc"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec40" class="calibre1"/>Promises</h1></div></div></div><p class="calibre7">If <a id="id207" class="calibre1"/>you are a full stack Java developer, there is a good chance that you have met promises in JavaScript.</p><p class="calibre7">Promises are simple abstractions that don't impose strict requirements on you; you can use them to calculate the result on some other thread, light process, or anything you like.</p><p class="calibre7">In Java, there are a couple of ways to achieve this; one of them is with futures (<code class="email">java.util.concurrentFuture</code>) and if you want something more similar to JavaScript's promise there is a nice implementation called <a id="id208" class="calibre1"/>
<span class="strong"><strong class="calibre8">jdeferred</strong></span> (<a class="calibre1" href="https://github.com/jdeferred/jdeferred">https://github.com/jdeferred/jdeferred</a>), which you might have used before.</p><p class="calibre7">In essence a promise is just a promise that you can give to your caller, the caller can use it at any given time. There are two possibilities:</p><div class="book"><ul class="itemizedlist"><li class="listitem">If the promise has already been fulfilled, the call returns immediately</li><li class="listitem">If not, the caller will block until the promise is fulfilled</li></ul></div><p class="calibre7">Let's take a look at an example; remember to use the start-thread function in the <code class="email">clojure-concurrency.core</code> package:</p><div class="mediaobject"><img src="../images/00019.jpeg" alt="Promises" class="calibre10"/></div><p class="calibre11"> </p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip20" class="calibre1"/>Tip</h3><p class="calibre7">Promises are only calculated once and then cached. So don't worry about using them as many times as you like once it has been calculated, there is no runtime cost associated!</p></div><p class="calibre7">Let's stop here and analyze the code, we are creating a promise called <code class="email">p</code> and then we start a thread that does two things.</p><p class="calibre7">It tries to get a value from <code class="email">p</code> (the <code class="email">deref</code> function tries to read the value from a promise) and then prints <code class="email">Hello world</code>.</p><p class="calibre7">We won't see the <code class="email">Hello world</code> message just yet; we will instead see a <code class="email">nil</code> value. Why is that?</p><p class="calibre7">The start thread returns the <code class="email">nil</code> value and what happens now is what we described in the first place; <code class="email">p</code> is the promise and our new thread will block it until it gets a value.</p><p class="calibre7">In order to see the <code class="email">Hello world</code> message, we need to deliver the promise. Let's do that now:</p><div class="mediaobject"><img src="../images/00020.jpeg" alt="Promises" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">As you can see, we now get the <code class="email">Hello world</code> message!</p><p class="calibre7">As I said, there<a id="id209" class="calibre1"/> is no need to use another thread. Let's now see another example in the REPL:</p><div class="mediaobject"><img src="../images/00021.jpeg" alt="Promises" class="calibre10"/></div><p class="calibre11"> </p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip21" class="calibre1"/>Tip</h3><p class="calibre7">You can use <code class="email">@p</code> instead of (<code class="email">deref p</code>), it works for every identity in this chapter too.</p></div><p class="calibre7">In this example we don't create separate threads; we create the promise, deliver it, and then use it in the same thread.</p><p class="calibre7">As you can see, promises are an extremely simple type of synchronization mechanism, you can decide whether to use threads, executor services (which are just thread pools), or some other mechanism, such as lightweight threads.</p><p class="calibre7">Let's have a look at Pulsar library for creating lightweight threads.</p></div>

<div class="book" title="Promises" id="1BRPS1-f3eee9b8c89a4c399520b72f8d890ddc">
<div class="book" title="Pulsar and lightweight threads"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec39" class="calibre1"/>Pulsar and lightweight threads</h2></div></div></div><p class="calibre7">Creating a thread is <a id="id210" class="calibre1"/>an expensive operation and it consumes RAM memory. To know how much memory creating a thread consumes in Mac OS X or Linux, run the next command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre8">java -XX:+PrintFlagsFinal -version | grep ThreadStackSize</strong></span>
</pre></div><p class="calibre7">What you <a id="id211" class="calibre1"/>see here will depend on the OS and JVM version that you are using, with Java 1.8u45 on Mac OS X, we get the following output:</p><div class="mediaobject"><img src="../images/00022.jpeg" alt="Pulsar and lightweight threads" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">I am getting a stack size of 1024 kilobytes per thread. What can we do to improve the numbers? Other languages, such as Erlang and Go create a few threads from the beginning and then execute their tasks using those threads. It becomes important to be able to suspend a particular task and run another in the same thread.</p><p class="calibre7">In Clojure there is a library<a id="id212" class="calibre1"/> called <span class="strong"><strong class="calibre8">Pulsar</strong></span> (<a class="calibre1" href="https://github.com/puniverse/pulsar">https://github.com/puniverse/pulsar</a>), which is an interface for a Java API called <a id="id213" class="calibre1"/>
<span class="strong"><strong class="calibre8">Quasar</strong></span> (<a class="calibre1" href="https://github.com/puniverse/quasar">https://github.com/puniverse/quasar</a>).</p><p class="calibre7">In order to support Pulsar, as of version 0.6.2, you need to do two things.</p><div class="book"><ul class="itemizedlist"><li class="listitem">Add the <code class="email">[co.paralleluniverse/pulsar "0.6.2"]</code> dependency to your project</li><li class="listitem">Add an instrumentation agent to your JVM (<code class="email">adding :java-agents [[co.paralleluniverse/quasar-core "0.6.2"]]</code> to your <code class="email">project.clj</code>)</li></ul></div><p class="calibre7">The instrumentation agent should be able to suspend functions in a thread and then change them for other functions. In the end, your <code class="email">project.clj</code> file should look similar to:</p><div class="informalexample"><pre class="programlisting"> (defproject clojure-concurrency "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
            :dependencies [[org.clojure/clojure "1.6.0"]
            [co.paralleluniverse/pulsar "0.6.2"]]
  :java-agents [[co.paralleluniverse/quasar-core "0.6.2"]])</pre></div><p class="calibre7">Let's write our<a id="id214" class="calibre1"/> last example with promises using Pulsar's lightweight threads called fibers.</p><p class="calibre7">Pulsar comes with<a id="id215" class="calibre1"/> its own promises in the <code class="email">co.paralleluniverse.pulsar.core</code> package and they can be used as a drop-in replacement for promises in <code class="email">clojure.core</code>:</p><div class="informalexample"><pre class="programlisting"> (clojure.core/use 'co.paralleluniverse.pulsar.core)
(def p1 (promise))
(def p2 (promise))
(def p3 (promise))
(spawn-fiber #(clojure.core/deliver p2 (clojure.core/+ @p1 5)))
(spawn-fiber #(clojure.core/deliver p3 (clojure.core/+ @p1 @p2)))
(spawn-thread #(println @p3))
(clojure.core/deliver p1 99)
;; 203</pre></div><p class="calibre7">This example is a bit more interesting, we use two of Pulsar's functions:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">spawn-fiber</code>: This<a id="id216" class="calibre1"/> function creates a light thread, you can create thousands of fibers if you want in a single program. They are cheap to create and as long as you program them carefully, there shouldn't be many problems coming from this.</li><li class="listitem"><code class="email">span-thread</code>: This<a id="id217" class="calibre1"/> is Pulsar's version of start-thread, it creates a real thread and runs it.</li></ul></div><p class="calibre7">In this particular example, we calculate <code class="email">p2</code> and <code class="email">p3</code> in two fibers and then <code class="email">p3</code> in a thread. At this point, everything is waiting for us to deliver the value of <code class="email">p1</code>; we do it with the <code class="email">deliver</code> function.</p><p class="calibre7">Pulsar has other very interesting features that allow for simpler parallel programming, have a look at the documentation if you are interested. In the last part of this chapter, we will have a look at <code class="email">core.async</code>. Pulsar has an interface modelled after <code class="email">core.async</code>, which you can use if you like.</p></div></div>
<div class="book" title="Futures" id="1CQAE1-f3eee9b8c89a4c399520b72f8d890ddc"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec41" class="calibre1"/>Futures</h1></div></div></div><p class="calibre7">If you have been <a id="id218" class="calibre1"/>using Java for a while, you might know the <code class="email">java.util.concurrent.Future</code> class, this is Clojure's implementation of futures and it is extremely similar to Java, only a bit simpler. Its interface and usage are almost identical to promises with a very important difference, when using futures everything will run in a different thread automatically.</p><p class="calibre7">Let's see a simple example using futures, in any REPL do the following:</p><div class="informalexample"><pre class="programlisting">(def f (future (Thread/sleep 20000) "Hello world"))
(println @f)</pre></div><p class="calibre7">Your REPL should freeze for 20 seconds and then print <code class="email">Hello world</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip22" class="calibre1"/>Tip</h3><p class="calibre7">Futures are also cached, so you only need to pay once for the cost of calculation and then you can use them any number of times you want.</p></div><p class="calibre7">At first glance, futures look much easier than promises. You don't need to worry about creating threads or fibers, but there are downsides to this approach:</p><div class="book"><ul class="itemizedlist"><li class="listitem">You have less flexibility; you can only run futures in a predefined thread pool.</li><li class="listitem">You should be careful if your futures take too much time, they could end up NOT running because the implicit thread pool has a number of threads available. If they are all busy some of your tasks will end up queued and waiting.</li></ul></div><p class="calibre7">
<code class="email">Futures</code> have their use cases, if you have very few processor intensive tasks, if you have IO bound tasks, maybe using promises with fibers is a good idea, since they allow you to keep your processor free to run more tasks concurrently.</p></div>
<div class="book" title="Software transactional memory and refs"><div class="book" id="1DOR02-f3eee9b8c89a4c399520b72f8d890ddc"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec42" class="calibre1"/>Software transactional memory and refs</h1></div></div></div><p class="calibre7">One of Clojure's most interesting <a id="id219" class="calibre1"/>features is <span class="strong"><strong class="calibre8">software transactional memory</strong></span> (<span class="strong"><strong class="calibre8">STM</strong></span>). It uses <a id="id220" class="calibre1"/>
<span class="strong"><strong class="calibre8">multiversion concurrency control</strong></span> (<span class="strong"><strong class="calibre8">MVCC</strong></span>), in a very similar fashion to how databases work, implementing a form of optimistic concurrency control.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note21" class="calibre1"/>Note</h3><p class="calibre7">MVCC is what databases use for transactions; what this means is that every operation within a transaction has its own copy of variables. After executing its operations, it checks if any of the used variables changed during the transaction and if they did the transaction fails. This is called optimistic concurrency control because we are optimistic and we don't lock any variable; we let every thread do its work thinking that it's going to work correctly and then check if it was correct. In practice, this allows for greater concurrency.</p></div><p class="calibre7">Let's start <a id="id221" class="calibre1"/>with the most obvious example, a bank account.</p><p class="calibre7">Let's write some code now, enter into the REPL and write:</p><div class="informalexample"><pre class="programlisting">(def account (ref 20000))
(dosync (ref-set account 10))
(deref account)

(defn test []
  (dotimes [n 5]
    (println n @account)
    (Thread/sleep 2000))
  (ref-set account 90))

(future (dosync (test)))
(Thread/sleep 1000)
(dosync (ref-set account 5))</pre></div><p class="calibre7">Try to write the future and the <code class="email">dosync</code> functions at the same time so you have the same results.</p><p class="calibre7">We have just three lines of code here but there are quite a few things happening.</p><p class="calibre7">First of all we define a <code class="email">ref (account)</code>; refs are the managed variables in transactions. They are also the first implementation we see of Clojure's identity idea. Note that the account is an identity now and it might take multiple values throughout its life.</p><p class="calibre7">We now modify its value, we do this within a transaction since refs cannot be modified outside of transactions; thus, the <code class="email">dosync</code> block.</p><p class="calibre7">In the end, we print the account and we can use (<code class="email">deref</code> account) or <code class="email">@account</code>, as we did for promises and futures.</p><p class="calibre7">Refs can be read from anywhere, there is no need for it to be within a transaction.</p><p class="calibre7">Let's look at something a little bit more interesting now, write or copy the next code into the REPL:</p><div class="informalexample"><pre class="programlisting">(def account (ref 20000))

(defn test []
  (println "Transaction started")
  (dotimes [n 5]
    (println n @account)
    (Thread/sleep 2000))
  (ref-set account 90))

(future (dosync (test)))
(future (dosync (Thread/sleep 4000) (ref-set account 5)))</pre></div><p class="calibre7">If everything goes well, you should have an output similar to the following screenshot:</p><div class="mediaobject"><img src="../images/00023.jpeg" alt="Software transactional memory and refs" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">This might <a id="id222" class="calibre1"/>seem a little strange, what is happening?</p><p class="calibre7">The first transaction starts its process using the current value for account, the other transaction then modifies the value of account before the first transaction is finished; Clojure realizes this and it restarts the first transaction.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip23" class="calibre1"/>Tip</h3><p class="calibre7">You shouldn't execute functions with side effects within transactions, as there is no guarantee that they will be executed only once. If you need to do something like that you should use an agent.</p></div><p class="calibre7">This is the first example of how a transaction works, but using <code class="email">ref-set</code> is not a good idea in general.</p><p class="calibre7">Let's take a look at another example, the classic example of moving money from an account <span class="strong"><em class="calibre9">A</em></span> to an account <span class="strong"><em class="calibre9">B</em></span>:</p><div class="informalexample"><pre class="programlisting">(def account-a (ref 10000))
(def account-b (ref 2000))
(def started (clojure.core/promise))

(defn move [acc1 acc2 amount]
  (dosync
    (let [balance1 @acc1
           balance2 @acc2]
      (println "Transaction started")
      (clojure.core/deliver started true)
      (Thread/sleep 5000)
      (when (&gt; balance1 amount)
        (alter acc1 - amount)
        (alter acc2 + amount))
      (println "Transaction finished"))))

(future (move account-a account-b 50))
@started
(dosync (ref-set account-a 20))</pre></div><p class="calibre7">This is a better <a id="id223" class="calibre1"/>example of how transactions work; you will probably see something similar to the following screenshot:</p><div class="mediaobject"><img src="../images/00024.jpeg" alt="Software transactional memory and refs" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">First of all, you need to understand how the <code class="email">alter</code> function works; it's simple and it receives:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The ref that it has to modify</li><li class="listitem">The function that it has to apply</li><li class="listitem">The extra arguments</li></ul></div><p class="calibre7">So this function:</p><div class="informalexample"><pre class="programlisting">(alter ref fun arg1 arg2)</pre></div><p class="calibre7">Is translated to something like this:</p><div class="informalexample"><pre class="programlisting">(ref-set ref (fun @ref arg1 arg2))</pre></div><p class="calibre7">This is the preferred way to modify the current value.</p><p class="calibre7">Let's see a step <a id="id224" class="calibre1"/>by step description of what's going on here:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">We define two accounts with a balance of 10000 and 2000.</li><li class="listitem" value="2">We try to move 500 units from the first account to the second but first we sleep for 5 seconds.</li><li class="listitem" value="3">We announce (using the promise) that we have started the transaction. The current thread moves on, since it was waiting for the started value.</li><li class="listitem" value="4">We set the balance of account-a to 20.</li><li class="listitem" value="5">The first transaction realizes that something has changed and restarts.</li><li class="listitem" value="6">The transaction goes on and is finished this time.</li><li class="listitem" value="7">Nothing happens, since the new balance is not enough to move 50 units.</li></ol><div class="calibre22"/></div><p class="calibre7">In the end, if you check the balance, like <code class="email">[@account-a @account-b]</code>, you will see that the first account has 20 and the second account has 2000.</p><p class="calibre7">There is another use case that you should take into account; let's check the following code:</p><div class="informalexample"><pre class="programlisting">(def account (ref 1000))
(def secured (ref false))
(def started (promise))

(defn withdraw [account amount secured]
  (dosync
    (let [secured-value @secured]
      (deliver started true)
      (Thread/sleep 5000)
      (println :started)
      (when-not secured-value
        (alter account - amount))
      (println :finished))))

(future (withdraw account 500 secured))
@started
(dosync (ref-set secured true))</pre></div><p class="calibre7">The idea is that if <code class="email">secured</code> is set to true, you shouldn't be able to withdraw any money.</p><p class="calibre7">If you run it and then check for the value of <code class="email">@account</code>, you'll see that even after changing the value of <code class="email">secured</code> to true a withdrawal occurs. Why is that?</p><p class="calibre7">The reason is that <a id="id225" class="calibre1"/>transactions only check for values that you modify within a transaction or values that you read; here we are reading the secured value before the modification, so the transaction doesn't fail. We can tell the transaction to be a little bit more careful by using the following code:</p><div class="informalexample"><pre class="programlisting"> (ensure secured)
;; instead of
@secured


(def account (ref 1000))
(def secured (ref false))
(def started (promise))

(defn withdraw [account amount secured]
  (dosync
    (let [secured-value (ensure secured)]
      (deliver started true)
      (Thread/sleep 5000)
      (println :started)
      (when-not secured-value
        (alter account - amount))
      (println :finished))))

(future (withdraw account 500 secured))
@started
(dosync (ref-set secured true))</pre></div><p class="calibre7">Here almost the same thing happened. What is the difference?</p><p class="calibre7">There is one subtle difference, the second transaction can't finish until the first transaction is done. If you look at it in detail, you will notice that you can't modify the secured value until after the other transaction runs.</p><p class="calibre7">This is similar to a lock; not the best idea but useful in some cases.</p></div>
<div class="book" title="Atoms" id="1ENBI1-f3eee9b8c89a4c399520b72f8d890ddc"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec43" class="calibre1"/>Atoms</h1></div></div></div><p class="calibre7">We <a id="id226" class="calibre1"/>have now seen how promises, futures, and transactions work in Clojure. We'll now see atoms.</p><p class="calibre7">Even though STM is very useful and powerful you'll see that in practice it is not very commonly used.</p><p class="calibre7">Atoms<a id="id227" class="calibre1"/> are one of Clojure's workhorses, when it comes to concurrent programming.</p><p class="calibre7">You can think of atoms as transactions that modify one single value. You might be thinking, what good is that? Imagine you had lots of events that you want to store in a single vector. If you are used to Java, you probably know that using a <code class="email">java.util.ArrayList</code> package is bound to have problems; since, you are almost surely going to lose data.</p><p class="calibre7">In that case, you probably want to use a class from the <code class="email">java.util.concurrent</code> package, how can you guarantee that you'll have no data loss in Clojure?</p><p class="calibre7">It's easy, atoms come to the rescue! Let's try this piece of code:</p><div class="informalexample"><pre class="programlisting">(clojure.core/use 'co.paralleluniverse.pulsar.core)
(def events (atom []))
(defn log-events [count event-id]
  (dotimes [_ count]
    (swap! events conj event-id)))
(dotimes [n 5]
  (spawn-fiber #(log-events 500 n)))</pre></div><p class="calibre7">We are again using Pulsar and its lightweight threads. Here, we define an events atom and a <code class="email">log-events</code> function.</p><p class="calibre7">The <code class="email">log-events</code> execute a <code class="email">swap!</code> a given number of times.</p><p class="calibre7">
<code class="email">Swap!</code> is similar to the <code class="email">alter</code> function it receives:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The atom that it should modify</li><li class="listitem">The function that it applies to the atom</li><li class="listitem">The extra arguments</li></ul></div><p class="calibre7">In this case, it gives the atom the new value that comes from:</p><div class="informalexample"><pre class="programlisting">(conj events event-id)</pre></div><p class="calibre7">We then spawn five fibers, each fiber adds 500 events to the events atom.</p><p class="calibre7">After running this, we can check for the number of events from each fiber like this:</p><div class="informalexample"><pre class="programlisting">(count (filter #(= 0 %) @events))
;; 500
(count (filter #(= 1 %) @events))
;; 500
(count (filter #(= 2 %) @events))
;; 500
(count (filter #(= 3 %) @events))
;; 500
(count (filter #(= 4 %) @events))
;; 500</pre></div><p class="calibre7">As you can see, we<a id="id228" class="calibre1"/> have 500 elements from each fiber with no data loss and using Clojure's default data structures. There is no need to use special data structures for each use case, locks, or mutexes. This allows for greater concurrency.</p><p class="calibre7">When you modify an atom, you need to wait for the operation to be complete meaning it is synchronous.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Agents" id="1FLS41-f3eee9b8c89a4c399520b72f8d890ddc"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec44" class="calibre1"/>Agents</h1></div></div></div><p class="calibre7">What if <a id="id229" class="calibre1"/>you don't care about the result of some operation? You just need to fire something and then forget it. In that case agents are what you need.</p><p class="calibre7">Agents also run in separate thread pools, there are two functions that you can use to fire an agent:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">send</code>: This executes your function in an implicit thread pool</li><li class="listitem"><code class="email">send-off</code>: This tries to execute your function in a new thread but there's a change, it will reuse another thread</li></ul></div><p class="calibre7">Agents are the way to go if you want to cause side effects in a transaction; since, they will only be executed after the transaction has completed successfully.</p><p class="calibre7">They work in a very simple manner, here is an example usage:</p><div class="informalexample"><pre class="programlisting">(def agt (agent 0))
(defn sum [&amp; nums]
  (Thread/sleep 5000)
  (println :done)
  (apply + nums))
(send agt sum 10) ;; You can replace send with send-off
                  ;; if you want this to be executed in a different thread
@agt</pre></div><p class="calibre7">If you copy and paste the exact previous code you will see a <code class="email">0</code> and then a <code class="email">:done</code> message, if you check for the value of <code class="email">@agt</code>, then you will see the value <code class="email">10</code>.</p><p class="calibre7">Agents are a good way to execute a given task and modify some value in a different thread with simpler semantics than those of futures or manually modifying values in another thread.</p></div>

<div class="book" title="Agents" id="1FLS41-f3eee9b8c89a4c399520b72f8d890ddc">
<div class="book" title="Validators"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec40" class="calibre1"/>Validators</h2></div></div></div><p class="calibre7">We<a id="id230" class="calibre1"/> have seen the primary concurrency primitives now, let's see some utilities that apply to all of them at once.</p><p class="calibre7">We can define a validator that checks if the new value of some function is desirable or not; you can use them for refs, atoms, agents, and even vars.</p><p class="calibre7">The <code class="email">validator</code> function must receive a single value and return true if the new value is valid or false otherwise.</p><p class="calibre7">Let's create a simple <code class="email">validator</code> that checks if the new value is lower than <code class="email">5</code>:</p><div class="informalexample"><pre class="programlisting">(def v (atom 0))
(set-validator! v #(&lt; % 5))
(swap! v + 10)

;; IllegalStateException Invalid reference state  clojure.lang.ARef.validate (ARef.java:33)</pre></div><p class="calibre7">We get an exception. The reason is that the new value (<code class="email">10</code>) is not valid.</p><p class="calibre7">You can add <code class="email">4</code> without a problem:</p><div class="informalexample"><pre class="programlisting">(swap! v + 4)
;; 4</pre></div><p class="calibre7">Be careful with the validator and agents, since you will probably not know when an exception occurred:</p><div class="informalexample"><pre class="programlisting">(def v (agent 0))
(set-validator! v #(&lt; % 5))
(swap! v + 10)
;; THERE IS NO EXCEPTION</pre></div></div></div>

<div class="book" title="Agents" id="1FLS41-f3eee9b8c89a4c399520b72f8d890ddc">
<div class="book" title="Watchers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec41" class="calibre1"/>Watchers</h2></div></div></div><p class="calibre7">Similar <a id="id231" class="calibre1"/>to validators, there are also watchers. Watchers are functions that are executed whenever Clojure's identities get a new value. An important question is the thread in which watchers run. Watchers run in the same thread as the watched entity (if you add a watcher to an agent it will be run in the agent's thread), it will be run before the agent code executes, so you should be careful and use the old-value new-value instead of reading the value with <code class="email">deref</code>:</p><div class="informalexample"><pre class="programlisting">(def v (atom 0))
(add-watch v :sample (fn [k i old-value new-value] (println (= i v) k old-value new-value)))
(reset! v 5)</pre></div><p class="calibre7">The <code class="email">add-watch</code> function receives:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The ref, atom, agent, or var that should be watched</li><li class="listitem">A key that will be passed to the watcher function</li><li class="listitem">A function with four parameters: the key, the reference itself, the old value, and the new value</li></ul></div><p class="calibre7">After <a id="id232" class="calibre1"/>executing the previous code we get:</p><div class="informalexample"><pre class="programlisting">true :sample 0 5</pre></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="core.async"><div class="book" id="1GKCM2-f3eee9b8c89a4c399520b72f8d890ddc"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec45" class="calibre1"/>core.async</h1></div></div></div><p class="calibre7">The <code class="email">core.async</code> is yet<a id="id233" class="calibre1"/> another way of programming concurrently; it uses the idea of lightweight threads and channels to communicate between them.</p></div>

<div class="book" title="core.async">
<div class="book" title="Why lightweight threads?"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec42" class="calibre1"/>Why lightweight threads?</h2></div></div></div><p class="calibre7">The <a id="id234" class="calibre1"/>lightweight threads are used in languages, such as go and Erlang. They excel in being able to run thousands of threads in a single process.</p><p class="calibre7">What is the<a id="id235" class="calibre1"/> difference between the lightweight threads and traditional threads?</p><p class="calibre7">The traditional threads need to reserve memory. This also takes some time. If you want to create a couple of thousand threads, you will be using a noticeable amount of memory for each thread; asking the kernel to do that also takes time.</p><p class="calibre7">What is the difference with lightweight threads? To have a couple of hundred lightweight threads, you only need to create a couple of threads. There is no need to reserve memory and lightweight threads are a mere software idea.</p><p class="calibre7">This can be achieved with most languages and Clojure is adding first class support (without changing the language this is part of the Lisp power) with using <code class="email">core.async</code>! Let's have a look at how it works.</p><p class="calibre7">There are two concepts that you need to keep in mind:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">Goblocks</strong></span>: They <a id="id236" class="calibre1"/>are the lightweight threads.</li><li class="listitem"><span class="strong"><strong class="calibre8">Channels</strong></span>: Channels <a id="id237" class="calibre1"/>are a way to communicate between goblocks, you can think of them as queues. Goblocks can publish a message to the channel and other goblocks can take a message from them. Just as there are integration patterns for queues, there are integration patterns for channels and you will find concepts similar to broadcasting, filtering, and mapping.</li></ul></div><p class="calibre7">Now, let's play a little with each of them so you can understand better how to use them for our program.</p></div></div>

<div class="book" title="core.async">
<div class="book" title="Goblocks"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec43" class="calibre1"/>Goblocks</h2></div></div></div><p class="calibre7">You <a id="id238" class="calibre1"/>will find <a id="id239" class="calibre1"/>goblocks in the <code class="email">clojure.core.async</code> namespace.</p><p class="calibre7">Goblocks are extremely easy to use, you need the go macro and you will do something similar to this:</p><div class="informalexample"><pre class="programlisting">(ns test
  (:require [clojure.core.async :refer [go]]))

(go
  (println "Running in a goblock!"))</pre></div><p class="calibre7">They are similar to threads; you just need to remember that you can create goblocks freely. There can be thousands of running goblocks in a single JVM.</p></div></div>

<div class="book" title="core.async">
<div class="book" title="Channels"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch06lvl2sec44" class="calibre1"/>Channels</h2></div></div></div><p class="calibre7">You<a id="id240" class="calibre1"/> can <a id="id241" class="calibre1"/>actually use anything you like to communicate between goblocks, but it is recommended that you use channels.</p><p class="calibre7">Channels have two main operations: putting and getting. Let's check how to do it:</p><div class="informalexample"><pre class="programlisting"> (ns test
  (:require [clojure.core.async :refer [go chan &gt;! &lt;!]]))

(let [c (chan)]
  (go (println (str "The data in the channel is" (&lt;! c))))
  (go (&gt;! c 6)))</pre></div><p class="calibre7">That's it!! It looks pretty simple, as you can see there are three main functions that we are using with channels:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">chan</code>: This <a id="id242" class="calibre1"/>function creates a channel and the channels can store some messages in a buffer. If you want this functionality, you should just pass the size of the buffer to the <code class="email">chan</code> function. If no size is specified, the channel can store only one message.</li><li class="listitem"><code class="email">&gt;!</code>: The <a id="id243" class="calibre1"/>put function must be used within a goblock; it receives a channel and the value you want to publish to it. This function blocks, if a channel's buffer is already full. It will block until something is consumed from the channel.</li><li class="listitem"><code class="email">&lt;!</code>: This <a id="id244" class="calibre1"/>takes function; this function must be used within a goblock. It receives the channel you are taking from. It is blocking and if you haven't published something in the channel it will park until there's data available.</li></ul></div><p class="calibre7">There are lots of other functions that you can use with channels, for now let's add two related functions that you will probably use soon:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">&gt;!!</code>: The <a id="id245" class="calibre1"/>blocking put, works exactly the same as the <code class="email">put</code> function; except it can be used from anywhere. Note that if a channel cannot take more data, this function will block the entire thread from where it runs.</li><li class="listitem"><code class="email">&lt;!!</code>: The <a id="id246" class="calibre1"/>blocking works exactly the same as the <code class="email">take</code> function, except you can use this from anywhere and not just from inside goblocks. Just keep in mind that this blocks the thread where it runs until there's data available.</li></ul></div><p class="calibre7">If you <a id="id247" class="calibre1"/>look into the <code class="email">core.async</code> API docs (<a class="calibre1" href="http://clojure.github.io/core.async/">http://clojure.github.io/core.async/</a>) you will find a fair amount of functions.</p><p class="calibre7">Some of them look similar to the functions that give you functionalities similar to queues, let's take a look at the <code class="email">broadcast</code> function:</p><div class="informalexample"><pre class="programlisting">(ns test
  (:require [clojure.core.async.lab :refer [broadcast]]
            [clojure.core.async :refer [chan &lt;! &gt;!! go-loop]])

(let [c1 (chan 5)
      c2 (chan 5)
      bc (broadcast c1 c2)]
  (go-loop []
    (println "Getting from the first channel" (&lt;! c1))
    (recur))
  (go-loop []
    (println "Getting from the second channel" (&lt;! C2))
    (recur))
  (&gt;!! bc 5)
  (&gt;!! bc 9))</pre></div><p class="calibre7">With this you can publish it to several channels at the same time, this is helpful if you want to subscribe multiple processes to a single source of events with a great amount of separation of concern.</p><p class="calibre7">If you take a good look, you will also find familiar functions over there: <code class="email">map</code>, <code class="email">filter</code>, and <code class="email">reduce</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note22" class="calibre1"/>Note</h3><p class="calibre7">Depending on the version of <code class="email">core.async</code>, some of these functions might not be there anymore.</p></div><p class="calibre7">Why are these functions there? Those functions are meant to modify collections of data, right?</p><p class="calibre7">The reason is that there has been a good amount of effort towards using channels as higher-level abstractions.</p><p class="calibre7">The idea is <a id="id248" class="calibre1"/>to see channels as collections of events, if you think of them that way it's easy to see that you can create a new channel by mapping every element of an old channel or you can create a new channel by filtering away some elements.</p><p class="calibre7">In recent versions of Clojure, the abstraction has become even more noticeable with transducers.</p></div></div>

<div class="book" title="core.async">
<div class="book" title="Transducers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch06lvl2sec45" class="calibre1"/>Transducers</h2></div></div></div><p class="calibre7">Transducers<a id="id249" class="calibre1"/> are a way to separate the computations from the input source. Simply, they are a way to apply a sequence of steps to a sequence or a channel.</p><p class="calibre7">Let's look at an example of a sequence:</p><div class="informalexample"><pre class="programlisting">(let [odd-counts (comp (map count)
                       (filter odd?))
      vs [[1 2 3 4 5 6]
          [:a :c :d :e]
          [:test]]]
  (sequence odd-counts vs))</pre></div><p class="calibre7">The <code class="email">comp</code> feels similar to the threading macros, it composes functions and stores the steps of the computation.</p><p class="calibre7">The interesting part is that we can use the same odd-counts transformation with a channel, such as:</p><div class="informalexample"><pre class="programlisting">(let [odd-counts (comp (map count)
                       (filter odd?))
      input (chan)
      output (chan 5 odd-counts)]
  (go-loop []
    (let [x (&lt;! output)]
      (println x))
      (recur))
  (&gt;!! input [1 2 3 4 5 6])
  (&gt;!! input [:a :c :d :e])
  (&gt;!! input [:test]))</pre></div></div></div>
<div class="book" title="Summary" id="1HIT81-f3eee9b8c89a4c399520b72f8d890ddc"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec46" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">We have checked the core Clojure mechanisms for concurrent programming, as you can see, they feel natural and they build on already existing paradigms, such as immutability. The most important idea is what an identity and value is; we now know that we can have the following values as identifiers:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Refs</li><li class="listitem">Atoms</li><li class="listitem">Agents</li></ul></div><p class="calibre7">We can also get the snapshot of their value with the defer function or the <code class="email">@</code> shortcut.</p><p class="calibre7">If we want to use something a little more primitive, we can use promises or futures.</p><p class="calibre7">We have also seen how to use threads, or Pulsar's fibers. Most of Clojure's primitives aren't specific to some concurrency mechanism, so we can use any parallel programming mechanism with any type of Clojure primitive.</p></div></body></html>