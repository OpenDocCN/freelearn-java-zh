<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Application Packaging and Deployment</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Creating a Spring Boot executable JAR</li>
<li>Creating Docker images</li>
<li>Building self-executing binaries</li>
<li>Spring Boot environment configuration, hierarchy, and precedence</li>
<li>Adding a custom PropertySource to the environment using EnvironmentPostProcessor</li>
<li>Externalizing an environmental configuration using property files</li>
<li>Externalizing an environmental configuration using environment variables</li>
<li>Externalizing an environmental configuration using Java system properties</li>
<li>Externalizing an environmental configuration using JSON</li>
<li>Setting up Consul</li>
<li>Externalizing an environmental configuration using Consul and envconsul</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>What good is an application unless it is being used? In today's day and age—when DevOps has become the way of doing software development, when the cloud is the king, and when building microservices is considered the thing to do—a lot of attention is being focused on how applications get packaged, distributed, and deployed in their designated environments.</p>
<p>The Twelve-Factor App methodology has played an instrumental role in defining how a modern <strong>Software as a Service</strong> (<strong>SaaS</strong>) application is supposed to be built and deployed. One of the key principles is the separation of environmental configuration definitions from the application and storage of this in the environments. The Twelve-Factor App methodology also favors the isolation and bundling of the dependencies, development versus production parity, and ease of deployment and disposability of the applications, among other things.</p>
<div class="packt_infobox">The Twelve-Factor App methodology can be found at <a href="http://12factor.net/"><span class="URLPACKT">http://12factor.net/</span></a>.</div>
<p>The DevOps model also encourages us to have complete ownership of our application, starting from writing and testing the code all the way to building and deploying it. If we are to assume this ownership, we need to ensure that the maintenance and overhead costs are not excessive and won't take away much time from our primary task of developing new features. This can be achieved by having clean, well-defined, and isolated deployable artifacts, which are self-contained, self-executed, and can be deployed in any environment without having to be rebuilt.</p>
<p>The following recipes will walk us through all the necessary steps to achieve the goal of low-effort deployment and maintenance while having clean and elegant code behind it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a Spring Boot executable JAR</h1>
                </header>
            
            <article>
                
<p>The Spring Boot magic would not be complete without providing a nice way to package the entire application including all of its dependencies, resources, and so on in one composite, executable JAR file. After the JAR file is created, it can simply be launched by running a <kbd>java -jar &lt;name&gt;.jar</kbd> command.</p>
<p>We will continue with the application code that we built in the previous chapters and will add the necessary functionalities to package it. Let's go ahead and take a look at how to create the Spring Boot Uber JAR.</p>
<div class="packt_infobox">The Uber JAR is typically known as an application bundle encapsulated in a single composite JAR file that internally contains a <kbd>/lib</kbd> directory with all the dependent inner jars and optionally a <kbd>/bin</kbd> directory with the executables.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Let's go to our code directory from <a href="1136c424-e79e-467a-8f7f-8af2099306d7.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Application Testing</em>, and execute <kbd>./gradlew clean build</kbd></li>
<li>With the Uber JAR built, let's launch the application by executing <kbd>java -jar build/libs/ch6-0.0.1-SNAPSHOT.jar</kbd></li>
<li>This will result in our application running in the JAR file with the following console output:</li>
</ol>
<pre style="padding-left: 60px">    <strong>  .   ____          _            __ _ _</strong>
    <strong> /\ / ___'_ __ _ _(_)_ __  __ _    </strong>
    <strong>( ( )___ | '_ | '_| | '_ / _` |    </strong>
    <strong> \/  ___)| |_)| | | | | || (_| |  ) ) ) )</strong>
    <strong>  '  |____| .__|_| |_|_| |___, | / / / /</strong>
    <strong> =========|_|==============|___/=/_/_/_/</strong>
    <strong> :: Spring Boot ::  (v2.0.0.BUILD-SNAPSHOT)</strong>
    <strong>...</strong>
    <strong>(The rest is omitted for conciseness)</strong>
    <strong>...</strong>
    <strong>2017-12-17 INFO: Registering beans for JMX exposure on startup</strong>
    <strong>2017-12-17 INFO: Tomcat started on port(s): 8080 (http) 8443  <br/>    (https)</strong>
    <strong>2017-12-17 INFO: Welcome to the Book Catalog System!</strong>
    <strong>2017-12-17 INFO: BookRepository has 1 entries</strong>
    <strong>2017-12-17 INFO: ReviewerRepository has 0 entries</strong>
    <strong>2017-12-17 INFO: PublisherRepository has 1 entries</strong>
    <strong>2017-12-17 INFO: AuthorRepository has 1 entries</strong>
    <strong>2017-12-17 INFO: Started BookPubApplication in 12.156 seconds (JVM <br/>    running for 12.877)</strong>
    <strong>2017-12-17 INFO: Number of books: 1</strong>
  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As you can see, getting the packaged executable JAR file is fairly straightforward. All the magic is already coded and provided to us as part of the Spring Boot Gradle plugin. The addition of the plugin adds a number of tasks, which allow us to package the Spring Boot application, run it and build the JAR, TAR, WAR files, and so on. For example, the <kbd>bootRun</kbd> task, which we have been using throughout this book, is provided by the Spring Boot Gradle plugin, among others. We can see a complete list of the available Gradle tasks by executing <kbd>./gradlew tasks</kbd>. When we run this command, we will get the following output:</p>
<pre>    <strong>------------------------------------------------------------</strong>
    <strong>All tasks runnable from root project</strong>
    <strong>------------------------------------------------------------</strong>
    
    <strong>Application tasks</strong>
    <strong>-----------------</strong>
    <strong>bootRun - Run the project with support for auto-detecting main <br/>    class and reloading static resources</strong>
    <strong>run - Runs this project as a JVM application</strong>
    
    <strong>Build tasks</strong>
    <strong>-----------</strong>
    <strong>assemble - Assembles the outputs of this project.</strong>
    <strong>bootJar - Assembles an executable jar archive containing the main <br/>    classes and their dependencies.</strong>
    <strong>build - Assembles and tests this project.</strong>
    <strong>buildDependents - Assembles and tests this project and all projects <br/>    that depend on it.</strong>
    <strong>buildNeeded - Assembles and tests this project and all projects it <br/>    depends on.</strong>
    <strong>classes - Assembles classes 'main'.</strong>
    <strong>clean - Deletes the build directory.</strong>
    <strong>jar - Assembles a jar archive containing the main classes.</strong>
    <strong>testClasses - Assembles classes 'test'.</strong>
    
    <strong>Build Setup tasks</strong>
    <strong>-----------------</strong>
    <strong>init - Initializes a new Gradle build. [incubating]</strong>
    
    <strong>Distribution tasks</strong>
    <strong>------------------</strong>
    <strong>assembleBootDist - Assembles the boot distributions</strong>
    <strong>assembleDist - Assembles the main distributions</strong>
    <strong>bootDistTar - Bundles the project as a distribution.</strong>
    <strong>bootDistZip - Bundles the project as a distribution.</strong>
    <strong>distTar - Bundles the project as a distribution.</strong>
    <strong>distZip - Bundles the project as a distribution.</strong>
    <strong>installBootDist - Installs the project as a distribution as-is.</strong>
    <strong>installDist - Installs the project as a distribution as-is.</strong>      </pre>
<p>The preceding output is not complete; I've excluded the non-relevant task groups such as IDE, documentation, and so on, but you will see them on your console. In the task list, we will see tasks such as <kbd>bootRun</kbd>, <kbd>bootJar</kbd>, and others. These tasks have been added by the Spring Boot Gradle plugin and executing them gets the required Spring Boot steps added to the build pipeline. You can see the actual task dependency if you execute <kbd>./gradlew tasks --all</kbd>, which will not only print the visible tasks, but also the depended, internal tasks, and the task dependencies. For example, when we were running the <kbd>build</kbd> task, all the following dependent tasks were executed as well:</p>
<pre>    <strong>build - Assembles and tests this project. [assemble, check]</strong>
    <strong>assemble - Assembles the outputs of this project. [bootJar, <br/>    distTar, distZip, jar]</strong>
  </pre>
<p>You can see that the <kbd>build</kbd> task will execute the <kbd>assemble</kbd> task, which in turn will call <kbd>bootJar</kbd>, where the creation of the Uber JAR is actually taking place.</p>
<p>The plugin also provides a number of very useful configuration options. While I am not going to go into detail about all of them, I'll mention the two that I find very useful:</p>
<pre style="padding-left: 30px">bootJar { 
  classifier = 'exec' 
  baseName = 'bookpub' 
} </pre>
<p>This configuration allows us to specify the executable JAR file <kbd>classifier</kbd>, along with the JAR <kbd>baseName</kbd>, allowing for having the regular JAR contain just the application code and the executable JAR with the <kbd>classifier</kbd> in the name, <kbd>bookpub-0.0.1-SNAPSHOT-exec.jar</kbd>.</p>
<p>Another useful configuration option allows us to specify which dependency JARs require unpacking because, for some reason, they can't be included as nested inner JARs. This comes in very handy when you need something to be available in the system <kbd>Classloader</kbd> such as setting a custom <kbd>SecurityManager</kbd> via the startup system properties:</p>
<pre style="padding-left: 30px">bootJar { 
  requiresUnpack = '**/some-jar-name-*.jar' 
} </pre>
<p>In this example, the contents of the <kbd>some-jar-name-1.0.3.jar</kbd> dependency will be unpacked into a temporary folder on a filesystem when the application is launched.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating Docker images</h1>
                </header>
            
            <article>
                
<p>Docker, Docker, Docker! I hear this phrase more and more in all the conferences and tech meetups that I have attended. The arrival of Docker has been welcomed by the community with open arms and it has instantly become a hit. The Docker ecosystem has been rapidly expanding with many other companies providing services, support, and complementing frameworks such as <strong>Apache Mesos</strong>, Amazon Elastic Beanstalk, ECS, and Kubernetes, just to name a few. Even Microsoft is providing Docker support in their Azure Cloud Service and is partnering with Docker to bring Docker to Windows operating system.</p>
<p>The reason for Docker's overwhelming popularity lies in its ability to package and deploy applications in a form of self-contained containers. The containers are more lightweight than the traditional full-blown virtual machines. Multiple numbers of them can be run on top of a single OS instance, thus increasing the number of applications that can be deployed on the same hardware compared to traditional VMs.</p>
<p>In this recipe, we will take a look at what it would take to package our Spring Boot application as a Docker image and how to deploy and run it.</p>
<p>Building a Docker image and just running it on your development machine is doable, but not as much fun as being able to share it with the world. You will need to publish it somewhere for it to be deployable, especially if you are thinking of using it with Amazon or some other cloud-like environment. Luckily, Docker provides us with not only the container solution, but also with a repository service, Docker Hub, located at <span class="URLPACKT"><a href="https://hub.docker.com">https://hub.docker.com</a>,</span> where we can create repositories and publish our Docker images. So think of it like Maven Central for Docker.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>The first step will be to create an account on Docker Hub so that we can publish our images. Go to <a href="https://hub.docker.com"><span class="URLPACKT">https://hub.docker.com</span></a> and create an account. You can also use your GitHub account and log in using it if you have one.</li>
<li>Once you have an account, we will need to create a repository named <kbd>springbootcookbook</kbd>.</li>
<li>With this account created, now is the time to build the image. For this, we will use one of the Gradle Docker plugins. We will start by changing <kbd>build.gradle</kbd> to modify the <kbd>buildscript</kbd> block with the following change:</li>
</ol>
<pre style="padding-left: 60px">buildscript { 
  dependencies { 
    classpath("org.springframework.boot:spring-boot-gradle- 
      plugin:${springBootVersion}") 
    classpath("se.transmode.gradle:gradle-docker:1.2") 
  } 
} </pre>
<ol start="4">
<li>We will also need to apply this plugin by adding the <kbd>apply plugin: 'docker'</kbd> directive to the <kbd>build.gradle</kbd> file.</li>
<li>We also need to explicitly add the <kbd>application</kbd> plugin to <kbd>build.gradle</kbd> as well, since it is no longer automatically included by the Spring Boot Gradle plugin.</li>
<li>Add <kbd>apply plugin: 'application'</kbd> to the list of plugins in the <kbd>build.gradle</kbd> file.</li>
<li>Lastly, we will need to add the following Docker configuration to the <kbd>build.gradle</kbd> file as well:</li>
</ol>
<pre style="padding-left: 60px">task distDocker(type: Docker,  
                overwrite: true,  
                dependsOn: bootDistTar) { 
    group = 'docker' 
    description = "Packs the project's JVM application<br/>    as a Docker image." 
 
    inputs.files project.bootDistTar 
    def installDir = "/" + project.bootDistTar.archiveName  
                         - ".${project.bootDistTar.extension}" 
 
    doFirst { 
        tag "ch6" 
        push false 
        exposePort 8080 
        exposePort 8443 
        addFile file("${System.properties['user.home']}<br/>        /.keystore"), "/root/" 
        applicationName = project.applicationName 
        addFile project.bootDistTar.outputs.files.singleFile 
 
        entryPoint = ["$installDir/bin/${project.applicationName}"] 
    } 
} </pre>
<ol start="8">
<li>Assuming that you already have Docker installed on your machine, we can proceed to creating the image by executing <kbd>./gradlew clean distDocker</kbd>.</li>
</ol>
<ol start="9">
<li>For Docker installation instructions, please visit the tutorial that is located at <a href="https://docs.docker.com/installation/#installation">https://docs.docker.com/installation/#installation</a>. If everything has worked out correctly, you should see the following output:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; Task :distDocker</strong><br/><strong>Sending build context to Docker daemon  68.22MB
  Step 1/6 : FROM aglover/java8-pier
   ---&gt; 3f3822d3ece5
  Step 2/6 : EXPOSE 8080
   ---&gt; Using cache
   ---&gt; 73717aaca6f3
  Step 3/6 : EXPOSE 8443
   ---&gt; Using cache
   ---&gt; 6ef3c0fc3d2a
  Step 4/6 : ADD .keystore /root/
   ---&gt; Using cache
   ---&gt; 6efebb5a868b
  Step 5/6 : ADD ch6-boot-0.0.1-SNAPSHOT.tar /
   ---&gt; Using cache
   ---&gt; 0634eace4952
  Step 6/6 : ENTRYPOINT /ch6-boot-0.0.1-SNAPSHOT/bin/ch6
   ---&gt; Using cache
   ---&gt; 39a853b7ddbb
  Successfully built 39a853b7ddbb
  Successfully tagged ch6:0.0.1-SNAPSHOT
    
    
  BUILD SUCCESSFUL<br/>  Total time: 1 mins 0.009 secs.
    
  </strong></pre>
<ol start="10">
<li>We can also execute the following Docker images command so as to see the newly created image:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ docker images</strong>
<strong>REPOSITORY           TAG                IMAGE ID         CREATED             VIRTUAL  SIZE</strong>
<strong>ch6                  0.0.1-SNAPSHOT     39a853b7ddbb     17 minutes ago      1.04 GB</strong>
<strong>aglover/java8-pier   latest             69f4574a230e     11 months ago       1.01 GB</strong></pre>
<ol start="11">
<li>With the image built successfully, we are now ready to start it in Docker by executing the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>docker run -d -P ch6:0.0.1-SNAPSHOT.</strong>  </pre>
<ol start="12">
<li>After the container has started, we can query the Docker registry for the port bindings so that we can access the HTTP endpoints for our service. This can be done via the <kbd>docker ps</kbd> command. If the container is running successfully, we should see the following result (names and ports will vary):</li>
</ol>
<pre style="padding-left: 60px">    <strong>CONTAINER ID        IMAGE               COMMAND               <br/>    CREATED             STATUS              PORTS                                                  <br/>    NAMES</strong>
    <strong>37b37e411b9e        ch6:latest         "/ch6-boot-0.0.1-S..." <br/>    10 minutes ago      Up 10 minutes       0.0.0.0:32778-<br/>    &gt;8080/tcp,      0.0.0.0:32779-&gt;8443/tcp   drunk_carson</strong>
  </pre>
<ol start="13">
<li>From this output, we can tell that the port mapping for the internal port <kbd>8080</kbd> has been set up to be <kbd>32778</kbd> (your port will vary for every run). Let's open <kbd>http://localhost:32778/books</kbd> in the browser to see our application in action, as shown in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/425c27f4-c4c1-4e8e-876e-c45ddf26145f.png"/></div>
<div class="mce-root packt_infobox"><span>If you are using macOS X with</span> <kbd>boot2docker</kbd><span>, then you won't be running the Docker container locally. In this scenario, you will be using the</span> <kbd>boot2docker <span>ip</span></kbd> <span>instead of the local host to connect to the application. For more tips on how to make the <kbd>boot2docker</kbd> integration easier, please visit</span> <a href="http://viget.com/extend/how-to-use-docker-on-os-x-the-missing-guide"><span>http://viget.com/extend/how-to-use-docker-on-os-x-the-missing-guide</span></a>. One can also use a nice Docker façade, generously created by Ian Sinnott, which will automatically start boot2docker and handle the environment variables as well. To get the wrapper, go to <a href="https://gist.github.com/iansinnott/0a0c212260386bdbfafb">https://gist.github.com/iansinnott/0a0c212260386bdbfafb</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In the preceding example, we saw how easy it is to have our <kbd>build</kbd> package the application in a Docker container. The additional Gradle-Docker plugin does the bulk of the work of the <kbd>Dockerfile</kbd> creation, image building, and publishing; all we have to do is give it some instructions on what and how we want the image to be. Because the Spring Boot Gradle plugin uses a <kbd>boot</kbd> distribution, the Gradle-Docker plugin does not know that it needs to use a bootified TAR archive. To help with that, we override the <kbd>distDocker</kbd> task. Let's examine these instructions in detail:</p>
<ul>
<li>The <kbd>group</kbd> and <kbd>description</kbd> attributes merely help with displaying the task properly when the <kbd>./gradlew tasks</kbd> command is executed.</li>
<li>The <kbd>inputs.files project.bootDistTar</kbd> directive is very important. This is what instructs the <kbd>distDocker</kbd> task to use the TAR archive created by the Spring Boot distribution, instead of the generic one.</li>
<li>The <kbd>def installDir = "/" + project.bootDistTar.archiveName - ".${project.bootDistTar.extension}"</kbd> directive is creating a variable, containing the directory where the untarred artifacts will be placed inside the Docker container.</li>
<li>The <kbd>exposePort</kbd> directive tells the plugin to add an <kbd>EXPOSE &lt;port&gt;</kbd> instruction to the Dockerfile so that when our container is started, it will expose these internal ports to the outside via port mapping. We saw this mapping while running the <kbd>docker ps</kbd> command.</li>
<li>The <kbd>addFile</kbd> directive tells the plugin to add an <kbd>ADD &lt;src&gt; &lt;dest&gt;</kbd> instruction to the Dockerfile so that when the container is being built, we will copy the file from the source filesystem in the filesystem in the container image. In our case, we will need to copy the <kbd>.keystore</kbd> certificate file that we configured in one of our previous recipes for the HTTPS connector, which we instructed in <kbd>tomcat.https.properties</kbd> to be loaded from <kbd>${user.home}/.keystore</kbd>. Now, we need it to be in the <kbd>/root/ directory</kbd> directory as, in the container, our application will be executed under the root. (This can be changed with more configurations.)</li>
</ul>
<div class="mce-root packt_infobox">The Gradle-Docker plugin uses the project name as a name for the image by default. The project name, in turn, is being inferred by Gradle from the project's directory name, unless an explicit property value is configured. As the code example is for <a href="c2ad0549-f6af-458f-8043-3fb5227a1e50.xhtml">Chapter 6</a>, <em>Application Packaging and Deployment</em> the project directory is named <kbd>ch6</kbd>, thus the name of the image. The project name can be explicitly configured by adding <kbd>name='some_project_name'</kbd> in <kbd>gradle.properties</kbd>.</div>
<p>If you look at the resulting Dockerfile, which can be found in the <kbd>build/docker/</kbd> directory at the root of the project, you will see the following two instructions:</p>
<pre style="padding-left: 60px">ADD ch6-boot-0.0.1-SNAPSHOT.tar / 
ENTRYPOINT ["/ch6-boot-0.0.1-SNAPSHOT/bin/ch6"] </pre>
<p>The <kbd>ADD</kbd> instruction adds the TAR application archive that was produced by the <kbd>bootDistTar</kbd> task and contains our application bundled up as a tarball. We can even see the contents of the produced tarball by executing <kbd>tar tvf build/distributions/ch6-boot-0.0.1-SNAPSHOT.tar</kbd>. During the building of the container, the contents of the TAR file will be extracted in the <kbd>/</kbd> directory in the container and later used to launch the application.</p>
<p>It is followed by the <kbd>ENTRYPOINT</kbd> instruction. This tells Docker to execute <kbd>/ch6-boot-0.0.1-SNAPSHOT/bin/ch6</kbd>, which we saw as part of the tarball content, once the container is started, thus automatically launching our application.</p>
<p>The first line in the Dockerfile, which is <kbd>FROM aglover/java8-pier</kbd>, is the instruction to use the <kbd>aglover/java8-pier</kbd> image, which contains the Ubuntu OS with Java 8 installed as a base image for our container, on which we will install our application. This image comes from the Docker Hub Repository and is automatically used by the plugin, but can be changed via the configuration settings, if so desired.</p>
<p>If you created an account on Docker Hub, we can also publish the created Docker image to the registry. As fair warning, the resulting image could be many hundreds of megabytes in size so uploading it could take some time. To publish this image, we will need to change the tag to <kbd>tag "&lt;docker hub username&gt;/&lt;docker hub repository name&gt;"</kbd> and add the <kbd>push true</kbd> setting to the <kbd>distDocker</kbd> task definition in <kbd>build.gradle</kbd>:</p>
<pre style="padding-left: 60px">task distDocker(type: Docker,  
                overwrite: true,  
                dependsOn: bootDistTar) { 
    ... 
    doFirst { 
        tag "&lt;docker hub username&gt;/&lt;docker hub repository name&gt;" 
        push true 
        ... 
    } 
} </pre>
<p>The <kbd>tag</kbd> property sets up the created image tag and, by default, the plugin assumes that it is residing in the Docker Hub Repository. This is where it will be publishing it if the <kbd>push</kbd> configuration is set to <kbd>true</kbd>, as it is in our case.</p>
<div class="packt_infobox">For a complete list of all the Gradle-Docker plugin configuration options, take a look at the <a href="https://github.com/Transmode/gradle-docker"><span class="URLPACKT">https://github.com/Transmode/gradle-docker</span></a> GitHub project page.</div>
<p>When launching a Docker image, we use the <kbd>-d</kbd> and <kbd>-P</kbd> command-line arguments. Their uses are as follows:</p>
<ul>
<li><kbd>-d</kbd>: This argument indicates the desire to run the container in a detached mode where the process starts in the background</li>
<li><kbd>-P</kbd>: This argument instructs Docker to publish all the internally exposed ports to the outside so that we can access them</li>
</ul>
<div class="mce-root packt_infobox"><span>For a detailed explanation of all the possible command-line options, refer to</span> <a href="https://docs.docker.com/engine/reference/commandline/cli/"><span>https://docs.docker.com/reference/commandline/cli/</span></a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building self-executing binaries</h1>
                </header>
            
            <article>
                
<p>As of Spring Boot version 1.3, the Gradle and Maven plugins support the option of generating true executable binaries. These look like normal JAR files, but have the content of JAR fused together with the launch script that contains the command-building logic and is capable of self-starting itself without the need to execute the <kbd>java -jar file.jar</kbd> command explicitly. This capability comes in very handy as it allows for the easy configuration of Linux autostart services such as <kbd>init.d</kbd> or <kbd>systemd</kbd>, and <kbd>launchd</kbd> on macOS X.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>For this recipe, we will use our existing application build. We will examine how the self-starting executable JAR files get created and how to modify the default launch script to add support for the custom JVM start up arguments, such as the <kbd>-D</kbd> start up system properties, JVM memory, Garbage Collection, and other settings.</p>
<p>For this recipe, make sure that <kbd>build.gradle</kbd> is using Spring Boot version 2.0.0 or above. If it is not, then change the following setting in the <kbd>buildscript</kbd> configuration block:</p>
<pre style="padding-left: 60px">ext { 
  springBootVersion = '2.0.0.BUILD-SNAPSHOT' 
} </pre>
<p>The same upgrade of the Spring Boot version should be done in the <kbd>db-counter-starter/build.gradle</kbd> file as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Building a default self-executing JAR file is very easy; actually, it is done automatically once we execute the <kbd>./gradlew clean bootJar</kbd> command.</li>
<li>We can proceed to launch the created application simply by invoking <kbd>./build/libs/bookpub-0.0.1-SNAPSHOT.jar</kbd>.</li>
</ol>
<ol start="3">
<li>In an enterprise environment, it is rare that we are satisfied with the default JVM launch arguments as we often need to tweak the memory settings, GC configurations, and even pass the startup system properties in order to ensure that we are using the desired version of the XML parser or a proprietary implementation of class loader or security manager. To accomplish those needs, we will modify the default <kbd>launch.script</kbd> file to add support for the JVM options. Let's start by copying the default <kbd>launch.script</kbd> file from the <span class="URLPACKT"><a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-tools/spring-boot-loader-tools/src/main/resources/org/springframework/boot/loader/tools/launch.script">https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-tools/spring-boot-loader-tools/src/main/resources/org/springframework/boot/loader/tools/launch.script</a></span> Spring Boot GitHub repository in the root of our project.</li>
</ol>
<p>The <kbd>launch.script</kbd> file is supported only on Linux and OS X environments. If you are looking to make self-executing JARs for Windows, you will need to provide your own <kbd>launch.script</kbd> file that is tailored for the Windows shell command execution. The good news is that it is the only special thing that is required; all the instructions and concepts in this recipe will work just fine on Windows as well, provided that the compliant <kbd>launch.script</kbd> template is being used.</p>
<ol start="4">
<li>We will modify the copied <kbd>launch.script</kbd> file and add the following content right above the <em>line 142</em> mark (this is showing only the relevant part of the script so as to condense the space):</li>
</ol>
<pre style="padding-left: 60px">...<br/># Find Java<br/>if [[ -n "$JAVA_HOME" ]] &amp;amp;&amp;amp; [[ -x "$JAVA_HOME/bin/java" ]]; then<br/>javaexe="$JAVA_HOME/bin/java"<br/>elif type -p java 2&gt;&amp;amp;1&gt; /dev/null; then<br/>javaexe=java<br/>elif [[ -x "/usr/bin/java" ]]; then<br/>javaexe="/usr/bin/java"<br/>else<br/>echo "Unable to find Java"<br/>exit 1<br/>fi<br/># Configure JVM Options<br/>jvmopts="{{jvm_options:}}"<br/>arguments=(-Dsun.misc.URLClassPath.disableJarChecking=true $jvmopts $JAVA_OPTS -jar $jarfile $RUN_ARGS "$@")<br/># Action functions<br/>start() {<br/>...</pre>
<ol start="5">
<li>With the custom <kbd>launch.script</kbd> file in place, we will need to add the options setting to our <kbd>build.gradle</kbd> file with the following content:</li>
</ol>
<pre style="padding-left: 60px">applicationDefaultJvmArgs = [ 
    "-Xms128m", 
    "-Xmx256m" 
] 
 
bootJar { 
    classifier = 'exec' 
    baseName = 'bookpub' 
    launchScript { 
        script = file('launch.script') 
        properties 'jvm_options' : applicationDefaultJvmArgs.join(' ') 
    } 
} </pre>
<ol start="6">
<li>We are now ready to launch our application. First, let's use the <kbd>./gradlew clean bootRun</kbd> command, and if we look at the JConsole VM Summary tab, we will see that our arguments indeed have been passed to the JVM, as follows:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/dd0b250c-6176-4663-9d7f-d74644feb2fe.png"/></div>
</li>
<li>We can also build the self-starting executable JAR by running the <kbd>./gradlew clean bootJar</kbd> command and then executing <kbd>./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar</kbd> in order to launch our application. We should expect to see a similar result in JConsole.</li>
</ol>
<ol start="8">
<li>Alternatively, we can also use the <kbd>JAVA_OPTS</kbd> environment variable to override some of the JVM arguments. Say we want to change the minimum memory heap size to 128 megabytes. We can launch our application using the <kbd>JAVA_OPTS=-Xmx128m ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar</kbd> command and this would show us the following effect in JConsole:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/20ed07bc-00c6-490b-89c5-9d1e20772536.png" style="text-align: center;color: black;font-size: 1em"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>With a small customization to <kbd>launch.script</kbd>, we were able to create a self-executing deployable application, packaged as a self-contained JAR file, which on top of everything else can also be configured in order to be launched using the various OS-specific autostarting frameworks.</p>
<p>The Spring Boot Gradle and Maven plugins provide us with lots of options for parameter customization and even an ability to embed mustache-like template placeholders in <kbd>launch.script</kbd>, which can later be replaced with values during build time. We have leveraged this capability to inject our JVM arguments into the file using the <kbd>launchScript{properties}</kbd> configuration setting.</p>
<p>In our custom version of <kbd>launch.script</kbd>, we added the <kbd>jvmopts="{{jvm_options:}}"</kbd> line, which will be replaced with the value of the <kbd>jvm_options</kbd> parameter during the build and packaging time. This parameter is declared in our <kbd>build.gradle</kbd> file as a value of the <kbd>launchScript.properties</kbd> argument <kbd>: launchScript{properties 'jvm_options' : applicationDefaultJvmArgs.join(' ')}</kbd>.</p>
<p>The JVM arguments can be hardcoded, but it is much better to maintain consistency between how our application starts using the <kbd>bootRun</kbd> task and how it starts when launched from the self-executing JAR. To achieve this, we will use the same <kbd>applicationDefaultJvmArgs</kbd> collection of arguments that we will define for the <kbd>bootRun</kbd> execution purpose, only with all the different arguments collapsed in a single line of text separated by white spaces. Using this approach, we have to define the JVM arguments only once and use them in both modes of execution.</p>
<div class="packt_infobox">It is important to notice that this reuse also applies to the application distributions that are built using the <kbd>distZip</kbd> and <kbd>distTar</kbd> tasks defined by Gradle's <kbd>application</kbd> plugin, as well as Spring Boot Gradle's <kbd>bootDistZip</kbd> and <kbd>bootDistTar</kbd>.</div>
<p>We can modify the build to create the Docker image by launching our self-executing JAR instead of the contents of the TAR file produced by the <kbd>distTar</kbd> task by default. To do this, we will need to change our <kbd>distDocker</kbd> configuration block using the following code:</p>
<pre style="padding-left: 30px">task distDocker(type: Docker, overwrite: true, <br/>                dependsOn: bootJar) { 
  ... 
  inputs.files project.bootJar 
  doFirst { 
    ... 
    addFile file("${System.properties['user.home']}/.keystore"), <br/>       "/root/" 
    applicationName = project.applicationName 
    addFile project.bootJar.outputs.files.singleFile 
 
    def executableName = "/" + <br/>       project.bootJar.outputs.files.singleFile.name 
    entryPoint = ["$executableName"] 
  } 
} </pre>
<p>This will make our <kbd>distDocker</kbd> task put the executable jar inside a Docker image instead of a TAR archive.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Boot environment configuration, hierarchy, and precedence</h1>
                </header>
            
            <article>
                
<p>In the previous few recipes, we looked at how to package our application in a variety of ways and how it can be deployed. The next logical step is the need to configure the application in order to provide some behavioral control as well as some environment-specific configuration values, which could and most likely will vary from environment to environment.</p>
<p>A common example of such an environmental configuration difference is the database setup. We certainly don't want to connect to a production environment database with an application running on our development machine. There are also cases where we want an application to run in different modes or use a different set of profiles, as they are referred to by Spring. An example could be running an application in live or simulator mode.</p>
<p>For this recipe, we will pick up from the previous state of the code base and add the support for different configuration profiles as well as examine how to use the property values as placeholders in other properties.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>We will start by adding an <kbd>@Profile</kbd> annotation to the <kbd>@Bean</kbd> creation of <kbd>schedulerRunner</kbd> by changing the definition of the <kbd>schedulerRunner(...)</kbd> method in <kbd>BookPubApplication.java</kbd>, located in the <kbd>src/main/java/org/test/bookpub</kbd> directory at the root of our project, to the following content:</li>
</ol>
<pre style="padding-left: 60px">@Bean 
@Profile("logger") 
public StartupRunner schedulerRunner() { 
    return new StartupRunner(); 
} </pre>
<ol start="2">
<li>Start the application by running <kbd>./gradlew clean bootRun</kbd>.</li>
<li>Once the application is running, we should no longer see the previous log output from the <kbd>StartupRunner</kbd> class, which looked like this:</li>
</ol>
<pre style="padding-left: 60px"><strong>2017-12-17 --- org.test.bookpub.StartupRunner : Number of books: 1</strong></pre>
<ol start="4">
<li>Now, let's build the application by running <kbd>./gradlew clean bootJar</kbd> and start it by running <kbd>./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger</kbd>; we will see the log output line show up again.</li>
<li>Another functionality that is enabled by the profile selector is the ability to add profile-specific property files. Let's create an <kbd>application-inmemorydb.properties</kbd> file in the <kbd>src/main/resources</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">spring.datasource.url = jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE </pre>
<ol start="6">
<li>Let's build the application by running <kbd>./gradlew clean bootJar</kbd> and start it by running <kbd>./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger,inmemorydb</kbd>, which will use the <kbd>inmemorydb</kbd> profile configuration in order to use the in-memory database instead of the file-based one.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we experimented with using profiles and applying additional configuration settings based on the active profiles. Profiles were first introduced in Spring Framework 3.2 and were used to conditionally configure the beans in context, depending on which profiles were active. In Spring Boot, this facility was extended even further to allow configuration separation as well.</p>
<p>By placing an <kbd>@Profile("logger")</kbd> annotation on our <kbd>StartupRunner@Bean</kbd> creation method, Spring will be instructed to create the bean only if the logger profile has been activated. Conventionally, this is done by passing the <kbd>--spring.profiles.active</kbd> option in the command line during the application startup. In the tests, another way that this can be done is using the <kbd>@ActiveProfiles("profile")</kbd> annotation on the <kbd>Test</kbd> class, but it is not supported for the execution of a normal application. It is also possible to negate profiles such as <kbd>@Profile("!production")</kbd>. When such an annotation is used (with <kbd>!</kbd> marking the negation), the bean will be created only if no profile production is active.</p>
<p>During startup, Spring Boot treats all the options that get passed via the command line as application properties, and thus anything that gets passed during startup ends up as a property value that is capable of being used. This same mechanism not only works for new properties but can be used as a way of overriding the existing properties as well. Let's imagine a situation where we already have an active profile defined in our <kbd>application.properties</kbd> file that looks like this: <kbd>spring.profiles.active=basic</kbd>. By passing the <kbd>--spring.profiles.active=logger</kbd> option via the command line, we will replace the active profile from <kbd>basic</kbd> to <kbd>logger</kbd>. If we want to include some profiles regardless of the active configuration, Spring Boot gives us a <kbd>spring.profiles.include</kbd> option to configure. Any profiles that are set up this way will be added to the list of active profiles.</p>
<p>As these options are nothing more than regular Spring Boot application properties, they all follow the same hierarchy for override precedence. The options have been outlined as follows:</p>
<ul>
<li><strong>Command-line arguments</strong>: These values supersede every other property source in the list, and you can always rest assured that anything passed via <kbd>--property.name=value</kbd> will take precedence over the other means.</li>
<li><strong>JNDI attributes</strong>: They are the next in precedence priority. If you are using an application container that provides data via a JNDI <kbd>java:comp/env</kbd> namespace, these values will override all the other settings from below.</li>
<li><strong>Java system properties</strong>: These values are another way to pass the properties to the application either via the <kbd>-Dproperty=name</kbd> command-line arguments or by calling <kbd>System.setProperty(...)</kbd> in the code. They provide another way to replace the existing properties. Anything coming from <kbd>System.getProperty(...)</kbd> will win over the others in the list.</li>
<li><strong>OS environment variables</strong>: Whether from Windows, Linux, OS X, or any other, they are a common way to specify a configuration, especially for locations and values. The most notable one is <kbd>JAVA_HOME</kbd>, which is a common way to indicate where the JVM location resides in the filesystem. If neither of the preceding settings are present, the <kbd>ENV</kbd> variables will be used for the property values instead of the ones mentioned as follows:</li>
</ul>
<div class="mce-root packt_infobox"><span>As the OS environment variables typically don't support dots (</span><kbd>.</kbd><span>) or dashes (</span><kbd>-</kbd><span>), Spring Boot provides an automatic remapping mechanism that replaces the underscores (</span><kbd>_</kbd><span>) with dots (</span><kbd>.</kbd><span>) during the property evaluation; it also handles the case conversion. Thus,</span> <kbd><span>JAVA_HOME</span></kbd> <span>becomes synonymous with</span> <kbd><span>java.home</span></kbd>.</div>
<ul>
<li><kbd>random.*</kbd>: This provides special support for the random values of primitive types that can be used as placeholders in configuration properties. For example, we can define a property named <kbd>some.number=${random.int}</kbd> where <kbd>${random.int}</kbd> will be replaced by some random integer value. The same goes for <kbd>${random.value}</kbd> for textual values and <kbd>${random.long}</kbd> for longs.</li>
<li><kbd>application-{profile}.properties</kbd>: They are the profile-specific files that get applied only if a corresponding profile gets activated.</li>
<li><kbd>application.properties</kbd>: They are the main property files that contain the base/default application configuration. Similar to the profile-specific ones, these values can be loaded from the following list of locations, with the top one taking priority over the lower entries:
<ul>
<li><kbd>file:config/</kbd>: This is a <kbd>/config</kbd> directory located in the current directory:</li>
<li><kbd>file:</kbd>: This is the current directory</li>
<li><kbd>classpath:/config</kbd>: This is a <kbd>/config</kbd> package in the classpath</li>
<li><kbd>classpath:</kbd>: This is a root of the classpath</li>
</ul>
</li>
<li><strong>@Configuration annotated classes annotated with @PropertySource</strong>: These are any in-code property sources that have been configured using annotations. We have seen an example of such usage the <em>Adding custom connectors</em> recipe from <span class="ChapterrefPACKT"><a href="f10744d1-32d1-4047-a3a6-df7e9a3ede92.xhtml">Chapter 3</a>, <em>Web Framework Behavior Tuning</em></span>. They are very low in the precedence chain and are only preceded by the default properties.</li>
<li><strong>Default properties</strong>: They are configured via the <kbd>SpringApplication.setDefaultProperties(...)</kbd> call and are seldom used, as it feels very much like hardcoding values in code instead of externalizing them in configuration files.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a custom PropertySource to the environment using EnvironmentPostProcessor</h1>
                </header>
            
            <article>
                
<p>In cases where the enterprise is already using a particular configuration system, custom written or off the shelf, Spring Boot provides us with a facility to integrate this into the application via the creation of a custom <kbd>PropertySource</kbd> implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's imagine that we have an existing configuration setup that uses a popular Apache Commons Configuration framework and stores the configuration data in XML files:</p>
<ol>
<li>To mimic our supposed pre-existing configuration system, add the following content to the dependencies section in the <kbd>build.gradle</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">dependencies { 
  ... 
  compile project(':db-count-starter') 
  compile("commons-configuration:commons-<br/>     configuration:1.10") 
  compile("commons-codec:commons-codec:1.6") 
  compile("commons-jxpath:commons-jxpath:1.3") 
  compile("commons-collections:commons-collections:3.2.1") 
  runtime("com.h2database:h2") 
  ... 
} </pre>
<ol start="2">
<li>Follow this up by creating a simple configuration file named <kbd>commons-config.xml</kbd> in the <kbd>src/main/resources</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="ISO-8859-1" ?&gt; 
&lt;config&gt; 
  &lt;book&gt; 
    &lt;counter&gt; 
      &lt;delay&gt;1000&lt;/delay&gt; 
      &lt;rate&gt;${book.counter.delay}0&lt;/rate&gt; 
    &lt;/counter&gt; 
  &lt;/book&gt; 
&lt;/config&gt; </pre>
<ol start="3">
<li>Next, we will create the <kbd>PropertySource</kbd> implementation file named <kbd>ApacheCommonsConfigurationPropertySource.java</kbd> in the <kbd>src/main/java/org/test/bookpub</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">public class ApacheCommonsConfigurationPropertySource <br/>   extends EnumerablePropertySource&lt;XMLConfiguration&gt; { 
  private static final Log logger = LogFactory.getLog(<br/>   ApacheCommonsConfigurationPropertySource.class); 
 
  public static final String <br/>     COMMONS_CONFIG_PROPERTY_SOURCE_NAME = "commonsConfig"; 
 
  public ApacheCommonsConfigurationPropertySource(<br/>     String name, XMLConfiguration source) { 
    super(name, source); 
  } 
 
  @Override 
  public String[] getPropertyNames() { 
    ArrayList&lt;String&gt; keys = <br/>       Lists.newArrayList(this.source.getKeys()); 
    return keys.toArray(new String[keys.size()]); 
  } 
 
  @Override 
  public Object getProperty(String name) { 
    return this.source.getString(name); 
  } 
 
  public static void addToEnvironment(<br/>     ConfigurableEnvironment environment, XMLConfiguration <br/>       xmlConfiguration) { 
    environment.getPropertySources().addAfter(<br/>      StandardEnvironment.<br/>        SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, new <br/>          ApacheCommonsConfigurationPropertySource( 
           COMMONS_CONFIG_PROPERTY_SOURCE_NAME, 
             xmlConfiguration)); 
    logger.trace("ApacheCommonsConfigurationPropertySource <br/>      add to Environment"); 
  } 
} </pre>
<ol start="4">
<li>We will now create the <kbd>EnvironmentPostProcessor</kbd> implementation class so as to bootstrap our <kbd>PropertySource</kbd> named <kbd>ApacheCommonsConfigurationEnvironmentPostProcessor.java</kbd> in the <kbd>src/main/java/org/test/bookpub</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">package com.example.bookpub;<br/><br/>import org.apache.commons.configuration.ConfigurationException;<br/>import org.apache.commons.configuration.XMLConfiguration;<br/>import org.springframework.boot.SpringApplication;<br/>import org.springframework.boot.env.EnvironmentPostProcessor;<br/>import org.springframework.core.env.ConfigurableEnvironment;<br/><br/>public class ApacheCommonsConfigurationEnvironmentPostProcessor  
       implements EnvironmentPostProcessor {<br/><br/>    @Override<br/>    public void postProcessEnvironment( 
                   ConfigurableEnvironment environment,  
                   SpringApplication application) {<br/>        try {<br/>            ApacheCommonsConfigurationPropertySource 
               .addToEnvironment(environment,<br/>                    new XMLConfiguration("commons- 
                                         config.xml"));<br/>        } catch (ConfigurationException e) {<br/>            throw new RuntimeException("Unable to load commons-config.xml", e);<br/>        }<br/>    }<br/>} </pre>
<ol start="5">
<li>Finally, we will need to create a new directory named <kbd>META-INF</kbd> in the <kbd>src/main/resources</kbd> directory at the root of our project and create a file named <kbd>spring.factories</kbd> in it with the following content:</li>
</ol>
<pre style="padding-left: 60px"># Environment Post Processors<br/>org.springframework.boot.env.EnvironmentPostProcessor=\<br/>com.example.bookpub.ApacheCommonsConfigurationEnvironmentPostProcessor </pre>
<ol start="6">
<li>With the setup done, we are now ready to use our new properties in our application. Let's change the configuration of the <kbd>@Scheduled</kbd> annotation for our <kbd>StartupRunner</kbd> class located in the <kbd>src/main/java/org/test/bookpub</kbd> directory at the root of our project, as follows:</li>
</ol>
<pre style="padding-left: 60px">@Scheduled(initialDelayString = "${book.counter.delay}", <br/>   fixedRateString = "${book.counter.rate}") </pre>
<ol start="7">
<li>Let's build the application by running <kbd>./gradlew clean bootJar</kbd> and start it by running <kbd>./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger</kbd> in order to ensure that our <kbd>StartupRunner</kbd> class is still logging the book count every ten seconds, as expected.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we have explored how to add our own custom <kbd>PropertySource</kbd> that allowed us to bridge the existing system in the Spring Boot environment. Let's look into the inner workings of how the pieces fit together.</p>
<p>In the previous section, we learned how the different configuration definitions stacked up and what rules were used to overlay them on top of each other. This will help us to better understand how the bridging of an Apache Commons Configuration, using a custom <kbd>PropertySource</kbd> implementation, works. (This should not be confused with an <kbd>@PropertySource</kbd> annotation!)</p>
<p>In <a href="6139967b-794e-479a-8461-d3197eb0322e.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>Writing Custom Spring Boot Starters</em>, we learned about the use of <kbd>spring.factories</kbd>, and so we already know that this file serves to define the classes that should automatically be incorporated by Spring Boot during application startup. The only difference this time is that instead of configuring the <kbd>EnableAutoConfiguration</kbd> settings, we will configure the <kbd>SpringApplicationRunListener</kbd> ones.</p>
<p>We created the following two classes to support our needs:</p>
<ul>
<li><kbd>ApacheCommonsConfigurationPropertySource</kbd>: This is the extension of the <kbd>EnumerablePropertySource</kbd> base class that provides you with internal functionality in order to bridge XMLConfiguration from Apache Commons Configuration to the world of Spring Boot by providing transformation to get the specific property values by name via the <kbd>getProperty(String name)</kbd> implementation, and the list of all the supported property names via the <kbd>getPropertyNames()</kbd> implementation. In situations where you are dealing with the use case when the complete list of the available property names is not known or is very expensive to compute, you can just extend the <kbd>PropertySource</kbd> abstract class instead of using <kbd>EnumerablePropertySource</kbd>.</li>
<li><kbd>ApacheCommonsConfigurationEnvironmentPostProcessor</kbd>: This is the implementation of the <kbd>EnvironmentPostProcessor</kbd> interface that gets instantiated by Spring Boot during the application startup and receives notification callback after the initial environment initialization has been completed, but before the application context startup. This class is configured in <kbd>spring.factories</kbd> and is automatically created by Spring Boot.</li>
</ul>
<p>In our post-processor, we implement the <kbd>postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application)</kbd> method, which gives us access to the <kbd>ConfigurableEnvironment</kbd> instance. By the time this callback is invoked, we will get an environment instance that has already been populated with all of the properties from the preceding hierarchy. However, we will get the opportunity to inject our own <kbd>PropertySource</kbd> implementation anywhere in the list, which we will successfully do in the <kbd>ApacheCommonsConfigurationPropertySource.addToEnvironment(...)</kbd> method.</p>
<p>In our case, we will choose to insert our source right below <kbd>systemEnvironment</kbd> in the order of precedence, but if needs be, we can alter this order to whatever highest precedence we desire. Just be careful not to place it so high that your properties become impossible to override via the command-line arguments, system properties, or environment variables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Externalizing an environmental configuration using property files</h1>
                </header>
            
            <article>
                
<p>The previous recipe taught us about the application properties and how they are provisioned. As was mentioned at the beginning of this chapter, during application deployment, it is almost inevitable to have some property values that are environment dependant. They can be database configurations, service topologies, or even simple feature configurations where something might be enabled in development but not quite ready for production just yet.</p>
<p>In this recipe, we will learn how to use an externally residing properties file for an environment-specific configuration, which might reside in the local filesystem or out in the wild on the internet.</p>
<p>In this recipe, we will use the same application with all the existing configurations as we used in the previous recipe. We will use it to experiment with starting up using the external configuration properties that are living in the local filesystem and from an internet URL, such as GitHub or any other.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Let's start by adding a bit of code to log the value of our particular configuration property so that we can easily see the change in it as we do different things. Add an <kbd>@Bean</kbd> method to the <kbd>BookPubApplication</kbd> class located in the <kbd>src/main/java/org/test/bookpub</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">@Bean 
public CommandLineRunner configValuePrinter(<br/>   @Value("${my.config.value:}") String configValue) { 
  return args -&gt; LogFactory.getLog(getClass()).<br/>     info("Value of my.config.value property is: " + <br/>       configValue); 
} </pre>
<ol start="2">
<li>Let's build the application by running <kbd>./gradlew clean bootJar</kbd> and start it by running <kbd>./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger</kbd> so as to see the following log output:</li>
</ol>
<pre style="padding-left: 30px">    <strong>2017-12-17 --- ication$$EnhancerBySpringCGLIB$$b123df6a : Value of <br/>    my.config.value property is:</strong>
  </pre>
<ol start="3">
<li>The value is empty, as we expected. Next, we will create a file named <kbd>external.properties</kbd> in our home directly with the following content:</li>
</ol>
<pre style="padding-left: 60px"><strong>my.config.value=From Home Directory Config</strong>
  </pre>
<ol start="4">
<li>Let's run our application by executing <kbd>./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger --spring.config.location=file:/home/&lt;username&gt;/external.properties</kbd> in order to see the following output in the logs:</li>
</ol>
<pre style="padding-left: 60px"><strong>2017-12-17 --- ication$$EnhancerBySpringCGLIB$$b123df6a : Value of my.config.value property is: From Home Directory Config</strong>
  </pre>
<div class="mce-root packt_infobox"><span>For macOS users, the home directories can be found in the</span> <kbd>/Users/&lt;username&gt;</kbd> <span>folder.</span></div>
<ol start="5">
<li>We can also load the file as an HTTP resource and not from the local filesystem. So, place a file named <kbd>external.properties</kbd> with the content of <kbd>my.config.value=From HTTP Config</kbd> somewhere on the web. It can even be checked in a GitHub or BitBucket repository, as long as it is accessible without any need for authentication.</li>
<li>Let's run our application by executing <kbd>./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger --spring.config.location=http://&lt;your file location path&gt;/external.properties</kbd> in order to see the following output in the logs:</li>
</ol>
<pre style="padding-left: 60px"><strong>2017-12-17 --- ication$$EnhancerBySpringCGLIB$$b123df6a : Value of my.config.value property is: From HTTP Config</strong>
  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Before delving into the details of an external configuration setup, let's quickly look at the code that was added in order to print the property value in the log. The element of focus is the <kbd>@Value</kbd> annotation that can be used on class fields or method arguments; it also instructs Spring to automatically inject the annotated variable with the value defined in the annotation. If the value is positioned in the wrapping curly braces prefixed with a dollar sign, (<kbd>${ }</kbd>), Spring will replace this with the value from the corresponding application property or with the default value, if it is provided, by adding the textual data after the colon (<kbd>:</kbd>).</p>
<p>In our case, we defined it as <kbd>@Value("${my.config.value:}")String configValue</kbd>, so unless an application property named <kbd>my.config.value</kbd> exists, the default value of an empty String will be assigned to the <kbd>configValue</kbd> method argument. This construct is quite handy and eliminates the need to explicitly wire in the instance of an environment object just to get a specific property value out of it, as well as simplifying the code during testing, with less objects to mock.</p>
<p>The support for being able to specify the location of the application properties configuration file is geared towards supporting a dynamic multitude of environmental topologies, especially in cloud environments. This is often the case when the compiled application gets bundled into different cloud images that are destined for different environments and are being specially assembled by deployment tools such as Packer, Vagrant, and others.</p>
<p>In this scenario, it is very common to drop a configuration file in the image filesystem while making the image, depending on what environment it is destined for. Spring Boot provides a very convenient ability to specify, via the command-line arguments, where the configuration properties file, which should be added to the application configuration bundle, resides.</p>
<p>Using the <kbd>--spring.config.location</kbd> startup option, we can specify a location of one or multiple files, which can then be separated by a comma (<kbd>,</kbd>) to be added to the default ones. The file designations can be either files from a local filesystem, a classpath, or a remote URL. The locations will be resolved either by the <kbd>DefaultResourceLoader</kbd> class or, if configured via a <kbd>SpringApplication</kbd> constructor or setter, by the implementation that is provided by the <kbd>SpringApplication</kbd> instance.</p>
<p>If the location contains directories, the names should end with a <kbd>/</kbd> so as to let Spring Boot know that it should look for the <kbd>application.properties</kbd> file in these directories.</p>
<p>If you want to change the default name of the file, Spring Boot provides you with this ability as well. Just set the <kbd>--spring.config.name</kbd> option to whatever filename that you want.</p>
<div class="packt_infobox">It is important to remember that the default search paths for the configuration of <kbd>classpath:,classpath:/config,file:,file:config/</kbd> will always be used regardless of the presence of the <kbd>--spring.config.location</kbd> setting. This way, you can always retain your default configuration in <kbd>application.properties</kbd> and just override the ones that you need via the start up settings.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Externalizing an environmental configuration using environment variables</h1>
                </header>
            
            <article>
                
<p>In the previous recipes, we have, a number of times, alluded to the fact that configuration values to a Spring Boot application can be passed and overridden by using OS environment variables. Operating systems rely on these variables to store information about various things. We probably have to set <kbd>JAVA_HOME</kbd> or <kbd>PATH</kbd> a few times, and these are examples of environment variables. <span>OS environment variables</span> is also a very important feature if one deploys their application using a PaaS system such as Heroku or Amazon AWS. In these environments, configuration values such as database access credentials and various API tokens are all provided over the environment variables.</p>
<p>Their power comes from the ability to completely externalize the configuration of simple key-value data pairs without the need to rely on placing a property or some other files in a particular location, and having this hardcoded in the application code base. These variables are also agnostic to the particular operating system and can be consumed in the Java program in the same way, <kbd>System.getenv()</kbd>, regardless of which OS the program is running on.</p>
<p>In this recipe, we will explore how this power can be leveraged to pass the configuration properties to our Spring Boot applications. We will continue to use the code base from the previous recipe and experiment with a few different ways of starting the application and using the OS environment variables in order to change the configuration values of some properties.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>In the previous recipe, we added a configuration property named <kbd>my.config.value</kbd>. Let's build the application by running <kbd>./gradlew clean bootJar</kbd> and start it by running <kbd>MY_CONFIG_VALUE="From ENV Config" ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger</kbd> so as to see the following output in the logs:</li>
</ol>
<pre style="padding-left: 30px">    <strong>2017-12-17 --- ication$$EnhancerBySpringCGLIB$$b123df6a : Value of <br/>    my.config.value property is: From ENV Config</strong></pre>
<ol start="2">
<li>If we want to use the environment variables while running our application via the Gradle <kbd>bootRun</kbd> task, the command line will be <kbd>MY_CONFIG_VALUE="From ENV Config" ./gradlew clean bootRun</kbd> and should produce the same output as in the preceding step.</li>
<li>Conveniently enough, we can even mix and match how we set the configurations. We can use the environment variable to configure the <kbd>spring.config.location</kbd> property and use it to load other property values from the external properties file, as we did in the previous recipe. Let's try this by launching our application by executing <kbd>SPRING_CONFIG_LOCATION= file:/home/&lt;username&gt;/external.properties ./gradlew bootRun</kbd>. We should see the following in the logs:</li>
</ol>
<pre style="padding-left: 60px"><strong>2017-12-17 --- ication$$EnhancerBySpringCGLIB$$b123df6a : Value of <br/>my.config.value property is: From Home Directory Config</strong>
  </pre>
<div class="mce-root packt_infobox"><span>While using environment variables is very convenient, it does have maintenance overhead if the number of these variables gets to be too many. To help deal with this issue, it is good practice to use a method of delegation by setting the</span> <kbd><span>SPRING_CONFIG_LOCATION</span></kbd> <span>variable to configure the location of the environment-specific properties file, typically by loading them from a URL location.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As you learned from the section on environment configuration hierarchy, Spring Boot offers multiple ways of providing the configuration properties. Each of these is managed via an appropriate <kbd>PropertySource</kbd> implementation. We looked at how to create a custom implementation of <kbd>PropertySource</kbd> when we were implementing <kbd>ApacheCommonsConfigurationPropertySource</kbd>. Spring Boot already provides a <kbd>SystemEnvironmentPropertySource</kbd> implementation for us to use out of the box. This even gets automatically registered with the default implementation of the environment interface: the <kbd>SystemEnvironment</kbd>.</p>
<p>As the <kbd>SystemEnvironment</kbd> implementation provides a composite façade on top of a multitude of different <kbd>PropertySource</kbd> implementations, the overriding takes place seamlessly, simply because the <kbd>SystemEnvironmentPropertySource</kbd> class sits higher up in the list than the <kbd>application.properties</kbd> file one.</p>
<p>An important aspect that you should notice is the use of <kbd>ALL_CAPS</kbd> with underscores (<kbd>_</kbd>) in order to separate the words instead of the traditional conventional <kbd>all.lower.cased</kbd> format with dots (<kbd>.</kbd>) separating the words used in Spring Boot to name the configuration properties. This is due to the nature of some operating systems, namely Linux and OS X, which prevent the use of dots (<kbd>.</kbd>) in the names and instead encourages the use of the <kbd>ALL_CAPS</kbd> underscore-separated notation.</p>
<p>In situations where the usage of environment variables to specify or override the configuration properties is not desired, Spring provides us with the <kbd>-Dspring.getenv.ignore</kbd> system property, which can be set to true and prevents the usage of environment variables. You might want to change this setting to true if you see errors or exceptions in the log due to the running of your code on some application servers or a particular security policy configuration that might not allow access to environment variables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Externalizing an environmental configuration using Java system properties</h1>
                </header>
            
            <article>
                
<p>While environment variables can, on rare occasions, be hit or miss, the good old Java system properties can always be trusted to be there for you. In addition to using the environment variables and command-line arguments represented by the property names prefixed with a double dash (<kbd>--</kbd>), Spring Boot provides you with the ability to use the plain Java system properties to set or override the configuration properties.</p>
<p>This can be useful in a number of situations, particularly if your application is running in a container that sets certain values during startup via the system properties that you want to get access to, or if a property value is not set via a command-line <kbd>-D</kbd> argument, but rather in some library via code and by calling <kbd>System.setProperty(...)</kbd>, especially if <span>property value is being accessed from inside</span> a static method of sorts. While arguably these cases are rare, it takes only one to make you bend over backwards in an effort to try and integrate this value into your application.</p>
<p>In this recipe, we will use the same application executable that was used for the previous one, with the only difference being that we are using Java system properties instead of command-line arguments or environment variables to set our configuration properties at runtime.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Let's continue our experiments by setting the <kbd>my.config.value</kbd> configuration property. Build the application by running <kbd>./gradlew clean bootJar</kbd> and start it by running <kbd>java -Dmy.config.value="From System Config" -jar ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar</kbd> so as to see the following in the logs:</li>
</ol>
<pre style="padding-left: 60px"><strong>2017-12-17 --- ication$$EnhancerBySpringCGLIB$$b123df6a : Value of my.config.value property is: From System Config</strong>
  </pre>
<ol start="2">
<li>If we want to be able to set the Java system property while running our application using the Gradle's <kbd>bootRun</kbd> task, we will need to add this to the <kbd>applicationDefaultJvmArgs</kbd> configuration in the <kbd>build.gradle</kbd> file. Let's add <kbd>-Dmy.config.value=Gradle</kbd> to this list and start the application by running <kbd>./gradlew clean bootRun</kbd>. We should see the following in the logs:</li>
</ol>
<pre style="padding-left: 60px"><strong>2017-12-17 --- ication$$EnhancerBySpringCGLIB$$b123df6a : Value of my.config.value property is: Gradle</strong>
  </pre>
<ol start="3">
<li>As we made the <kbd>applicationDefaultJvmArgs</kbd> setting to be shared with <kbd>launch.script</kbd>, rebuilding the application by running <kbd>./gradlew clean bootJar</kbd> and starting it by running <kbd>./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar</kbd> should yield the same output in the logs as in the preceding step.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You might have already guessed that Java system properties are consumed by a similar mechanism that is used for environment variables, and you would be correct. The only real difference is the implementation of <kbd>PropertySource</kbd>. This time, a more generic <kbd>MapPropertySource</kbd> implementation is used by <kbd>StandardEnvironment</kbd>.</p>
<p>What you have also probably noticed is the need to launch our application using the <kbd>java -Dmy.config.value="From System Config" -jar ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar</kbd> command instead of just simply invoking the self-executing packaged JAR by itself. This is because, unlike the environment variables and command-line arguments, Java system properties have to be set on the Java executable ahead of everything else.</p>
<p>We did manage to work around this need by effectively hardcoding the values in our <kbd>build.gradle</kbd> file, which, combined with the enhancements that we made to <kbd>launch.script</kbd>, allowed us embed the <kbd>my.config.value</kbd> property in the command line in the self-executing jar, as well as use it with the Gradle's <kbd>bootRun</kbd> task.</p>
<p>The risk of using this approach with the configuration properties is that it will always override the values that we set in the higher layers of the configuration, such as <kbd>application.properties</kbd> and others. Unless you are explicitly constructing the Java executable command line and not using the self-launching capabilities of the packaged JAR, it is best not to use Java system properties and consider using the command-line arguments or environment variables instead.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Externalizing an environmental config using JSON</h1>
                </header>
            
            <article>
                
<p>We have looked at a number of different ways to externally add or override the values of specific properties, either by using environment variables, system properties, or command-line arguments. All those options provide us with a great deal of flexibility, but with the exception of external property files, are all limited to setting one property at a time. When it comes to using property files, the syntax is not exactly the best at representing nested, hierarchical data structures, and can get a bit tricky. To avoid this situation, Spring Boot provides us with an ability to also pass, externally, JSON-encoded content containing an entire config hierarchy of settings.</p>
<p>In this recipe, we will use the same application executable that was used for the previous one, with the only difference being using external JSON content to set our configuration properties at runtime.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Let's continue our experiments by setting the <kbd>my.config.value</kbd> configuration property. Build the application by running <kbd>./gradlew clean bootJar</kbd> and start it by running <kbd>java -jar ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.application.json={"my":{"config":{"value":"From external JSON"}}}</kbd> so as to see the following in the logs:</li>
</ol>
<pre style="padding-left: 60px"><strong>2017-12-17 --- ication$$EnhancerBySpringCGLIB$$b123df6a : Value of my.config.value property is: From external JSON</strong>
  </pre>
<ol start="2">
<li>If we want to be able to set the content using Java system properties, we can use <kbd>-Dspring.application.json</kbd> instead, assigning the same JSON content as the value.</li>
<li>Alternatively, we can also rely on the <kbd>SPRING_APPLICATION_JSON</kbd> environment variable to pass the same JSON content in the following way:</li>
</ol>
<pre style="padding-left: 60px">SPRING_APPLICATION_JSON={"my":{"config":{"value":"From external JSON"}}} java -jar ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Just like every other configuration approach we have looked at, the JSON content is consumed by a dedicated <kbd>EnvironmentPostProcessor</kbd> implementation. The only difference is the flattening of the JSON tree into a flat property map, to match the dot-separated properties naming style. In our case, the <kbd>my-&gt;config-&gt;value</kbd> nested map gets converted into a flat map with only one key, <kbd>my.config.value</kbd>, with the value of <kbd>From external JSON</kbd>.</p>
<p>The setting of the JSON content can come from ANY property source, available from the environment at the time of loading, which contains a key named <kbd>spring.application.json</kbd> with a value of valid JSON content, and is not only limited to being set by an Environment Variable or using the <kbd>SPRING_APPLICATION_JSON</kbd> name or Java System Property.</p>
<p>This capability can be very useful to provide externally-defined, environment-specific configuration in bulk. The best way is to do so via setting the <kbd>SPRING_APPLICATION_JSON</kbd> environment variable on the machine instance using machine/image provisioning tools such as Chef, Puppet, Ansible, Packer, and so on. This enables you to store an entire configuration hierarchy in one JSON file externally, and then simply provision the correct content on the specific machine during provisioning time by just setting an Environment Variable. All applications running on that machine will automatically consume it upon startup.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up Consul</h1>
                </header>
            
            <article>
                
<p>So far, everything that we have been doing with the configuration was connected to the local set of data. In a real, large-scale enterprise environment, this is not always the case and quite frequently there is the desire to be able to make the configuration changes at large, across hundreds or even thousands of instances or machines.</p>
<p>There are a number of tools that exist to help you with this task, and in this recipe, we will take a look at one that, in my opinion, stands out from the group, giving you the ability to cleanly and elegantly configure the environment variables for a starting application using a distributed data store. The tool's name is <strong>Consul</strong>. It is an open source product from Hashicorp and is designed to discover and configure the services in a large, distributed infrastructure.</p>
<p>In this recipe, we will take a look at how to install and configure Consul and experiment with some key functionalities that it provides. This will give us the necessary familiarity for our next recipe, where we will be using Consul to provide the configuration values that are needed to start our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Go to <a href="https://consul.io/downloads.html"><span class="URLPACKT">https://consul.io/downloads.html</span></a> and download the appropriate archive, depending on the operating system that you are using. Consul supports Windows, OS X, and Linux, so it should work for the majority of readers.</li>
</ol>
<div class="mce-root packt_infobox"><span>If you are an OS X user, you can install Consul using Homebrew by running</span> <kbd>brew install caskroom/cask/brew-cask</kbd> <span>followed by</span> <kbd><span>brew cask install consul</span></kbd>.</div>
<ol start="2">
<li>After the installation, we should be able to run <kbd>consul --version</kbd> and see the following output:</li>
</ol>
<pre style="padding-left: 60px"><strong>Consul v1.0.1<br/>Protocol 2 spoken by default, understands 2 to 3 (agent will automatically use protocol &gt;2 when speaking to compatible agents)<br/></strong></pre>
<ol start="3">
<li>With Consul successfully installed, we should be able to start it by running the <kbd>consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul</kbd> command and our terminal window will display the following:</li>
</ol>
<pre style="padding-left: 60px"><strong>==&gt; WARNING: BootstrapExpect Mode is specified as 1; this is the same as Bootstrap mode.</strong>
<strong>==&gt; WARNING: Bootstrap mode enabled! Do not enable unless necessary</strong>
<strong>==&gt; WARNING: It is highly recommended to set GOMAXPROCS higher than 1</strong>
<strong>==&gt; Starting Consul agent...</strong>
<strong>==&gt; Starting Consul agent RPC...</strong>
<strong>==&gt; Consul agent running!</strong>
<strong>         Node name: &lt;your machine name&gt;'</strong>
<strong>        Datacenter: 'dc1'</strong>
<strong>            Server: true (bootstrap: true)</strong>
 <strong>      Client Addr: 127.0.0.1 (HTTP: 8500, HTTPS: -1, DNS: 8600, RPC: 8400)</strong>
  <strong>    Cluster Addr: 192.168.1.227 (LAN: 8301, WAN: 8302)</strong>
    <strong>Gossip encrypt: false, RPC-TLS: false, TLS-Incoming: false</strong>
    <strong>         Atlas: &lt;disabled&gt;</strong>
    
<strong>==&gt; Log data will now stream in as it occurs:</strong>
    
<strong>    2017/12/17 20:34:43 [INFO] serf: EventMemberJoin: &lt;your machine name&gt; 192.168.1.227</strong>
    <strong>2017/12/17 20:34:43 [INFO] serf: EventMemberJoin: &lt;your machine name&gt;.dc1 192.168.1.227</strong>
<strong>    2017/12/17 20:34:43 [INFO] raft: Node at 192.168.1.227:8300 [Follower] entering Follower state</strong>
<strong>    2017/12/17 20:34:43 [INFO] consul: adding server &lt;your machine name&gt; (Addr: 192.168.1.227:8300) (DC: dc1)</strong>
<strong>    2017/12/17 20:34:43 [INFO] consul: adding server &lt;your machine name&gt;.dc1 (Addr: 192.168.1.227:8300) (DC: dc1)</strong>
<strong>    2017/12/17 20:34:43 [ERR] agent: failed to sync remote state: No cluster leader</strong>
<strong>    2017/12/17 20:34:45 [WARN] raft: Heartbeat timeout reached, starting election</strong>
<strong>    2017/12/17 20:34:45 [INFO] raft: Node at 192.168.1.227:8300 [Candidate] entering Candidate state</strong>
<strong>    2017/12/17 20:34:45 [INFO] raft: Election won. Tally: 1</strong>
<strong>    2017/12/17 20:34:45 [INFO] raft: Node at 192.168.1.227:8300 [Leader] entering Leader state</strong>
<strong>    2017/12/17 20:34:45 [INFO] consul: cluster leadership acquired</strong>
<strong>    2017/12/17 20:34:45 [INFO] consul: New leader elected: &lt;your machine name&gt;</strong>
<strong>    2017/12/17 20:34:45 [INFO] raft: Disabling EnableSingleNode (bootstrap)</strong>
<strong>    2017/12/17 20:34:45 [INFO] consul: member '&lt;your machine name&gt;' joined, marking health alive</strong>
<strong>    2017/12/17 20:34:47 [INFO] agent: Synced service 'consul'</strong>
  </pre>
<ol start="4">
<li>With the Consul service running, we can verify that it contains one member by running the <kbd>consul members</kbd> command, and should see the following result:</li>
</ol>
<pre style="padding-left: 30px"><strong>Node                 Address        Status  Type    Build  Protocol  DC</strong>
<strong>&lt;your_machine_name&gt; 2.168.1.227:8301 alive  server   0.5.2     2    dc1</strong>
  </pre>
<ol start="5">
<li>While Consul can also provide discovery for services, health checks, distributed locks, and more, we are going to focus on the key/value service as this is what will be used to provide the configuration in the next recipe. So, let's put the <kbd>From Consul Config</kbd> value in the key/value store by executing the <kbd>curl -X PUT -d 'From Consul Config' http://localhost:8500/v1/kv/bookpub/my/config/value</kbd> command.</li>
</ol>
<div class="mce-root packt_infobox"><span>If you are using Windows, you can get</span> <span>curl</span> <span>from</span> <a href="http://curl.haxx.se/download.html">http://curl.haxx.se/download.html</a>.</div>
<ol start="6">
<li>We can also retrieve the data by running the <kbd>curl http://localhost:8500/v1/kv/bookpub/my/config/value</kbd> command and should see the following output:</li>
</ol>
<pre style="padding-left: 60px">        <strong>[{"CreateIndex":20,"ModifyIndex":20,"LockIndex":0,"Key":"bookpub/my/config/value","Flags":0,"Value":"RnJvbSBDb25zdWwgQ29uZmln"}]</strong>
      </pre>
<ol start="7">
<li>We can delete this value by running the <kbd>curl -X DELETE http://localhost:8500/v1/kv/bookpub/my/config/value</kbd> command.</li>
<li>In order to modify the existing value and change it for something else, execute the <kbd>curl -X PUT -d 'newval' http://localhost:8500/v1/kv/bookpub/my/config/value?cas=20</kbd> command.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>A detailed explanation about how Consul works and all the possible options for its key/value service would take a book of its own, so here we will look only at the basic pieces. It is strongly recommended that you read Consul's documentation at <a href="https://consul.io/intro/getting-started/services.html"><span class="URLPACKT">https://consul.io/intro/getting-started/services.html</span></a>.</p>
<p>In <em>step 3</em>, we started the Consul agent in server mode. It acts as a main master node and, in real deployment, the local agents running on the individual instances will be using the server node to connect to and retrieve data from. For our test purposes, we will just use this server node as if it were a local agent.</p>
<p>The information displayed upon startup shows us that our node has started as a server node, establishing an HTTP service on port <kbd>8500</kbd> as well as the DNS and RPC services, if that's how one chooses to connect to it. We can also see that there is only one node in the cluster, ours, and we are the elected leader running in a healthy state.</p>
<p>As we will be using the convenient RESTful HTTP API via cURL, all of our requests will be using localhost on port <kbd>8500</kbd>. Being a RESTful API, it fully adheres to CRUD verb terminology, and to insert the data, we will use a <kbd>PUT</kbd> method on a <kbd>/v1/kv</kbd> endpoint in order to set the <kbd>bookpub/my/config/value</kbd> key.</p>
<p>Retrieving the data is even more straightforward: we just make a <kbd>GET</kbd> request to the same <kbd>/v1/kv</kbd> service using the desired key. The same goes for <kbd>DELETE</kbd>, with the only difference being the method name.</p>
<p>The update operation requires a bit more information in the URL, namely the <kbd>cas</kbd> parameter. The value of this parameter should be the <kbd>ModifyIndex</kbd> of the desired key, which can be obtained from the <kbd>GET</kbd> request. In our case, it has a value of 20.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Externalizing an environmental config using Consul and envconsul</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, we had our Consul service installed and experimented with its key/value capabilities to learn how we could manipulate the data in it in order to integrate Consul with our application and make the data extraction process seamless and non-invasive from an application standpoint.</p>
<p>As we don't want <span>our application</span> to know anything about Consul and have to explicitly connect to it, even though such a possibility exists, we will employ another utility, also created as open source by Hashicorp, called <strong>envconsul</strong>. It will connect to the Consul service for us, extract the specified configuration key/value tree, and expose it as the environment variables to be used while also launching our application. Pretty cool, right?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Before we get started with launching our application, which was created in the previous recipes, we need to install the envconsul utility.</p>
<p>Download the binary for your respective operating system from <a href="https://github.com/hashicorp/envconsul/releases"><span class="URLPACKT">https://github.com/hashicorp/envconsul/releases</span></a> and extract the executable to any directory of your choice, though it is better to put it somewhere that is in the PATH.</p>
<p>Once envconsul is extracted from the downloaded archive, we are ready to start using it so as to configure our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>If you have not already added the value for the <kbd>my/config/value</kbd> key to Consul, let's add it by running <kbd>curl -X PUT -d 'From Consul Config' http://localhost:8500/v1/kv/bookpub/my/config/value</kbd>.</li>
<li>The first step is to make sure envconsul can connect to the Consul server and that it extracts the correct data based on our configuration key. Let's execute a simple test by running the <kbd>envconsul --once --sanitize --upcase --prefix bookpub env</kbd> command. We should see the following in the output:</li>
</ol>
<pre style="padding-left: 30px">    <strong>...</strong>
    <strong>TERM=xterm-256color</strong>
    <strong>SHELL=/bin/bash</strong>
    <strong>LANG=en_US.UTF-8</strong>
    <strong>HOME=/Users/&lt;your_user_name&gt;</strong>
    <strong>...</strong>
    <strong>MY_CONFIG_VALUE=From Consul Config</strong></pre>
<ol start="3">
<li>After we have verified that envconsul is returning the correct data to us, we will use it to launch our <kbd>BookPub</kbd> application by running <kbd>envconsul --once --sanitize --upcase --prefix bookpub ./gradlew clean bootRun</kbd>. Once the application has started, we should see the following output in the logs:</li>
</ol>
<pre style="padding-left: 60px"><strong>2017-12-17 --- ication$$EnhancerBySpringCGLIB$$b123df6a : Value of my.config.value property is: From Consul Config</strong>
  </pre>
<ol start="4">
<li>We can do the same thing by building the self-starting executable JAR by running <kbd>./gradlew clean bootJar</kbd>, and start it by running <kbd>envconsul --once --sanitize --upcase --prefix bookpub ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar</kbd> to make sure we see the same output in the logs as in the preceding step. If you see <kbd>Gradle</kbd> instead of <kbd>From Consul Config</kbd>, make sure the <kbd>applicationDefaultJvmArgs</kbd> configuration in <kbd>build.gradle</kbd> does not have <kbd>-Dmy.config.value=Gradle</kbd> in it.</li>
<li>Another marvelous ability of envconsul is not only to export the configuration key values as environment variables, but also to monitor for any changes and restart the application if the values in Consul change. Let's launch our application by running <kbd>envconsul --sanitize --upcase --prefix bookpub ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar</kbd>, and we should see the following value in the log:</li>
</ol>
<pre style="padding-left: 60px"><strong>2017-12-17 --- ication$$EnhancerBySpringCGLIB$$b123df6a : Value of my.config.value property is: From Consul Config</strong>
  </pre>
<ol start="6">
<li>We will now use the consul command to get the current <kbd>ModifyIndex</kbd> of our key and update its value to <kbd>From UpdatedConsul Config</kbd> by opening another terminal window and executing <kbd>curl http://localhost:8500/v1/kv/bookpub/my/config/value</kbd>, grabbing the <kbd>ModifyIndex</kbd> value, and using it to execute <kbd>curl -X PUT -d 'From UpdatedConsul Config' http://localhost:8500/v1/kv/bookpub/my/config/value?cas=&lt;ModifyIndex Value&gt;</kbd>. We should see our running application magically restart itself and our newly updated value displayed in the log at the end:</li>
</ol>
<pre style="padding-left: 60px"><strong>2017-12-17 --- ication$$EnhancerBySpringCGLIB$$b123df6a : Value of my.config.value property is: From UpdatedConsul Config</strong>
  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>What we just did was pretty sweet, right? Let's examine the magic going on behind the scenes in more detail. We will start by dissecting the command line and explaining what each argument control option does.</p>
<p>Our first execution command line was <kbd>envconsul --once --sanitize --upcase --prefix bookpub ./gradlew clean bootRun</kbd>, so let's take a look at exactly what we did, as follows:</p>
<ul>
<li>First, one might notice that there is no indication about which Consul node we should be connecting to. This is because there is an implicit understanding or an assumption that you already have a Consul agent running locally on <kbd>localhost:8500</kbd>. If this is not the case for whatever reason, you can always explicitly specify the Consul instance to connect via the <kbd>--consul localhost:8500</kbd> argument added to the command line.</li>
<li>The <kbd>--prefix</kbd> option specifies the starting configuration key segment in which to look for the different values. When we were adding keys to Consul, we used the following key: <kbd>bookpub/my/config/value</kbd>. By specifying the <kbd>--prefix bookpub</kbd> option, we tell envconsul to strip the <kbd>bookpub</kbd> part of the key and use all the internal tree elements in <kbd>bookpub</kbd> to construct the environment variables. Thus, <kbd>my/config/value</kbd> becomes the environment variable.</li>
<li>The <kbd>--sanitize</kbd> option tells envconsul to replace all the invalid characters with underscores (<kbd>_</kbd>). So, if we were to only use <kbd>--sanitize</kbd>, we would end up with <kbd>my_config_value</kbd> as an environment variable.</li>
<li>The <kbd>--upcase</kbd> option, as you might already have guessed, changes the environment variable key to all upper case characters, so when combined with the <kbd>--sanitize</kbd> option, <kbd>my/config/value</kbd> key gets transformed into the <kbd>MY_CONFIG_VALUE</kbd> environment variable.</li>
<li>The <kbd>--once</kbd> option indicates that we only want to externalize the keys as environment variables once and do not want to continuously monitor for changes in the Consul cluster. If a key in our prefix tree has changed its value, we re-externalize the keys as environment variables and restart the application.</li>
</ul>
<p>This last option, <kbd>--once</kbd>, provides a very useful choice of functionalities. If you are interested only in the initial bootstrapping of your application via the use of a Consul-shared configuration, then the keys will be set as environment variables, the application will be launched, and envconsul will consider its job done. However, if you would like to monitor the Consul cluster for changes to keys/values and, after the change has taken place, restart your application reflecting the new change, then remove the <kbd>--once</kbd> option and envconsul will restart the application once the change has occurred.</p>
<p>Such behavior can be very useful and handy for things such as a near-instantaneous changes to the database connection configuration. Imagine that you need to do a quick failover from one database to another and your JDBC URL is configured via Consul. All you need to do is push a new JDBC URL value and envconsul will almost immediately detect this change and restart the application, telling it to connect to a new database node.</p>
<p>Currently, this functionality is implemented by sending a traditional SIGTERM signal to an application running process, telling it to terminate and, once the process is exited, restart the application. This might not always be the desired behavior, especially if it takes some time for an application to start up and be capable of taking traffic. You don't want your entire cluster of web applications to be shut down, even if it will only be for a few minutes.</p>
<p>To provide a better handling of this scenario, envconsul was enhanced to be able to send a number of standard signals that can be configured via a newly added <kbd>--kill-signal</kbd> option. Using this option, we can specify any of the SIGHUP, SIGTERM, SIGINT, SIGQUIT, SIGUSR1, or SIGUSR2 signals to be used instead of the default SIGTERM, to be sent to a running application process once the key/value changes have been detected.</p>
<p>The process signal handling in Java is not as clear and straightforward due to most of the behavior being very specific to a particular operating system and the JVM that is run atop it. Some of the signals in the list will terminate the application anyway or, in the case of SIGQUIT, the JVM will print Core Dump into the standard output. However, there are ways to configure the JVM, depending on the operating system, to let us use SIGUSR1 and SIGUSR2 instead of acting on those signals itself, but unfortunately that topic falls outside the scope of this book.</p>
<p>Here is a sample example of how to deal with <strong>Signal Handlers</strong>: <a href="https://github.com/spotify/daemon-java">https://github.com/spotify/daemon-java</a>, or see the Oracle Java documentation at <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/signals.html">https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/signals.html</a> for a detailed explanation.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>