<html><head></head><body>
		<div id="_idContainer022">
			<h1 id="_idParaDest-61"><em class="italic"><a id="_idTextAnchor068"/>Chapter 4</em>: Developing Cloud-Native Applications</h1>
			<p>MicroProfile 4.1 builds on some <strong class="bold">Jakarta EE</strong> (formerly <strong class="bold">Java Enterprise Edition</strong>) <strong class="bold">application programming interfaces</strong> (<strong class="bold">APIs</strong>)—specifically, <strong class="bold">Jakarta RESTful Web Services</strong> (<strong class="bold">JAX-RS</strong>), <strong class="bold">Jakarta Contexts and Dependency Injection</strong> (<strong class="bold">CDI</strong>), <strong class="bold">JavaScript Object Notation Processing</strong> (<strong class="bold">JSON-P</strong>), and <strong class="bold">JSON Binding</strong> (<strong class="bold">JSON-B</strong>). Using only these technologies, it is possible to develop a perfectly capable cloud-native application. The MicroProfile community added a type-safe mechanism for invoking RESTful services known as the <strong class="bold">MicroProfile Rest Client</strong>. These technologies are essential for building Java-based microservices that can interoperate in the cloud. Learning to use these technologies will enable you to build robust and secure Java microservices. </p>
			<p>In this chapter, we will explore all of the following topics:</p>
			<ul>
				<li>Developing a RESTful service with JAX-RS</li>
				<li>Managing the payload with JSON-P and JSON-B</li>
				<li>Consuming RESTful services with the MicroProfile Rest Client</li>
				<li>Managing life cycle and <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) with CDI</li>
			</ul>
			<p>This chapter covers a wide spectrum of technologies and the functionality within each technology. When you have finished this chapter, you should have a broad and deep understanding of how to build reliable, robust RESTful applications that can communicate with each other using JSON.</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor069"/>Technical requirements</h1>
			<p>In order to build and run the samples mentioned in this chapter, you will need a Mac or PC (Windows or Linux) with the following software:</p>
			<ul>
				<li><strong class="bold">Java Development Kit</strong> (<strong class="bold">JDK</strong>) version 8 or higher (<a href="http://ibm.biz/GetSemeru">http://ibm.biz/GetSemeru</a>)</li>
				<li>Apache Maven (<a href="https://maven.apache.org/">https://maven.apache.org/</a>)</li>
				<li>A Git client (<a href="https://git-scm.com/">https://git-scm.com/</a>)</li>
				<li>All of the source code used in this chapter is available on GitHub at <a href="https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter04">https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter04</a>.</li>
			</ul>
			<p>Once you have cloned the GitHub repository, you can start the Open Liberty server that these code samples will execute in by entering the <strong class="source-inline">Chapter04</strong> directory and running the following command from the command line:</p>
			<p class="source-code"> mvn clean package liberty:run</p>
			<p>You can then stop the server in the same command window by pressing <em class="italic">Ctrl + C</em>.</p>
			<p>Now we've got the prerequisites taken care of, let's start by building a basic RESTful service.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor070"/>Developing a RESTful service with JAX-RS</h1>
			<p>In this<a id="_idIndexMarker280"/> section, we will develop a few RESTful <a id="_idIndexMarker281"/>services using JAX-RS. We'll start with a simple example, and then we'll add more complex and powerful techniques such as exception handling, advanced conversion of <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) data into Java objects (and vice versa), cross-cutting<a id="_idIndexMarker282"/> concerns, asynchronous methods, and DI. </p>
			<p>JAX-RS is built around the idea<a id="_idIndexMarker283"/> of a <strong class="bold">request-response</strong> pipeline. On the server side, an HTTP request enters the pipeline, then the JAX-RS server invokes <a id="_idIndexMarker284"/>any pre-matching <strong class="bold">filters</strong> on the request. It then attempts to match the request with <a id="_idIndexMarker285"/>a JAX-RS <strong class="bold">resource method</strong>.  </p>
			<p>When the JAX-RS container receives an incoming request, it will perform the following process:</p>
			<ol>
				<li>Invoke any registered pre-matching filters.</li>
				<li>Attempt to match the request to a <strong class="source-inline">resource</strong> method. If no match can be made, the container will respond with an appropriate <strong class="source-inline">not found</strong> HTTP response.</li>
				<li>Invoke any registered post-matching filters.</li>
				<li>Perform conversion of HTTP data (such as the HTTP entity payload or parameters, headers, and so on) into Java objects consumable by the resource method if necessary.</li>
				<li>Invoke the <strong class="source-inline">resource</strong> method.</li>
				<li>Perform <a id="_idIndexMarker286"/>exception<a id="_idIndexMarker287"/> handling, if necessary.</li>
				<li>Invoke any registered response filters.</li>
				<li>Perform conversion of Java object(s) to HTTP response data, if necessary.</li>
				<li>Return the HTTP response to the client.</li>
			</ol>
			<p>This pipeline flow is illustrated in the following diagram: </p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/Figure_4.1_-_B17377.jpg" alt="Figure 4.1 – JAX-RS server pipeline flow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – JAX-RS server pipeline flow</p>
			<p>In JAX-RS, there are three types of components, outlined as follows:</p>
			<ul>
				<li><strong class="bold">Resources</strong>: The resources<a id="_idIndexMarker288"/> are what ultimately make the RESTful service what it is as they contain the business logic.</li>
				<li><strong class="bold">Providers</strong>: Providers<a id="_idIndexMarker289"/> augment the application by performing tasks such as customizing the conversion of HTTP data into a Java object or vice versa, handling exceptions thrown from the resources, and intercepting the pipeline flow to perform supplementary tasks such as authorization or authentication, and more. Filters, <strong class="source-inline">MessageBodyReader</strong>, <strong class="source-inline">MessageBodyWriter</strong>, <strong class="source-inline">ParamConverter</strong>, <strong class="source-inline">ExceptionMapper</strong>, <strong class="source-inline">ReaderInterceptor</strong>, and <strong class="source-inline">WriterInterceptor</strong> are all providers.</li>
				<li><strong class="bold">Application subclasses</strong>: An <strong class="source-inline">Application</strong> subclass is used to provide configuration<a id="_idIndexMarker290"/> for the JAX-RS application. </li>
			</ul>
			<p>Now we understand the basic flow, let's create a simple JAX-RS application.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor071"/>Hello World!</h2>
			<p>A JAX-RS application must <a id="_idIndexMarker291"/>contain at least one resource class. Providers are optional. An <strong class="source-inline">Application</strong> subclass is only necessary if you don't have a <strong class="source-inline">web.xml</strong> file that specifies an application path. So, a very simple application might look like this:</p>
			<p class="source-code">@ApplicationPath("/rest")</p>
			<p class="source-code">public class HelloWorldApp extends Application {}</p>
			<p class="source-code">@Path("/hello")</p>
			<p class="source-code">public class HelloWorldResource {</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    public String helloWorld() {</p>
			<p class="source-code">        return "Hello World!";</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>If we build this code into a web application called <strong class="source-inline">myApp.war</strong> and deploy it into a JAX-RS container such as Open Liberty, we could quickly test it using an HTTP client by browsing to <strong class="source-inline">http://localhost:9080/myApp/rest/hello</strong> and we would see the text <strong class="bold">Hello World!</strong>.</p>
			<p>This works because the <strong class="source-inline">@GET</strong> annotation on the <strong class="source-inline">helloWorld()</strong> method tells the JAX-RS container that this method should be invoked when a client issues a <strong class="source-inline">GET</strong> request to the <strong class="source-inline">/hello</strong> path of the <strong class="source-inline">/rest</strong> application path under <a id="_idIndexMarker292"/>the <strong class="bold">context root</strong> path. The context root path is usually the <a id="_idIndexMarker293"/>same name as the <strong class="bold">Web application ARchive</strong> (<strong class="bold">WAR</strong>) file but <a id="_idIndexMarker294"/>without the <strong class="source-inline">.war</strong> extension. By default, most HTTP clients (browsers, <strong class="source-inline">curl</strong>, and so on) use <strong class="source-inline">GET</strong> unless specified otherwise. This brings up a good point about tooling. When developing RESTful applications, it is extremely valuable to have a client tool that can issue different types of HTTP requests. Command-line tools such as <strong class="source-inline">curl</strong> are very useful, and there are several browser extension-based tools that would also work.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor072"/>A more real-world example</h2>
			<p>Now we have built a simple JAX-RS<a id="_idIndexMarker295"/> application, let's build a more complex application—a thesaurus service where clients can search and update synonyms. We'll start with an <strong class="bold">exception mapper</strong>, as follows:</p>
			<p class="source-code">@Provider</p>
			<p class="source-code">public class NoSuchWordExceptionMapper implements </p>
			<p class="source-code">  ExceptionMapper&lt;NoSuchWordException&gt; {</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public Response toResponse(NoSuchWordException ex) {</p>
			<p class="source-code">        return Response.status(404)                   .entity(ex.getMessage()).build();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Most applications will have <strong class="bold">business exceptions</strong>—exceptions specific to the application domain. For a thesaurus service, that might include a <strong class="source-inline">NoSuchWordException</strong> exception, which could be used to indicate that a searched word does not exist. It is clear in the application that somebody specified a word that does not exist, but it is not clear to an HTTP client. The <strong class="source-inline">NoSuchWordExceptionMapper</strong> provider class makes that possible. It enables the resource class methods to throw a <strong class="source-inline">NoSuchWordException</strong> exception, and the JAX-RS container will map the <a id="_idIndexMarker296"/>exception to an HTTP response (in this case, a <strong class="source-inline">404 Not Found</strong> error).</p>
			<p>Next is the resource class (the full source code is available at <a href="https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/thesaurus/ThesaurusResource.java">https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/thesaurus/ThesaurusResource.java</a>), as illustrated in the following code snippet:</p>
			<p class="source-code">@Path("/thesaurus/{word}")</p>
			<p class="source-code">@Consumes(MediaType.TEXT_PLAIN)</p>
			<p class="source-code">@Produces(MediaType.TEXT_PLAIN)</p>
			<p class="source-code">public class ThesaurusResource { // ... </p>
			<p>There are a few new annotations on the resource class: <strong class="source-inline">@Produces</strong> and <strong class="source-inline">@Consumes</strong>. These annotations can be placed on resource classes or methods—as with most annotations of this type in JAX-RS, annotations on the method take priority over annotations on the class. These annotations help control the matching of requests and the entity providers (<strong class="source-inline">MessageBodyReaders</strong> and <strong class="source-inline">MessageBodyWriters</strong>) to be used in deserializing the HTTP entity from the request or serializing the HTTP entity in the response.</p>
			<p>HTTP requests and responses may contain a header that indicates the <strong class="bold">media type</strong> (also known as<a id="_idIndexMarker297"/> the <strong class="bold">Multi-purpose Internet Mail Extensions (MIME) type</strong>) of the HTTP entity—<strong class="source-inline">Content-Type</strong>. HTTP requests may also contain a header that specifies the media type(s) that it expects to receive in the response—<strong class="source-inline">Accept</strong>. In the absence of these headers, all media types are allowed (denoted by, <strong class="source-inline">*/*</strong>). </p>
			<p>In the previous example, the resource class specifies <strong class="source-inline">MediaType.TEXT_PLAIN</strong> or <strong class="source-inline">text/plain</strong>. Other media types include <strong class="source-inline">text/html</strong>, <strong class="source-inline">application/json</strong>, <strong class="source-inline">application/xml</strong>, <strong class="source-inline">image/jpeg</strong>, and much more. Specifying <strong class="source-inline">text/plain</strong> would prevent the resource methods from being invoked if a request contained a header such as <strong class="source-inline">Content-Type: application/pdf </strong>or <strong class="source-inline">Accept: image/png</strong>—instead of invoking the resource method, the JAX-RS container would return a <strong class="source-inline">415 Unsupported Media Type</strong> error.</p>
			<p class="callout-heading">Best practice</p>
			<p class="callout">Always use <strong class="source-inline">@Produces</strong> and <strong class="source-inline">@Consumes</strong> to limit media types. This will place limits on the types of requests your service will respond to. It will ensure that your application (if properly tested) can handle requests of the specified media types.</p>
			<p>This example<a id="_idIndexMarker298"/> also introduces new method-level HTTP verb annotations: <strong class="source-inline">@POST</strong>, <strong class="source-inline">@PUT</strong>, <strong class="source-inline">@DELETE</strong>, and <strong class="source-inline">@PATCH</strong>. As with <strong class="source-inline">@GET</strong>, these annotations specify which method should be invoked based on the HTTP request's <strong class="bold">verb</strong> (also known as method—<strong class="bold">HTTP method</strong> is<a id="_idIndexMarker299"/> probably the more commonly used term, but we will use <em class="italic">verb</em> in this book to disambiguate from Java methods). The JAX-RS API set includes these five verb annotations as well as <strong class="source-inline">@HEAD</strong> and <strong class="source-inline">@OPTIONS</strong>, which are less commonly used. </p>
			<p class="callout-heading">Special note</p>
			<p class="callout">If the resource class contains a method annotated with <strong class="source-inline">@GET</strong> but not <strong class="source-inline">@HEAD</strong>, the JAX-RS container would invoke the <strong class="source-inline">@GET</strong> method for matching HTTP <strong class="source-inline">HEAD</strong> requests, but it would remove the entity. Likewise, if a resource class contains any HTTP verb annotation other than <strong class="source-inline">@OPTIONS</strong>, the JAX-RS container would return a response indicating all of the valid verbs that could be matched for that request. Using the preceding example, an <strong class="source-inline">OPTIONS</strong> request would result in a response with a header such as <strong class="source-inline">Allow: DELETE, HEAD, GET, OPTIONS, PATCH, POST, PUT</strong>.</p>
			<p>This example also introduces the idea of HTTP parameters—specifically, <strong class="source-inline">@PathParam("word") String word;</strong>. </p>
			<p>This annotation can be placed on fields or method parameters. The value of <strong class="source-inline">@PathParm</strong> is <strong class="source-inline">word</strong>, which corresponds to the template variable in the resource class's <strong class="source-inline">@Path</strong> value (<strong class="source-inline">"/thesaurus/{word}"</strong>). This means that for an HTTP request such as <strong class="source-inline">http://localhost:9080/myApp/rest/thesaurus/funny</strong>, the value injected into the <strong class="source-inline">word</strong> field would be <strong class="source-inline">funny</strong>.</p>
			<p>There are other HTTP parameter types that can be used in JAX-RS, including <strong class="source-inline">@QueryParam</strong>, <strong class="source-inline">@FormParam</strong>, <strong class="source-inline">@CookieParam</strong>, <strong class="source-inline">@HeaderParam</strong>, and <strong class="source-inline">@MatrixParam</strong>, which all correspond to different parts of an HTTP request. JAX-RS also allows multiple HTTP parameter annotations to be aggregated on a single Java class and then referenced in the resource class or method as a <strong class="source-inline">@BeanParam</strong> parameter type. Here is an example<a id="_idIndexMarker300"/> of this:</p>
			<p class="source-code">public class ParamBean {</p>
			<p class="source-code">    private int id;</p>
			<p class="source-code">    @QueryParam("id")</p>
			<p class="source-code">    public void setId(int id) {</p>
			<p class="source-code">        this.id = id;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @HeaderParam("X-SomeHeader")</p>
			<p class="source-code">    public String someHeaderValue;</p>
			<p class="source-code">    @PathParam("path")</p>
			<p class="source-code">    public String pathParamValue;</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public String toString() {</p>
			<p class="source-code">        return "ID: " + id + " X-SomeHeader: "            + someHeaderValue + " path: " + pathParamValue;</p>
			<p class="source-code">    }</p>
			<p class="source-code">} </p>
			<p>The <strong class="source-inline">ParamBean</strong> bean<a id="_idIndexMarker301"/> is just a <strong class="bold">plain old Java object</strong> (<strong class="bold">POJO</strong>) with<a id="_idIndexMarker302"/> fields or setters annotated with other <strong class="source-inline">@*Param</strong> annotations. Then, this POJO is injected into a resource, like this:</p>
			<p class="source-code">@GET</p>
			<p class="source-code">@Path("/beanparam/{path}")</p>
			<p class="source-code">public Response get(@BeanParam ParamBean params) {</p>
			<p class="source-code">    return Response.ok(params.toString()).build();</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">@BeanParam</strong> beans can be very useful for aggregating common sets of RESTful parameters to avoid writing repetitive code. Let's test this example from the command line using <strong class="source-inline">curl</strong>, as follows:</p>
			<p class="source-code">$ curl "http://localhost:9080/rest/beanparam/  myPath?id=1234" -H "X-SomeHeader: MyHeaderValue"</p>
			<p class="source-code">ID: 1234 X-SomeHeader: MyHeaderValue path: myPath</p>
			<p>One thing to be wary of is that not all parameters will be non-null, so you will need to check for null values, or you can use the <strong class="source-inline">@DefaultValue</strong> annotation. This applies to method parameters as well. An example is provided here:</p>
			<p class="source-code">@GET public String get(@QueryParam("startPage") </p>
			<p class="source-code">@DefaultValue("1") Integer startPage) { // ...</p>
			<p>Notice that the value in the <strong class="source-inline">@DefaultValue</strong> annotation is always a string, but as long as it can be converted from a string to the parameter type (<strong class="source-inline">Integer</strong>, in this case), it will work. In the next section, we will learn how to convert data sent from a client into the Java objects in our application code.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor073"/>Entity providers and ParamConverter</h2>
			<p>So far, our resource methods have mainly been dealing with strings or other primitives. The JAX-RS container is responsible for serializing and deserializing those objects, but what if we want to send and receive more complex objects? In those cases, we may need to implement some <strong class="bold">entity providers</strong> and/or <strong class="source-inline">ParamConverter</strong>.</p>
			<h3>Entity providers</h3>
			<p>Entity providers <a id="_idIndexMarker303"/>include <strong class="source-inline">MessageBodyReader</strong> and <strong class="source-inline">MessageBodyWriter</strong>, and they are responsible for deserializing HTTP entity data to a Java object and serializing a Java object to an HTTP entity, respectively.  </p>
			<p>Let's say that we have a <strong class="source-inline">Person</strong> object such as this:</p>
			<p class="source-code">public class Person {</p>
			<p class="source-code">    public enum Color {</p>
			<p class="source-code">        RED, BLUE, YELLOW, GREEN, ORANGE, PURPLE</p>
			<p class="source-code">    }</p>
			<p class="source-code">    private String firstName;</p>
			<p class="source-code">    private String lastName;</p>
			<p class="source-code">    private int age;</p>
			<p class="source-code">    private Color favoriteColor;</p>
			<p class="source-code">    //public getters/setters</p>
			<p class="source-code">}</p>
			<p>And let's say that we have a <strong class="source-inline">service</strong> object such as this:</p>
			<p class="source-code">@Path("/person")</p>
			<p class="source-code">@Produces(MediaType.APPLICATION_JSON)</p>
			<p class="source-code">@Consumes(MediaType.APPLICATION_JSON)</p>
			<p class="source-code">public class PersonService {</p>
			<p class="source-code">    static List&lt;Person&gt; people = new ArrayList&lt;&gt;();</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    @Path("/{id}")</p>
			<p class="source-code">    public Person getPerson(@PathParam("id") int id) {</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            return people.get(id);</p>
			<p class="source-code">        } catch (IndexOutOfBoundsException ex) {</p>
			<p class="source-code">            throw new WebApplicationException               (Response.status(404).entity("ID " + id + "                 not found.").build());</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @POST</p>
			<p class="source-code">    public int postPerson(Person person) {</p>
			<p class="source-code">        people.add(person);</p>
			<p class="source-code">        return people.lastIndexOf(person);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>One thing to notice<a id="_idIndexMarker304"/> here is that the <strong class="source-inline">getPerson(…)</strong> method throws a new <strong class="source-inline">WebApplicationException</strong> exception, passing it as a <strong class="source-inline">404</strong> response. This is another way to map an exception to a response without needing an <strong class="source-inline">ExceptionMapper</strong> instance.</p>
			<p class="callout-heading">Best practice</p>
			<p class="callout">Use <strong class="source-inline">ExceptionMappers</strong> when multiple resource methods may throw the same exception. Throw a <strong class="source-inline">WebApplicationException</strong> exception with a passed-in <strong class="source-inline">Response</strong> object only in cases where you don't have an appropriate business exception to throw or you only throw the exception from one resource method.</p>
			<p>Another <a id="_idIndexMarker305"/>thing to notice is the use of <strong class="source-inline">APPLICATION_JSON</strong> as the media type that this resource produces and consumes. The <strong class="source-inline">application/json</strong> media type is the most common content type used in microservices. <strong class="bold">JSON</strong> is concise, human-readable, and easily processed by most programming <a id="_idIndexMarker306"/>languages. Here is an example of JSON representing the <strong class="source-inline">Person</strong> object from the previous sample code:</p>
			<p class="source-code">{</p>
			<p class="source-code"> "firstName": "John",</p>
			<p class="source-code"> "lastName": "Doe",</p>
			<p class="source-code"> "age": 33,</p>
			<p class="source-code"> "favoriteColor":"RED"</p>
			<p class="source-code">}</p>
			<p>In order for a client to create a new <strong class="source-inline">Person</strong> object via the <strong class="source-inline">POST</strong> method, we need a <strong class="source-inline">MessageBodyReader</strong> instance. There are some built-in readers that would handle this nicely, but for now, we'll write and register our own, like this (the full source code is available at <a href="https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonReader.java">https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonReader.java</a>): </p>
			<p class="source-code">@Provider</p>
			<p class="source-code">@Consumes(MediaType.APPLICATION_JSON)</p>
			<p class="source-code">public class MyJsonReader implements MessageBodyReader&lt;Person&gt; {</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public boolean isReadable(Class&lt;?&gt; type, Type         genericType, Annotation[] annotations, MediaType             mediaType) {</p>
			<p class="source-code">        return type.equals(Person.class) &amp;&amp;            mediaType.isCompatible(MediaType                 .APPLICATION_JSON_TYPE);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public Person readFrom(Class&lt;Person&gt; type,         Type genericType, Annotation[] annotations,             MediaType mediaType,</p>
			<p class="source-code">        MultivaluedMap&lt;String, String&gt; httpHeaders,           InputStream entityStream)</p>
			<p class="source-code">                 throws IOException, WebApplicationException {</p>
			<p class="source-code">        String s = new BufferedReader(new InputStreamReader             (entityStream)).lines().collect                 (Collectors.joining(" ")).trim();</p>
			<p class="source-code">        if (!s.startsWith("{") || !s.endsWith("}")) {</p>
			<p class="source-code">            throw new WebApplicationException(Response                 .status(400).build());</p>
			<p class="source-code">        }</p>
			<p class="source-code">        Person p = new Person();</p>
			<p class="source-code">        // ... parse string into Peron object ...</p>
			<p class="source-code">        return p;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Furthermore, in order to write a <strong class="source-inline">Person</strong> object as JSON in a response entity, we must register a<a id="_idIndexMarker307"/> JSON <strong class="source-inline">MessageBodyWriter</strong> instance, like this (the full source code is available at <a href="https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonWriter.java">https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonWriter.java</a>):</p>
			<p class="source-code">@Provider</p>
			<p class="source-code">@Produces(MediaType.APPLICATION_JSON)</p>
			<p class="source-code">public class MyJsonWriter implements </p>
			<p class="source-code">  MessageBodyWriter&lt;Person&gt; {</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public boolean isWriteable(Class&lt;?&gt; type, Type         genericType, Annotation[] annotations, MediaType             mediaType) {</p>
			<p class="source-code">        return type.equals(Person.class) &amp;&amp; mediaType             .isCompatible(MediaType.APPLICATION_JSON_TYPE);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public void writeTo(Person p, Class&lt;?&gt; type, Type         genericType, Annotation[] annotations, MediaType             mediaType, MultivaluedMap&lt;String, Object&gt;              httpHeaders, OutputStream entityStream)</p>
			<p class="source-code">        throws IOException, WebApplicationException {</p>
			<p class="source-code">            PrintStream ps = new PrintStream(entityStream);</p>
			<p class="source-code">            // print Person object to entity stream</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>These <a id="_idIndexMarker308"/>providers could easily be combined into one <strong class="source-inline">MyJsonEntityProvider</strong> class that implements both interfaces. Both implementations use <strong class="bold">input/output</strong> (<strong class="bold">I/O</strong>) streams<a id="_idIndexMarker309"/> to represent the entity—<strong class="source-inline">InputStream</strong> to read an entity from a client request and <strong class="source-inline">OutputStream</strong> for writing the response entity. Both providers have a Boolean check to verify that this is the proper entity provider to invoke—in addition to the generic type specified (<strong class="source-inline">Person</strong>) and the <strong class="source-inline">@Consumes</strong>/<strong class="source-inline">@Produces</strong> values, returning <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> for the <strong class="source-inline">isReadable</strong> or <strong class="source-inline">isWriteable</strong> methods will tell the JAX-RS container whether this provider should be used to serialize/deserialize the data. </p>
			<p>Another criterion for selecting among multiple providers would be the <strong class="source-inline">@Priority</strong> annotation—the JAX-RS container will select the provider with the highest priority (which is the lowest value—thus, <strong class="source-inline">@Priority(1)</strong> would be selected before <strong class="source-inline">@Priority(2)</strong>).</p>
			<p>Ultimately, the value returned from the reader's <strong class="source-inline">readFrom</strong> method will be injected into the resource method's <strong class="bold">entity parameter</strong>. An entity parameter<a id="_idIndexMarker310"/> is any method parameter that is not annotated with <strong class="source-inline">@Context</strong> (more on this in the <em class="italic">Context injection</em> section) or <strong class="source-inline">@*Param</strong>. A resource method may contain zero or one entity parameters—any more will result in a deployment failure.</p>
			<p>On the response side, the content written to the writer's <strong class="source-inline">writeTo</strong> entity stream will be written to the HTTP response sent back to the client.</p>
			<p>If the amount of code complexity for writing and reading JSON seems a little daunting at this point, don't fret! We'll cover a simpler approach in the next section.</p>
			<p>So, entity providers are responsible for serializing and deserializing HTTP entities to objects, but what about parameters such as query parameters, path parameters, and so on? These are deserialized with <strong class="source-inline">ParamConverter</strong></p>
			<h3>ParamConverter</h3>
			<p>Building<a id="_idIndexMarker311"/> on our <strong class="source-inline">PersonService</strong> example, let's add a <strong class="source-inline">PATCH</strong> method allowing clients to change a person's favorite color, as follows:</p>
			<p class="source-code">    @PATCH</p>
			<p class="source-code">    @Path("/{id}")</p>
			<p class="source-code">    public Person updateFavoriteColor(@PathParam("id") int         id, @QueryParam("color") Color color) { // ...</p>
			<p>We can invoke this method from the command line like this:</p>
			<p class="source-code">$ curl http://localhost:9080/rest/person/0?color=BLUE -X PATCH</p>
			<p class="source-code">{</p>
			<p class="source-code"> "firstName": "John",</p>
			<p class="source-code"> "lastName": "Doe",</p>
			<p class="source-code"> "age": 33,</p>
			<p class="source-code"> "favoriteColor":"BLUE"</p>
			<p class="source-code">}</p>
			<p>We are able to update <a id="_idIndexMarker312"/>John's favorite color because the JAX-RS container was able to identify that <strong class="source-inline">Color</strong> is an enumerated type, and so it will invoke its <strong class="source-inline">valueOf(String)</strong> method to get the <strong class="source-inline">Color</strong> object that it injects when invoking the <strong class="source-inline">updateFavoriteColor</strong> method. But what happens when we specify the <strong class="source-inline">color</strong> in lowercase? Let's have a look at the following output to find out:</p>
			<p class="source-code">$ curl http://localhost:9080/rest/person/0?color=blue -X PATCH -v</p>
			<p class="source-code">...</p>
			<p class="source-code">&lt; HTTP/1.1 404 Not Found</p>
			<p class="source-code">...</p>
			<p class="source-code">&lt;</p>
			<p>Uh oh! The JAX-RS container could not match the request to a resource method (resulting in a <strong class="source-inline">404 Not Found</strong> response) because it could not convert <strong class="source-inline">blue</strong> to <strong class="source-inline">Color.BLUE</strong>. In order for our service to be more resilient or to handle more complex objects as parameters, we must use <strong class="source-inline">ParamConverterProvider</strong> and <strong class="source-inline">ParamConverter</strong> like this:</p>
			<p class="source-code">@Provider</p>
			<p class="source-code">public class ColorParamConverterProvider implements   ParamConverterProvider {</p>
			<p class="source-code">  @Override</p>
			<p class="source-code">  public &lt;T&gt; ParamConverter&lt;T&gt; getConverter(Class&lt;T&gt;     rawType, Type genericType, Annotation[] annotations) {</p>
			<p class="source-code">    if (rawType.equals(Color.class)) {</p>
			<p class="source-code">        return (ParamConverter&lt;T&gt;) new ColorParamConverter();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return null;</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">ParamConverterProvider</strong> is <a id="_idIndexMarker313"/>responsible for returning an instance of a class that implements <strong class="source-inline">ParamConverter</strong>, such as this:</p>
			<p class="source-code">public class ColorParamConverter implements   ParamConverter&lt;Color&gt; {</p>
			<p class="source-code">  @Override</p>
			<p class="source-code">  public Color fromString(String value) {</p>
			<p class="source-code">    return Color.valueOf(value.toUpperCase());</p>
			<p class="source-code">  }</p>
			<p class="source-code">  @Override</p>
			<p class="source-code">  public String toString(Color value) {</p>
			<p class="source-code">    return value.name();</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The first class, <strong class="source-inline">ColorParamConverterProvider</strong>, is the registered provider class. When a resource method has a parameter that needs to be converted from <strong class="source-inline">String</strong> to an object, the JAX-RS container will invoke the <strong class="source-inline">getContainer</strong> method of any registered <strong class="source-inline">ParamConverterProvider</strong> class until one returns a non-null <strong class="source-inline">ParamConverter</strong> instance.</p>
			<p>The <strong class="source-inline">ColorParamConverter</strong> class <a id="_idIndexMarker314"/>simply capitalizes the string value to ensure that the enum's <strong class="source-inline">valueOf</strong> method will return the <strong class="source-inline">Color.BLUE</strong> color, regardless of whether the client request's query parameter was <strong class="source-inline">BLUE</strong>, <strong class="source-inline">Blue</strong>, <strong class="source-inline">blue</strong>, <strong class="source-inline">bLuE</strong>, and so on.</p>
			<p><strong class="source-inline">ParamConverter</strong> work for <strong class="source-inline">@QueryParam</strong> parameters as demonstrated, but also work for <strong class="source-inline">@CookieParam</strong>, <strong class="source-inline">@FormParam</strong>, <strong class="source-inline">@HeaderParam</strong>, <strong class="source-inline">@MatrixParam</strong>, and <strong class="source-inline">@PathParam</strong> parameters, and they can be used to convert a string to any object, and vice versa. The conversion from object to <strong class="source-inline">String</strong> is important on the client side. We'll discuss that in the <em class="italic">Consuming RESTful services with the MicroProfile Rest Client</em> section.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor074"/>Intercepting requests and responses</h2>
			<p>There may be times when you need to <a id="_idIndexMarker315"/>check the input stream of a request before or <a id="_idIndexMarker316"/>after processing it in the <strong class="source-inline">MessageBodyReader</strong> entity provider. Likewise, there may be times where you want to perform additional processing to the output stream before or after processing it in the <strong class="source-inline">MessageBodyWriter</strong> entity provider. <strong class="source-inline">ReaderInterceptors</strong> and <strong class="source-inline">WriterInterceptors</strong> are intended for such tasks. </p>
			<h3>ReaderInterceptors and WriterInterceptors</h3>
			<p>In our <strong class="source-inline">MessageBodyReader</strong> entity provider, we make a lot of calls to trim strings, which can be expensive in terms of performance. One way we might be able to reduce such calls would be to<a id="_idIndexMarker317"/> remove whitespace from the entity stream in a <strong class="source-inline">ReaderInterceptor</strong> provider so that then the <strong class="source-inline">MessageBodyReader</strong> provider could always assume that the stream contains no whitespace characters. Here's an example of this:</p>
			<p class="source-code">@Provider</p>
			<p class="source-code">public class WhiteSpaceRemovingReaderInterceptor implements   ReaderInterceptor {</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public Object aroundReadFrom(ReaderInterceptorContext       context) throws IOException, WebApplicationException {</p>
			<p class="source-code">        InputStream originalStream = context.getInputStream();</p>
			<p class="source-code">        String entity = // convert stream to string</p>
			<p class="source-code">        entity = entity.replaceAll("\\s","");</p>
			<p class="source-code">        context.setInputStream(new ByteArrayInputStream           (entity.getBytes()));</p>
			<p class="source-code">        return context.proceed();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>When a client sends a <a id="_idIndexMarker318"/>multiline request entity with spaces, line feeds, or other white space, you can see that this will convert them with the system output, as follows:</p>
			<p class="source-code">PRE: {</p>
			<p class="source-code"> "firstName": "John",</p>
			<p class="source-code"> "lastName": "Doe",</p>
			<p class="source-code"> "age": 33,</p>
			<p class="source-code"> "favoriteColor":"RED"</p>
			<p class="source-code">}</p>
			<p class="source-code">POST: {"firstName":"John","lastName":"Doe","age":33,  "favoriteColor":"RED"}</p>
			<p>A common use<a id="_idIndexMarker319"/> case for <strong class="source-inline">WriterInterceptors</strong> is to reduce the response entity size by using GZIP compression—see a full example of this at <a href="https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/GzipWriterInterceptor.java">https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/GzipWriterInterceptor.java</a>.</p>
			<p class="callout-heading">Special note about entity streams</p>
			<p class="callout">While you can read the entity<a id="_idIndexMarker320"/> stream from multiple places (entity providers, reader or writer interceptors, filters—we'll cover these shortly), you can run into problems when you do. For example, your initial request entity stream may not support re-reading, so if you attempt to read it twice, you may end up with an <strong class="source-inline">IOException</strong> exception. In that case, you may need to reset the stream (if the stream supports resetting—each JAX-RS container may be a little different) or copy and replace the stream entirely as we did in our <strong class="source-inline">ReaderInterceptor</strong> example.</p>
			<h3>Filters</h3>
			<p>Where <strong class="source-inline">ReaderInterceptors</strong> and <strong class="source-inline">WriterInterceptors</strong> intercept the reading and writing of entity streams, <strong class="bold">filters</strong> intercept <a id="_idIndexMarker321"/>the overall request and response. Filters enable some powerful cross-cutting abilities in RESTful applications. So, what can we use filters for? We could probably fill the rest of this book with useful examples, from managing authentication, authorizing requests, redirecting requests, managing headers, aborting invalid requests before wasting server resources on them, audit logging requests/responses, detecting suspicious activity, providing application statistics, tracing requests/responses, throttling requests from specific clients, and more.</p>
			<p>Let's start with an example that checks incoming requests for an API key and returns a useful response if none exists, if it is unrecognized, or if that API key has exceeded the maximum number of requests for the day (the full source code is available at <a href="https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/ApiKeyCheckFilter.java">https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/ApiKeyCheckFilter.java</a>). Have a look at the following code snippet:</p>
			<p class="source-code">@PreMatching</p>
			<p class="source-code">@Provider</p>
			<p class="source-code">public class ApiKeyCheckFilter implements </p>
			<p class="source-code">    ContainerRequestFilter {</p>
			<p class="source-code">    private final Map&lt;String, Integer&gt; apiInvocations = new </p>
			<p class="source-code">      ConcurrentHashMap&lt;&gt;();</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public void filter(ContainerRequestContext       requestContext) throws IOException {</p>
			<p class="source-code">        String apiKey = requestContext.getHeaderString            (API_KEY_HEADER);</p>
			<p class="source-code">        if (apiKey == null) {</p>
			<p class="source-code">            requestContext.abortWith(Response.status(              Status.UNAUTHORIZED).build());</p>
			<p class="source-code">            return;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        // get count of recent invocations for this API key </p>
			<p class="source-code">        int currentInvocations = // ...</p>
			<p class="source-code">        if (currentInvocations == -1) {</p>
			<p class="source-code">            requestContext.abortWith(                Response.status(Status.FORBIDDEN).build());</p>
			<p class="source-code">            return;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        if (currentInvocations &gt; MAX_REQUESTS_PER_INTERVAL) {</p>
			<p class="source-code">            requestContext.abortWith(                Response.status(Status.TOO_MANY_REQUESTS)                        .header(HttpHeaders.RETRY_AFTER, 5)                        .build());</p>
			<p class="source-code">            return;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This example checks that the client sent an API key as an HTTP header, that the API key is valid (by its existence in the map), and that the user's key has not exceeded their quota of requests. If any of these conditions occur, the filter will abort the request and return a response with useful data for the client. If the filter method exits normally, then the request will proceed, and the JAX-RS container will attempt to match the request to a resource class and method.</p>
			<p>Once the request has been matched to a resource method, the JAX-RS container will invoke post-match request filters. These <a id="_idIndexMarker322"/>filters are useful for performing <strong class="bold">cross-cutting concerns</strong> that are <a id="_idIndexMarker323"/>only applicable for valid requests. This could include audit logging (for tracking which RESTful APIs are used by which clients), custom authentication or authorization checks, more refined request validation, and so on. Post-match request filters implement <a id="_idIndexMarker324"/>the same interface (<strong class="source-inline">ContainerRequestFilter</strong>) as pre-match filters, but without the <strong class="source-inline">@PreMatching</strong> annotation. Post-match filters also enable more methods from the <strong class="source-inline">RequestContext</strong> object so that it knows which resource will be invoked. This is handy for situations where your filter may want to behave differently based on the resource class/method it will invoke.</p>
			<p>Response filters<a id="_idIndexMarker325"/> are similar to request filters<a id="_idIndexMarker326"/> but are invoked after the resource method has been completed. Response filters can then further refine or transform the response. They could add or modify response headers or cookies. They could also replace the response entity entirely, though a <strong class="source-inline">MessageBodyWriter</strong> provider and/or <strong class="source-inline">WriterInterceptor</strong> provider might be more appropriate for that.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor075"/>Dynamic providers</h2>
			<p>So far, all of the providers <a id="_idIndexMarker327"/>we have discussed will apply to all requests—or at least all matched requests—the only exception being entity providers, which will apply to all requests of the request's specified media type(s). But what if we want some providers to only be executed in certain circumstances, such as when a specific resource method is invoked or if the request contains specific content, or if the client's user is part of a special group? JAX-RS provides a few different mechanisms for more dynamic providers. First, we'll look at name binding.</p>
			<p><strong class="bold">Name binding</strong> allows<a id="_idIndexMarker328"/> users to place a custom annotation on one or more provider classes and one or more resource classes or methods. The JAX-RS container will then recognize that annotation and only invoke the provider if the target resource method or class is also annotated. For example, suppose we want to log certain requests; we might create an annotation like this:</p>
			<p class="source-code">@NameBinding</p>
			<p class="source-code">@Retention(RetentionPolicy.RUNTIME)</p>
			<p class="source-code">@Target({ElementType.METHOD, ElementType.TYPE})</p>
			<p class="source-code">public @interface Logged {}</p>
			<p>The <strong class="source-inline">@NameBinding</strong> annotation is what tells the JAX-RS container to pay attention to this annotation. We can now create a filter that logs the request method, the <strong class="bold">Uniform Resource Identifier</strong> (<strong class="bold">URI</strong>), and the<a id="_idIndexMarker329"/> request and response entity (the full source code is available at <a href="https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/dynamicbinding/LoggingFilter.java">https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/dynamicbinding/LoggingFilter.java</a>). Have a look at the following code snippet:</p>
			<p class="source-code">@Logged</p>
			<p class="source-code">@Provider</p>
			<p class="source-code">public class LoggingFilter implements </p>
			<p class="source-code">  ContainerRequestFilter, ContainerResponseFilter {</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public void filter(ContainerRequestContext       requestContext) throws IOException {</p>
			<p class="source-code">        int requestID = idCounter.incrementAndGet();</p>
			<p class="source-code">        requestContext.setProperty("request.id", requestID);</p>
			<p class="source-code">        System.out.println("&gt;&gt;&gt; " + requestID + " "            + requestContext.getRequest().getMethod() + " "             + requestContext.getUriInfo().getRequestUri()            + " " + getAndReplaceEntity(requestContext));</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public void filter(ContainerRequestContext         requestContext, ContainerResponseContext             responseContext)</p>
			<p class="source-code">            throws IOException {</p>
			<p class="source-code">        int requestID = (int) requestContext.getProperty             ("request.id");</p>
			<p class="source-code">        System.out.println("&lt;&lt;&lt; " + requestID + " "            + requestContext.getUriInfo().getRequestUri()            + " " + responseContext.getEntity());</p>
			<p class="source-code">    }</p>
			<p class="source-code">    //...</p>
			<p class="source-code">}</p>
			<p>This <strong class="source-inline">filter</strong> class is both a <a id="_idIndexMarker330"/>request and response filter. While it is very convenient to combine request and response filters (or perhaps even other provider types), it is important to note that the life-cycle behavior may change from one JAX-RS container to another. In general, it is considered a best practice not to store data in instance variables. If you want to store a piece of data from the request's filter method to be used in the response's filter method, a more portable approach would be to store that data in <strong class="source-inline">requestContext</strong> as a property, as <a id="_idIndexMarker331"/>we did for the request <strong class="bold">identifier</strong> (<strong class="bold">ID</strong>) in the preceding example.</p>
			<p>Now, we would just add the <strong class="source-inline">@Logged</strong> annotation to the classes (all methods in the class) or methods that should be logged, so in the following example, only the <strong class="source-inline">POST</strong> method would be logged (the full source code is available at <a href="https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/dynamicbinding/DynamicResource.java">https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/dynamicbinding/DynamicResource.java</a>):</p>
			<p class="source-code">@Path("/dynamic")</p>
			<p class="source-code">public class DynamicResource {</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    public String getMessage() { // ...</p>
			<p class="source-code">    @POST</p>
			<p class="source-code">    @Logged</p>
			<p class="source-code">    public String postMessage(String message) { // ...</p>
			<p class="source-code">}</p>
			<p>Another approach to dynamically apply providers is to use <strong class="bold">dynamic features</strong>. Dynamic features are providers themselves that determine, on each request, which providers to use. Dynamic features must implement one method, <strong class="source-inline">configure</strong>, which provides a <strong class="source-inline">ResourceInfo</strong> object that is used to determine specifics of the matched resource, and a <strong class="source-inline">FeatureContext</strong> object that is used to configure the providers and properties or view the application configuration for each request. The following example will add the <strong class="source-inline">LoggingFilter</strong> class to all resource methods that start with <strong class="source-inline">get</strong>:</p>
			<p class="source-code">@Provider</p>
			<p class="source-code">public class MyDynamicFeature implements DynamicFeature {</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public void configure(ResourceInfo resourceInfo,       FeatureContext context) {</p>
			<p class="source-code">        Method m = resourceInfo.getResourceMethod();</p>
			<p class="source-code">        if (m.getName().startsWith("get")) {</p>
			<p class="source-code">            context.register(LoggingFilter.class);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Since the <strong class="source-inline">ResourceInfo</strong> object <a id="_idIndexMarker332"/>will return the matched class and method, it is also possible to check the annotations of the matched resource. This makes it easy for dynamic features to register a provider for all requests of a specific HTTP verb (<strong class="source-inline">if (resourceInfo.getResourceMethod().getAnnotation(GET.class) != null) { //… </strong>) or methods with annotations that don't already have the <strong class="source-inline">@NameBinding</strong> annotation. </p>
			<p>Name binding annotations and dynamic filters are powerful ways to control request and response processing.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor076"/>Async</h2>
			<p>Enough with providers! Let's <a id="_idIndexMarker333"/>get back to the core of RESTful services—the resources. In many cases, the synchronous nature of the JAX-RS request/response flow is inefficient. For example, suppose your resources tend to pass a request to a data store that looks up or modifies data in a database. If your data store logic has a fixed set of threads performing the database operations, then when the service is under load, incoming requests may be queued. With the synchronous flow we've been working with so far, this means that the flow of execution would block inside the resource method waiting for the data-store logic to complete before completing the flow. This can be inefficient as one thread <a id="_idIndexMarker334"/>essentially waits for another to complete. That initial thread could be more efficient if it were to perform some other task while the data-store operations take place. Using <strong class="bold">asynchronous</strong> APIs in JAX-RS can obtain that increased efficiency.</p>
			<h3>AsyncResponse</h3>
			<p>Asynchronous methods in<a id="_idIndexMarker335"/> JAX-RS are created by adding an <strong class="source-inline">AsyncResponse</strong> parameter to the resource method, annotated with <strong class="source-inline">@Suspended</strong>. The <strong class="source-inline">AsyncResponse</strong> object may then be used to <em class="italic">resume</em> the request once the data has been fetched from the data store. Let's take a look at an example. Suppose we have a service that tracks people, like the one we used in the <em class="italic">Entity providers</em> section. We'll change the resource class around a little so that the data store access uses a separate <strong class="source-inline">Executor</strong> class to retrieve the data (the full source code is available at <a href="https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/AsyncPersonService.java">https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/AsyncPersonService.java</a>). Have a look at the following code snippet:</p>
			<p class="source-code">@Path("/person")</p>
			<p class="source-code">public class AsyncPersonService {</p>
			<p class="source-code">    static ExecutorService executor =         Executors.newFixedThreadPool(5);</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    @Path("sync/{id}")</p>
			<p class="source-code">    public Person getPersonSync(@PathParam("id") int id)       throws InterruptedException, ExecutionException {</p>
			<p class="source-code">        Future&lt;Person&gt; someData = executor.submit(() -&gt;            getPerson(id));</p>
			<p class="source-code">        return someData.get();</p>
			<p class="source-code">    }</p>
			<p class="source-code"> </p>
			<p class="source-code">    private Person getPerson(int id) {//...</p>
			<p class="source-code">}</p>
			<p>In this version of the code, the <strong class="source-inline">getPersonSync</strong> method will submit a request to the executor service to retrieve the <strong class="source-inline">Person</strong> object with the specified ID, then it will block until the executor service has completed the operation. In this case (for code simplicity), it is just pulling data out of a hash map, but if it were pulling data out of a remote database, the time spent blocking in the <strong class="source-inline">someData.get()</strong> call could be more substantial.</p>
			<p>So, let's try to improve the <a id="_idIndexMarker336"/>efficiency so that we don't have to block. We can rewrite the <strong class="source-inline">getPersonSync()</strong> method to look like this:</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    @Path("async/{id}")</p>
			<p class="source-code">    public void getPersonAsync(@PathParam("id") int id,</p>
			<p class="source-code">      @Suspended AsyncResponse ar) {</p>
			<p class="source-code">        executor.submit(() -&gt; {</p>
			<p class="source-code">            ar.resume(getPerson(id));</p>
			<p class="source-code">        });</p>
			<p class="source-code">    }</p>
			<p>Now, the executor service is invoking the <strong class="source-inline">getPerson(id)</strong> method, but then passing the result to <strong class="source-inline">ar.resume(…)</strong>, which will pick up the request/response flow where it left off and return a response. The request thread that invoked the <strong class="source-inline">getPersonAsync(…)</strong> method immediately returns and can be used to service another request.</p>
			<p>The <strong class="source-inline">AsyncResponse</strong> object can also be used to handle an exception. Let's say that we want to throw a <strong class="source-inline">NoSuchPersonException</strong> exception if the ID specified does not match any <strong class="source-inline">Person</strong> instance in the database. We might change the code to look like this:</p>
			<p class="source-code">executor.submit(() -&gt; {</p>
			<p class="source-code">    Optional&lt;Person&gt; p = Optional.ofNullable(getPerson(id));</p>
			<p class="source-code">    if (p.isPresent())</p>
			<p class="source-code">        ar.resume(p.get());</p>
			<p class="source-code">    else ar.resume(new NoSuchPersonException());</p>
			<p class="source-code">});</p>
			<p>When we resume a <a id="_idIndexMarker337"/>response with an exception, the JAX-RS container will attempt to map the exception to a suitable response, just as it does in the synchronous case. </p>
			<h3>Server-sent events</h3>
			<p>Another form of server-side async<a id="_idIndexMarker338"/> is <strong class="bold">server-sent events</strong> (<strong class="bold">SSEs</strong>). SSEs are a part of the <strong class="bold">HyperText Markup Language 5</strong> (<strong class="bold">HTML 5</strong>) specification and provide <a id="_idIndexMarker339"/>a way for a client to register and receive events asynchronously from a server.  </p>
			<p>JAX-RS has two ways of sending SSEs—streaming directly to each client and <strong class="bold">broadcasting</strong> to <a id="_idIndexMarker340"/>all clients. Let's take a look at how you might implement the first way, as follows (the full source code is available at <a href="https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/SseService.java">https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/SseService.java</a>):</p>
			<p class="source-code">@Path("/sse")</p>
			<p class="source-code">@Produces(MediaType.SERVER_SENT_EVENTS)</p>
			<p class="source-code">public class SseService {</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    public void stream3Events(@Context SseEventSink sink,                               @Context Sse sse) {</p>
			<p class="source-code">        Executors.newSingleThreadExecutor().submit(() -&gt; {</p>
			<p class="source-code">            try (SseEventSink sinkToClose = sink) {</p>
			<p class="source-code">                sink.send(sse.newEventBuilder()</p>
			<p class="source-code">                             .mediaType(TEXT_PLAIN_TYPE)</p>
			<p class="source-code">                             .data("foo")</p>
			<p class="source-code">                             .name("fooEvent")</p>
			<p class="source-code">                             .id("1")</p>
			<p class="source-code">                             .build());</p>
			<p class="source-code">                Thread.sleep(500);</p>
			<p class="source-code">                // repeat for 2/bar</p>
			<p class="source-code">                Thread.sleep(500);</p>
			<p class="source-code">                // repeat for 3/baz</p>
			<p class="source-code">            } catch (InterruptedException ex) {}</p>
			<p class="source-code">        });</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This is a <a id="_idIndexMarker341"/>contrived example, but it shows the method immediately returns after starting a new thread that sends a few text events to the client separated by a half-second delay. </p>
			<p>This example shows us that in order for a JAX-RS resource to send SSEs, it must produce the SSE media type (<strong class="source-inline">MediaType.SERVER_SENT_EVENTS</strong>, or <strong class="source-inline">text/event-stream</strong>) and the method must receive <strong class="source-inline">Sse</strong> and <strong class="source-inline">SseEventSink</strong> parameters, both annotated with <strong class="source-inline">@Context</strong>. The <strong class="source-inline">Sse</strong> type is a utility class that can create events and broadcasters. The <strong class="source-inline">SseEventSink</strong> type represents the connection between the server and the client, so calling the <strong class="source-inline">send(…)</strong> method sends a new event to that specific client, and calling the <strong class="source-inline">close()</strong> method (which is done implicitly by the try-with-resources logic) will gracefully close the connection with the client.</p>
			<p>The events we<a id="_idIndexMarker342"/> are sending have a <strong class="source-inline">text/plain</strong> media type—the media type is used to determine which <strong class="source-inline">MessageBodyWriter</strong> provider should be used to serialize that object passed to the data method. The <strong class="source-inline">name(…)</strong> and <strong class="source-inline">id(...)</strong> methods can provide additional context to each event sent. Only the <strong class="source-inline">data(…)</strong> method is required, though it is always a best practice to specify the media type.</p>
			<p>If we were to invoke this service using <strong class="source-inline">curl</strong>, we would see something like this:</p>
			<p class="source-code">$ curl http://localhost:9080/rest/sse</p>
			<p class="source-code">event: fooEvent</p>
			<p class="source-code">id: 1</p>
			<p class="source-code">data: foo</p>
			<p class="source-code">event: barEvent</p>
			<p class="source-code">id: 2</p>
			<p class="source-code">data: bar</p>
			<p class="source-code">event: bazEvent</p>
			<p class="source-code">id: 3</p>
			<p class="source-code">data: baz</p>
			<p>Another approach to sending events is to use a <strong class="bold">broadcaster</strong>. A broadcaster is basically a collection of <strong class="source-inline">SseEventSinks</strong>, and it will send events to all registered clients. Let's look at an example of code that we might add to our <strong class="source-inline">SseService</strong> class, as follows:</p>
			<p class="source-code">    static SseBroadcaster broadcaster;</p>
			<p class="source-code">    static ScheduledExecutorService executor =         Executors.newSingleThreadScheduledExecutor();</p>
			<p class="source-code">    private void startBroadcasting(Sse sse) {</p>
			<p class="source-code">        if (broadcaster == null) {</p>
			<p class="source-code">            broadcaster = sse.newBroadcaster(); //...</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    @Path("/broadcast")</p>
			<p class="source-code">    public void broadcast(@Context SseEventSink sink,                          @Context Sse sse) {</p>
			<p class="source-code">        startBroadcasting(sse);</p>
			<p class="source-code">        broadcaster.register(sink);</p>
			<p class="source-code">        broadcaster.broadcast(sse.newEventBuilder()</p>
			<p class="source-code">            .mediaType(TEXT_PLAIN_TYPE)</p>
			<p class="source-code">            .data("new registrant")</p>
			<p class="source-code">            .build());</p>
			<p class="source-code">    }</p>
			<p>As with the <a id="_idIndexMarker343"/>direct-stream approach, this approach also requires that the method produce a media type of <strong class="source-inline">SERVER_SENT_EVENTS</strong> and that the method has the <strong class="source-inline">SseEventSink</strong> and <strong class="source-inline">Sse</strong> parameter types.</p>
			<p>First, we need to set <strong class="source-inline">SseBroadcaster</strong> as a static field. We do this because the default life cycle for JAX-RS resources is per request. We will discuss alternate life cycles in the <em class="italic">Managing life cycle and DI with CDI</em> section—that will simplify this code and improve performance too.</p>
			<p>Once we have the broadcaster set, we then register the event sink with it. Once registered, the client associated with that event sink will receive all events sent from this broadcaster. In this example, we broadcast an event any time a new client is registered and every 5 seconds. Let's see what this looks like on the command line when using <strong class="source-inline">curl</strong> when we are the first client, and when a second client registers (from a separate command window), as follows:</p>
			<p class="source-code">$ curl http://localhost:9080/rest/sse/broadcast</p>
			<p class="source-code">    UnnamedEvent</p>
			<p class="source-code">data: new registrant</p>
			<p class="source-code">    UnnamedEvent</p>
			<p class="source-code">data: ping</p>
			<p class="source-code">    UnnamedEvent</p>
			<p class="source-code">data: ping </p>
			<p>One thing to notice about this output is the <strong class="source-inline">UnnamedEvent</strong> text—this is because SSEs must have a name, so if no name is provided when it is built, the JAX-RS container creates a name for it. Other JAX-RS containers may use a different name if none is specified.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor077"/>Context injection</h2>
			<p>We've already discussed injection when using the <strong class="source-inline">@Context</strong> annotation for SSE objects, but this annotation can be used for a lot more. <strong class="bold">Context injection</strong> can occur in both resources and providers. There<a id="_idIndexMarker344"/> are lots of useful things you can inject, as outlined here:</p>
			<ul>
				<li><strong class="source-inline">ResourceContext</strong>: Used for initializing sub-resource locators</li>
				<li><strong class="source-inline">ResourceInfo</strong>: Used for determining the matched resource class and method</li>
				<li><strong class="source-inline">HttpHeaders</strong>: Used for reading HTTP headers in the client request</li>
				<li><strong class="source-inline">SecurityContext</strong>: Used for determining the current user, their security role, and so on</li>
				<li><strong class="source-inline">UriInfo</strong>: Used for reading the URI of the client request</li>
				<li><strong class="source-inline">Application</strong>: Used for obtaining the application representing this RESTful service</li>
				<li><strong class="source-inline">Providers</strong>: Used for accessing other JAX-RS providers</li>
				<li><strong class="source-inline">Sse</strong> and <strong class="source-inline">SseEventSink</strong>: Discussed in<a id="_idIndexMarker345"/> the previous section<p class="callout-heading">Best practice</p><p class="callout">In most cases, it is recommended that context injection occurs in fields rather than as parameters. The reason for this is that the Jakarta REST project is intending to deprecate the <strong class="source-inline">@Context</strong> annotation in favor of CDI's <strong class="source-inline">@Inject</strong> annotation, which does not target method parameters.</p></li>
			</ul>
			<p><strong class="bold">Javadoc</strong> (<a href="https://jakarta.ee/specifications/restful-ws/2.1/apidocs/overview-summary.html">https://jakarta.ee/specifications/restful-ws/2.1/apidocs/overview-summary.html</a>) is the best <a id="_idIndexMarker346"/>resource for understanding the capabilities of each of these injectable types. Here are a few basic examples:</p>
			<p class="source-code">@Context</p>
			<p class="source-code">SecurityContext secCtx;</p>
			<p class="source-code">@GET</p>
			<p class="source-code">public Response getSomeData() {</p>
			<p class="source-code">    if (secCtx.isUserInRole("special")) {</p>
			<p class="source-code">        return getSpecialResponse();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return getNormalResponse();</p>
			<p class="source-code">} </p>
			<p>This example uses the role of the<a id="_idIndexMarker347"/> client's user principal to determine what entity response to return. The following example uses the <strong class="source-inline">ResourceInfo</strong> class to determine whether a <strong class="source-inline">MessageBodyWriter</strong> provider should be used or not:</p>
			<p class="source-code">@Provider</p>
			<p class="source-code">@Produces(MediaType.APPLICATION_JSON)</p>
			<p class="source-code">public class MySpecialJsonWriter implements   MessageBodyWriter&lt;Person&gt; {</p>
			<p class="source-code">    @Context</p>
			<p class="source-code">    ResourceInfo resInfo;</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public boolean isWriteable(Class&lt;?&gt; type, Type       genericType, Annotation[] annotations, MediaType        mediaType) {</p>
			<p class="source-code">        Class&lt;?&gt; resourceClass = resInfo.getResourceClass();</p>
			<p class="source-code">        return resourceClass.equals(SpecialResource.class)           &amp;&amp; type.equals(Person.class) &amp;&amp; mediaType             .isCompatible (APPLICATION_JSON_TYPE);</p>
			<p class="source-code">    }</p>
			<p>The injection of context objects into resources and providers enables us to develop powerful and flexible applications. Now, let's turn our attention to formatting the data our application will need to send and receive.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor078"/>Managing the payload with JSON-P and JSON-B</h1>
			<p>While RESTful services in general and JAX-RS applications specifically can serve entities of any media type (plain text, <strong class="bold">Extensible Markup Language</strong> (<strong class="bold">XML</strong>), <strong class="bold">Portable Document Format</strong> (<strong class="bold">PDF</strong>), binary, and so on), JSON is the <em class="italic">standard du jour</em> for cloud-native applications. JSON<a id="_idIndexMarker348"/> is popular because it is both human-readable and easily parsed— libraries for JSON parsing and binding exist in virtually all modern languages.</p>
			<p>In the <em class="italic">Entity providers</em> section, we got a taste of serializing and deserializing a Java object (<strong class="source-inline">Person</strong>) into JSON. In that section, we performed this by hand using string manipulation. While a manual approach can work, we're now going to discuss two APIs that enable simpler and more powerful control over JSON in Java.</p>
			<p>JSON-P<a id="_idIndexMarker349"/> is a programmatic API for manipulating JSON, while JSON-B is a declarative (annotation-based) API for quickly and easily mapping an object to JSON or vice versa.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor079"/>JSON-P</h2>
			<p><strong class="bold">JSON-P</strong> has an <a id="_idIndexMarker350"/>object model API similar to the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) for XML <a id="_idIndexMarker351"/>processing and a streaming API similar to<a id="_idIndexMarker352"/> the <strong class="bold">Streaming API for XML</strong> (<strong class="bold">StAX</strong>). Like their XML equivalents, the object model is better suited for making frequent changes or for using smaller documents as it is processed in memory. The streaming API is best suited for reading larger JSON documents or event-based processing. Both<a id="_idIndexMarker353"/> APIs can be used together, and the streaming API's parser will return objects such as <strong class="source-inline">JsonObject</strong>, <strong class="source-inline">JsonArray</strong>, and so on, which are part of the object model API.</p>
			<p>Let's say we have some objects such as these:</p>
			<p class="source-code">public class Starship {</p>
			<p class="source-code">    private String name;</p>
			<p class="source-code">    private boolean hasHyperdrive;</p>
			<p class="source-code">    private List&lt;Weapon&gt; weapons;</p>
			<p class="source-code">    private int speedRating;</p>
			<p class="source-code">    //with public getters and setters</p>
			<p class="source-code">}</p>
			<p class="source-code">public class Weapon {</p>
			<p class="source-code">    private String name;</p>
			<p class="source-code">    private String type;</p>
			<p class="source-code">    private int damageRating;</p>
			<p class="source-code">    //with public getters and setters</p>
			<p class="source-code">}</p>
			<p>And let's say we want<a id="_idIndexMarker354"/> to convert that into JSON content that looks like this:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "name": "Coreillian Freighter",</p>
			<p class="source-code">  "hasHyperdrive": true,</p>
			<p class="source-code">  "speedRating": 22,</p>
			<p class="source-code">  "weapons": [</p>
			<p class="source-code">    {</p>
			<p class="source-code">      "name":"Quad Blaster Turret",</p>
			<p class="source-code">      "type":"Laser",</p>
			<p class="source-code">      "damageRating":24</p>
			<p class="source-code">    }</p>
			<p class="source-code">  ]</p>
			<p class="source-code">}</p>
			<p>We'll start out by converting an instance of <strong class="source-inline">Starship</strong> into a JSON string. We can do this by using the <strong class="source-inline">Json</strong> class to create object builders and array builders. These builders can create objects by adding properties or objects. So, to create the JSON for a starship, we would need an object builder for the starship and for each weapon, and then an array builder for all of the weapons. An example of this is available at <a href="https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/jsonp/JsonpConverter.java">https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/jsonp/JsonpConverter.java</a>.</p>
			<p>Each object needs its<a id="_idIndexMarker355"/> own <strong class="source-inline">JsonObjectBuilder</strong> instance, and each array or collection needs its own <strong class="source-inline">JsonArrayBuilder</strong> instance. Then, you simply add items to them.</p>
			<p>Deserializing a JSON string into an object works in the opposite way. First, you must extract <strong class="source-inline">JsonObject</strong> instance from <strong class="source-inline">JsonReader</strong>, like so:</p>
			<p class="source-code">JsonReader reader = Json.createReader(new StringReader(json));</p>
			<p class="source-code">JsonObject shipObject = reader.readObject();</p>
			<p>Then, you must create a <strong class="source-inline">Starship</strong> instance and populate it from the properties in the <strong class="source-inline">JsonObject</strong>, like this:</p>
			<p class="source-code">Starship ship = new Starship();</p>
			<p class="source-code">ship.setName(shipObject.getString("name"));</p>
			<p class="source-code">ship.setHasHyperdrive(shipObject.getBoolean</p>
			<p class="source-code">  ("hasHyperdrive"));</p>
			<p class="source-code">//...</p>
			<p>This approach uses the object model, which requires loading the entire JSON stream into memory before it can be converted into an object. For small JSON files, this is not an issue, and it allows the model to be stored in memory and re-accessed. It also allows the model to be changed over time before writing the JSON back to a stream.</p>
			<p>The streaming approach requires far less memory and is capable of reading extremely large JSON streams without running out of memory. It accomplishes this by firing events as it reads the JSON and then discards that portion of the JSON. This is very efficient and performs better than the object model, but it requires more complex coding, and since the object model is not in memory, you cannot go back later to ask it: <em class="italic">Now, what was the value again?</em></p>
			<p>Using the same Java object and JSON stream as before, here is what the serialization code looks like (the full source code is available at <a href="https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/jsonp/JsonpStreamingConverter.java">https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/jsonp/JsonpStreamingConverter.java</a>):</p>
			<p class="source-code">StringWriter sw = new StringWriter();</p>
			<p class="source-code">JsonGenerator generator = Json.createGenerator(sw);</p>
			<p class="source-code">generator.writeStartObject()</p>
			<p class="source-code">         .write("name", ship.getName())</p>
			<p class="source-code">         .write("hasHyperdrive", ship.isHasHyperdrive())</p>
			<p class="source-code">         .write("speedRating", ship.getSpeedRating())</p>
			<p class="source-code">         .writeStartArray("weapons");</p>
			<p class="source-code">for (Weapon w : ship.getWeapons()) {</p>
			<p class="source-code">    generator.writeStartObject()</p>
			<p class="source-code">             .write("name", w.getName())</p>
			<p class="source-code">             .write("type", w.getType())</p>
			<p class="source-code">             .write("damageRating", w.getDamageRating())</p>
			<p class="source-code">             .writeEnd();</p>
			<p class="source-code">}</p>
			<p class="source-code">generator.writeEnd()</p>
			<p class="source-code">         .writeEnd();</p>
			<p class="source-code">generator.close();</p>
			<p>Similar to <strong class="source-inline">JsonObjectBuilder</strong> and <strong class="source-inline">JsonArrayBuilder</strong>, <strong class="source-inline">JsonGenerator</strong> can pass in map-like values to<a id="_idIndexMarker356"/> build the JSON object. Unlike the object model builder APIs, <strong class="source-inline">JsonGenerator</strong> cannot make changes—once the JSON is written, you cannot change the values. Both of the builders have <strong class="source-inline">remove</strong> methods, and the <strong class="source-inline">JsonArrayBuilder</strong> API has setter methods, allowing you to change previously configured values. The reason for having these two approaches is to allow you to make a decision between flexibility and efficiency.</p>
			<p>For parsing JSON into an<a id="_idIndexMarker357"/> object, a stream-based approach is even more complex, as we can see here:</p>
			<p class="source-code">Starship ship = new Starship();</p>
			<p class="source-code">JsonParser parser = Json.createParser(new StringReader(json));</p>
			<p class="source-code">while (parser.hasNext()) {</p>
			<p class="source-code">    Event event = parser.next();</p>
			<p class="source-code">    if (event == Event.KEY_NAME) {</p>
			<p class="source-code">    String keyName = parser.getString();</p>
			<p class="source-code">    parser.next();</p>
			<p class="source-code">    switch(keyName) {</p>
			<p class="source-code">    case "name": ship.setName(parser.getString()); break;</p>
			<p class="source-code">    //...</p>
			<p class="source-code">    case "weapons": ship.setWeapons(parseWeapons(parser)); </p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The parser works similar to a Java iterator, returning events to indicate things such as object start (<strong class="source-inline">{</strong>), object end (<strong class="source-inline">}</strong>), array start (<strong class="source-inline">[</strong>), array end (<strong class="source-inline">]</strong>), key names (for example, <strong class="source-inline">name</strong> and <strong class="source-inline">speedRating</strong>), and key values (for example, <strong class="source-inline">Coreillian Freighter</strong> and <strong class="source-inline">24</strong>). It is important that each event is interpreted within its context. For example, an array might contain several objects, so it is necessary to keep track of which object is currently being parsed to avoid mixing up data. The <strong class="source-inline">parseWeapons</strong> method provides an example of this by separately parsing each item in the array, as illustrated in the following code snippet:</p>
			<p class="source-code">private List&lt;Weapon&gt; parseWeapons (JsonParser parser) {</p>
			<p class="source-code">   List&lt;Weapon&gt; weapons = new ArrayList&lt;&gt;();</p>
			<p class="source-code">   Event event = null;</p>
			<p class="source-code">   while ((event = parser.next()) != Event.END_ARRAY) {</p>
			<p class="source-code">      Weapon w = new Weapon();</p>
			<p class="source-code">      while (event != Event.END_OBJECT) {</p>
			<p class="source-code">         if (event == Event.KEY_NAME) {</p>
			<p class="source-code">             String keyName = parser.getString();</p>
			<p class="source-code">             parser.next();</p>
			<p class="source-code">             switch(keyName) {</p>
			<p class="source-code">             case "name": w.setName(parser.getString()); //...</p>
			<p class="source-code">             }</p>
			<p class="source-code">         }</p>
			<p class="source-code">         event = parser.next();</p>
			<p class="source-code">      }</p>
			<p class="source-code">      weapons.add(w);</p>
			<p class="source-code">   }</p>
			<p class="source-code">   return weapons;</p>
			<p class="source-code">}</p>
			<p>JSON-P provides a very<a id="_idIndexMarker358"/> powerful API set for reading and writing JSON programmatically. The code can tend to be a tad verbose, though. That's something that JSON-B can help with.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor080"/>JSON-B</h2>
			<p>While<a id="_idIndexMarker359"/> JSON-P is very powerful and flexible, <strong class="bold">JSON-B</strong> is very simple and efficient at serializing and deserializing objects to JSON. JSON-B has some programmatic APIs but overall, it takes a declarative approach to writing/reading JSON. This means that the conversion of an object to JSON will be based on the object type's getter methods—and likewise, the conversion of JSON to object will be based on the object type's setter methods.</p>
			<p>If we use the example objects of <strong class="source-inline">Starships</strong> and <strong class="source-inline">Weapons</strong> from JSON-P, the conversion of object to JSON and vice versa is very simple, as is illustrated here:</p>
			<p class="source-code">StringWriter sw = new StringWriter();</p>
			<p class="source-code">Jsonb jsonb = JsonbBuilder.create();</p>
			<p class="source-code">jsonb.toJson(ship, sw);</p>
			<p class="source-code">String json = sw.getBuffer().toString();</p>
			<p>It is possible to convert directly to a string but using <strong class="source-inline">OutputStream</strong> or <strong class="source-inline">Writer</strong> is preferable, especially when dealing with large JSON objects. The primary objects here are <strong class="source-inline">Jsonb</strong> and the <strong class="source-inline">toJson(…)</strong> method. You can see the output here:</p>
			<p class="source-code">{"hasHyperdrive":true,"name":"Coreillian Freighter","speedRating":22,"weapons":[{"damageRating":24,"name":"Quad Blaster Turret","type":"Laser"}]}</p>
			<p>This looks very<a id="_idIndexMarker360"/> similar to what we created using JSON-P, but it's all on one line and difficult to distinguish where one object ends and the next begins. For most JSON consumers that should not be a problem, but if we want to make it more human-readable, we can add some configuration by replacing the <strong class="source-inline">JsonbBuilder.create()</strong> method call with the following code:</p>
			<p class="source-code">Jsonb jsonb = JsonbBuilder.create(</p>
			<p class="source-code">    new JsonbConfig().withFormatting(true));</p>
			<p>This will produce the following output:</p>
			<p class="source-code">{</p>
			<p class="source-code">    "hasHyperdrive": true,</p>
			<p class="source-code">    "name": "Coreillian Freighter",</p>
			<p class="source-code">    "speedRating": 22,</p>
			<p class="source-code">    "weapons": [</p>
			<p class="source-code">        {</p>
			<p class="source-code">            "damageRating": 24,</p>
			<p class="source-code">            "name": "Quad Blaster Turret",</p>
			<p class="source-code">            "type": "Laser"</p>
			<p class="source-code">        }</p>
			<p class="source-code">    ]</p>
			<p class="source-code">}</p>
			<p>There are several other configuration options that you could use to handle the serialization of a Java object.  For example, you could also add your own <strong class="bold">deserializers</strong> to provide some customization for certain objects. Deserializers<a id="_idIndexMarker361"/> work by allowing you to use a <strong class="source-inline">JsonParser</strong> from JSON-P to convert the object to JSON your own way.</p>
			<p>Converting JSON back into an object is just as simple, as we can see here:</p>
			<p class="source-code"><strong class="source-inline">Starship shipFromJson = jsonb.fromJson(json,Starship.class);</strong></p>
			<p>And as with the <strong class="source-inline">toJson(…)</strong> method, you can use a string or a stream.</p>
			<p>So, what happens if<a id="_idIndexMarker362"/> you have an object, but you want the JSON fields to have a different name than the Java property name? Or, maybe you don't want certain fields to be exposed as JSON at all? That's where annotations such as <strong class="source-inline">@JsonbProperty("someOtherName")</strong> and <strong class="source-inline">@JsonbTransient</strong> come in handy, and depending on where you place the annotation, it will have a different effect. If the annotation is on the getter, then it will only apply to serialization (conversion from Java to JSON). If the annotation is on the setter, then it will only apply deserialization. If the annotation is on the field itself, then it will apply to both. Let's consider the following code snippet:</p>
			<p class="source-code">public class Person {</p>
			<p class="source-code">    private String firstName;</p>
			<p class="source-code">    @JsonbTransient</p>
			<p class="source-code">    private String middleName;</p>
			<p class="source-code">    @JsonbProperty("familyName")</p>
			<p class="source-code">    private String lastName;</p>
			<p class="source-code">    private String favoriteColor;</p>
			<p class="source-code">    private int age;</p>
			<p class="source-code">    //...all other public unannotated getters/setters</p>
			<p class="source-code">    @JsonbProperty("favouriteColour")</p>
			<p class="source-code">    public String getFavoriteColor() {</p>
			<p class="source-code">        return favoriteColor;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @JsonbProperty("yearsOld")</p>
			<p class="source-code">    public void setAge(int age) {</p>
			<p class="source-code">        this.age = age;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We would create an<a id="_idIndexMarker363"/> instance of <strong class="source-inline">Person</strong> and print it out to JSON, like so:</p>
			<p class="source-code">Person p = new Person();</p>
			<p class="source-code">p.setFirstName("John");</p>
			<p class="source-code">p.setMiddleName("Tiberius");</p>
			<p class="source-code">p.setLastName("Doe");</p>
			<p class="source-code">p.setFavoriteColor("Green");</p>
			<p class="source-code">p.setAge(25);</p>
			<p class="source-code">String jsonPerson = jsonb.toJson(p);</p>
			<p class="source-code">System.out.println(jsonPerson);</p>
			<p>The output would look like this:</p>
			<p class="source-code">{</p>
			<p class="source-code">    "age": 25,</p>
			<p class="source-code">    "familyName": "Doe",</p>
			<p class="source-code">    "favouriteColour": "Green",</p>
			<p class="source-code">    "firstName": "John"</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">lastName</strong> field has been converted to <strong class="source-inline">familyName</strong>, the <strong class="source-inline">middleName</strong> field has not been printed at all, and the <strong class="source-inline">favoriteColor</strong> field has been Britishized to <strong class="source-inline">favouriteColour</strong>. But <a id="_idIndexMarker364"/>if we tried to create a new <strong class="source-inline">Person</strong> instance from this JSON, we would get an incomplete <strong class="source-inline">Person</strong> instance. Let's take a look, as follows:</p>
			<p class="source-code">Person p2 = jsonb.fromJson(jsonPerson, Person.class);</p>
			<p class="source-code">System.out.println(p2.getFirstName());</p>
			<p class="source-code">System.out.println(p2.getMiddleName());</p>
			<p class="source-code">System.out.println(p2.getLastName());</p>
			<p class="source-code">System.out.println(p2.getFavoriteColor());</p>
			<p class="source-code"><strong class="source-inline">System.out.println(p2.getAge());</strong></p>
			<p>This would yield the following output:</p>
			<p class="source-code">John</p>
			<p class="source-code">null</p>
			<p class="source-code">Doe</p>
			<p class="source-code">null</p>
			<p class="source-code">0</p>
			<p>The <strong class="source-inline">middleName</strong> field was missing from the JSON, so it is no surprise that it is null. Since the <strong class="source-inline">@JsonbProperty("favouriteColour")</strong> annotation is only on the getter, JSON-B will not convert the Britishized JSON field to the Americanized Java field. And since the <strong class="source-inline">@JsonbProperty("yearsOld")</strong> annotation is applied to the <strong class="source-inline">setAge(…)</strong> method, it will not be set since the JSON is still using the <strong class="source-inline">age</strong> field name.</p>
			<p>The behavior differences depending on where an annotation is placed are important to note when using JSON-B.</p>
			<p>Now, let's tie this back to <a id="_idIndexMarker365"/>JAX-RS. The JAX-RS specification says that a product that supports JSON-P must supply <strong class="source-inline">MessageBodyReaders</strong> and <strong class="source-inline">MessageBodyWriters</strong> for entity types of <strong class="source-inline">JsonStructure</strong>, <strong class="source-inline">JsonObject</strong>, <strong class="source-inline">JsonArray</strong>, <strong class="source-inline">JsonString</strong>, and <strong class="source-inline">JsonNumber</strong>. Furthermore, a product that supports JSON-B must supply <strong class="source-inline">MessageBodyReaders</strong> and <strong class="source-inline">Writers</strong> for any object type when the media type is <strong class="source-inline">application/json</strong>, <strong class="source-inline">text/json</strong>, <strong class="source-inline">*/json</strong>, <strong class="source-inline">or</strong> <strong class="source-inline">*/*+json</strong>. Any product that implements the entire MicroProfile set of specifications will have JAX-RS, JSON-P, and JSON-B. This means that for the most part, you can count on your JAX-RS container to handle the conversion of JSON to objects and back to JSON.</p>
			<p>Now we've learned the easy way to work with JSON, let's learn how we can send requests and consume results using the client APIs.</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor081"/>Consuming RESTful services with the MicroProfile Rest Client</h1>
			<p>Thus far, we've covered how we<a id="_idIndexMarker366"/> can design <a id="_idIndexMarker367"/>elaborate RESTful services and how we can easily transform JSON into Java objects and vice versa. Next up, we need to consume those services using the client APIs. In a microservice architecture, RESTful clients are critical for invoking remote services.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor082"/>JAX-RS Client APIs</h2>
			<p>One way to consume <a id="_idIndexMarker368"/>RESTful services is with the <strong class="bold">JAX-RS Client APIs</strong>. Similar to JSON-P (as opposed to JSON-B), these APIs tend to be more programmatic with more control over individual options, such as headers, path construction, and so on. Let's take a look at some code using the thesaurus example from earlier in this chapter, as follows:</p>
			<p class="source-code">String uri = "http://localhost:9080/rest/thesaurus";</p>
			<p class="source-code">Client client = ClientBuilder.newBuilder().build();</p>
			<p class="source-code">WebTarget target = client.target(uri).path(word);</p>
			<p class="source-code">Builder builder = target.request(MediaType.TEXT_PLAIN);</p>
			<p class="source-code">try (Response response = builder.get()) {</p>
			<p class="source-code">    int status = response.getStatus();</p>
			<p class="source-code">    assert status == 200;</p>
			<p class="source-code">} finally {</p>
			<p class="source-code">    client.close();</p>
			<p class="source-code">}</p>
			<p>The client instance is built using <strong class="source-inline">ClientBuilder</strong>. In this example, it simply builds a <strong class="source-inline">Client</strong> instance, but you could use <strong class="source-inline">ClientBuilder</strong> to set configuration properties or register client-side providers. <strong class="source-inline">Client</strong> instances should be explicitly closed when you are done using them—they currently do not implement the <strong class="source-inline">AutoCloseable</strong> interface, but a future version of the JAX-RS specification will add that, allowing <strong class="source-inline">Client</strong> instances to be closed in a try-with-resources block.</p>
			<p><strong class="source-inline">WebTarget</strong> represents the<a id="_idIndexMarker369"/> destination of the client request. It has methods for appending path elements, resolving path template variables, adding query or matrix parameters, or specifying the expected response media type. In the previous example, we append the <strong class="source-inline">word</strong> variable to the <strong class="source-inline">uri</strong> variable with this line of code: </p>
			<p class="source-code">WebTarget target = client.target(uri).path(word);</p>
			<p>Alternatively, we could change the <strong class="source-inline">uri</strong> variable to <strong class="source-inline">http://localhost:9080/rest/thesaurus/{word}</strong>, then we could use the following line of code:</p>
			<p class="source-code">WebTarget target = client.target(uri).resolveTemplate   ("word", word);</p>
			<p>Depending on the situation, either might be more usable.</p>
			<p>An <strong class="source-inline">Invocation.Builder</strong> object is created by calling the <strong class="source-inline">request(…)</strong> method on the <strong class="source-inline">WebTarget</strong>—an optional media type parameter is used to determine what media type is expected for the response; it will set the <strong class="source-inline">Accept</strong> header. The <strong class="source-inline">Invocation.Builder</strong> object has methods such as <strong class="source-inline">get(…)</strong>, <strong class="source-inline">post(…)</strong>, <strong class="source-inline">put(…)</strong>, <strong class="source-inline">delete(…)</strong>, and other methods that represent the HTTP verb to use for the request. You can use the <strong class="source-inline">method(…)</strong> method to specify HTTP verbs that are not built into the API. It also has methods for setting cookies or headers.</p>
			<p>The <strong class="source-inline">Invocation.Builder</strong> object also has <strong class="source-inline">async()</strong> and <strong class="source-inline">rx()</strong> methods that will return an asynchronous invoker and reactive invoker, respectively. These invokers enable users to retrieve the response asynchronously, which will generally improve performance.</p>
			<p>The <strong class="source-inline">Response</strong> object represents the HTTP response from the remote server. From the <strong class="source-inline">Response</strong> object, you can check the status code of the response (<strong class="source-inline">200</strong>, <strong class="source-inline">204</strong>, <strong class="source-inline">400</strong>, <strong class="source-inline">404</strong>, <strong class="source-inline">500</strong>, and so on) and response headers, read the response entity, and more. Note that the <strong class="source-inline">Response</strong> object is <strong class="source-inline">AutoCloseable</strong>—it is always a good practice to close both <strong class="source-inline">Response</strong> and <strong class="source-inline">Clientobjects</strong>.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor083"/>MicroProfile Rest Client</h2>
			<p>If the JAX-RS Client is similar to <a id="_idIndexMarker370"/>JSON-P, then the <strong class="bold">MicroProfile Rest Client</strong> API is similar to JSON-B. It uses annotations and a declarative approach to specify the HTTP endpoint and the entity object, header, and other data to be sent with the request. The MicroProfile Rest Client is type-safe, so the remote service is represented by a Java interface that is annotated similar to server-side JAX-RS resources—with <strong class="source-inline">@Path</strong>, <strong class="source-inline">@GET</strong>, <strong class="source-inline">@PUT</strong>, <strong class="source-inline">@POST</strong>, <strong class="source-inline">@DELETE</strong>, and so on, annotations. The MicroProfile Rest Client implementation provides an instance of the interface, which you can then invoke in order to invoke the remote service.</p>
			<p>Let's take a look at an example, as follows (the full source code is available at <a href="https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/ThesaurusClient.java">https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/ThesaurusClient.java</a>):</p>
			<p class="source-code">@Path("/thesaurus/{word}")</p>
			<p class="source-code">@Consumes(MediaType.TEXT_PLAIN)</p>
			<p class="source-code">@Produces(MediaType.TEXT_PLAIN)</p>
			<p class="source-code">public interface ThesaurusClient {</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    String getSynonymsFor(@PathParam("word") String word)        throws NoSuchWordException;</p>
			<p class="source-code">    @POST</p>
			<p class="source-code">    String setSynonymsFor(@PathParam("word") String word,         String synonyms) throws WordAlreadyExistsException;</p>
			<p class="source-code">    // other methods matching ThesaurusResource ...</p>
			<p class="source-code">}</p>
			<p>The methods here match the five resource methods in the <strong class="source-inline">ThesaurusResource</strong> class, with the exception that the <strong class="source-inline">@PathParam</strong> parameter is a method parameter. These methods all return a <strong class="source-inline">String</strong> object, but they could also return a <strong class="source-inline">Response</strong> object if it was important to view things in the response such as headers or status code, and so on. Usually, these things can be abstracted so that you can return the actual data type. This interface approach<a id="_idIndexMarker371"/> allows us to invoke the service by simply calling these methods. But first, we need to build an instance of this client. If we are in an environment that uses CDI (see the next section) and MicroProfile Config (see <a href="B17377_05_Final_SB_epub.xhtml#_idTextAnchor091"><em class="italic">Chapter 5</em></a>, <em class="italic">Enhancing Cloud-Native Applications</em>), then the framework can automatically build and inject the client instance. Otherwise (or if you just want to build the instance programmatically), you can use the <strong class="source-inline">RestClientBuilder</strong> API, like so:</p>
			<p class="source-code">ThesaurusClient thesaurus = RestClientBuilder.newBuilder()  .baseUri(URI.create("http://localhost:9080/rest"))</p>
			<p class="source-code">            .build(ThesaurusClient.class);</p>
			<p>This sets <strong class="source-inline">baseUri</strong>, the URI path up to the point where the <strong class="source-inline">@Path</strong> annotation is added. Similar to the JAX-RS <strong class="source-inline">ClientBuilder</strong> API, we could also use the <strong class="source-inline">RestClientBuilder</strong> API to specify properties for the client instance or register providers. Once we've built the client instance, we can invoke it like so:</p>
			<p class="source-code">thesaurus.getSynonymsFor(word);</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor084"/>Client-side providers</h2>
			<p>That's a nice way to<a id="_idIndexMarker372"/> invoke the service—a lot less code and it reads easier too! You might be thinking: <em class="italic">That method throws an exception—how does the implementation know when it should throw it?</em> Excellent question! The answer is <strong class="source-inline">ResponseExceptionMapper</strong>. It is basically the converse of JAX-RS <strong class="source-inline">ExceptionMapper</strong>—instead of mapping an exception to a response, they map a response to an exception. By default, MicroProfile Rest Client implementations will throw a <strong class="source-inline">WebApplicationException</strong> on any response with a status code of <strong class="source-inline">400</strong> or higher— those codes are client errors or server errors. To map more specific responses to exceptions, you would need to register one or more <strong class="source-inline">ResponseExceptionMapper</strong>, such as the following:</p>
			<p class="source-code">public class NoSuchWordResponseMapper implements     ResponseExceptionMapper&lt;NoSuchWordException&gt; {</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public boolean handles(int status,MultivaluedMap&lt;String,       Object&gt; headers) {</p>
			<p class="source-code">        return status == 404;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public NoSuchWordException toThrowable(Response resp) {</p>
			<p class="source-code">        return new NoSuchWordException();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This response exception mapper implements two methods. The first, <strong class="source-inline">handles(…)</strong>, is used to inform the client implementation of whether it should use this mapper for the current response. If it returns <strong class="source-inline">true</strong>, then the client implementation will invoke the <strong class="source-inline">toThrowable(…)</strong> method to obtain the exception it should throw. If the <strong class="source-inline">handles(…)</strong> method returns <strong class="source-inline">false</strong>, then the client implementation will check any other registered response exception mappers before assuming that the response was successful and simply <a id="_idIndexMarker373"/>returning a valid value to the client caller rather than throwing an exception. </p>
			<p class="callout-heading">Special note</p>
			<p class="callout">The <strong class="source-inline">toThrowable(…)</strong> method should <em class="italic">return</em> the exception, not throw it. The client implementation will actually throw the exception; it just needs to know which exception to throw.</p>
			<p>As with server-side providers, client-side providers need to be registered. There are two ways to register client providers. First, you can register them from the <strong class="source-inline">RestClientBuilder</strong> API before building the client, as illustrated in the following code snippet:</p>
			<p class="source-code">ThesaurusClient thesaurus = RestClientBuilder.newBuilder()  .baseUri(URI.create("http://localhost:9080/rest"))</p>
			<p class="source-code">            .register(NoSuchWordResponseMapper.class)</p>
			<p class="source-code">            .build(ThesaurusClient.class);</p>
			<p>A second way to register a client provider is to use one or more <strong class="source-inline">@RegisterProvider</strong> annotations on the client interface, like this:</p>
			<p class="source-code">@RegisterProvider(NoSuchWordResponseMapper.class)</p>
			<p class="source-code">public interface ThesaurusClient { //...</p>
			<p>You can register as many of the same types of providers on the client side as you would on the server, including <strong class="source-inline">MessageBodyReader</strong> and <strong class="source-inline">Writer</strong>, <strong class="source-inline">Reader</strong>, and <strong class="source-inline">WriterInterceptors</strong>. You may not register <strong class="source-inline">ExceptionMappers</strong> or server-side filters (<strong class="source-inline">ContainerRequestFilter</strong> or <strong class="source-inline">ContainerResponseFilter</strong>). You may, however, register client-side filters (<strong class="source-inline">ClientRequestFilter</strong> or <strong class="source-inline">ClientResponseFilter</strong>)—they work in much the same way as server-side filters.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The <strong class="source-inline">ClientRequestFilter</strong> filter's <strong class="source-inline">ClientRequestContext</strong> has an <strong class="source-inline">abortWith(Response)</strong> method similar to the <strong class="source-inline">ContainerRequestFilter</strong> filter. This method can be useful in test code for mocking different server responses.  </p>
			<p>All of these client-side providers will work with either client, the JAX-RS Client and the MicroProfile Rest Client, except for <strong class="source-inline">ResponseExceptionMapper</strong>—these will only work with the MicroProfile Rest Client.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor085"/>Async</h2>
			<p>Both JAX-RS Client and the<a id="_idIndexMarker374"/> MicroProfile Rest Client are capable of invoking services asynchronously. This is perhaps even more powerful on the client than on the server, as a client will often run in resource-constrained environments and may be called upon to perform multiple requests in order to achieve its goal.</p>
			<p>The JAX-RS Client invokes services asynchronously by creating an <strong class="source-inline">AsyncInvoker</strong> instance that will produce <strong class="source-inline">java.util.concurrent.Future</strong> objects that reference the response objects or allow the user to specify an <strong class="source-inline">InvocationCallback</strong> that is notified when the response is available (or if there was an exception during the request/response). Here is an example of the <strong class="source-inline">Future</strong> approach:</p>
			<p class="source-code">AsyncInvoker invoker = builder.async();</p>
			<p class="source-code">Future&lt;Response&gt; future = invoker.get();</p>
			<p class="source-code">// do something else while waiting for the response...</p>
			<p class="source-code">try (Response response = future.get()) {</p>
			<p class="source-code">    // handle response...</p>
			<p class="source-code">} finally {</p>
			<p class="source-code">    client.close();</p>
			<p class="source-code">}</p>
			<p>This code looks very similar to the synchronous code from earlier in this section and makes for a very simple way to perform asynchronous client requests. Next, let's see how we would use <strong class="source-inline">InvocationCallbacks</strong>, as follows (the full source code for this and the <strong class="source-inline">Future</strong> approach is available at <a href="https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/JAXRSClient.java">https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/JAXRSClient.java</a>):</p>
			<p class="source-code">String uri = "http://localhost:9080/rest/thesaurus";</p>
			<p class="source-code">Client client = ClientBuilder.newBuilder().build();</p>
			<p class="source-code">for (String word : words) {</p>
			<p class="source-code">    WebTarget target = client.target(uri).path(word);</p>
			<p class="source-code">    Builder builder = target.request(MediaType.TEXT_PLAIN);</p>
			<p class="source-code">    AsyncInvoker invoker = builder.async();</p>
			<p class="source-code">    invoker.get(new InvocationCallback&lt;String&gt;() {</p>
			<p class="source-code">        @Override</p>
			<p class="source-code">        public void completed(String response) {</p>
			<p class="source-code">            sb.append(response + "\n");</p>
			<p class="source-code">        }</p>
			<p class="source-code">        @Override</p>
			<p class="source-code">        public void failed(Throwable th) {</p>
			<p class="source-code">            th.printStackTrace();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    });</p>
			<p class="source-code">}</p>
			<p>This example shows<a id="_idIndexMarker375"/> how you might look up multiple words. It sends multiple requests in parallel to the server, and the <strong class="source-inline">completed</strong> method of <strong class="source-inline">InvocationCallback</strong> is invoked when the response is available.</p>
			<p>Asynchronous requests in the MicroProfile Rest Client are slightly different. The client interface methods must return <strong class="source-inline">CompletionStage</strong> that wraps the intended return type. So, we would modify our client interface to look like this (the full source code is available at <a href="https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/ThesaurusAsyncClient.java">https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/ThesaurusAsyncClient.java</a>):</p>
			<p class="source-code">@Path("/thesaurus/{word}")</p>
			<p class="source-code">@RegisterProvider(NoSuchWordResponseMapper.class)</p>
			<p class="source-code">@Consumes(MediaType.TEXT_PLAIN)</p>
			<p class="source-code">@Produces(MediaType.TEXT_PLAIN)</p>
			<p class="source-code">public interface ThesaurusAsyncClient {</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    CompletionStage&lt;String&gt; getSynonymsFor(@PathParam       ("word") String word);</p>
			<p class="source-code">    @POST</p>
			<p class="source-code">    CompletionStage&lt;String&gt;setSynonymsFor       (@PathParam("word") String word, String synonyms);</p>
			<p class="source-code">    //...similar methods for PUT, DELETE, and PATCH</p>
			<p class="source-code">}</p>
			<p>Notice that none of <a id="_idIndexMarker376"/>these methods declare that they throw any exceptions. That is because any exception processing occurs after the processing of the returned <strong class="source-inline">CompletionStage</strong>. This is how we might invoke this client:</p>
			<p class="source-code">StringBuffer sb = new StringBuffer();</p>
			<p class="source-code">CountDownLatch latch = new CountDownLatch(wordsArr.length);</p>
			<p class="source-code">ThesaurusAsyncClient client = RestClientBuilder.newBuilder()</p>
			<p class="source-code">    .baseUri(URI.create("http://localhost:9080/rest"))</p>
			<p class="source-code">    .register(NoSuchWordResponseMapper.class)</p>
			<p class="source-code">    .build(ThesaurusAsyncClient.class);</p>
			<p class="source-code">Arrays.stream(wordsArr).parallel()</p>
			<p class="source-code">                       .map(client::getSynonymsFor)</p>
			<p class="source-code">                       .forEach(cs -&gt; {</p>
			<p class="source-code">    cs.exceptionally(t -&gt; {</p>
			<p class="source-code">        t.printStackTrace();</p>
			<p class="source-code">        return "unable to complete request";</p>
			<p class="source-code">    }).thenAccept(s -&gt; {</p>
			<p class="source-code">        sb.append(s + "\n");</p>
			<p class="source-code">        latch.countDown();</p>
			<p class="source-code">    });</p>
			<p class="source-code">});</p>
			<p class="source-code">latch.await(5, TimeUnit.SECONDS);</p>
			<p>Like the JAX-RS Client callback example, this example looks up the synonyms for multiple words simultaneously. By using <strong class="source-inline">CompletionStage</strong>, we can easily handle exceptions or perform additional processing inline.</p>
			<p>Remember another form of asynchronous operations is SSEs. The JAX-RS Client APIs allow you to receive events in the form of <strong class="source-inline">InboundSseEvent</strong> objects. The MicroProfile Rest Client goes a step further <a id="_idIndexMarker377"/>and allows you to receive events using <strong class="bold">Reactive Streams</strong> <strong class="source-inline">Publisher</strong> objects. The events can be <strong class="source-inline">InboundSseEvent</strong> objects that allow you to read extra metadata on each event or as a specific Java type, so long as you have <strong class="source-inline">MessageBodyReader</strong> to convert the event into that type.</p>
			<p>If we want to consume the SSE events from the service we wrote at the end of the <em class="italic">Building a RESTful Service with Jakarta REST</em> section, we might write a client interface that looks something like this:</p>
			<p class="source-code">@Path("/sse")</p>
			<p class="source-code">@Produces(MediaType.SERVER_SENT_EVENTS)</p>
			<p class="source-code">public interface SseClient {</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    Publisher&lt;String&gt; receiveSSEs();</p>
			<p>The client interface is simple enough, right? So, this is how you might use it (the full source code is available at <a href="https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/MPSseConsumerResource.java">https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/MPSseConsumerResource.java</a>): </p>
			<p class="source-code">client.receiveSSEs().subscribe(new Subscriber&lt;String&gt;() {</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public void onSubscribe(Subscription s) {</p>
			<p class="source-code">        s.request(3);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public void onNext(String s) {</p>
			<p class="source-code">        // handle event</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public void onError(Throwable t) {</p>
			<p class="source-code">        // exception while processing event</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public void onComplete() {</p>
			<p class="source-code">        // done receiving events</p>
			<p class="source-code">    }</p>
			<p class="source-code">});</p>
			<p>Once the <strong class="source-inline">Publisher</strong> is returned from the client interface, a caller can subscribe to it and control the flow of the SSEs via the <strong class="source-inline">request(int)</strong> method of <strong class="source-inline">Subscription</strong>. The <strong class="source-inline">onNext</strong> callback method is invoked for each new event (so long as it has been requested). The <strong class="source-inline">onError</strong> callback is invoked when an error occurs (for example, not being able to find a <strong class="source-inline">MessageBodyReader</strong> that can deserialize the event). The <strong class="source-inline">onComplete</strong> callback is invoked when the connection with the server has been closed.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor086"/>Propagating HTTP headers from server to client</h2>
			<p>Quite often, you<a id="_idIndexMarker378"/> may need to construct a RESTful service that needs to consume other RESTful services. This might be part of a gateway or delegation pattern, or it may be that your service needs to aggregate other services such as the following service, where a vacation service may need to make reservations for airlines, hotels, entertainment venues, and so on:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/Figure_4.2_-_B17377.jpg" alt="Figure 4.2 – Aggregating service&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Aggregating service</p>
			<p>In these situations, it is often useful to propagate headers from the original request to the delegated requests. For example, suppose you want to reuse the authentication credentials sent on the original request when making the subsequent requests; the MicroProfile Rest Client has some built-in mechanisms that make this easy to do.</p>
			<p>First, you must annotate your client interface with <strong class="source-inline">@RegisterClientHeaders</strong> and then specify a comma-separated list of headers that the container should automatically propagate in a <a id="_idIndexMarker379"/>MicroProfile Config property, like so:</p>
			<p class="source-code">org.eclipse.microprofile.rest.client.propagateHeaders=Authorization,X-RequestID</p>
			<p>Next, you can specify headers declaratively in the client interface, like this:</p>
			<p class="source-code">@RegisterRestClient</p>
			<p class="source-code">@ClientHeaderParam(name="AgentID", value="Bob's Travel Co.")</p>
			<p class="source-code">public interface AirlineReservationClient {</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    Reservation getReservation(String reservationID);</p>
			<p class="source-code">    @POST</p>
			<p class="source-code">    @ClientHeaderParam(name = "RequestID", value = "{newId}")</p>
			<p class="source-code">    String makeReservation(Reservation r);</p>
			<p class="source-code">    default String newId() {</p>
			<p class="source-code">        return UUID.randomUUID().toString();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this code, the <strong class="source-inline">AgentID</strong> header with the hardcoded value <strong class="source-inline">Bob's Travel Co.</strong> would be sent on every request from this client since the <strong class="source-inline">@ClientHeaderParam</strong> annotation is applied to the interface. When the <strong class="source-inline">makeReservation</strong> method is invoked, the MicroProfile Rest Client implementation will invoke the <strong class="source-inline">newId</strong> method to obtain the value of the <strong class="source-inline">RequestID</strong> header—the value of the header is the return value of a method<a id="_idIndexMarker380"/> because the annotation value is surrounded by curly braces.</p>
			<p>Both of these approaches allow headers to be sent without needing to modify the signature of the client interface method.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor087"/>Managing life cycle and DI with CDI</h1>
			<p>By default, JAX-RS<a id="_idIndexMarker381"/> resources are created for each request. While this might be <a id="_idIndexMarker382"/>useful in some cases, it would be far more efficient if they were singletons. That way, we wouldn't be creating new object instances (an expensive operation) for each request, and we wouldn't be generating excess garbage after the request is completed.</p>
			<p>While we could create an <strong class="source-inline">Application</strong> subclass that returns the resources via the <strong class="source-inline">getSingletons()</strong> method, that would prevent the container from automatically discovering and registering resources and providers. Another reason to avoid that approach is that the <strong class="source-inline">getSingletons()</strong> method is deprecated in a future version of JAX-RS and will eventually be removed.</p>
			<p>Instead, we can use <strong class="bold">Context and Dependency Injection </strong>(<strong class="bold">CDI</strong>). CDI uses annotations to allow developers to <a id="_idIndexMarker383"/>declaratively manage object life cycles and perform injections of fields, constructors, and setter methods. </p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor088"/>Scopes</h2>
			<p>CDI has several built-in <strong class="bold">scopes</strong> for <a id="_idIndexMarker384"/>declaring an object's life cycle. Some of the more common scopes are <strong class="source-inline">@ApplicationScoped</strong>, <strong class="source-inline">@RequestScoped</strong>, and <strong class="source-inline">@Dependent</strong>. As you can probably guess, an object annotated with <strong class="source-inline">@ApplicationScoped</strong> will <em class="italic">live</em> for the lifetime of the application, while <a id="_idIndexMarker385"/>an object annotated with <strong class="source-inline">@RequestScoped</strong> will only live for the lifetime of a single request.</p>
			<p>The <strong class="source-inline">@Dependent</strong> annotation is a little special. Basically, objects annotated with it will inherit the scope of the object it is injected into. In the case of JAX-RS resource classes that are not really<a id="_idIndexMarker386"/> injected into anything, it inherits the scope of the JAX-RS container. For resource objects, that is <strong class="bold">per request</strong>, but for provider objects, that is <strong class="bold">per application</strong>.  </p>
			<p>This means that we can annotate our JAX-RS resource classes with <strong class="source-inline">@ApplicationScoped</strong> and then we can get rid of those pesky static fields and just use normal instance fields.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor089"/>Injection</h2>
			<p>DI is another<a id="_idIndexMarker387"/> powerful piece of CDI. Using annotations, you can specify your dependencies and let the container handle all of the wiring. In the most basic cases where you want to inject a class or an instance of an interface where there is only one managed bean implementation of that interface, you can use <strong class="source-inline">@Inject</strong>, and CDI does the rest.</p>
			<p>Let's take a look at an example. Suppose we have a class like this that we want to inject (the full source code for all CDI examples can be found at <a href="https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/cdi">https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/cdi</a>):</p>
			<p class="source-code">public interface MyDependency {</p>
			<p class="source-code">    int getInstanceId();</p>
			<p class="source-code">}</p>
			<p class="source-code">@RequestScoped</p>
			<p class="source-code">public class MyDependencyImpl implements MyDependency {</p>
			<p class="source-code">    static AtomicInteger COUNTER = new AtomicInteger();</p>
			<p class="source-code">    private final int instanceId = COUNTER.getAndIncrement();</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public int getInstanceId() {</p>
			<p class="source-code">        return instanceId;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We have a <a id="_idIndexMarker388"/>request-scoped bean that, when instantiated, will have a unique instance ID. Now, let's say that we want to inject it into a JAX-RS resource class that is managed by CDI, but we want the resource class to be application-scoped for better performance. It might look like this:</p>
			<p class="source-code">@ApplicationScoped</p>
			<p class="source-code">@Path("/cdi")</p>
			<p class="source-code">public class MyCdiResource {</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    MyDependency dependency;</p>
			<p class="source-code">    //...</p>
			<p class="source-code">}</p>
			<p>This object, <strong class="source-inline">MyCdiResource</strong>, will only be instantiated once for the lifetime of the application, with no extra object creation or excess garbage. But the <strong class="source-inline">MyDependency</strong> object that is injected is <strong class="bold">request-scoped</strong>, meaning that for each request where it is accessed, CDI will create a new instance. We can see this when we invoke a <strong class="source-inline">GET</strong> method that returns the dependency instance ID, as the dependency's instance ID increments on each request, as illustrated here:</p>
			<p class="source-code">$ curl http://localhost:9080/rest/cdi</p>
			<p class="source-code">1</p>
			<p class="source-code">$ curl http://localhost:9080/rest/cdi</p>
			<p class="source-code">2</p>
			<p class="source-code">$ curl http://localhost:9080/rest/cdi</p>
			<p class="source-code">3</p>
			<p>There may be times where you want to create your own bean that is injected. CDI provides a mechanism where you would use the <strong class="source-inline">@Produces</strong> annotation (same name but different package as the JAX-RS <strong class="source-inline">@Produces</strong> annotation for specifying media types). To use this, you would apply this annotation to a method on a CDI-managed bean; the object returned by that method will be injected appropriately. Let's see how this would look in a code<a id="_idIndexMarker389"/> example, as follows:</p>
			<p class="source-code">@ApplicationScoped</p>
			<p class="source-code">public class SomeOtherBean {</p>
			<p class="source-code">    @Produces</p>
			<p class="source-code">    public MyProducedDependency produceDependency() {</p>
			<p class="source-code">        return new MyProducedDependency(Math.random() * 10);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">@ApplicationScoped</p>
			<p class="source-code">@Path("/cdi")</p>
			<p class="source-code">public class MyCdiResource {</p>
			<p class="source-code">    //...</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    MyProducedDependency producedDependency;</p>
			<p class="source-code">    //...</p>
			<p class="source-code">}</p>
			<p>And in this case, since the <strong class="source-inline">MyCdiResource</strong> class is annotated with <strong class="source-inline">@ApplicationScoped</strong>, the <strong class="source-inline">MyProducedDependency</strong> object is only built and injected once for the lifetime of the application. If we were to change <strong class="source-inline">MyCdiResource</strong> to be <strong class="source-inline">@RequestScoped</strong>, then the random number would change for each request. The <strong class="source-inline">producer</strong> method is invoked when needed by the <em class="italic">consuming</em> bean.</p>
			<p>So, what happens if you have more than one possible bean to inject? Your application may fail to start with a <strong class="source-inline">DeploymentException</strong> exception, indicating ambiguous dependencies. To<a id="_idIndexMarker390"/> resolve this, you can either use the <strong class="source-inline">@Named</strong> annotation or <em class="italic">qualifier</em> annotations.</p>
			<p>The <strong class="source-inline">@Named</strong> annotation may look something like this:</p>
			<p class="source-code">@ApplicationScoped</p>
			<p class="source-code">@Named("max")</p>
			<p class="source-code">public class MyOtherDependencyImpl implements MyDependency {</p>
			<p class="source-code">    //...</p>
			<p class="source-code">}</p>
			<p class="source-code">@ApplicationScoped</p>
			<p class="source-code">@Path("/cdi")</p>
			<p class="source-code">public class MyCdiResource {</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    @Named("max")</p>
			<p class="source-code">    MyDependency dependency;</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">@Named</strong> annotation with the same value, <strong class="source-inline">max</strong>, is applied to both the implementation class <em class="italic">and</em> the injection point.</p>
			<p>Qualifiers are a little more complex but add more flexibility. It first involves the creation of a new annotation, like this:</p>
			<p class="source-code">@Documented</p>
			<p class="source-code">@Retention(RetentionPolicy.RUNTIME)</p>
			<p class="source-code">@Qualifier</p>
			<p class="source-code">public @interface Minimal { }</p>
			<p>Then, we just add that annotation on both the class and injection target, like so:</p>
			<p class="source-code">@ApplicationScoped</p>
			<p class="source-code">@Minimal</p>
			<p class="source-code">public class MyThirdDependencyImpl implements MyDependency {</p>
			<p class="source-code">    //...</p>
			<p class="source-code">}</p>
			<p class="source-code">@ApplicationScoped</p>
			<p class="source-code">@Path("/cdi")</p>
			<p class="source-code">public class MyCdiResource {</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    @Minimal</p>
			<p class="source-code">    MyDependency dependency;</p>
			<p class="source-code">}</p>
			<p>Qualifiers can be used more extensively in other CDI artifacts such as interceptors and portable extensions. One<a id="_idIndexMarker391"/> such extension is built into the MicroProfile Rest Client implementation, which allows client instances to be built and injected into your CDI beans. It uses the <strong class="source-inline">@RestClient</strong> qualifier. For this to work, you would need to add the <strong class="source-inline">@RegisterRestClient</strong> annotation to the client interface. With this annotation, you can also specify the <strong class="source-inline">baseUri</strong> path. Alternatively, you could use MicroProfile Config to specify the <strong class="source-inline">baseUri</strong> path and other configuration options for the client instance. Here's what it might look like:</p>
			<p class="source-code">@Path("/thesaurus/{word}")</p>
			<p class="source-code">@RegisterProvider(NoSuchWordResponseMapper.class)</p>
			<p class="source-code">@RegisterRestClient(baseUri = "http://localhost:9080/rest")</p>
			<p class="source-code">public interface ThesaurusClient {</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    String getSynonymsFor(@PathParam("word") String word)        throws NoSuchWordException;</p>
			<p class="source-code">    //...</p>
			<p class="source-code">}</p>
			<p>Then, we could inject the client instance and use it like so:</p>
			<p class="source-code">@ApplicationScoped</p>
			<p class="source-code">@Path("/cdi")</p>
			<p class="source-code">public class MyCdiResource {</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    @RestClient</p>
			<p class="source-code">    ThesaurusClient thesaurusClient;</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    @Path("/thesaurus/{word}")</p>
			<p class="source-code">    public String lookup(@PathParam("word") String word) {</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            return thesaurusClient.getSynonymsFor(word);</p>
			<p class="source-code">        } catch (NoSuchWordException ex) {</p>
			<p class="source-code">            return "Sorry, that word is not found.";</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p>While it might <a id="_idIndexMarker392"/>seem silly to create a RESTful service that then uses a client to access a different RESTful service in the same application, the principle is very common for microservice architecture. This service could be a gateway for the real thesaurus service, or perhaps the complete thesaurus is split across several <strong class="bold">virtual machines</strong> (<strong class="bold">VMs</strong>). The ability to provide or consume RESTful services where those services' life cycles and dependencies are managed declaratively can be very powerful indeed.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor090"/>Summary</h1>
			<p>In this chapter, we've learned how to create and consume basic and complex RESTful services using industry-standard APIs such as JAX-RS, CDI, JSON-P, JSON-B, and the MicroProfile Rest Client. We've learned that some of these APIs provide very concise and type-safe approaches, while others provide additional flexibility at the cost of increased code complexity. Having completed this chapter, we can now create fully functioning micro-services utilizing REST and JSON. We can also improve the efficiency of these services by using asynchronous clients and appropriate life-cycle scopes. </p>
			<p>In the next chapter, we will explore how we can improve the configurability and robustness of these services with other MicroProfile APIs.</p>
		</div>
	</body></html>