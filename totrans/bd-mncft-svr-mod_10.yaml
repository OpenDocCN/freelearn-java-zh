- en: Chapter 10. The Bukkit Scheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Bukkit scheduler is a very powerful tool, and it is easy to learn how to
    use it. It allows you to create repetitive tasks such as saving data. It also
    allows you to delay how long until a block of code is executed. The Bukkit scheduler
    can also be used to asynchronously compute lengthy tasks. This means that a task
    such as writing data to a file or downloading a file to the server can be scheduled
    to run on a separate thread to prevent the main thread, and thus the game, from
    lagging. In this chapter, you will learn how to do each of these by continuing
    to work on the `Warper` teleportation plugin, as well as creating a new plugin
    called `AlwaysDay`. This new plugin will ensure that it is always daytime on the
    server by repeatedly setting the time to noon. This chapter will cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a `BukkitRunnable` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding synchronous and asynchronous tasks and when they should be used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a task from a `BukkitRunnable` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling a delayed task from a `BukkitRunnable` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling a repeating task from a `BukkitRunnable` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a plugin called `AlwaysDay` that uses a repeating task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a delayed task to the `Warper` plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronously executing code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a BukkitRunnable class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by creating the `AlwaysDay` plugin. The code that we will write
    for this plugin will be put inside the `onEnable` method. The first step to creating
    a scheduled task is to create a `BukkitRunnable` class. This class will comprise
    very few lines of code. Therefore, it is not necessary to create a whole new Java
    file for it. For this reason, we will create a class within the `onEnable` method.
    This can be done using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, this code would be valid since you are constructing a new instance
    of a class. However, `BukkitRunnable` is an **abstract class**, which means that
    it cannot be instantiated. The purpose of an **abstract class** is to provide
    some base code that other classes can **extend** and build on top of. An example
    of this is the `JavaPlugin` class. For each plugin that you created, you started
    with a class that extends `JavaPlugin`. This allows you to override methods, such
    as `onEnable`, while keeping the current code of other methods, such as `getConfig`.
    This is similar to implementing an Interface, such as Listener. The difference
    between an abstract class and an interface is its purpose. As mentioned earlier,
    an abstract class is a base for other classes to extend. An interface is more
    of an outline within which classes can implement. Interfaces do not include code
    within any of their methods and therefore, all methods within an interface must
    have an implementation. For an abstract class, only the methods defined as `abstract`
    must be overridden because they do not include code within them. Therefore, because
    `BukkitRunnable` is an abstract class, you will be given a warning that will ask
    you to implement all the abstract methods. NetBeans can automatically add the
    needed methods for you. The new method that is added for you is `run`. This method
    will be called when the scheduler runs your task. For the new `AlwaysDay` plugin,
    we want the task to set each world''s time to noon, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember that time on a Minecraft server is measured in ticks. 20 ticks is
    equivalent to 1 second. The measurement of ticks is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '0 ticks: Dawn'
  prefs: []
  type: TYPE_NORMAL
- en: '6,000 ticks: Noon'
  prefs: []
  type: TYPE_NORMAL
- en: '12,000 ticks: Dusk'
  prefs: []
  type: TYPE_NORMAL
- en: '18,000 ticks: Midnight'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the API documentation for the `BukkitRunnable` class at [https://hub.spigotmc.org/javadocs/spigot/org/bukkit/scheduler/BukkitRunnable.html](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/scheduler/BukkitRunnable.html).
    Note that there are six ways to run this task, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: runTask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: runTaskAsynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: runTaskLater
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: runTaskLaterAsynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: runTaskTimer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: runTaskTimerAsynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronous versus asynchronous tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A task can be run either synchronously or asynchronously. Simply put, when a
    synchronous task is executed, it must be completed before the server can continue
    running normally. An asynchronous task can run in the background while the server
    continues to function. If a task accesses the Bukkit API in any way, then it should
    be run synchronously. For this reason, you will rarely run a task asynchronously.
    An advantage that an asynchronous task gives is that it can be completed without
    causing your server to lag. For example, writing data to a save file can be done
    asynchronously. Later in this chapter, we will modify the `Warper` plugin to save
    its data asynchronously. As for the `AlwaysDay` plugin, we must run the task synchronously
    because it accesses the Minecraft server.
  prefs: []
  type: TYPE_NORMAL
- en: Running a task from a BukkitRunnable class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Calling `runTask` or `runTaskAsynchronously` on a `BukkitRunnable` class will
    cause the task to run immediately. The only time you are likely to use this is
    to run a synchronous task from an asynchronous context or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Running a task later from a BukkitRunnable class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Calling `runTaskLater` or `runTaskLaterAsynchronously` on a `BukkitRunnable`
    class will delay the task from being executed for a specific amount of time. The
    amount of time is measured in ticks. Remember that there are 20 ticks in every
    second. In the `Warper` plugin, we will add a warp delay so that the player is
    teleported 5 seconds after running the warp command. We will accomplish this by
    running the task later.
  prefs: []
  type: TYPE_NORMAL
- en: Running a task timer from a BukkitRunnable class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Calling `runTaskTimer` or `runTaskTimerAsynchronously` on a `BukkitRunnable`
    class will repeat the task every specified number of ticks. The task will repeat
    until it is canceled. Task timers can also be delayed to offset the initial run
    of the task. A task timer can be used to periodically save data, but for now,
    we will use this type of repeating task to complete the `AlwaysDay` plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a repeating task for a plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already have a `BukkitRunnable` class. Therefore, in order to run a task
    timer, we just need to determine the delay and the period by which the task is
    delayed. We want the delay to be 0\. That way, if it is night when the plugin
    is enabled, the time will be set to noon right away. As for the period, we can
    repeat the task every second if we want to keep the sun always directly above.
    The task only contains one simple line of code. Repeating it often will not cause
    the server to lag. However, repeating the task every minute will still prevent
    the world from ever growing dark and will be less of a strain on the computer.
    Therefore, we will delay the task by 0 ticks and repeat it every 1,200 ticks.
    This results in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we started a repeating task. It is good practice to cancel repeating
    tasks when the plugin is disabled. To accomplish this, we will store the `BukkitTask`
    as a class variable so that we can access it later to disable it. Once you have
    canceled the task within the `onDisable` method, the entire `AlwaysDay` plugin
    is given in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Adding a delayed task to a plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now add a warp delay to the `Warper` plugin. This will require players
    to stand still after running the warp or home commands. If they move too much,
    the warp task will be canceled and they will not be teleported. This will prevent
    players from teleporting when someone is attacking them or they are falling to
    their death.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t already, add a variable of `warpDelay` in the `main` class.
    This is given in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This time will be in seconds. We will multiply it by 20 later in the code to
    calculate the number of ticks by which we wish to delay the task.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need to keep track of the player who is in the process of warping
    so that we can check whether they are moving. Add another variable of the current
    `warpers`. This will be a `HashMap` so that we can keep track of which players
    are warping and the tasks that will be run to teleport them. That way, if a specific
    player moves, we can get their task and cancel it. This is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The code contains three new methods, which must be added to the `main` class
    in order to schedule the warp task, check whether a player has a warp task, and
    cancel a player''s warp task. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the `scheduleTeleportation` method, note that both the `player` and `loc`
    variables are `final`. This is required to use the variables within the `BukkitRunnable`
    class. This must be done to ensure that the values will not change before the
    task is run. Also, note that the `runTaskLater` method call returns a `BukkitTask`,
    which is what we save inside the `HashMap`. You can see why it is saved by looking
    at the `cancelWarp` method, which removes the `BukkitTask` of the given player
    and then invokes the `cancel` method on it before it is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In both the `WarpCommand` and `HomeCommand` classes, we teleport a player.
    We want to remove that line and replace it with a method call to `scheduleTeleportation`.
    The feature addition is nearing completion. All that is left to do is calling
    the `cancelWarp` method when a `warper` moves. For this, add an event listener
    to listen for the `player move` event. This can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Do not forget to register the event within the `onEnable` method.
  prefs: []
  type: TYPE_NORMAL
- en: Executing code asynchronously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can improve the `Warper` plugin by writing its data to a file asynchronously.
    This will help keep the main thread of the server running smoothly with no lag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the current `save` method. We will add the data to a `YamlConfiguration`
    file and then write the configuration to the file. This entire method cannot be
    run asynchronously. Adding the data to the configuration must be done synchronously
    to ensure that it is not modified while it is being added. However, the `save`
    method call on the configuration can be called asynchronously. We will place the
    entire `try/catch` block within a new `BukkitRunnable class`. We will then run
    it asynchronously as a task. This task will be stored as a static variable in
    the `Warper` class. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, the rest of the server can continue running while the data is being saved.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, what if we try to save the file again when the previous write is not
    yet finished? In this case, we do not care about the previous task, because it
    is now saving outdated data. We will first cancel the task before starting a new
    one. This will be done using the following code before creating the `BukkitRunnable`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This completes this version of `Warper`. As mentioned in [Chapter 9](part0069_split_000.html#21PMQ1-b66e70deee6e4ed481db4b113e303f23
    "Chapter 9. Saving Your Data"), *Saving Your Data*, this plugin has a lot of potential
    for feature additions. You now have the required knowledge to add these additions
    on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You are now familiar with most of the complicated aspects of the Bukkit API.
    With this knowledge, you can program almost any type of Bukkit plugin. Try putting
    this knowledge to use by creating a new plugin. You can perhaps try to write an
    announcement plugin that will rotate through a list of messages that need to be
    broadcast on a server. Think about all the Bukkit API concepts and how you can
    use them to add new features to the plugin. For example, with an announcement
    plugin, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add commands to allow an administrator to add messages that need to be announced
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add permissions to control who can add messages and even who can see the messages
    that are announced
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an `EventHandler` method to listen for when players log in so that a message
    can be sent to them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a `config.yml` file to set how often messages should be announced
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a save file to save and load all the messages that will be announced
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Bukkit scheduler to repeatedly broadcast the messages while the server
    is running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For any plugin that you make, think of each segment of the Bukkit API to figure
    out some way to improve the plugin by adding more features. This will surely make
    your plugin and server stand out.
  prefs: []
  type: TYPE_NORMAL
- en: There are some topics that were not discussed in this book, but they are simple
    enough; you can learn how to use them on your own by reading the API documentation.
    Some interesting features that can spruce up a Bukkit plugin are the `playSound`
    and `playEffect` methods, which can be found inside the `World` and `Player` classes.
    I encourage you to read about them and try to use them yourself.
  prefs: []
  type: TYPE_NORMAL
- en: You know how to program plugin commands, player permissions, event listeners,
    configuration files, the saving and loading of data, and scheduled tasks. All
    that remains is imagining how to use these newfound skills to create a great and
    unique plugin for the Bukkit server.
  prefs: []
  type: TYPE_NORMAL
