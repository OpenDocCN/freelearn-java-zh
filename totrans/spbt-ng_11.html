<html><head></head><body>
		<div id="_idContainer093">
			<h1 class="chapter-number" id="_idParaDest-193"><a id="_idTextAnchor203"/>11</h1>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor204"/>Building Reactive Forms</h1>
			<p>In the previous chapter, we have already learned how to structure our Angular application at the module and component level, which promotes the maintainability of code, especially in enterprise applications. We have organized modules into three categories: core modules, shared modules, and feature modules. We have also grouped components into two classifications: Smart and Dumb components, which separate components that retrieve data and have dependencies from components that are for presentation <span class="No-Break">purposes only.</span></p>
			<p>We have also discussed how to configure and implement Angular Material, which is a UI library that provides ready-to-use components and base styling for our <span class="No-Break">Angular application.</span></p>
			<p>In this chapter, we will now start learning how to build forms using reactive forms in Angular. We will understand form groups, form controls, and form arrays and create validations in <span class="No-Break">our form.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Understanding <span class="No-Break">reactive forms</span></li>
				<li>Basic <span class="No-Break">form controls</span></li>
				<li>Grouping <span class="No-Break">form controls</span></li>
				<li>Using the <strong class="source-inline">FormBuilder</strong> service to <span class="No-Break">generate controls</span></li>
				<li>Validating <span class="No-Break">form input</span></li>
			</ul>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor205"/>Technical requirements</h1>
			<p>Here is a link to the finished version of <span class="No-Break">this chapter:</span></p>
			<p><a href="https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-11"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-11</span></a></p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor206"/>Understanding reactive forms</h1>
			<p>One of the advantages of the <strong class="bold">Angular</strong> framework is that it already provides its form extensions. We can find these extensions under the <strong class="source-inline">@angular/forms</strong> package once we have created our Angular application. There are two available ways to build forms. These are <strong class="bold">template-driven forms</strong> and <strong class="bold">reactive forms</strong>; them having their own form extension is advantageous to the<a id="_idIndexMarker884"/> developers as this does not require installing under packages to <span class="No-Break">create forms.</span></p>
			<p>At the same time, we can make sure that every Angular application uses a single library for building forms. In this section, we will be focusing more on how to implement reactive forms in our application as this is the commonly used method in developing forms in Angular applications, but first, let’s discuss a basic introduction to the template-driven approach before proceeding to <span class="No-Break">reactive forms.</span></p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor207"/>The template-driven approach</h2>
			<p>Template-driven forms, as the <a id="_idIndexMarker885"/>name suggests, are forms declared and validated on the template (HTML). It uses the <strong class="source-inline">ngForm</strong> directives, which transforms <a id="_idIndexMarker886"/>the HTML form into a template-driven form and creates a top-level <strong class="source-inline">FormGroup</strong>, and the <strong class="source-inline">ngModel</strong> directive makes a <strong class="source-inline">FormControl</strong> for the <span class="No-Break">form elements.</span></p>
			<p>To use template-driven forms, we must import <strong class="source-inline">FormsModule</strong> into the module where we want to use the template-driven forms. In the following code example, we have imported <strong class="source-inline">FormsModule</strong> into the <span class="No-Break"><strong class="source-inline">app.module.ts</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
…
import { FormsModule } from '@angular/forms';
@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    AppRoutingModule,
    FormsModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }</pre>
			<p>We must not forget<a id="_idIndexMarker887"/> to import <strong class="source-inline">FormsModule</strong> as our application<a id="_idIndexMarker888"/> will not recognize the <strong class="source-inline">ngForm</strong> and <span class="No-Break"><strong class="source-inline">ngModel</strong></span><span class="No-Break"> directives.</span></p>
			<h3>Creating a template-driven form</h3>
			<p>The first step in creating template-driven forms is<a id="_idIndexMarker889"/> to create an HTML form template. Let’s have a look at the following code example for an illustration of how to <span class="No-Break">do this:</span></p>
			<pre class="source-code">
&lt;form&gt;
  &lt;p&gt;
    &lt;label for="email"&gt;Email &lt;/label&gt;
    &lt;input type="text" id="email" name="email"&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;label for="firstname"&gt;First Name&lt;/label&gt;
    &lt;input type="text" id="firstname" name="firstname"&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;label for="lastname"&gt;Last Name&lt;/label&gt;
    &lt;input type="text" id="lastname" name="lastname"&gt;
  &lt;/p&gt;
  &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;</pre>
			<p>In the preceding code example, we have created our HTML form template and have added three form elements: the email, first name, and last name input, which will be our form controls. We have also enclosed the elements with a <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">form&gt;</strong></span><span class="No-Break"> tag.</span></p>
			<p>After successfully creating an HTML form template, this form will be automatically converted into a template-driven<a id="_idIndexMarker890"/> form. It is not required for us to add the <strong class="source-inline">ngForm</strong> directive to the <strong class="source-inline">form</strong> tag as Angular finds all form tags in our application to convert it into a template-driven form, although we can still use the <strong class="source-inline">ngForm</strong> directive to be assigned in a local template variable for us to access the properties and method of the <strong class="source-inline">ngForm</strong> directive. We can also use the variable template for submitting our forms. Let’s have a look at the following <span class="No-Break">code example:</span></p>
			<pre class="source-code">
&lt;form #userForm="ngForm"&gt;</pre>
			<p>Now, we can convert our elements into form controls by adding the <strong class="source-inline">ngModel</strong> directive to each input; this allows us to track the values, validation status, and user interaction of each form element. Let’s have a look at the following code example with the added <span class="No-Break">form controls:</span></p>
			<pre class="source-code">
&lt;form #userForm="ngForm"&gt;
  &lt;p&gt;
    &lt;label for="firstname"&gt;First Name&lt;/label&gt;
    &lt;input type="text" name="firstname" <strong class="source-inline">ngModel</strong>&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;label for="lastname"&gt;Last Name&lt;/label&gt;
    &lt;input type="text" name="lastname" <strong class="source-inline">ngModel</strong>&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;label for="email"&gt;Email &lt;/label&gt;
    &lt;input type="text" id="email" name="email" <strong class="source-inline">ngModel</strong>&gt;
  &lt;/p&gt;
&lt;/form&gt;</pre>
			<p>Lastly, we will add an <strong class="source-inline">ngSubmit</strong> event to submit the data of the form component. We will add the <strong class="source-inline">ngSubmit</strong> event <a id="_idIndexMarker891"/>to the <strong class="source-inline">form</strong> tag and add a method to the component class to receive the data. Let’s have a look at the following <span class="No-Break">code example:</span></p>
			<pre class="source-code">
&lt;!—HTML template -- &gt;
&lt;form #userForm="ngForm" (ngSubmit)="onSubmit(userForm)"&gt;
&lt;!—typescript file (Component class) -- &gt;
onSubmit(contactForm) {
    console.log(userForm.value);
 }</pre>
			<p>In the preceding code example, once the user has clicked the <strong class="bold">Submit</strong> button of the form, this will call the <strong class="source-inline">onSubmit()</strong> method, and it will display the form control values as a JSON object in our console; this will now allow us to use the form values in sending data implementing <span class="No-Break">business logic.</span></p>
			<p>After successfully implementing all the steps, we will now have a final template for the <span class="No-Break">template-driven form:</span></p>
			<pre class="source-code">
&lt;form #userForm="ngForm"(ngSubmit)="onSubmit(userForm)"&gt;&gt;
  &lt;p&gt;
    &lt;label for="firstname"&gt;First Name&lt;/label&gt;
    &lt;input type="text" name="firstname" ngModel&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;label for="lastname"&gt;Last Name&lt;/label&gt;
    &lt;input type="text" name="lastname" ngModel&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;label for="email"&gt;Email &lt;/label&gt;
    &lt;input type="text" id="email" name="email" ngModel&gt;
  &lt;/p&gt;
 &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;</pre>
			<h3>When to use template-driven forms</h3>
			<p>Template-driven forms are<a id="_idIndexMarker892"/> very flexible and easy to implement in Angular applications. However, this approach has some limitations and can cause an impact in terms of maintainability; some of the best scenarios for using a template-driven approach in building forms are set <span class="No-Break">out here:</span></p>
			<ul>
				<li>It’s easier to use template-driven forms when migrating from AngularJS to Angular2, such that both use the <span class="No-Break"><strong class="source-inline">ngModel</strong></span><span class="No-Break"> directive.</span></li>
				<li>Template-driven forms are more suitable in simple and small forms that do not require complex validations since validation is applied at the template level. This could be a disadvantage as it will be hard to maintain validations on larger applications at the same time. It has limitations on applying validations to the <span class="No-Break">form controls.</span></li>
			</ul>
			<p>In the second of the aforementioned scenarios, reactive forms are chosen over template-driven forms as complex forms can be handled better with reactive forms, especially in implementing validations. Let’s now understand the concept of <span class="No-Break">reactive forms.</span></p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor208"/>The reactive approach</h2>
			<p>A reactive form is the second<a id="_idIndexMarker893"/> approach in building forms in Angular applications; this is the most commonly used approach as it is more effective in handling complex forms than template-driven forms. Reactive forms are also known as <strong class="bold">model-driven forms</strong>, in which we<a id="_idIndexMarker894"/> define the structure of our forms in the component class instead of defining it in <span class="No-Break">the template.</span></p>
			<p>We also define the validations in <a id="_idIndexMarker895"/>the class before we bind it in to our HTML form, which means that the logic and validation patterns will now be separated from the HTML template and will be maintained by the TypeScript side of <span class="No-Break">our component.</span></p>
			<h3>Using reactive forms</h3>
			<p>The first step for us to use reactive <a id="_idIndexMarker896"/>forms is to import <strong class="source-inline">ReactiveFormsModule</strong>; this is usually imported into the root module or the shared module of the application. <strong class="source-inline">ReactiveFormsModule</strong> contains all directives—such as <strong class="source-inline">formGroup</strong> and <strong class="source-inline">formControlName</strong>—that will allow us to implement reactive forms; this is also found under the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">angular/forms</strong></span><span class="No-Break"> package.</span></p>
			<p>After successfully importing <strong class="source-inline">ReactiveFormsModule</strong>, the next step is to create our HTML form template and create a model using <strong class="source-inline">FormGroup</strong>, <strong class="source-inline">FormControl</strong>, and <strong class="source-inline">FormArray</strong>. These are the three building blocks of reactive forms that we will use to bind our form templates and are outlined in more <span class="No-Break">detail here:</span></p>
			<ul>
				<li><strong class="source-inline">FormControl</strong>: This represents a single form element inside a form; it stores the value of a form element that allows us to retrieve data from <span class="No-Break">each input.</span></li>
				<li><strong class="source-inline">FormArray</strong>: This is a collection of form controls that allows us to dynamically add and remove controls to accept more values from <span class="No-Break">the form.</span></li>
				<li><strong class="source-inline">FormGroup</strong>: This is a collection of form controls; it can also contain another form group or <span class="No-Break">form arrays.</span></li>
			</ul>
			<p>Assuming we have a <strong class="source-inline">HeroesComponent</strong>, we will create a <strong class="source-inline">FormGroup</strong> by writing the following code in the <span class="No-Break">class component:</span></p>
			<pre class="source-code">
userForm = new FormGroup({})</pre>
			<p>In the preceding code example, we have instantiated a new <strong class="source-inline">FormGroup</strong> and assigned it to the <strong class="source-inline">userForm</strong> variable; this is only a form group, and we have not yet added form controls to the model. To add a form control, we will place the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
userForm = new FormGroup({
  email: new FormControl(),
  firstName: new FormControl(),
  lastName: new FormControl(),
});</pre>
			<p>We can see in the preceding example that we have added three form controls to our <strong class="source-inline">FormGroup</strong>; this can now be bound to the HTML form template in our application to capture the values and<a id="_idIndexMarker897"/> state of <span class="No-Break">form elements.</span></p>
			<p>Let’s now create an HTML form template with <strong class="source-inline">formGroup</strong> and <span class="No-Break"><strong class="source-inline">formControlName</strong></span><span class="No-Break"> directives:</span></p>
			<pre class="source-code">
&lt;form [formGroup]="userForm" (ngSubmit)="onSubmit()"&gt;
   &lt;p&gt;
    &lt;label for="email"&gt;Email &lt;/label&gt;
    &lt;input type="text" id="email" name="email"
      formControlName="email"&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;label for="firstname"&gt;First Name &lt;/label&gt;
    &lt;input type="text" id="firstname" name="firstName"
      formControlName="firstname"&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;label for="lastname"&gt;Last Name &lt;/label&gt;
    &lt;input type="text" id="lastname" name="lastname"
      formControlName="lastName"&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;button type="submit"&gt;Submit&lt;/button&gt;
  &lt;/p&gt;
&lt;/form&gt;</pre>
			<p>In the example code, we can see that the template is almost the same as the template-driven forms. The only difference is that we use <strong class="source-inline">formGroup</strong> and <strong class="source-inline">formControlName</strong> directives to bind our form. The <strong class="source-inline">formGroup</strong> directive is used to bind the <strong class="source-inline">userFrom</strong> form group in our component class; on the other hand, the <strong class="source-inline">formControlName</strong> directive is used to bind the <a id="_idIndexMarker898"/>values and the state of the form controls defined in the <strong class="source-inline">userForm</strong> form group. Lastly, we are still using the <strong class="source-inline">ngSubmit</strong> event to call a method when the <strong class="bold">Submit</strong> button in the form <span class="No-Break">is clicked.</span></p>
			<p>We have now successfully created a reactive form in our application, but this only covers the basic features and concepts of reactive forms. In the following sections of this chapter, we will be discussing the functionalities and capabilities of form controls and <span class="No-Break">form groups.</span></p>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor209"/>Basic form controls</h1>
			<p>This section will now discuss more of the concepts of form controls in reactive forms. We have already created an example of form controls in the previous section, but now, we will discover more about the<a id="_idIndexMarker899"/> functions and capabilities of form controls <span class="No-Break">in Angular.</span></p>
			<p>Form controls represent a single form element inside a form; they store the value of a form element that allows us to retrieve data of each input. This can be <strong class="source-inline">input</strong>, <strong class="source-inline">textarea</strong>, or any element that accepts values. When used in Angular, form controls can be instantiated by adding <strong class="source-inline">new FormControl('')</strong> code; we can see that it takes a single argument that defines the values of the control. These values can be <strong class="source-inline">null</strong> as form controls can <span class="No-Break">be reset.</span></p>
			<p>Form controls are like the properties of a JSON object, but compared to JSON, each control has its methods that will help us control, modify, and validate <span class="No-Break">the values.</span></p>
			<p>Next, let’s have a look at the different methods and features of <span class="No-Break">form controls.</span></p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor210"/>Form control methods</h2>
			<p>Let’s have a look at the different<a id="_idIndexMarker900"/> form control methods and their parameters that we can use for <span class="No-Break">modifying controls:</span></p>
			<ul>
				<li><strong class="source-inline">setValue()</strong>: A method that sets the new value for <span class="No-Break">the control.</span></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">Parameters</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">value</strong>: The new value assigned to the <span class="No-Break">form control.</span></li>
				<li><strong class="source-inline">options</strong>: An object that <a id="_idIndexMarker901"/>defines the configuration of the controls on how it will propagate changes and emit events when the value changes. Here are the options that we can set in the <span class="No-Break">form control:</span><ul><li><strong class="source-inline">onlySelf</strong>: When set to <strong class="source-inline">true</strong>, the changes from the control will not affect the <span class="No-Break">other controls.</span></li><li><strong class="source-inline">emitEvent</strong>: When set to <strong class="source-inline">true</strong> or not supplied, <strong class="source-inline">statusChanges</strong> and <strong class="source-inline">valueChanges</strong> observables are emitted when the status and the value of the form control <span class="No-Break">are updated.</span></li><li><strong class="source-inline">emitModelToViewChange</strong>: When set to <strong class="source-inline">true</strong> or not supplied, a change from the form control will call the <strong class="source-inline">onChange</strong> event to update <span class="No-Break">the view.</span></li><li><strong class="source-inline">emitViewToModelChange</strong>: When set to <strong class="source-inline">true</strong> or not supplied, a change from the form control will call the <strong class="source-inline">onModelChange</strong> event to update <span class="No-Break">the view.</span></li></ul></li>
			</ul>
			<p>Here’s the code for using the <span class="No-Break"><strong class="source-inline">setValue()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="console">
setValue(value: TValue, options?: { onlySelf?: boolean; emitEvent?: boolean; emitModelToViewChange?: boolean; emitViewToModelChange?: boolean; }): void</pre>
			<ul>
				<li><strong class="source-inline">patchValue()</strong>: Patches the value of a control. The parameters of the <strong class="source-inline">patchValue</strong> method are the same as the <span class="No-Break"><strong class="source-inline">setValue()</strong></span><span class="No-Break"> method.</span></li>
			</ul>
			<p>Here’s the code for using the <span class="No-Break"><strong class="source-inline">patchValue()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="console">
patchValue(value: TValue, options?: { onlySelf?: boolean; emitEvent?: boolean; emitModelToViewChange?: boolean; emitViewToModelChange?: boolean; }): void</pre>
			<ul>
				<li><strong class="source-inline">getRawValue()</strong>: Retrieves the value of a form control. This is commonly used on disabled <span class="No-Break">form controls.</span></li>
			</ul>
			<p>Here’s the code for using the <span class="No-Break"><strong class="source-inline">getRawValue()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="console">
getRawValue(): TValue</pre>
			<ul>
				<li><strong class="source-inline">reset()</strong>: Resets the form control from its default value. It will also mark the control as pristine <span class="No-Break">and </span><span class="No-Break"><a id="_idIndexMarker902"/></span><span class="No-Break">untouched.</span></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">Parameters</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">formState</strong>: Defines the initial value and the disabled state of <span class="No-Break">the control.</span></li>
				<li><strong class="source-inline">options</strong>: An object that defines the configuration of the controls on how it will propagate changes and emit events when the value changes. We can set the following option in the <span class="No-Break">form control:</span><ul><li><strong class="source-inline">onlySelf</strong>: When set to <strong class="source-inline">true</strong>, changes from the control will not affect the <span class="No-Break">other controls.</span></li></ul></li>
			</ul>
			<p>Here’s the code for using the <span class="No-Break"><strong class="source-inline">reset()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="console">
reset(formState?: TValue | <strong class="source-inline">FormControl</strong>State&lt;TValue&gt;, options?: { onlySelf?: boolean; emitEvent?: boolean; }): void</pre>
			<ul>
				<li><strong class="source-inline">registerOnChange()</strong>: Registers a listener to emit events once the form control value <span class="No-Break">is changed.</span></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">Parameters</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">function</strong>: The method that is called when the value changes, as <span class="No-Break">illustrated here:</span><pre class="console">
registerOnChange(fn: Function): void</pre></li>
			</ul>
			<ul>
				<li><strong class="source-inline">registerOnDisabledChange()</strong>: Registers a listener to emit events once the <strong class="source-inline">isDisabled</strong> status of the <span class="No-Break">control changes.</span></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">Parameters</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">function</strong>: The method that is called when the disabled status changes, as <span class="No-Break">illustrated here:</span><pre class="console">
registerOnDisabledChange(fn: (isDisabled: boolean) =&gt; void): void</pre></li>
			</ul>
			<p>We have now learned about the<a id="_idIndexMarker903"/> different methods we can use in form controls. Now, let’s have a look at some examples of different usage of <span class="No-Break">form controls.</span></p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor211"/>Initializing form controls</h2>
			<p>There are several ways to initialize our<a id="_idIndexMarker904"/> form controls. We can set the value, the disabled state, and the validators of a specific form control. Let’s have a look at the <span class="No-Break">following examples:</span></p>
			<ul>
				<li><strong class="bold">Initializing a form control with an </strong><span class="No-Break"><strong class="bold">initial value</strong></span><span class="No-Break">:</span><pre class="console">
const control = new FormControl('Hero!'); console.log(control.value); // Hero</pre></li>
			</ul>
			<p>In the preceding code example, we instantiated a form control with a default value of <strong class="source-inline">Hero</strong>. We can access the value by accessing the <strong class="source-inline">value</strong> property inherited <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">AbstractControl</strong></span><span class="No-Break">.</span></p>
			<ul>
				<li><strong class="bold">Initializing a form control with an initial value and the </strong><span class="No-Break"><strong class="bold">disabled state</strong></span><span class="No-Break">:</span><pre class="console">
const control = new FormControl({ value: 'Hero', disabled: true });</pre><pre class="console">
// get the status</pre><pre class="console">
console.log(control.value, control.status); //Hero,</pre><pre class="console">
                                            //DISABLED</pre></li>
			</ul>
			<p>In the preceding code example, we instantiated a form control with an object value. This initializes the value and the disabled state of the form control. We can access the value by <a id="_idIndexMarker905"/>accessing the <strong class="source-inline">status</strong> property inherited <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">AbstractControl</strong></span><span class="No-Break">.</span></p>
			<ul>
				<li><strong class="bold">Initializing a form control with an initial value and an array of </strong><span class="No-Break"><strong class="bold">built-in validators</strong></span><span class="No-Break">:</span><pre class="console">
const control = new <strong class="source-inline">FormControl</strong>('', [Validators.email, Validators.required);</pre><pre class="console">
// get the status</pre><pre class="console">
console.log(control.status); // INVALID</pre></li>
			</ul>
			<p>We instantiated a form control with an empty string value in the preceding code example. With the second parameter of an array of validators, this will return an invalid status since there should not be an empty value and should be a valid <span class="No-Break">email format.</span></p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor212"/>Resetting form controls</h2>
			<p>We can use the <strong class="source-inline">reset()</strong> method to reset the <a id="_idIndexMarker906"/>value and the disabled state of a form control. Let’s have a look at the following code examples of <span class="No-Break">different usage:</span></p>
			<ul>
				<li><strong class="bold">Resetting controls to a </strong><span class="No-Break"><strong class="bold">specific value</strong></span><span class="No-Break">:</span><pre class="console">
const control = new <strong class="source-inline">FormControl</strong>('Tony Stark')</pre><pre class="console">
console.log(control.value); // Tony Stark</pre><pre class="console">
control.reset('Iron Man');</pre><pre class="console">
console.log(control.value); // Iron Man</pre></li>
			</ul>
			<p>In the preceding code example, we have used the <strong class="source-inline">reset()</strong> method with a parameter. The parameter allows us to reset the form control to a <span class="No-Break">specific value.</span></p>
			<ul>
				<li><strong class="bold">Resetting controls to an </strong><span class="No-Break"><strong class="bold">initial value</strong></span><span class="No-Break">:</span><pre class="console">
const control = new <strong class="source-inline">FormControl</strong>('Tony Stark')</pre><pre class="console">
console.log(control.value); // Tony Stark</pre><pre class="console">
control.reset();</pre><pre class="console">
console.log(control.value); // Tony Stark</pre></li>
			</ul>
			<p>In the preceding code example, we used the <strong class="source-inline">reset()</strong> method without a parameter. This would <a id="_idIndexMarker907"/>reset the form control’s value with its <span class="No-Break">initial value.</span></p>
			<ul>
				<li><strong class="bold">Resetting controls with a value and a  </strong><span class="No-Break"><strong class="bold">disabled state</strong></span><span class="No-Break">:</span><pre class="console">
const control = new <strong class="source-inline">FormControl</strong>('Tony Stark'); console.log(control.value); // Tony Stark console.log(control.status); // VALID</pre><pre class="console">
control.reset({ value: 'Iron Man', disabled: true });</pre><pre class="console">
console.log(control.value); // Iron Man console.log(control.status); // DISABLED</pre></li>
			</ul>
			<p>In the preceding code example, we have used an object parameter in calling the <strong class="source-inline">reset()</strong> method, and we have indicated the value and disabled state of the form control. In this case, it will disable the control and change the status <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">DISABLED</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor213"/>Listening to events</h2>
			<p>In using form controls, we can listen to <a id="_idIndexMarker908"/>several events such as changing values and status. Let’s have a look at the following code examples on how to listen to events of <span class="No-Break">form controls:</span></p>
			<ul>
				<li><strong class="bold">Listening to </strong><span class="No-Break"><strong class="bold">value changes</strong></span><span class="No-Break">:</span><pre class="console">
control = new FormControl('');</pre><pre class="console">
this.control.valueChanges.subscribe((data) =&gt; {</pre><pre class="console">
      console.log(data); // Iron Man</pre><pre class="console">
    });</pre><pre class="console">
this.control.setValue('Iron Man')</pre></li>
			</ul>
			<p>In the preceding code example, we have called the <strong class="source-inline">valueChanges</strong> property that has an <strong class="source-inline">Observable</strong> type, which we can subscribe to listen to changes to the form control value. In this case, once<a id="_idIndexMarker909"/> we set the value of the form control, the <strong class="source-inline">valueChanges</strong> property will emit the <span class="No-Break">new value.</span></p>
			<ul>
				<li><strong class="bold">Listening to </strong><span class="No-Break"><strong class="bold">status changes</strong></span><span class="No-Break">:</span><pre class="console">
control = new FormControl('');</pre><pre class="console">
this.control.statusChanges.subscribe((data) =&gt; {</pre><pre class="console">
      console.log(data); // DISABLED</pre><pre class="console">
    });</pre><pre class="console">
This.control.disable ()</pre></li>
			</ul>
			<p>In the preceding code example, we have called the <strong class="source-inline">statusChanges</strong> property that has an <strong class="source-inline">Observable</strong> type, which we can subscribe to listen to changes to the form control status. In this case, once we disable the form control, this will emit the new status, which <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">DISABLED</strong></span><span class="No-Break">.</span></p>
			<p>We have already learned about the features and functionalities of form controls; now, we will discuss how to group form controls using form groups and <span class="No-Break">form arrays.</span></p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor214"/>Grouping form controls</h1>
			<p>This section will now discuss how to group form controls in our application. Forms contain several related controls, which is <a id="_idIndexMarker910"/>why it is necessary to group them for a better structure. Reactive forms provide two ways to group form controls, <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Form group</strong>: Creates a<a id="_idIndexMarker911"/> form with a fixed set of form controls. Form groups can also contain another set of form groups to handle <span class="No-Break">complex forms.</span></li>
				<li><strong class="bold">Form array</strong>: Creates a form <a id="_idIndexMarker912"/>with dynamic form controls. It can add and remove form controls and at the same time can contain other form arrays to handle <span class="No-Break">complex forms.</span></li>
			</ul>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor215"/>Creating form groups</h2>
			<p>Form groups allow us to control the values <a id="_idIndexMarker913"/>and status of form controls by groups. We can also access a single form control inside a form group using its name. To create a form group, let’s follow the <span class="No-Break">next steps:</span></p>
			<ol>
				<li>Let’s say we have a <strong class="source-inline">HeroComponent</strong>; for example, the first step is to import the <strong class="source-inline">FormGroup</strong> and <strong class="source-inline">FormControl</strong> classes from the <strong class="source-inline">@angular/forms</strong> package, <span class="No-Break">like so:</span><pre class="console">
import { <strong class="source-inline">FormGroup</strong>, <strong class="source-inline">FormControl</strong> } from '@angular/forms';</pre></li>
				<li>The next step is to create a <strong class="source-inline">FormGroup</strong> instance. In this example, we want to create a new form group with <strong class="source-inline">firstName</strong>, <strong class="source-inline">lastName</strong>, and <strong class="source-inline">knownAs</strong> <span class="No-Break">form controls:</span><pre class="console">
export class HeroComponent {</pre><pre class="console">
  heroForm = new FormGroup({</pre><pre class="console">
      firstName: new FormControl(''),</pre><pre class="console">
      lastName: new FormControl(''),</pre><pre class="console">
      knownAs: new FormControl('')</pre><pre class="console">
});</pre><pre class="console">
}</pre></li>
			</ol>
			<p>In the preceding code example, we have created a new form group named <strong class="source-inline">heroForm</strong>. Simultaneously, we have added three form controls as object parameters included in the <span class="No-Break"><strong class="source-inline">heroForm</strong></span><span class="No-Break"> form.</span></p>
			<ol>
				<li value="3">The next step is to bind our form group instance with the form element in <span class="No-Break">our view:</span><pre class="console">
&lt;form [formGroup]=" heroForm "&gt;</pre><pre class="console">
  &lt;label for="first-name"&gt;First Name: &lt;/label&gt;</pre><pre class="console">
  &lt;input id="first-name" type="text"</pre><pre class="console">
    formControlName="firstName"&gt;</pre><pre class="console">
  &lt;label for="last-name"&gt;Last Name: &lt;/label&gt;</pre><pre class="console">
  &lt;input id="last-name" type="text"</pre><pre class="console">
    formControlName="lastName"&gt;</pre><pre class="console">
  &lt;label for="known-as"&gt;Known As: &lt;/label&gt;</pre><pre class="console">
  &lt;input id="known-as" type="text"</pre><pre class="console">
    formControlName="knownAs"&gt; &lt;/form&gt;</pre></li>
			</ol>
			<p>In the preceding code example, we have used the <strong class="source-inline">formGroup</strong> directive to bind our <strong class="source-inline">heroForm</strong> form in our<a id="_idIndexMarker914"/> form element. We must also bind each form control with the input elements by using the <span class="No-Break"><strong class="source-inline">formControlName</strong></span><span class="No-Break"> directive.</span></p>
			<ol>
				<li value="4">The last step is to get the value of the whole form group. We will use the <strong class="source-inline">ngSubmit</strong> event to call a method and will retrieve the form value by accessing the <strong class="source-inline">value</strong> property, <span class="No-Break">like so:</span><pre class="console">
//hero.component.html</pre><pre class="console">
&lt;form [formGroup]="heroForm" (ngSubmit)="onSubmit()"&gt;</pre><pre class="console">
//hero.component.ts</pre><pre class="console">
onSubmit() {</pre><pre class="console">
// Will display value of form group in a form of JSON</pre><pre class="console">
 console.warn(this.heroForm.value);</pre><pre class="console">
}</pre></li>
			</ol>
			<p>We have created and bound an example form group, but this is only a simple form group and introduces a linear <a id="_idIndexMarker915"/>structure of controls. Now, let’s create a form group that contains <span class="No-Break">form groups.</span></p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor216"/>Creating nested form groups</h2>
			<p>Form groups can also have another form group<a id="_idIndexMarker916"/> instead of having a list of controls. Imagine a JSON object that has properties with the value of another JSON object. This cannot be handled by a simple linear of form controls, and we must create another set of form groups to take this kind <span class="No-Break">of object.</span></p>
			<p>Let’s follow the next steps to develop nested <span class="No-Break">form groups:</span></p>
			<ol>
				<li value="1">We will be using the previous form example; in this case, we would want to add a new <strong class="source-inline">address</strong> property in our form, but instead of having it as a new instance of the form control, we will declare it as a new instance of the <span class="No-Break">form group:</span><pre class="console">
export class HeroComponent {</pre><pre class="console">
 heroForm = new FormGroup({</pre><pre class="console">
      firstName: new FormControl(''),</pre><pre class="console">
lastName: new FormControl(''),</pre><pre class="console">
knownAs: new FormControl('')</pre><pre class="console">
address: new FormGroup({</pre><pre class="console">
    street: new FormControl('')</pre><pre class="console">
    city: new FormControl('')</pre><pre class="console">
    country: new FormControl('')</pre><pre class="console">
})</pre><pre class="console">
});</pre><pre class="console">
}</pre></li>
			</ol>
			<p>In the preceding code example, we have added an <strong class="source-inline">address</strong> property as a new form group instance. We have also added new form controls inside the form group—namely, <strong class="source-inline">street</strong>, <strong class="source-inline">city</strong>, and <strong class="source-inline">country</strong>. This is now considered a nested <span class="No-Break">form group.</span></p>
			<ol>
				<li value="2">The next step is to <a id="_idIndexMarker917"/>bind the nested form group with our form element in <span class="No-Break">the view:</span><pre class="console">
  &lt;div formGroupName="address"&gt;</pre><pre class="console">
        &lt;label for="street"&gt;Street: &lt;/label&gt;</pre><pre class="console">
        &lt;input id="street" type="text"</pre><pre class="console">
          formControlName="street"&gt;</pre><pre class="console">
        &lt;label for="city"&gt;City: &lt;/label&gt;</pre><pre class="console">
        &lt;input id="city" type="text"</pre><pre class="console">
          formControlName="city"&gt;</pre><pre class="console">
        &lt;label for="country"&gt;Country: &lt;/label&gt;</pre><pre class="console">
        &lt;input id="country" type="text"</pre><pre class="console">
          formControlName="country"&gt;</pre><pre class="console">
    &lt;/div&gt;</pre></li>
			</ol>
			<p>In the preceding code example, we have used the <strong class="source-inline">formGroupName</strong> directive to bind our address form group. Remember that this element should be inside the <strong class="source-inline">heroForm</strong> form group; we have also used the <strong class="source-inline">formControlName</strong> directive to bind the controls under the nested form group. Now, we can also use the <strong class="source-inline">ngSubmit</strong> event again and call the <strong class="source-inline">value</strong> property as we did in the previous example to get the value of the <span class="No-Break">whole form.</span></p>
			<p>We have created simple and complex forms using form groups. Let’s now discuss another way of grouping controls using <span class="No-Break">form arrays.</span></p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor217"/>Creating form arrays</h2>
			<p>Form arrays are helpful, especially if we want to <a id="_idIndexMarker918"/>add or remove controls in our form at runtime. This allows us to have flexible forms in our application and at the same time handle a more complex set of objects to process. To create a form array, let’s have a look at the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">We will be using the previous form example; in this case, we would want to add a new <strong class="source-inline">powers</strong> property to our form and declare it as a new <span class="No-Break"><strong class="source-inline">FormArray</strong></span><span class="No-Break"> instance:</span><pre class="console">
export class HeroComponent implements OnInit {</pre><pre class="console">
 powerFormArray: FormArray;</pre><pre class="console">
 constructor() {</pre><pre class="console">
    this.powerFormArray=</pre><pre class="console">
      this.heroForm.get("powers") as FormArray;</pre><pre class="console">
 }</pre><pre class="console">
ngOnInit() {</pre><pre class="console">
    heroForm = new <strong class="source-inline">FormGroup</strong>({</pre><pre class="console">
        ... controls from previous example</pre><pre class="console">
        powers: new FormArray([])</pre><pre class="console">
   })</pre><pre class="console">
 }</pre><pre class="console">
}</pre></li>
			</ol>
			<p>In the preceding code example, we have created a new <strong class="source-inline">FormArray</strong> instance inside our <strong class="source-inline">heroForm</strong> form group. This accepts an empty array having no form controls on initialization. We have also assigned the instance of the form array into a variable for us to access the array in <span class="No-Break">our view.</span></p>
			<ol>
				<li value="2">The next step is to create methods that can add and remove an instance of a form control in the <span class="No-Break">form array:</span><pre class="console">
 addPower() {</pre><pre class="console">
    (this.form.get("powers") as FormArray).push(new</pre><pre class="console">
      <strong class="source-inline">FormControl</strong>());</pre><pre class="console">
  }</pre><pre class="console">
  deletePower(i: number) {</pre><pre class="console">
    (this.form.get("powers") as</pre><pre class="console">
      FormArray).removeAt(i);</pre><pre class="console">
  }</pre></li>
			</ol>
			<p>In the preceding code example, we have created two methods that we will use for the form array. The <strong class="source-inline">addPower()</strong> method allows us to add a new form control instance in the power<a id="_idIndexMarker919"/> form array; this gets the instance of the form array by name and pushes a new form <span class="No-Break">control instance.</span></p>
			<p>On the other hand, the <strong class="source-inline">deletePower()</strong> method gets the instance of the form array by name and removes a specific form control using the <strong class="source-inline">removeAt()</strong> method and the index of the control to <span class="No-Break">be deleted.</span></p>
			<ol>
				<li value="3">The last step is to bind the form array instance with the form element in <span class="No-Break">the view:</span><pre class="console">
&lt;ng-container formArrayName="powers"&gt;</pre><pre class="console">
   &lt;label for="tags"&gt;Tags&lt;/label&gt;</pre><pre class="console">
   &lt;div class="input-group mb-3" *ngFor="let _ of</pre><pre class="console">
     powerFormArray.controls; index as i"&gt;</pre><pre class="console">
      &lt;input type="text" class="form-control"</pre><pre class="console">
         [formControlName]="i" placeholder="Power</pre><pre class="console">
          Name"&gt;</pre><pre class="console">
      &lt;button (click)="deletePower(i)"</pre><pre class="console">
        class="btn btn-danger"</pre><pre class="console">
        type="button"&gt;Delete&lt;/button&gt;</pre><pre class="console">
&lt;/div&gt;</pre><pre class="console">
      &lt;button class="btn btn-info me-md-2"</pre><pre class="console">
        type="button" (click)="addPower()"&gt;</pre><pre class="console">
        Add&lt;/button&gt;</pre><pre class="console">
&lt;/ng-container&gt;</pre></li>
			</ol>
			<p>In the preceding code example, we have bound the powers to form an array with the view using the <strong class="source-inline">formArrayName</strong> directive. We have also used the <strong class="source-inline">ngFor</strong> directive to iterate all the <a id="_idIndexMarker920"/>controls inside the form array; we would also need to get the index of each control to pass it on to our <span class="No-Break"><strong class="source-inline">deletePower()</strong></span><span class="No-Break"> method.</span></p>
			<p>After successfully creating the form arrays, we will now have a view of <span class="No-Break">the form:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer091">
					<img alt="Figure 11.1 – Hero form with a form group and form arrays" src="image/B18159_11_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Hero form with a form group and form arrays</p>
			<p>We have successfully created reactive forms using form groups and form arrays. Now, we will use the <strong class="source-inline">FormBuilder</strong> service to<a id="_idIndexMarker921"/> simplify the syntax in creating forms in <span class="No-Break">our application.</span></p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor218"/>Using the FormBuilder service to generate controls</h1>
			<p>In the previous section, we successfully <a id="_idIndexMarker922"/>created reactive forms using form groups, form arrays, and form controls. However, as we can see from the syntax, creating<a id="_idIndexMarker923"/> forms becomes repetitive. We are always instantiating new instances of form controls, form arrays, and form groups, and this is not ideal in larger forms. <strong class="source-inline">FormBuilder</strong> provides the solution for <span class="No-Break">this issue.</span></p>
			<p>This is a service that can be injected into our components to generate groups, controls, and arrays without instantiating new ones. To create a reactive form using <strong class="source-inline">FormBuilder</strong>, we will be following the <span class="No-Break">next steps:</span></p>
			<ol>
				<li value="1">We will be transforming the form in the previous section using <strong class="source-inline">FormBuilder</strong>. The first step is to import the <strong class="source-inline">FormBuilder</strong> service into our component <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">@angular/forms</strong></span><span class="No-Break">:</span><pre class="console">
import { FormBuilder } from '@angular/forms';</pre></li>
				<li>The next step is to inject the <strong class="source-inline">FormBuilder</strong> service into <span class="No-Break">our component:</span><pre class="console">
export class HeroComponent implements OnInit {</pre><pre class="console">
 powerFormArray: FormArray;</pre><pre class="console">
constructor(private fb: FormBuilder) {}</pre><pre class="console">
... code implementation</pre><pre class="console">
}</pre></li>
				<li>The last step is now to create and generate controls using the methods of the <span class="No-Break"><strong class="source-inline">FormBuilder</strong></span><span class="No-Break"> service:</span><pre class="console">
export class HeroComponent implements OnInit {</pre><pre class="console">
 heroForm = this.fb.group({</pre><pre class="console">
      firstName: [''],</pre><pre class="console">
     lastName: [''],</pre><pre class="console">
     knownAs: [''],</pre><pre class="console">
     address:  this.fb.group({</pre><pre class="console">
        street: [''],</pre><pre class="console">
        city: [''],</pre><pre class="console">
        country: [''],</pre><pre class="console">
    }),</pre><pre class="console">
      powers: this.fb.array([])</pre><pre class="console">
});</pre><pre class="console">
constructor(private fb: FormBuilder) {}</pre><pre class="console">
... code implementation</pre><pre class="console">
}</pre></li>
			</ol>
			<p>We can see in the<a id="_idIndexMarker924"/> preceding example that our form has the same structure as the form we created in the previous section. The <a id="_idIndexMarker925"/>major difference is that we are using the methods of <strong class="source-inline">FormBuilder</strong> to create forms. We have used the <strong class="source-inline">group()</strong> method to generate form groups, the <strong class="source-inline">array()</strong> method to generate a form array, and an array with an empty string value to generate a control and set its <span class="No-Break">default value.</span></p>
			<p>The output for this code will be the same. <strong class="source-inline">FormBuilder</strong> methods are mainly for making our reactive forms clean and readable. Now, we will discuss how to add validations to <span class="No-Break">our controls.</span></p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor219"/>Validating form input</h1>
			<p>We have now created and <a id="_idIndexMarker926"/>simplified our reactive form in the previous section, but we want to make our forms accurate in accepting data and at the same time create a user-friendly experience for the user to let them know easily what the valid values for each control are. Now, we will learn how to add validations to our <span class="No-Break">reactive forms.</span></p>
			<p>In reactive forms, we are adding validators as parameters directly to the form controls in the component class instead of adding them as an attribute in <span class="No-Break">the template.</span></p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor220"/>Built-in validators</h2>
			<p>Angular provides several<a id="_idIndexMarker927"/> built-in validator functions that we can use directly in our forms. Let’s <a id="_idIndexMarker928"/>have a look at some <span class="No-Break">of these:</span></p>
			<ul>
				<li><strong class="source-inline">static min(min: number)</strong>—Requires the value of the control to be equal to or greater than the <span class="No-Break">given number:</span><pre class="console">
form = this.fb.group({</pre><pre class="console">
  name: [10, [Validators.min(4)]]</pre><pre class="console">
});</pre><pre class="console">
console.log(this.form.status) // returns VALID</pre><pre class="console">
static max(max: number) – requires the value of the control to be equal to or less than the given number.</pre><pre class="console">
form = this.fb.group({</pre><pre class="console">
  name: [3, [Validators.max (4)]]</pre><pre class="console">
});</pre><pre class="console">
console.log(this.form.status) // returns VALID</pre></li>
				<li><strong class="source-inline">static required(control: AbstractControl&lt;any, any&gt;)</strong>—Controls must not have a <span class="No-Break">non-empty value:</span><pre class="console">
form = this.fb.group({</pre><pre class="console">
  name: ['test value', [Validators.required]]</pre><pre class="console">
});</pre><pre class="console">
console.log(this.form.status) // returns VALID</pre></li>
				<li><strong class="source-inline">static requiredTrue(control: AbstractControl&lt;any, any&gt;)</strong>—Controls must have<a id="_idIndexMarker929"/> a value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">:</span><pre class="console">
form = this.fb.group({</pre><pre class="console">
  name: [true, [Validators.requiredTrue]]</pre><pre class="console">
});</pre><pre class="console">
console.log(this.form.status) // returns VALID</pre></li>
				<li><strong class="source-inline">static minLength(minLength: number)</strong>—Used for arrays and strings, this requires that the length of the value should be equal to or greater than the <span class="No-Break">given number:</span><pre class="console">
form = this.fb.group({</pre><pre class="console">
  name: ['test', [Validators.minLength (4)]]</pre><pre class="console">
});</pre><pre class="console">
console.log(this.form.status) // returns VALID</pre></li>
				<li><strong class="source-inline">static maxLength(maxLength: number)</strong>—Used for arrays and strings, this requires that the <a id="_idIndexMarker930"/>length of the value should be equal to or less than the <span class="No-Break">given number:</span><pre class="console">
form = this.fb.group({</pre><pre class="console">
  name: ['test', [Validators.maxLength (4)]]</pre><pre class="console">
});</pre><pre class="console">
console.log(this.form.status) // returns VALID</pre></li>
			</ul>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor221"/>Custom validators</h2>
			<p>Other than the built-in validators, we can <a id="_idIndexMarker931"/>also create custom validators, which is <a id="_idIndexMarker932"/>helpful if our forms require more complex verification <span class="No-Break">and checking.</span></p>
			<p>Let’s have a look at the following example <span class="No-Break">custom validator:</span></p>
			<pre class="source-code">
import { AbstractControl, ValidationErrors, ValidatorFn } from "@angular/forms";
export function checkHasNumberValidator(): ValidatorFn {
    return (control: AbstractControl): ValidationErrors |
      null =&gt; {
      const error = /\d/.test(control.value);
      return error ? {hasNumbers: {value: control.value}} :
        null;
    };
}</pre>
			<p>In the preceding code example, we have created a new validator named <strong class="source-inline">checkHasNumberValidator()</strong>. The main use of this validator is to invalidate control values that have a number. We have retrieved the form control where the validator is assigned, then we have tested the value of the control and will return a custom error named <strong class="source-inline">hasNumbers</strong> if the regex <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
			<p>After successfully creating the custom validator, we can now use it in our controls, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
heroForm = this.fb.group({
     firstName: ['', [<strong class="bold">checkHasNumberValidator</strong>]],
     lastName: ['', [<strong class="bold">checkHasNumberValidator</strong>]],
     knownAs: [''],
     address:  this.fb.group({
        street: [''],
        city: [''],
        country: [''],
    }),
      powers: this.fb.array([])
});</pre>
			<p>In the preceding example code, we want our first name and last name field to be restricted to letters only. In this case, we have used <strong class="source-inline">checkHasNumberValidator</strong> as a second parameter for the <strong class="source-inline">firstName</strong> and <span class="No-Break"><strong class="source-inline">lastName</strong></span><span class="No-Break"> controls.</span></p>
			<p>Let’s now proceed to<a id="_idIndexMarker933"/> the implementation of <span class="No-Break">reactive</span><span class="No-Break"><a id="_idIndexMarker934"/></span><span class="No-Break"> forms.</span></p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor222"/>Implementing reactive forms in our project</h2>
			<p>We have now successfully learned<a id="_idIndexMarker935"/> how to develop reactive forms using <strong class="source-inline">FormBuilder</strong>, and at the same time, added validations to our controls. Now, we will implement these reactive forms in <span class="No-Break">our project.</span></p>
			<p>The first step is to create our form group instance. Under the <strong class="source-inline">anti-hero/components/anti-hero-form</strong> file, we will create our form group using the <strong class="source-inline">FormBuilder</strong> service in the class component, and at the same time, we will create our form elements in our HTML template. Follow the <span class="No-Break">next steps:</span></p>
			<ol>
				<li value="1">Create a form group instance by executing the <span class="No-Break">following code:</span><pre class="console">
export class AntiHeroFormComponent implements OnInit {</pre><pre class="console">
  @Input() selectedId = "";</pre><pre class="console">
  @Input() actionButtonLabel: string = 'Create';</pre><pre class="console">
  form: FormGroup;</pre><pre class="console">
  constructor(private fb: FormBuilder) {</pre><pre class="console">
    this.form = this.fb.group({</pre><pre class="console">
      id: [''],</pre><pre class="console">
      firstName: [''],</pre><pre class="console">
      lastName: [''],</pre><pre class="console">
      house: [''],</pre><pre class="console">
      knownAs: ['']</pre><pre class="console">
    })</pre><pre class="console">
   }</pre><pre class="console">
&lt;! – Please refer to the anti-hero-form.component.ts file in the GitHub repo, Thank you -&gt;</pre><pre class="console">
}</pre></li>
				<li>Then, create an HTML<a id="_idIndexMarker936"/> template, <span class="No-Break">like so:</span><pre class="console">
&lt;! – Please refer to the anti-hero-form.component.html file in the GitHub repo, Thank you -&gt;</pre></li>
			</ol>
			<p>In the implemented code in our <strong class="source-inline">component</strong> class, the first thing we did was create a form group object. We have added several controls that resemble the properties of the anti-hero object. Our goal here is to use the same form for creating and updating an anti-hero detail. In this case, we have also added several <strong class="source-inline">Input()</strong> bindings and methods to our class to help the form identify which actions are currently <span class="No-Break">being done:</span></p>
			<ul>
				<li><strong class="source-inline">selectedId</strong>: This will accept the ID of the anti-hero if the actions <span class="No-Break">are updated.</span></li>
				<li><strong class="source-inline">actionButtonLabel</strong>: This will change depending on the action being done (<strong class="source-inline">Create</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">Update</strong></span><span class="No-Break">).</span></li>
				<li><strong class="source-inline">checkAction()</strong>: If <strong class="source-inline">selectedId</strong> has a value, this will change the value of <strong class="source-inline">actionButtonLabel</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">"Update"</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">patchDataValues()</strong>: This will be used for patching the values of the selected anti-hero in the <span class="No-Break">form controls.</span></li>
				<li><strong class="source-inline">emitAction()</strong>: Emits the value of the form and the action into the <span class="No-Break">parent component.</span></li>
				<li><strong class="source-inline">clear()</strong>: Calls the <strong class="source-inline">reset()</strong> method to clean <span class="No-Break">the form.</span></li>
			</ul>
			<ol>
				<li value="3">The next step is to use the anti-hero form in our form page component. Under the <strong class="source-inline">anti-hero/pages/form</strong> file, we will place the anti-hero form in the HTML template, and at the same time, check the current route if it has the ID of the selected anti-hero in the <a id="_idIndexMarker937"/>parameters. Here are <span class="No-Break">the steps:</span><ol><li>Add the anti-hero form to the <span class="No-Break">HTML template:</span></li></ol><pre class="console">
&lt;app-anti-hero-form [selectedId]="id"&gt;&lt;/app-anti-hero-form&gt;</pre><ol><li value="2">Add the activated router to capture <span class="No-Break">the ID:</span></li></ol><pre class="console">
export class FormComponent implements OnInit {</pre><pre class="console">
  id = "";</pre><pre class="console">
  constructor(private router: ActivatedRoute) { }</pre><pre class="console">
  ngOnInit(): void {</pre><pre class="console">
    this.id = this.router.snapshot.params['id'];</pre><pre class="console">
  }</pre><pre class="console">
}</pre></li>
				<li>The next step is now to create a route for our page form component. In the <strong class="source-inline">anti-hero-routing.module.ts</strong> file, we will add the following entry to <span class="No-Break">our routes:</span><pre class="console">
  {</pre><pre class="console">
    path: "form",</pre><pre class="console">
    children: [</pre><pre class="console">
      {</pre><pre class="console">
        path: "",</pre><pre class="console">
        component: FormComponent</pre><pre class="console">
      },</pre><pre class="console">
      {</pre><pre class="console">
        path: ":id",</pre><pre class="console">
        component: FormComponent</pre><pre class="console">
      }</pre><pre class="console">
    ]</pre><pre class="console">
  },</pre></li>
			</ol>
			<p>In the preceding code example, we have created two routes that redirect to <strong class="source-inline">FormComponent</strong>. The first route is for the <strong class="source-inline">create</strong> action, which has a <strong class="source-inline">baseURL/anti-heroes/form</strong> route, and the second route is for the <strong class="source-inline">update</strong> action, which has a <strong class="source-inline">baseURL/anti-heroes/form/:id</strong> route. This means that we<a id="_idIndexMarker938"/> are using the same components for our two actions, and the <strong class="source-inline">id</strong> parameters act as our indicator of which action is currently <span class="No-Break">being done.</span></p>
			<ol>
				<li value="5">The last step is to add navigations to the <strong class="source-inline">list</strong> component. We will add several methods that will call navigate methods to redirect us to the form component depending on the selected action, <span class="No-Break">as follows:</span><ul><li><span class="No-Break"><strong class="source-inline">list.component.html</strong></span><span class="No-Break">:</span><pre class="console">
&lt;!-- Dumb component command bar --&gt;</pre><pre class="console">
&lt;app-anti-hero-command-bar <strong class="bold">(action)="executeCommandBarAction($event)"&gt;&lt;/</strong>app-anti-hero-command-bar&gt;</pre><pre class="console">
&lt;!-- Dumb component anti hero list --&gt;</pre><pre class="console">
&lt;app-anti-hero-list [antiHeroes]="antiHeroes" <strong class="bold">(antiHero)="selectAntiHero($event)"</strong> [headers]="headers"&gt;&lt;/app-anti-hero-list&gt;</pre></li><li><span class="No-Break"><strong class="source-inline">list.component.ts</strong></span><span class="No-Break">:</span><pre class="console">
selectAntiHero(data: {antiHero: AntiHero, action: TableActions}) {</pre><pre class="console">
&lt;! – Please refer to the list.component.ts file in the GitHub repo, Thank you-&gt;</pre><pre class="console">
  this.router.navigate(['anti-heroes', 'form',</pre><pre class="console">
                        data.antiHero.id]);</pre><pre class="console">
  }</pre><pre class="console">
  executeCommandBarAction(action: CommandBarActions) {</pre><pre class="console">
    switch(action) {</pre><pre class="console">
      case CommandBarActions.Create: {</pre><pre class="console">
        this.router.navigate(["anti-heroes", "form"]);</pre><pre class="console">
        return;</pre><pre class="console">
      }</pre><pre class="console">
      case CommandBarActions.DeleteAll: {</pre><pre class="console">
        return;</pre><pre class="console">
      }</pre><pre class="console">
      default: ""</pre><pre class="console">
    }</pre><pre class="console">
  }</pre></li></ul></li>
			</ol>
			<p>After accomplishing all the steps, we<a id="_idIndexMarker939"/> will now have the following <span class="No-Break">form output:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer092">
					<img alt="Figure 11.2 – Form UI ﻿for creating an anti-hero" src="image/B18159_11_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Form UI for creating an anti-hero</p>
			<h1 id="_idParaDest-213"><a id="_idTextAnchor223"/>Summary</h1>
			<p>With this, we have reached the end of this chapter; let’s have a recap of the valuable things you have learned. You have learned about the concepts and implementation of Angular reactive forms, and we have implemented <strong class="source-inline">FormGroup</strong>, <strong class="source-inline">FormBuilder</strong>, and <strong class="source-inline">formControlName</strong> directives to bind input values to capture data in our form. We have also discussed how to group form controls for binding nested properties and create form arrays in our reactive forms. This is primarily useful if some objects we want to display have <span class="No-Break">array values.</span></p>
			<p>At the same time, we want to accept a list of entries from users. Lastly, we have also learned how to implement validations for form controls to handle and verify user input, which will be beneficial for the user experience and help avoid <span class="No-Break">unexpected errors.</span></p>
			<p>In the next chapter, we will learn about the concepts and implementation of state management in Angular applications; we will discuss the idea of the Redux pattern and the <strong class="bold">NgRx</strong> library in terms of how they can improve the <span class="No-Break">application architecture.</span></p>
		</div>
	</body></html>