<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Conclusion</h1>
                </header>
            
            <article>
                
<p>I hope that all that we have learned in this book provides helpful insights into how to build modern, lightweight, business-oriented enterprise applications. Maybe this book could even dissolve some outdated best practices of the past.</p>
<p>We have seen how modern versions of Java EE fit into a new world of software development, embracing container technology, cloud platforms, automation, Continuous Delivery, and more.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Motivations in enterprise development</h1>
                </header>
            
            <article>
                
<p>As we have seen several times in this book, engineering teams should follow the right motivations when developing software. The main focus of enterprise systems should be on their business motivations. The domain and business use cases of applications need to be clear, before they can deliver value to their customers. At the end of the day, working software that accomplishes business functionality is what generates revenue.</p>
<p>A helpful question that developers can ask themselves over time is: <em>Is what we're doing helping to solve the business problem?</em></p>
<p>Software that aims to meet a customer's demands therefore mainly focuses on fulfilling business uses cases. Technology that fulfills a subordinate necessity, such as communication, persistence, or distribution, comes second. The chosen solutions should aim to solve the business demands first.</p>
<p>Therefore, technology, programming languages and frameworks ideally support the implementation of use cases without too much overhead. The team of engineers is advised to choose technology that they are productive and familiar with, but that also fits this requirement.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cloud and Continuous Delivery</h1>
                </header>
            
            <article>
                
<p>We have seen the necessity of moving fast in a fast moving world. It's important to put emphasis on agility and reactiveness towards the customer's demands, the time-to-market, or better, <em>time-to-production</em>. The best features don't deliver value, until they are in the customer's hands.</p>
<p>It makes sense to use concepts and technology that help achieve this goal, such as Continuous Delivery, automation, infrastructure as code, and automated software tests.</p>
<p>This is what represents the biggest benefit of modern environments and cloud technology: <em>the ability to move fast</em>. Application environments for new projects, features, or test scenarios, can be created in a matter of minutes, using well-defined specifications. In particular, infrastructure as code and container technology support these attempts. Software developers deliver the environment configuration together with the application code, contained in the project's repository.</p>
<p>Defining all contents of enterprise software thus becomes a responsibility of the whole engineering team. Developers, as well as operational engineers, are interested in shipping software that provides value to its users. The whole software team is accountable for achieving this goal.</p>
<p>This also includes the topic of software quality assurance. Delivering features with rapid pace is only possible if proper, automated quality verification mechanisms are in place. Tests that require human intervention and that don't run reliably or fast enough prevent fast processes and keep developers from doing more useful work. It's a necessity to invest effort in automated, sufficient, and reliable test cases that are built with maintainability and code quality in mind.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Relevance of Java EE</h1>
                </header>
            
            <article>
                
<p>We have seen how Java EE enables all this. The platform supports focusing on business demands by enabling developers to write code without setting too many constraints. Use cases can be designed and implemented by following the domain's demands first.</p>
<p>The technology itself does not <em>want attention</em>. In the majority of cases, it's sufficient to annotate business logic which leads the application container to add the required technical necessities. The approaches of Java EE standards, such as JAX-RS, JPA, or JSON-B, accomplish the required technical integration with minimum effort required.</p>
<p>The Java EE platform especially enables engineers to seamlessly integrate multiple standards without configuration work. The JSR specifications that are written with the principles of Java EE in mind, make this possible.</p>
<p>Modern Java EE has to be seen differently to how it was in the old days of J2EE. In fact, the programming model and runtimes have little to do with J2EE.</p>
<p>With the backwards-compatible nature of the platform, outdated approaches are still possible, but the technology has advanced a lot since then. Programming models and design patterns have been revisited and vastly simplified. In particular, the restrictions of past patterns in implementing hierarchies of technology-motivated interfaces, and superclasses, are gone. Developers are able to focus on business domains, not on the technology.</p>
<p>The nature of the Java EE standards allows companies to realize vendor-independent applications. This avoids vendor lock-in on the technology-side. Developers are also not exclusively trained for vendor-specific technologies. We have seen quite a few cases of teams that were solely familiar with vendors that became obsolete.</p>
<p>Java EE technology is not only used on the server-side. Standards such as JAX-RS, JSON-P, or CDI provide valuable benefits for Java SE applications as well. It makes sense to realize certain functionalities, such as HTTP clients, with standards technology that developers are familiar with.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">API updates introduced in Java EE 8</h1>
                </header>
            
            <article>
                
<p>This book focuses on enterprise applications with Java EE 8.</p>
<p>There have been certain standards that have been updated in the course of this version. The following are the most important new features and standards.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CDI 2.0</h1>
                </header>
            
            <article>
                
<p>Since Java EE 8 and CDI 2.0, events cannot only be handled synchronously. As we have seen previously in this book, CDI natively supports handling events asynchronously. In fact, this was only possible before if the event observer method was a business method of an EJB, annotated with <kbd>@Asynchronous</kbd>.</p>
<p>In order to emit and handle asynchronous CDI events, the publisher side uses the <kbd>fireAsync</kbd> method. The observer method parameter is annotated with <kbd>@ObservesAsync</kbd>.</p>
<p>Another new event functionality the advent of CDI 2.0 included is the possibility to order event observers. Therefore, the <kbd>@Priority</kbd> annotation, which is well-known within the Java EE platform, is specified at the event observer method:</p>
<pre style="padding-left: 30px">public void onCarCreated(@Observes <strong>@Priority(100)</strong> CarCreated event) {
    System.out.println("first: " + newCoffee);
}

public void alsoOnCarCreated(@Observes <strong>@Priority(200)</strong> CarCreated event) {
    System.out.println("second: " + newCoffee);
}</pre>
<p>This approach guarantees that the event observers are called in the specified order, with lower priority numbers first. Developers should consider whether the situation violates loose coupling and the single point of responsibility principle, by needing to order the event handlers.</p>
<p>The biggest feature of CDI 2.0 was the integration outside of an enterprise container,â€‰providing the possibility to use CDI in Java SE applications. The idea is that Java SE applications can also use the features of a sophisticated dependency injection standard. This aims to increase the acceptance of CDI outside of the Java EE world.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JAX-RS 2.1</h1>
                </header>
            
            <article>
                
<p>Version 2.1 of JAX-RS mainly targeted reactive clients, SSE, and better integration into standards such as JSON-B. Besides these, some small improvements have been added.</p>
<p>Reactive programming is used more and more, and, in particular, the client receives new, reactive functionality to make HTTP calls and directly returning so-called reactive types. An example for such a type is the <kbd>CompletionStage</kbd> type. This type is supported natively; other types and libraries can be added via extensions.</p>
<p>In order to make reactive calls, the <kbd>rx()</kbd> method of the <kbd>Invocation.Builder</kbd> is used.</p>
<p>As also shown in this book, JAX-RS 2.1 supports SSE, both on the client and on the server side. The SSE standard represents a lightweight, one-way messaging protocol that uses plain text messages over HTTP.</p>
<p>In order to match the usual approach of the Java EE platform, the JSON-B standard which has been added in Java EE 8 is seamlessly integrated into JAX-RS. This means that, similarly to JAXB, Java types that are used as request or response bodies, respectively, are implicitly mapped to JSON.</p>
<p>Similarly, the new features that are part of JSON-P 1.1 and Bean Validation 2.0 are included in JAX-RS, as well. This is possible since the specifications forward the specific functionality to the corresponding standards.</p>
<p>A smaller update that was incorporated into JAX-RS was the inclusion of the <kbd>@PATCH</kbd> annotation for the HTTP method of the same name. Although support of HTTP methods other than the provided ones was possible in JAX-RS before, it simplifies the usage for developers who require this feature.</p>
<p>Another small but indeed helpful improvement was to include standardized HTTP timeout methods on the JAX-RS client. The builder methods <kbd>connectTimeout</kbd> and <kbd>readTimeout</kbd> handle configured timeouts. A lot of projects require this configuration, which previously resulted in including vendor-specific features.</p>
<p>We have seen the implementation of these features in <a href="329094a0-f41b-4ad1-b05e-cd52c4bb9e42.xhtml">Chapter 3</a>, <em>Implementing Modern Java Enterprise Applications</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JSON-B 1.0</h1>
                </header>
            
            <article>
                
<p>The JSON-B is a new standard that maps Java types to and from JSON structures, respectively. Similarly to JAXB for XML, it provides functionality to declaratively map objects.</p>
<p>The biggest advantage of this standard within the Java EE ecosystem is that applications don't need to rely on vendor-specific implementations anymore. JSON mapping frameworks have typically prevented enterprise applications to be built in a portable way. They increase the risk of breaking runtime dependencies with existing framework versions.</p>
<p>JSON-B solves this issue by providing standardized JSON mapping. Shipping custom mapping frameworks such as Jackson or Johnzon is not required anymore.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JSON-P 1.1</h1>
                </header>
            
            <article>
                
<p>JSON-P 1.0, which was introduced in Java EE 7, shipped a powerful feature to programmatically create and read JSON structures. The version 1.1 mainly included support for common JSON standards.</p>
<p>One of these IETF standards is <strong>JSON Pointer</strong> (RFC 6901). It defines a syntax to query JSON structures and values. By using pointers such as <kbd>"/0/user/address"</kbd>, JSON values are referenced, similarly to <strong>XPath</strong> in the XML world.</p>
<p>This feature is included in the <kbd>JsonPointer</kbd> type, that is created via the <kbd>Json.createPointer()</kbd> method, similarly to the existing JSON-P API.</p>
<p>Another, newly-supported standard is <strong>JSON Patch</strong> (RFC 6902). RFC 6902 defines so-called patches and modification methods that are applied to existing JSON structures.</p>
<p>JSON 1.1 supports creating JSON patches via <kbd>Json.createPatch</kbd> or <kbd>Json.createPatchBuilder</kbd>, respectively. The corresponding JSON-P type is <kbd>JsonPatch</kbd>.</p>
<p>The third supported IETF standard is <strong>JSON Merge Patch</strong> (RFC 7386). This standard merges existing JSON structures to create new structures. JSON-P supports creating Merge Patches via <kbd>Json.createMergeDiff</kbd> or <kbd>Json.createMergePatch</kbd>, respectively, that result in the <kbd>JsonMergePatch</kbd>type.</p>
<p>Besides these supported IETF standards, JSON-P 1.1 includes a few smaller features that simplify the API usage. One example is the support of Java SE 8 streams via pre-defined stream collectors, such as the <kbd>JsonCollectors.toJsonArray()</kbd> method. Another small improvement enables the creation of JSON-P values types from Java strings and primitives, via <kbd>Json.createValue</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bean Validation 2.0</h1>
                </header>
            
            <article>
                
<p>Java EE 8 updates the Bean Validation version to 2.0. Besides including new, pre-defined constraints, it mainly targets support for Java SE 8.</p>
<p>The Java SE 8 support includes multiple, differently-configured validation constraint annotations. Types of the Java 8 Date and Time API are now supported; for example, via usage such as <kbd>@Past LocalDate date</kbd>.</p>
<p>Values that are contained in container types can also be validated separately, via parameterized type annotations. Examples for this are <kbd>Map&lt;String, @Valid Customer&gt; customers</kbd>, <kbd>List&lt;@NotNull String&gt; strings</kbd>, and <kbd>Optional&lt;@NotNull String&gt; getResult()</kbd>.</p>
<p>Bean Validation 2.0 includes new pre-defined constraints. For example, <kbd>@Email</kbd> validates email addresses. <kbd>@Negative</kbd> and <kbd>@Positive</kbd> verify numeric values. <kbd>@NotEmpty</kbd> ensures that collections, maps, arrays, or strings are not empty or <kbd>null</kbd>. <kbd>@NotBlank</kbd> validates that strings do not solely consist of whitespace.</p>
<p>These constraints are a helpful default feature that avoids potentially defining this manually.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JPA 2.2</h1>
                </header>
            
            <article>
                
<p>Java EE 8 updates the JPA specification to version 2.2. This version mainly targets Java SE 8 features.</p>
<p>Similar to Bean Validation, the Java SE 8 support includes the Date and Time API. Types such as <kbd>LocalDate</kbd> or <kbd>LocalDateTime</kbd> are now natively supported for entity properties.</p>
<p>Version 2.2 makes it possible to return a query result, not only as <kbd>List&lt;T&gt;</kbd> but <kbd>Stream&lt;T&gt;</kbd>, using the <kbd>getResultStream()</kbd> method as shown in the following code snippet:</p>
<pre>Stream&lt;Car&gt; cars = entityManager
        .createNamedQuery(Car.FIND_TWO_SEATERS, Car.class)
        .getResultStream();
cars.map(...)</pre>
<p>What JPA 2.2 also finally added is support to inject managed beans into attribute converters using CDI's <kbd>@Inject</kbd>. This increases the use and number of scenarios of custom attribute converters. Similar to other standards such as JSON-B, better CDI integration encourages reuse of Java EE components.</p>
<p>Also version 2.2 adds repeatable annotations, such as <kbd>@JoinColumn</kbd>, <kbd>@NamedQuery</kbd>, or <kbd>@NamedEntityGraph</kbd>. Since Java SE 8 allows to repeat the same annotation type multiple times, developers are no longer required to use the corresponding group annotations, such as <kbd>@JoinColumns</kbd>, for these functionalities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Security 1.0</h1>
                </header>
            
            <article>
                
<p>As seen in the last chapter, Security 1.0 aims to simplify the integration of security concerns into Java EE applications. Developers are therefore encouraged to use powerful functionalities such as JASPIC.</p>
<p>We have seen the features and usage of HTTP authentication mechanisms, identity stores, and security contexts in the previous chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Servlet 4.0</h1>
                </header>
            
            <article>
                
<p>As of writing this book, HTTP/1.1 is the primarily used version of HTTP. HTTP/2 targets the shortcomings of HTTP performance of web applications in the past. In particular, requesting several resources of a web based system could lead to suboptimal performance due to the numerous connections involved. Version 2 of HTTP aims to lower latency and maximize throughput by multiplexing, pipelining, compressing headers, and Server Push.</p>
<p>Most of the changes in HTTP/2 do not affect the engineers' work compared to 1.1. The servlet container deals with HTTP concerns under the hood. The exception to this is the Server Push feature.</p>
<p>Server Push works in such a way that the server directly sends HTTP responses of resources related to a client-requested resource, following the assumption that the client would need these resources as well. It allows the server to send resources which were not explicitly requested by a client. This is a performance optimization technique that in web pages mainly concerns style sheets, JavaScript code, and other assets.</p>
<p>The Servlet API supports Server Push messages by using the <kbd>PushBuilder</kbd> type that is instantiated with the <kbd>HttpServletRequest.newPushBuilder()</kbd> method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JSF 2.3</h1>
                </header>
            
            <article>
                
<p>Java Server Faces are a traditional way of building server-centric, component-based HTML UIs. Java EE 8 ships with the updated JSF version 2.3.</p>
<p>The main improvements of the version update include better CDI, WebSocket and AJAX integration, class-level Bean Validation, as well as support for Java SE 8.</p>
<p>Since the focus of this book is clearly on the backend-side, it doesn't include much about JSF.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JCP and participation</h1>
                </header>
            
            <article>
                
<p>The <strong>Java Community Process</strong> (<strong>JCP</strong>) defines the standards that make up the Java SE and EE platforms, including the Java EE umbrella standard itself. The individual standards are defined as <strong>Java Specification Requests</strong> (<strong>JSR</strong>), each forming so-called <strong>Expert Groups</strong>, consisting of experts and companies involved in enterprise software.</p>
<p>The idea is to standardize technology that has proven itself well in real-world projects. The experience of companies and individuals from these real-world projects is brought together to form vendor-independent Java enterprise standards.</p>
<p>It's highly advisable for both companies and individuals to participate in the JCP. It provides the ability to form the standards and the future of Java technology as well as to gain knowledge in this technology. The open processes of the JCP enable developers to get insight about how the future versions of Java EE will look.</p>
<p>Individuals and companies can also follow the standardization processes, even if they don't participate in the JCP. It's possible to review working states of the standards and provide feedback to the Expert Groups.</p>
<p>The Expert Groups indeed welcome constructive feedback while the specifications are being formed. It's very beneficial to receive feedback and experience from real-world projects and helps in crafting standards that suit the needs of the industry better.</p>
<p>I also was involved in shaping Java EE 8, being part of two Expert Groups, namely JAX-RS 2.1 and JSON-P 1.1. I personally gained a lot of knowledge as part of this engagement and can encourage enterprise Java developers to look into the processes within the JCP.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MicroProfile</h1>
                </header>
            
            <article>
                
<p>The motivation behind the MicroProfile initiative was to build upon the Java EE standards and create smaller-scale profiles that target microservice architectures as well as experiment with features independent from standardization. Multiple application server vendors have been involved in this initiative that forms vendor-agreed de facto standards.</p>
<p>Server applications that support MicroProfile pride the opportunity to run Java EE applications that only require a smaller set of standards,â€‰in the first version this includes JAX-RS, CDI, and JSON-P. Similarly, application server vendors provide the ability to strip down runtime to a specific required set of standards.</p>
<p>The advantage of these approaches is that they don't add dependencies to the enterprise project, rather than just optimizes the runtime. Developers still write their applications using the same Java EE standard technology.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Eclipse Enterprise for Java</h1>
                </header>
            
            <article>
                
<p>In September 2017, just before publishing this book, Oracle, the steward of Java EE and the JCP, announced to move the Java EE platform and its standards to an Open Source Foundation, what emerged in <strong>Eclipse Enterprise for Java</strong> (<strong>EE4J</strong>). The plans aim to lower the barrier for companies and developers who would like to contribute and to ultimately enable to a more open technology.</p>
<p>However the realization of these plans will look, it's important to mention that the plans include the preservation of the nature of the platform. The approaches and techniques presented in this book will hold true in the future of enterprise Java.</p>
<p>I can repeat my message of what I have said in the past about participation within the JCP. However the manifestation of the standardization process of Enterprise Java looks, I encourage engineers and companies to have a look into Eclipse Enterprise for Java and to participate in defining enterprise standards. The collective knowledge and real world experience helped shaping the standards of Java EE, and will help shaping Enterprise Java in the future.</p>


            </article>

            
        </section>
    </body></html>