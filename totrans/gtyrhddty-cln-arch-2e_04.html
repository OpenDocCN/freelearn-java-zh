<html><head></head><body>
<div id="_idContainer027">
<h1 class="hapter-number" id="_idParaDest-37"><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-38"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.2.1">Organizing Code</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Wouldn’t it be nice to recognize the architecture just by looking at </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">the code?</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we’ll examine different ways of organizing code and introduce an expressive package structure that directly reflects a </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">Hexagonal Architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In greenfield software projects, the first thing we try to get right is the package structure. </span><span class="koboSpan" id="kobo.7.2">We set up a nice-looking structure that we intend to use for the rest of the project. </span><span class="koboSpan" id="kobo.7.3">Then, during the project, things become hectic, and we realize that in many places the package structure is just a nice-looking facade for an unstructured mess of code. </span><span class="koboSpan" id="kobo.7.4">Classes in one package import classes from other packages that should not </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">be imported.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">We’ll discuss different options for structuring the code of the BuckPal example application that was introduced in the </span><em class="itali"><span class="koboSpan" id="kobo.10.1">Preface</span></em><span class="koboSpan" id="kobo.11.1">. </span><span class="koboSpan" id="kobo.11.2">More specifically, we’ll look at the </span><em class="itali"><span class="koboSpan" id="kobo.12.1">Send money</span></em><span class="koboSpan" id="kobo.13.1"> use case, which allows a user to transfer money from their account </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">to another.</span></span></p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.15.1">Organizing By Layer</span></h1>
<p><span class="koboSpan" id="kobo.16.1">The first approach to organizing</span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.17.1"> our code is by layer. </span><span class="koboSpan" id="kobo.17.2">We might</span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.18.1"> organize the code </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.20.1"><img alt="" src="image/code-4.1.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.21.1">For each of our layers – </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.22.1">web</span></strong><span class="koboSpan" id="kobo.23.1">, </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.24.1">domain</span></strong><span class="koboSpan" id="kobo.25.1">, and </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.26.1">persistence</span></strong><span class="koboSpan" id="kobo.27.1"> – we have a dedicated package. </span><span class="koboSpan" id="kobo.27.2">As discussed in </span><a href="B19916_04.xhtml"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.28.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.29.1">, </span><em class="itali"><span class="koboSpan" id="kobo.30.1">What’s Wrong with Layers?</span></em><span class="koboSpan" id="kobo.31.1">, simple layers may not be the best structure for our code for several reasons, so we have already applied the </span><strong class="bold"><span class="koboSpan" id="kobo.32.1">Dependency Inversion Principle </span></strong><span class="koboSpan" id="kobo.33.1">here, only allowing dependencies toward the domain code in the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.34.1">domain</span></strong><span class="koboSpan" id="kobo.35.1"> package. </span><span class="koboSpan" id="kobo.35.2">We did this by introducing the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.36.1">AccountRepository</span></strong><span class="koboSpan" id="kobo.37.1"> interface in the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.38.1">domain</span></strong><span class="koboSpan" id="kobo.39.1"> package and implementing it in the </span><span class="No-Break"><strong class="sour e-inline"><span class="koboSpan" id="kobo.40.1">persistence</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.41.1"> package.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">We can find at least three reasons why this package structure is </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">suboptimal, however:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.44.1">First, we have no package boundary between functional slices or features of our application. </span><span class="koboSpan" id="kobo.44.2">If we add a feature for managing users, we’ll add a </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.45.1">UserController</span></strong><span class="koboSpan" id="kobo.46.1"> to the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.47.1">web</span></strong><span class="koboSpan" id="kobo.48.1"> package; a </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.49.1">UserService</span></strong><span class="koboSpan" id="kobo.50.1">, </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.51.1">UserRepository</span></strong><span class="koboSpan" id="kobo.52.1">, and </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.53.1">User</span></strong><span class="koboSpan" id="kobo.54.1"> to the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.55.1">domain</span></strong><span class="koboSpan" id="kobo.56.1"> package; and a </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.57.1">UserRepositoryImpl</span></strong><span class="koboSpan" id="kobo.58.1"> to the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.59.1">persistence</span></strong><span class="koboSpan" id="kobo.60.1"> package. </span><span class="koboSpan" id="kobo.60.2">Without further structure, this might quickly become a mess of classes, leading to unwanted side effects between supposedly unrelated features of </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">the application.</span></span></li>
<li><span class="koboSpan" id="kobo.62.1">Second, we can’t see which use cases our application provides. </span><span class="koboSpan" id="kobo.62.2">Can you tell what use cases the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.63.1">AccountService</span></strong><span class="koboSpan" id="kobo.64.1"> or </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.65.1">AccountController</span></strong><span class="koboSpan" id="kobo.66.1"> classes implement? </span><span class="koboSpan" id="kobo.66.2">If we’re looking for a certain feature, we have to guess which service implements it and then search for the responsible method within </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">that service.</span></span></li>
<li><span class="koboSpan" id="kobo.68.1">Finally, we can’t see our target architecture within the package structure. </span><span class="koboSpan" id="kobo.68.2">We can guess that we have followed the Hexagonal Architecture style and then browse the classes in the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.69.1">web</span></strong><span class="koboSpan" id="kobo.70.1"> and </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.71.1">persistence</span></strong><span class="koboSpan" id="kobo.72.1"> packages to find the web and persistence adapters. </span><span class="koboSpan" id="kobo.72.2">But we can’t see at a glance which functionality is called by the web adapter and which functionality the persistence adapter provides to the domain</span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.73.1"> layer. </span><span class="koboSpan" id="kobo.73.2">The incoming and outgoing ports</span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.74.1"> are hidden in </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">the code.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.76.1">Let’s try to address some issues of the “organize by </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">layer” approach.</span></span></p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.78.1">Organizing by feature</span></h1>
<p><span class="koboSpan" id="kobo.79.1">The next approach</span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.80.1"> is to organize</span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.81.1"> our code </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">by feature:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.83.1"><img alt="" src="image/code-4.2.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.84.1">In essence, we have put all the code related to accounts into the high-level package, </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.85.1">account</span></strong><span class="koboSpan" id="kobo.86.1">. </span><span class="koboSpan" id="kobo.86.2">We have also removed the </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">layer packages.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">Each new group of features will get a new high-level package next to </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.89.1">account</span></strong><span class="koboSpan" id="kobo.90.1"> and we can enforce package boundaries between the features by using </span><strong class="bold"><span class="koboSpan" id="kobo.91.1">package-private</span></strong><span class="koboSpan" id="kobo.92.1"> visibility for the classes that should not be accessed from </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">the outside.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">The package boundaries, combined with package-private visibility, enable us to avoid unwanted dependencies </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">between features.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">We have also renamed </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.97.1">AccountService</span></strong> <strong class="sour e-inline"><span class="koboSpan" id="kobo.98.1">SendMoneyService</span></strong><span class="koboSpan" id="kobo.99.1"> to narrow its responsibility (we actually could have done that in the package-by-layer approach, too). </span><span class="koboSpan" id="kobo.99.2">We can now see that the code implements the </span><em class="itali"><span class="koboSpan" id="kobo.100.1">Send money</span></em><span class="koboSpan" id="kobo.101.1"> use case just by looking at the class name. </span><span class="koboSpan" id="kobo.101.2">Making the application’s functionality visible in the code is what Robert Martin calls a “Screaming Architecture” because it screams its intention </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">at us.</span></span><span class="No-Break"><span id="footnote-017-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-017"><span class="koboSpan" id="kobo.103.1">1</span></a></span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-017">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-017-backlink"><span class="koboSpan" id="kobo.104.1">1</span></a><span class="koboSpan" id="kobo.105.1">	Screaming Architecture</span><em class="itali"><span class="koboSpan" id="kobo.106.1">: Clean Architecture</span></em><span class="koboSpan" id="kobo.107.1"> by Robert C. </span><span class="koboSpan" id="kobo.107.2">Martin, Prentice Hall, 2017, </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.108.1">Chapter 21</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.110.1">However, the package-by-feature approach makes our architecture even less evident in the code than the package-by-layer approach. </span><span class="koboSpan" id="kobo.110.2">We have no package names to identify our adapters, and we still don’t see the incoming and outgoing ports. </span><span class="koboSpan" id="kobo.110.3">What’s more, even though we have inverted the dependencies between the domain code and persistence code so that </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.111.1">SendMoneyService</span></strong><span class="koboSpan" id="kobo.112.1"> only knows about the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.113.1">AccountRepository</span></strong><span class="koboSpan" id="kobo.114.1"> interface and not its implementation, we cannot use package-private visibility to protect the domain code from accidental dependencies on the </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">persistence code.</span></span></p>
<p><span class="koboSpan" id="kobo.116.1">So, how can we make our target architecture visible at a glance? </span><span class="koboSpan" id="kobo.116.2">It would be nice if we could point a finger at a box in an architecture diagram like </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.117.1">Figure 3</span></em></span><em class="itali"><span class="koboSpan" id="kobo.118.1">.4</span></em><span class="koboSpan" id="kobo.119.1"> and instantly know which part of the code is responsible for </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">that box.</span></span></p>
<p><span class="koboSpan" id="kobo.121.1">Let’s take one more step to create a package structure that is expressive enough to </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">support this.</span></span></p>
<h1 id="_idParaDest-41"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.123.1">An architecturally expressive package structure</span></h1>
<p><span class="koboSpan" id="kobo.124.1">In a Hexagonal Architecture, we have entities, use cases, </span><strong class="bold"><span class="koboSpan" id="kobo.125.1">input </span></strong><span class="koboSpan" id="kobo.126.1">and </span><strong class="bold"><span class="koboSpan" id="kobo.127.1">output</span></strong><strong class="bold"><a id="_idIndexMarker068"/></strong><strong class="bold"><span class="koboSpan" id="kobo.128.1"> ports</span></strong><span class="koboSpan" id="kobo.129.1">, and input and output (or “</span><strong class="bold"><span class="koboSpan" id="kobo.130.1">driving</span></strong><span class="koboSpan" id="kobo.131.1">” and “</span><strong class="bold"><span class="koboSpan" id="kobo.132.1">driven</span></strong><span class="koboSpan" id="kobo.133.1">”) adapters as our main architectural elements. </span><span class="koboSpan" id="kobo.133.2">Let’s fit them into a package structure that expresses </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">this architecture:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.135.1"><img alt="" src="image/code-4.3.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.136.1">We can map each element of the architecture directly to one of the packages. </span><span class="koboSpan" id="kobo.136.2">At the highest level, we have the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.137.1">adapter</span></strong><span class="koboSpan" id="kobo.138.1"> and </span><span class="No-Break"><strong class="sour e-inline"><span class="koboSpan" id="kobo.139.1">application</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.140.1"> packages.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">The </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.142.1">adapter</span></strong><span class="koboSpan" id="kobo.143.1"> package contains the incoming adapters that call the application’s incoming ports and the outgoing adapters that provide implementations for the application’s outgoing ports. </span><span class="koboSpan" id="kobo.143.2">In our case, we’re building a simple web application with the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.144.1">web</span></strong><span class="koboSpan" id="kobo.145.1"> and </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.146.1">persistence</span></strong><span class="koboSpan" id="kobo.147.1"> adapters, each having its </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">own sub-package.</span></span></p>
<p><span class="koboSpan" id="kobo.149.1">Moving the adapters’ code to their own packages has the benefit that we can very easily replace one adapter with another implementation, should the need arise. </span><span class="koboSpan" id="kobo.149.2">Imagine we have started implementing a persistence adapter against a simple key-value database because we thought we knew the required access patterns, but those patterns have changed, and we would be better off with an SQL database now. </span><span class="koboSpan" id="kobo.149.3">We simply implement all relevant outgoing ports in a new adapter package and then remove the </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">old package.</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">The </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.152.1">application</span></strong><span class="koboSpan" id="kobo.153.1"> package contains the “hexagon,” as in, our application code. </span><span class="koboSpan" id="kobo.153.2">This code consists of our domain model, which lives in the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.154.1">domain</span></strong><span class="koboSpan" id="kobo.155.1"> package, and the port interfaces, which live in the </span><span class="No-Break"><strong class="sour e-inline"><span class="koboSpan" id="kobo.156.1">port</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.157.1"> package.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">Why are the ports inside the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.159.1">application</span></strong><span class="koboSpan" id="kobo.160.1"> package and not next to it? </span><span class="koboSpan" id="kobo.160.2">The ports are our way</span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.161.1"> to apply the </span><strong class="bold"><span class="koboSpan" id="kobo.162.1">Dependency Inversion Principle</span></strong><span class="koboSpan" id="kobo.163.1">. </span><span class="koboSpan" id="kobo.163.2">The application defines these ports to communicate with the outside world. </span><span class="koboSpan" id="kobo.163.3">Putting the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.164.1">port</span></strong><span class="koboSpan" id="kobo.165.1"> package inside the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.166.1">application</span></strong><span class="koboSpan" id="kobo.167.1"> package expresses that the application owns </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">the ports.</span></span></p>
<p><span class="koboSpan" id="kobo.169.1">The </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.170.1">domain</span></strong><span class="koboSpan" id="kobo.171.1"> package contains our domain entities and domain services that implement the input ports and coordinate between the </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">domain entities.</span></span></p>
<p><span class="koboSpan" id="kobo.173.1">Finally, there is a </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.174.1">common</span></strong><span class="koboSpan" id="kobo.175.1"> package, which contains some code that is shared across the rest of the </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">Phew, that’s a lot of technical-sounding packages. </span><span class="koboSpan" id="kobo.177.2">Isn’t </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">that confusing?</span></span></p>
<p><span class="koboSpan" id="kobo.179.1">Imagine we have a high-level view of our Hexagonal Architecture hanging on the office wall and we’re talking to a colleague about modifying a client to a third-party API we’re consuming. </span><span class="koboSpan" id="kobo.179.2">While discussing this, we can point at the corresponding outgoing adapter on the poster to better understand each other. </span><span class="koboSpan" id="kobo.179.3">Then, when we’re finished talking, we sit down in front of our IDE and can start working on the client right away because the code of the API client we have talked about can be found in the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.180.1">adapter/out/&lt;name-of-adapter&gt;</span></strong><span class="koboSpan" id="kobo.181.1"> package. </span><span class="koboSpan" id="kobo.181.2">Rather helpful instead of confusing, don’t </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">you think?</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">This package structure</span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.184.1"> is a powerful element</span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.185.1"> in the fight against the so-called </span><strong class="bold"><span class="koboSpan" id="kobo.186.1">architecture/code gap</span></strong><span class="koboSpan" id="kobo.187.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.188.1">model/code gap</span></strong><span class="koboSpan" id="kobo.189.1">.</span><span id="footnote-016-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-016"><span class="koboSpan" id="kobo.190.1">2</span></a></span><span class="koboSpan" id="kobo.191.1"> These terms describe the fact that in most software development projects, the architecture is only an abstract concept that cannot be directly mapped to the code. </span><span class="koboSpan" id="kobo.191.2">With time, if the package structure (among other things) does not reflect the architecture, the code will usually deviate more and more from the </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">target architecture.</span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-016">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-016-backlink"><span class="koboSpan" id="kobo.193.1">2</span></a><span class="koboSpan" id="kobo.194.1">	Model/code gap: </span><em class="itali"><span class="koboSpan" id="kobo.195.1">Just Enough Architecture</span></em><span class="koboSpan" id="kobo.196.1"> by George Fairbanks, Marshall &amp; Brainerd, 2010, </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">page 167.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.198.1">Also, this expressive package structure promotes active thinking about the architecture. </span><span class="koboSpan" id="kobo.198.2">We have to actively decide which package our code to put into. </span><span class="koboSpan" id="kobo.198.3">But don’t so many packages mean that everything has to be public in order to allow access </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">across packages?</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">For the adapter packages, at least, this is not true. </span><span class="koboSpan" id="kobo.200.2">All the classes they contain may be package-private since they are not called by the outside world except over port interfaces, which live within the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.201.1">application</span></strong><span class="koboSpan" id="kobo.202.1"> package. </span><span class="koboSpan" id="kobo.202.2">So, there are no accidental</span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.203.1"> dependencies from the </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">application layer</span></strong><span class="koboSpan" id="kobo.205.1"> to the </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">adapter classes.</span></span></p>
<p><span class="koboSpan" id="kobo.207.1">Within the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.208.1">application</span></strong><span class="koboSpan" id="kobo.209.1"> package, however, some classes indeed have to be public. </span><span class="koboSpan" id="kobo.209.2">The ports must be public because they must be accessible to the adapters by design. </span><span class="koboSpan" id="kobo.209.3">The domain model must be public to be accessible to the services and, potentially, to the adapters. </span><span class="koboSpan" id="kobo.209.4">The services don’t need to be public because they can be hidden behind the incoming </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">port interfaces.</span></span></p>
<p><span class="koboSpan" id="kobo.211.1">So, yes, a fine-grained package structure such as this requires us to make some classes public that might be package-private in a coarser-grained package structure. </span><span class="koboSpan" id="kobo.211.2">We’ll look at ways to catch unwanted access to those public classes in </span><a href="B19916_12.xhtml#_idTextAnchor105"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.212.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.213.1">, </span><em class="itali"><span class="koboSpan" id="kobo.214.1">Enforcing </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.215.1">Architecture Boundaries</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">You might notice that this package structure contains only one domain, namely the domain handling account transactions. </span><span class="koboSpan" id="kobo.217.2">Many applications will contain code from more than one </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">domain, however.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">As we will learn in </span><a href="B19916_13.xhtml#_idTextAnchor112"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.220.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.221.1">, </span><em class="itali"><span class="koboSpan" id="kobo.222.1">Managing Multiple Bounded Contexts</span></em><span class="koboSpan" id="kobo.223.1">, Hexagonal Architecture doesn’t really tell us how to manage multiple domains. </span><span class="koboSpan" id="kobo.223.2">We can, of course, put the code for each domain into its own sub-package under the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.224.1">domain</span></strong><span class="koboSpan" id="kobo.225.1"> package and have the domains separated this way. </span><span class="koboSpan" id="kobo.225.2">If you’re thinking about separating the ports and adapters per domain, however, be careful because this quickly turns into a mapping nightmare. </span><span class="koboSpan" id="kobo.225.3">More about this in </span><a href="B19916_13.xhtml#_idTextAnchor112"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.226.1">Chapter 13</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.227.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.228.1">As with every structure, it takes discipline to maintain this package structure over the lifetime of a software project. </span><span class="koboSpan" id="kobo.228.2">Also, there will be cases when the package structure just does not fit and we see no other way than to widen the architecture/code gap and create a package that does not reflect </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">the architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.230.1">There is no perfection. </span><span class="koboSpan" id="kobo.230.2">But with an expressive package structure, we can</span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.231.1"> at least reduce the gap between code </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">and architecture.</span></span></p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.233.1">The role of dependency injection</span></h1>
<p><span class="koboSpan" id="kobo.234.1">The package structure described </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.235.1">previously goes a long way toward achieving a clean architecture, but an essential requirement</span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.236.1"> of such an architecture is that the </span><strong class="bold"><span class="koboSpan" id="kobo.237.1">application layer</span></strong><span class="koboSpan" id="kobo.238.1"> does not have dependencies on the incoming and outgoing adapters, as we have learned in </span><a href="B19916_03.xhtml#_idTextAnchor029"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.239.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.240.1">, </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.241.1">Inverting Dependencies</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">For incoming adapters, such as our web adapter, this is easy since the control flow points in the same direction as the dependency between the adapter and the domain code. </span><span class="koboSpan" id="kobo.243.2">The adapter simply calls the service within the application layer. </span><span class="koboSpan" id="kobo.243.3">In order to clearly bring out the entry points to our application, we’ll want to hide the actual services behind </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">port interfaces.</span></span></p>
<p><span class="koboSpan" id="kobo.245.1">For outgoing adapters, such as our persistence adapter, we have to make use of the </span><strong class="bold"><span class="koboSpan" id="kobo.246.1">Dependency Inversion Principle</span></strong><span class="koboSpan" id="kobo.247.1"> to turn the dependency against the direction of the </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">control flow.</span></span></p>
<p><span class="koboSpan" id="kobo.249.1">We have already seen how that works. </span><span class="koboSpan" id="kobo.249.2">We create an interface within the application layer, which is implemented by a class within the adapter. </span><span class="koboSpan" id="kobo.249.3">Within our Hexagonal Architecture, this interface is a port. </span><span class="koboSpan" id="kobo.249.4">The application layer then calls this port interface to call the functionality of the adapter, as shown in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.250.1">Figure 4</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.251.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.253.1"><img alt="Figure 4.1 – The web controller calls an incoming port, which is implemented by a service, and the service calls an outgoing port, which is implemented by an adapter" src="image/Figure_4.4_B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.254.1">Figure 4.1 – The web controller calls an incoming port, which is implemented by a service, and the service calls an outgoing port, which is implemented by an adapter</span></p>
<p><span class="koboSpan" id="kobo.255.1">But who provides the application with the actual objects that implement the port interfaces? </span><span class="koboSpan" id="kobo.255.2">We don’t want to instantiate the ports manually within the application layer because we don’t want to introduce a dependency on </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">an adapter.</span></span></p>
<p><span class="koboSpan" id="kobo.257.1">This is where </span><strong class="bold"><span class="koboSpan" id="kobo.258.1">dependency injection</span></strong><span class="koboSpan" id="kobo.259.1"> comes into play. </span><span class="koboSpan" id="kobo.259.2">We introduce a neutral component that has a dependency on all layers. </span><span class="koboSpan" id="kobo.259.3">This component is responsible for instantiating most of the classes that make up </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">our architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.261.1">In the preceding example figure, the neutral dependency injection component would create instances of the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.262.1">SendMoneyController</span></strong><span class="koboSpan" id="kobo.263.1">, </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.264.1">SendMoneyService</span></strong><span class="koboSpan" id="kobo.265.1">, and </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.266.1">AccountPersistenceAdapter</span></strong><span class="koboSpan" id="kobo.267.1"> classes. </span><span class="koboSpan" id="kobo.267.2">Since </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.268.1">SendMoneyController</span></strong><span class="koboSpan" id="kobo.269.1"> requires a </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.270.1">SendMoneyUseCase</span></strong><span class="koboSpan" id="kobo.271.1">, the dependency injection mechanism will give it an instance of the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.272.1">SendMoneyService</span></strong><span class="koboSpan" id="kobo.273.1"> class during construction. </span><span class="koboSpan" id="kobo.273.2">The controller doesn’t know that it actually got a </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.274.1">SendMoneyService</span></strong><span class="koboSpan" id="kobo.275.1"> instance since it only needs to know </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">the interface.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">Similarly, when constructing the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.278.1">SendMoneyService</span></strong><span class="koboSpan" id="kobo.279.1"> instance, the dependency injection mechanism</span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.280.1"> will inject an instance of the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.281.1">AccountPersistenceAdapter</span></strong><span class="koboSpan" id="kobo.282.1"> class, in the guise of the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.283.1">UpdateAccountStatePort</span></strong><span class="koboSpan" id="kobo.284.1"> interface. </span><span class="koboSpan" id="kobo.284.2">The service never knows the actual class behind </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">the interface.</span></span></p>
<p><span class="koboSpan" id="kobo.286.1">We’ll talk more about initializing an application using the Spring framework as an example in </span><a href="B19916_10.xhtml#_idTextAnchor089"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.287.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.288.1">, </span><em class="itali"><span class="koboSpan" id="kobo.289.1">Assembling </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.290.1">the Application</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">.</span></span></p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.292.1">How does this help me build maintainable software?</span></h1>
<p><span class="koboSpan" id="kobo.293.1">We looked at a package structure for a Hexagonal Architecture that takes the actual code structure as close to the target architecture as possible. </span><span class="koboSpan" id="kobo.293.2">Finding an element of the architecture in the code is now a matter of navigating down the package structure along the names of certain boxes in an architecture diagram, helping with communication, development, </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">and maintenance.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">In the following chapters, we’ll see this package structure and dependency injection in action as we implement a use case in the application layer, a web adapter, and a </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">persistence adapter.</span></span></p>
</div>
</body></html>