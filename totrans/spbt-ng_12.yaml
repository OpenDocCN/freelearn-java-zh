- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing States with NgRx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about the concepts and features of Reactive
    forms. We implemented `FormGroup`, `FormBuilder`, and `formControlName` to bind
    input values in the form elements in the application. We also discussed how to
    group form control to bind nested properties and create form arrays in our Reactive
    forms.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we learned how to implement validations for form controls to handle
    and verify user input. This will be beneficial for the user experience and help
    us avoid unexpected errors.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will add a new recipe to our application and learn how to
    implement state management, specifically **NgRx**, for handling data in our Angular
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding complexities in managing the states of large applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State management and the global state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started and setting up NgRx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a reducer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a selector and using a selector and dispatching it in a component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following link will take you to the finished version of code for this chapter:
    [https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-12/superheroes](https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-12/superheroes).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding complexities in managing the states of large applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data management in frontend applications is very important, just like how essential
    data management is in backend applications and databases. As we add more features
    to our application, we know that the number of components, modules, and services
    working inside our Angular project is also growing.
  prefs: []
  type: TYPE_NORMAL
- en: This also means that the data flow in the application is growing and becoming
    complex. A complex data flow can lead to an unmaintainable application, inconsistent
    and scattered states in different components, and nested input and output bindings
    that result in complex code structures. Due to these possible issues when it comes
    to managing data in Angular, a solution called **state management** was introduced
    as a standard solution for maintaining data in frontend applications.
  prefs: []
  type: TYPE_NORMAL
- en: State management is an extension or library that is mainly used for managing
    and handling data in frontend applications. It introduces a pattern where all
    data being used is stored in one big object that acts as the state of the whole
    application. This concept is also known as a **single source of truth**. In this
    case, no matter how many components or how many services are added to our application,
    there is always a single object where we can retrieve the data we need. You can
    compare this state to an acting database for the frontend application.
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding with state management, let’s compare the flow of data without
    and with state management.
  prefs: []
  type: TYPE_NORMAL
- en: The flow of data without state management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Data flow in Angular starts on the services. We call endpoints in the services
    to retrieve and manage the data that we need for our application. As the number
    of features increases, the number of services added and called increases, resulting
    in a more complex data flow. Let’s look at a graphical illustration of the flow
    of data without state management:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – The flow of data without state management](img/B18159_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – The flow of data without state management
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding graphical illustration, we can see that we have four different
    services that are responsible for managing different kinds of data; each feature
    retrieves the data it needs from these services.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the retrieval that occurs is scattered as the features are retrieving
    the data on different sources or services. This results in multiple data flows,
    and they can get larger as more services and features are required.
  prefs: []
  type: TYPE_NORMAL
- en: This can also lead to inconsistencies in data being held by each component as
    the source is coming from different services, leading to some unexpected bugs
    in the application. Now, let’s look at the flow of data with state management.
  prefs: []
  type: TYPE_NORMAL
- en: The flow of data with state management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous data flow, we saw that the flow of data is not optimized, which
    can result in several problems in our application as the data flow’s direction
    is very complex. When implementing state management in our Angular application,
    we will have the following data flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – The flow of data with state management](img/B18159_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – The flow of data with state management
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding graphical illustration, we can see that all of the services
    of our application are handled by state management. We are still using services
    to retrieve data in our database. The significant difference here is that our
    features are now accessing all the retrieved data in the state instead of directly
    accessing it in the services.
  prefs: []
  type: TYPE_NORMAL
- en: This allows the data to flow in one direction and has a single origin for all
    the data being used in the application. With this approach, inconsistency in the
    states, possible bugs, and multiple API calls can be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have learned about the importance of state management in developing
    applications, especially enterprise-level apps.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss more state management concepts and global states.
  prefs: []
  type: TYPE_NORMAL
- en: State management and the global state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: State management, as discussed in the previous section, is an extension or library
    that allows us to manage the flow of our data in the application in just one direction.
  prefs: []
  type: TYPE_NORMAL
- en: This is possible due to global states, which will contain all of the data. To
    understand how state management works, let’s discuss each of the building blocks
    of state management.
  prefs: []
  type: TYPE_NORMAL
- en: Global state/store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **global state**, also known as the **store**, is the most crucial element
    in state management. The primary responsibility of a global state is to store
    all the data retrieved by the API or simply data being used in the application.
  prefs: []
  type: TYPE_NORMAL
- en: This means that all components in an Angular application will retrieve the data
    in the global state. Think of it as a database of the Angular application but
    in the form of a JSON object where we can get each property as slices.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`dispatch()` function, which helps identify what events should be performed,
    such as modifying the state or calling APIs to retrieve data.'
  prefs: []
  type: TYPE_NORMAL
- en: Actions are just simple interfaces; the `type` property identifies what action
    is dispatched. This simple string is just a definition of the action, and we can
    add properties to the actions for the data we require in the API or state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at an example of an action interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example action is dispatched when a new blog is created. This
    is called when the `title`, `author`, and `content` is added as additional metadata
    to be passed on to the effect or reducer.
  prefs: []
  type: TYPE_NORMAL
- en: Reducers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Reducers** are the decision-makers of state management. They are the ones
    that decide which actions to handle based on the action type. Reducers are also
    the ones that can change the value of the state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reducers are pure functions and handle state transitions synchronously; let’s
    have a look at an example of a reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have created a reducer for the `addBlog()` action.
    This allows us to add a new blog object in the blog’s state once we have dispatched
    the `addBlog()` action.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss reducers in more detail later in the *Writing a reducer* section
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Selectors** are pure functions that allow us to retrieve slices of data in
    our store. It is a change detection mechanism where, when the value of the state
    changes, it compares the parts of the state and only sends the state if the changes
    are detected. This is a practice called **memorization**.'
  prefs: []
  type: TYPE_NORMAL
- en: Selectors are used in components to get the data used in the UI. It is returned
    as an Observable that listens to the state changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of a selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have created a selector for the blog slice, as
    well as a function that returns the *blogs* metadata, called `selectBlogList()`.
    We used this function in our `blog` component as a parameter for the `select`
    function to retrieve the data by subscribing to the selector. The subscription
    will emit once the value of the blog’s slice changes. We will discuss selectors
    in more detail in the next section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Effects are specific elements that the `NgRx` library uses; this is an *RxJs-powered*
    side effect model that handles external interactions such as API calls, web socket
    messages, and time-based events. Using effects, we can isolate our components
    from interacting with external sources and reduce their responsibilities. Let’s
    look at a comparison between an application with and without side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Application without side effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is an application without side effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code example, we have a component that has several responsibilities,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing the state of the blogs (the component has its blog state)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the blog service to call an external API to get the list of blogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying the state of the blog inside the component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that every component with a service dependency also has its state
    of data. Now, let’s look at an example of an application with side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Application with side effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is an application with side effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that the code for our blog page component
    has been reduced, and, at the same time, its responsibility is also less complex.
    Now, the component’s responsibility is to dispatch an action that will allow effects
    to identify what service needs to be called to retrieve the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example effect for the blog state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we created a new effect named `loadBlogs$`. This
    effect is responsible for calling the `getAll()` method from the blog service
    to retrieve the list of blogs from the external endpoint. At the same time, it
    is also responsible for dispatching a new action that passes the retrieved blog
    list into the reducer to modify the store. We will discuss how to write effects
    in the next section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we’ve seen all of the building blocks that make up state management.
    Let’s look at a detailed graphical illustration of how data flows in state management:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – How data flows when using NgRx state management](img/B18159_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – How data flows when using NgRx state management
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding graphical illustration, we can see that our UI components have
    only one responsibility, and this is to dispatch actions. If the action needs
    to call an API, an effect will be called to invoke an API using a service, and
    after getting the response data, the effect will also dispatch an action to call
    a reducer to modify the store.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if the action that’s sent from the component will alter the
    state, it will not need any side effects and call the reducer that matches the
    type of the action. All of the changes in the store will be detected by the selectors
    and emit the latest state to be used in the UI components.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we have learned about the necessary concepts surrounding state management
    and how data flows together with the building blocks of state management. In the
    next section, we will learn how to set up and configure one of the most famous
    state management libraries in Angular: **NgRx**.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started and setting up NgRx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use NgRx state management, we must install the `@ngrx/store` library; this
    will contain all of the functions that will allow us to configure the store and
    create reducers and actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the `@ngrx/store` library, we must execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Update `package.json` by adding `@ngrx/store` to the dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm install` to install the dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `src/app/app.module.ts` by adding `StoreModule.forRoot(reducers, {})`
    to the `imports` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before executing this command, make sure that the version of `@ngrx/store` is
    aligned with the version of your Angular; in our project, our Angular version
    is version `13.3.0`, which means that we need to use version 13 of `@ngrx/store`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flags are also available that allow us to install `@ngrx/store` with customizations.
    The following is the list of flags we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--path`: Specifies the path to the module where you want to import `StoreModule`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--project`: The name of the project that is defined in `angular.json`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--module`: The name of the file containing the module where you want to import
    `StoreModule`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--minimal`: This provides the minimal setup for the root state management
    if set to `true`. It imports `StoreModule.forRoot()` in the module with an empty
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--statePath`: This is the path where the state will be created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--stateInterface`: The interface that defines the state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding NgRx to our Angular project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s add this to our Angular project. We only want to use the minimal
    setup as we will add the reducers and store step by step. After successfully executing
    the `ng add @ngrx/store` command, we will have the following changes in our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that `StoreModule.forRoot()` has been
    added without any objects; this means that we initially imported the store without
    reducers.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have successfully installed `@ngrx/store` in our Angular project.
    Now, we will install another extension to help us debug the state.
  prefs: []
  type: TYPE_NORMAL
- en: Installing NgRx DevTools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NgRx DevTools is a valuable extension that provides developer tools and instrumentation
    for the store. It allows us to check the values of the state, implement time travel
    debugging, and have a visual representation of the previous and current values
    of the data in our store.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must execute the following command to install NgRx DevTools in our Angular
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After successfully executing this command, the following changes will be implemented
    in our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that a new module called `StoreDevtoolsModule`
    has been added; this will allow DevTools to be used once we run our application
    locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step to using DevTools is to add the Redux extension to our browser.
    To add this extension, go to one of the following links for your respective browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Google** **Chrome**: [https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd](https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mozilla** **Firefox**: [https://addons.mozilla.org/en-US/firefox/addon/reduxdevtools/](https://addons.mozilla.org/en-US/firefox/addon/reduxdevtools/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After adding this extension to your preferred browser, running your Angular
    project with the imported `StoreDevToolModule` module will be automatically detected
    by this extension. It will provide an interface for viewing the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Interface of the Redux DevTools extension](img/B18159_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Interface of the Redux DevTools extension
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows that our Redux DevTools extension has been activated;
    once we open our Angular project in our browser tab, we will see more Redux DevTools
    in action as we write our code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have configured our store and installed NgRx DevTools in our application,
    we are ready to write the building blocks for our state management.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first building block of state management is that we will write our actions.
    When writing actions, we have several rules we can follow so that we have good
    actions in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Upfront**: Writing actions should always come first before developing the
    features. This gives us an overview of what should be implemented in the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Divide**: We should always categorize the actions based on the event source
    and the associated data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Many**: Writing more number actions is not an issue. It is more beneficial
    as more actions create a better overview of the flow of your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event-Driven**: Capture *events* as you separate the description of an event
    and how it’s handled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Descriptive**: Always provide meaningful information using type metadata.
    This helps debug the state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at an example action that will set the list of blogs in our state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we used the `createAction()` function to create
    our action. The `createAction()` function also returns a function that returns
    an object of the action interface; in this case, it will return `"[Blog] Set blog
    list"` as the action type and the array of blogs as the additional properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'To dispatch the action, we will use the `dispatch()` function and use `setBlogList`
    as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Implementing actions in the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our primary goal for our project is to create the entire cycle to get the list
    of anti-heroes in our API and place it in our store. The first step is to take
    the actions we need; let’s look at the two actions that we should make for this
    feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getAntiHeroList`: This action will retrieve the list of blogs from the external
    API provided by our Spring project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setAntiHeroList`: This action will place the retrieved list of blogs in our
    store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have identified the list of actions we will create, in the `anti-heroes`
    folder, we will create a `state/anti-hero.actions.ts` file where we will place
    all of our actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s place the following code in the `anti-hero.actions.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we have created two actions for getting and setting
    the anti-hero list. The first action, `getAntiHeroList`, has a single parameter,
    which is the type. This does not need any additional properties as this will only
    call the API to retrieve the list of anti-heroes through the use of effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the second action, `setAntiHeroList`, has two parameters:
    the type and an additional property called `antiHero`. This will set the value
    of the store with the retrieved list of anti-heroes through the use of reducers.'
  prefs: []
  type: TYPE_NORMAL
- en: It is also excellent practice to make our action definitions enums in our code
    as this will help us avoid typographical errors when using the definition in other
    parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have successfully created the required action for our anti-heroes
    list feature. Now, we will discuss how to write effects that will be used to call
    the API and retrieve the anti-hero list.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We successfully created our actions in the previous section. Now, we will make
    the effects that will be responsible for calling our external API.
  prefs: []
  type: TYPE_NORMAL
- en: Effects are not included in the `@ngrx/store` library; we will install a separate
    library that will allow us to use the functions for effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install effects in our application, we must execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the `package.json` file with the `@``ngrx/effects` dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm install` to install the added dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `EffectsModule.forRoot()` to the imports array of your `app.module.ts` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Some flags are available that allow us to install `@ngrx/effects` with customizations;
    the following is the list of flags we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--path`: Specifies the path to the module where you want to import `EffectsModule`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--project`: The name of the project defined in `angular.json`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--skipTests`: This creates a test file when it is set to `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--module`: The name of the file containing the module where you want to import
    `EffectsModule`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--minimal`: This provides the minimal setup for the root effects if set to
    `true`. It imports `EffectsModule.forRoot()` in the module with an empty object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--group`: Group the `effects` files within the `effects` folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After successfully adding the dependency of the effect to our application,
    we can create our effects. Under the `anti-heroes/state` folder, we must create
    a new file named `anti-hero.effects.ts`. The first thing we need to do is create
    a class that has an `@``Injectable` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code example, we can see that effects are also service classes
    and can be injected by other services; we have injected the following services
    into `AntiHeroEffects`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Actions`: A service from `@ngrx/effects` that returns an observable that we
    can assign a type to. This will act as the identifier when an action is dispatched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AntiHeroService`: Our created service that contains the external APIs for
    our anti-heroes, found under `anti-hero/services/anti-hero.service.ts`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Router`: Used for redirection once an API call is made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After creating our `AntiHeroEffect` class and injecting our services, we can
    begin making our effects. The first thing we need to think of is what kind of
    effect we need to get the anti-heroes since we have the `GET_ANTI_HERO LIST` and
    `SET_ANTI_HERO_LIST` actions.
  prefs: []
  type: TYPE_NORMAL
- en: We should create an effect that has a type of `GET_ANTI_HERO_LIST` and can call
    the `getAntiHeroes()` function from `AntiHeroService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create this API, we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code example, we used the `createEffect()` function to create
    our effects; this returns an action that has two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ofType(AntiHeroActions.GET_ANTI_HERO_LIST)`: The first parameter uses the
    `ofType` operator, which defines the action type of the effect. This means that
    if the `GET_ANTI_HERO_LIST` action is dispatched, this effect will be called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mergeMap(() => this.antiHeroService.getAntiHeroes()`: The second parameter
    uses the `mergeMap` operator, which will allow us to invoke the `getAntiHeroes()`
    function to call the endpoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With that, we have our effect for the `GET_ANTI_HERO_LIST` actions, but this
    is not complete yet. After getting the list of anti-heroes, we want to dispatch
    another action that sets the anti-heroes list in our state. To implement this,
    we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have added a pipe to our `mergeMap` operator; this
    calls a `map` operator that returns `({ type: AntiHeroActions.SET_ANTI_HERO_LIST,
    antiHeroes }))`. This will dispatch another action that has a type of `SET_ANTI_HERO_LIST`
    and has additional `antiHeroes` objects coming from the list of anti-heroes retrieved
    from the API.'
  prefs: []
  type: TYPE_NORMAL
- en: Our effects for getting the list of anti-heroes feature is complete. The last
    step is to add `AntiHeroEffects` to our `effects` module. As we may recall, our
    `anti-heroes` module is lazy loaded, which means that we will not add `AntiHeroEffects`
    to `EffectsModule.forRoot([])` located in the `app.module.ts` file; otherwise,
    we would need to add `EffectsModule.forFeature([AntiHeroEffects])` in the imports
    of the `anti-hero.module.ts` file. This means that this `effects` class is only
    used under this module.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have successfully configured and created our effects for the anti-hero
    list feature. In the next section, we will write the reducers that will modify
    our state.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a reducer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NgRx states are immutable objects; we cannot modify their values through direct
    assignment, and the only way we can change their states is through reducers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reducers have different parts that we should implement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The interface or type that defines the properties of the state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The arguments, which consist of the initial state and the current action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of functions that handle that state changes based on the dispatched
    actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will create these reducer parts under the `anti-heroes/state/anti-hero.reducers.ts`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The state interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The state interface defines the shape of the state; this contains the properties
    or the slices of the state. In our application, we need a property that will hold
    the list of anti-heroes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the interface, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The initial state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next part we need to implement is the initial state; this defines what the
    initial values of the state slices are. In our anti-hero state, we will set the
    `antiHeroes` slice to an empty array.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The reducer function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After creating our initial state, we can implement our reducer function; this
    will hold the list of functions that will be called, depending on the type of
    action that is dispatched.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the reducer function, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that we have used a `createReducer()`
    function from the `@ngrx/store` library; this will contain all the functions that
    will modify our anti-hero state. The first parameter is our initial state, while
    the second parameter is a function that will be called when an action of `SET_ANTI_HERO_LIST`
    is dispatched.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the effect we created earlier will call this once the API has
    retrieved the anti-hero list successfully; this function contains two parameters
    – one that holds the current state and another that holds the list of anti-heroes
    objects from the API. To modify the `antiHeroes` state with the retrieved list,
    we have returned `{…``state, antiHeroes}`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have finished writing the reducers for our state, the last step
    is to register our reducers in the store. We will apply the same rules that we
    applied for the effects; since our anti-heroes module is lazy loaded, we will
    register our anti-hero reducer in our `anti-hero.module.ts` file by adding `StoreModule.forFeature('antiHeroState,'
    antiHeroReducer)`. The first parameter is the key for our anti-hero state, while
    the second is the function returned from the `createReducer()` function.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have successfully created and registered our reducer for the anti-hero
    list feature. Now, let’s discuss the NgRx selectors to get the state and how to
    dispatch actions in components.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a selector and using a selector and dispatching it in a component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we successfully implemented reducers that can mutate
    the values of our state. This means that our state contains valuable data that
    we can get from the Angular components; we can use selectors to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Selectors are pure functions that allow us to retrieve slices of state; we can
    use several helper functions, such as `createSelector()` and `createFeatureSelector()`,
    to create our selectors for the store.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting root states
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While selecting the root states, we will be using a pure function to create
    our selector. Let’s look at an example of a selector selecting the list of blogs
    under the root state (`AppState`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code example, we have only created a function that returns
    the `blogs` slice; this is feasible when we select slices under the project’s
    root state. To use the created selector in our component, we can use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we injected `Store` from the `@ngrx/store` library.
    `Store` provides a `select` function that accepts selectors as a parameter and
    returns an observable that returns the slice of state that is defined by the selector.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we have subscribed to the `blogs$` observable from the `select(selectBlogs()`
    function to retrieve the `blogs` slice that holds the list of blogs.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting feature states
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While selecting feature states, we will use the `createSelector()` and `createFeatureSelector()`
    functions to create the selector. Let’s look at an example of a selector selecting
    the list of blogs found under the feature state (`BlogState`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, the first step is to create the feature selector
    that will return the whole `BlogState`. Here, we have used `createFeatureSelector()`
    and the state’s key to identify the feature state we want to select.
  prefs: []
  type: TYPE_NORMAL
- en: The second step is to create the main selector of the blog slice; `createSelector()`
    has two parameters, where the first one is the `BlogState` feature selector, and
    the second one is a function where the returned `BlogState` from the feature selector
    is the parameter. The returned value is the blog slice.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing selectors in our project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have learned how to create selectors using the `createFeatureSelector()`
    and `createSelector()` functions. Now, let’s implement them in our project. The
    first thing we need to identify is the states or slices. The first slice that
    needs a selector is a blog slice located under `AnitHeroState`. Remember that
    `AntiHeroState` is not our root state; this means that we will have a feature
    selector for the following state.
  prefs: []
  type: TYPE_NORMAL
- en: The second selector we need is the selector for the `antiHeroes` slice, which
    contains the array of anti-heroes retrieved in the API. Finally, the third selector
    we want will need to select specific `antiHero` data from the list based on the
    `id` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create all of these selectors, place the following code in the `anti-hero/state/anti-hero.selectors.ts`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After successfully creating all of the selectors, we can use the `on anti-hero/pages/list.component.ts`
    file by adding the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we used the `selectAntiHeroes()` selector to
    get the array of anti-heroes from the state. `antiHeroes$` is an Observable that
    returns the current state of the `antiHero` slice once subscribed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we must get the anti-heroes list feature. We can do this by dispatching
    the `GET_ANTI_HERO_LIST` action in the list component in the `ngOnInit()` hook.
    This will call the effect that we created earlier, which invokes the endpoint
    for getting the list of anti-heroes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have successfully created selectors for the components to retrieve
    data from the state. In the next section, we will discuss the available configurations
    we can implement for the store.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we created all of the building blocks of NgRx that
    complete a fully functional store for the application. In this section, we will
    learn how to configure the NgRx store using runtime checks.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime checks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Runtime checks are used to configure the NgRx store to allow developers to follow
    the NgRx and Redux core concepts and best practices. This is very useful, especially
    for developers new to NgRx; they display errors regarding development based on
    the activated runtime checks.
  prefs: []
  type: TYPE_NORMAL
- en: '`@ngrx/store` provides six built-in runtime checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`strictStateImmutability`: Checks if the state isn’t mutated (default: *On*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strictActionImmutability`: Checks if the actions aren’t mutated (default:
    *On*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strictStateSerializability`: Checks if the state is serializable (default:
    *On*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strictActionSerializability`: Checks if the actions are serializable (default:
    *Off*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strictActionWithinNgZone`: Checks if actions are dispatched within NgZone
    (default: *Off*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strictActionTypeUniqueness`: Checks if the registered action types are unique
    (default: *Off*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To change the default configuration of the runtime checks, we will use the
    `runtimeChecks` property on the root store’s config object. The value of each
    runtime check can be assigned with `true` to activate the check or `false` to
    deactivate the check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: strictStateImmutability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the number one rule of NgRx. It is activated by default, and the runtime
    checks verify if the developer modifies the state object.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example violation of** **this rule**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**Fix for** **this violation**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: strictActionImmutability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This runtime check is similar to `strictStateImmutability` but is for actions.
    This runtime check verifies if the developer modifies the action. This check is
    activated by default.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example violation of** **this rule**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**Fix for** **this violation**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: strictStateSerializability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This runtime check verifies if the values placed in the state are serializable.
    This is essential for persisting the state so that it can be rehydrated in the
    future. This is deactivated by default.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example violation of** **this rule**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '**Fix for** **this violation**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: strictActionSerializability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This runtime check is similar to `strictStateSerializability`, but for actions.
    It checks if the states are serializable. This is done by Redux DevTools to debug
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example violation of** **this rule**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**Fix for** **this violation**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: strictActionWithinNgZone
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This runtime check verifies if the actions are dispatched by asynchronous tasks
    within `NgZone`. This check is deactivated by default.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example violation of** **this rule**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '**Fix for** **this violation**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: strictActionTypeUniqueness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This runtime check prevents developers from registering the same action type
    more than once. This check is deactivated by default.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example violation of** **this rule**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '**Fix for** **this violation**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With that, we have reached the end of this chapter. Let’s revisit the valuable
    things you have learned regarding the concepts and importance of having state
    management in applications.
  prefs: []
  type: TYPE_NORMAL
- en: A store serves as a single source of truth that provides a unidirectional flow
    of data to prevent inconsistency and mishandled subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how to install and configure the NgRx store and NgRx DevTools
    library with parameters for custom configuration. Lastly, you learned about the
    concepts surrounding state management and how to write the different blocks of
    NgRx, such as actions, reducers, effects, and selectors.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will complete the CRUD functionality of our application
    by using the building blocks of NgRx. We will add, remove, and update items using
    actions, effects, and reducers.
  prefs: []
  type: TYPE_NORMAL
