- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Managing States with NgRx
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 NgRx 管理状态
- en: In the previous chapter, we learned about the concepts and features of Reactive
    forms. We implemented `FormGroup`, `FormBuilder`, and `formControlName` to bind
    input values in the form elements in the application. We also discussed how to
    group form control to bind nested properties and create form arrays in our Reactive
    forms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了响应式表单的概念和特性。我们实现了 `FormGroup`、`FormBuilder` 和 `formControlName` 来绑定应用中表单元素中的输入值。我们还讨论了如何在响应式表单中分组表单控件以绑定嵌套属性并创建表单数组。
- en: After that, we learned how to implement validations for form controls to handle
    and verify user input. This will be beneficial for the user experience and help
    us avoid unexpected errors.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们学习了如何为表单控件实现验证以处理和验证用户输入。这将有益于用户体验，并帮助我们避免意外错误。
- en: In this chapter, we will add a new recipe to our application and learn how to
    implement state management, specifically **NgRx**, for handling data in our Angular
    application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向我们的应用添加一个新的食谱，并学习如何实现状态管理，特别是 **NgRx**，以处理我们的 Angular 应用中的数据。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding complexities in managing the states of large applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解在管理大型应用程序状态中的复杂性
- en: State management and the global state
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态管理和全局状态
- en: Getting started and setting up NgRx
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用并设置 NgRx
- en: Writing an action
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写动作
- en: Writing an effect
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写效果
- en: Writing a reducer
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写还原器
- en: Writing a selector and using a selector and dispatching it in a component
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件中编写选择器并使用选择器分发
- en: Configuring the store
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置存储
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following link will take you to the finished version of code for this chapter:
    [https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-12/superheroes](https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-12/superheroes).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接将带您到本章代码的完成版本：[https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-12/superheroes](https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-12/superheroes)。
- en: Understanding complexities in managing the states of large applications
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解在管理大型应用程序状态中的复杂性
- en: Data management in frontend applications is very important, just like how essential
    data management is in backend applications and databases. As we add more features
    to our application, we know that the number of components, modules, and services
    working inside our Angular project is also growing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 前端应用程序中的数据管理非常重要，就像后端应用程序和数据库中的数据管理一样重要。随着我们向应用添加更多功能，我们知道我们 Angular 项目内部工作的组件、模块和服务数量也在增长。
- en: This also means that the data flow in the application is growing and becoming
    complex. A complex data flow can lead to an unmaintainable application, inconsistent
    and scattered states in different components, and nested input and output bindings
    that result in complex code structures. Due to these possible issues when it comes
    to managing data in Angular, a solution called **state management** was introduced
    as a standard solution for maintaining data in frontend applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着应用程序中的数据流正在增长并变得复杂。复杂的数据流可能导致难以维护的应用程序、不同组件中的不一致和分散的状态，以及导致复杂代码结构的嵌套输入和输出绑定。由于在
    Angular 中管理数据时可能出现的这些问题，因此引入了称为 **状态管理** 的解决方案，作为维护前端应用程序数据的标准解决方案。
- en: State management is an extension or library that is mainly used for managing
    and handling data in frontend applications. It introduces a pattern where all
    data being used is stored in one big object that acts as the state of the whole
    application. This concept is also known as a **single source of truth**. In this
    case, no matter how many components or how many services are added to our application,
    there is always a single object where we can retrieve the data we need. You can
    compare this state to an acting database for the frontend application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 状态管理是一个扩展或库，主要用于管理和处理前端应用程序中的数据。它引入了一种模式，其中所有使用的数据都存储在一个大对象中，该对象充当整个应用程序的状态。这个概念也被称为
    **单一事实来源**。在这种情况下，无论我们向应用中添加多少组件或服务，总有一个单一的对象，我们可以从中检索所需的数据。您可以把这个状态比作前端应用程序的数据库。
- en: Before proceeding with state management, let’s compare the flow of data without
    and with state management.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行状态管理之前，让我们比较一下无状态管理和有状态管理的数据流。
- en: The flow of data without state management
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无状态管理的数据流
- en: 'Data flow in Angular starts on the services. We call endpoints in the services
    to retrieve and manage the data that we need for our application. As the number
    of features increases, the number of services added and called increases, resulting
    in a more complex data flow. Let’s look at a graphical illustration of the flow
    of data without state management:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，数据流始于服务。我们调用服务中的端点来检索和管理我们应用程序所需的数据。随着功能的增加，添加和调用的服务数量也会增加，导致数据流更加复杂。让我们看看没有状态管理的数据流图示：
- en: '![Figure 12.1 – The flow of data without state management](img/B18159_12_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 没有状态管理的数据流](img/B18159_12_01.jpg)'
- en: Figure 12.1 – The flow of data without state management
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 没有状态管理的数据流
- en: In the preceding graphical illustration, we can see that we have four different
    services that are responsible for managing different kinds of data; each feature
    retrieves the data it needs from these services.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的图形说明中，我们可以看到我们有四个不同的服务，它们负责管理不同类型的数据；每个功能都从这些服务中检索所需的数据。
- en: As we can see, the retrieval that occurs is scattered as the features are retrieving
    the data on different sources or services. This results in multiple data flows,
    and they can get larger as more services and features are required.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，由于功能在不同的源或服务中检索数据，检索是分散的。这导致多个数据流，并且随着需要更多服务和功能，它们可能会变得更大。
- en: This can also lead to inconsistencies in data being held by each component as
    the source is coming from different services, leading to some unexpected bugs
    in the application. Now, let’s look at the flow of data with state management.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可能导致每个组件持有的数据不一致，因为数据源来自不同的服务，导致应用程序中出现一些意外的错误。现在，让我们看看有状态管理的数据流。
- en: The flow of data with state management
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有状态管理的数据流
- en: 'In the previous data flow, we saw that the flow of data is not optimized, which
    can result in several problems in our application as the data flow’s direction
    is very complex. When implementing state management in our Angular application,
    we will have the following data flow:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的数据流中，我们看到数据流没有得到优化，这可能导致我们应用程序中出现几个问题，因为数据流的流向非常复杂。在我们实现Angular应用程序的状态管理时，我们将有以下数据流：
- en: '![Figure 12.2 – The flow of data with state management](img/B18159_12_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 有状态管理的数据流](img/B18159_12_02.jpg)'
- en: Figure 12.2 – The flow of data with state management
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 有状态管理的数据流
- en: In the preceding graphical illustration, we can see that all of the services
    of our application are handled by state management. We are still using services
    to retrieve data in our database. The significant difference here is that our
    features are now accessing all the retrieved data in the state instead of directly
    accessing it in the services.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的图形说明中，我们可以看到我们的应用程序中的所有服务都由状态管理处理。我们仍然使用服务从数据库中检索数据。这里的一个重要区别是，我们的功能现在是在状态中而不是直接在服务中访问所有检索到的数据。
- en: This allows the data to flow in one direction and has a single origin for all
    the data being used in the application. With this approach, inconsistency in the
    states, possible bugs, and multiple API calls can be avoided.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许数据单向流动，并且所有在应用程序中使用的数据都有一个单一来源。采用这种方法，可以避免状态的不一致性、可能的错误和多次API调用。
- en: With that, we have learned about the importance of state management in developing
    applications, especially enterprise-level apps.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经了解了在开发应用程序中状态管理的重要性，尤其是在开发企业级应用程序时。
- en: Now, let’s discuss more state management concepts and global states.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论更多关于状态管理和全局状态的概念。
- en: State management and the global state
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态管理和全局状态
- en: State management, as discussed in the previous section, is an extension or library
    that allows us to manage the flow of our data in the application in just one direction.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，状态管理是一个扩展或库，它允许我们以单向方式管理应用程序中的数据流。
- en: This is possible due to global states, which will contain all of the data. To
    understand how state management works, let’s discuss each of the building blocks
    of state management.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为全局状态，它将包含所有数据。为了理解状态管理是如何工作的，让我们讨论状态管理的各个构建块。
- en: Global state/store
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局状态/存储
- en: The **global state**, also known as the **store**, is the most crucial element
    in state management. The primary responsibility of a global state is to store
    all the data retrieved by the API or simply data being used in the application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局状态**，也称为**store**，是状态管理中最关键的因素。全局状态的主要责任是存储所有通过API检索到的数据或简单地存储在应用程序中使用的所有数据。'
- en: This means that all components in an Angular application will retrieve the data
    in the global state. Think of it as a database of the Angular application but
    in the form of a JSON object where we can get each property as slices.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Angular应用程序中的所有组件都将从全局状态中检索数据。将其视为Angular应用程序的数据库，但以JSON对象的形式，我们可以获取每个属性作为切片。
- en: Actions
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Actions
- en: '`dispatch()` function, which helps identify what events should be performed,
    such as modifying the state or calling APIs to retrieve data.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispatch()`函数，它有助于识别应该执行哪些事件，例如修改状态或调用API检索数据。'
- en: Actions are just simple interfaces; the `type` property identifies what action
    is dispatched. This simple string is just a definition of the action, and we can
    add properties to the actions for the data we require in the API or state.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 动作只是简单的接口；`type`属性标识了发出的动作。这个简单的字符串只是动作的定义，我们可以为动作添加属性，以添加我们需要的API或状态中的数据。
- en: 'Let’s have a look at an example of an action interface:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看动作接口的一个例子：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding example action is dispatched when a new blog is created. This
    is called when the `title`, `author`, and `content` is added as additional metadata
    to be passed on to the effect or reducer.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，当创建一个新的博客时，会发出这个动作。当`title`、`author`和`content`作为附加元数据添加时，会调用这个动作，以便传递给effect或reducer。
- en: Reducers
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Reducers
- en: '**Reducers** are the decision-makers of state management. They are the ones
    that decide which actions to handle based on the action type. Reducers are also
    the ones that can change the value of the state.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**Reducers**是状态管理的决策者。它们是决定基于动作类型处理哪些动作的那部分。Reducers也是可以改变状态值的那部分。'
- en: 'Reducers are pure functions and handle state transitions synchronously; let’s
    have a look at an example of a reducer:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Reducers是纯函数，并同步处理状态转换；让我们看看一个reducer的例子：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding example, we have created a reducer for the `addBlog()` action.
    This allows us to add a new blog object in the blog’s state once we have dispatched
    the `addBlog()` action.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们为`addBlog()`动作创建了一个reducer。这允许我们在发出`addBlog()`动作后，在博客的状态中添加一个新的博客对象。
- en: We will discuss reducers in more detail later in the *Writing a reducer* section
    of this chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的“编写reducer”部分更详细地讨论reducer。
- en: Selectors
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Selectors
- en: '**Selectors** are pure functions that allow us to retrieve slices of data in
    our store. It is a change detection mechanism where, when the value of the state
    changes, it compares the parts of the state and only sends the state if the changes
    are detected. This is a practice called **memorization**.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择器**是允许我们从store中检索数据片段的纯函数。这是一个变化检测机制，当状态值发生变化时，它会比较状态的部分，并且只有在检测到变化时才发送状态。这是一种称为**记忆化**的实践。'
- en: Selectors are used in components to get the data used in the UI. It is returned
    as an Observable that listens to the state changes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器用于组件中获取UI中使用的数据。它返回一个Observable，该Observable监听状态变化。
- en: 'Let’s look at an example of a selector:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个选择器的例子：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, we have created a selector for the blog slice, as
    well as a function that returns the *blogs* metadata, called `selectBlogList()`.
    We used this function in our `blog` component as a parameter for the `select`
    function to retrieve the data by subscribing to the selector. The subscription
    will emit once the value of the blog’s slice changes. We will discuss selectors
    in more detail in the next section of this chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们为博客切片创建了一个选择器，以及一个返回*blogs*元数据的函数，称为`selectBlogList()`。我们在`blog`组件中将此函数用作`select`函数的参数，通过订阅选择器来检索数据。订阅将在博客切片的值发生变化时发出。我们将在本章的下一节更详细地讨论选择器。
- en: Effects
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Effects
- en: Effects are specific elements that the `NgRx` library uses; this is an *RxJs-powered*
    side effect model that handles external interactions such as API calls, web socket
    messages, and time-based events. Using effects, we can isolate our components
    from interacting with external sources and reduce their responsibilities. Let’s
    look at a comparison between an application with and without side effects.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用是`NgRx`库使用的特定元素；这是一个由`RxJs`驱动的副作用模型，它处理外部交互，如API调用、WebSocket消息和时间相关事件。使用副作用，我们可以将我们的组件从与外部源交互中隔离出来，并减少它们的职责。让我们来看一个具有和没有副作用的应用程序的比较。
- en: Application without side effects
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有副作用的应用程序
- en: 'The following is an application without side effects:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个没有副作用的应用程序：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code example, we have a component that has several responsibilities,
    as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们有一个具有多个职责的组件，如下所示：
- en: Managing the state of the blogs (the component has its blog state)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理博客的状态（组件有自己的博客状态）
- en: Using the blog service to call an external API to get the list of blogs
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用博客服务调用外部API以获取博客列表
- en: Modifying the state of the blog inside the component
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件内部修改博客的状态
- en: This means that every component with a service dependency also has its state
    of data. Now, let’s look at an example of an application with side effects.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每个具有服务依赖的组件也有其数据状态。现在，让我们来看一个具有副作用的应用程序示例。
- en: Application with side effects
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有副作用的应用程序
- en: 'The following is an application with side effects:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个具有副作用的应用程序：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code example, we can see that the code for our blog page component
    has been reduced, and, at the same time, its responsibility is also less complex.
    Now, the component’s responsibility is to dispatch an action that will allow effects
    to identify what service needs to be called to retrieve the data.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到我们的博客页面组件的代码已经减少，同时，其职责也更加简单。现在，组件的职责是分派一个动作，这将允许副作用识别需要调用哪个服务来检索数据。
- en: 'Let’s look at an example effect for the blog state:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个博客状态的示例副作用：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code example, we created a new effect named `loadBlogs$`. This
    effect is responsible for calling the `getAll()` method from the blog service
    to retrieve the list of blogs from the external endpoint. At the same time, it
    is also responsible for dispatching a new action that passes the retrieved blog
    list into the reducer to modify the store. We will discuss how to write effects
    in the next section of this chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们创建了一个名为`loadBlogs$`的新副作用。这个副作用负责从博客服务中调用`getAll()`方法来从外部端点检索博客列表。同时，它还负责分派一个新动作，将检索到的博客列表传递给reducer以修改存储。我们将在本章的下一节讨论如何编写副作用。
- en: 'With that, we’ve seen all of the building blocks that make up state management.
    Let’s look at a detailed graphical illustration of how data flows in state management:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经看到了构成状态管理的所有构建块。让我们来看一个详细的可视化说明，展示在状态管理中数据是如何流动的：
- en: '![Figure 12.3 – How data flows when using NgRx state management](img/B18159_12_03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – 使用NgRx状态管理时数据流的情况](img/B18159_12_03.jpg)'
- en: Figure 12.3 – How data flows when using NgRx state management
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 使用NgRx状态管理时数据流的情况
- en: In the preceding graphical illustration, we can see that our UI components have
    only one responsibility, and this is to dispatch actions. If the action needs
    to call an API, an effect will be called to invoke an API using a service, and
    after getting the response data, the effect will also dispatch an action to call
    a reducer to modify the store.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图形说明中，我们可以看到我们的UI组件只有一个职责，那就是分派动作。如果动作需要调用API，将调用副作用来通过服务调用API，并在获取响应数据后，副作用还将分派一个动作来调用匹配动作类型的reducer以修改存储。
- en: On the other hand, if the action that’s sent from the component will alter the
    state, it will not need any side effects and call the reducer that matches the
    type of the action. All of the changes in the store will be detected by the selectors
    and emit the latest state to be used in the UI components.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果从组件发送的动作将改变状态，它将不需要任何副作用，并调用匹配动作类型的reducer。存储中的所有更改都将被selectors检测到，并发出最新的状态，用于UI组件。
- en: 'With that, we have learned about the necessary concepts surrounding state management
    and how data flows together with the building blocks of state management. In the
    next section, we will learn how to set up and configure one of the most famous
    state management libraries in Angular: **NgRx**.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经了解了围绕状态管理所需的概念以及数据如何与状态管理的构建块一起流动。在下一节中，我们将学习如何设置和配置 Angular 中最著名的状态管理库之一：**NgRx**。
- en: Getting started and setting up NgRx
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用并设置 NgRx
- en: To use NgRx state management, we must install the `@ngrx/store` library; this
    will contain all of the functions that will allow us to configure the store and
    create reducers and actions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 NgRx 状态管理，我们必须安装 `@ngrx/store` 库；这将包含所有允许我们配置存储和创建还原器和操作的函数。
- en: 'To install the `@ngrx/store` library, we must execute the following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 `@ngrx/store` 库，我们必须执行以下命令：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding command will perform the following steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此前命令将执行以下步骤：
- en: Update `package.json` by adding `@ngrx/store` to the dependencies.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加 `@ngrx/store` 到依赖项来更新 `package.json`。
- en: Run `npm install` to install the dependencies.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `npm install` 来安装依赖项。
- en: Update `src/app/app.module.ts` by adding `StoreModule.forRoot(reducers, {})`
    to the `imports` array.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 `StoreModule.forRoot(reducers, {})` 添加到 `imports` 数组来更新 `src/app/app.module.ts`。
- en: Before executing this command, make sure that the version of `@ngrx/store` is
    aligned with the version of your Angular; in our project, our Angular version
    is version `13.3.0`, which means that we need to use version 13 of `@ngrx/store`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此命令之前，请确保 `@ngrx/store` 的版本与您的 Angular 版本一致；在我们的项目中，我们的 Angular 版本是 `13.3.0`
    版本，这意味着我们需要使用 `@ngrx/store` 的 13 版本。
- en: 'Flags are also available that allow us to install `@ngrx/store` with customizations.
    The following is the list of flags we can use:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 也有可用的标志，允许我们使用自定义设置安装 `@ngrx/store`。以下是我们可以使用的标志列表：
- en: '`--path`: Specifies the path to the module where you want to import `StoreModule`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--path`：指定您想要导入 `StoreModule` 的模块的路径。'
- en: '`--project`: The name of the project that is defined in `angular.json`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--project`：在 `angular.json` 中定义的项目名称。'
- en: '`--module`: The name of the file containing the module where you want to import
    `StoreModule`.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--module`：包含您想要导入 `StoreModule` 的模块的文件名。'
- en: '`--minimal`: This provides the minimal setup for the root state management
    if set to `true`. It imports `StoreModule.forRoot()` in the module with an empty
    object.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--minimal`：如果设置为 `true`，则提供根状态管理的最小设置。它在模块中导入 `StoreModule.forRoot()` 并使用空对象。'
- en: '`--statePath`: This is the path where the state will be created.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--statePath`：这是创建状态的位置。'
- en: '`--stateInterface`: The interface that defines the state.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--stateInterface`：定义状态的接口。'
- en: Adding NgRx to our Angular project
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 NgRx 添加到我们的 Angular 项目中
- en: 'Now, let’s add this to our Angular project. We only want to use the minimal
    setup as we will add the reducers and store step by step. After successfully executing
    the `ng add @ngrx/store` command, we will have the following changes in our project:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将其添加到我们的 Angular 项目中。我们只想使用最小设置，因为我们将会逐步添加还原器和存储。在成功执行 `ng add @ngrx/store`
    命令后，我们的项目中将会有以下更改：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code example, we can see that `StoreModule.forRoot()` has been
    added without any objects; this means that we initially imported the store without
    reducers.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到 `StoreModule.forRoot()` 已添加，但没有添加任何对象；这意味着我们最初导入存储时没有还原器。
- en: With that, we have successfully installed `@ngrx/store` in our Angular project.
    Now, we will install another extension to help us debug the state.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经成功地在我们的 Angular 项目中安装了 `@ngrx/store`。现在，我们将安装另一个扩展来帮助我们调试状态。
- en: Installing NgRx DevTools
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 NgRx DevTools
- en: NgRx DevTools is a valuable extension that provides developer tools and instrumentation
    for the store. It allows us to check the values of the state, implement time travel
    debugging, and have a visual representation of the previous and current values
    of the data in our store.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: NgRx DevTools 是一个非常有价值的扩展，它为存储提供了开发者工具和仪表。它允许我们检查状态值，实现时间旅行调试，并可视地表示我们存储中数据的先前和当前值。
- en: 'We must execute the following command to install NgRx DevTools in our Angular
    project:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须执行以下命令来在我们的 Angular 项目中安装 NgRx DevTools：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After successfully executing this command, the following changes will be implemented
    in our project:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功执行此命令后，我们的项目中将实施以下更改：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code example, we can see that a new module called `StoreDevtoolsModule`
    has been added; this will allow DevTools to be used once we run our application
    locally.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到已添加了一个名为`StoreDevtoolsModule`的新模块；这将允许我们在本地运行我们的应用时使用DevTools。
- en: 'The next step to using DevTools is to add the Redux extension to our browser.
    To add this extension, go to one of the following links for your respective browser:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DevTools的下一步是将Redux扩展添加到我们的浏览器中。要添加此扩展，请访问以下链接之一以获取您相应浏览器的链接：
- en: '**Google** **Chrome**: [https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd](https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd)'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google** **Chrome**: [https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd](https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd)'
- en: '**Mozilla** **Firefox**: [https://addons.mozilla.org/en-US/firefox/addon/reduxdevtools/](https://addons.mozilla.org/en-US/firefox/addon/reduxdevtools/)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mozilla** **Firefox**: [https://addons.mozilla.org/en-US/firefox/addon/reduxdevtools/](https://addons.mozilla.org/en-US/firefox/addon/reduxdevtools/)'
- en: 'After adding this extension to your preferred browser, running your Angular
    project with the imported `StoreDevToolModule` module will be automatically detected
    by this extension. It will provide an interface for viewing the state:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在将此扩展添加到您首选的浏览器后，使用导入的`StoreDevToolModule`模块运行您的Angular项目将自动被此扩展检测到。它将提供一个查看状态的界面：
- en: '![Figure 12.4 – Interface of the Redux DevTools extension](img/B18159_12_04.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – Redux DevTools扩展的界面](img/B18159_12_04.jpg)'
- en: Figure 12.4 – Interface of the Redux DevTools extension
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – Redux DevTools扩展的界面
- en: The preceding screenshot shows that our Redux DevTools extension has been activated;
    once we open our Angular project in our browser tab, we will see more Redux DevTools
    in action as we write our code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示我们的Redux DevTools扩展已被激活；一旦我们在浏览器标签中打开我们的Angular项目，我们将在编写代码时看到更多Redux
    DevTools的实际应用。
- en: Now that we have configured our store and installed NgRx DevTools in our application,
    we are ready to write the building blocks for our state management.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了我们的存储并在我们的应用中安装了NgRx DevTools，我们就可以为我们的状态管理编写构建块了。
- en: Writing an action
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写动作
- en: 'The first building block of state management is that we will write our actions.
    When writing actions, we have several rules we can follow so that we have good
    actions in our application:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 状态管理的第一个构建块是我们将编写我们的动作。在编写动作时，我们可以遵循一些规则，以确保我们的应用中有良好的动作：
- en: '**Upfront**: Writing actions should always come first before developing the
    features. This gives us an overview of what should be implemented in the application.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前置**: 编写动作应该在开发功能之前进行。这让我们对应用中应实现的内容有一个概述。'
- en: '**Divide**: We should always categorize the actions based on the event source
    and the associated data.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**划分**: 我们应该始终根据事件源和相关数据对动作进行分类。'
- en: '**Many**: Writing more number actions is not an issue. It is more beneficial
    as more actions create a better overview of the flow of your application.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**众多**: 编写更多动作不是问题。动作越多，对应用流程的概述就越好。'
- en: '**Event-Driven**: Capture *events* as you separate the description of an event
    and how it’s handled.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件驱动**: 在分离事件描述及其处理方式时，捕获*事件*。'
- en: '**Descriptive**: Always provide meaningful information using type metadata.
    This helps debug the state.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述性**: 始终使用类型元数据提供有意义的信息。这有助于调试状态。'
- en: 'Let’s look at an example action that will set the list of blogs in our state:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例动作，该动作将设置我们状态中的博客列表：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code example, we used the `createAction()` function to create
    our action. The `createAction()` function also returns a function that returns
    an object of the action interface; in this case, it will return `"[Blog] Set blog
    list"` as the action type and the array of blogs as the additional properties.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们使用了`createAction()`函数来创建我们的动作。`createAction()`函数还返回一个返回动作接口对象的函数；在这种情况下，它将返回`"[Blog]
    Set blog list"`作为动作类型，以及博客数组作为附加属性。
- en: 'To dispatch the action, we will use the `dispatch()` function and use `setBlogList`
    as a parameter:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要分发动作，我们将使用`dispatch()`函数，并将`setBlogList`作为参数：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Implementing actions in the project
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在项目中实现动作
- en: 'Our primary goal for our project is to create the entire cycle to get the list
    of anti-heroes in our API and place it in our store. The first step is to take
    the actions we need; let’s look at the two actions that we should make for this
    feature:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的首要目标是创建整个周期，从我们的API获取反英雄列表并将其放置在我们的存储中。第一步是获取我们需要的操作；让我们看看为这个功能应该创建的两个操作：
- en: '`getAntiHeroList`: This action will retrieve the list of blogs from the external
    API provided by our Spring project.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAntiHeroList`: 此操作将从我们Spring项目提供的外部API检索博客列表。'
- en: '`setAntiHeroList`: This action will place the retrieved list of blogs in our
    store.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setAntiHeroList`: 此操作将检索到的博客列表放置在我们的存储中。'
- en: Now that we have identified the list of actions we will create, in the `anti-heroes`
    folder, we will create a `state/anti-hero.actions.ts` file where we will place
    all of our actions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了我们将创建的操作列表，在 `anti-heroes` 文件夹中，我们将创建一个 `state/anti-hero.actions.ts`
    文件，我们将放置所有的操作。
- en: 'Let’s place the following code in the `anti-hero.actions.ts` file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将以下代码放置在 `anti-hero.actions.ts` 文件中：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code example, we have created two actions for getting and setting
    the anti-hero list. The first action, `getAntiHeroList`, has a single parameter,
    which is the type. This does not need any additional properties as this will only
    call the API to retrieve the list of anti-heroes through the use of effects.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们创建了两个用于获取和设置反英雄列表的操作。第一个操作 `getAntiHeroList` 有一个单一参数，即类型。这个不需要任何额外的属性，因为这个操作将只通过使用效果调用API来检索反英雄列表。
- en: 'On the other hand, the second action, `setAntiHeroList`, has two parameters:
    the type and an additional property called `antiHero`. This will set the value
    of the store with the retrieved list of anti-heroes through the use of reducers.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，第二个操作 `setAntiHeroList` 有两个参数：类型和一个额外的属性称为 `antiHero`。这将通过使用reducer设置存储中检索到的反英雄列表的值。
- en: It is also excellent practice to make our action definitions enums in our code
    as this will help us avoid typographical errors when using the definition in other
    parts of the application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中将动作定义枚举也是一项非常好的实践，因为这将帮助我们避免在使用定义的其他部分应用程序时出现打字错误。
- en: With that, we have successfully created the required action for our anti-heroes
    list feature. Now, we will discuss how to write effects that will be used to call
    the API and retrieve the anti-hero list.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经成功创建了所需的反英雄列表功能操作。现在，我们将讨论如何编写将用于调用API和检索反英雄列表的效果。
- en: Writing an effect
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个效果
- en: We successfully created our actions in the previous section. Now, we will make
    the effects that will be responsible for calling our external API.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们成功创建了我们的操作。现在，我们将制作负责调用我们的外部API的效果。
- en: Effects are not included in the `@ngrx/store` library; we will install a separate
    library that will allow us to use the functions for effects.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 效果不包括在 `@ngrx/store` 库中；我们将安装一个单独的库，这将允许我们使用效果函数。
- en: 'To install effects in our application, we must execute the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中安装效果，我们必须执行以下命令：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding command will perform the following steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将执行以下步骤：
- en: Update the `package.json` file with the `@``ngrx/effects` dependency.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `@ngrx/effects` 依赖项更新 `package.json` 文件。
- en: Run `npm install` to install the added dependency.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `npm install` 以安装添加的依赖项。
- en: Add `EffectsModule.forRoot()` to the imports array of your `app.module.ts` file.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `EffectsModule.forRoot()` 添加到您的 `app.module.ts` 文件的 `imports` 数组中。
- en: 'Some flags are available that allow us to install `@ngrx/effects` with customizations;
    the following is the list of flags we can use:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些标志可供使用，允许我们使用自定义安装 `@ngrx/effects`；以下是我们可以使用标志的列表：
- en: '`--path`: Specifies the path to the module where you want to import `EffectsModule`.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--path`: 指定您想要导入 `EffectsModule` 的模块的路径。'
- en: '`--project`: The name of the project defined in `angular.json`.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--project`: 在 `angular.json` 中定义的项目名称。'
- en: '`--skipTests`: This creates a test file when it is set to `false`.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--skipTests`: 当设置为 `false` 时，这将创建一个测试文件。'
- en: '`--module`: The name of the file containing the module where you want to import
    `EffectsModule`.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--module`: 包含您想要导入 `EffectsModule` 的模块的文件名。'
- en: '`--minimal`: This provides the minimal setup for the root effects if set to
    `true`. It imports `EffectsModule.forRoot()` in the module with an empty object.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--minimal`: 如果设置为 `true`，则提供根效果的最低设置。它在模块中导入 `EffectsModule.forRoot()` 并使用空对象。'
- en: '`--group`: Group the `effects` files within the `effects` folder.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--group`: 在 `effects` 文件夹内对 `effects` 文件进行分组。'
- en: 'After successfully adding the dependency of the effect to our application,
    we can create our effects. Under the `anti-heroes/state` folder, we must create
    a new file named `anti-hero.effects.ts`. The first thing we need to do is create
    a class that has an `@``Injectable` annotation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功将效果依赖添加到我们的应用程序后，我们可以创建我们的效果。在`anti-heroes/state`文件夹下，我们必须创建一个名为`anti-hero.effects.ts`的新文件。我们需要做的第一件事是创建一个带有`@Injectable`注解的类：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code example, we can see that effects are also service classes
    and can be injected by other services; we have injected the following services
    into `AntiHeroEffects`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到效果也是服务类，并且可以被其他服务注入；我们已经将以下服务注入到`AntiHeroEffects`中：
- en: '`Actions`: A service from `@ngrx/effects` that returns an observable that we
    can assign a type to. This will act as the identifier when an action is dispatched.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Actions`: 来自`@ngrx/effects`的服务，它返回一个我们可以分配类型的可观察对象。这将作为动作分发时的标识符。'
- en: '`AntiHeroService`: Our created service that contains the external APIs for
    our anti-heroes, found under `anti-hero/services/anti-hero.service.ts`.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AntiHeroService`: 我们创建的服务，其中包含我们反英雄的外部API，位于`anti-hero/services/anti-hero.service.ts`。'
- en: '`Router`: Used for redirection once an API call is made.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Router`: 用于API调用后进行重定向。'
- en: After creating our `AntiHeroEffect` class and injecting our services, we can
    begin making our effects. The first thing we need to think of is what kind of
    effect we need to get the anti-heroes since we have the `GET_ANTI_HERO LIST` and
    `SET_ANTI_HERO_LIST` actions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的`AntiHeroEffect`类并注入我们的服务后，我们可以开始制作我们的效果。我们首先需要考虑的是我们需要什么类型的效果来获取反英雄，因为我们有`GET_ANTI_HERO_LIST`和`SET_ANTI_HERO_LIST`动作。
- en: We should create an effect that has a type of `GET_ANTI_HERO_LIST` and can call
    the `getAntiHeroes()` function from `AntiHeroService`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该创建一个类型为`GET_ANTI_HERO_LIST`的效果，并且可以调用`AntiHeroService`中的`getAntiHeroes()`函数。
- en: 'To create this API, we can write the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个API，我们可以编写以下代码：
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code example, we used the `createEffect()` function to create
    our effects; this returns an action that has two parameters:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们使用了`createEffect()`函数来创建我们的效果；这返回一个有两个参数的动作：
- en: '`ofType(AntiHeroActions.GET_ANTI_HERO_LIST)`: The first parameter uses the
    `ofType` operator, which defines the action type of the effect. This means that
    if the `GET_ANTI_HERO_LIST` action is dispatched, this effect will be called.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ofType(AntiHeroActions.GET_ANTI_HERO_LIST)`: 第一个参数使用`ofType`操作符，它定义了效果的动作类型。这意味着如果`GET_ANTI_HERO_LIST`动作被分发，这个效果将被调用。'
- en: '`mergeMap(() => this.antiHeroService.getAntiHeroes()`: The second parameter
    uses the `mergeMap` operator, which will allow us to invoke the `getAntiHeroes()`
    function to call the endpoint.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mergeMap(() => this.antiHeroService.getAntiHeroes()`: 第二个参数使用`mergeMap`操作符，这将允许我们调用`getAntiHeroes()`函数来调用端点。'
- en: 'With that, we have our effect for the `GET_ANTI_HERO_LIST` actions, but this
    is not complete yet. After getting the list of anti-heroes, we want to dispatch
    another action that sets the anti-heroes list in our state. To implement this,
    we can use the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有了针对`GET_ANTI_HERO_LIST`动作的效果，但这还不完整。在获取到反英雄列表后，我们希望分发另一个动作来设置我们状态中的反英雄列表。为此，我们可以使用以下代码：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding code, we have added a pipe to our `mergeMap` operator; this
    calls a `map` operator that returns `({ type: AntiHeroActions.SET_ANTI_HERO_LIST,
    antiHeroes }))`. This will dispatch another action that has a type of `SET_ANTI_HERO_LIST`
    and has additional `antiHeroes` objects coming from the list of anti-heroes retrieved
    from the API.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中，我们向`mergeMap`操作符添加了一个管道；这调用一个返回`({ type: AntiHeroActions.SET_ANTI_HERO_LIST,
    antiHeroes })`的`map`操作符。这将分发另一个类型为`SET_ANTI_HERO_LIST`的动作，并从API获取的反英雄列表中包含额外的`antiHeroes`对象。'
- en: Our effects for getting the list of anti-heroes feature is complete. The last
    step is to add `AntiHeroEffects` to our `effects` module. As we may recall, our
    `anti-heroes` module is lazy loaded, which means that we will not add `AntiHeroEffects`
    to `EffectsModule.forRoot([])` located in the `app.module.ts` file; otherwise,
    we would need to add `EffectsModule.forFeature([AntiHeroEffects])` in the imports
    of the `anti-hero.module.ts` file. This means that this `effects` class is only
    used under this module.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取反英雄列表的效果已经完成。最后一步是将`AntiHeroEffects`添加到我们的`effects`模块中。正如我们可能记得的，我们的`anti-heroes`模块是懒加载的，这意味着我们不会将`AntiHeroEffects`添加到`app.module.ts`文件中的`EffectsModule.forRoot([])`；否则，我们需要在`anti-hero.module.ts`文件的导入中添加`EffectsModule.forFeature([AntiHeroEffects])`。这意味着这个`effects`类只在这个模块中使用。
- en: With that, we have successfully configured and created our effects for the anti-hero
    list feature. In the next section, we will write the reducers that will modify
    our state.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经成功配置并创建了我们的效果以用于反英雄列表功能。在下一节中，我们将编写将修改我们状态的reducer。
- en: Writing a reducer
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写reducer
- en: NgRx states are immutable objects; we cannot modify their values through direct
    assignment, and the only way we can change their states is through reducers.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: NgRx 状态是不可变对象；我们不能通过直接赋值来修改它们的值，我们唯一能改变它们状态的方式是通过reducer。
- en: 'Reducers have different parts that we should implement, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Reducer有不同的部分需要我们实现，如下所示：
- en: The interface or type that defines the properties of the state
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义状态属性的接口或类型
- en: The arguments, which consist of the initial state and the current action
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由初始状态和当前动作组成的参数
- en: The list of functions that handle that state changes based on the dispatched
    actions
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理基于派发动作的状态变化的函数列表
- en: We will create these reducer parts under the `anti-heroes/state/anti-hero.reducers.ts`
    file.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`anti-heroes/state/anti-hero.reducers.ts`文件下创建这些reducer部分。
- en: The state interface
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态接口
- en: The state interface defines the shape of the state; this contains the properties
    or the slices of the state. In our application, we need a property that will hold
    the list of anti-heroes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 状态接口定义了状态的结构；这包含属性或状态的切片。在我们的应用中，我们需要一个属性来保存反英雄列表。
- en: 'To implement the interface, we can use the following code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现接口，我们可以使用以下代码：
- en: '[PRE17]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The initial state
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始状态
- en: The next part we need to implement is the initial state; this defines what the
    initial values of the state slices are. In our anti-hero state, we will set the
    `antiHeroes` slice to an empty array.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的下一个部分是初始状态；这定义了状态切片的初始值。在我们的反英雄状态中，我们将`antiHeroes`切片设置为空数组。
- en: 'To implement this, we can use the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以使用以下代码：
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The reducer function
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Reducer函数
- en: After creating our initial state, we can implement our reducer function; this
    will hold the list of functions that will be called, depending on the type of
    action that is dispatched.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的初始状态后，我们可以实现我们的reducer函数；这将持有根据派发动作的类型将被调用的函数列表。
- en: 'To implement the reducer function, we can use the following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现reducer函数，我们可以使用以下代码：
- en: '[PRE19]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code example, we can see that we have used a `createReducer()`
    function from the `@ngrx/store` library; this will contain all the functions that
    will modify our anti-hero state. The first parameter is our initial state, while
    the second parameter is a function that will be called when an action of `SET_ANTI_HERO_LIST`
    is dispatched.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到我们使用了`@ngrx/store`库中的`createReducer()`函数；这将包含所有将修改我们反英雄状态的函数。第一个参数是我们的初始状态，而第二个参数是在派发`SET_ANTI_HERO_LIST`动作时被调用的函数。
- en: This means that the effect we created earlier will call this once the API has
    retrieved the anti-hero list successfully; this function contains two parameters
    – one that holds the current state and another that holds the list of anti-heroes
    objects from the API. To modify the `antiHeroes` state with the retrieved list,
    we have returned `{…``state, antiHeroes}`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们之前创建的效果在API成功检索到反英雄列表后会调用一次这个函数；这个函数包含两个参数——一个持有当前状态，另一个持有从API获取的反英雄对象列表。为了使用检索到的列表修改`antiHeroes`状态，我们返回了`{…state,
    antiHeroes}`。
- en: Now that we have finished writing the reducers for our state, the last step
    is to register our reducers in the store. We will apply the same rules that we
    applied for the effects; since our anti-heroes module is lazy loaded, we will
    register our anti-hero reducer in our `anti-hero.module.ts` file by adding `StoreModule.forFeature('antiHeroState,'
    antiHeroReducer)`. The first parameter is the key for our anti-hero state, while
    the second is the function returned from the `createReducer()` function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了我们状态的reducer编写，最后一步是在store中注册我们的reducer。我们将应用与效果相同的规则；由于我们的反英雄模块是懒加载的，我们将在`anti-hero.module.ts`文件中注册我们的反英雄reducer，通过添加`StoreModule.forFeature('antiHeroState,'
    antiHeroReducer)`。第一个参数是我们反英雄状态的关键，而第二个是`createReducer()`函数返回的函数。
- en: With that, we have successfully created and registered our reducer for the anti-hero
    list feature. Now, let’s discuss the NgRx selectors to get the state and how to
    dispatch actions in components.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经成功创建并注册了我们的reducer以用于反英雄列表功能。现在，让我们讨论NgRx选择器以获取状态以及如何在组件中派发动作。
- en: Writing a selector and using a selector and dispatching it in a component
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写选择器、使用选择器以及在组件中分发它
- en: In the previous section, we successfully implemented reducers that can mutate
    the values of our state. This means that our state contains valuable data that
    we can get from the Angular components; we can use selectors to do this.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们成功实现了可以修改我们状态值的reducers。这意味着我们的状态包含有价值的数据，我们可以从Angular组件中获取这些数据；我们可以使用选择器来完成这个任务。
- en: Selectors are pure functions that allow us to retrieve slices of state; we can
    use several helper functions, such as `createSelector()` and `createFeatureSelector()`,
    to create our selectors for the store.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器是纯函数，它允许我们检索状态切片；我们可以使用几个辅助函数，如`createSelector()`和`createFeatureSelector()`，来为我们的存储创建选择器。
- en: Selecting root states
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择根状态
- en: 'While selecting the root states, we will be using a pure function to create
    our selector. Let’s look at an example of a selector selecting the list of blogs
    under the root state (`AppState`):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择根状态时，我们将使用纯函数来创建我们的选择器。让我们看看一个选择器选择根状态下的博客列表（`AppState`）的示例：
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding code example, we have only created a function that returns
    the `blogs` slice; this is feasible when we select slices under the project’s
    root state. To use the created selector in our component, we can use the following
    code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们只创建了一个返回`blogs`切片的函数；当我们需要在项目的根状态下选择切片时，这是可行的。为了在我们的组件中使用创建的选择器，我们可以使用以下代码：
- en: '[PRE21]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code example, we injected `Store` from the `@ngrx/store` library.
    `Store` provides a `select` function that accepts selectors as a parameter and
    returns an observable that returns the slice of state that is defined by the selector.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们从`@ngrx/store`库中注入了`Store`。`Store`提供了一个`select`函数，它接受选择器作为参数，并返回一个返回由选择器定义的状态切片的观察者。
- en: In this case, we have subscribed to the `blogs$` observable from the `select(selectBlogs()`
    function to retrieve the `blogs` slice that holds the list of blogs.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们已经从`select(selectBlogs())`函数订阅了`blogs$`观察者，以检索包含博客列表的`blogs`切片。
- en: Selecting feature states
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择功能状态
- en: 'While selecting feature states, we will use the `createSelector()` and `createFeatureSelector()`
    functions to create the selector. Let’s look at an example of a selector selecting
    the list of blogs found under the feature state (`BlogState`):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择功能状态时，我们将使用`createSelector()`和`createFeatureSelector()`函数来创建选择器。让我们看看一个选择器选择功能状态下的博客列表（`BlogState`）的示例：
- en: '[PRE22]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code example, the first step is to create the feature selector
    that will return the whole `BlogState`. Here, we have used `createFeatureSelector()`
    and the state’s key to identify the feature state we want to select.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，第一步是创建一个将返回整个`BlogState`的功能选择器。在这里，我们使用了`createFeatureSelector()`和状态的关键字来识别我们想要选择的功能状态。
- en: The second step is to create the main selector of the blog slice; `createSelector()`
    has two parameters, where the first one is the `BlogState` feature selector, and
    the second one is a function where the returned `BlogState` from the feature selector
    is the parameter. The returned value is the blog slice.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是创建博客切片的主要选择器；`createSelector()`有两个参数，第一个是`BlogState`功能选择器，第二个是一个函数，其中从功能选择器返回的`BlogState`是参数。返回的值是博客切片。
- en: Implementing selectors in our project
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的项目中实现选择器
- en: So far, we have learned how to create selectors using the `createFeatureSelector()`
    and `createSelector()` functions. Now, let’s implement them in our project. The
    first thing we need to identify is the states or slices. The first slice that
    needs a selector is a blog slice located under `AnitHeroState`. Remember that
    `AntiHeroState` is not our root state; this means that we will have a feature
    selector for the following state.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何使用`createFeatureSelector()`和`createSelector()`函数创建选择器。现在，让我们在我们的项目中实现它们。首先，我们需要确定状态或切片。第一个需要选择器的切片是位于`AnitHeroState`下的博客切片。记住，`AntiHeroState`不是我们的根状态；这意味着我们将为以下状态有一个功能选择器。
- en: The second selector we need is the selector for the `antiHeroes` slice, which
    contains the array of anti-heroes retrieved in the API. Finally, the third selector
    we want will need to select specific `antiHero` data from the list based on the
    `id` parameter.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的第二个选择器是`antiHeroes`切片的选择器，它包含从API检索到的反英雄数组。最后，我们想要的第三个选择器将需要根据`id`参数从列表中选择特定的`antiHero`数据。
- en: 'To create all of these selectors, place the following code in the `anti-hero/state/anti-hero.selectors.ts`
    file:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建所有这些选择器，请将以下代码放置在 `anti-hero/state/anti-hero.selectors.ts` 文件中：
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After successfully creating all of the selectors, we can use the `on anti-hero/pages/list.component.ts`
    file by adding the following code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功创建所有选择器之后，我们可以通过在 `anti-hero/pages/list.component.ts` 文件中添加以下代码来使用 `on`：
- en: '[PRE24]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code example, we used the `selectAntiHeroes()` selector to
    get the array of anti-heroes from the state. `antiHeroes$` is an Observable that
    returns the current state of the `antiHero` slice once subscribed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们使用了 `selectAntiHeroes()` 选择器从状态中获取反英雄数组。`antiHeroes$` 是一个 Observable，它返回一旦订阅就返回
    `antiHero` 切片的当前状态。
- en: 'Finally, we must get the anti-heroes list feature. We can do this by dispatching
    the `GET_ANTI_HERO_LIST` action in the list component in the `ngOnInit()` hook.
    This will call the effect that we created earlier, which invokes the endpoint
    for getting the list of anti-heroes:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须获取反英雄列表功能。我们可以通过在列表组件的 `ngOnInit()` 钩子中分发 `GET_ANTI_HERO_LIST` 动作来实现这一点。这将调用我们之前创建的效果，该效果调用获取反英雄列表的端点：
- en: '[PRE25]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With that, we have successfully created selectors for the components to retrieve
    data from the state. In the next section, we will discuss the available configurations
    we can implement for the store.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经成功为组件创建了选择器以从状态中检索数据。在下一节中，我们将讨论我们可以为存储实现的可用配置。
- en: Configuring the store
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置存储
- en: In the previous sections, we created all of the building blocks of NgRx that
    complete a fully functional store for the application. In this section, we will
    learn how to configure the NgRx store using runtime checks.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们创建了 NgRx 的所有构建块，以完成应用程序的完整功能存储。在本节中，我们将学习如何使用运行时检查来配置 NgRx 存储。
- en: Runtime checks
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时检查
- en: Runtime checks are used to configure the NgRx store to allow developers to follow
    the NgRx and Redux core concepts and best practices. This is very useful, especially
    for developers new to NgRx; they display errors regarding development based on
    the activated runtime checks.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时检查用于配置 NgRx 存储，以便开发者遵循 NgRx 和 Redux 的核心概念和最佳实践。这对新手开发者非常有用；它们会根据激活的运行时检查显示有关开发的错误。
- en: '`@ngrx/store` provides six built-in runtime checks:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ngrx/store` 提供了六个内置的运行时检查：'
- en: '`strictStateImmutability`: Checks if the state isn’t mutated (default: *On*)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strictStateImmutability`: 检查状态是否未被修改（默认：*开启*）'
- en: '`strictActionImmutability`: Checks if the actions aren’t mutated (default:
    *On*)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strictActionImmutability`: 检查动作是否未被修改（默认：*开启*）'
- en: '`strictStateSerializability`: Checks if the state is serializable (default:
    *On*)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strictStateSerializability`: 检查状态是否可序列化（默认：*开启*）'
- en: '`strictActionSerializability`: Checks if the actions are serializable (default:
    *Off*)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strictActionSerializability`: 检查动作是否可序列化（默认：*关闭*）'
- en: '`strictActionWithinNgZone`: Checks if actions are dispatched within NgZone
    (default: *Off*)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strictActionWithinNgZone`: 检查动作是否在 NgZone 内分发（默认：*关闭*）'
- en: '`strictActionTypeUniqueness`: Checks if the registered action types are unique
    (default: *Off*)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strictActionTypeUniqueness`: 检查注册的动作类型是否唯一（默认：*关闭*）'
- en: 'To change the default configuration of the runtime checks, we will use the
    `runtimeChecks` property on the root store’s config object. The value of each
    runtime check can be assigned with `true` to activate the check or `false` to
    deactivate the check:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改运行时检查的默认配置，我们将使用根存储配置对象的 `runtimeChecks` 属性。每个运行时检查的值可以通过 `true` 来激活检查或通过
    `false` 来停用检查：
- en: '[PRE26]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: strictStateImmutability
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: strictStateImmutability
- en: This is the number one rule of NgRx. It is activated by default, and the runtime
    checks verify if the developer modifies the state object.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 NgRx 的第一条规则。它默认激活，运行时检查会验证开发者是否修改了状态对象。
- en: '**Example violation of** **this rule**:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**此规则的** **违规示例**:'
- en: '[PRE27]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Fix for** **this violation**:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**此违规的** **修复方法**:'
- en: '[PRE28]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: strictActionImmutability
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: strictActionImmutability
- en: This runtime check is similar to `strictStateImmutability` but is for actions.
    This runtime check verifies if the developer modifies the action. This check is
    activated by default.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此运行时检查类似于 `strictStateImmutability`，但针对动作。此运行时检查验证开发者是否修改了动作。此检查默认激活。
- en: '**Example violation of** **this rule**:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**此规则的** **违规示例**:'
- en: '[PRE29]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Fix for** **this violation**:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**此违规的** **修复方法**:'
- en: '[PRE30]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: strictStateSerializability
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: strictStateSerializability
- en: This runtime check verifies if the values placed in the state are serializable.
    This is essential for persisting the state so that it can be rehydrated in the
    future. This is deactivated by default.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此运行时检查验证放置在状态中的值是否可序列化。这对于持久化状态以便将来重新激活至关重要。此检查默认不激活。
- en: '**Example violation of** **this rule**:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**此规则** **的违规示例**:'
- en: '[PRE31]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Fix for** **this violation**:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**针对** **此违规** **的修复**:'
- en: '[PRE32]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: strictActionSerializability
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: strictActionSerializability
- en: This runtime check is similar to `strictStateSerializability`, but for actions.
    It checks if the states are serializable. This is done by Redux DevTools to debug
    errors.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此运行时检查类似于`strictStateSerializability`，但针对动作。它检查状态是否可序列化。这是通过Redux DevTools进行错误调试完成的。
- en: '**Example violation of** **this rule**:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**此规则** **的违规示例**:'
- en: '[PRE33]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Fix for** **this violation**:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**针对** **此违规** **的修复**:'
- en: '[PRE34]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: strictActionWithinNgZone
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: strictActionWithinNgZone
- en: This runtime check verifies if the actions are dispatched by asynchronous tasks
    within `NgZone`. This check is deactivated by default.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 此运行时检查验证动作是否由`NgZone`内的异步任务分发。此检查默认不激活。
- en: '**Example violation of** **this rule**:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**此规则** **的违规示例**:'
- en: '[PRE35]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Fix for** **this violation**:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**针对** **此违规** **的修复**:'
- en: '[PRE36]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: strictActionTypeUniqueness
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: strictActionTypeUniqueness
- en: This runtime check prevents developers from registering the same action type
    more than once. This check is deactivated by default.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 此运行时检查防止开发者在NgZone中注册相同的动作类型超过一次。此检查默认不激活。
- en: '**Example violation of** **this rule**:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**此规则** **的违规示例**:'
- en: '[PRE37]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Fix for** **this violation**:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**针对** **此违规** **的修复**:'
- en: '[PRE38]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With that, we have reached the end of this chapter. Let’s revisit the valuable
    things you have learned regarding the concepts and importance of having state
    management in applications.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经到达了本章的结尾。让我们回顾一下你在应用状态管理概念和重要性方面学到的宝贵知识。
- en: A store serves as a single source of truth that provides a unidirectional flow
    of data to prevent inconsistency and mishandled subscriptions.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库作为单一的真实来源，提供单向数据流以防止不一致和错误处理订阅。
- en: You also learned how to install and configure the NgRx store and NgRx DevTools
    library with parameters for custom configuration. Lastly, you learned about the
    concepts surrounding state management and how to write the different blocks of
    NgRx, such as actions, reducers, effects, and selectors.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了如何使用自定义配置参数安装和配置NgRx存储库和NgRx DevTools库。最后，你了解了围绕状态管理的概念以及如何编写NgRx的不同块，例如动作、还原器、效果和选择器。
- en: In the next chapter, we will complete the CRUD functionality of our application
    by using the building blocks of NgRx. We will add, remove, and update items using
    actions, effects, and reducers.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过使用NgRx的构建块来完成我们应用程序的CRUD功能。我们将通过动作、效果和还原器添加、删除和更新项目。
