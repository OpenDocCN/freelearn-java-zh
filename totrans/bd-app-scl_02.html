<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Creating Your App Architecture and Bootstrapping with SBT" id="aid-173721"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Creating Your App Architecture and Bootstrapping with SBT</h1></div></div></div><p>In the previous chapter, we learned about Functional Programing and Scala. This chapter will be focused on <span class="strong"><strong>Simple Build Tool </strong></span>(<span class="strong"><strong>SBT</strong></span>) and Activator in order to Bootstrap complex Scala and Play framework projects. Using SBT and Activator, we can perform several development tasks such as building, running tests, and deploying the application (which will be covered in detail in <a class="link" title="Chapter 10.  Scaling up" href="part0116.xhtml#aid-3EK181">Chapter 10</a>, <span class="emphasis"><em>Scaling Up</em></span>). Let's get started.</p><p>In this chapter, we will see the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">SBT basics--installation, structure, and dependencies</li><li class="listitem">Activator basics--creating projects</li><li class="listitem">Overall architecture of our application</li></ul></div><div class="section" title="Introducing SBT"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec33"/>Introducing SBT</h1></div></div></div><p>SBT is the ultimate Scala solution for building and packing Scala applications. SBT has lots of plugins, such as Eclipse and IntelliJ IDEA projects generation, which help a great deal when we are doing Scala development. SBT is built in Scala in order to help you build your Scala applications. However, SBT can still be used to build Java applications if you wish.</p><p>The core features of SBT are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Scala-based build definition</li><li class="listitem">Incremental compilation</li><li class="listitem">Continuous compilation and testing</li><li class="listitem">Great support for testing libraries such as ScalaCheck, Specs, ScalaTest, and JUnit</li><li class="listitem">REPL integration</li><li class="listitem">Parallel Task execution</li></ul></div><p>We will use SBT with the Typesafe Activator to Bootstrap our application later in this very chapter. Before doing so, we will play with SBT to learn the key concepts of setting up a build project for a Scala application. In this book, we will be using SBT version 0.13.11.</p></div></div>
<div class="section" title="Installing SBT on Ubuntu Linux" id="aid-181NK1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec34"/>Installing SBT on Ubuntu Linux</h1></div></div></div><p>Keep in mind that we need to have Java and Scala installed before installing SBT. If you don't have Java and Scala installed, go back to <a class="link" title="Chapter 1. Introduction to FP, Reactive, and Scala" href="part0015.xhtml#aid-E9OE1">Chapter 1</a>, <span class="emphasis"><em>Introduction to FP, Reactive, and Scala</em></span> and follow the installation instructions. Open a terminal window, and run the following commands in order to download and install SBT:</p><pre class="programlisting">
<span class="strong"><strong>$ cd /tmp</strong></span>
<span class="strong"><strong>$ wget https://repo.typesafe.com/typesafe/ivy-releases/org.scala- &#13;
sbt/sbt-launch/0.13.11/sbt-launch.jar?&#13;
_ga=1.44294116.1153786209.1462636319 -O sbt-launch.jar</strong></span>
<span class="strong"><strong>$ chmod +x sbt-launch.jar</strong></span>
<span class="strong"><strong>$ mkdir ~/bin/ &amp;&amp; mkdir ~/bin/sbt/</strong></span>
<span class="strong"><strong>$ mv sbt-launch.jar ~/bin/sbt/</strong></span>
<span class="strong"><strong>$ cd ~/bin/sbt/</strong></span>
<span class="strong"><strong>$ touch sbt</strong></span>
</pre><p>Add the following content to the<code class="literal"> ~/bin/sbt/sbt</code> file:</p><pre class="programlisting">
<span class="strong"><strong>#!/bin/bash</strong></span>
<span class="strong"><strong>w</strong></span>
</pre><p>After saving the <code class="literal">~/bin/sbt/sbt</code> file, we need to give permission to execute the file with the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ chmod u+x ~/bin/sbt/sbt</strong></span>
</pre><p>Now we need to put SBT into the operational system path in order to be able to execute anywhere in the Linux terminal. We need to export SBT through the <code class="literal">PATH</code> command into the <code class="literal">~/.bashrc</code> file. Open the <code class="literal">~/.bashrc</code> file in your favorite editor, and add the following content:</p><pre class="programlisting">
<span class="strong"><strong>export SBT_HOME=~/bin/sbt/</strong></span>
<span class="strong"><strong>export PATH=$PATH:$SBT_HOME</strong></span>
</pre><p>We need to source the file using <code class="literal">$ source ~/.bashrc.</code>
</p><p>Now we can run SBT and move on with the installation. When you now type <code class="literal">$ sbt</code> on your console, SBT will download all the dependencies required for use to run itself.</p></div>
<div class="section" title="Getting started with SBT" id="aid-190861"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec35"/>Getting started with SBT</h1></div></div></div><p>Let's create folder named <code class="literal">hello-world-sbt</code>, and add the following project structure:</p><p>
</p><div class="mediaobject"><img src="../Images/image00235.jpeg" alt="Getting started with SBT"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>For <code class="literal">build.properties</code>, you need to have the following content:</p><pre class="programlisting">    build.properties &#13;
 &#13;
    sbt.version=0.13.11 &#13;
</pre><p>For <code class="literal">hello_world.scala</code>, we will use the following code:</p><pre class="programlisting">    hello_world.scala &#13;
 &#13;
    object SbtScalaMainApp extends App { &#13;
      println("Hello world SBT / Scala App ") &#13;
    } &#13;
</pre><p>For now we will use an SBT DSL. However, since SBT is written Scala, we can use the <code class="literal">build.scala</code> format if we wish. This is handy in some cases, because we can use any kind of Scala code in order to make the build more dynamic and to reuse code and tasks.</p><p>We will set some predefined variables, however, you can create your own variables, which can be used to avoid duplicate code. Finally, let's see the <code class="literal">build.sbt</code> file content as follows:</p><pre class="programlisting">    build.scala &#13;
 &#13;
    name := "hello-world-sbt" &#13;
 &#13;
    version := "1.0" &#13;
 &#13;
    scalaVersion := "2.11.8" &#13;
    scalaVersion in ThisBuild := "2.11.8" &#13;
</pre><p>In the preceding code, we have the name of the application, the version which will be used in the generated JAR file, and also the Scala version used on the application and the one used in the build process. We are ready to build this project, so open your terminal and type <code class="literal">$ sbt compile</code>.</p><p>This instruction will make SBT compile our Scala code, and you should see something like this following screen:</p><pre class="programlisting">
<span class="strong"><strong>$ sbt compile </strong></span>
</pre><p>
</p><div class="mediaobject"><img src="../Images/image00236.jpeg" alt="Getting started with SBT"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Congratulations! SBT just compiled our Scala application. Now we can run the application using SBT. In order to do this, we just need to type <code class="literal">$ sbt run</code> as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ sbt run </strong></span>
</pre><p>
</p><div class="mediaobject"><img src="../Images/image00237.jpeg" alt="Getting started with SBT"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>SBT makes it easier to test and play with your Scala application, because SBT has a REPL like the Scala REPL we were playing with in <a class="link" title="Chapter 1. Introduction to FP, Reactive, and Scala" href="part0015.xhtml#aid-E9OE1">Chapter 1</a>, <span class="emphasis"><em>Introduction to FP, Reactive, and Scala</em></span>. The SBT REPL makes all the Scala code that you might have under the project available at the REPL.</p><p>Execute the command <code class="literal">$ sbt console.</code>
</p><p>
</p><div class="mediaobject"><img src="../Images/image00238.jpeg" alt="Getting started with SBT"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Once you are into the REPL, you can type any Scala code. As you must've realized, I just called the main Scala application directly via <code class="literal">$ SbtScalaMainApp.main(null)</code>.</p></div>
<div class="section" title="Adding dependencies"><div class="titlepage" id="aid-19UOO2"><div><div><h1 class="title"><a id="ch02lvl1sec36"/>Adding dependencies</h1></div></div></div><p>Like any build tool, SBT allows you to resolve dependencies. SBT uses the Ivy / Maven2 patterns to resolve dependencies. So, if you are familiar with Maven2, Gradle, or Ant/Ivy, you will realize that setting SBT dependencies is the same, although with a different syntax. Dependencies are defined in the <code class="literal">build.sbt</code> file. There is no Scala development without unit tests. One of the most popular testing libraries is JUnit (<a class="ulink" href="http://junit.org/junit4/">http://junit.org/junit4/</a>). JUnit works with Java and Scala projects. SBT will download and add JUnit to your Scala application <code class="literal">classpath</code> parameter. We need to edit the <code class="literal">build.sbt</code> file to add JUnit as a dependency as follows:</p><pre class="programlisting">    build.sbt &#13;
    name := "hello-world-sbt" &#13;
 &#13;
    version := "1.0" &#13;
     &#13;
    scalaVersion := "2.11.7" &#13;
    scalaVersion in ThisBuild := "2.11.7" &#13;
 &#13;
    libraryDependencies += "junit" % "junit" % "4.12" % Test &#13;
    libraryDependencies += "com.novocode" % "junit-interface" % "0.11" &#13;
    % "test" &#13;
 &#13;
    testOptions += Tests.Argument(TestFrameworks.JUnit, "-q", "-v") &#13;
</pre><p>As I mentioned before, SBT uses the same pattern as Maven2 / Ivy with: group ID + artifactid + version. If you don't know the pattern for the library you want to add, you can check out the Maven Repository website (they generate SBT configs as well) at the following link: <a class="ulink" href="http://mvnrepository.com/artifact/junit/junit/4.12">http://mvnrepository.com/artifact/junit/junit/4.12</a>.</p><p>
</p><div class="mediaobject"><img src="../Images/image00239.jpeg" alt="Adding dependencies"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>SBT has scope for dependencies. We don't want to ship JUnit as part of the source code dependency. That's why we have the <code class="literal">% Test</code> after the dependency definition.</p><p>Once you have saved the file with the new content, you can run <code class="literal">$ sbt compile</code>. SBT will download JUnit for you and store the jar into the local Ivy repo files located at <code class="literal">/home/YOUR_USER/.ivy2/cache</code>. With the dependency in place, we can add more code and also use SBT to run our tests as follows:</p><pre class="programlisting">    src/main/scala/calc.scala &#13;
    class Calculator{ &#13;
      def sum(a:Int,b:Int):Int = { &#13;
        return a + b &#13;
      } &#13;
      def multiply(a:Int,b:Int):Int = { &#13;
        return a * b &#13;
      } &#13;
    } &#13;
</pre><p>In the preceding code, we just created a simple and straightforward calculator in Scala, which can add two integer numbers and also perform multiplication of two integers numbers. Now we can move on to the unit tests using JUnit. Tests need to be located in the <code class="literal">src/test/scala/</code> folder. Look at the following code:</p><pre class="programlisting">    src/test/scala/calcTest.scala &#13;
 &#13;
    import org.junit.Test &#13;
    import org.junit.Assert._ &#13;
 &#13;
    class CalcTest { &#13;
      @Test &#13;
      def testSumOK():Unit = { &#13;
        val c:Calculator = new Calculator() &#13;
        val result:Int = c.sum(1,5) &#13;
        assertNotNull(c) &#13;
        assertEquals(6,result) &#13;
      } &#13;
 &#13;
      @Test &#13;
      def testSum0():Unit = { &#13;
        val c:Calculator = new Calculator() &#13;
        val result:Int = c.sum(0,0) &#13;
        assertNotNull(c) &#13;
        assertEquals(0,result) &#13;
      } &#13;
 &#13;
      @Test &#13;
      def testMultiplyOk():Unit = { &#13;
        val c:Calculator = new Calculator() &#13;
        val result:Int = c.multiply(2,3) &#13;
        assertNotNull(c) &#13;
        assertEquals(6,result) &#13;
      } &#13;
 &#13;
      @Test &#13;
      def testMultiply0():Unit = { &#13;
        val c:Calculator = new Calculator() &#13;
        val result:Int = c.multiply(5,0) &#13;
        assertNotNull(c) &#13;
        assertEquals(4,result) &#13;
      } &#13;
 &#13;
    } &#13;
</pre><p>Okay, now we can just run the tests with the command <code class="literal">$ sbt test</code> as follows:</p><p>
</p><div class="mediaobject"><img src="../Images/image00240.jpeg" alt="Adding dependencies"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>As you can see in the previous screenshot, all the tests are running. A test is created when we add the Java annotation <code class="literal">@Test</code>, and it needs to be a public function as well. There is one test, called <code class="literal">testMultiply0</code> , which fails, because it expects the result <code class="literal">4</code>, but <code class="literal">5</code> multiplied by <code class="literal">0</code> is zero, so the test is wrong. Let's fix this method by changing assertion to accept zero, like in the following code, and rerun the <code class="literal">$sbt test</code> as follows:</p><pre class="programlisting">    @Test &#13;
    def testMultiply0():Unit = { &#13;
      val c:Calculator = new Calculator() &#13;
      val result:Int = c.multiply(5,0) &#13;
      assertNotNull(c) &#13;
      assertEquals(0,result) &#13;
    } &#13;
</pre><p>
<code class="literal">$ sbt test</code> gives you the following result:</p><p>
</p><div class="mediaobject"><img src="../Images/image00241.jpeg" alt="Adding dependencies"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Hooray! All the tests passed. By default, SBT runs all your tests in parallel, which is great for speeding up build time - nobody likes to wait when doing builds, and Scala is not the fastest tech to build. However, you can disable parallel tests if you want by adding the following line into the <code class="literal">build.sbt</code>:</p><pre class="programlisting">    parallelExecution in Test := false &#13;
</pre></div>
<div class="section" title="Generating Eclipse project files from SBT"><div class="titlepage" id="aid-1AT9A2"><div><div><h1 class="title"><a id="ch02lvl1sec37"/>Generating Eclipse project files from SBT</h1></div></div></div><p>SBT via plugins can generate Eclipse files. It's possible to add these plugins directly into your <code class="literal">build.sbt</code> file. However, there is a better solution. You can define global configurations, which are ideal, because you don't need to add in every simple <code class="literal">build.sbt</code> file you have. This also makes a lot of sense if you are working with multiple projects and/or you are working with open source projects because, as it is a matter of preference, people often do not versionate IDE files.</p><p>Go to the following directory if it exists, otherwise please create the following directory: <code class="literal">/home/YOUR_USER/.sbt/0.13/plugins</code>.</p><p>Now create the file <code class="literal">build.sbt</code> with the following content:</p><p>
<code class="literal">/home/YOUR_USER/.sbt/0.13/plugins/build.sbt</code> Global config file</p><pre class="programlisting">    resolvers += Classpaths.typesafeResolver 
    addSbtPlugin("com.typesafe.sbteclipse" % "sbteclipse-plugin" % 
    "4.0.0") 
</pre><p>Once you save the file with this content, we can reload our SBT application by executing <code class="literal">$ sbt reload</code> , or quit the SBT console (<span class="emphasis"><em>
<span class="strong"><strong>Ctrl</strong></span>
</em></span> + <span class="emphasis"><em>
<span class="strong"><strong>D</strong></span>
</em></span>) and open sbt again using <code class="literal">$ sbt.</code>
</p><pre class="programlisting">
<span class="strong"><strong>$ sbt reload</strong></span>
</pre><p>
</p><div class="mediaobject"><img src="../Images/image00242.jpeg" alt="Generating Eclipse project files from SBT"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Now we can generate Eclipse files by using the command <code class="literal">$ eclipse</code>.</p><p>
</p><div class="mediaobject"><img src="../Images/image00243.jpeg" alt="Generating Eclipse project files from SBT"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Once the generation is done, you can import the .project file generated into Eclipse.</p><p>By default, Eclipse does not attach source folders when generating the Eclipse project. If you want the source code (of third-party deps like Junit), you need to add an extra line into your <code class="literal">build.sbt</code> project. Adding source folders is often a good idea, otherwise, you can't do proper debugging without the source code.</p><p>build.sbt</p><pre class="programlisting">    EclipseKeys.withSource := true 
</pre><p>The SBT Scala application imported into Eclipse is shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="../Images/image00244.jpeg" alt="Generating Eclipse project files from SBT"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div>
<div class="section" title="Application distribution" id="aid-1BRPS1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec38"/>Application distribution</h1></div></div></div><p>For this section, we will play with three different packaging solutions, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The default SBT packagers</li><li class="listitem">SBT assembly plugin</li><li class="listitem">SBT native packager</li></ul></div><p>SBT can generate jars by default. It is also possible to generate RPMs, DEBs, and even docker images via SBT plugins. First of all, let's generate an executable jar. This is done by the task package in SBT. Open your SBT console, and run the <code class="literal">$ sbt package</code>. However, we want to generate a <code class="literal">FAT</code> jar, which is a jar with all other dependencies (jars) of the application. In order to do that, we need to use another plugin called assembly.</p><p>
</p><div class="mediaobject"><img src="../Images/image00245.jpeg" alt="Application distribution"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>The SBT package can generate a jar, but it does not ship the dependencies. In order to use the assembly plugin, create the file <code class="literal">project/assembly.sbt</code>, and add the content as follows:</p><pre class="programlisting">    $ project/assembly.sbt &#13;
    addSbtPlugin("com.eed3si9n" % "sbt-assembly" % "0.11.2") &#13;
</pre><p>In our <code class="literal">build.sbt</code>, we need to import the assembly plugin, like this:</p><p>
<code class="literal">$ build.sbt</code> (put into the top of the file)</p><pre class="programlisting">    import AssemblyKeys._ &#13;
    assemblySettings &#13;
</pre><p>Now we can run <code class="literal">$ sbt assembly</code> to generate our <code class="literal">FAT</code> jar.</p><p>
</p><div class="mediaobject"><img src="../Images/image00246.jpeg" alt="Application distribution"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>There we go. Now we can run this as a normal Java application just using the command <code class="literal">java -jar</code> as follows:</p><pre class="programlisting">    $ java -jar hello-world-sbt/target/scala-2.11/hello-world-sbt-&#13;
    assembly-1.0.jar &#13;
</pre></div>
<div class="section" title="Hello world SBT / Scala App"><div class="titlepage" id="aid-1CQAE2"><div><div><h1 class="title"><a id="ch02lvl1sec39"/>Hello world SBT / Scala App</h1></div></div></div><p>There is another useful plugin for packing the Scala application, which is <code class="literal">sbt-native-packager</code>. <code class="literal">sbt-native-packager</code> can generate packages for Linux OS like DEB and RPM files. Since this is a new plugin, we need to create a file called <code class="literal">plugins.sbt</code> in <code class="literal">project/</code> as follows:</p><pre class="programlisting">    resolvers += "Typesafe repository" at 
    "http://repo.typesafe.com/typesafe/releases/" 
    addSbtPlugin("com.typesafe.sbt" %% "sbt-native-packager" % "1.0.4") 
</pre><p>At the very end of your <code class="literal">build.sbt</code>, you need to add this line:</p><pre class="programlisting">    enablePlugins(JavaAppPackaging) 
</pre><p>Now we can generate packages with <code class="literal">sbt-native-packager</code> using <code class="literal">$ sbt universal:packageBin</code> or <code class="literal">$ sbt universal:packageZipTarball</code> .</p><p>
</p><div class="mediaobject"><img src="../Images/image00247.jpeg" alt="Hello world SBT / Scala App"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Now we have a ZIP and a TGZ file with your application in the folder <code class="literal">hello-world-sbt/target/universal/</code>. Inside this ZIP/TGZ file, we have our application in a jar format with all the dependencies; for now we just have Scala, but if we had more, they would be there as well. There are SH and BAT scripts to run this application easily in Linux(SH) and Windows(BAT) respectively.</p><p>
<code class="literal">sbt-native-packager</code> can also cook docker images. This is great, because that makes it easier to deploy applications into production environments. Our project is fully ready to bake docker images. We need to have docker installed on Linux; you can do so by running the following commands:</p><pre class="programlisting">
<span class="strong"><strong>sudo apt-get update</strong></span>
<span class="strong"><strong>sudo apt-get install docker-engine</strong></span>
<span class="strong"><strong>sudo service docker start</strong></span>
<span class="strong"><strong>sudo docker run hello-world</strong></span>
</pre><p>You should see something like the following screenshot if you've successfully installed Docker:</p><p>
</p><div class="mediaobject"><img src="../Images/image00248.jpeg" alt="Hello world SBT / Scala App"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Now you can run <code class="literal">$ sbt</code>, and then generate your docker images by using the command <code class="literal">$ docker:publishLocal</code>. You will see an output similar to the following:</p><pre class="programlisting">
<span class="strong"><strong>&gt; docker:publishLocal</strong></span>
<span class="strong"><strong>[info] Wrote /home/diego/github/diegopacheco/Book_Building_Reactive_Functional_Scala_Applications/hello-world-sbt/target/scala-2.11/hello-world-sbt_2.11-1.0.pom</strong></span>
<span class="strong"><strong>[info] Sending build context to Docker daemon 5.769 MB</strong></span>
<span class="strong"><strong>[info] Step 1 : FROM java:latest</strong></span>
<span class="strong"><strong>[info] Pulling repository docker.io/library/java</strong></span>
<span class="strong"><strong>[info] 31ae46664586: Pulling image (latest) from docker.io/library/java</strong></span>
<span class="strong"><strong>[info] 31ae46664586: Pulling image (latest) from docker.io/library/java, endpoint: https://registry-1.docker.io/v1/</strong></span>
<span class="strong"><strong>[info] 31ae46664586: Pulling dependent layers</strong></span>
<span class="strong"><strong>[info] e9fa146e2b2b: Pulling metadata</strong></span>
<span class="strong"><strong>[info] Status: Downloaded newer image for java:latest</strong></span>
<span class="strong"><strong>[info] docker.io/library/java: this image was pulled from a legacy registry. Important: This registry version will not be supported in future versions of docker.</strong></span>
<span class="strong"><strong>[info] ---&gt; 31ae46664586</strong></span>
<span class="strong"><strong>[info] Step 2 : WORKDIR /opt/docker</strong></span>
<span class="strong"><strong>[info] ---&gt; Running in 74c3e354e9fd</strong></span>
<span class="strong"><strong>[info] ---&gt; d67542bcaa1c</strong></span>
<span class="strong"><strong>[info] Removing intermediate container 74c3e354e9fd</strong></span>
<span class="strong"><strong>[info] Step 3 : ADD opt /opt</strong></span>
<span class="strong"><strong>[info] ---&gt; f6cec2a2779f</strong></span>
<span class="strong"><strong>[info] Removing intermediate container 0180e167ae2d</strong></span>
<span class="strong"><strong>[info] Step 4 : RUN chown -R daemon:daemon .</strong></span>
<span class="strong"><strong>[info] ---&gt; Running in 837ecff2ffcc</strong></span>
<span class="strong"><strong>[info] ---&gt; 8a261bd9d88a</strong></span>
<span class="strong"><strong>[info] Removing intermediate container 837ecff2ffcc</strong></span>
<span class="strong"><strong>[info] Step 5 : USER daemon</strong></span>
<span class="strong"><strong>[info] ---&gt; Running in 6101bd5b482b</strong></span>
<span class="strong"><strong>[info] ---&gt; e03f5fa23bdf</strong></span>
<span class="strong"><strong>[info] Removing intermediate container 6101bd5b482b</strong></span>
<span class="strong"><strong>[info] Step 6 : ENTRYPOINT bin/hello-world-sbt</strong></span>
<span class="strong"><strong>[info] ---&gt; Running in 43de9335129c</strong></span>
<span class="strong"><strong>[info] ---&gt; eb3961f1e26b</strong></span>
<span class="strong"><strong>[info] Removing intermediate container 43de9335129c</strong></span>
<span class="strong"><strong>[info] Step 7 : CMD</strong></span>
<span class="strong"><strong>[info] ---&gt; Running in 302e1fcd0a3d</strong></span>
<span class="strong"><strong>[info] ---&gt; 04e7872e85fa</strong></span>
<span class="strong"><strong>[info] Removing intermediate container 302e1fcd0a3d</strong></span>
<span class="strong"><strong>[info] Successfully built 04e7872e85fa</strong></span>
<span class="strong"><strong>[info] Built image hello-world-sbt:1.0</strong></span>
<span class="strong"><strong>[success] Total time: 447 s, completed 07/05/2016 17:41:47</strong></span>
<span class="strong"><strong>&gt;</strong></span>
</pre><p>You can confirm that there is a new docker image in your system just by running the command <code class="literal">$ docker ps:</code>
</p><p>
</p><div class="mediaobject"><img src="../Images/image00249.jpeg" alt="Hello world SBT / Scala App"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>The very first image is our docker image generated by the <code class="literal">sbt-native-packager</code> plugin with our Scala application. Congratulations! You have a docker container running with your Scala application. SBT Native Packager is really powerful, yet simple to use. You can get more details on the official documentation site (<a class="ulink" href="http://www.scala-sbt.org/sbt-native-packager/gettingstarted.html">http://www.scala-sbt.org/sbt-native-packager/gettingstarted.html</a>).</p><p>These are the basic things we need to know about SBT to build professional Scala applications. SBT has many other features and possibilities, which you can check it out at <a class="ulink" href="http://www.scala-sbt.org/0.13/docs/index.html">http://www.scala-sbt.org/0.13/docs/index.html</a>. Next, we will learn about Typesafe Activator, which is a wrapper around SBT that makes it easy to use with Play framework applications.</p></div>
<div class="section" title="Bootstrapping our Play framework app with Activator" id="aid-1DOR01"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec40"/>Bootstrapping our Play framework app with Activator</h1></div></div></div><p>Lightband (former Typesafe) has another tool called Activator (<a class="ulink" href="https://www.lightbend.com/community/core-tools/activator-and-sbt">https://www.lightbend.com/community/core-tools/activator-and-sbt</a>), which is a wrapper on top of SBT. Activator makes it easier to create Reactive applications using Scala, Akka, and the Play framework. Don't worry about the Play framework right now, because we will cover that in greater detail in <a class="link" title="Chapter 3. Developing the UI with Play Framework" href="part0052.xhtml#aid-1HIT81">Chapter 3</a>, <span class="emphasis"><em>Developing the UI with Play Framework</em></span>. Akka will be covered in detail in <a class="link" title="Chapter 8. Developing a Chat with Akka" href="part0097.xhtml#aid-2SG6I1">Chapter 8</a>, <span class="emphasis"><em>Developing a chat with Akka</em></span>.</p><p>Let's download and install Activator, and Bootstrap our architecture. Remember, we need to have Java 8 and Scala 2.11 already installed. If you don't have Java 8 or Scala 2.11, go back to <a class="link" title="Chapter 1. Introduction to FP, Reactive, and Scala" href="part0015.xhtml#aid-E9OE1">Chapter 1</a>, <span class="emphasis"><em>Introduction to FP, Reactive, and Scala</em></span> and install them.</p><p>First of all, you need to download activator from here: <a class="ulink" href="https://www.lightbend.com/activator/download">https://www.lightbend.com/activator/download</a>
</p><p>I recommend that you download the minimal package, and let Activator download and install the rest of the other dependencies for you. You can download the minimal package here: <a class="ulink" href="https://downloads.typesafe.com/typesafe-activator/1.3.10/typesafe-activator-1.3.10-minimal.zip">https://downloads.typesafe.com/typesafe-activator/1.3.10/typesafe-activator-1.3.10-minimal.zip</a>.</p><p>For this book, we will be using version 1.3.10. We need to put the <code class="literal">activator/bin</code> folder in the OS PATH.If you want, you can install Activator using the terminal, like this:</p><p>If you want, you can install Activator using the terminal, like this:</p><pre class="programlisting">
<span class="strong"><strong>$ cd /usr/local/</strong></span>
<span class="strong"><strong>$ wget https://downloads.typesafe.com/typesafe-&#13;
activator/1.3.10/typesafe-activator-1.3.10-minimal.zip</strong></span>
<span class="strong"><strong>$ tar -xzf typesafe-activator-1.3.10-minimal.zip</strong></span>
<span class="strong"><strong>$ rm -rf typesafe-activator-1.3.10-minimal.zip</strong></span>
<span class="strong"><strong>$ sudo echo 'export PATH=$PATH:/usr/local/typesafe-activator-&#13;
1.3.10-minimal/bin' &gt;&gt; ~/.bashrc</strong></span>
<span class="strong"><strong>$ source &gt;&gt; ~/.bashrc</strong></span>
</pre><p>In order to test your installation, execute this command:</p><pre class="programlisting">
<span class="strong"><strong>$ activator new ReactiveWebStore</strong></span>
</pre><p>The preceding command will Bootstrap an architecture for you with Scala, Akka, Play framework, and SBT.</p><p>Activator will ask you a series of questions like such as what templates you might like to use. There are a couple of templates for Java applications, Scala applications, Akka applications, and Play applications. For now, we will pick option <code class="literal">6) play-scala</code>.</p><p>The first time you run Activator, it could take some time, because it will download all the dependencies from the web. When Activator finishes, you should see a folder called <code class="literal">ReactiveWebStore</code> in your file system.</p><p>The command <code class="literal">$ activator new ReactiveWebStore</code> shows the following result:</p><p>
</p><div class="mediaobject"><img src="../Images/image00250.jpeg" alt="Bootstrapping our Play framework app with Activator"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>You should enter the <code class="literal">ReactiveWebStore</code> folder if you type <code class="literal">$ ll</code> into the console, and you should also see the following structure:</p><pre class="programlisting">
<span class="strong"><strong>diego@4winds:~/bin/activator-1.3.10-minimal/bin/ReactiveWebStore$ &#13;
ll</strong></span>
<span class="strong"><strong>total 52</strong></span>
<span class="strong"><strong>drwxrwxr-x 9 diego diego 4096 Mai 14 19:03 ./</strong></span>
<span class="strong"><strong>drwxr-xr-x 3 diego diego 4096 Mai 14 19:03 ../</strong></span>
<span class="strong"><strong>drwxrwxr-x 6 diego diego 4096 Mai 14 19:03 app/</strong></span>
<span class="strong"><strong>drwxrwxr-x 2 diego diego 4096 Mai 14 19:03 bin/</strong></span>
<span class="strong"><strong>-rw-rw-r-- 1 diego diego 346 Mai 14 19:03 build.sbt</strong></span>
<span class="strong"><strong>drwxrwxr-x 2 diego diego 4096 Mai 14 19:03 conf/</strong></span>
<span class="strong"><strong>-rw-rw-r-- 1 diego diego 80 Mai 14 19:03 .gitignore</strong></span>
<span class="strong"><strong>drwxrwxr-x 2 diego diego 4096 Mai 14 19:03 libexec/</strong></span>
<span class="strong"><strong>-rw-rw-r-- 1 diego diego 591 Mai 14 19:03 LICENSE</strong></span>
<span class="strong"><strong>drwxrwxr-x 2 diego diego 4096 Mai 14 19:03 project/</strong></span>
<span class="strong"><strong>drwxrwxr-x 5 diego diego 4096 Mai 14 19:03 public/</strong></span>
<span class="strong"><strong>-rw-rw-r-- 1 diego diego 1063 Mai 14 19:03 README</strong></span>
<span class="strong"><strong>drwxrwxr-x 2 diego diego 4096 Mai 14 19:03 test/</strong></span>
</pre><p>The content is explained as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>app</strong></span>: This is the Play framework application folder where we will do the Scala web development.</li><li class="listitem"><span class="strong"><strong>build.sbt</strong></span>: This is the build file; as you can see, Activator has generated the SBT build config for us.</li><li class="listitem"><span class="strong"><strong>conf</strong></span>: This holds the application config files such as logging and Scala/Play app config.</li><li class="listitem"><span class="strong"><strong>project</strong></span>: This is the SBT project folder where we define SBT plugins and SBT version.</li><li class="listitem"><span class="strong"><strong>test</strong></span>: This holds the test source code for our application.</li><li class="listitem"><span class="strong"><strong>public</strong></span>: This holds static HTML assets like Images, CSS, and JavaScript code.</li><li class="listitem"><span class="strong"><strong>bin</strong></span>: This holds a copy of the activator script for Linux/Mac and Windows.</li><li class="listitem"><span class="strong"><strong>libexec</strong></span>: This holds the Activator jar. This is pretty useful, because Activator has packed itself with our application. So, let's say you push this application for GitHub - when someone needs to access this app and download it from GitHub, the SBT file will be there, so they won't need to download it from the Internet. This is especially useful when you are provisioning and deploying applications in production, which this book will cover in detail in <a class="link" title="Chapter 10.  Scaling up" href="part0116.xhtml#aid-3EK181">Chapter 10</a>, <span class="emphasis"><em>Scaling Up</em></span>.</li></ul></div></div>
<div class="section" title="Activator shell" id="aid-1ENBI1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec41"/>Activator shell</h1></div></div></div><p>Activator allows you to run REPL like we did in Scala and SBT. In order to get REPL access, you need to type the following on the console:</p><p>$ activator shell</p><p>
</p><div class="mediaobject"><img src="../Images/image00251.jpeg" alt="Activator shell"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Activator has plenty of tasks that you can use. In order to know all the available commands, you can type <code class="literal">$ activator help</code> on the console.</p><p>
</p><div class="mediaobject"><img src="../Images/image00252.jpeg" alt="Activator shell"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div>
<div class="section" title="Activator - compiling, testing, and running"><div class="titlepage" id="aid-1FLS42"><div><div><h1 class="title"><a id="ch02lvl1sec42"/>Activator - compiling, testing, and running</h1></div></div></div><p>Let's get to business now. We will compile, run tests, and run our web application using Activator and SBT. First of all, let's compile. Type <code class="literal">$ activator compile</code> on the console as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ activator compile</strong></span>
<span class="strong"><strong>diego@4winds:~/bin/activator-1.3.10-minimal/bin/ReactiveWebStore$ &#13;
activator compile</strong></span>
<span class="strong"><strong>[info] Loading global plugins from /home/diego/.sbt/0.13/plugins</strong></span>
<span class="strong"><strong>[info] Loading project definition from /home/diego/bin/activator-&#13;
1.3.10-minimal/bin/ReactiveWebStore/project</strong></span>
<span class="strong"><strong>[info] Set current project to ReactiveWebStore (in build &#13;
file:/home/diego/bin/activator-1.3.10-&#13;
minimal/bin/ReactiveWebStore/)</strong></span>
<span class="strong"><strong>[info] Updating {file:/home/diego/bin/activator-1.3.10-&#13;
minimal/bin/ReactiveWebStore/}root...</strong></span>
<span class="strong"><strong>[info] Compiling 14 Scala sources and 1 Java source to &#13;
/home/diego/bin/activator-1.3.10-&#13;
minimal/bin/ReactiveWebStore/target/scala-2.11/classes...</strong></span>
<span class="strong"><strong>[success] Total time: 154 s, completed 14/05/2016 19:28:03</strong></span>
<span class="strong"><strong>diego@4winds:~/bin/activator-1.3.10-minimal/bin/ReactiveWebStore$</strong></span>
</pre><p>Let's run our tests now with the command <code class="literal">$ activator test</code>.</p><p>
</p><div class="mediaobject"><img src="../Images/image00253.jpeg" alt="Activator - compiling, testing, and running"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Finally, it's time to run your application. Type <code class="literal">$ activator run</code> on the console.</p><p>
</p><div class="mediaobject"><img src="../Images/image00254.jpeg" alt="Activator - compiling, testing, and running"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Open your web browser, and go to the URL: <code class="literal">http://localhost:9000</code>.</p><p>You should see a screen like the following:</p><p>
</p><div class="mediaobject"><img src="../Images/image00255.jpeg" alt="Activator - compiling, testing, and running"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div>
<div class="section" title="Summary" id="aid-1GKCM1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec43"/>Summary</h1></div></div></div><p>Congratulations! You've just Bootstrapped your first Scala / Play framework first. Activator makes our life easier. As you can see, with three commands, we were able to get a site up and running. You could do the same with just SBT, however, it would take more time, because we would need to get all the dependencies, configure all the source code structure, and add some sample HTML and Scala code. Thanks to Activator, we don't need to do any of that. However, we can still change all the SBT files and configs as per our wish. Activator is not tight with Scala or our application code, since it is more like a template-based code generator.</p><p>In the next chapter, we will be improving the application by adding validations, database persistence, Reactive Microservices calling using RxScala and Scala, and much more.</p></div></body></html>