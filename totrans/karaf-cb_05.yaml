- en: Chapter 5. Hosting Web Services with Apache CXF
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。使用Apache CXF托管Web服务
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Installing Apache CXF modules in Apache Karaf
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Apache Karaf中安装Apache CXF模块
- en: Using the CXF list endpoints command
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CXF列出端点命令
- en: Using the CXF stop/start endpoints command
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CXF停止/启动端点命令
- en: Building and deploying a RESTful service in Karaf
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Karaf中构建和部署RESTful服务
- en: Building and deploying a Camel CXF web service in Karaf
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Karaf中构建和部署Camel CXF Web服务
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In [Chapter 3](ch03.html "Chapter 3. Deploying a Message Broker with Apache
    ActiveMQ"), *Deploying a Message Broker with Apache ActiveMQ*, we discussed how
    and when to set up JMS systems. Another way to communicate between systems or
    applications is to provide web service or RESTful endpoints. Apache CXF provides
    a way to easily set up and publish web service endpoints. Publishing web services
    in Apache Karaf provides commands to control the endpoint lifecycle and monitor
    what is deployed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。使用Apache ActiveMQ部署消息代理")中，*使用Apache ActiveMQ部署消息代理*，我们讨论了如何以及何时设置JMS系统。另一种在系统或应用程序之间进行通信的方式是提供Web服务或RESTful端点。Apache
    CXF提供了一种轻松设置和发布Web服务端点的方法。在Apache Karaf中发布Web服务提供了控制端点生命周期和监控已部署内容的命令。
- en: Installing Apache CXF modules in Apache Karaf
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Apache Karaf中安装Apache CXF模块
- en: Before we can deploy any web service or RESTful services, we need to get CXF
    installed in the Karaf container. Just like other frameworks, we need to get the
    features that support the required services installed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够部署任何Web服务或RESTful服务之前，我们需要在Karaf容器中安装CXF。就像其他框架一样，我们需要安装支持所需服务的特性。
- en: How to do it…
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To install the CXF framework, just install the CXF feature from the default
    Karaf instance. If no version is specified, it will use the latest version. For
    this example, we are using `version 3.0.0-milestone2`. We can do this using the
    following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装CXF框架，只需从默认的Karaf实例安装CXF特性。如果没有指定版本，它将使用最新版本。在这个例子中，我们使用`version 3.0.0-milestone2`。我们可以使用以下命令完成此操作：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the feature URL is added, we can see all the CXF features that are provided.
    This can be done using the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了特性URL，我们就可以看到所有提供的CXF特性。这可以通过以下命令完成：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The list of CXF features is extensive, but for all of our recipes, we can simply
    install the CXF feature using the following command. This will install all the
    required features that will be used in this book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: CXF特性的列表非常广泛，但对我们所有的配方来说，我们只需使用以下命令简单地安装CXF特性。这将安装本书中将使用的所有所需特性。
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can see that a large number of the required features have been installed
    at this point. The following list is a subset from a `feature:list` command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，此时已经安装了大量所需特性。以下列表是从`feature:list`命令的一个子集：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'If we look at the `features.xml` file from the CXF code base, we can see that
    the `cxf` feature is just a feature that installs all the required features for
    CXF deployment in Karaf. This is shown in the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看CXF代码库中的`features.xml`文件，我们可以看到`cxf`特性只是一个安装所有在Karaf中部署CXF所需特性的特性。这如下面的代码所示：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `cxf` feature adds a compatibility bundle for the required bundle, as stated
    in the `features.xml` file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`cxf`特性为所需的包添加了一个兼容性包，如`features.xml`文件中所述。'
- en: See also
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Using the CXF list-endpoints command* recipe
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用CXF列出端点命令*配方'
- en: The *Using the CXF stop and start commands* recipe
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用CXF停止和启动命令*配方'
- en: Using the CXF list-endpoints command
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CXF列出端点命令
- en: In order to view what is deployed into an instance of CXF, we can use the `list-endpoints`
    command. This will list out all the buses currently deployed in the Karaf runtime.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看部署到CXF实例中的内容，我们可以使用`list-endpoints`命令。这将列出在Karaf运行时当前部署的所有总线。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This recipe is only to demonstrate the use of the commands; we will cover how
    to create different CXF bundles in later recipes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方只是为了演示命令的使用；我们将在后面的配方中介绍如何创建不同的CXF包。
- en: Getting ready
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: After completing the *Installing Apache CXF modules in Apache Karaf* recipe,
    we now need to build and deploy a sample CXF application into Karaf.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成*在Apache Karaf中安装Apache CXF模块*配方后，我们现在需要构建和部署一个示例CXF应用程序到Karaf。
- en: 'Go to the code bundle of this chapter and run the Maven build using the following
    command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前往本章的代码包，并使用以下命令运行Maven构建：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will build and install the sample applications for this chapter in the
    Maven repository so we can easily install them in the Karaf instance.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在Maven仓库中构建和安装本章的示例应用程序，以便我们可以在Karaf实例中轻松安装它们。
- en: 'From the command line in the Karaf instance, install this recipe''s CXF module
    using the following command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Karaf实例的命令行中，使用以下命令安装此配方的CXF模块：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How to do it…
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We can run the following command to list CXF endpoints published in this instance
    of Karaf:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行以下命令来列出在此Karaf实例中发布的CXF端点：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will provide us with a list of CXF buses that have been started from our
    sample bundle. This is shown in the following command-line output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供一个列表，其中包含从我们的示例包中启动的CXF总线。以下命令行输出显示了这一点：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see from the result that our endpoint is published and available. The
    name of the implementation class name is `StringRestServiceImpl`. Also note that
    it is in the `Started` state and the address where we can locate the REST service.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中我们可以看到，我们的端点已发布并可用。实现类的名称是`StringRestServiceImpl`。此外，请注意它处于`Started`状态，以及我们可以找到REST服务的地址。
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use the `–f` parameter on the `list-endpoints` command to get the full address
    to the endpoint.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`list-endpoints`命令的`-f`参数来获取端点的完整地址。
- en: So let's give this a try. When you go to `http://localhost:8181/cxf/chapter5/recipeTwo`,
    it will display the message returned from the recipe code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们试一试。当你访问`http://localhost:8181/cxf/chapter5/recipeTwo`时，它将显示配方代码返回的消息。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The type of browser might impact what you see; we are using Chrome in this example.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器的类型可能会影响您看到的内容；在这个例子中，我们使用Chrome。
- en: 'The following screenshot displays what will be seen in the browser:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在浏览器中将会看到的内容：
- en: '![How to do it…](img/5081OS_05_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/5081OS_05_03.jpg)'
- en: As you can see, we are able to hit the endpoint and see our message from the
    implementation class.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们能够访问端点并看到实现类中的消息。
- en: How it works…
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Just like the `list-busses` command, this command uses the CXF controller to
    get the information needed for display in the console. The code for this is in
    the `ListEndpointsCommand` class. This will get the buses using the CXF controller,
    and then loop through the list and pull the ServiceRegistry in order to get a
    list of servers. From the server, we can get the rest of the details of the list,
    including the name, state, and address.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`list-busses`命令一样，此命令使用CXF控制器来获取控制台显示所需的信息。此代码位于`ListEndpointsCommand`类中。这将使用CXF控制器获取总线，然后遍历列表并获取ServiceRegistry以获取服务器列表。从服务器，我们可以获取列表的其余详细信息，包括名称、状态和地址。
- en: See also
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using the CXF stop and start commands* recipe
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用CXF停止和启动命令*配方'
- en: Using the CXF stop and start commands
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CXF停止和启动命令
- en: In some instances, there might be a need to control the state of the endpoint
    manually. Using the `stop-endpoint` or `start-endpoint` commands, we can shut
    down and start up a published endpoint from the command line. This is useful when
    testing client code to make sure that you are handling unavailable endpoints correctly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能需要手动控制端点的状态。使用`stop-endpoint`或`start-endpoint`命令，我们可以从命令行关闭和启动已发布的端点。这在测试客户端代码以确保正确处理不可用端点时非常有用。
- en: Getting ready
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Follow the steps from the *Using the CXF list-endpoints command* recipe.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 按照从*使用CXF list-endpoints命令*配方中的步骤操作。
- en: How to do it…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s look at how to use the `stop-endpoint` and `start-endpoint` commands.
    Both commands require parameters for the bus and endpoint in order to know what
    to start or stop. The syntax for these commands looks like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`stop-endpoint`和`start-endpoint`命令。这两个命令都需要提供总线参数和端点参数，以便知道要启动或停止什么。这些命令的语法如下所示：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To stop an endpoint, follow these steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止一个端点，请按照以下步骤操作：
- en: 'Use the `list-endpoints` command to get the bus ID and the name of our published
    endpoint. The following will be the output:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`list-endpoints`命令获取总线ID和我们的已发布端点的名称。以下将是输出：
- en: '[PRE10]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The information in the output of the preceding step can now be used to start
    and stop endpoints published in this instance of Karaf. Consider the following
    command:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前一步骤的输出中的信息现在可以用来启动和停止在此Karaf实例中发布的端点。考虑以下命令：
- en: '[PRE11]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding command will stop the endpoint we published in the *Getting ready*
    section. Rerun the `list-endpoints` command in order to see the state change as
    follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的命令将停止在*准备工作*部分发布的端点。重新运行`list-endpoints`命令以查看状态变化如下：
- en: '[PRE12]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Notice that the state has been changed to `Stopped`. This indicates that our
    REST service endpoint is no longer available from our browser. Use a browser to
    hit this endpoint address: `http://localhost:8181/cxf/chapter5/recipeTwo`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，状态已更改为`Stopped`。这表示我们的REST服务端点不再从我们的浏览器中可用。使用浏览器访问此端点地址：`http://localhost:8181/cxf/chapter5/recipeTwo`。
- en: 'The browser cannot find the address specified, which is exactly what we expect
    to happen. The following screenshot is what you should see:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器找不到指定的地址，这正是我们期望发生的。以下截图是你应该看到的：
- en: '![How to do it…](img/5081OS_05_02.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/5081OS_05_02.jpg)'
- en: 'Now, perform the following steps to start the endpoint again:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行以下步骤重新启动端点：
- en: 'Use the endpoint listed in the `list-endpoints` command as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`list-endpoints`命令中列出的端点如下：
- en: '[PRE13]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will start the endpoint we published in the *Getting ready* section. Rerun
    the `list-endpoints` command in order to see the state change as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将启动我们在*准备工作*部分发布的端点。重新运行`list-endpoints`命令，以查看状态变化如下：
- en: '[PRE14]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works…
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The command is made available from the `cxf` feature implemented by the `StopEndpointCommand`
    class (the `start-endpoint` command is very similar). This is shown in the following
    code line:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 命令由`StopEndpointCommand`类（`start-endpoint`命令非常相似）实现的`cxf`功能提供。这如下面的代码行所示：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The command annotation shows you that the CXF defines the subshell and the
    command name is `stop-endpoint`. This command also has several required parameters
    defined by the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 命令注释显示CXF定义了子shell，命令名称为`stop-endpoint`。此命令还定义了以下代码中定义的几个必需参数：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There are two parameters that are required (as noted by the `required=true`
    parameter in the `Argument` annotation).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个参数是必需的（如`Argument`注释中的`required=true`参数所示）。
- en: See also
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using the CXF list-endpoints command* recipe
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用CXF list-endpoints命令*配方'
- en: Building and deploying a RESTful service in Karaf
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Karaf中构建和部署RESTful服务
- en: Now, let's look at how the code is assembled in order to publish a CXF endpoint
    in Karaf using just CXF.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看代码是如何组装的，以便仅使用CXF在Karaf中发布CXF端点。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will work with the `chapter5-recipe3` example from the code
    bundle. Uninstall the `recipe2` code before going ahead with this recipe
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用代码包中的`chapter5-recipe3`示例。在继续此配方之前，请先卸载`recipe2`代码。
- en: First, install CXF as shown in the *Installing Apache CXF modules in Apache
    Karaf* recipe, and then build and deploy a sample CXF application as `recipe3`
    in Karaf.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照*在Apache Karaf中安装Apache CXF模块*配方所示安装CXF，然后构建并部署一个示例CXF应用程序，作为Karaf中的`recipe3`。
- en: 'Go to the `chapter5-recipe3` example from the code bundle and run the Maven
    build using the following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码包中的`chapter5-recipe3`示例运行Maven构建，使用以下命令：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will build and install the sample applications for the `chapter5-recipe3`
    example into the Maven repository, so we can easily install them in the Karaf
    instance.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在Maven仓库中构建和安装`chapter5-recipe3`示例的样本应用程序，这样我们就可以轻松地在Karaf实例中安装它们。
- en: How to do it…
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Once the bundle is deployed, we can look at deploying and starting the CXF endpoint.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦部署了包，我们就可以查看部署和启动CXF端点。
- en: 'From the command line in the Karaf instance, install the `chapter5-recipe3`
    example''s CXF module, start the bundle, and publish the endpoint with the following
    command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Karaf实例的命令行中，安装`chapter5-recipe3`示例的CXF模块，启动包，并使用以下命令发布端点：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `list-endpoints` command will show us that our endpoint has been started
    and is available, as shown in the following command-line snippet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`list-endpoints`命令将显示我们的端点已启动且可用，如下面的命令行片段所示：'
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that we have verified that our endpoint is published, let''s test it by
    hitting this endpoint address: `http://localhost:8181/cxf/chapter5/recipeThree`.
    The output is as shown in the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了我们的端点已发布，让我们通过访问此端点地址来测试它：`http://localhost:8181/cxf/chapter5/recipeThree`。输出如下所示截图：
- en: '![How to do it…](img/5081OS_05_04.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/5081OS_05_04.jpg)'
- en: How it works…
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Let's examine the different pieces of this puzzle to find out how we got the
    endpoint published.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这个拼图中不同的部分，以了解我们是如何发布端点的。
- en: 'First, we need to define the endpoint using an interface. In the sample code,
    look at the `StringRestService` interface class shown as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用一个接口定义端点。在示例代码中，查看以下所示的`StringRestService`接口类：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `@Path("/")` annotation is set to null. This means that there is no address
    location that has been defined to access this RESTful endpoint.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Path("/")`注解被设置为null。这意味着没有定义地址位置来访问此RESTful端点。'
- en: This interface only defines the `@GET` value (not the `@POST` value) of the
    RESTful endpoint. In order to access this endpoint, we only need to use the `/recipeThree`
    location after the default in order to access the `getRecipeThree()` method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口仅定义了RESTful端点的`@GET`值（而不是`@POST`值）。为了访问此端点，我们只需在默认值之后使用`/recipeThree`位置即可访问`getRecipeThree()`方法。
- en: The `@Produces` annotation defines the type of data that will be returned to
    the caller. In this case, we are defining XML via `application/xml`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Produces`注解定义了将返回给调用者的数据类型。在这种情况下，我们通过`application/xml`定义了XML。'
- en: 'Then, we have to implement the interface in order to process the request to
    the endpoint. In our simple example, we are just returning a string value with
    XML. The implementation class looks like the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须实现接口以处理对端点的请求。在我们的简单示例中，我们只是返回一个带有XML的字符串值。实现类如下所示：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The implementation class is simple—we are creating the `getRecipeThree` method
    and returning an XML string.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 实现类很简单——我们正在创建`getRecipeThree`方法并返回一个XML字符串。
- en: 'Now that we have the interface and implementation class defined, we need to
    configure the endpoint. Consider the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了接口和实现类，我们需要配置端点。考虑以下代码：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When working in the OSGi environment, it is suggested that you use Blueprint.
    The preceding XML code is from a Blueprint XML file.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在OSGi环境中工作时，建议您使用Blueprint。前面的XML代码来自一个Blueprint XML文件。
- en: In this configuration, we are defining the `cxf` bus and adding the `logging`
    feature. There is no reason to specify the implementation class for the bus since
    all of the logging information is embedded in the underlying schema definition.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置中，我们正在定义`cxf`总线并添加`logging`功能。由于所有日志信息都嵌入在底层模式定义中，因此没有必要指定总线的实现类。
- en: Then, we need to instantiate the implementation class as a bean. Here, we give
    this an ID of `stringRestServiceBean`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将实现类实例化为一个Bean。在这里，我们给它一个ID为`stringRestServiceBean`。
- en: This bean ID is used in the server configuration to define ServiceBean. This
    will use the interface class implemented by the implementation class to publish
    the endpoint at the `/chapter5` location. Since we did not define a class with
    a base location, the address will look like `http://localhost:8181/cxf/chapter5/recipeThree`
    once it is deployed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此Bean ID用于服务器配置中定义ServiceBean。这将使用实现类实现的接口类在`/chapter5`位置发布端点。由于我们没有定义一个具有基本位置的类，因此一旦部署，地址将看起来像`http://localhost:8181/cxf/chapter5/recipeThree`。
- en: Notice that in the previous URL, the `/chapter5` location comes first, which
    is the address for the JAX-RS server, followed by the path defined in the interface
    class.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的URL中，`/chapter5`位置首先出现，这是JAX-RS服务器的地址，然后是接口类中定义的路径。
- en: See also
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Building and deploying a Camel CXF web service in Karaf* recipe.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在Karaf中构建和部署Camel CXF web服务*的配方。'
- en: Building and deploying a Camel CXF web service in Karaf
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Karaf中构建和部署Camel CXF web服务
- en: In the previous recipe, we saw how easy it can be to deploy a RESTful service
    using CXF and Karaf. Now, we will explore how to deploy a WSDL first CXF endpoint
    using Camel. This is a good way to implement integration routes that expose web
    services. Uninstall the `recipe2` code before going ahead with this recipe
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配方中，我们看到了如何使用CXF和Karaf轻松部署RESTful服务。现在，我们将探讨如何使用Camel部署WSDL首先的CXF端点。这是实现暴露Web服务的集成路由的好方法。在继续此配方之前，请先卸载`recipe2`代码。
- en: Getting ready
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example code for this recipe is in the `chapter5-recipe4` example of the
    code bundle. More than likely, you have already built the code, but just in case,
    go ahead and run the `mvn clean install` command against the `chapter5` folder.
    This will build and move the bundle to the Maven repository for deployment in
    Karaf.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的示例代码位于代码包的`chapter5-recipe4`示例中。很可能您已经构建了代码，但以防万一，请运行针对`chapter5`文件夹的`mvn
    clean install`命令。这将构建并将包移动到Maven仓库以在Karaf中部署。
- en: 'Notice that there is the following line in the console for the build:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在构建控制台中有以下行：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding line indicates that the codegen plugin for CXF has been run and
    has generated the code from the WSDL defined in the `pom.xml` file. The following
    is the plugin definition that instructs Maven to build code from the WSDL:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行表示CXF的codegen插件已运行，并已从`pom.xml`文件中定义的WSDL生成了代码。以下是指示Maven从WSDL构建代码的插件定义：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The WSDL is identified by the `<wsdl>` tags, so we can see that the `report_domain.wsdl`
    file is found in the `${basedir}/src/main/resources/META-INF/wsdl/` directory.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: WSDL由`<wsdl>`标签标识，因此我们可以看到`report_domain.wsdl`文件位于`${basedir}/src/main/resources/META-INF/wsdl/`目录中。
- en: The `wsdl2java` goal indicates that we want the plugin to generate the necessary
    files from the WSDL.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`wsdl2java`目标表示我们希望插件从WSDL生成必要的文件。'
- en: How to do it…
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'First, we need to get the environment set up to run our Camel CXF endpoint.
    This can be done as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置环境以运行我们的Camel CXF端点。这可以按以下方式完成：
- en: 'We need to get Apache Camel installed using the following Camel feature command:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要使用以下Camel功能命令安装Apache Camel：
- en: '[PRE25]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will add the feature definitions for Camel into the Karaf instance.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将为Camel的功能定义添加到Karaf实例中。
- en: 'Now, we need to actually install the `camel` and `camel-cxf` features using
    the following commands:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要实际使用以下命令安装`camel`和`camel-cxf`功能：
- en: '[PRE26]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once the `camel` and `camel-cxf` features are installed, we can install the
    bundle for this recipe using the following command:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦安装了`camel`和`camel-cxf`功能，我们可以使用以下命令安装此菜谱的包：
- en: '[PRE27]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can list the bundles in order to make sure that the bundle was successfully
    installed using the `bundle:list` command. The output will be as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`bundle:list`命令列出包，以确保包已成功安装。输出将如下所示：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can see that the last bundle is our recipe bundle. It has been started and
    is active, which indicates that the endpoint has been published.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到最后一个包是我们的菜谱包。它已启动并处于活动状态，这表明端点已发布。
- en: 'To verify this, we can use CXF commands. When we use the `karaf@root()> cxf:list-busses`
    command, the output will be as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这一点，我们可以使用CXF命令。当我们使用`karaf@root()> cxf:list-busses`命令时，输出将如下所示：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When we use the `karaf@root()> cxf:list-endpoints -f` command, the output will
    be as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`karaf@root()> cxf:list-endpoints -f`命令时，输出将如下所示：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This indicates that our Camel CXF web service is deployed and available at `http://localhost:9080/webservices/domain`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们的Camel CXF Web服务已部署并可在`http://localhost:9080/webservices/domain`处访问。
- en: You can also look at the WSDL code available from the endpoint at `http://localhost:9080/webservices/domain?wsdl`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以查看端点`http://localhost:9080/webservices/domain?wsdl`上可用的WSDL代码。
- en: 'Put the preceding address in your favorite web browser and we will see the
    WSDL code. This should look like the following screenshot:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述地址放入您喜欢的网页浏览器中，我们将看到WSDL代码。这应该看起来像以下截图：
- en: '![How to do it…](img/5081OS_05_07.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/5081OS_05_07.jpg)'
- en: 'We see that the endpoint is published and available through several avenues.
    Let''s go ahead and test it using SoapUI, which is a free web service testing
    tool that is available at [http://www.soapui.org/](http://www.soapui.org/). The
    steps are as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到端点通过多个途径发布并可用。让我们使用 SoapUI 来测试它，这是一个免费的Web服务测试工具，可在[http://www.soapui.org/](http://www.soapui.org/)找到。步骤如下：
- en: Load the WSDL code as a project in SoapUI, and it will automatically set up
    a request for us based on the WSDL definition. The following screenshot shows
    us what the request should look like:![How to do it…](img/5081OS_05_05.jpg)
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将WSDL代码作为项目加载到SoapUI中，它将根据WSDL定义自动为我们设置请求。以下截图显示了请求应该看起来是什么样子：![如何做…](img/5081OS_05_05.jpg)
- en: This will also autoload the address for the request.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这也将自动加载请求的地址。
- en: We can hit the play button to submit the request to the endpoint. It will respond
    with a simple `OK`, as shown in the following screenshot:![How to do it…](img/5081OS_05_06.jpg)
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以点击播放按钮向端点提交请求。它将简单地响应`OK`，如下面的截图所示：![如何做…](img/5081OS_05_06.jpg)
- en: This shows that we were able to submit a request to the endpoint and retrieve
    the response. The response is a simple hardcoded `OK` but demonstrates the availability
    of the endpoint.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们能够向端点提交请求并检索响应。响应是一个简单的硬编码的`OK`，但展示了端点的可用性。
- en: How it works…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'First, let''s look at the endpoint configuration for the Camel component. In
    the Blueprint file, we define the service endpoint as shown in the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看Camel组件的端点配置。在Blueprint文件中，我们定义服务端点，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding code is the CXF endpoint configuration; notice that we are specifying
    the address and port for our published web service as well as the location of
    the WSDL file.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是CXF端点配置；请注意，我们指定了发布的Web服务的地址和端口，以及WSDL文件的位置。
- en: The route is instantiated via a Blueprint with a `domainRoutes` bean ID. This
    will allow us to reference it from the CamelContext configuration.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 路由通过一个带有`domainRoutes` bean ID的Blueprint实例化。这将允许我们从CamelContext配置中引用它。
- en: The CamelContext defines all the Camel routes to be used in this bundle.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: CamelContext定义了在此捆绑包中要使用的所有Camel路由。
- en: 'Now, let''s look at the actual code for the route:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看路由的实际代码：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `from("cxf:bean:reportDomain")`code line is the start of the route. We need
    to be able to configure it so that it can handle any calls to our web service.
    The `reportDomain` part in the URI is a reference to the `cxfEndpoint` object
    configured in the `blueprint.xml` file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`from("cxf:bean:reportDomain")`代码行是路由的开始。我们需要能够配置它，以便它可以处理对我们的Web服务的任何调用。URI中的`reportDomain`部分是对在`blueprint.xml`文件中配置的`cxfEndpoint`对象的引用。'
- en: Tip
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that no implementation code is needed when using the Camel CXF endpoint,
    as all requests are intercepted and processed by the route.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当使用Camel CXF端点时，不需要实现代码，因为所有请求都被路由拦截并处理。
- en: The rest of the route is just for show. We convert the body to the defined data
    type in the WSDL. In this case, it is converted to `InputReportDomain.class`.
    Then, we log it to the `karaf.log` file using `.to("log:dummy")`. Finally, we
    return `OutputReportDomain.class` with an `OK` code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的路由只是为了展示。我们在WSDL中将主体转换为定义的数据类型。在这种情况下，它被转换为`InputReportDomain.class`。然后，我们使用`.to("log:dummy")`将其记录到`karaf.log`文件中。最后，我们返回带有`OK`代码的`OutputReportDomain.class`。
- en: See also
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Building and deploying a RESTful service in Karaf* recipe
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在Karaf中构建和部署RESTful服务的方法*'
