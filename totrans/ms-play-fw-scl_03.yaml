- en: Chapter 3. Building Routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the services supported by an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The flow of requests received
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Play routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the supported routes are specified within a single file: `routes` (by default).
    This makes it all the easier to figure out which one would be ideal.'
  prefs: []
  type: TYPE_NORMAL
- en: The `routes` file is compiled and if any errors occur, the compilation fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the `routes` file is not a Scala object. So how does the compiler
    know what to do with the `routes` file? To find this out, let''s perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a project that displays a *Hello, World!* page. Now, define the
    `index.scala.html` home page as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use this in our controller in this way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All we need to view our page is an entry in the `routes` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now compile the project. You will notice that a `routes_routing.scala` file
    is now available in the `HelloWorld/target/scala-2.10/src_managed/main` directory.
    The contents of the file will be similar to the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, Play generates Scala code from the `routes` file. A `routes` partial function
    is created using the routes file. The `call` method takes a function that returns
    a handler and defines the parameters to be passed to it. It is defined to handle
    0 to 21 parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `invokeHandler` method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The result from `d.call`(call and handler) is matched to the predefined `play.core.j.JavaAction`,
    `EssentialAction`, and `WebSocket` types (all of which extend the handler trait)
    and their result is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '`HandlerDef` is a class, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Automatic generation of routes_routing.scala
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's have a look at how the `routes_routing.scala` file is generated.
  prefs: []
  type: TYPE_NORMAL
- en: Play utilizes the features provided by **Simple Build Tool** (**SBT**) to add
    a source generation task. A source generation task should generate sources in
    a subdirectory of `sourceManaged` and return a sequence of the files generated.
  prefs: []
  type: TYPE_NORMAL
- en: The SBT documentation can be found at [http://www.scala-sbt.org/0.13.2/docs/Howto/generatefiles.html](http://www.scala-sbt.org/0.13.2/docs/Howto/generatefiles.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage can be seen in `PlaySettings.scala`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`RouteFiles` is defined in the `PlaySourceGenerators` trait, which handles
    the Scala code generation for routes and views. Yes, even views are transformed
    to Scala code. For example, an `index.template.scala` file is available for the
    `HelloWorld` project at `HelloWorld/target/scala-2.10/src_managed/main/views/html`.'
  prefs: []
  type: TYPE_NORMAL
- en: The definition for `RouteFiles` calls the `RoutesCompiler.compile` method and
    then returns the file paths where the source will be generated. The `compile`
    method parses the file using `RouteFileParser` and then generates the Scala code
    using the `generateRouter` method.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Play provides a feature to make HTTP calls using Scala methods. For every route
    defined, an equivalent Scala method is generated in the `routes_ReverseRouting.scala`
    file. This is very convenient when making a request from within our Scala code,
    for example, within views such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of the `routes_reverseRouting.scala` file would be similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The reverse routes return a call. A call describes an HTTP request and can
    be used to create links or fill and redirect data. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript reverse routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `routes_reverseRouting.scala`, there is also a method that returns `JavascriptReverseRoute`.
    We could use this in our JavaScript code when we wish to send a request. Prior
    to this, however, we would need to define a JavaScript router. We could do this
    by defining an action and then adding a route for it, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we could include it in the routes file in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we could refer to it in our views as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, in our JavaScript scripts we could use the router to send
    requests to the server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any web application would require a style sheet or some other resources such
    as images, scripts, and so in. In a non-Play application, we would refer to these
    by figuring out the relative location of the file. For example, suppose that our
    application has a `webapp` folder with `index.html`, where we need to add a `homePage.css`
    stylesheet, which is located at `webapp/styles`. Now, the reference in `index.html`
    would be something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Such relative paths can get very confusing and, at times, difficult to manage.
    In a Play application, the resources are placed in the public directory and can
    be accessed using a request. It is suggested that you split the public directory
    into three subdirectories for images, CSS style sheets, and JavaScript files for
    consistency, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assets](img/3803OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to this, Play provides an asset controller by default to support
    requests, which can access resources (assets). In most Play applications, a route
    for assets is also available in the routes file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This route gives access to resources, such as style sheets, scripts, and so
    on. A file is expected to be the remainder of the path after `/public`, which
    is required to access it. For example, to get the `homePage.css` style sheet,
    we would send a GET request to `/assets/stylesheets/homePage.css`. The path preceded
    by `/assets/` is considered to be the path for the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In views, we would need to use a `routes` helper. So, if we wish to add a style
    sheet in one of our views, we would refer to it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we will refer to a JavaScript script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to specify a separate path for images, style sheets, or
    scripts so that the request paths are shorter, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The Action `at` is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a *gzipped* version of a file is available, the asset controller will serve
    that instead. A gzipped version refers to the version of the file that was obtained
    by compressing the file using gzip. It adds the `.gz` extension to the filename.
  prefs: []
  type: TYPE_NORMAL
- en: As well as the resource, `AssetController` adds the `etag` header.
  prefs: []
  type: TYPE_NORMAL
- en: The `etag` acronym is used for an entity tag. This is a unique identifier for
    the resource being requested, and is generally a hash of the resource or of its
    last modified timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Views in most applications rely on third-party libraries. In Play, we could
    define dependencies located in such libraries using **webJars** and **npm**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Play extracts the assets from the WebJar dependencies as well as from `npm`
    packages into the `lib` directory within the public assets. We can refer to these
    when defining an asset with a dependency on the files present there. For example,
    if our view depends on `d3.js`, then we use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WebJars are JARs of libraries used for the client-side development of a web
    application.
  prefs: []
  type: TYPE_NORMAL
- en: '`npm` is an acronym for node packaged modules. It is the package manager for
    Node.js. It allows developers to install registered modules through the command
    line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a WebJar, we would need to define our project''s dependency on it just
    as in any other module, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To include npm packages, we would need to place the `package.json` file in
    a project root. The `package.json` file would be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Configuring route definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Play supports both static and dynamic request paths. If a request path cannot
    be matched to any of the defined routes, an `Action not found` error is thrown
    at runtime, which is rendered using the `devNotFound.scala.html` default template.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dynamic paths are those that can be used for multiple requests and they may
    or may not result in a similar response. For example, the default assets path
    is a path used to serve resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `*` symbol indicates that anything following `/assets/` until a space is
    found is the value of the `file` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another way to make the path dynamic when we need to add one
    or more variables. For example, to get a user''s details by `userId` we use the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, all the variables that occur in a path are of the `String` type.
    If a conversion is required, the type should be mentioned explicitly. So, if the
    `getUser` method takes a long parameter, we would just need to specify it in this
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Using the"`:`" prefix for `userId` means that the `userId` variable is exactly
    one URI part. The assets path uses *any suffix indicator* as the relative file
    path, which is required to access any file.
  prefs: []
  type: TYPE_NORMAL
- en: It is not necessary that a path should end with a variable; for example, `/api/user/:userId/album`
    can be used as a valid path to fetch all the albums stored by a user.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple variables can also be used in the same path. Supposing we wished to
    fetch a specific album, we could use `/api/user/:userId/album/:albumId`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The maximum number of variables we can specify in a path is 21, since this is
    the maximum that the `call` method used in `routes_routing.scala` is defined to
    handle. Also, the request path becomes complicated and ends up with too many variables.
    In general, keeping the number of such parameters to less than five is a good
    practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Play also supports using regular expressions to match the variables. For example,
    assume that we want to restrict a string variable to consisting of only letters,
    such as a region code; in this case, our route can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when we specify a regular expression for the variable in the route,
    it is prefixed with a `$` symbol instead of the `:` symbol while defining the
    route.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding route definition restricts the request by a regular expression.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/api/region/IN/user` is a valid path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/api/region/CABT/user` and `/api/region/99/user` are invalid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The order of preference to a route is defined by its position in the `routes`
    file. The router returns the first matching route for a given path. If the same
    request type and route are mapped for two different actions, the compiler does
    not throw an error or warning. Some IDEs indicate when duplicate route definitions
    occur, but it is completely the developer's responsibility to ensure that such
    cases do not occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'This table summarizes the different ways of defining a dynamic path:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Sr.no. | Purpose | Special characters | Example usage(s) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | URI path separator is part of the variable | `*` | `/assets/*file` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Single or multiple variables | `:` | `/api/user/:userId``/api/user/:userId/album``/api/user/:userId/album/:albumId`
    |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Regular expression pattern for variables | `$` | `/api/region/$regionId<[a-zA-Z]{2}>/user`
    |'
  prefs: []
  type: TYPE_TB
- en: Static paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Static request paths are fixed and constant. They cannot support arguments
    in the request path. All the data required for such requests should be sent through
    request parameters or request bodies. For example, the actions used for signing
    in or signing out are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: So does Play search for specific characters to identify the kind of path?
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, the special characters are used by `RoutesFileParser` to recognize whether
    a path is static or dynamic. The paths are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the methods used to identify a path, the `~>`, `not`, and `^^` methods are
    from `scala.util.parsing.combinator.{Parser, RegexParsers}`. `DynamicPart` and
    `StaticPart` are defined with the intention of capturing the parts of a URL, so
    that it''s simpler to pass values to a corresponding action. They are defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Configuring request parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many applications use additional parameters along with RESTful HTTP GET requests
    to obtain required information. Play supports configuring these request parameters
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Supposing we have a request to search users by their name, we could define
    this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, we wouldn't need to get the parameters from the request in the action.
    We could let Play handle acquiring the parameters from the request and passing
    them to the action.
  prefs: []
  type: TYPE_NORMAL
- en: What do we do when the request parameters are optional? For example, what happens
    if we allow a search of users by their name where `lastName` is optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can specify `Option` as the type for this request parameter. Therefore,
    the route definition would be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to this, we can also specify the default value, if any, for request
    parameters. Suppose we had a limit parameter for the search request as well. In
    this case, if we wish to set the default value as `10`, the route definition would
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application works as expected but when the code is added to one or more
    base packages, the reverse routing doesn't work.
  prefs: []
  type: TYPE_NORMAL
- en: The routes are compiled, so when you make changes to the controllers, the project
    should be recompiled. In this case, run the `clean` command and then compile the
    project. It is better to see whether the generated routing files reflect the changes
    made. If not, delete the target directory and compile the project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw what an essential role routing plays in a Play application.
    As well as this, we saw the various default methods that Play provides to simplify
    the process of routing, in the form of assets, reverse routing, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to define views in a Play application and
    also uncover how it works. As well as from the templating mechanism, the internals
    of building and using forms and internationalization will be covered in detail.
  prefs: []
  type: TYPE_NORMAL
