- en: Chapter 3. Building Routes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。构建路由
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Defining the services supported by an application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义应用程序支持的服务
- en: The flow of requests received
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收到的请求流程
- en: Configuring routes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置路由
- en: Handling assets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理资产
- en: Introduction to Play routes
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Play 路由简介
- en: 'All the supported routes are specified within a single file: `routes` (by default).
    This makes it all the easier to figure out which one would be ideal.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所有支持的路由都指定在单个文件中：`routes`（默认）。这使得确定哪个是理想的变得更容易。
- en: The `routes` file is compiled and if any errors occur, the compilation fails.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译过程中出现错误，`routes` 文件将编译失败。
- en: 'However, the `routes` file is not a Scala object. So how does the compiler
    know what to do with the `routes` file? To find this out, let''s perform the following
    steps:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`routes` 文件不是一个 Scala 对象。那么编译器是如何知道如何处理 `routes` 文件的？为了找出答案，让我们执行以下步骤：
- en: 'Let''s create a project that displays a *Hello, World!* page. Now, define the
    `index.scala.html` home page as follows:'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个显示 *Hello, World!* 页面的项目。现在，将主页 `index.scala.html` 定义如下：
- en: '[PRE0]'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will use this in our controller in this way:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在我们的控制器中以这种方式使用它：
- en: '[PRE1]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'All we need to view our page is an entry in the `routes` file:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要在 `routes` 文件中添加一个条目就可以查看我们的页面：
- en: '[PRE2]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now compile the project. You will notice that a `routes_routing.scala` file
    is now available in the `HelloWorld/target/scala-2.10/src_managed/main` directory.
    The contents of the file will be similar to the following code snippet:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译项目。你会注意到在 `HelloWorld/target/scala-2.10/src_managed/main` 目录中现在有一个 `routes_routing.scala`
    文件。文件的内容将类似于以下代码片段：
- en: '[PRE3]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, Play generates Scala code from the `routes` file. A `routes` partial function
    is created using the routes file. The `call` method takes a function that returns
    a handler and defines the parameters to be passed to it. It is defined to handle
    0 to 21 parameters.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Play 从 `routes` 文件生成 Scala 代码。使用路由文件创建了一个 `routes` 部分函数。`call` 方法接受一个返回处理器的函数，并定义传递给它的参数。它被定义为处理
    0 到 21 个参数。
- en: 'The `invokeHandler` method is defined as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`invokeHandler` 方法定义如下：'
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The result from `d.call`(call and handler) is matched to the predefined `play.core.j.JavaAction`,
    `EssentialAction`, and `WebSocket` types (all of which extend the handler trait)
    and their result is returned.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`d.call`（调用和处理）的结果与预定义的 `play.core.j.JavaAction`、`EssentialAction` 和 `WebSocket`
    类型（所有这些都扩展了处理器特质）相匹配，并返回其结果。'
- en: '`HandlerDef` is a class, which is defined as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandlerDef` 是一个类，其定义如下：'
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Automatic generation of routes_routing.scala
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动生成 `routes_routing.scala`
- en: Let's have a look at how the `routes_routing.scala` file is generated.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `routes_routing.scala` 文件是如何生成的。
- en: Play utilizes the features provided by **Simple Build Tool** (**SBT**) to add
    a source generation task. A source generation task should generate sources in
    a subdirectory of `sourceManaged` and return a sequence of the files generated.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Play 利用 **Simple Build Tool**（**SBT**）提供的功能添加一个源生成任务。源生成任务应在 `sourceManaged`
    的子目录中生成源，并返回生成的文件序列。
- en: The SBT documentation can be found at [http://www.scala-sbt.org/0.13.2/docs/Howto/generatefiles.html](http://www.scala-sbt.org/0.13.2/docs/Howto/generatefiles.html).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: SBT 文档可以在 [http://www.scala-sbt.org/0.13.2/docs/Howto/generatefiles.html](http://www.scala-sbt.org/0.13.2/docs/Howto/generatefiles.html)
    找到。
- en: 'The usage can be seen in `PlaySettings.scala`, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用情况可以在 `PlaySettings.scala` 中看到，如下所示：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`RouteFiles` is defined in the `PlaySourceGenerators` trait, which handles
    the Scala code generation for routes and views. Yes, even views are transformed
    to Scala code. For example, an `index.template.scala` file is available for the
    `HelloWorld` project at `HelloWorld/target/scala-2.10/src_managed/main/views/html`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouteFiles` 定义在 `PlaySourceGenerators` 特质中，该特质处理路由和视图的 Scala 代码生成。是的，甚至视图也被转换成
    Scala 代码。例如，`HelloWorld` 项目在 `HelloWorld/target/scala-2.10/src_managed/main/views/html`
    中有一个 `index.template.scala` 文件。'
- en: The definition for `RouteFiles` calls the `RoutesCompiler.compile` method and
    then returns the file paths where the source will be generated. The `compile`
    method parses the file using `RouteFileParser` and then generates the Scala code
    using the `generateRouter` method.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouteFiles` 的定义调用了 `RoutesCompiler.compile` 方法，然后返回源将生成的文件路径。`compile` 方法使用
    `RouteFileParser` 解析文件，然后使用 `generateRouter` 方法生成 Scala 代码。'
- en: Reverse routing
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反向路由
- en: 'Play provides a feature to make HTTP calls using Scala methods. For every route
    defined, an equivalent Scala method is generated in the `routes_ReverseRouting.scala`
    file. This is very convenient when making a request from within our Scala code,
    for example, within views such as the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Play提供了一种使用Scala方法进行HTTP调用的功能。对于每个定义的路由，`routes_ReverseRouting.scala`文件中都会生成一个等效的Scala方法。这在从Scala代码（例如视图）内部进行请求时非常方便。
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The content of the `routes_reverseRouting.scala` file would be similar to the
    following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes_reverseRouting.scala`文件的内容可能类似于以下内容：'
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The reverse routes return a call. A call describes an HTTP request and can
    be used to create links or fill and redirect data. It is defined as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 反向路由返回一个调用。调用描述了一个HTTP请求，可以用来创建链接或填充和重定向数据。它定义如下：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: JavaScript reverse routing
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript反向路由
- en: 'In `routes_reverseRouting.scala`, there is also a method that returns `JavascriptReverseRoute`.
    We could use this in our JavaScript code when we wish to send a request. Prior
    to this, however, we would need to define a JavaScript router. We could do this
    by defining an action and then adding a route for it, as shown in this example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`routes_reverseRouting.scala`中，还有一个返回`JavascriptReverseRoute`的方法。当我们希望发送请求时，可以在JavaScript代码中使用它。然而，在此之前，我们需要定义一个JavaScript路由器。我们可以通过定义一个动作并为它添加一个路由来实现，如下例所示：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we could include it in the routes file in this way:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以以这种方式将其包含在路由文件中：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we could refer to it in our views as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在视图中如下引用它：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once this is done, in our JavaScript scripts we could use the router to send
    requests to the server, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，在我们的JavaScript脚本中可以使用路由器向服务器发送请求，如下所示：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Assets
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资产
- en: 'Any web application would require a style sheet or some other resources such
    as images, scripts, and so in. In a non-Play application, we would refer to these
    by figuring out the relative location of the file. For example, suppose that our
    application has a `webapp` folder with `index.html`, where we need to add a `homePage.css`
    stylesheet, which is located at `webapp/styles`. Now, the reference in `index.html`
    would be something similar to the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Web应用程序都需要样式表或其他资源，如图像、脚本等。在非Play应用程序中，我们会通过确定文件的相对位置来引用这些资源。例如，假设我们的应用程序有一个`webapp`文件夹，其中包含`index.html`，我们需要添加一个位于`webapp/styles`的`homePage.css`样式表。现在，`index.html`中的引用可能类似于以下内容：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Such relative paths can get very confusing and, at times, difficult to manage.
    In a Play application, the resources are placed in the public directory and can
    be accessed using a request. It is suggested that you split the public directory
    into three subdirectories for images, CSS style sheets, and JavaScript files for
    consistency, as shown in the following figure:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的相对路径可能会变得非常混乱，有时难以管理。在Play应用程序中，资源放置在public目录中，可以通过请求访问。建议您将public目录分为三个子目录，用于图像、CSS样式表和JavaScript文件，以保持一致性，如下图所示：
- en: '![Assets](img/3803OS_03_01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![资产](img/3803OS_03_01.jpg)'
- en: 'In addition to this, Play provides an asset controller by default to support
    requests, which can access resources (assets). In most Play applications, a route
    for assets is also available in the routes file, as shown here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Play默认提供资产控制器来支持请求，可以访问资源（资产）。在大多数Play应用程序中，路由文件中也提供了一个资产路由，如下所示：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This route gives access to resources, such as style sheets, scripts, and so
    on. A file is expected to be the remainder of the path after `/public`, which
    is required to access it. For example, to get the `homePage.css` style sheet,
    we would send a GET request to `/assets/stylesheets/homePage.css`. The path preceded
    by `/assets/` is considered to be the path for the file.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此路由提供了对资源（如样式表、脚本等）的访问。文件是路径`/public`之后的剩余部分，这是访问所必需的。例如，要获取`homePage.css`样式表，我们需要向`/assets/stylesheets/homePage.css`发送GET请求。以`/assets/`开头的是文件路径。
- en: 'In views, we would need to use a `routes` helper. So, if we wish to add a style
    sheet in one of our views, we would refer to it as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中，我们需要使用`routes`辅助工具。因此，如果我们想在某个视图中添加样式表，我们可以如下引用它：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Similarly, we will refer to a JavaScript script as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们将如下引用JavaScript脚本：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It is also possible to specify a separate path for images, style sheets, or
    scripts so that the request paths are shorter, as shown here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以指定图像、样式表或脚本的单独路径，以便请求路径更短，如下所示：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The Action `at` is defined as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 动作`at`定义如下：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If a *gzipped* version of a file is available, the asset controller will serve
    that instead. A gzipped version refers to the version of the file that was obtained
    by compressing the file using gzip. It adds the `.gz` extension to the filename.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件有可用的 *gzip* 版本，资产控制器将提供该版本。gzip 版本是指通过使用 gzip 压缩文件而获得的文件版本。它将 `.gz` 扩展名添加到文件名中。
- en: As well as the resource, `AssetController` adds the `etag` header.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了资源之外，`AssetController` 还添加了 `etag` 头部。
- en: The `etag` acronym is used for an entity tag. This is a unique identifier for
    the resource being requested, and is generally a hash of the resource or of its
    last modified timestamp.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`etag` 缩写用于实体标签。这是请求资源的唯一标识符，通常是资源或其最后修改时间戳的哈希。'
- en: Client-side libraries
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端库
- en: Views in most applications rely on third-party libraries. In Play, we could
    define dependencies located in such libraries using **webJars** and **npm**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序中的视图依赖于第三方库。在 Play 中，我们可以使用 **webJars** 和 **npm** 定义位于这些库中的依赖项。
- en: 'Play extracts the assets from the WebJar dependencies as well as from `npm`
    packages into the `lib` directory within the public assets. We can refer to these
    when defining an asset with a dependency on the files present there. For example,
    if our view depends on `d3.js`, then we use the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Play 从 WebJar 依赖以及 `npm` 包中提取资产到公共资产目录内的 `lib` 目录。我们可以在定义具有对那里现有文件依赖的资产时引用这些资产。例如，如果我们的视图依赖于
    `d3.js`，那么我们使用以下方式：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: WebJars are JARs of libraries used for the client-side development of a web
    application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: WebJars 是用于网络应用程序客户端开发的库的 JAR 文件。
- en: '`npm` is an acronym for node packaged modules. It is the package manager for
    Node.js. It allows developers to install registered modules through the command
    line.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm` 是 node packaged modules 的缩写。它是 Node.js 的包管理器。它允许开发人员通过命令行安装已注册的模块。'
- en: 'To use a WebJar, we would need to define our project''s dependency on it just
    as in any other module, as shown here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 WebJar，我们需要像在其他模块中一样定义我们项目对该模块的依赖，如下所示：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To include npm packages, we would need to place the `package.json` file in
    a project root. The `package.json` file would be similar to this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含 npm 包，我们需要将 `package.json` 文件放置在项目根目录中。`package.json` 文件将类似于以下内容：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Configuring route definitions
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置路由定义
- en: Play supports both static and dynamic request paths. If a request path cannot
    be matched to any of the defined routes, an `Action not found` error is thrown
    at runtime, which is rendered using the `devNotFound.scala.html` default template.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Play 支持静态和动态请求路径。如果请求路径无法与定义的任何路由匹配，则在运行时抛出 `Action not found` 错误，该错误使用 `devNotFound.scala.html`
    默认模板渲染。
- en: Dynamic paths
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态路径
- en: 'Dynamic paths are those that can be used for multiple requests and they may
    or may not result in a similar response. For example, the default assets path
    is a path used to serve resources:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 动态路径是可以用于多个请求的路径，它们可能或可能不会产生相似响应。例如，默认的资产路径是一个用于提供资源的路径：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `*` symbol indicates that anything following `/assets/` until a space is
    found is the value of the `file` variable.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` 符号表示 `/assets/` 之后直到找到空格的所有内容都是 `file` 变量的值。'
- en: 'Let''s look at another way to make the path dynamic when we need to add one
    or more variables. For example, to get a user''s details by `userId` we use the
    following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要添加一个或多个变量时，让我们看看另一种使路径动态化的方法。例如，要通过 `userId` 获取用户详情，我们使用以下代码：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'By default, all the variables that occur in a path are of the `String` type.
    If a conversion is required, the type should be mentioned explicitly. So, if the
    `getUser` method takes a long parameter, we would just need to specify it in this
    way:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，路径中出现的所有变量都是 `String` 类型。如果需要转换，则应明确指定类型。因此，如果 `getUser` 方法需要一个长参数，我们只需以这种方式指定它：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using the"`:`" prefix for `userId` means that the `userId` variable is exactly
    one URI part. The assets path uses *any suffix indicator* as the relative file
    path, which is required to access any file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `userId` 的 `:` 前缀意味着 `userId` 变量正好是一个 URI 部分。资产路径使用 *任何后缀指示符* 作为相对文件路径，这是访问任何文件所必需的。
- en: It is not necessary that a path should end with a variable; for example, `/api/user/:userId/album`
    can be used as a valid path to fetch all the albums stored by a user.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 路径不以变量结尾并不是必需的；例如，`/api/user/:userId/album` 可以作为一个有效的路径来获取用户存储的所有专辑。
- en: Multiple variables can also be used in the same path. Supposing we wished to
    fetch a specific album, we could use `/api/user/:userId/album/:albumId`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个路径中也可以使用多个变量。假设我们想要获取一个特定的专辑，我们可以使用 `/api/user/:userId/album/:albumId`。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The maximum number of variables we can specify in a path is 21, since this is
    the maximum that the `call` method used in `routes_routing.scala` is defined to
    handle. Also, the request path becomes complicated and ends up with too many variables.
    In general, keeping the number of such parameters to less than five is a good
    practice.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在路径中指定的变量最大数量是 21，因为这是在 `routes_routing.scala` 中使用的 `call` 方法定义可以处理的最大的数量。此外，请求路径变得复杂，最终包含太多的变量。通常，将此类参数的数量保持在五个以下是一个好的做法。
- en: 'Play also supports using regular expressions to match the variables. For example,
    assume that we want to restrict a string variable to consisting of only letters,
    such as a region code; in this case, our route can be defined as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Play 还支持使用正则表达式来匹配变量。例如，假设我们想要限制一个字符串变量只包含字母，例如地区代码；在这种情况下，我们的路由可以定义为如下：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice that when we specify a regular expression for the variable in the route,
    it is prefixed with a `$` symbol instead of the `:` symbol while defining the
    route.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们为路由中的变量指定正则表达式时，它是以 `$` 符号开头，而不是在定义路由时使用的 `:` 符号。
- en: 'The preceding route definition restricts the request by a regular expression.
    For example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的路由定义通过正则表达式限制了请求。例如：
- en: '`/api/region/IN/user` is a valid path'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api/region/IN/user` 是一个有效的路径'
- en: '`/api/region/CABT/user` and `/api/region/99/user` are invalid'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api/region/CABT/user` 和 `/api/region/99/user` 是无效的'
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The order of preference to a route is defined by its position in the `routes`
    file. The router returns the first matching route for a given path. If the same
    request type and route are mapped for two different actions, the compiler does
    not throw an error or warning. Some IDEs indicate when duplicate route definitions
    occur, but it is completely the developer's responsibility to ensure that such
    cases do not occur.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 路由的优先级顺序由其在 `routes` 文件中的位置定义。路由器返回给定路径的第一个匹配的路由。如果相同的请求类型和路由映射到两个不同的动作，编译器不会抛出错误或警告。一些
    IDE 在出现重复的路由定义时会给出提示，但确保这种情况不发生完全是开发者的责任。
- en: 'This table summarizes the different ways of defining a dynamic path:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此表总结了定义动态路径的不同方法：
- en: '| Sr.no. | Purpose | Special characters | Example usage(s) |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| Sr.no. | Purpose | Special characters | Example usage(s) |'
- en: '| --- | --- | --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 1 | URI path separator is part of the variable | `*` | `/assets/*file` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 1 | URI 路径分隔符是变量的一部分 | `*` | `/assets/*file` |'
- en: '| 2 | Single or multiple variables | `:` | `/api/user/:userId``/api/user/:userId/album``/api/user/:userId/album/:albumId`
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 单个或多个变量 | `:` | `/api/user/:userId` `/api/user/:userId/album` `/api/user/:userId/album/:albumId`
    |'
- en: '| 3 | Regular expression pattern for variables | `$` | `/api/region/$regionId<[a-zA-Z]{2}>/user`
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 变量的正则表达式模式 | `$` | `/api/region/$regionId<[a-zA-Z]{2}>/user` |'
- en: Static paths
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态路径
- en: 'Static request paths are fixed and constant. They cannot support arguments
    in the request path. All the data required for such requests should be sent through
    request parameters or request bodies. For example, the actions used for signing
    in or signing out are given as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 静态请求路径是固定和不变的。它们不支持请求路径中的参数。此类请求所需的所有数据都应该通过请求参数或请求体发送。例如，用于登录或注销的动作如下所示：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So does Play search for specific characters to identify the kind of path?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 Play 是否也会搜索特定的字符来识别路径的类型？
- en: 'Yes, the special characters are used by `RoutesFileParser` to recognize whether
    a path is static or dynamic. The paths are defined as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，特殊字符被 `RoutesFileParser` 用于识别路径是静态的还是动态的。路径被定义为如下：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the methods used to identify a path, the `~>`, `not`, and `^^` methods are
    from `scala.util.parsing.combinator.{Parser, RegexParsers}`. `DynamicPart` and
    `StaticPart` are defined with the intention of capturing the parts of a URL, so
    that it''s simpler to pass values to a corresponding action. They are defined
    as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别路径的方法中，`~>`, `not`, 和 `^^` 方法来自 `scala.util.parsing.combinator.{Parser, RegexParsers}`。`DynamicPart`
    和 `StaticPart` 是为了捕获 URL 的部分而定义的，这样就可以更简单地传递值到相应的动作。它们被定义为如下：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Configuring request parameters
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置请求参数
- en: Many applications use additional parameters along with RESTful HTTP GET requests
    to obtain required information. Play supports configuring these request parameters
    as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序在 RESTful HTTP GET 请求中使用了额外的参数来获取所需的信息。Play 也支持配置这些请求参数。
- en: 'Supposing we have a request to search users by their name, we could define
    this as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个按用户名搜索用户的需求，我们可以这样定义：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Therefore, we wouldn't need to get the parameters from the request in the action.
    We could let Play handle acquiring the parameters from the request and passing
    them to the action.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不需要在操作中从请求中获取参数。我们可以让 Play 处理从请求中获取参数并将其传递给操作。
- en: What do we do when the request parameters are optional? For example, what happens
    if we allow a search of users by their name where `lastName` is optional.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求参数是可选的时，我们该怎么办？例如，如果我们允许通过用户名搜索用户，其中`lastName`是可选的，会发生什么。
- en: 'We can specify `Option` as the type for this request parameter. Therefore,
    the route definition would be similar to the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`Option`指定为该请求参数的类型。因此，路由定义将与以下类似：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In addition to this, we can also specify the default value, if any, for request
    parameters. Suppose we had a limit parameter for the search request as well. In
    this case, if we wish to set the default value as `10`, the route definition would
    be as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以指定请求参数的默认值（如果有的话）。假设我们还有一个用于搜索请求的限制参数。在这种情况下，如果我们希望将默认值设置为`10`，则路由定义如下：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Troubleshooting
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除
- en: The application works as expected but when the code is added to one or more
    base packages, the reverse routing doesn't work.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序按预期工作，但当代码添加到一个或多个基本包中时，反向路由不起作用。
- en: The routes are compiled, so when you make changes to the controllers, the project
    should be recompiled. In this case, run the `clean` command and then compile the
    project. It is better to see whether the generated routing files reflect the changes
    made. If not, delete the target directory and compile the project.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 路由已编译，因此当你对控制器进行更改时，项目应该重新编译。在这种情况下，运行`clean`命令然后编译项目。最好查看生成的路由文件是否反映了所做的更改。如果没有，删除目标目录并编译项目。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw what an essential role routing plays in a Play application.
    As well as this, we saw the various default methods that Play provides to simplify
    the process of routing, in the form of assets, reverse routing, and so on.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了路由在 Play 应用程序中扮演的基本角色。此外，我们还看到了 Play 提供的各种默认方法，以简化路由过程，例如资产、反向路由等。
- en: In the next chapter, we will see how to define views in a Play application and
    also uncover how it works. As well as from the templating mechanism, the internals
    of building and using forms and internationalization will be covered in detail.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何在 Play 应用程序中定义视图，并揭示其工作原理。此外，从模板机制，以及构建和使用表单以及国际化等内部细节都将被详细阐述。
