- en: Miscellaneous Improvements in JDK 11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 11 covers a number of additional interesting changes that we cannot cover
    in individual chapters. However, this doesn't mean that they are not relevant
    or important enough, but because their details are beyond the scope of this book.
    For instance, nest-based access includes changes to the **Java Virtual Machine**
    (**JVM**) specification, dynamic class-file constants extending existing class-file
    constants, improvements with cryptography layers and **Transport Layer Security**
    (**TLS**), and more.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter includes an overview of the remaining JDK 11 features that are
    related to the SE, JDK, and implementation of Java 11 features.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Nest-based access control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic class-file constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving AArch64 intrinsics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing the Java EE and CORBA modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A key agreement with Curve25519 and Curve448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unicode 10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ChaCha20 and Poly1305 cryptographic algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching single file source code programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TLS 1.3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecating the Nashorn JavaScript engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecating the pack200 tools and API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To work with the code that is included in this chapter, you'll need JDK 11,
    or later, installed on your system.
  prefs: []
  type: TYPE_NORMAL
- en: Since this chapter covers multiple features in Java 11, let's quickly map the
    features with their **JDK Enhancement Proposal** (**JEP**) number and scope.
  prefs: []
  type: TYPE_NORMAL
- en: Listing the JEPs that are used in this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table lists the JDK 11 features that are covered in this chapter,
    their corresponding JEP number, and scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **JEP** | **Scope** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 181 | SE | Nest-based access control |'
  prefs: []
  type: TYPE_TB
- en: '| 309 | SE | Dynamic class-file constants |'
  prefs: []
  type: TYPE_TB
- en: '| 315 | Implementation | Improving AArch64 intrinsics |'
  prefs: []
  type: TYPE_TB
- en: '| 320 | SE | Removing the Java EE and CORBA modules |'
  prefs: []
  type: TYPE_TB
- en: '| 324 | SE | A key agreement with Curve25519 and Curve448 |'
  prefs: []
  type: TYPE_TB
- en: '| 327 | SE | Unicode 10 |'
  prefs: []
  type: TYPE_TB
- en: '| 329 | SE | ChaCha20 and Poly1305 cryptographic algorithms |'
  prefs: []
  type: TYPE_TB
- en: '| 330 | JDK | Launch single file source code programs |'
  prefs: []
  type: TYPE_TB
- en: '| 332 | SE | TLS 1.3 |'
  prefs: []
  type: TYPE_TB
- en: '| 335 | JDK | Deprecate the Nashorn JavaScript engine |'
  prefs: []
  type: TYPE_TB
- en: '| 336 | SE | Deprecate the pack200 tools and API |'
  prefs: []
  type: TYPE_TB
- en: Let's get started with the first feature.
  prefs: []
  type: TYPE_NORMAL
- en: Nest-based access control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine what happens when you define nested classes or interfaces? For instance,
    if you define a *two-level class*, say `Outer`, and an *inner class*, say `Inner`,
    can `Inner` access the `private` instance variables of `Outer`? Here''s some sample
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, it can. Since you define these classes within the same source code file,
    you might assume it to be obvious. However, it is not. The compiler generates
    separate bytecode files (`.class`) for the `Outer` and `Inner` classes. For the
    preceding example, the compiler creates two bytecode files: `Outer.class` and `Outer$Inner.class`.
    For your quick reference, the bytecode file of an inner class is preceded by the
    name of its outer class and a dollar sign.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable the access of variables across these classes and to preserve the
    expectations of programmers, the compiler broadens the access of private members
    to a package or adds bridge variables or methods in each of these classes. Here''s
    the decompiled version of the `Outer` and `Inner` classes that have been decompiled
    using the **JAD Java Decompiler**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the `Outer$Inner` decompiled class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you will notice, the decompiled versions verify that the compiler defined
    a bridge variable, that is, `this$0` of type `Outer` in the `Inner` class, to
    access members of `Outer` from `Inner`.
  prefs: []
  type: TYPE_NORMAL
- en: These bridge variables and methods risk encapsulation and increase the size
    of the deployed application. They can also confuse developers and tools.
  prefs: []
  type: TYPE_NORMAL
- en: What is nest-based access?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JEP 181 introduces nest-based access control. As you know, classes and interfaces,
    which are defined within another class or interface are compiled to separate class
    files. To access each other's private members, compilers had been either broadening
    their access levels or inserting bridge methods.
  prefs: []
  type: TYPE_NORMAL
- en: Nest-based access control allows such classes and interfaces to access each
    other's private members, without any workarounds (or bridge code) by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Nest-based access control also results in changes to the JVM specification.
    You can refer to the following link to access these changes (removals are highlighted
    by a red font background and additions are highlighted using the green background): [https://cr.openjdk.java.net/~dlsmith/nestmates.html](https://cr.openjdk.java.net/~dlsmith/nestmates.html).
  prefs: []
  type: TYPE_NORMAL
- en: Affects of nest-based control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though it might seem simple, nest-based access control affects all specifications
    and APIs —which involve access control or method invocation—either implicitly
    or explicitly. As mentioned in the *What is nest-based access?* section, it includes
    changes in the JVM specification. It also affects class file attributes, access
    control rules, bytecode invocation rules, reflection, method invocation, and field
    access rules.
  prefs: []
  type: TYPE_NORMAL
- en: It also adds new class file attributes, modifies `MethodHandle` lookup rules,
    results in class transformation/redefinition—the JVM TI and `java.lang.instrument`
    APIs, JDWP, and JDI (`com.sun.jdi.VirtualMachine`).
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic class-file constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JEP 309 extends the existing Java class-file format, creating `CONSTANT_Dynamic`.
    This is a JVM feature and doesn't depend on the higher software layers. The loading
    of `CONSTANT_Dynamic` delegates the creation of a bootstrap method. When comparing
    it to the **invokedynamic** call, you will see how it delegates linking to a bootstrap
    method.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main goals of dynamic class-file constants is to make it simple to
    create new forms of materializable class-file constants, which provides language
    designers and compiler implementers with broader options for expressivity and
    performance. This is achieved by creating a new constant pool form that can be
    parameterized using a bootstrap method with static arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Improving AArch64 intrinsics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JEP 315 works by improving intrinsics on AArch64 processors. The current string
    and array intrinsic are improved. Also a new intrinsic is implemented for the
    sine, cosine, and logarithmicfunctions in `java.lang.Math`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to enhance application performance, intrinsics utilize an assembly
    code that is specific to CPU architecture. It does not execute generic Java code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you will see AArch64 processors having an implementation of most
    of the intrinsics. However, JEP 315 implemented an optimized intrinsic for the
    following methods in the `java.lang.Math` class that was not up to the mark:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sin()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cos()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is also worth noting that some of the intrinsics that are previously implemented
    in the AArch64 port might not be completely optimal. Such intrinsic can take advantage
    of features such as memory address alignment or software prefetching instructions.
    Some of those methods are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String::compareTo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String::indexOf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StringCoding::hasNegatives`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `Arrays::equals` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StringUTF16::compress`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StringLatin1::inflate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing the Java EE and CORBA modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java EE moved to the Eclipse Foundation with Java 9 under a new name – Jakarta
    EE (interestingly, still JEE). With Java 9, the modules and classes that were
    specific to Java EE were deprecated. With Java 11, these deprecated APIs and modules
    have been removed from the Java SE platform and the JDK. CORBA's APIs were also
    deprecated in Java 9 and were eventually removed in Java 11.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Java SE 6 (core Java), you can develop web services using the following
    technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JAX-WS** (short for **Java API for XML-Based Web Services**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JAXB** (short for **Java Architecture for XML Binding**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JAF** (short for **JavaBeans Activation Framework**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Common annotations**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the code for the preceding tech stack was added to core Java, it was identical
    to its versions for **Java's Enterprise Edition** (**JEE**). However, over time,
    the JEE version evolved, leading to a mismatch in the functionality that was offered
    by the same APIs in Java SE and JEE.
  prefs: []
  type: TYPE_NORMAL
- en: 'JEP 320 removed the following modules in Java 11, deleting their source code
    from the OpenJDK repository and runtime JDK image:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.xml.ws` (JAX-WS)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.xml.bind` (JAXB)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.activation` (JAF)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.xml.ws.annotation` (common annotations)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.corba` (CORBA)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.transaction` (JTA)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.se.ee` (an aggregator module for the preceding six modules)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jdk.xml.ws` (JAX-WS tools)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jdk.xml.bind` (JAXB tools)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from marking the preceding modules as deprecated in Java 9, JDK didn't
    resolve them when code that was using these modules was compiled or executed.
    This forced the developers to use standalone versions of Java EE or CORBA on the
    classpath.
  prefs: []
  type: TYPE_NORMAL
- en: 'After their removal, tools such as `wsgen` and `wsimport` (from `jdk.xml.ws`),
    `schemagen` and `xjc` (from `jdk.xml.bind`), `idlj`, `orbd`, `servertool`, and
    `tnamesrv` (from `java.corba`) were no longer available. Developers couldn''t
    enable them using runtime command-line flags, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: CORBA, an ORB implementation, was included in Java SE in 1998\. Over time, support
    for CORBA has outweighed its benefits. First of all, with better technologies
    available, hardly anyone is using CORBA now. CORBA evolves outside the **Java
    Community Process** (**JCP**) and it is becoming increasingly difficult to maintain
    JDK's CORBA implementation. With JEE now moving to the Eclipse Foundation, it
    makes no sense to synchronize ORB in JDK with Jakarta EE's ORB. To add to this,
    JEE 8 designated it as **Proposed Optional**, which essentially means that JEE
    might drop supporting CORBA in one of its future versions (marking it as deprecated).
  prefs: []
  type: TYPE_NORMAL
- en: Enterprises moving from Java 8 to Java 11 are at a higher risk if their applications
    use JEE or CORBA APIs. However, an alternate API is suggested by Oracle, easing
    the migration.
  prefs: []
  type: TYPE_NORMAL
- en: A key agreement with Curve25519 and Curve448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With JEP 324, Java SE is making further advances in cryptography that offers
    security and performance. This feature implements a key agreement using Curve25519
    and Curve448\. Other cryptography libraries, such as OpenSSL and BoringSSL, already
    support key exchanges using Curve25519 and Curve448.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information on Cureve25519 and Curve448 at [https://tools.ietf.org/html/rfc7748](https://tools.ietf.org/html/rfc7748).
  prefs: []
  type: TYPE_NORMAL
- en: Unicode 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JEP 327 upgrades existing platform APIs to support Unicode 10 Standard ([http://www.unicode.org/standard/standard.html](http://www.unicode.org/standard/standard.html)),
    mainly in the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Character` and `String` (the `java.lang` package)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NumericShaper` (the `java.awt.font` package)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bidi`, `BreakIterator`, and `Normalizer` (the `java.text` package)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ChaCha20 and Poly1305 cryptographic algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 11 includes multiple additions and enhancements in cryptographic toolkits
    and TLS implementations. JEP 329 implements the ChaCha20 and ChaCha20-Poly1305
    ciphers. Being a comparatively new stream cipher, ChaCha20 is capable in taking
    place of the RC4 stream cipher.
  prefs: []
  type: TYPE_NORMAL
- en: At present, the RC4 stream cipher, which has been widely adopted, is not so
    secure. The industry is moving toward the adoption of the more secure ChaCha20-Poly1305\.
    This has also been widely adopted across TLS implementations as well as in other
    cryptographic protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Launching single file source code programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine being able to execute a Java application without compilation; for instance,
    if you define the following Java class in `HelloNoCompilation.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With Java 11, you can execute it using the following command (no compilation
    takes place):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the preceding command starts the JVM using `java`, which is passed
    the name of a source file with the `.java` extension. In this case, the class
    is compiled in memory before it is executed by the JVM. This applies to multiple
    classes or interfaces that are defined within the same source file. Here''s another
    example (consider it to be defined within the same `HelloNoCompilation.java` source
    file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'On execution, you will see the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With JEP 330, you can cut down the step of compiling your code and go to the
    execution of your Java applications straight away. However, this only applies
    to applications with a single source file. The source file can define multiple
    classes or interfaces, as shown in the preceding example code.
  prefs: []
  type: TYPE_NORMAL
- en: Launching single file source code programs helps to reduce the ceremony attached
    to simple code execution. This is the most helpful for students or professionals
    who are beginning to learn Java. However, when they move to working with multiple
    source files, they'll need to compile their code before executing them.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you compile your source class using the `javac` command and then
    try to launch it as a single file source code, it won''t execute. For example,
    compile the `HelloNoCompilation` source file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, try to execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll receive the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: TLS 1.3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here's another addition to the TLS implementation in Java. JEP 332 implements
    Version 1.3 of the TLS Protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Version 1.3 of TLS supersedes and obsoletes its previous versions, including
    Version 1.2 (that is, RFC 5246, which can be found at [https://tools.ietf.org/html/rfc5246](https://tools.ietf.org/html/rfc5246)).
    It also obsoletes or changes other TLS features, such as the **OCSP** (short for
    **Online Certificate Status Protocol**) stapling extensions (that is, RFC 6066,
    which can be found at [https://tools.ietf.org/html/rfc6066](https://tools.ietf.org/html/rfc6066); and
    RFC 6961, which can be found at [https://tools.ietf.org/html/rfc6961](https://tools.ietf.org/html/rfc6961)),
    and the session hash and extended master secret extension (that is, RFC 7627;
    for more information, visit [https://tools.ietf.org/html/rfc7627](https://tools.ietf.org/html/rfc7627)).
  prefs: []
  type: TYPE_NORMAL
- en: Deprecating the Nashorn JavaScript engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With JEP 335, Java 11 deprecates the Nashorn JavaScript script engine, its APIs,
    and its `jjs` tool. These will be removed in future Java versions.
  prefs: []
  type: TYPE_NORMAL
- en: The Nashorn JavaScript engine was first included in JDK in its recent versions—JDK
    8\. The reason for this was to replace the Rhino scripting engine. However, Java
    is unable to keep up the pace with the evolution of ECMAScript, on which the Nashorn
    JavaScript engine is based.
  prefs: []
  type: TYPE_NORMAL
- en: The challenge to maintain the Nashorn JavaScript engine outperforms the advantages
    that it offers, and therefore paving the way for its deprecation.
  prefs: []
  type: TYPE_NORMAL
- en: JEP 336 – deprecating the pack200 tools and API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduced in Java 5, pack200 was a compression scheme for JAR files. It was
    used to decrease the disk space and bandwidth demand when Java programs were packaged,
    transmitted, or delivered. Developers used pack200 and unpack200 to compress and
    decompress the Java JAR files.
  prefs: []
  type: TYPE_NORMAL
- en: However, these are becoming irrelevant in today's modern storage and transmission
    improvements. JEP 336 deprecates the pack200 and unpack200 tools, and also the
    corresponding pack200 API.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered various features of Java 11\. We saw how a number
    of changes have been introduced over different versions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discover the exciting new additions and modifications
    to the Java language as they are being worked on in **Project Amber** – which
    is about right-sizing the Java language ceremony.
  prefs: []
  type: TYPE_NORMAL
