- en: Miscellaneous Improvements in JDK 11
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDK 11 中的其他改进
- en: Java 11 covers a number of additional interesting changes that we cannot cover
    in individual chapters. However, this doesn't mean that they are not relevant
    or important enough, but because their details are beyond the scope of this book.
    For instance, nest-based access includes changes to the **Java Virtual Machine**
    (**JVM**) specification, dynamic class-file constants extending existing class-file
    constants, improvements with cryptography layers and **Transport Layer Security**
    (**TLS**), and more.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Java 11 包含了许多我们无法在各个章节中单独涵盖的有趣变化。然而，这并不意味着它们不重要或不重要到足以忽略，而是因为它们的细节超出了本书的范围。例如，基于嵌套的访问控制包括对
    **Java 虚拟机**（**JVM**）规范的修改，动态类文件常量扩展了现有的类文件常量，加密层和 **传输层安全性**（**TLS**）的改进，以及更多。
- en: This chapter includes an overview of the remaining JDK 11 features that are
    related to the SE, JDK, and implementation of Java 11 features.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括对与 SE、JDK 和 Java 11 功能实现相关的剩余 JDK 11 功能的概述。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Nest-based access control
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于嵌套的访问控制
- en: Dynamic class-file constants
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态类文件常量
- en: Improving AArch64 intrinsics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进 AArch64 内联函数
- en: Removing the Java EE and CORBA modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除 Java EE 和 CORBA 模块
- en: A key agreement with Curve25519 and Curve448
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 Curve25519 和 Curve448 的密钥协商
- en: Unicode 10
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unicode 10
- en: ChaCha20 and Poly1305 cryptographic algorithms
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ChaCha20 和 Poly1305 密码学算法
- en: Launching single file source code programs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动单个文件源代码程序
- en: TLS 1.3
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TLS 1.3
- en: Deprecating the Nashorn JavaScript engine
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 废弃 Nashorn JavaScript 引擎
- en: Deprecating the pack200 tools and API
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 废弃 pack200 工具和 API
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To work with the code that is included in this chapter, you'll need JDK 11,
    or later, installed on your system.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用本章中包含的代码，您需要在您的系统上安装 JDK 11 或更高版本。
- en: Since this chapter covers multiple features in Java 11, let's quickly map the
    features with their **JDK Enhancement Proposal** (**JEP**) number and scope.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章涵盖了 Java 11 的多个功能，让我们快速将功能与其 **JDK 增强提案**（**JEP**）编号和范围进行匹配。
- en: Listing the JEPs that are used in this chapter
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出本章中使用的 JEP
- en: 'The following table lists the JDK 11 features that are covered in this chapter,
    their corresponding JEP number, and scope:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了本章中涵盖的 JDK 11 功能，它们的对应 JEP 编号和范围：
- en: '| **JEP** | **Scope** | **Description** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **JEP** | **范围** | **描述** |'
- en: '| 181 | SE | Nest-based access control |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 181 | SE | 基于嵌套的访问控制 |'
- en: '| 309 | SE | Dynamic class-file constants |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 309 | SE | 动态类文件常量 |'
- en: '| 315 | Implementation | Improving AArch64 intrinsics |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 315 | 实现 | 改进 AArch64 内联函数 |'
- en: '| 320 | SE | Removing the Java EE and CORBA modules |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 320 | SE | 移除 Java EE 和 CORBA 模块 |'
- en: '| 324 | SE | A key agreement with Curve25519 and Curve448 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 324 | SE | 基于 Curve25519 和 Curve448 的密钥协商 |'
- en: '| 327 | SE | Unicode 10 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 327 | SE | Unicode 10 |'
- en: '| 329 | SE | ChaCha20 and Poly1305 cryptographic algorithms |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 329 | SE | ChaCha20 和 Poly1305 密码学算法 |'
- en: '| 330 | JDK | Launch single file source code programs |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 330 | JDK | 启动单个文件源代码程序 |'
- en: '| 332 | SE | TLS 1.3 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 332 | SE | TLS 1.3 |'
- en: '| 335 | JDK | Deprecate the Nashorn JavaScript engine |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 335 | JDK | 废弃 Nashorn JavaScript 引擎 |'
- en: '| 336 | SE | Deprecate the pack200 tools and API |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 336 | SE | 废弃 pack200 工具和 API |'
- en: Let's get started with the first feature.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个功能开始。
- en: Nest-based access control
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于嵌套的访问控制
- en: 'Imagine what happens when you define nested classes or interfaces? For instance,
    if you define a *two-level class*, say `Outer`, and an *inner class*, say `Inner`,
    can `Inner` access the `private` instance variables of `Outer`? Here''s some sample
    code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下当你定义嵌套类或接口时会发生什么？例如，如果你定义一个 *两层类*，比如说 `Outer`，和一个 *内部类*，比如说 `Inner`，`Inner`
    能否访问 `Outer` 的 `private` 实例变量？以下是一些示例代码：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Yes, it can. Since you define these classes within the same source code file,
    you might assume it to be obvious. However, it is not. The compiler generates
    separate bytecode files (`.class`) for the `Outer` and `Inner` classes. For the
    preceding example, the compiler creates two bytecode files: `Outer.class` and `Outer$Inner.class`.
    For your quick reference, the bytecode file of an inner class is preceded by the
    name of its outer class and a dollar sign.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，它可以。由于您在同一个源代码文件中定义了这些类，您可能会认为这是显而易见的。然而，事实并非如此。编译器为 `Outer` 和 `Inner` 类生成单独的字节码文件（`.class`）。对于前面的示例，编译器创建了两个字节码文件：`Outer.class`
    和 `Outer$Inner.class`。为了您的快速参考，内部类的字节码文件以外部类的名称和一个美元符号开头。
- en: 'To enable the access of variables across these classes and to preserve the
    expectations of programmers, the compiler broadens the access of private members
    to a package or adds bridge variables or methods in each of these classes. Here''s
    the decompiled version of the `Outer` and `Inner` classes that have been decompiled
    using the **JAD Java Decompiler**:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些类之间的变量访问成为可能，并保留程序员的期望，编译器将私有成员的访问范围扩展到包中，或者在每一个这些类中添加桥接变量或方法。以下是使用**JAD
    Java Decompiler**反编译的`Outer`和`Inner`类的反编译版本：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And here is the `Outer$Inner` decompiled class, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Outer$Inner`反编译类的如下所示：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you will notice, the decompiled versions verify that the compiler defined
    a bridge variable, that is, `this$0` of type `Outer` in the `Inner` class, to
    access members of `Outer` from `Inner`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将注意到的，反编译版本验证了编译器定义了一个桥接变量，即在`Inner`类中的`Outer`类型的`this$0`，以便从`Inner`访问`Outer`的成员。
- en: These bridge variables and methods risk encapsulation and increase the size
    of the deployed application. They can also confuse developers and tools.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些桥接变量和方法可能会破坏封装性，并增加部署应用程序的大小。它们也可能使开发人员和工具感到困惑。
- en: What is nest-based access?
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是基于巢的访问？
- en: JEP 181 introduces nest-based access control. As you know, classes and interfaces,
    which are defined within another class or interface are compiled to separate class
    files. To access each other's private members, compilers had been either broadening
    their access levels or inserting bridge methods.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 181 引入了基于巢的访问控制。正如您所知，定义在另一个类或接口内部的类和接口被编译为单独的类文件。为了访问对方的私有成员，编译器要么扩展它们的访问级别，要么插入桥接方法。
- en: Nest-based access control allows such classes and interfaces to access each
    other's private members, without any workarounds (or bridge code) by the compiler.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 基于巢的访问控制允许这样的类和接口相互访问对方的私有成员，而不需要编译器进行任何工作（或桥接代码）。
- en: Nest-based access control also results in changes to the JVM specification.
    You can refer to the following link to access these changes (removals are highlighted
    by a red font background and additions are highlighted using the green background): [https://cr.openjdk.java.net/~dlsmith/nestmates.html](https://cr.openjdk.java.net/~dlsmith/nestmates.html).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 基于巢的访问控制还导致JVM规范的变化。您可以参考以下链接来访问这些变化（删除的内容以红色字体背景突出显示，添加的内容以绿色背景突出显示）：[https://cr.openjdk.java.net/~dlsmith/nestmates.html](https://cr.openjdk.java.net/~dlsmith/nestmates.html)。
- en: Affects of nest-based control
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于巢的控制的 影响
- en: Though it might seem simple, nest-based access control affects all specifications
    and APIs —which involve access control or method invocation—either implicitly
    or explicitly. As mentioned in the *What is nest-based access?* section, it includes
    changes in the JVM specification. It also affects class file attributes, access
    control rules, bytecode invocation rules, reflection, method invocation, and field
    access rules.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它可能看起来很简单，但基于巢的访问控制会影响所有涉及访问控制或方法调用的规范和API——无论是隐式还是显式。如*什么是基于巢的访问？*部分所述，它包括JVM规范的变化。它还影响类文件属性、访问控制规则、字节码调用规则、反射、方法调用和字段访问规则。
- en: It also adds new class file attributes, modifies `MethodHandle` lookup rules,
    results in class transformation/redefinition—the JVM TI and `java.lang.instrument`
    APIs, JDWP, and JDI (`com.sun.jdi.VirtualMachine`).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它还添加了新的类文件属性，修改了`MethodHandle`查找规则，导致类转换/重新定义——JVM TI和`java.lang.instrument`
    API、JDWP和JDI（`com.sun.jdi.VirtualMachine`）。
- en: Dynamic class-file constants
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态类文件常量
- en: JEP 309 extends the existing Java class-file format, creating `CONSTANT_Dynamic`.
    This is a JVM feature and doesn't depend on the higher software layers. The loading
    of `CONSTANT_Dynamic` delegates the creation of a bootstrap method. When comparing
    it to the **invokedynamic** call, you will see how it delegates linking to a bootstrap
    method.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 309 扩展了现有的Java类文件格式，创建`CONSTANT_Dynamic`。这是一个JVM功能，不依赖于更高层的软件。`CONSTANT_Dynamic`的加载将创建引导方法的创建委托给其他地方。当与**invokedynamic**调用进行比较时，您将看到它是如何将链接委托给引导方法的。
- en: One of the main goals of dynamic class-file constants is to make it simple to
    create new forms of materializable class-file constants, which provides language
    designers and compiler implementers with broader options for expressivity and
    performance. This is achieved by creating a new constant pool form that can be
    parameterized using a bootstrap method with static arguments.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类文件常量的一个主要目标是使其能够轻松创建可物化的类文件常量的新形式，这为语言设计者和编译器实现者提供了更广泛的表达性和性能选择。这是通过创建一个新的常量池形式来实现的，该形式可以使用具有静态参数的自举方法进行参数化。
- en: Improving AArch64 intrinsics
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进 AArch64 内联函数
- en: JEP 315 works by improving intrinsics on AArch64 processors. The current string
    and array intrinsic are improved. Also a new intrinsic is implemented for the
    sine, cosine, and logarithmicfunctions in `java.lang.Math`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 315 通过改进 AArch64 处理器上的内联函数来工作。当前的字符串和数组内联函数得到了改进。同时，在 `java.lang.Math` 中实现了新的内联函数，用于正弦、余弦和对数函数。
- en: In order to enhance application performance, intrinsics utilize an assembly
    code that is specific to CPU architecture. It does not execute generic Java code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高应用程序性能，内联函数使用针对 CPU 架构特定的汇编代码。它不会执行通用的 Java 代码。
- en: 'Note that you will see AArch64 processors having an implementation of most
    of the intrinsics. However, JEP 315 implemented an optimized intrinsic for the
    following methods in the `java.lang.Math` class that was not up to the mark:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您将看到 AArch64 处理器实现了大多数内联函数。然而，JEP 315 在 `java.lang.Math` 类中实现了以下方法的优化内联函数，但并未达到预期：
- en: '`sin()`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sin()`'
- en: '`cos()`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cos()`'
- en: '`log()`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log()`'
- en: 'It is also worth noting that some of the intrinsics that are previously implemented
    in the AArch64 port might not be completely optimal. Such intrinsic can take advantage
    of features such as memory address alignment or software prefetching instructions.
    Some of those methods are listed as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，在 AArch64 端口之前实现的一些内联函数可能并不完全优化。这样的内联函数可以利用诸如内存地址对齐或软件预取指令等特性。以下列出了一些这些方法：
- en: '`String::compareTo`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String::compareTo`'
- en: '`String::indexOf`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String::indexOf`'
- en: '`StringCoding::hasNegatives`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringCoding::hasNegatives`'
- en: '`` `Arrays::equals` ``'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `Arrays::equals` ``'
- en: '`StringUTF16::compress`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringUTF16::compress`'
- en: '`StringLatin1::inflate`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringLatin1::inflate`'
- en: Removing the Java EE and CORBA modules
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除 Java EE 和 CORBA 模块
- en: Java EE moved to the Eclipse Foundation with Java 9 under a new name – Jakarta
    EE (interestingly, still JEE). With Java 9, the modules and classes that were
    specific to Java EE were deprecated. With Java 11, these deprecated APIs and modules
    have been removed from the Java SE platform and the JDK. CORBA's APIs were also
    deprecated in Java 9 and were eventually removed in Java 11.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 在 Java 9 中迁移到了 Eclipse 基金会，并采用了新的名称——Jakarta EE（有趣的是，仍然是 JEE）。在 Java
    9 中，特定于 Java EE 的模块和类已被弃用。在 Java 11 中，这些弃用的 API 和模块已被从 Java SE 平台和 JDK 中删除。CORBA
    的 API 也在 Java 9 中被弃用，并在 Java 11 中最终被删除。
- en: 'With Java SE 6 (core Java), you can develop web services using the following
    technologies:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java SE 6（核心 Java）中，您可以使用以下技术来开发 Web 服务：
- en: '**JAX-WS** (short for **Java API for XML-Based Web Services**)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JAX-WS**（Java API for XML-Based Web Services 的缩写）'
- en: '**JAXB** (short for **Java Architecture for XML Binding**)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JAXB**（Java Architecture for XML Binding 的缩写）'
- en: '**JAF** (short for **JavaBeans Activation Framework**)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JAF**（JavaBeans Activation Framework 的缩写）'
- en: '**Common annotations**'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常用注解**'
- en: When the code for the preceding tech stack was added to core Java, it was identical
    to its versions for **Java's Enterprise Edition** (**JEE**). However, over time,
    the JEE version evolved, leading to a mismatch in the functionality that was offered
    by the same APIs in Java SE and JEE.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当将上述技术堆栈的代码添加到核心 Java 中时，它与 **Java 企业版**（**JEE**）的版本相同。然而，随着时间的推移，JEE 版本发生了演变，导致
    Java SE 和 JEE 中相同 API 提供的功能不匹配。
- en: 'JEP 320 removed the following modules in Java 11, deleting their source code
    from the OpenJDK repository and runtime JDK image:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 320 在 Java 11 中删除了以下模块，从 OpenJDK 仓库和运行时 JDK 图像中删除了它们的源代码：
- en: '`java.xml.ws` (JAX-WS)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.xml.ws` (JAX-WS)'
- en: '`java.xml.bind` (JAXB)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.xml.bind` (JAXB)'
- en: '`java.activation` (JAF)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.activation` (JAF)'
- en: '`java.xml.ws.annotation` (common annotations)'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.xml.ws.annotation` (常用注解)'
- en: '`java.corba` (CORBA)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.corba` (CORBA)'
- en: '`java.transaction` (JTA)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.transaction` (JTA)'
- en: '`java.se.ee` (an aggregator module for the preceding six modules)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.se.ee`（前六个模块的聚合模块）'
- en: '`jdk.xml.ws` (JAX-WS tools)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jdk.xml.ws` (JAX-WS 工具)'
- en: '`jdk.xml.bind` (JAXB tools)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jdk.xml.bind` (JAXB 工具)'
- en: Apart from marking the preceding modules as deprecated in Java 9, JDK didn't
    resolve them when code that was using these modules was compiled or executed.
    This forced the developers to use standalone versions of Java EE or CORBA on the
    classpath.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在Java 9中将前面的模块标记为已弃用外，JDK在编译或执行使用这些模块的代码时并没有解决这些问题。这迫使开发者必须在类路径上使用Java EE或CORBA的独立版本。
- en: 'After their removal, tools such as `wsgen` and `wsimport` (from `jdk.xml.ws`),
    `schemagen` and `xjc` (from `jdk.xml.bind`), `idlj`, `orbd`, `servertool`, and
    `tnamesrv` (from `java.corba`) were no longer available. Developers couldn''t
    enable them using runtime command-line flags, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在它们被移除后，`wsgen`和`wsimport`（来自`jdk.xml.ws`）、`schemagen`和`xjc`（来自`jdk.xml.bind`）、`idlj`、`orbd`、`servertool`和`tnamesrv`（来自`java.corba`）等工具不再可用。开发者无法通过运行时命令行标志来启用它们，如下所示：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: CORBA, an ORB implementation, was included in Java SE in 1998\. Over time, support
    for CORBA has outweighed its benefits. First of all, with better technologies
    available, hardly anyone is using CORBA now. CORBA evolves outside the **Java
    Community Process** (**JCP**) and it is becoming increasingly difficult to maintain
    JDK's CORBA implementation. With JEE now moving to the Eclipse Foundation, it
    makes no sense to synchronize ORB in JDK with Jakarta EE's ORB. To add to this,
    JEE 8 designated it as **Proposed Optional**, which essentially means that JEE
    might drop supporting CORBA in one of its future versions (marking it as deprecated).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: CORBA，一个ORB实现，于1998年被包含在Java SE中。随着时间的推移，对CORBA的支持超过了其好处。首先，随着更好的技术的可用性，现在几乎没有人使用CORBA。CORBA在**Java社区进程**（**JCP**）之外发展，维护JDK的CORBA实现变得越来越困难。由于JEE现在正转向Eclipse基金会，将JDK中的ORB与Jakarta
    EE的ORB同步就没有意义了。更不用说，JEE 8将其指定为**建议可选**，这实际上意味着JEE可能在未来的某个版本中放弃对CORBA的支持（将其标记为已弃用）。
- en: Enterprises moving from Java 8 to Java 11 are at a higher risk if their applications
    use JEE or CORBA APIs. However, an alternate API is suggested by Oracle, easing
    the migration.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正在从Java 8迁移到Java 11的企业，如果它们的应用程序使用JEE或CORBA API，将面临更高的风险。然而，Oracle建议使用一个替代API，这有助于简化迁移过程。
- en: A key agreement with Curve25519 and Curve448
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Curve25519和Curve448曲线的关键协议
- en: With JEP 324, Java SE is making further advances in cryptography that offers
    security and performance. This feature implements a key agreement using Curve25519
    and Curve448\. Other cryptography libraries, such as OpenSSL and BoringSSL, already
    support key exchanges using Curve25519 and Curve448.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过JEP 324，Java SE在密码学方面取得了进一步进展，提供了安全和性能。此功能实现了使用Curve25519和Curve448的关键协议。其他密码学库，如OpenSSL和BoringSSL，已经支持使用Curve25519和Curve448进行密钥交换。
- en: You can find more information on Cureve25519 and Curve448 at [https://tools.ietf.org/html/rfc7748](https://tools.ietf.org/html/rfc7748).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://tools.ietf.org/html/rfc7748](https://tools.ietf.org/html/rfc7748)上找到更多关于Curve25519和Curve448的信息。
- en: Unicode 10
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unicode 10
- en: 'JEP 327 upgrades existing platform APIs to support Unicode 10 Standard ([http://www.unicode.org/standard/standard.html](http://www.unicode.org/standard/standard.html)),
    mainly in the following classes:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 327将现有平台API升级以支持Unicode 10标准([http://www.unicode.org/standard/standard.html](http://www.unicode.org/standard/standard.html))，主要在以下类中：
- en: '`Character` and `String` (the `java.lang` package)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Character`和`String`（位于`java.lang`包）'
- en: '`NumericShaper` (the `java.awt.font` package)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NumericShaper`（位于`java.awt.font`包）'
- en: '`Bidi`, `BreakIterator`, and `Normalizer` (the `java.text` package)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bidi`、`BreakIterator`和`Normalizer`（位于`java.text`包）'
- en: ChaCha20 and Poly1305 cryptographic algorithms
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ChaCha20和Poly1305加密算法
- en: Java 11 includes multiple additions and enhancements in cryptographic toolkits
    and TLS implementations. JEP 329 implements the ChaCha20 and ChaCha20-Poly1305
    ciphers. Being a comparatively new stream cipher, ChaCha20 is capable in taking
    place of the RC4 stream cipher.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Java 11在密码工具包和TLS实现中包含了多个新增和增强功能。JEP 329实现了ChaCha20和ChaCha20-Poly1305密码。作为一个相对较新的流密码，ChaCha20能够取代RC4流密码。
- en: At present, the RC4 stream cipher, which has been widely adopted, is not so
    secure. The industry is moving toward the adoption of the more secure ChaCha20-Poly1305\.
    This has also been widely adopted across TLS implementations as well as in other
    cryptographic protocols.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，广泛采用的RC4流密码并不那么安全。行业正在转向采用更安全的ChaCha20-Poly1305。这也已被广泛采用在TLS实现以及其他加密协议中。
- en: Launching single file source code programs
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动单个文件源代码程序
- en: 'Imagine being able to execute a Java application without compilation; for instance,
    if you define the following Java class in `HelloNoCompilation.java`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下能够在不进行编译的情况下执行 Java 应用程序；例如，如果你在 `HelloNoCompilation.java` 文件中定义以下 Java
    类：
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With Java 11, you can execute it using the following command (no compilation
    takes place):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Java 11，你可以使用以下命令执行它（不进行编译）：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that the preceding command starts the JVM using `java`, which is passed
    the name of a source file with the `.java` extension. In this case, the class
    is compiled in memory before it is executed by the JVM. This applies to multiple
    classes or interfaces that are defined within the same source file. Here''s another
    example (consider it to be defined within the same `HelloNoCompilation.java` source
    file):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，上述命令使用 `java` 启动 JVM，它传递了一个具有 `.java` 扩展名的源文件名。在这种情况下，类是在 JVM 执行之前在内存中编译的。这适用于在同一源文件中定义的多个类或接口。以下是一个示例（假设它定义在同一个
    `HelloNoCompilation.java` 源文件中）：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On execution, you will see the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行时，你会看到以下命令：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code will output as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将输出如下：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With JEP 330, you can cut down the step of compiling your code and go to the
    execution of your Java applications straight away. However, this only applies
    to applications with a single source file. The source file can define multiple
    classes or interfaces, as shown in the preceding example code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JEP 330，你可以减少编译代码的步骤，直接进入执行 Java 应用程序。然而，这仅适用于单源文件的应用程序。源文件可以定义多个类或接口，如前例代码所示。
- en: Launching single file source code programs helps to reduce the ceremony attached
    to simple code execution. This is the most helpful for students or professionals
    who are beginning to learn Java. However, when they move to working with multiple
    source files, they'll need to compile their code before executing them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 启动单文件源代码程序有助于减少简单代码执行所需的仪式。这对刚开始学习 Java 的学生或专业人士来说非常有帮助。然而，当他们开始使用多个源文件工作时，他们需要在执行之前编译他们的代码。
- en: 'However, if you compile your source class using the `javac` command and then
    try to launch it as a single file source code, it won''t execute. For example,
    compile the `HelloNoCompilation` source file, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你使用 `javac` 命令编译源类，然后尝试将其作为单文件源代码启动，它将无法执行。例如，按照以下方式编译 `HelloNoCompilation`
    源文件：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, try to execute the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，尝试执行以下命令：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You''ll receive the following error:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你将收到以下错误：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: TLS 1.3
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TLS 1.3
- en: Here's another addition to the TLS implementation in Java. JEP 332 implements
    Version 1.3 of the TLS Protocol.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Java 中 TLS 实现的另一个补充。JEP 332 实现了 TLS 协议的 1.3 版本。
- en: Version 1.3 of TLS supersedes and obsoletes its previous versions, including
    Version 1.2 (that is, RFC 5246, which can be found at [https://tools.ietf.org/html/rfc5246](https://tools.ietf.org/html/rfc5246)).
    It also obsoletes or changes other TLS features, such as the **OCSP** (short for
    **Online Certificate Status Protocol**) stapling extensions (that is, RFC 6066,
    which can be found at [https://tools.ietf.org/html/rfc6066](https://tools.ietf.org/html/rfc6066); and
    RFC 6961, which can be found at [https://tools.ietf.org/html/rfc6961](https://tools.ietf.org/html/rfc6961)),
    and the session hash and extended master secret extension (that is, RFC 7627;
    for more information, visit [https://tools.ietf.org/html/rfc7627](https://tools.ietf.org/html/rfc7627)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.3 版本取代并过时了其之前的版本，包括 1.2 版本（即 RFC 5246，可以在 [https://tools.ietf.org/html/rfc5246](https://tools.ietf.org/html/rfc5246)
    找到）。它还过时或更改了其他 TLS 功能，例如 **OCSP**（即 **在线证书状态协议**）的粘贴扩展（即 RFC 6066，可以在 [https://tools.ietf.org/html/rfc6066](https://tools.ietf.org/html/rfc6066)
    找到；以及 RFC 6961，可以在 [https://tools.ietf.org/html/rfc6961](https://tools.ietf.org/html/rfc6961)
    找到) 和会话哈希以及扩展主密钥扩展（即 RFC 7627；更多信息，请访问 [https://tools.ietf.org/html/rfc7627](https://tools.ietf.org/html/rfc7627)）。
- en: Deprecating the Nashorn JavaScript engine
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弃用 Nashorn JavaScript 引擎
- en: With JEP 335, Java 11 deprecates the Nashorn JavaScript script engine, its APIs,
    and its `jjs` tool. These will be removed in future Java versions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JEP 335，Java 11 弃用了 Nashorn JavaScript 脚本引擎、其 API 和其 `jjs` 工具。这些将在未来的 Java
    版本中删除。
- en: The Nashorn JavaScript engine was first included in JDK in its recent versions—JDK
    8\. The reason for this was to replace the Rhino scripting engine. However, Java
    is unable to keep up the pace with the evolution of ECMAScript, on which the Nashorn
    JavaScript engine is based.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Nashorn JavaScript 引擎首次包含在 JDK 的最新版本中——JDK 8。这样做的原因是为了替换 Rhino 脚本引擎。然而，Java
    无法跟上基于 ECMAScript 的 Nashorn JavaScript 引擎的演变步伐。
- en: The challenge to maintain the Nashorn JavaScript engine outperforms the advantages
    that it offers, and therefore paving the way for its deprecation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 维护 Nashorn JavaScript 引擎的挑战超过了它所提供的优势，因此为其废弃铺平了道路。
- en: JEP 336 – deprecating the pack200 tools and API
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JEP 336 – 废弃 pack200 工具和 API
- en: Introduced in Java 5, pack200 was a compression scheme for JAR files. It was
    used to decrease the disk space and bandwidth demand when Java programs were packaged,
    transmitted, or delivered. Developers used pack200 and unpack200 to compress and
    decompress the Java JAR files.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Java 5 中引入的 pack200 是一种用于 JAR 文件的压缩方案。它用于在打包、传输或交付 Java 程序时减少磁盘空间和带宽需求。开发者使用
    pack200 和 unpack200 来压缩和解压缩 Java JAR 文件。
- en: However, these are becoming irrelevant in today's modern storage and transmission
    improvements. JEP 336 deprecates the pack200 and unpack200 tools, and also the
    corresponding pack200 API.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着今天现代存储和传输技术的改进，这些变得不再相关。JEP 336 废弃了 pack200 和 unpack200 工具，以及相应的 pack200
    API。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered various features of Java 11\. We saw how a number
    of changes have been introduced over different versions.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Java 11 的各种特性。我们看到了在不同版本中引入了众多变化。
- en: In the next chapter, we will discover the exciting new additions and modifications
    to the Java language as they are being worked on in **Project Amber** – which
    is about right-sizing the Java language ceremony.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将发现 Java 语言在 **Project Amber** 项目中的新增功能和修改——该项目旨在调整 Java 语言的规模。
