- en: Concurrency and Parallelization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发与并行化
- en: The need for concurrency has grown rapidly in the past 10 years and has become
    a necessity for every professional Java programmer. Concurrency (also called **multithreading**)
    is essentially multitasking, where you have several processes executing at the
    same time. If you want to fully utilize your hardware's computing power (whether
    it is a phone, server, laptop, or desktop computer), you need to learn how to
    multithread and leverage concurrency. Thankfully, RxJava makes concurrency much
    easier and safer to achieve.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去10年中，对并发的需求迅速增长，并已成为每位专业Java程序员的需求。并发（也称为**多线程**）本质上是一种多任务处理，其中同时执行多个进程。如果你想充分利用硬件的计算能力（无论是手机、服务器、笔记本电脑还是台式计算机），你需要学习如何多线程和利用并发。幸运的是，RxJava使并发变得更容易且更安全。
- en: 'In this chapter, we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: An overview of concurrency and its necessity
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发及其必要性的概述
- en: '`subscribeOn()`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribeOn()`'
- en: '`observeOn()`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`observeOn()`'
- en: Parallelization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行化
- en: '`unsubscribeOn()`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsubscribeOn()`'
- en: Why concurrency is necessary
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么并发是必要的
- en: In simpler times, computers had only one CPU and this marginalized the need
    for concurrency. Hardware manufacturers successfully found ways to make CPUs faster,
    and this made single-threaded programs faster. But eventually, this had a diminishing
    return, and manufacturers found they could increase computational power by putting
    multiple CPUs in a device. From desktops and laptops to servers and smartphones,
    most hardware nowadays sports multiple CPUs, or cores.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在更简单的时代，计算机只有一个CPU，这使得并发需求变得微不足道。硬件制造商成功找到了让CPU更快的方法，这使得单线程程序运行得更快。但最终，这种方法的效果逐渐减弱，制造商发现他们可以通过在设备中放置多个CPU来提高计算能力。从台式机和笔记本电脑到服务器和智能手机，现在的多数硬件都配备了多个CPU或核心。
- en: For developers, this is a major disruption in building software and how coding
    is done. Single-threaded software is easier to code and works fine on a single-core
    device. But a single-threaded program on a multi-core device will only use one
    core, leaving the others not utilized. If you want your program to scale, it needs
    to be coded in a way that utilizes all cores available in a processor.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发者来说，这是构建软件和编码方式的一次重大颠覆。单线程软件更容易编写，在单核设备上运行良好。但在多核设备上的单线程程序只会使用一个核心，而其他核心则未被利用。如果你想让你的程序可扩展，它需要以利用处理器中所有可用核心的方式编写。
- en: However, concurrency is traditionally not easy to implement. If you have several
    independent processes that do not interact with each other, it is easier to accomplish.
    But when resources, especially mutable objects, are shared across different threads
    and processes, chaos can ensue if locking and synchronization are not carefully
    implemented. Not only can threads race each other chaotically to read and change
    an object's properties, but a thread may simply not see a value changed by another
    thread! This is why you should strive to make your objects immutable and make
    as many properties and variables `final` as possible. This ensures that properties
    and variables are thread-safe and anything that is mutable should be synchronized
    or at least utilize the `volatile` keyword.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，传统上并发并不容易实现。如果你有几个相互独立的进程，那么实现起来更容易。但当资源，尤其是可变对象，在不同线程和进程之间共享时，如果不小心实现锁定和同步，就会引发混乱。不仅线程可能会混乱地相互竞争以读取和更改对象的属性，而且一个线程可能根本看不到另一个线程更改的值！这就是为什么你应该努力使你的对象不可变，并尽可能多地使属性和变量`final`。这确保了属性和变量是线程安全的，任何可变的东西都应该同步，或者至少使用`volatile`关键字。
- en: 'Thankfully, RxJava makes concurrency and multithreading much easier and safer.
    There are ways you can undermine the safety it provides, but generally, RxJava
    handles concurrency safely for you mainly using two operators: `subscribeOn()`
    and `observeOn()`.  As we will find out in this chapter, other operators such
    as `flatMap()` can be combined with these two operators to create powerful concurrency
    dataflows.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，RxJava使并发和多线程变得更容易且更安全。有方法可以破坏它提供的安全性，但通常，RxJava主要使用两个操作符：`subscribeOn()`和`observeOn()`来为你安全地处理并发。正如我们将在本章中了解到的那样，其他操作符如`flatMap()`可以与这两个操作符结合使用，以创建强大的并发数据流。
- en: While RxJava can help you make safe and powerful concurrent applications with
    little effort, it can be helpful to be aware of the traps and pitfalls in multithreading.
    Joshua Bloch's famous book *Effective Java* is an excellent resource that every
    Java developer should have, and it succinctly covers best practices for concurrent
    applications. If you want deep knowledge in Java concurrency, ensure that you
    read Brian Goetz' *Java Concurrency in Practice* as well.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 RxJava 可以帮助你轻松地创建安全且强大的并发应用程序，但了解多线程中的陷阱和陷阱仍然很有帮助。Joshua Bloch 的著名书籍 *Effective
    Java* 是每个 Java 开发者都应该拥有的优秀资源，它简洁地涵盖了并发应用程序的最佳实践。如果你想在 Java 并发方面获得深入的知识，确保你也阅读了
    Brian Goetz 的 *Java Concurrency in Practice*。
- en: Concurrency in a nutshell
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发概述
- en: Concurrency, also called **multithreading**, can be applied in a variety of
    ways. Usually, the motivation behind concurrency is to run more than one task
    simultaneously in order to get work done faster. As we discussed in the beginning
    of this book, concurrency can also help our code resemble the real world more,
    where multiple activities occur at the same time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 并发，也称为 **多线程**，可以以多种方式应用。通常，并发的动机是为了更快地完成工作而同时运行多个任务。正如我们在本书的开头所讨论的，并发还可以帮助我们的代码更接近现实世界，在现实世界中，多种活动是同时发生的。
- en: First, let's cover some fundamental concepts behind concurrency.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来了解一下并发背后的基本概念。
- en: 'One common application of concurrency is to run different tasks simultaneously.
    Imagine that you have three yard chores: mow the lawn, trim the trees, and pull
    the weeds. If you do these three chores by yourself, you can only do one chore
    at a time. You cannot mow the lawn and trim the trees simultaneously. You have
    to sequentially mow the lawn first, then trim the trees, then pull the weeds.
    But if you have a friend to help you, one of you can mow the lawn while the other
    trims the trees. The first one of you to get done can then move on to the third
    task: pulling the weeds. This way, these three tasks get done much more quickly.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 并发的一个常见应用是同时运行不同的任务。想象一下，你有三项庭院工作：修剪草坪、修剪树木和拔草。如果你自己完成这三项工作，你一次只能做一项。你不能同时修剪草坪和修剪树木。你必须先顺序修剪草坪，然后修剪树木，最后拔草。但是如果你有一个朋友帮忙，你们中的一个可以修剪草坪，而另一个可以修剪树木。第一个完成的人可以接着进行第三项任务：拔草。这样，这三项任务可以更快地完成。
- en: Metaphorically, you and your friend are **threads**. You do work together. Collectively,
    you both are a **thread pool** ready to execute tasks. The chores are tasks that
    are queued for the thread pool, which you can execute two at a time. If you have
    more threads, your thread pool will have more bandwidth to take on more tasks
    concurrently. However, depending on how many cores your computer has (as well
    as the nature of the tasks), you can only have so many threads. Threads are expensive
    to create, maintain, and destroy, and there is a diminishing return in performance
    as you create them excessively. That is why it is better to have a thread pool
    to *reuse* threads and have them work a queue of tasks.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 比喻地说，你和你的朋友是 **线程**。你们一起工作。从整体上看，你们两人是一个 **线程池**，准备执行任务。家务是线程池中排队的任务，你可以一次执行两个。如果你有更多的线程，你的线程池将拥有更多的带宽来同时处理更多的任务。然而，根据你的计算机有多少核心（以及任务的性质），你只能拥有这么多线程。线程的创建、维护和销毁都很昂贵，随着你创建它们的数量增加，性能的回报会逐渐减少。这就是为什么有一个线程池来
    *重用* 线程并让它们处理任务队列会更好。
- en: Understanding parallelization
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解并行化
- en: Parallelization (also called parallelism) is a broad term that could encompass
    the preceding scenario. In effect, you and your friend are executing two tasks
    at the same time and are thus processing in parallel. But let's apply parallelization
    to processing multiple identical tasks at the same time. Take, for example, a
    grocery store that has 10 customers waiting in a line for checkout. These 10 customers
    represent 10 tasks that are identical. They each need to check out their groceries.
    If a cashier represents a thread, we can have multiple cashiers to process these
    customers more quickly. But like threads, cashiers are expensive. We do not want
    to create a cashier for each customer, but rather pool a fixed number of cashiers
    and reuse them. If we have five cashiers, we can process five customers at a time
    while the rest wait in the queue. The moment a cashier finishes a customer, they
    can process the next one.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 并行化（也称为并行性）是一个广泛的概念，可以涵盖上述场景。实际上，你和你的朋友同时执行两个任务，因此是在并行处理。但让我们将并行化应用于同时处理多个相同任务的情况。以一个有10名顾客在结账处排队等待的杂货店为例。这10名顾客代表了10个相同的任务，他们各自需要结账。如果收银员代表一个线程，我们可以有多个收银员来更快地处理这些顾客。但就像线程一样，收银员是昂贵的。我们不希望为每个顾客创建一个收银员，而是集中一定数量的收银员并重复使用它们。如果我们有五个收银员，我们就可以一次处理五个顾客，其余的则在队列中等待。当一个收银员完成一个顾客后，他们可以处理下一个顾客。
- en: This is essentially what parallelization achieves. If you have 1000 objects
    and you need to perform an expensive calculation on each one, you can use five
    threads to process five objects at a time and potentially finish this process
    five times more quickly. It is critical to pool these threads and reuse them because
    creating 1000 threads to process these 1000 objects could overwhelm your memory
    and crash your program.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是并行化所达到的效果。如果你有1000个对象，并且需要对每个对象执行昂贵的计算，你可以使用五个线程一次处理五个对象，并可能使这个过程快五倍。关键是要池化这些线程并重复使用它们，因为创建1000个线程来处理这1000个对象可能会耗尽你的内存并使程序崩溃。
- en: With a conceptual understanding of concurrency, we will move on to discussing
    how it is achieved in RxJava.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了并发的概念之后，我们将继续讨论在RxJava中是如何实现并发的。
- en: Introducing RxJava concurrency
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入RxJava并发
- en: Concurrency in RxJava is simple to execute, but somewhat abstract to understand.
    By default, Observables execute work on the immediate thread, which is the thread
    that declared the `Observer` and subscribed it. In many of our earlier examples,
    this was the main thread that kicked off our `main()` method.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxJava中执行并发很简单，但理解起来有些抽象。默认情况下，`Observable`在立即的线程上执行工作，即声明`Observer`并订阅它的线程。在我们的许多早期示例中，这是启动我们的`main()`方法的主线程。
- en: 'But as hinted in a few other examples, not all Observables will fire on the
    immediate thread. Remember those times we used `Observable.interval()`, as shown
    in the following code? Let''s take a look:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如在几个其他示例中暗示的那样，并非所有`Observable`都会在立即的线程上触发。记得我们使用`Observable.interval()`的那些时候，如下面的代码所示？让我们看看：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This `Observable` will actually fire on a thread other than the main one. Effectively,
    the main thread will kick-off `Observable.interval(),` but not wait for it to
    complete because it is operating on its own separate thread now. This, in fact,
    makes it a concurrent application because it is leveraging two threads now. If
    we do not call a `sleep()` method to pause the main thread, it will charge to
    the end of the `main()` method and quit the application before the intervals have
    a chance to fire.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Observable`实际上会在主线程之外的线程上触发。实际上，主线程将启动`Observable.interval()`，但不会等待它完成，因为它现在正在自己的单独线程上运行。这实际上使它成为一个并发应用程序，因为它现在正在利用两个线程。如果我们不调用`sleep()`方法来暂停主线程，它将冲到`main()`方法的末尾并退出应用程序，而此时间隔还没有机会触发。
- en: 'Usually, concurrency is useful only when you have long-running or calculation-intensive
    processes. To help us learn concurrency without creating noisy examples, we will
    create a helper method called `intenseCalculation()` to emulate a long-running
    process. It will simply accept any value and then sleep for 0-3 seconds and then
    return the same value.  Sleeping a thread, or pausing it, is a great way to simulate
    a busy thread doing work:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，并发只有在你有长时间运行或计算密集型过程时才有用。为了帮助我们学习并发而不创建嘈杂的示例，我们将创建一个名为`intenseCalculation()`的辅助方法来模拟长时间运行的过程。它将简单地接受任何值，然后睡眠0-3秒，然后返回相同的值。暂停线程，或暂停它，是模拟忙碌线程工作的好方法：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s create two Observables with two Observers subscribing to them. In each
    operation. map each emission to the `intenseCalculation()` method in order to
    slow them down:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建两个Observables，并让两个Observer订阅它们。在每个操作中，将每个发射映射到`intenseCalculation()`方法以减慢它们的速度：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note how both Observables fire emissions slowly as each one is slowed by 0-3
    seconds in the `map()` operation. More importantly, note how the first `Observable`
    firing `Alpha`, `Beta`, `Gamma` must finish first and call `onComplete()` before
    firing the second `Observable` emitting the numbers `1` through `6`.  If we fire
    both Observables at the same time rather than waiting for one to complete before
    starting the other, we could get this operation done much more quickly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于每个Observables在`map()`操作中被减慢了0-3秒，它们发射发射的速度都很慢。更重要的是，注意第一个发射`Alpha`、`Beta`、`Gamma`的`Observable`必须首先完成并调用`onComplete()`，然后才能发射第二个发射数字`1`到`6`的`Observable`。如果我们同时发射两个Observables而不是等待一个完成后再开始另一个，我们可以更快地完成这个操作。
- en: 'We can achieve this using the `subscribeOn()` operator, which suggests to the
    source to fire emissions on a specified `Scheduler`. In this case, let us use
    `Schedulers.computation()`, which pools a fixed number of threads appropriate
    for computation operations. It will provide a thread to push emissions for each
    `Observer`. When `onComplete()` is called, the thread will be given back to `Scheduler`
    so it can be reused elsewhere:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`subscribeOn()`操作符来实现这一点，该操作符建议源在指定的`Scheduler`上触发发射。在这种情况下，让我们使用`Schedulers.computation()`，它为计算操作收集了适当数量的线程。它将为每个`Observer`提供一个线程来推送发射。当调用`onComplete()`时，线程将被返回给`Scheduler`以便可以在其他地方重用：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is as follows (yours may be different):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下（您的可能不同）：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Your output will likely be different from mine due to the random sleeping times.
    But note how both operations are firing simultaneously now, allowing the program
    to finish much more quickly. Rather than the main thread becoming occupied, executing
    emissions for the first `Observable` before moving onto the second, it will fire-off
    both Observables immediately and move on. It will not wait for either `Observable`
    to complete.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输出可能与我不同，因为随机睡眠时间。但请注意，现在两个操作都在同时发射，这使得程序可以更快地完成。而不是主线程被占用，在执行第一个Observables的发射之前移动到第二个，它将立即发射两个Observables并继续。它不会等待任何一个Observables完成。
- en: Having multiple processes occurring at the same time is what makes an application
    concurrent. It can result in much greater efficiency as it will utilize more cores
    and finish work more quickly. Concurrency also makes code models more powerful
    and more representative of how our world works, where multiple activities occur
    simultaneously.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 同时发生多个进程是使应用程序并发的因素。它可以带来更高的效率，因为它将利用更多核心并更快地完成工作。并发还使代码模型更强大，更能代表我们世界的运作方式，在那里多个活动同时发生。
- en: 'Something else that is exciting about RxJava is its operators (at least the
    official ones and the custom ones built properly). They can work with Observables
    on different threads safely. Even operators and factories that combine multiple
    Observables, such as `merge()` and `zip()`, will safely combine emissions pushed
    by different threads. For instance, we can use  `zip()` on our two Observables
    in the preceding example even if they are emitting on two separate computation
    threads:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 关于RxJava令人兴奋的另一个方面是其操作符（至少是官方的操作符和构建良好的自定义操作符）。它们可以在不同的线程上安全地与Observables一起工作。甚至像`merge()`和`zip()`这样的操作符和工厂，它们可以安全地组合来自不同线程的发射。例如，即使它们在两个不同的计算线程上发射，我们也可以在我们的前一个示例中使用`zip()`：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Being able to split and combine Observables happening on different threads is
    powerful and eliminates the pain points of callbacks. Observables are agnostic
    to whatever thread they work on, making concurrency easy to implement, configure,
    and evolve at any time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在不同线程上拆分和组合Observables是非常强大的，并且消除了回调的痛点。Observables对它们工作的线程一无所知，这使得并发易于实现、配置和随时演进。
- en: When you start making reactive applications concurrent, a subtle complication
    can creep in.  By default, a non-concurrent application will have one thread doing
    all the work from the source to the final `Observer`. But having multiple threads
    can cause emissions to be produced faster than an `Observer` can consume them
    (for instance, the `zip()` operator may have one source producing emissions faster
    than the other). This can overwhelm the program and memory can run out as backlogged
    emissions are cached by certain operators. When you are working with a high volume
    of emissions (more than 10,000) and leveraging concurrency, you will likely want
    to use Flowables instead of Observables, which we will cover in [Chapter 8](14efb9e9-14a6-41ba-86cb-20b5674dce8e.xhtml), *Flowables
    and Backpressure*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始使反应式应用程序并发时，可能会出现微妙的复杂性。默认情况下，一个非并发应用程序将有一个线程从源到最终的`Observer`执行所有工作。但是，多个线程可能会导致发射速度超过`Observer`可以消费的速度（例如，`zip()`操作符可能有一个源产生发射速度比另一个快）。这可能会使程序过载，内存可能会耗尽，因为某些操作符会缓存积压的发射。当你处理大量发射（超过10,000）并利用并发时，你可能会想使用Flowables而不是Observables，我们将在[第8章](14efb9e9-14a6-41ba-86cb-20b5674dce8e.xhtml)中介绍，*Flowables和背压*。
- en: Keeping an application alive
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持应用程序存活
- en: Up until this point, we have used a `sleep()` method to keep concurrent reactive
    applications from quitting prematurely, just long enough for the Observables to
    fire. If you are using Android, JavaFX, or other frameworks that manage their
    own non-daemon threads, this is not a concern as the application will be kept
    alive for you. But if you are simply firing off a program with a `main()` method
    and you want to kick off long-running or infinite Observables, you may have to
    keep the main thread alive for a period longer than 5-20 seconds. Sometimes, you
    may want to keep it alive indefinitely.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用`sleep()`方法来防止并发反应式应用程序过早退出，仅足够让Observables触发。如果你使用Android、JavaFX或其他管理自己的非守护线程的框架，这不是一个问题，因为应用程序会为你保持存活。但如果你只是使用`main()`方法启动程序，并且你想启动长时间运行或无限的Observables，你可能需要让主线程存活的时间超过5-20秒。有时，你可能希望无限期地保持其存活。
- en: 'One way to keep an application alive indefinitely is to simply pass `Long.MAX_VALUE`
    to the `Thread.sleep()` method, as shown in the following code, where we have `Observable.interval()`
    firing emissions forever:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让应用程序无限期存活的一种方法是将`Long.MAX_VALUE`传递给`Thread.sleep()`方法，如下面的代码所示，其中我们使用`Observable.interval()`无限期地触发发射：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Okay, sleeping your main thread for 9,223,372,036,854,775,807 milliseconds is
    not forever, but that is the equivalent to  292,471,208.7 years. For the purposes
    of sleeping a thread, that might as well be forever!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让主线程休眠9,223,372,036,854,775,807毫秒不是永远，但这相当于292,471,208.7年。对于休眠线程的目的来说，这几乎就是永远！
- en: There are ways to keep an application alive only long enough for a subscription
    to finish. With classical concurrency tools discussed in Brian Goetz' book *Java
    Concurrency in Practice*, you can keep an application alive using `CountDownLatch`
    to wait for two subscriptions to finish. But an easier way is to use blocking
    operators in RxJava.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有方法可以让应用程序仅存活足够长的时间来完成订阅。在Brian Goetz的书籍《Java并发实践》中讨论的经典并发工具，你可以使用`CountDownLatch`等待两个订阅完成来保持应用程序存活。但更简单的方法是使用RxJava中的阻塞操作符。
- en: 'You can use blocking operators to stop the declaring thread and wait for emissions.
    Usually, blocking operators are used for unit testing (as we will discuss in [Chapter
    10](ec80132f-c411-4cc1-87b2-7a8ebba089b8.xhtml), *Testing and Debugging*), and
    they can attract antipatterns if used improperly in production. However, keeping
    an application alive based on the life cycle of a finite `Observable` subscription
    is a valid case to use a blocking operator. As shown here, `blockingSubscribe()`
    can be used in place of `subscribe()` to stop and wait for `onComplete()` to be
    called before the main thread is allowed to proceed and exit the application:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用阻塞操作符来停止声明线程并等待发射。通常，阻塞操作符用于单元测试（我们将在[第10章](ec80132f-c411-4cc1-87b2-7a8ebba089b8.xhtml)中讨论，*测试和调试*），如果使用不当，它们可能会在生产中吸引反模式。然而，基于有限`Observable`订阅的生命周期来保持应用程序存活是一个有效的情况来使用阻塞操作符。如图所示，`blockingSubscribe()`可以用作`subscribe()`的替代，在允许主线程继续进行并退出应用程序之前停止并等待`onComplete()`被调用：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will discuss blocking operators in further detail in [Chapter 10](ec80132f-c411-4cc1-87b2-7a8ebba089b8.xhtml),
    *Testing and Debugging*. For the remainder of this chapter, we will explore concurrency
    in detail using the `subscribeOn()` and `observeOn()` operators. But first, we
    will cover the different `Scheduler` types available in RxJava.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第10章[ec80132f-c411-4cc1-87b2-7a8ebba089b8.xhtml]，*测试和调试*中更详细地讨论阻塞操作符。在本章的剩余部分，我们将使用`subscribeOn()`和`observeOn()`操作符详细探讨并发。但首先，我们将介绍RxJava中可用的不同`Scheduler`类型。
- en: Understanding Schedulers
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解调度器
- en: As discussed earlier, thread pools are a collection of threads. Depending on
    the policy of that thread pool, threads may be persisted and maintained so they
    can be reused. A queue of tasks is then executed by that thread pool.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，线程池是一组线程。根据线程池的策略，线程可能会被持久化和维护，以便可以重用。然后，该线程池会执行任务队列中的任务。
- en: Some thread pools hold a fixed number of threads (such as the  `computation()`
    one we used earlier), while others dynamically create and destroy threads as needed.
    Typically in Java, you use an `ExecutorService` as your thread pool. However,
    RxJava implements its own concurrency abstraction called `Scheduler`.  It define
    methods and rules that an actual concurrency provider such as an `ExecutorService`
    or actor system must obey. The construct flexibly makes RxJava non-opinionated
    on the source of concurrency.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一些线程池保持固定数量的线程（例如我们之前使用的`computation()`），而其他线程池则会根据需要动态创建和销毁线程。在Java中，通常使用`ExecutorService`作为线程池。然而，RxJava实现了自己的并发抽象，称为`Scheduler`。它定义了实际并发提供者（如`ExecutorService`或actor系统）必须遵守的方法和规则。这种结构使RxJava在并发源上没有特定的观点。
- en: Many of the default `Scheduler` implementations can be found in the `Schedulers`
    static factory class. For a given `Observer`, a `Scheduler` will provide a thread
    from its pool that will push the emissions. When `onComplete()` is called, the
    operation will be disposed of and the thread will be given back to the pool, where
    it may be persisted and reused by another `Observer`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 许多默认的`Scheduler`实现可以在`Schedulers`静态工厂类中找到。对于给定的`Observer`，`Scheduler`将提供一个线程池中的线程来推送事件。当调用`onComplete()`时，操作将被处置，并将线程返回到池中，它可能被另一个`Observer`持久化和重用。
- en: 'To keep this book practical, we will only look at Schedulers in their natural
    environment: being used with `subscribeOn()` and `observeOn()`. If you want to
    learn more about Schedulers and how they work in isolation, refer to Appendix
    X to learn more.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使本书实用，我们只会在其自然环境中查看调度器：与`subscribeOn()`和`observeOn()`一起使用。如果你想了解更多关于调度器及其独立工作方式的信息，请参阅附录X以获取更多信息。
- en: Here are a few Scheduler types in RxJava. There are also some common third-party
    ones available in other libraries such as RxAndroid (covered in [Chapter 11](4d8d0f1a-6015-4c42-82db-cb7f966e9f7c.xhtml), *RxJava
    for Android*) and RxJavaFX (covered later in this chapter).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxJava中，这里有几种调度器类型。在其他库中，如RxAndroid（在第11章中介绍，*RxJava for Android*）和RxJavaFX（本章后面介绍）也有一些常见的第三方调度器可用。
- en: Computation
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算
- en: 'We already saw the computation `Scheduler`, which you can get the global instance
    of by calling `Schedulers.computation()`. This will maintain a fixed number of
    threads based on the processor count available to your Java session, making it
    appropriate for computational tasks. Computational tasks (such as math, algorithms,
    and complex logic) may utilize cores to their fullest extent. Therefore, there
    is no benefit in having more worker threads than available cores to perform such
    work, and the computational `Scheduler` will ensure that:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了计算型`Scheduler`，你可以通过调用`Schedulers.computation()`来获取其全局实例。这将根据Java会话中可用的处理器数量维护固定数量的线程，这使得它适用于计算任务。计算任务（如数学、算法和复杂逻辑）可能充分利用核心。因此，拥有比可用核心更多的工作线程来执行此类工作没有好处，计算型`Scheduler`将确保：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When you are unsure how many tasks will be executed concurrently or are simply
    unsure which `Scheduler` is the right one to use, prefer the computation one by
    default.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不确定将同时执行多少任务，或者只是不确定哪个`Scheduler`是正确的选择时，默认选择计算型调度器。
- en: A number of operators and factories will use the computation `Scheduler` by
    default unless you specify a different one as an argument. These include one or
    more overloads for `interval()`, `delay()`, `timer()`, `timeout()`, `buffer()`,
    `take()`, `skip()`, `takeWhile()`, `skipWhile()`, `window()`, and a few others.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 许多操作符和工厂默认会使用计算`Scheduler`，除非您指定不同的一个作为参数。这包括`interval()`、`delay()`、`timer()`、`timeout()`、`buffer()`、`take()`、`skip()`、`takeWhile()`、`skipWhile()`、`window()`等几个其他操作符的重载。
- en: IO
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IO
- en: 'IO tasks such as reading and writing databases, web requests, and disk storage
    are less expensive on the CPU and often have idle time waiting for the data to
    be sent or come back. This means you can create threads more liberally, and `Schedulers.io()`
    is appropriate for this. It will maintain as many threads as there are tasks and
    will dynamically grow, cache, and reduce the number of threads as needed. For
    instance, you may use `Schedulers.io()` to perform SQL operations using RxJava-JDBC
    ([https://github.com/davidmoten/rxjava-jdbc](https://github.com/davidmoten/rxjava-jdbc)):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: IO任务，如读取和写入数据库、网络请求和磁盘存储，在CPU上的开销较小，并且通常有等待数据发送或返回的空闲时间。这意味着您可以更自由地创建线程，而`Schedulers.io()`是适合这种情况的。它将维护与任务数量相等的线程，并根据需要动态增长、缓存和减少线程数量。例如，您可以使用`Schedulers.io()`来执行使用RxJava-JDBC的SQL操作（[https://github.com/davidmoten/rxjava-jdbc](https://github.com/davidmoten/rxjava-jdbc)）：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: But you have to be careful! As a rule of thumb, assume that each subscription
    will result in a new thread.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 但您必须小心！作为一个经验法则，假设每个订阅都会导致一个新的线程。
- en: New thread
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: New thread
- en: 'The `Schedulers.newThread()` factory will return a `Scheduler` that does not
    pool threads at all. It will create a new thread for each `Observer` and then
    destroy the thread when it is done. This is different than `Schedulers.io()` because
    it does not attempt to persist and cache threads for reuse:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Schedulers.newThread()`工厂将返回一个完全不池化线程的`Scheduler`。它将为每个`Observer`创建一个新线程，并在完成后销毁该线程。这与`Schedulers.io()`不同，因为它不会尝试持久化和缓存线程以供重用：'
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This may be helpful in cases where you want to create, use, and then destroy
    a thread immediately so it does not take up memory. But for complex applications
    generally, you will want to use `Schedulers.io()` so there is some attempt to
    reuse threads if possible.  You also have to be careful as  `Schedulers.newThread()`
    can run amok in complex applications (as can `Schedulers.io()`) and create a high
    volume of threads, which could crash your application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有助于在您想要立即创建、使用然后销毁线程以避免占用内存的情况下。但对于通常的复杂应用程序，您将希望使用`Schedulers.io()`，以便尽可能重用线程。您还必须小心，因为`Schedulers.newThread()`在复杂应用程序中可能会失控（就像`Schedulers.io()`一样）并创建大量线程，这可能导致您的应用程序崩溃。
- en: Single
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Single
- en: 'When you want to run tasks sequentially on a single thread, you can invoke
    `Schedulers.single()`. This is backed by a single-threaded implementation appropriate
    for event looping. It can also be helpful to isolate fragile, non-threadsafe operations
    to a single thread:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想在单个线程上顺序运行任务时，可以调用`Schedulers.single()`。它由适合事件循环的单线程实现支持。它还可以帮助将脆弱的、非线程安全的操作隔离到单个线程：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Trampoline
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Trampoline
- en: '`Schedulers.trampoline()` is an interesting `Scheduler`. In practicality, you
    will not invoke it often as it is used primarily in RxJava''s internal implementation.
    Its pattern is also borrowed for UI Schedulers such as RxJavaFX and RxAndroid.
    It is just like default scheduling on the immediate thread, but it prevents cases
    of recursive scheduling where a task schedules a task while on the same thread.
    Instead of causing a stack overflow error, it will allow the current task to finish
    and *then* execute that new scheduled task afterward.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Schedulers.trampoline()`是一个有趣的`Scheduler`。实际上，您不太可能经常调用它，因为它主要用于RxJava的内部实现。它的模式也被借用于UI调度器，如RxJavaFX和RxAndroid。它就像在立即线程上的默认调度，但它防止了递归调度的情形，即一个任务在同一个线程上调度另一个任务。而不是导致堆栈溢出错误，它将允许当前任务完成，*然后*执行那个新调度的任务。'
- en: ExecutorService
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ExecutorService
- en: 'You can build a Scheduler off a standard Java `ExecutorService`. You may choose
    to do this in order to have more custom and fine-tuned control over your thread
    management policies. For example, say, we want to create a Scheduler that uses
    20 threads. We can create a new fixed `ExecutorService` specified with this number
    of threads. Then, you can wrap it inside a `Scheduler` implementation by calling
    `Schedulers.from()`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从标准的 Java `ExecutorService` 构建一个调度器。您可能选择这样做是为了对线程管理策略有更多自定义和精细的控制。例如，假设我们想要创建一个使用
    20 个线程的调度器。我们可以创建一个新的固定 `ExecutorService`，并指定这个数量的线程。然后，您可以通过调用 `Schedulers.from()`
    方法将这个 `ExecutorService` 包装在一个 `Scheduler` 实现中：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`ExecutorService` will likely keep your program alive indefinitely, so you
    have to manage its disposal if its life is supposed to be finite. If I only wanted
    to support the life cycle of one `Observable` subscription, I need to call its
    `shutdown()` method. That is why I called its `shutdown()` method after the operation
    terminates or disposes via the `doFinally()` operator.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecutorService` 可能会无限期地保持您的程序运行，因此如果您希望其生命周期有限，您必须管理其销毁。如果我只想要支持一个 `Observable`
    订阅的生命周期，我需要调用它的 `shutdown()` 方法。这就是为什么我在操作通过 `doFinally()` 操作符终止或销毁后调用其 `shutdown()`
    方法的原因。'
- en: Starting and shutting down Schedulers
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动和关闭调度器
- en: Each default `Scheduler` is lazily instantiated when you first invoke its usage.
    You can dispose the `computation()`, `io()`, `newThread()`, `single()`, and `trampoline()`
    Schedulers at any time by calling their `shutdown()` method or all of them by
    calling `Schedulers.shutdown()`. This will stop all their threads and forbid new
    tasks from coming in and will throw an error if you try otherwise. You can also
    call their `start()` method, or `Schedulersers.start()`, to reinitialize the Schedulers
    so they can accept tasks again.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每个默认的 `Scheduler` 都是在您第一次调用其使用时懒加载实例化的。您可以通过调用它们的 `shutdown()` 方法来在任何时候销毁 `computation()`、`io()`、`newThread()`、`single()`
    和 `trampoline()` 调度器，或者通过调用 `Schedulers.shutdown()` 来销毁所有调度器。这将停止所有线程，并禁止新的任务进入，如果您尝试其他方式，将会抛出错误。您也可以调用它们的
    `start()` 方法，或者 `Schedulersers.start()`，以重新初始化调度器，以便它们可以再次接受任务。
- en: In desktop and mobile app environments, you should not run into many cases where
    you have to start and stop the Schedulers. On the server side, however, J2EE-based
    applications (for example, Servlets) may get unloaded and reloaded and use a different
    classloader, causing the old Schedulers instances to leak. To prevent this from
    occurring, the Servlet should shut down the `Schedulers` manually in its `destroy()`
    method.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在桌面和移动应用环境中，您不太可能遇到需要启动和停止调度器的情况。然而，在服务器端，基于 J2EE 的应用程序（例如，Servlets）可能会被卸载和重新加载，并使用不同的类加载器，导致旧的调度器实例泄漏。为了防止这种情况发生，Servlet
    应该在其 `destroy()` 方法中手动关闭 `Schedulers`。
- en: Only manage the life cycle of your Schedulers if you absolutely have to. It
    is better to let the Schedulers dynamically manage their usage of resources and
    keep them initialized and available so tasks can quickly be executed at a moment's
    notice. Note carefully that it is better to ensure that all outstanding tasks
    are completed or disposed of before you shut down the Schedulers, or else you
    may leave the sequences in an inconsistent state.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在绝对需要的情况下才管理调度器的生命周期。最好让调度器动态管理它们对资源的使用，并保持它们初始化和可用，以便任务可以在任何时候快速执行。请注意，在关闭调度器之前，最好确保所有未完成的任务都已完成或销毁，否则您可能会留下不一致的状态。
- en: Understanding subscribeOn()
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 `subscribeOn()`
- en: We kind of touched on using `subscribeOn()` already, but in this section, we
    will explore it in more detail and look at how it works.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经稍微提到了使用 `subscribeOn()`，但在这个部分，我们将更详细地探讨它，并查看它是如何工作的。
- en: The `subscribeOn()` operator will suggest to the source `Observable` upstream
    which `Scheduler` to use and how to execute operations on one of its threads.
    If that source is not already tied to a particular `Scheduler`, it will use the `Scheduler`
    you specify. It will then push emissions *all the way* to the final `Observer`
    using that thread (unless you add `observeOn()` calls, which we will cover later).
    You can put `subscribeOn()` anywhere in the `Observable` chain, and it will suggest
    to the upstream all the way to the origin `Observable` which thread to execute
    emissions with.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribeOn()` 操作符会建议上游的 `Observable` 使用哪个 `Scheduler` 以及如何在它的某个线程上执行操作。如果那个上游
    `Observable` 没有绑定到特定的 `Scheduler`，它将使用您指定的 `Scheduler`。然后，它将使用该线程将发射事件一直推送到最终的
    `Observer`（除非您添加了 `observeOn()` 调用，我们将在后面介绍）。您可以在 `Observable` 链中的任何位置放置 `subscribeOn()`，并且它将建议上游一直到达原始
    `Observable` 使用哪个线程来执行发射。'
- en: 'In the following example, it makes no difference whether you put this `subscribeOn()`
    right after `Observable.just()` or after one of the operators. The `subscribeOn()`
    will communicate upstream to the `Observable.just()` which `Scheduler` to use
    no matter where you put it. For clarity, though, you should place it as close
    to the source as possible:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，你将`subscribeOn()`放在`Observable.just()`之后还是放在一个操作符之后，这并没有区别。`subscribeOn()`将向上游通信到`Observable.just()`，无论你将其放在哪里，它都将使用哪个`Scheduler`。为了清晰起见，你应该尽可能将其放置在源附近：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Having multiple Observers to the same `Observable` with `subscribeOn()` will
    result in each one getting its own thread (or have them waiting for an available
    thread if none are available). In the `Observer`, you can print the executing
    thread''s name by calling `Thread.currentThread().getName()`. We will print that
    with each emission to see that two threads, in fact, are being used for both Observers:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个`Observer`来订阅同一个`Observable`并调用`subscribeOn()`会导致每个`Observer`都获得自己的线程（如果没有可用线程，它们将等待可用线程）。在`Observer`中，你可以通过调用`Thread.currentThread().getName()`来打印执行线程的名称。我们将通过每次发射来打印这个名称，以证明实际上使用了两个线程来处理这两个`Observer`：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note how one `Observer` is using a thread named `RxComputationThreadPool-2`,
    while the other is using `RxComputationThreadPool-1`. These names indicate which
    `Scheduler` they came from (which is the `Computation` one) and what their index
    is. As shown here, if we want only one thread to serve both Observers, we can
    multicast this operation. Just make sure `subscribeOn()` is before the multicast
    operators:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一个`Observer`正在使用名为`RxComputationThreadPool-2`的线程，而另一个正在使用`RxComputationThreadPool-1`。这些名称表明它们来自哪个`Scheduler`（即`Computation`类型的`Scheduler`）以及它们的索引。正如这里所示，如果我们只想让一个线程为两个`Observer`服务，我们可以使用多播操作。只需确保`subscribeOn()`在多播操作之前：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Most `Observable` factories, such as `Observable.fromIterable()` and `Observable.just()`,
    will emit items on the `Scheduler` specified by `subscribeOn()`. For factories
    such as `Observable.fromCallable()` and `Observable.defer()`, the initialization
    of these sources will also run on the specified `Scheduler` when using `subscribeOn()`.
    For instance, if you use `Observable.fromCallable()` to wait on a URL response,
    you can actually do that work on the IO Scheduler so the main thread is not blocking
    and waiting for it:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数`Observable`工厂，如`Observable.fromIterable()`和`Observable.just()`，都会在由`subscribeOn()`指定的`Scheduler`上发射项目。对于`Observable.fromCallable()`和`Observable.defer()`等工厂，当使用`subscribeOn()`时，这些源初始化也会在指定的`Scheduler`上运行。例如，如果你使用`Observable.fromCallable()`等待URL响应，你实际上可以在IO
    Scheduler上执行这项工作，这样主线程就不会阻塞并等待它：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Nuances of subscribeOn()
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`subscribeOn()`的细微差别'
- en: 'It is important to note that  `subscribeOn()` will have no practical effect
    with certain sources (and will keep a worker thread unnecessarily on standby until
    that operation terminates). This might be because these Observables already use
    a specific `Scheduler`, and if you want to change it, you can provide a `Scheduler`
    as an argument. For example, `Observable.interval()` will use `Schedulers.computation()` and
    will ignore any `subscribeOn()`you specify otherwise. But you can provide a third
    argument to specify a different `Scheduler` to use. Here, I specify `Observable.interval()`
    to use `Schedulers.newThread()`, as shown here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`subscribeOn()`在某些源上不会有实际效果（并且会不必要地让工作线程保持待机状态，直到该操作终止）。这可能是因为这些`Observable`已经使用了特定的`Scheduler`，如果你想要更改它，你可以提供一个`Scheduler`作为参数。例如，`Observable.interval()`将使用`Schedulers.computation()`并忽略你指定的任何其他`subscribeOn()`。但你可以提供一个第三个参数来指定要使用不同的`Scheduler`。在这里，我指定`Observable.interval()`使用`Schedulers.newThread()`，如下所示：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This also brings up another point: if you have multiple `subscribeOn()` calls
    on a given `Observable` chain, the top-most one, or the one closest to the source,
    will win and cause any subsequent ones to have no practical effect (other than
    unnecessary resource usage). If I call `subscribeOn()` with `Schedulers.computation()` and
    then call `subscribeOn()` for  `Schedulers.io()`, `Schedulers.computation()` is
    the one that will be used:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这也引出了另一个问题：如果你在给定的`Observable`链上有多个`subscribeOn()`调用，最上面的一个，或者最接近源的一个，将获胜，并导致后续的调用没有实际效果（除了不必要的资源使用）。如果我使用`Schedulers.computation()`调用`subscribeOn()`，然后调用`subscribeOn()`为`Schedulers.io()`，那么将使用`Schedulers.computation()`：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This can happen when an API returns an `Observable` already preapplied with
    a `Scheduler` via `subscribeOn()`, although the consumer of the API wants a different
    `Scheduler`. API designers are, therefore, encouraged to provide methods or overloads
    that allow parameterizing which `Scheduler` to use, just like RxJava's Scheduler-dependent
    operators (for example,  `Observable.interval()`).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能发生在API返回一个已经通过`subscribeOn()`预先应用了`Scheduler`的`Observable`时，尽管API的消费者想要一个不同的`Scheduler`。因此，API的设计者被鼓励提供允许参数化使用哪个`Scheduler`的方法或重载，就像RxJava的基于`Scheduler`的操作符（例如，`Observable.interval()`）一样。
- en: In summary, `subscribeOn()` specifies which `Scheduler` the source `Observable`
    should use, and it will use a worker from this `Scheduler` to push emissions all
    the way to the final `Observer`. Next, we will learn about `observeOn()`, which
    switches to a different `Scheduler` at that point in the `Observable` chain.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`subscribeOn()`指定了源`Observable`应该使用的`Scheduler`，并且它将使用该`Scheduler`的worker将事件推送到最终的`Observer`。接下来，我们将学习`observeOn()`，它在`Observable`链的该点切换到不同的`Scheduler`。
- en: Understanding observeOn()
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解`observeOn()`
- en: The `subscribeOn()` operator instructs the source `Observable` which `Scheduler`
    to emit emissions on. If `subscribeOn()` is the only concurrent operation in an
    `Observable` chain,  the thread from that `Scheduler` will work the entire `Observable`
    chain, pushing emissions from the source all the way to the final `Observer`.
    The `observeOn()` operator, however, will intercept emissions at that point in
    the `Observable` chain and switch them to a different `Scheduler` going forward.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribeOn()`操作符指示源`Observable`在哪个`Scheduler`上发出事件。如果`subscribeOn()`是`Observable`链中唯一的并发操作，那么来自该`Scheduler`的线程将处理整个`Observable`链，将来自源的事件推送到最终的`Observer`。然而，`observeOn()`操作符将在`Observable`链的该点拦截事件，并将它们切换到不同的`Scheduler`。'
- en: 'Unlike `subscribeOn()`, the placement of `observeOn()` matters. It will leave
    all operations upstream on the default or `subscribeOn()`-defined `Scheduler`, but
    will switch to a different `Scheduler` downstream. Here, I can have an `Observable`
    emit a series of strings that are `/`-separated values and break them up on an
    IO `Scheduler`. But after that, I can switch to a computation `Scheduler` to filter
    only numbers and calculate their sum, as shown in the following code snippet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与`subscribeOn()`不同，`observeOn()`的位置很重要。它将保留上游的所有操作在默认或`subscribeOn()`定义的`Scheduler`上，但将切换到下游的不同`Scheduler`。在这里，我可以让一个`Observable`发出一系列由`/`分隔的字符串，并在IO
    `Scheduler`上拆分它们。但是之后，我可以切换到计算`Scheduler`来过滤出数字并计算它们的总和，如下面的代码片段所示：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Of course, this example is not computationally intensive, and in real life,
    it should be done on a single thread. The overhead of concurrency that we introduced
    is not warranted, but let's pretend it is a long-running process.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个例子计算量不大，在现实生活中，它应该在单个线程上完成。我们引入的并发开销是不必要的，但让我们假装它是一个长时间运行的过程。
- en: Again, use `observeOn()` to intercept each emission and push them forward on
    a different `Scheduler`.  In the preceding example, operators before `observeOn()`
    are executed on  `Scheduler.io()`, but the ones after it are executed by `Schedulers.computation()`.
    Upstream operators before `observeOn()` are not impacted, but downstream ones
    are.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`observeOn()`来拦截每个事件并将它们推送到不同的`Scheduler`。在前面的例子中，`observeOn()`之前的操作符在`Scheduler.io()`上执行，但之后的操作符由`Schedulers.computation()`执行。`observeOn()`之前的上游操作符不受影响，但下游操作符受影响。
- en: You might use  `observeOn()` for a situation like the one emulated earlier.
    If you want to read one or more data sources and wait for the response to come
    back, you will want to do that part on `Schedulers.io()` and will likely leverage
    `subscribeOn()` since that is the initial operation. But once you have that data,
    you may want to do intensive computations with it, and `Scheduler.io()` may no
    longer be appropriate. You will want to constrain these operations to a few threads
    that will fully utilize the CPU. Therefore, you use `observeOn()` to redirect
    data to  `Schedulers.computation()`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在类似之前模拟的情况中使用`observeOn()`。如果你想读取一个或多个数据源并等待响应返回，你将想要在`Schedulers.io()`上执行这部分操作，并且可能会利用`subscribeOn()`，因为那是初始操作。但是一旦你有了这些数据，你可能想要用它们进行密集的计算，而`Scheduler.io()`可能不再合适。你将想要将这些操作限制在几个线程上，这些线程将充分利用CPU。因此，你使用`observeOn()`将数据重定向到`Schedulers.computation()`。
- en: 'You can actually use multiple `observeOn()` operators to switch `Schedulers`
    more than once. Continuing with our earlier example, let''s say we want to write
    our computed sum to a disk and write it in a file. Let''s pretend this was a lot
    of data rather than a single number and we want to get this disk-writing operation
    off the computation `Scheduler` and put it back in the IO `Scheduler`. We can
    achieve this by introducing a second `observeOn()`. Let''s also add some `doOnNext() `
    and `doOnSuccess()` (due to the `Maybe`) operators to peek at which thread each
    operation is using:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以使用多个 `observeOn()` 操作符来切换 `Schedulers` 多次。继续我们之前的例子，假设我们想要将计算出的总和写入磁盘并写入一个文件。让我们假装这是一大批数据而不是一个单独的数字，并且我们想要将磁盘写入操作从计算
    `Scheduler` 上移除并放回 IO `Scheduler`。我们可以通过引入第二个 `observeOn()` 来实现这一点。让我们还添加一些 `doOnNext()`
    和 `doOnSuccess()`（由于 `Maybe`）操作符来查看每个操作使用的线程：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you look closely at the output, you will see that the `String` emissions
    were initially pushed and split on the IO `Scheduler` via the thread `RxCachedThreadScheduler-1`.
    After that, each emission was switched to the computation `Scheduler` and pushed
    into a sum calculation, which was all done on the thread `RxComputationThreadPool-1`.
    That sum was then switched to the IO `scheduler` to be written to a text file
    (which I specified to output on my Linux Mint desktop), and that work was done
    on `RxCachedThreadScheduler-1` (which happened to be the thread that pushed the
    initial emissions and was reused!).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看输出，你会看到 `String` 的输出最初是通过线程 `RxCachedThreadScheduler-1` 在 IO `Scheduler`
    上推送和分割的。之后，每个输出都被切换到计算 `Scheduler` 并推入一个求和计算中，所有这些都是在线程 `RxComputationThreadPool-1`
    上完成的。然后这个总和被切换到 IO `scheduler` 以写入一个文本文件（我指定在我的 Linux Mint 桌面上输出），这项工作是在 `RxCachedThreadScheduler-1`
    上完成的（碰巧是推送初始输出的线程，并且被重用了！）。
- en: Using observeOn() for UI event threads
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 observeOn() 为 UI 事件线程
- en: When it comes to building mobile apps, desktop applications, and other user
    experiences, users have little patience for interfaces that hang up or freeze
    while work is being done. The visual updating of user interfaces is often done
    by a single dedicated UI thread, and changes to the user interface must be done
    on that thread. User input events are typically fired on the UI thread as well.
    If a user input triggers work, and that work is not moved to another thread, that
    UI thread will become busy. This is what makes the user interface unresponsive,
    and today's users expect better than this. They want to still interact with the
    application while work is happening in the background, so concurrency is a must-have.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到构建移动应用、桌面应用程序和其他用户体验时，用户对于在操作进行时界面挂起或冻结的界面几乎没有耐心。用户界面的视觉更新通常由一个专门的 UI 线程完成，并且对用户界面的更改必须在那个线程上完成。用户输入事件通常也在
    UI 线程上触发。如果用户输入触发了工作，并且这项工作没有被移动到另一个线程，那么这个 UI 线程就会变得繁忙。这就是导致用户界面无响应的原因，而今天的用户期望的要比这个更好。他们希望在后台操作进行时仍然能够与应用程序交互，因此并发性是必不可少的。
- en: Thankfully, RxJava can come to the rescue! You can use `observeOn()` to move
    UI events to a computation or IO `Scheduler` to do the work, and when the result
    is ready, move it back to the UI thread with another `observeOn()`. This second
    usage of `observeOn()` will put emissions on a UI thread using a custom `Scheduler`
    that wraps around the UI thread. RxJava extension libraries such as RxAndroid
    ([https://github.com/ReactiveX/RxAndroid](https://github.com/ReactiveX/RxAndroid)),
    RxJavaFX ([https://github.com/ReactiveX/RxJavaFX](https://github.com/ReactiveX/RxJavaFX)),
    and RxSwing ([https://github.com/ReactiveX/RxSwing](https://github.com/ReactiveX/RxSwing))
    come with these custom `Scheduler` implementations.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，RxJava 可以提供帮助！你可以使用 `observeOn()` 将 UI 事件移动到计算或 IO `Scheduler` 来执行工作，当结果准备好后，再使用另一个
    `observeOn()` 将其移回 UI 线程。这个 `observeOn()` 的第二次使用将使用一个围绕 UI 线程的自定义 `Scheduler`
    将输出放在 UI 线程上。RxJava 扩展库，如 RxAndroid ([https://github.com/ReactiveX/RxAndroid](https://github.com/ReactiveX/RxAndroid))、RxJavaFX
    ([https://github.com/ReactiveX/RxJavaFX](https://github.com/ReactiveX/RxJavaFX))
    和 RxSwing ([https://github.com/ReactiveX/RxSwing](https://github.com/ReactiveX/RxSwing))，都包含这些自定义
    `Scheduler` 实现。
- en: 'For instance, say we have a simple JavaFX application that displays a `ListView<String>`
    of the 50 U.S. states every time a button is clicked on. We can create `Observable<ActionEvent>`
    off the button and then switch to an IO `Scheduler` with `observeOn()` ( `subscribeOn()`
    will have no effect against UI event sources). We can load the 50 states from
    a text web response while on the IO `Scheduler`. Once the states are returned,
    we can use another `observeOn()` to put them back on `JavaFxScheduler`, and safely
    populate them into `ListView<String>` on the JavaFX UI thread:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个简单的 JavaFX 应用程序，每次点击按钮都会显示一个包含 50 个美国州的 `ListView<String>`。我们可以从按钮创建
    `Observable<ActionEvent>` 并使用 `observeOn()` 切换到 IO `Scheduler`（`subscribeOn()`
    对 UI 事件源没有影响）。我们可以在 IO `Scheduler` 上从文本网络响应中加载 50 个州。一旦返回了州，我们可以使用另一个 `observeOn()`
    将它们放回 `JavaFxScheduler`，并在 JavaFX UI 线程上安全地将它们填充到 `ListView<String>` 中：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The code should run the JavaFX application shown as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码应运行如下所示的 JavaFX 应用程序：
- en: '![](img/cb3da1d9-e11e-47e3-a35a-86be88253a82.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/cb3da1d9-e11e-47e3-a35a-86be88253a82.png)'
- en: The preceding screenshot demonstrates that hitting the REFRESH button will emit
    an event but switch it to an IO `Scheduler` where the work is done to retrieve
    the U.S. states. When the response is ready, it will emit a `List<String>` and
    put it back on the JavaFX `Scheduler` to be displayed in a `ListView`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示，点击 REFRESH 按钮将发出一个事件，但将其切换到执行检索美国州数据的 IO `Scheduler`。当响应准备好后，它将发出一个 `List<String>`
    并将其放回 JavaFX `Scheduler` 以在 `ListView` 中显示。
- en: These concepts apply to Android development as well, and you put all operations
    affecting the app user interface on `AndroidSchedulers.mainThread()` rather than `JavaFxScheduler.platform()`.
    We will cover Android development in [Chapter 11](4d8d0f1a-6015-4c42-82db-cb7f966e9f7c.xhtml),
    *RxJava for Android*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念也适用于 Android 开发，你将影响应用程序用户界面的所有操作放在 `AndroidSchedulers.mainThread()` 而不是
    `JavaFxScheduler.platform()` 上。我们将在第 11 章 [RxJava for Android](4d8d0f1a-6015-4c42-82db-cb7f966e9f7c.xhtml)
    中讨论 Android 开发。
- en: Nuances of observeOn()
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: observeOn() 的细微差别
- en: '`observeOn()`comes with nuances to be aware of, especially when it comes to
    performance implications due to lack of backpressure, which we will cover in [Chapter
    8](14efb9e9-14a6-41ba-86cb-20b5674dce8e.xhtml), *Flowables and Backpressure*.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`observeOn()` 有一些需要注意的细微差别，尤其是在缺乏背压的情况下对性能的影响，我们将在第 8 章 [Flowables and Backpressure](14efb9e9-14a6-41ba-86cb-20b5674dce8e.xhtml)
    中进行讨论。'
- en: Say, you have an `Observable` chain with two sets of operations, Operation A
    and Operation B. Let's not worry what operators each one is using. If you do not
    have any `observeOn()`between them, the operation will pass emissions strictly
    one at a time from the source to Operation A, then Operation B, and finally to
    the `Observer`. Even with a `subscribeOn()`, the source will not pass the next
    emission down the chain until the current one is passed all the way to the `Observer`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含两套操作的 `Observable` 链，操作 A 和操作 B。我们暂时不考虑每个操作使用的算子是什么。如果你在这两个操作之间没有 `observeOn()`，操作将严格按照一个接一个的顺序从源传递到操作
    A，然后是操作 B，最后是 `Observer`。即使有 `subscribeOn()`，源也不会在当前事件传递到 `Observer` 之前向下传递下一个事件。
- en: This changes when you introduce an `observeOn()` and say we put it between Operation
    A and Operation B. What happens is after Operation A hands an emission to the
    `observeOn(),` it will immediately start the next emission and not wait for the
    downstream to finish the current one, including Operation B and the `Observer`.
    This means that the source and Operation A can *produce* emissions faster than
    Operation B and the `Observer` can *consume* them. This is a classic producer/consumer
    scenario where the producer is producing emissions faster than the consumer can
    consume them. If this is the case, unprocessed emissions will be queued in `observeOn()`
    until the downstream is able to process them. But if you have a lot of emissions,
    you can potentially run into memory issues.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当你引入一个 `observeOn()` 并将其置于操作 A 和操作 B 之间时，情况会有所不同。发生的情况是，在操作 A 将一个发射事件传递给 `observeOn()`
    之后，它会立即开始下一个发射事件，而不是等待下游完成当前事件，包括操作 B 和 `Observer`。这意味着源和操作 A 可以比操作 B 和 `Observer`
    更快地产生发射事件。这是一个经典的生产者/消费者场景，其中生产者产生的发射事件速度超过了消费者可以消费的速度。如果出现这种情况，未处理的事件将在 `observeOn()`
    中排队，直到下游能够处理它们。但是，如果你有大量的事件，你可能会遇到内存问题。
- en: This is why when you have a flow of 10,000 emissions or more, you will definitely
    want to use a `Flowable` (which supports backpressure) instead of an `Observable`.
    Backpressure communicates upstream all the way to the source to slow down and
    only produce so many emissions at a time. It restores *pull-based* requesting
    of emissions even when complex concurrency operations are introduced. We will
    cover this in [Chapter 8](14efb9e9-14a6-41ba-86cb-20b5674dce8e.xhtml), *Flowables
    and Backpressure*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么当你有10,000次或更多次的发射流时，你肯定会想使用`Flowable`（它支持背压）而不是`Observable`。背压会向上游通信，直到源处，以减慢速度并一次只产生这么多的发射。即使在引入复杂的并发操作时，它也能恢复基于拉取的发射请求。我们将在[第8章](14efb9e9-14a6-41ba-86cb-20b5674dce8e.xhtml)中介绍这一点，*Flowables和Backpressure*。
- en: Parallelization
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行化
- en: Parallelization, also called **parallelism** or **parallel computing**, is a
    broad term that can be used for any concurrent activity (including what we covered).
    But for the purposes of RxJava, let's define it as processing multiple emissions
    at a time for a given `Observable`. If we have 1000 emissions to process in a
    given `Observable` chain, we might be able to get work done faster if we process
    eight emissions at a time instead of one. If you recall, the `Observable` contract
    dictates that emissions must be pushed *serially* down an `Observable` chain and
    never race each other due to concurrency. As a matter of fact, pushing eight emissions
    down an `Observable` chain at a time would be downright catastrophic and wreak
    havoc.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 并行化，也称为**并行性**或**并行计算**，是一个广泛的概念，可以用于任何并发活动（包括我们讨论的内容）。但就RxJava而言，让我们将其定义为对给定`Observable`同时处理多个发射。如果我们有一个给定`Observable`链中的1000个发射要处理，如果我们一次处理八个发射而不是一个，我们可能能够更快地完成任务。如果你还记得，`Observable`契约规定发射必须按*序列*推送到`Observable`链中，并且由于并发性永远不会相互竞争。事实上，一次将八个发射推送到`Observable`链中将是灾难性的，并造成混乱。
- en: This seems to put us at odds with what we want to accomplish, but thankfully,
    RxJava gives you enough operators and tools to be clever. While you cannot push
    items concurrently on the same `Observable`, you are allowed to have multiple
    Observables running at once, each having its own single thread pushing items through.
    As we have done throughout this chapter, we created several Observables running
    on different threads/schedulers and *even combined them*. You actually have the
    tools already, and the secret to achieving parallelization is in the `flatMap()`
    operator, which is, in fact, a powerful concurrency operator.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎与我们想要达成的目标相矛盾，但幸运的是，RxJava为你提供了足够的操作符和工具来变得聪明。虽然你不能在同一个`Observable`上并发推送项目，但你允许同时运行多个`Observable`，每个`Observable`都有自己的单独线程推送项目。正如我们在本章中一直所做的那样，我们创建了几个在不同的线程/调度器上运行的`Observable`，并且甚至将它们组合在一起。实际上，你已经有了这些工具，实现并行化的秘密在于`flatMap()`操作符，它实际上是一个强大的并发操作符。
- en: 'Here, we have an `Observable` emitting 10 integers, and we are performing `intenseCalculation()` on
    each one. This process can take a while due to the artificial processing we emulated
    with `sleep()`. Let''s print each one with the time in the `Observer` so we can
    measure the performance, as shown in the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个`Observable`发出10个整数，并且我们对每个整数执行`intenseCalculation()`操作。这个过程可能需要一段时间，因为我们是通过`sleep()`函数模拟的人工处理。让我们在`Observer`中打印每个整数及其时间，以便我们可以测量性能，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is as follows(yours will be different):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下（你的输出可能会有所不同）：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The randomness causes some variability, of course, but in this instance, it
    took roughly 17 seconds to complete (although your time will likely vary). We
    will probably get better performance if we process emissions in parallel, so how
    do we do that?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 随机性当然会导致一些可变性，但在这个例子中，它大约花费了17秒来完成（尽管你的时间可能会不同）。如果我们并行处理发射，我们可能会得到更好的性能，那么我们如何做到这一点呢？
- en: 'Remember, serialization (emitting items one at a time) only needs to happen
    on the same `Observable`. The `flatMap()` operator will merge multiple Observables
    derived off each emission even if they are *concurrent*. If a light bulb has not
    gone off yet, read on. In `flatMap()`, let''s wrap each emission into `Observable.just()`,
    use `subscribeOn()` to emit it on  `Schedulers.computation()`, and then `map` it
    to the `intenseCalculation()`. For good measure, let''s print the current thread
    in the `Observer` as well, as shown in the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，序列化（逐个发射项目）只需要在同一个`Observable`上发生。`flatMap()`操作符会合并从每个发射中派生出的多个`Observable`，即使它们是*并发*的。如果一个灯泡还没有亮起来，请继续阅读。在`flatMap()`中，让我们将每个发射包装成`Observable.just()`，使用`subscribeOn()`在`Schedulers.computation()`上发射它，然后`map`它到`intenseCalculation()`。为了保险起见，让我们在`Observer`中打印当前线程，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output is as follows (yours will be different):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下（你的输出可能会有所不同）：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This took three seconds to complete, and you will find that this processes items
    much faster.  Of course, my computer has eight cores and that is why my output
    likely indicates that there are eight threads in use. If you have a computer with
    less cores, this process will take longer and use fewer threads. But it will likely
    still be faster than the single-threaded implementation we ran earlier.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程花费了三秒钟完成，你会发现这个处理项目要快得多。当然，我的电脑有八个核心，这就是为什么我的输出可能表明有八个线程在使用。如果你的电脑核心数更少，这个过程将花费更长的时间并使用更少的线程。但它可能仍然比我们之前运行的单一线程实现要快。
- en: What we did is we created a `Observable` off each emission, used `subscribeOn()`
    to emit it on the computation `Scheduler`, and then performed the `intenseCalculation()`,
    which will occur on one of the computation threads. Each instance will request
    its own thread from the computation `Scheduler`, and `flatMap()` will merge all
    of them safely back into a serialized stream.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是为每个发射创建一个`Observable`，使用`subscribeOn()`在计算`Scheduler`上发射它，然后执行`intenseCalculation()`，这将发生在计算线程之一上。每个实例将从计算`Scheduler`请求自己的线程，`flatMap()`将安全地将它们合并回一个序列化的流。
- en: The `flatMap()`will only let one thread out of it at a time to push emissions
    downstream, which maintains that the `Observable` contract demanding emissions
    stays serialized. A neat little behavior with `flatMap()` is that it will not
    use excessive synchronization or blocking to accomplish this. If a thread is already
    pushing an emission out of `flatMap()` downstream toward `Observer`, any threads
    also waiting to push emissions will simply leave their emissions for that occupying
    thread to take ownership of.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap()`一次只会让一个线程出来推送发射，这保持了`Observable`合同要求发射保持序列化的特性。`flatMap()`的一个巧妙的行为是，它不会使用过多的同步或阻塞来完成这个任务。如果一个线程已经在将发射从`flatMap()`推送到`Observer`下游，任何等待推送发射的线程将简单地让它们的发射由那个正在使用的线程接管。'
- en: The example here is not necessarily optimal, however. Creating an `Observable`
    for each emission might create some unwanted overhead. There is a leaner way to
    achieve parallelization, although it has a few more moving parts. If we want to
    avoid creating excessive `Observable` instances, maybe we should split the source
    `Observable` into a fixed number of Observables where emissions are evenly divided
    and distributed through each one. Then, we can parallelize and merge them with
    `flatMap()`. Even better, since I have eight cores on my computer, maybe it would
    be ideal that I have eight Observables for eight streams of calculations.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供的例子不一定是最优的。为每个发射创建一个`Observable`可能会产生一些不必要的开销。虽然这样做会有更多的组件需要操作，但有一种更简洁的方法来实现并行化。如果我们想避免创建过多的`Observable`实例，也许我们应该将源`Observable`分割成固定数量的`Observable`，使得发射均匀地分配并分布到每一个中。然后，我们可以使用`flatMap()`来并行化并合并它们。甚至更好，既然我的电脑有八个核心，也许拥有八个`Observable`来处理八个计算流会是理想的。
- en: We can achieve this using a `groupBy()` trick. If I have eight cores, I want
    to key each emission to a number in the range 0 through 7\. This will yield me
    eight `GroupedObservables` that cleanly divide the emissions into eight streams.
    More specifically,  I want to cycle through these eight numbers and assign them
    as a key to each emission. `GroupedObservables` are not necessarily impacted by
    `subscribeOn()` (it will emit on the source's thread with the exception of the
    cached emissions), so I will need to use `observeOn()` to parallelize them instead.
    I can also use an `io()` or `newThread()` scheduler since I have already constrained
    the number of workers to the number of cores, simply by constraining the number
    of `GroupedObservables`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `groupBy()` 技巧来实现这一点。如果我拥有八个核心，我想将每个发射与 0 到 7 范围内的一个数字相关联。这将产生八个 `GroupedObservables`，将发射干净地分成八个流。更具体地说，我想循环这八个数字，并将它们作为键分配给每个发射。`GroupedObservables`
    不一定会受到 `subscribeOn()` 的影响（它将在源线程上发射，除了缓存的发射之外），所以我需要使用 `observeOn()` 来并行化它们。我还可以使用
    `io()` 或 `newThread()` 调度程序，因为我已经通过限制 `GroupedObservables` 的数量来限制了工作者的数量。
- en: 'Here is how I do this, but instead of hardcoding for eight cores, I dynamically
    query the number of cores available:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我如何做这件事的，但我不是硬编码为八个核心，而是动态查询可用的核心数量：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here is the output (yours will be different):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出结果（你的输出将不同）：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: For each emission, I will need to increment the number it groups on, and after
    it reaches `7`, it will start over at `0`. This ensures that the emissions are
    distributed as evenly as possible. We achieve this using `AtomicInteger` with
    a modulus operation. If we keep incrementing `AtomicInteger` for each emission,
    we can divide that result by the numbers of cores, but return the remainder, which
    will always be a number between `0` and `7`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个发射，我需要增加它所分组的数字，当它达到 `7` 时，它将从 `0` 重新开始。这确保了发射尽可能均匀地分布。我们使用 `AtomicInteger`
    和模运算来实现这一点。如果我们为每个发射递增 `AtomicInteger`，我们可以将结果除以核心的数量，但返回余数，这始终是一个介于 `0` 和 `7`
    之间的数字。
- en: '`AtomicInteger` is just an integer protected inside a `threadsafe` container
    and has convenient `threadsafe` methods, such as `incrementAndGet()`. Typically,
    when you have an object or state existing outside an `Observable` chain but is
    modified by the `Observable` chain''s operations (this is known as creating side
    effects), that object should be made `threadsafe`, especially when concurrency
    is involved. You can learn more about `AtomicInteger` and other utilities in Brian
    Goetz''s *Java Concurrency in Practice*.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`AtomicInteger` 只是一个被保护在 `threadsafe` 容器内的整数，并且有方便的 `threadsafe` 方法，例如 `incrementAndGet()`。通常，当你有一个对象或状态存在于
    `Observable` 链之外，但被 `Observable` 链的操作修改（这被称为副作用），那么这个对象应该被做成 `threadsafe`，尤其是在涉及并发的情况下。你可以在
    Brian Goetz 的 *Java Concurrency in Practice* 中了解更多关于 `AtomicInteger` 和其他实用工具的信息。'
- en: You do not have to use the processor count to control how many `GroupedObservables`
    are created. You can specify any number if you, for some reason, deem that more
    workers would result in better performance. If your concurrent operations are
    a mix between IO and computation, and you find that there is more IO, you might
    benefit from increasing the number of threads/`GroupedObservables` allowed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必使用处理器数量来控制创建多少个 `GroupedObservables`。如果你认为更多的工作者会带来更好的性能，你可以指定任何数量。如果你的并发操作是
    IO 和计算的混合，并且你发现 IO 更多，你可能从增加允许的线程/`GroupedObservables` 的数量中受益。
- en: unsubscribeOn()
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`unsubscribeOn()`'
- en: One last concurrency operator that we need to cover is  `unsubscribeOn()`. When
    you dispose an `Observable`, sometimes, that can be an expensive operation depending
    on the nature of the source. For instance, if your `Observable` is emitting the
    results of a database query using RxJava-JDBC, ([https://github.com/davidmoten/rxjava-jdbc](https://github.com/davidmoten/rxjava-jdbc))
    it can be expensive to stop and dispose that `Observable` because it needs to
    shut down the JDBC resources it is using.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要讨论的最后一种并发操作符是 `unsubscribeOn()`。当你销毁一个 `Observable` 时，这有时可能是一个昂贵的操作，这取决于源的性质。例如，如果你的
    `Observable` 正在使用 RxJava-JDBC 发射数据库查询的结果（[https://github.com/davidmoten/rxjava-jdbc](https://github.com/davidmoten/rxjava-jdbc)），停止和销毁这个
    `Observable` 可能很昂贵，因为它需要关闭它所使用的 JDBC 资源。
- en: This can cause the thread that calls `dispose()` to become busy, as it will
    be doing all the work stopping an `Observable` subscription and disposing it.
    If this is a UI thread in JavaFX or Android (for instance, because a CANCEL PROCESSING button
    was clicked), this can cause undesirable UI freezing because the UI thread is
    working to stop and dispose the `Observable` operation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致调用 `dispose()` 的线程变得繁忙，因为它将执行所有停止 `Observable` 订阅和销毁的操作。如果这是一个 JavaFX
    或 Android 中的 UI 线程（例如，因为点击了 CANCEL PROCESSING 按钮），这可能会导致不希望的 UI 冻结，因为 UI 线程正在努力停止和销毁
    `Observable` 操作。
- en: 'Here is a simple `Observable` that is emitting every one second. We stop the
    main thread for three seconds, and then it will call `dispose()` to shut the operation
    down. Let''s use `doOnDispose()` (which will be executed by the disposing thread)
    to see that the main thread is indeed disposing of the operation:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的每秒发射一次的 `Observable`。我们暂停主线程三秒钟，然后它会调用 `dispose()` 来关闭操作。让我们使用 `doOnDispose()`（将由销毁线程执行）来查看主线程确实正在销毁操作：
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s add `unsubscribeOn()` and specify to unsubscribe on `Schedulers.io()`.
    You should put `unsubscribeOn()` wherever you want all operations upstream to
    be affected:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加 `unsubscribeOn()` 并指定在 `Schedulers.io()` 上取消订阅。你应该在你想让所有上游操作受到影响的地方放置
    `unsubscribeOn()`：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now you will see that disposal is being done by the IO `Scheduler`, whose thread
    is identified by the name `RxCachedThreadScheduler-1`.  This allows the main thread
    to kick off disposal and continue without waiting for it to complete.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你会看到销毁是由 IO `Scheduler` 执行的，其线程由名称 `RxCachedThreadScheduler-1` 标识。这允许主线程启动销毁并继续，而无需等待其完成。
- en: Like any concurrency operators, you really should not need to use `unsubscribeOn()`
    for lightweight operations such as this example, as it adds unnecessary overhead.
    But if you have `Observable` operations that are heavy with resources which are
    slow to dispose of, `unsubscribeOn()` can be a crucial tool if threads calling
    `dispose()` are sensitive to high workloads.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何并发操作符一样，你实际上不需要为像这个例子这样的轻量级操作使用 `unsubscribeOn()`，因为它会增加不必要的开销。但是，如果你有资源密集型的
    `Observable` 操作，销毁这些资源又很慢，`unsubscribeOn()` 可以是一个关键工具，如果调用 `dispose()` 的线程对高负载敏感。
- en: You can use multiple `unsubscribeOn()` calls if you want to target specific
    parts of the `Observable` chain to be disposed of with different Schedulers. Everything
    upstream to an `unsubscribeOn()` will be disposed of with that `Scheduler` until
    another `unsubscribeOn()` is encountered, which will own the next upstream segment.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想针对 `Observable` 链中的特定部分使用不同的调度器来销毁，你可以使用多个 `unsubscribeOn()` 调用。直到遇到另一个
    `unsubscribeOn()`，上游的所有内容都将使用那个 `Scheduler` 销毁。该 `unsubscribeOn()` 将拥有下一个上游段。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was probably our most intense chapter yet, but it provides a turning point
    in your proficiency as an RxJava developer as well as a master of concurrency!
    We covered the different Schedulers available in RxJava as well as ones available
    in other libraries such as RxJavaFX and RxAndroid. The `subscribeOn()` operator
    is used to suggest to the upstream in an `Observable` chain which `Scheduler`
    to push emissions on.  The `observeOn()`will switch emissions to a different `Scheduler`
    *at that point* in the `Observable` chain and use that `Scheduler` downstream.
    You can use these two operators in conjunction with `flatMap()` to create powerful
    parallelization patterns so you can fully utilize your multi-CPU power. We finally
    covered `unsubscribeOn()`, which helps us specify a different `Scheduler` to dispose
    operations on, preventing subtle hang-ups on threads we want to keep free and
    available even if they call the `dispose()` method.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是我们迄今为止最紧张的一章，但它为你在 RxJava 开发者以及并发大师的专业技能提供了一个转折点！我们涵盖了 RxJava 中可用的不同调度器，以及
    RxJavaFX 和 RxAndroid 等其他库中可用的调度器。`subscribeOn()` 操作符用于向上游的 `Observable` 链建议推送发射的
    `Scheduler`。`observeOn()` 将在 `Observable` 链的该点切换发射到不同的 `Scheduler` 并在下游使用该 `Scheduler`。你可以结合使用这两个操作符和
    `flatMap()` 来创建强大的并行化模式，以便充分利用你的多 CPU 能力。我们最后涵盖了 `unsubscribeOn()`，它帮助我们指定用于销毁操作的不同的
    `Scheduler`，防止在想要保持空闲和可用的线程上出现微妙的挂起，即使它们调用了 `dispose()` 方法。
- en: It is important to note that when you start playing with concurrency, you need
    to become wary of how much data you are juggling between threads now. A lot of
    data can queue up in your `Observable` chain, and some threads will produce work
    faster than other threads can consume them. When you are dealing with 10,000+
    elements, you will want to use Flowables to prevent memory issues, and we will
    cover this in [Chapter 8](14efb9e9-14a6-41ba-86cb-20b5674dce8e.xhtml), *Flowables
    and Backpressure*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，当你开始尝试并发编程时，你需要警惕你现在在线程之间处理的数据量。大量的数据可能会在你的`Observable`链中排队，有些线程可能会比其他线程更快地产生工作，而其他线程则可能无法及时消费这些工作。当你处理10,000+个元素时，你将希望使用Flowables来防止内存问题，我们将在[第8章](14efb9e9-14a6-41ba-86cb-20b5674dce8e.xhtml)，“Flowables和背压”中介绍这一点。
- en: The next chapter will look into this topic of dealing with Observables that
    produce emissions too quickly, and there are some operators that can help with
    this without backpressure. We will hit that next.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨处理产生排放过快的可观测对象这一主题，并且有一些算子可以在不产生背压的情况下帮助解决这个问题。我们将在下一章中触及这一点。
