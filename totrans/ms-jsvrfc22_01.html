<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Dynamic Access to JSF Application Data through Expression Language (EL 3.0)"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Dynamic Access to JSF Application Data through Expression Language (EL 3.0)</h1></div></div></div><p>Java <span class="strong"><strong>Expression Language</strong></span> (<span class="strong"><strong>EL</strong></span>) is a compact and powerful mechanism that enables dynamic communication in JSP and JSF-based applications (including development frameworks based on JSF such as PrimeFaces, ICEfaces, and RichFaces); we embed expressions in the presentation layer to communicate with the application logic layer.<a id="id0" class="indexterm"/> EL provides bidirectional communication, which means that we can expose application logic data to the user, but we also can submit user data to be processes. Generically speaking, EL can be used to populate HTTP requests with user data, to extract and expose data from HTTP responses, to update HTML DOM, to conditionally process data, and much more.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>Commonly, EL expressions will be present in JSP and JSF pages, but they can also appear outside, in <code class="literal">faces-config.xml</code>, for example.</p></div></div><p>In this chapter, you will see how to use EL in web pages to communicate with managed beans, which is the most common case in JSF applications. We will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">EL syntax, operators, and reserved words</li><li class="listitem" style="list-style-type: disc">EL immediate and deferred evaluation</li><li class="listitem" style="list-style-type: disc">EL value and method expressions</li><li class="listitem" style="list-style-type: disc">The conditional text in JSF</li><li class="listitem" style="list-style-type: disc">Write a custom EL resolver</li></ul></div><div class="section" title="EL syntax"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>EL syntax</h1></div></div></div><p>In this section, you can see an overview of the main aspects of EL 2.2 and 3.0 syntax. EL supports a handful<a id="id1" class="indexterm"/> of operators and reserved words. Each of these are quickly described in the following section (more details are in the EL specification document (<a class="ulink" href="http://download.oracle.com/otndocs/jcp/el-3_0-fr-eval-spec/index.html">http://download.oracle.com/otndocs/jcp/el-3_0-fr-eval-spec/index.html</a>)).</p><div class="section" title="EL operators"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>EL operators</h2></div></div></div><p>EL supports the following<a id="id2" class="indexterm"/> categories of operators—arithmetic, relational, logical,<a id="id3" class="indexterm"/> conditional, empty and added starting with EL 3.0, string concatenation, assignment and semicolon operators:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Textuals</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th><th style="text-align: left" valign="bottom">
<p>Symbols</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>A <code class="literal">+</code> B</p>
</td><td style="text-align: left" valign="top">
<p>Addition</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">+</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>A <code class="literal">-</code> B</p>
</td><td style="text-align: left" valign="top">
<p>Subtraction</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">-</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>A <code class="literal">*</code> B</p>
</td><td style="text-align: left" valign="top">
<p>Multiplication</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">*</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>A {<code class="literal">div</code>, <code class="literal">/</code>} B</p>
</td><td style="text-align: left" valign="top">
<p>Arithmetic operator division</p>
</td><td style="text-align: left" valign="top">
<p>/, <code class="literal">div</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>A {<code class="literal">mod</code>, <code class="literal">%</code>} B</p>
</td><td style="text-align: left" valign="top">
<p>Arithmetic operator modulo</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">%</code>, <code class="literal">mod</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>A {<code class="literal">and</code>, <code class="literal">&amp;&amp;</code>} B</p>
</td><td style="text-align: left" valign="top">
<p>Logical AND</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&amp;&amp;</code>, <code class="literal">and</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>A {<code class="literal">or</code>, <code class="literal">||</code>} B</p>
</td><td style="text-align: left" valign="top">
<p>Logical OR</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">||</code>, <code class="literal">or</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>{<code class="literal">not</code>, <code class="literal">!</code>} A</p>
</td><td style="text-align: left" valign="top">
<p>Logical opposite</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">!</code>, <code class="literal">not</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>A {<code class="literal">lt</code>, <code class="literal">&lt;</code>} B</p>
</td><td style="text-align: left" valign="top">
<p>Relational less than</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&lt;</code>, <code class="literal">lt</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>A {<code class="literal">gt</code>, <code class="literal">&gt;</code>} <code class="literal">B</code></p>
</td><td style="text-align: left" valign="top">
<p>Relational greater than</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt;</code>, <code class="literal">gt</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>A {<code class="literal">le</code>, <code class="literal">&lt;=</code>} B</p>
</td><td style="text-align: left" valign="top">
<p>Relational less than or equal to</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&lt;=</code>, <code class="literal">le</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>A {<code class="literal">ge</code>, <code class="literal">&gt;=</code>} B</p>
</td><td style="text-align: left" valign="top">
<p>Relational greater than or equal to</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt;=</code>, <code class="literal">ge</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>A {<code class="literal">eq</code>, <code class="literal">==</code>} B</p>
</td><td style="text-align: left" valign="top">
<p>Equal to</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">==</code>, <code class="literal">eq</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>A {<code class="literal">ne</code>, <code class="literal">!=</code>} B</p>
</td><td style="text-align: left" valign="top">
<p>Not equal to</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">!=</code>, <code class="literal">ne</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>A<code class="literal"> = </code>B</p>
</td><td style="text-align: left" valign="top">
<p>Assignment (EL 3.0)</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">=</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>A <code class="literal">; </code>B</p>
</td><td style="text-align: left" valign="top">
<p>Semicolon (EL 3.0)</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">;</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>A<code class="literal"> += </code>B</p>
</td><td style="text-align: left" valign="top">
<p>String concatenation (EL 3.0)</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">+=</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>A <code class="literal">-&gt;</code> B</p>
</td><td style="text-align: left" valign="top">
<p>Lambda expression (EL 3.0)</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">-&gt;</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">empty</code> A</p>
</td><td style="text-align: left" valign="top">
<p>Determine whether a value is null or empty</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>A<code class="literal"> ? </code>B<code class="literal"> : </code>C</p>
</td><td style="text-align: left" valign="top">
<p>Evaluates B or<a id="id4" class="indexterm"/> C, depending on the result of the<a id="id5" class="indexterm"/> evaluation of A. Known as the<a id="id6" class="indexterm"/> <span class="strong"><strong>ternary operator</strong></span>.</p>
</td><td style="text-align: left" valign="top">
<p>?:</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>Used when <a id="id7" class="indexterm"/>writing EL expressions</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">.</code></p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>Used when writing EL expressions</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">[]</code></p>
</td></tr></tbody></table></div></div><div class="section" title="EL precedence of operators"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>EL precedence of operators</h2></div></div></div><p>Conforming to EL specification,<a id="id8" class="indexterm"/> the precedence of operators from<a id="id9" class="indexterm"/> the highest to lowest, left to right is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">[].</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">()</code> (used to change the precedence of operators)</li><li class="listitem" style="list-style-type: disc"><code class="literal">-</code> (unary) <code class="literal">not ! empty</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">* / div % mod</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">+</code> <code class="literal">-</code> (binary)</li><li class="listitem" style="list-style-type: disc"><code class="literal">+=</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt; &gt; &lt;= &gt;= lt gt le ge</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">== != eq ne</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">&amp;&amp; and</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">|| or</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">?</code> <code class="literal">:</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">-&gt;</code> (lambda expression)</li><li class="listitem" style="list-style-type: disc"><code class="literal">=</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">;</code></li></ul></div></div><div class="section" title="EL reserved words"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>EL reserved words</h2></div></div></div><p>EL defines the<a id="id10" class="indexterm"/> following<a id="id11" class="indexterm"/> reserved words:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">and</code>, <code class="literal">or</code>, <code class="literal">not</code>, <code class="literal">eq</code>, <code class="literal">ne</code>, <code class="literal">lt</code>, <code class="literal">gt</code>, <code class="literal">le</code>, <code class="literal">ge</code>, <code class="literal">true</code> (Boolean literal), <code class="literal">false</code> (Boolean literal), <code class="literal">null</code>, <code class="literal">instanceof</code> (a Java keyword to do a class comparison between objects), <code class="literal">empty</code>, <code class="literal">div</code>, and <code class="literal">mod</code></li></ul></div></div></div></div>
<div class="section" title="EL immediate and deferred evaluation"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>EL immediate and deferred evaluation</h1></div></div></div><p>EL evaluates expressions as <span class="strong"><strong>immediate</strong></span> or <span class="strong"><strong>deferred</strong></span>.</p><p>Immediate evaluation<a id="id12" class="indexterm"/> returns the result as soon as the page is first rendered. These<a id="id13" class="indexterm"/> kinds of expressions are read-only value expressions and they can be present only in tags that accept runtime expressions. They are easy to recognize after the <code class="literal">${}</code> notation. Usually, they are used for arithmetic and logical operations in JSP pages.</p><p>Deferred evaluation<a id="id14" class="indexterm"/> can return the result at different phases of a page's life cycle depending<a id="id15" class="indexterm"/> on the technology that is using the expression. JSF can evaluate the expression at different phases of the life cycle (for example, during the rendering and postback phase), depending on how the expression is being used in the page. These kind of expressions can be value and method expressions, and they are marked by the <code class="literal">#{}</code> notation.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>In Facelets, <code class="literal">${}</code> and <code class="literal">#{}</code> act the same.</p></div></div></div>
<div class="section" title="EL value expressions"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>EL value expressions</h1></div></div></div><p><span class="strong"><strong>Value expressions</strong></span> are probably used the most, and they refer to objects and their properties and attributes. Such expressions are dynamically used to evaluate results or set bean properties at runtime. <a id="id16" class="indexterm"/>Through value expressions, you can easily access JavaBeans components, collections, and Java SE enumerated types. Moreover, EL provides a set of implicit objects that can be used to get attributes from different scopes and parameter values. Furthermore, you will see how EL deals with each of these objects.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>Value expressions that can read data, but cannot write it are known as <span class="strong"><strong>rvalue</strong></span><a id="id17" class="indexterm"/> (<code class="literal">${}</code> expressions are always rvalue), while those that can read and write data are known as <span class="strong"><strong>lvalue</strong></span><a id="id18" class="indexterm"/> (<code class="literal">#{}</code> expressions can be rvalue and/or lvalue).</p></div></div><div class="section" title="Referencing a managed bean"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Referencing a managed bean</h2></div></div></div><p>Referencing a managed bean<a id="id19" class="indexterm"/> is not exactly a useful example, <a id="id20" class="indexterm"/>but it is a good point to start. Most commonly, your managed bean will look like the following code (in this case, the bean's class name is <code class="literal">PlayersBean</code>):</p><div class="informalexample"><pre class="programlisting">@ManagedBean
//some scope
public class PlayersBean{
...
}</pre></div><p>Or, in the CDI version, your managed bean will be as follows:</p><div class="informalexample"><pre class="programlisting">@Named
//some scope
public class PlayersBean{
...
}</pre></div><p>Or, with an explicit name, your managed bean will be as follows:</p><div class="informalexample"><pre class="programlisting">@ManagedBean(name = "myPlayersBean")
//some scope
public class PlayersBean{
...
}

@Named(value = "myPlayersBean")
//some scope
public class PlayersBean{
...
}</pre></div><p>Now, for the first two examples, EL refers to the <code class="literal">PlayersBean</code> managed bean, like this—the name is obtained from taking the unqualified class name portion of the fully qualified class name and converting the first character to lowercase as follows:</p><div class="informalexample"><pre class="programlisting">#{playersBean}</pre></div><p>In addition, for the next two examples, EL uses the explicit name as follows:</p><div class="informalexample"><pre class="programlisting">#{myPlayersBean}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>You should use CDI beans whenever possible since they are more flexible than JSF managed beans, and because annotations from <code class="literal">javax.faces.bean</code> will be deprecated in a future JSF version. Therefore, the CDI ones are recommended.</p></div></div><p>When the referenced managed bean<a id="id21" class="indexterm"/> cannot be found in<a id="id22" class="indexterm"/> any scope, a <code class="literal">null</code> value will be returned.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p><span class="strong"><strong>Downloading the example code</strong></span></p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div><div class="section" title="Referencing a managed bean's properties"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Referencing a managed bean's properties</h2></div></div></div><p>As is commonly known, managed beans usually contain private fields, which are accessible through getter and setter methods<a id="id23" class="indexterm"/> as bean properties, <a id="id24" class="indexterm"/>and some public methods that exploits these properties to serve different logic tasks.</p><p>EL expressions that can access<a id="id25" class="indexterm"/> these properties contain the dot or square brackets notation, <code class="literal">[]</code>. For example, let's suppose that the <code class="literal">PlayersBean</code> managed bean contains two fields defined like the following lines:</p><div class="informalexample"><pre class="programlisting">private String playerName = "Rafael";
private String playerSurname = "Nadal";</pre></div><p>EL can access these fields through their getter methods; therefore, you need to define them as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public String getPlayerName() {
  return playerName;
}
public String getPlayerSurname() {
  return playerSurname;
}</pre></div><p>Now, an expression that accesses the <code class="literal">playerName</code> property can use the dot notation (<code class="literal">.</code>) to refer it, as shown in the following line of code:</p><div class="informalexample"><pre class="programlisting">#{playersBean.playerName}</pre></div><p>Alternatively, this expression can use the square brackets notation, <code class="literal">[]</code>, as shown in the following line of code:</p><div class="informalexample"><pre class="programlisting">#{playersBean['playerName']}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>JSF evaluates this expression from left to right. First, it searches for <code class="literal">playersBean</code> in all available scopes (such as request, session, and application). Then, the bean is instantiated and the <code class="literal">getPlayerName</code>/<code class="literal">getPlayerSurname</code> getter methods are called (in the case of Boolean properties, the getter method will be named as <code class="literal">is</code><span class="emphasis"><em>XXX</em></span>).When you are using the <code class="literal">[]</code> notation, you can use simple or double quotes. Just remember to alternate them correctly in cases like the following quotations.</p></div></div><p>An incorrect quotation <a id="id26" class="indexterm"/>(you cannot use double quotes inside double quotes) is:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputText value="#{playersBean["playerName"]}"/&gt;</pre></div><p>An incorrect <a id="id27" class="indexterm"/>quotation (you cannot use simple quotes inside simple quotes) is:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputText value='#{playersBean['playerName']}'/&gt;</pre></div><p>A correct <a id="id28" class="indexterm"/>quotation (you can use simple quotes in double quotes) is:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputText value="#{playersBean['playerName']}"/&gt;</pre></div><p>A correct quotation (you can use double quotes in simple quotes) is:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputText value='#{playersBean["playerName"]}'/&gt;</pre></div></div><div class="section" title="Referencing a managed bean's nested properties"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Referencing a managed bean's nested properties</h2></div></div></div><p>Usually, managed beans<a id="id29" class="indexterm"/> use nested properties. <a id="id30" class="indexterm"/>Such properties can<a id="id31" class="indexterm"/> be accessed by EL using the <code class="literal">.</code> and <code class="literal">[]</code> notations multiple times in the same expression.</p><p>For example, the <code class="literal">PlayersBean</code> managed bean may represent general data about tennis players, such as name, surname, titles, and finals. More detailed information, such as birthday, birthplace, height, and weight can be represented through a different class named <code class="literal">PlayersDetails</code>. Now, the <code class="literal">PlayersBean</code> managed bean contains a field of type <code class="literal">PlayersDetails</code>, which means that birthday, birthplace, and so on become nested properties of <code class="literal">PlayersBean</code>. Speaking in code lines, the relevant part of the <code class="literal">PlayersDetails</code> class<a id="id32" class="indexterm"/> is as follows:</p><div class="informalexample"><pre class="programlisting">public class PlayerDetails {

  private Date birthday;
  private String birthplace;
  ...

  public Date getBirthday() {
    return birthday;
  }

  public String getBirthplace() {
    return birthplace;
  }
  ...
}</pre></div><p>The<a id="id33" class="indexterm"/> managed bean of the <code class="literal">PlayersBean</code> class<a id="id34" class="indexterm"/> is as follows:</p><div class="informalexample"><pre class="programlisting">@Named
public class PlayersBean{

  private String playerName = "Rafael";
  private String playerSurname = "Nadal";
  private PlayerDetails playerDetails;

  public String getPlayerName() {
    return playerName;
  }

  public String getPlayerSurname() {
    return playerSurname;
  }

  public PlayerDetails getPlayerDetails() {
    return playerDetails;
  }
  ...
}</pre></div><p>You already know how to call the <code class="literal">playerName</code> and <code class="literal">playerSurname</code> properties using the <code class="literal">.</code> and <code class="literal">[]</code> notations.<a id="id35" class="indexterm"/> Next, you can<a id="id36" class="indexterm"/> use the same notations to<a id="id37" class="indexterm"/> access the <code class="literal">birthday</code> and <code class="literal">birthplace</code> nested properties, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">#{playersBean.playerDetails.birthday}
#{playersBean.playerDetails.birthplace}

#{playersBean['playerDetails']['birthday']}
#{playersBean['playerDetails']['birthplace']}</pre></div><p>Or, you can use both notations in the same expressions, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">#{playersBean.playerDetails['birthday']}
#{playersBean.playerDetails['birthplace']}

#{playersBean['playerDetails'].birthday}
#{playersBean['playerDetails'].birthplace}</pre></div><p>Of course, the <code class="literal">PlayerDetails</code> class can contain its own nested properties and so. In this case, just use the <code class="literal">.</code> and <code class="literal">[]</code> notations to<a id="id38" class="indexterm"/> get deeper in the hierarchy of objects until you reach the desired property.</p><p>In the preceding expressions, JSF search for <code class="literal">playersBean</code> in all the available scopes (request, session, application, and so on) and <a id="id39" class="indexterm"/>obtain an instance of it.<a id="id40" class="indexterm"/> Afterwards, it calls the <code class="literal">getPlayerDetails</code> method and the <code class="literal">getBirthday</code> method on result of the <code class="literal">getPlayerDetails</code> method (and the same for the <code class="literal">birthplace</code> property).</p></div><div class="section" title="Referencing Java SE enumerated types"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Referencing Java SE enumerated types</h2></div></div></div><p>EL can access Java SE enumerated types<a id="id41" class="indexterm"/> using a <code class="literal">String</code> literal. For example, let's have an enumerated type defined in <code class="literal">PlayersBean</code>, as shown<a id="id42" class="indexterm"/> in the following code:</p><div class="informalexample"><pre class="programlisting">public enum Plays {
  Left, Right
};

private Plays play;
...
play = Plays.Left;//initialization can be done in constructor
...
public Plays getPlay() {
  return play;
}
...</pre></div><p>You can easily output the <code class="literal">play</code> value as shown in the following line of code:</p><div class="informalexample"><pre class="programlisting">#{playersBean.play}</pre></div><p>To refer to the <code class="literal">Plays</code> constant, <code class="literal">Plays.Left</code>, with an expression, use the <code class="literal">String</code> literal <code class="literal">Left</code> (or <code class="literal">Right</code> for <code class="literal">Plays.Right</code>), for example, you can test whether <code class="literal">play</code> is <code class="literal">Left</code> or <code class="literal">Right</code>, as shown in the <a id="id43" class="indexterm"/>following code:</p><div class="informalexample"><pre class="programlisting">#{playersBean.play == 'Left'} //return true
#{playersBean.play == 'Right'}//return false</pre></div></div><div class="section" title="Referencing collections"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Referencing collections</h2></div></div></div><p><span class="strong"><strong>Collection</strong></span> items (arrays, lists, maps, sets, and so on) can be accessed from EL expressions by <a id="id44" class="indexterm"/>specifying a literal value<a id="id45" class="indexterm"/> that can be converted to an integer or the <code class="literal">[]</code> notation with an integer and without quotes.</p><p>For example, let's suppose that the <code class="literal">PlayersBean</code> managed bean contains an array named <code class="literal">titles_2013</code> that keeps the titles won by a player in 2013. The array is defined as shown in the following code:</p><div class="informalexample"><pre class="programlisting">private String[] titles_2013 = {"Sao Paulo", "Acapulco", "ATP World Tour Masters 1000 Indian Wells", "Barcelona", ...};
...
public String[] getTitles_2013() {
  return titles_2013;
}   </pre></div><p>Now, you can access the first title from the array by specifying its position in array, which is <code class="literal">0</code>:</p><div class="informalexample"><pre class="programlisting">#{playersBean.titles_2013[0]}</pre></div><p>This is equivalent in Java to getting or setting the value for <code class="literal">titles_2013[0]</code>.</p><p>However, sometimes you need to iterate over the array instead of accessing a specific item. This can be easily accomplished with the <code class="literal">c:forEach</code> JSTL tag (<a class="ulink" href="http://www.oracle.com/technetwork/java/index-jsp-135995.html">http://www.oracle.com/technetwork/java/index-jsp-135995.html</a>). The following code snippet iterates over the <code class="literal">titles_2013</code> array and outputs each item (this is a pretty uncommon usage, so do not try it in production):</p><div class="informalexample"><pre class="programlisting">&lt;c:forEach begin="0" 
  end="${fn:length(playersBean.titles_2013)-1}" 
  var="i"&gt;
  #{playersBean.titles_2013[i]},
&lt;/c:forEach&gt;</pre></div><p>You can simplify it as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;c:forEach var="title" items="#{playersBean.titles_2013}"&gt;
  &lt;i&gt;#{title}&lt;/i&gt;,
&lt;/c:forEach&gt;</pre></div><p>You can also use the <code class="literal">&lt;ui:repeat&gt;</code> tag as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;ui:repeat var="title" value="#{playersBean.titles_2013}"&gt;
  &lt;i&gt;#{title}&lt;/i&gt;,
&lt;/ui:repeat&gt;</pre></div><p>This tag is detailed in <a class="link" href="ch12.html" title="Chapter 12. Facelets Templating">Chapter 12</a>, <span class="emphasis"><em>Facelets Templating</em></span>, in the <span class="emphasis"><em>Iterating with &lt;ui:repeat&gt;</em></span> section.</p><p>You can use the same approach for every <code class="literal">List</code>. For example, in the case of <code class="literal">List</code>, the expression <code class="literal">#{playersBean.titles_2013[0]}</code> is equivalent in Java to <code class="literal">titles_2013.get(0)</code> and <code class="literal">titles_2013.set(0,</code> <span class="emphasis"><em>some_value</em></span><code class="literal">)</code>.</p><p>In the case of collections of type key-value (for example, <code class="literal">Map</code>), the EL expressions obtain items by key. For example, let's<a id="id46" class="indexterm"/> add a <code class="literal">Map</code> in <code class="literal">PlayersBean</code> that stores some match facts of a player. It can be defined as shown in the following code:</p><div class="informalexample"><pre class="programlisting">private Map&lt;String, String&gt; matchfacts = new HashMap&lt;&gt;();
...
matchfacts.put("Aces", "12");
matchfacts.put("Double Faults", "2");
matchfacts.put("1st Serve", "70%");
...

public Map&lt;String, String&gt; getMatchfacts() {
  return matchfacts;
}</pre></div><p>Now, an EL expression that <a id="id47" class="indexterm"/>accesses the item with the key <code class="literal">Aces</code> can be written like the following line of code:</p><div class="informalexample"><pre class="programlisting">#{playersBean.matchfacts.Aces}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>Notice that this approach is not supported on arrays or lists. For example, <code class="literal">#{playersBean.titles_2013.0}</code> is not correct.</p></div></div><p>When the key is not an acceptable variable name (for example, <code class="literal">Double Faults</code>), you need to use brackets and quotes, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">#{playersBean.matchfacts["Double Faults"]}</pre></div></div><div class="section" title="EL implicit objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>EL implicit objects</h2></div></div></div><p>JSF provides several objects<a id="id48" class="indexterm"/> related to the current request and environment. EL exposes these objects (known as <span class="strong"><strong>implicit objects</strong></span>) that can be accessed at<a id="id49" class="indexterm"/> runtime in a Facelet, servlets, or backing bean—these objects are accessible through value expressions and are managed by the container. For each expression, EL first checks if the value of the base is one of these implicit objects, and, if it is not, then it will check beans in progressively wider scopes<a id="id50" class="indexterm"/> (from request to view, and finally to application scope).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>In EL, the part of the expression before the dot or the square bracket is named <span class="strong"><strong>base</strong></span> and it usually indicates where the bean instances should be located. The part after the first dot, or the square bracket, is called a <span class="strong"><strong>property</strong></span> and is recursively cracked in smaller parts, which represents the bean's properties to get from the base.</p></div></div><p>You can see a short<a id="id51" class="indexterm"/> overview of these objects in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Implicit object EL</p>
</th><th style="text-align: left" valign="bottom">
<p>Type</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">#{application}</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">ServletContext</code> or <code class="literal">PortletContext</code></p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id52" class="indexterm"/> an instance <a id="id53" class="indexterm"/>of <code class="literal">ServletContext</code> or <code class="literal">PortletContext</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">#{facesContext}</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">FacesContext</code></p>
</td><td style="text-align: left" valign="top">
<p>This is <a id="id54" class="indexterm"/>an instance<a id="id55" class="indexterm"/> of <code class="literal">FacesContext</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">#{initParam}</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Map</code></p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id56" class="indexterm"/> the context initialization<a id="id57" class="indexterm"/> parameter map returned by <code class="literal">getInitParameterMap</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">#{session}</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">HttpSession</code> or <code class="literal">PortletSession</code></p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id58" class="indexterm"/> an instance<a id="id59" class="indexterm"/> of <code class="literal">HttpSession</code> or <code class="literal">PortletSession</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">#{view}</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">UIViewRoot</code></p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id60" class="indexterm"/> the <a id="id61" class="indexterm"/>current <code class="literal">UIViewRoot</code> (the root of the <code class="literal">UIComponent</code> tree).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">#{component}</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">UIComponent</code></p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id62" class="indexterm"/> the <a id="id63" class="indexterm"/>current <code class="literal">UIComponent</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">#{cc}</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">UIComponent</code></p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id64" class="indexterm"/> the<a id="id65" class="indexterm"/> composite component currently being processed.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">#{request}</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">ServletRequest</code> or <code class="literal">PortletRequest</code></p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id66" class="indexterm"/> an <a id="id67" class="indexterm"/>instance of <code class="literal">ServletRequest</code> or <code class="literal">PortletRequest</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">#{applicationScope}</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Map</code></p>
</td><td style="text-align: left" valign="top">
<p>This is a map<a id="id68" class="indexterm"/> to store application-scoped<a id="id69" class="indexterm"/> data returned by <code class="literal">getApplicationMap</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">#{sessionScope}</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Map</code></p>
</td><td style="text-align: left" valign="top">
<p>This is a<a id="id70" class="indexterm"/> map<a id="id71" class="indexterm"/> to store session-scoped data returned by <code class="literal">getSessionMap</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">#{viewScope}</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Map</code></p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id72" class="indexterm"/> a map <a id="id73" class="indexterm"/>to store current view scoped data returned by <code class="literal">getViewMap</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">#{requestScope}</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Map</code></p>
</td><td style="text-align: left" valign="top">
<p>This is a<a id="id74" class="indexterm"/> map<a id="id75" class="indexterm"/> to store request-scoped data returned by <code class="literal">getRequestMap</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">#{flowScope}</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Map</code></p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id76" class="indexterm"/> a map to store <a id="id77" class="indexterm"/>flow-scoped <a id="id78" class="indexterm"/>data returned by <code class="literal">facesContext.getApplication().getFlowHandler().getCurrentFlowScope()</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">#{flash}</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Map</code></p>
</td><td style="text-align: left" valign="top">
<p>This is a <a id="id79" class="indexterm"/>map that contains<a id="id80" class="indexterm"/> values present only on the "next" request.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">#{param}</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Map</code></p>
</td><td style="text-align: left" valign="top">
<p>This is a map<a id="id81" class="indexterm"/> view of all<a id="id82" class="indexterm"/> the query parameters for this request. It is returned by <code class="literal">getRequestParameterMap</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">#{paramValues}</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Map</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the request <a id="id83" class="indexterm"/>parameter value<a id="id84" class="indexterm"/> map returned by <code class="literal">getRequestParameterValuesMap</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">#{header}</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Map</code></p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id85" class="indexterm"/> is a map view of all the HTTP headers<a id="id86" class="indexterm"/> for this request returned by <code class="literal">getRequestHeaderMap</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">#{headerValue}</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Map</code></p>
</td><td style="text-align: left" valign="top">
<p>This is the<a id="id87" class="indexterm"/> request header values map<a id="id88" class="indexterm"/> returned by <code class="literal">getRequestHeaderValuesMap</code>. Each value in the<a id="id89" class="indexterm"/> map is an array of strings that contains all the values for that key.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">#{cookie}</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Map</code></p>
</td><td style="text-align: left" valign="top">
<p>This is <a id="id90" class="indexterm"/>a map view of values in the HTTP Set-Cookie<a id="id91" class="indexterm"/> header returned by <code class="literal">getRequestCookieMap</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">#{resource}</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Resource</code></p>
</td><td style="text-align: left" valign="top">
<p>This is <a id="id92" class="indexterm"/>a JSF<a id="id93" class="indexterm"/> resource identifier to a concrete resource URL.</p>
</td></tr></tbody></table></div></div></div>
<div class="section" title="EL method expressions"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>EL method expressions</h1></div></div></div><p>With EL expressions, we can call arbitrary static and public methods that live on the server side in managed beans. Such<a id="id94" class="indexterm"/> expressions are usually present in tag's attributes (that is, inside an <code class="literal">action</code> or <code class="literal">actionListener</code> attribute) and must use the deferred evaluation syntax since a method can be called during different phases of the life cycle. Commonly, methods are called to respond with actions to different kinds of events and for autopages navigation.</p><p>Let's see some examples of calling<a id="id95" class="indexterm"/> bean methods using EL (all methods were defined in the <code class="literal">PlayersBean</code> managed bean):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Calling the <code class="literal">vamosRafa_1</code> void bean method<a id="id96" class="indexterm"/> with no arguments, as shown in the following code:<div class="informalexample"><pre class="programlisting">public void vamosRafa_1(){
  System.out.println("Vamos Rafa!");
}

#{playersBean.vamosRafa_1()}</pre></div></li><li class="listitem" style="list-style-type: disc">Calling the <code class="literal">vamosRafa_2</code> bean method<a id="id97" class="indexterm"/> with no arguments. It returns a string, as shown in the following code:<div class="informalexample"><pre class="programlisting">public String vamosRafa_2() {
  return "Vamos Rafa!";
}

#{playersBean.vamosRafa_2()}</pre></div><p>The returned string, <code class="literal">Vamos Rafa!</code>, can be displayed on the web page or used for other purposes. In other words, the expression will be evaluated to this string.</p></li><li class="listitem" style="list-style-type: disc">Calling the <code class="literal">vamosRafa_3</code> bean method<a id="id98" class="indexterm"/> with one argument. It returns void, as shown in the following code:<div class="informalexample"><pre class="programlisting">public void vamosRafa_3(String text) {
  System.out.println(text);
}

#{playersBean.vamosRafa_3('Vamos Rafa!')}</pre></div><p>Notice that the <code class="literal">String</code> arguments are passed by using quotes.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>The <code class="literal">String</code> constants are passed between simple or double quotes!</p></div></div></li><li class="listitem" style="list-style-type: disc">Calling the <code class="literal">vamosRafa_4</code> bean method<a id="id99" class="indexterm"/> with two arguments. It returns a string, as shown in the following code:<div class="informalexample"><pre class="programlisting">public String vamosRafa_4(String name, String surname) {    
  return "Vamos " + name + " " + surname + "!";
}

#{playersBean.vamosRafa_4(playersBean.playerName, playersBean.playerSurname)}</pre></div><p>The expression will be evaluated to the string, <code class="literal">Vamos Rafael Nadal!</code>.</p></li><li class="listitem" style="list-style-type: disc">Calling the <code class="literal">vamosRafa_5</code> bean method for autonavigation. <a id="id100" class="indexterm"/>First, define the method in the managed bean to return a view (outcome) name (<code class="literal">vamos</code> is the view name for the <code class="literal">vamos.xhtml</code> file), as shown in the following code:<div class="informalexample"><pre class="programlisting">public String vamosRafa_5(){
 return "vamos";
}</pre></div></li></ul></div><p>Furthermore, extract the view name in the <code class="literal">action</code> attribute of any JSF UI component as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt;  
  &lt;h:commandButton action="#{playersBean.vamosRafa_5()}" value="Vamos ..." /&gt;
&lt;/h:form&gt;</pre></div><p>Now, when the button labeled <span class="strong"><strong>Vamos...</strong></span> is clicked, JSF will resolve the view name, <code class="literal">vamos</code>, to the <code class="literal">vamos.xhtml</code> file. Moreover, JSF will look for the <code class="literal">vamos.xhtml</code> file in the current directory and will <a id="id101" class="indexterm"/>navigate to it. Commonly, these navigation methods are used for conditional navigation between JSF pages.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>We have used parentheses to call a method, even when the method doesn't contain arguments. A special case is represented by the methods that contain an <code class="literal">ActionEvent</code> argument. These methods should be called without parentheses, except in the case when you override the <code class="literal">ActionEvent</code> argument altogether by passing and specifying custom argument(s).</p></div></div><p>EL expressions can also be used inside JavaScript function calls. For example, when you want to pass bean properties to a JavaScript function, you need to place them between quotes, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:form&gt;
  &lt;h:commandButton type="button" value="Click Me!" onclick="infoJS('#{playersBean.playerName}', '#{playersBean.playerSurname}')"/&gt;
&lt;/h:form&gt;</pre></div><p>The JavaScript function for this is shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
  function infoJS(name, surname) {
    alert("Name: " + name + " Surname: " + surname);
  }
&lt;/script&gt;</pre></div></div>
<div class="section" title="The conditional text in JSF"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>The conditional text in JSF</h1></div></div></div><p>When you need to output <a id="id102" class="indexterm"/>the conditional text (without the HTML content), you can use the EL ternary operator, which has the following syntax:</p><div class="informalexample"><pre class="programlisting">boolean_test ? result_for_true : result_for_false</pre></div><p>For example, you can use this operator to select between two CSS classes, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">.red { color:#cc0000; } 
.blue { color: #0000cc; }</pre></div><p>Now, you want to conditionally output a red or a blue text, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputText styleClass="#{playersBean.play == 'Left' ? 'red': 'blue'}" value="#{playersBean.play}"/&gt;</pre></div><p>So, if the value of <code class="literal">play</code> is <code class="literal">Left</code>, the text will be displayed using the <code class="literal">red</code> CSS class, and if it is not <code class="literal">Left</code>, then the <code class="literal">blue</code> class will be used.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>Keep in mind that the HTML content is not recommended (for security reasons do not use <code class="literal">escape="false"</code>), and the <code class="literal">else</code> part of the condition cannot be omitted.</p></div></div><p>For better understanding<a id="id103" class="indexterm"/>, let's look at another example. Remember that you have iterated over the <code class="literal">titles_2013</code> array and output each item as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;c:forEach var="title" items="#{playersBean.titles_2013}"&gt;
  &lt;i&gt;#{title}&lt;/i&gt;,
&lt;/c:forEach&gt;</pre></div><p>Well, the output of this code will be something like the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_01_01.jpg" alt="The conditional text in JSF"/></div><p>Everything looks fine except the last comma, which should not appear since the <span class="strong"><strong>US Open</strong></span> term is the last item to display. You can easily fix this issue with the EL ternary operator, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;c:forEach var="title" items="#{playersBean.titles_2013}" varStatus="v"&gt;
  &lt;i&gt;#{title}&lt;/i&gt;
  #{v.last ? '':','}
&lt;/c:forEach&gt;</pre></div><p>Sometimes you just need to show or hide text based on a condition. For this, you can place a Boolean expression as the value of the <code class="literal">rendered</code> attribute (all JSF UI components have this attribute). For example, the following line of code will output a player's Facebook address only if such an address exists:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputText value="Facebook address: #{playersBean.facebook}" rendered="#{!empty playersBean.facebook}" /&gt;</pre></div><p>Another common situation is<a id="id104" class="indexterm"/> to display or hide non-HTML text using two buttons of type "Show something..." and "Hide something...". For example, you can have a button labeled <span class="strong"><strong>Show Career Prize Money</strong></span> and one labeled <span class="strong"><strong>Hide Career Prize Money</strong></span>. Obviously, you want to display the career prize money when the first button is clicked and to hide the career prize money when the second button is clicked. For this, you can use the <code class="literal">rendered</code> attribute<a id="id105" class="indexterm"/>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:form id="prizeFormId"&gt;
  &lt;h:commandButton value="Show Career Prize Money"&gt;
  &lt;f:ajax render="rnprizeid"  listener="#{playersBean.showPrizeMoney()}"/&gt;
  &lt;/h:commandButton&gt;
  &lt;h:panelGrid id="rnprizeid"&gt;
    &lt;h:outputText value="#{playersBean.prize}" rendered="#{playersBean.show_prize}"&gt;
      &lt;f:convertNumber type="currency" currencySymbol="$" /&gt;
    &lt;/h:outputText&gt;            
  &lt;/h:panelGrid&gt;
  &lt;h:commandButton value="Hide Career Prize Money"&gt;
    &lt;f:ajax render="rnprizeid" 
            listener="#{playersBean.hidePrizeMoney()}"/&gt;
  &lt;/h:commandButton&gt;
&lt;/h:form&gt;</pre></div><p>Both the buttons use AJAX mechanism and an EL method expression to call the <code class="literal">showPrizeMoney</code> and <code class="literal">hidePrizeMoney</code> methods. These methods just modify the value of a <code class="literal">boolean</code> property, named <code class="literal">show_prize</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">private boolean show_prize = false;
...
public boolean isShow_prize() {
  return show_prize;
}
...
public void showPrizeMoney(){
  this.show_prize = true;
}
    
public void hidePrizeMoney(){
  this.show_prize = false;
}</pre></div><p>When the request is complete, JSF will re-render the panel grid component with the ID <code class="literal">rnprizeid</code>; this was indicated in the <code class="literal">render</code> attribute of the <code class="literal">f:ajax</code> tag. As you can see, the re-rendered component is a panel that contains a simple <code class="literal">h:outputText</code> tag that outputs the <code class="literal">prize</code> property depending on the Boolean value of the EL expression present in the <code class="literal">rendered</code> attribute, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">private int prize = 60941937;
...
public int getPrize() {
  return prize;
}</pre></div><p>Showing and hiding text can be<a id="id106" class="indexterm"/> useful, but not enough. Usually, we need to show or hide the HTML content. For example, you may need to show or hide a picture:</p><div class="informalexample"><pre class="programlisting">&lt;img src="resources/images/babolat.jpg" width="290" height="174"/&gt;</pre></div><p>This task can be easily accomplished by nesting the HTML code inside the Facelets <code class="literal">ui:fragment</code> tag, which supports the <code class="literal">rendered</code> attribute, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;ui:fragment rendered="#{playersBean.show_racquet}"&gt;
  &lt;img src="#{resource['images:babolat.jpg']}" width="290" height="174"/&gt;
&lt;/ui:fragment&gt;</pre></div><p>As you can see, the EL expression of the <code class="literal">rendered</code> attribute indicates a <code class="literal">boolean</code> property of the <code class="literal">PlayersBean</code> managed bean, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">private boolean show_racquet = false;
...
public boolean isShow_racquet() {
  return show_racquet;
}</pre></div><p>Now, you can let the user decide when to show or hide the image. You can easily adapt the preceding example, with two buttons labeled <span class="strong"><strong>Show Image</strong></span> and <span class="strong"><strong>Hide Image</strong></span>, or more elegant, you can use a checkbox, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">...
&lt;h:form&gt;
  &lt;h:selectBooleanCheckbox label="Show Image"valueChangeListener="#{playersBean.showHideRacquetPicture}"&gt;
    &lt;f:ajax render="racquetId"/&gt;
  &lt;/h:selectBooleanCheckbox&gt;        
  &lt;h:panelGroup id="racquetId"&gt;
    &lt;ui:fragment rendered="#{playersBean.show_racquet}"&gt;
    &lt;img src="resources/images/babolat.jpg" width="290" height="174"/&gt;
  &lt;/ui:fragment&gt;    
  &lt;/h:panelGroup&gt;
&lt;/h:form&gt;
...</pre></div><p>The <code class="literal">showHideRacquetPicture</code> method<a id="id107" class="indexterm"/> sets the value of the <code class="literal">show_racquet</code> property to <code class="literal">true</code> or <code class="literal">false</code>, depending on<a id="id108" class="indexterm"/> the checkbox status. After this method is executed, JSF will re-render the content of the <code class="literal">ui:fragment</code> tag—this is accomplished via the HTML content rendered by the <code class="literal">&lt;h:panelGroup&gt;</code> tag, because the <code class="literal">&lt;ui:fragment&gt;</code> tag doesn't render the HTML content; therefore, it cannot be referenced by the ID. The following is the code for the <code class="literal">showHideRacquetPicture</code> method:</p><div class="informalexample"><pre class="programlisting">public void showHideRacquetPicture(ValueChangeEvent e){
  if(e.getNewValue() == Boolean.TRUE){
     this.show_racquet=true;
  } else {
     this.show_racquet=false;
  }
}</pre></div><p>So, we can conclude that the <code class="literal">rendered</code> attribute can be used to conditionally output the HTML/non-HTML content. The user interaction and internal conditions can be used to play with this attribute value.</p><p>The complete application is named <code class="literal">ch1_1</code>.</p></div>
<div class="section" title="Writing a custom EL resolver"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Writing a custom EL resolver</h1></div></div></div><p>EL flexibility can be tested<a id="id109" class="indexterm"/> by extending it with custom implicit variables, properties, and method calls. This is possible if we extend the <code class="literal">VariableResolver</code> or <code class="literal">PropertyResolver</code> class, or even better, the <code class="literal">ELResolver</code> class that give us flexibility to reuse the same implementation for different tasks. The following are three simple steps to add<a id="id110" class="indexterm"/> custom implicit variables:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create your own class that extends the <code class="literal">ELResolver</code> class.</li><li class="listitem">Implement the inherited abstract methods.</li><li class="listitem">Add the <code class="literal">ELResolver</code> class in <code class="literal">faces-config.xml</code>.</li></ol></div><p>Next, you will see how to add a custom implicit variable by extending EL based on these steps. In this example, you<a id="id111" class="indexterm"/> want to retrieve a collection that contains the ATP singles rankings using EL directly in your JSF page. The variable name used to access the collection will be <code class="literal">atp</code>.</p><p>First, you need to create a class that extends the <code class="literal">javax.el.ELResolver</code> class. This is very simple. The code for the <code class="literal">ATPVarResolver</code> class<a id="id112" class="indexterm"/> is as follows:</p><div class="informalexample"><pre class="programlisting">public class ATPVarResolver extends ELResolver {

  private static final Logger logger = Logger.getLogger(ATPVarResolver.class.getName());
  private static final String PLAYERS = "atp";
  private final Class&lt;?&gt; CONTENT = List.class;
...
}</pre></div><p>Second, you need to implement six abstract methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">getValue</code>: This method is<a id="id113" class="indexterm"/> defined in the following manner:<div class="informalexample"><pre class="programlisting">public abstract Object getValue(ELContext context, Object base, Object property)</pre></div><p>This is the most important method of an <code class="literal">ELResolver</code> class. In the implementation of the <code class="literal">getValue</code> method, you will return the ATP items if the property requested is named <code class="literal">atp</code>. Therefore, the implementation will be as follows:</p><div class="informalexample"><pre class="programlisting">@Override
public Object getValue(ELContext ctx, Object base, Object property) {

logger.log(Level.INFO, "Get Value property : {0}", property);

  if ((base == null) &amp;&amp; property.equals(PLAYERS)) {
    logger.log(Level.INFO, "Found request {0}", base);    
    ctx.setPropertyResolved(true);          
    List&lt;String&gt; values = ATPSinglesRankings.getSinglesRankings();
    return values;
    }
  return null;
}</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">getType</code>: This method<a id="id114" class="indexterm"/> is defined in the following manner:<div class="informalexample"><pre class="programlisting">public abstract Class&lt;?&gt; getType(ELContext context, Object base,Object property)</pre></div><p>This method identifies<a id="id115" class="indexterm"/> the most general acceptable type for our property. The scope of this method is to determine if a call of the <code class="literal">setValue</code> method is safe without causing a <code class="literal">ClassCastException</code> to be thrown. Since we return a collection, we can say that the general acceptable type is <code class="literal">List</code>. The implementation of the <code class="literal">getType</code> method is as follows:</p><div class="informalexample"><pre class="programlisting">@Override
public Class&lt;?&gt; getType(ELContext ctx, Object base, Object property) {

  if (base != null) {
    return null;
  }

  if (property == null) {
    String message = MessageUtils.getExceptionMessageString(MessageUtils.NULL_PARAMETERS_ERROR_MESSAGE_ID, "property");
    throw new PropertyNotFoundException(message);
  }

  if ((base == null) &amp;&amp; property.equals(PLAYERS)) {
    ctx.setPropertyResolved(true);
    return CONTENT;
  }
  return null; 
}</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">setValue</code>: This<a id="id116" class="indexterm"/> method is defined in the following manner:<div class="informalexample"><pre class="programlisting">public abstract void setValue(ELContext context, Object base, Object property, Object value)</pre></div><p>This method tries to set the value for a given property and base. For read-only variables, such as <code class="literal">atp</code>, you need to throw an exception of type <code class="literal">PropertyNotWritableException</code>. The<a id="id117" class="indexterm"/> implementation of the <code class="literal">setValue</code> method is as follows:</p><div class="informalexample"><pre class="programlisting">@Override
public void setValue(ELContext ctx, Object base, Object property, Object value) {

  if (base != null) {
    return;
  }

  ctx.setPropertyResolved(false);
  if (property == null) {
    String message = MessageUtils.getExceptionMessageString(MessageUtils.NULL_PARAMETERS_ERROR_MESSAGE_ID, "property");
    throw new PropertyNotFoundException(message);
  }

  if (PLAYERS.equals(property)) {
    throw new PropertyNotWritableException((String) property);
  }
}</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">isReadOnly</code>: This method is<a id="id118" class="indexterm"/> defined in the following<a id="id119" class="indexterm"/> manner:<div class="informalexample"><pre class="programlisting">public abstract boolean isReadOnly(ELContext context, Object base, Object property)</pre></div><p>This method returns <code class="literal">true</code> if the variable is read-only and <code class="literal">false</code> otherwise. Since the <code class="literal">atp</code> variable is read-only, the implementation is obvious. This method is directly related to the <code class="literal">setValue</code> method, meaning that it signals whether it is safe or not to call the <code class="literal">setValue</code> method without getting <code class="literal">PropertyNotWritableException</code> as a response. The implementation of the <code class="literal">isReadOnly</code> method is as follows:</p><div class="informalexample"><pre class="programlisting">@Override
public boolean isReadOnly(ELContext ctx, Object base, Object property) {
  return true;
}</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">getFeatureDescriptors</code>: This <a id="id120" class="indexterm"/>method is defined in the following manner:<div class="informalexample"><pre class="programlisting">public abstract Iterator&lt;FeatureDescriptor&gt; getFeatureDescriptors(ELContext context, Object base</pre></div><p>This method returns a set of information about the variables or properties that can be resolved (commonly it is used by a design time tool (for example, JDeveloper has such a tool) to allow code completion of expressions). In this case, you can return <code class="literal">null</code>. The implementation of the <code class="literal">getFeatureDescriptors</code> method is as follows:</p><div class="informalexample"><pre class="programlisting">@Override
public Iterator&lt;FeatureDescriptor&gt; getFeatureDescriptors(ELContext ctx, Object base) {
  return null;
}</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">getCommonPropertyType</code>: This method is<a id="id121" class="indexterm"/> defined in<a id="id122" class="indexterm"/> the following manner:<div class="informalexample"><pre class="programlisting">public abstract Class&lt;?&gt; getCommonPropertyType(ELContext context, Object base)</pre></div><p>This method returns the most general type that this resolver accepts. The implementation of the <code class="literal">getCommonPropertyType</code> method is as follows:</p><div class="informalexample"><pre class="programlisting">@Override
public Class&lt;?&gt; getCommonPropertyType(ELContext ctx, Object base) {
  if (base != null) {
    return null;
  }
  return String.class;
}</pre></div></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>How do you know if the <code class="literal">ELResolver</code> class acts as a <code class="literal">VariableResolver</code> class (these two classes are deprecated in JSF 2.2) or as a <code class="literal">PropertyResolver</code> class? The answer lies in the first part of the expression (known as the base argument), which in our case is <code class="literal">null</code> (the base is before the first dot or the square bracket, while property is after this dot or the square bracket). When the base is <code class="literal">null</code>, the <code class="literal">ELresolver</code> class acts as a <code class="literal">VariableResolver</code> class; otherwise, it acts as a <code class="literal">PropertyResolver</code> class.</p></div></div><p>The <code class="literal">getSinglesRankings</code> method<a id="id123" class="indexterm"/> (that populates the collection) is called from the <code class="literal">getValue</code> method, and<a id="id124" class="indexterm"/> is defined in the following <code class="literal">ATPSinglesRankings</code> class:</p><div class="informalexample"><pre class="programlisting">public class ATPSinglesRankings {
    
  public static List&lt;String&gt; getSinglesRankings(){
       
    List&lt;String&gt; atp_ranking= new ArrayList&lt;&gt;();
        
    atp_ranking.add("1 Nadal, Rafael (ESP)");
    ...              
        
    return atp_ranking;
  }
}</pre></div><p>Third, you register the custom <code class="literal">ELResolver</code> class in <code class="literal">faces-config.xml</code> using the <code class="literal">&lt;el-resolver&gt;</code> tag and specifying the fully qualified name of the corresponding class. In other words, you add the <code class="literal">ELResolver</code> class in the chain of responsibility, which represents the pattern<a id="id125" class="indexterm"/> used by JSF to deal with <code class="literal">ELResolvers</code>:</p><div class="informalexample"><pre class="programlisting">&lt;application&gt;
  &lt;el-resolver&gt;book.beans.ATPVarResolver&lt;/el-resolver&gt;
&lt;/application&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>Each time an expression needs to be resolved, JSF will call the default expression language resolver implementation. Each value expression is evaluated behind the scenes by the <code class="literal">getValue</code> method. When the <code class="literal">&lt;el-resolver&gt;</code> tag is present, the custom resolver is added in the chain of responsibility. The EL implementation manages a chain of resolver instances for different types of expression elements. For each part of an expression, EL will traverse the chain until it finds a resolver capable to resolve that part. The resolver capable of dealing with that part will pass <code class="literal">true</code> to the <code class="literal">setPropertyResolved</code> method<a id="id126" class="indexterm"/>; this method acts as a flag at the <code class="literal">ELContext</code> level.</p><p>Furthermore, EL implementation checks, after each resolver call, the value of this flag via the <code class="literal">getPropertyResolved</code> method. When the flag is <code class="literal">true</code>, EL implementation will repeat the process for the next part of the expression.</p></div></div><p>Done! Next, you can simply output the collection items in a data table, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:dataTable id="atpTableId" value="#{atp}" var="t"&gt;
  &lt;h:column&gt;
    #{t}
  &lt;/h:column&gt;
&lt;/h:dataTable&gt;</pre></div><p>Well, so far so good! Now, our custom EL resolver returns the plain list of ATP rankings. But, what can we do if we need the list items in the reverse order, or to have the items in uppercase, or to obtain a random list? The answer could consist in adapting the preceding EL resolver to this situation.</p><p>First, you need to modify the <code class="literal">getValue</code> method. At this moment, it returns <code class="literal">List</code>, but you need to obtain an instance of the <code class="literal">ATPSinglesRankings</code> class. Therefore, modify it as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public Object getValue(ELContext ctx, Object base, Object property) {

  if ((base == null) &amp;&amp; property.equals(PLAYERS)) {
    ctx.setPropertyResolved(true);
    return new ATPSinglesRankings();
  }
  return null;
}</pre></div><p>Moreover, you need to<a id="id127" class="indexterm"/> redefine the <code class="literal">CONTENT</code> constant accordingly as shown in the following line of code:</p><div class="informalexample"><pre class="programlisting">private final Class&lt;?&gt; CONTENT = ATPSinglesRankings.class;</pre></div><p>Next, the <code class="literal">ATPSinglesRankings</code> class can contain a method for each case, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public class ATPSinglesRankings {
    
  public List&lt;String&gt; getSinglesRankings(){
       
    List&lt;String&gt; atp_ranking= new ArrayList&lt;&gt;();
        
    atp_ranking.add("1 Nadal, Rafael (ESP)");
    ...             
        
    return atp_ranking;
  }
    
  public List&lt;String&gt; getSinglesRankingsReversed(){
       
    List&lt;String&gt; atp_ranking= new ArrayList&lt;&gt;();
                
    atp_ranking.add("5 Del Potro, Juan Martin (ARG)");
    atp_ranking.add("4 Murray, Andy (GBR)");        
    ...  
                
    return atp_ranking;
  }
    
  public List&lt;String&gt; getSinglesRankingsUpperCase(){
       
    List&lt;String&gt; atp_ranking= new ArrayList&lt;&gt;();
                
    atp_ranking.add("5 Del Potro, Juan Martin (ARG)".toUpperCase());                        
    atp_ranking.add("4 Murray, Andy (GBR)".toUpperCase());
    ...
                
    return atp_ranking;
  }
...
}</pre></div><p>Since the EL resolver returns an instance of the <code class="literal">ATPSinglesRankings</code> class in the <code class="literal">getValue</code> method, you<a id="id128" class="indexterm"/> can easily call the <code class="literal">getSinglesRankings</code>, <code class="literal">getSinglesRankingsReversed</code>, and <code class="literal">getSinglesRankingsUpperCase</code> methods directly from your EL expressions, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;b&gt;Ordered:&lt;/b&gt;&lt;br/&gt;
&lt;h:dataTable id="atpTableId1" value="#{atp.singlesRankings}"var="t"&gt;
  &lt;h:column&gt;#{t}&lt;/h:column&gt;
&lt;/h:dataTable&gt;
&lt;br/&gt;&lt;br/&gt;&lt;b&gt;Reversed:&lt;/b&gt;&lt;br/&gt;
&lt;h:dataTable id="atpTableId2" value="#{atp.singlesRankingsReversed}" var="t"&gt;
  &lt;h:column&gt;#{t}&lt;/h:column&gt;
&lt;/h:dataTable&gt;
&lt;br/&gt;&lt;br/&gt;&lt;b&gt;UpperCase:&lt;/b&gt;&lt;br/&gt;
&lt;h:dataTable id="atpTableId3" value="#{atp.singlesRankingsUpperCase}" var="t"&gt;
  &lt;h:column&gt;#{t}&lt;/h:column&gt;
&lt;/h:dataTable&gt;</pre></div><p>The complete applications<a id="id129" class="indexterm"/> to demonstrate custom <code class="literal">ELResolvers</code> are available in the code bundle of this chapter and are named <code class="literal">ch1_2</code> and <code class="literal">ch1_3</code>.</p><p>In order to develop the last example of writing a custom resolver, let's imagine the following scenario: we want to access the <code class="literal">ELContext</code> object as an implicit object, by writing <code class="literal">#{elContext}</code> instead of <code class="literal">#{facesContext.ELContext}</code>. For this, we can use the knowledge accumulated from the previous two examples to write the following custom resolver:</p><div class="informalexample"><pre class="programlisting">public class ELContextResolver extends ELResolver {

  private static final String EL_CONTEXT_NAME = "elContext";

  @Override
  public Class&lt;?&gt; getCommonPropertyType(ELContext ctx,Object base){
    if (base != null) {
      return null;
    }
    return String.class;
  }

  @Override
  public Iterator&lt;FeatureDescriptor&gt; getFeatureDescriptors(ELContext ctx, Object base) {
    if (base != null) {
      return null;
  }
    ArrayList&lt;FeatureDescriptor&gt; list = new ArrayList&lt;&gt;(1);
    list.add(Util.getFeatureDescriptor("elContext", "elContext","elContext", false, false, true, 
    ELContext.class, Boolean.TRUE));
    return list.iterator();
  }

  @Override
  public Class&lt;?&gt; getType(ELContext ctx, Object base, Object property) {
    if (base != null) {
      return null;
    }
    if (property == null) {
      String message = MessageUtils.getExceptionMessageString(MessageUtils.NULL_PARAMETERS_ERROR_MESSAGE_ID, "property");
      throw new PropertyNotFoundException(message);
    }
    if ((base == null) &amp;&amp; property.equals(EL_CONTEXT_NAME)) {
      ctx.setPropertyResolved(true);
    }
    return null;
  }

  @Override
  public Object getValue(ELContext ctx, Object base, Object property) {

    if ((base == null) &amp;&amp; property.equals(EL_CONTEXT_NAME)) {
      ctx.setPropertyResolved(true);
      FacesContext facesContext = FacesContext.getCurrentInstance();
        return facesContext.getELContext();
    }
    return null;
  }

  @Override
  public boolean isReadOnly(ELContext ctx, Object base, Object property) {
    if (base != null) {
      return false;
    }
    if (property == null) {
      String message = MessageUtils.getExceptionMessageString(MessageUtils.NULL_PARAMETERS_ERROR_MESSAGE_ID, "property");
      throw new PropertyNotFoundException(message);
    }
    if (EL_CONTEXT_NAME.equals(property)) {
      ctx.setPropertyResolved(true);
      return true;
    }
    return false;
  }

  @Override
  public void setValue(ELContext ctx, Object base, Object property, Object value) {
    if (base != null) {
      return;
    }
    ctx.setPropertyResolved(false);
    if (property == null) {
      String message = MessageUtils.getExceptionMessageString(MessageUtils.NULL_PARAMETERS_ERROR_MESSAGE_ID, "property");
      throw new PropertyNotFoundException(message);
    }
    if (EL_CONTEXT_NAME.equals(property)) {
      throw new PropertyNotWritableException((String) property);
    }
  }
}</pre></div><p>The complete application is named, <code class="literal">ch1_6</code>. The goal of these three examples was to get you familiar with the main<a id="id130" class="indexterm"/> steps of writing a custom resolver. In <a class="link" href="ch03.html" title="Chapter 3. JSF Scopes – Lifespan and Use in Managed Beans Communication">Chapter 3</a>, <span class="emphasis"><em>JSF Scopes – Lifespan and Use in Managed Beans Communication</em></span>, you will see how to write a custom resolver for a custom scope.</p></div>
<div class="section" title="EL 3.0 overview"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>EL 3.0 overview</h1></div></div></div><p>EL 3.0 (JSR 341, part of Java EE 7)<a id="id131" class="indexterm"/> represents a major boost of EL 2.2. The main features<a id="id132" class="indexterm"/> of EL 3.0 are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">New operators <code class="literal">+</code>, <code class="literal">=</code>, and <code class="literal">;</code></li><li class="listitem" style="list-style-type: disc">Lambda expressions</li><li class="listitem" style="list-style-type: disc">Collection objects support</li><li class="listitem" style="list-style-type: disc">An API for standalone environments</li></ul></div><p>In the upcoming sections, you will see how to use EL 3.0 features in JSF pages.</p><div class="section" title="Working with the assignment operator"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Working with the assignment operator</h2></div></div></div><p>In an expression of type, <code class="literal">x = y</code>, the<a id="id133" class="indexterm"/> assignment operator (<code class="literal">=</code>), assign the value of <code class="literal">y</code> to <code class="literal">x</code>. In order to avoid an<a id="id134" class="indexterm"/> error of the kind <code class="literal">PropertyNotWritableException</code>, the <code class="literal">x</code> value must be an lvalue. The following examples show you how to use this operator in two simple expressions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">#{x = 3}</code> evaluates to 3</li><li class="listitem" style="list-style-type: disc"><code class="literal">#{y = x + 5}</code> evaluates to 8</li></ul></div><p>The assignment operator is right-<a id="id135" class="indexterm"/>associative (<code class="literal">z = y = x</code> is equivalent with <code class="literal">z = (y = x)</code>). For <a id="id136" class="indexterm"/>example, <code class="literal">#{z = y = x + 4}</code> evaluates to 7.</p></div><div class="section" title="Working with the string concatenation operator"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Working with the string concatenation operator</h2></div></div></div><p>In an expression<a id="id137" class="indexterm"/> of type, <code class="literal">x += y</code>, the string concatenation operator (<code class="literal">+=</code>) returns<a id="id138" class="indexterm"/> the concatenated string of <code class="literal">x</code> and <code class="literal">y</code>. For example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">#{x += y}</code> evaluates to 37</li><li class="listitem" style="list-style-type: disc"><code class="literal">#{0 += 0 +=0 += 1 += 1 += 0 += 0 += 0}</code> evaluates to 00011000</li></ul></div><p>In EL 2.2, you can do this using the following code:</p><div class="informalexample"><pre class="programlisting">#{'0'.concat(0).concat(0).concat(1).concat(1).concat(0).concat(0).concat(0)}</pre></div></div><div class="section" title="Working with the semicolon operator"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>Working with the semicolon operator</h2></div></div></div><p>In an expression of type, <code class="literal">x; y</code>, <code class="literal">x</code> is first<a id="id139" class="indexterm"/> evaluated, and its value is discarded. Next, <code class="literal">y</code> is evaluated and its value<a id="id140" class="indexterm"/> is returned. For example, <code class="literal">#‌{x = 5; y = 3; z = x + y}</code> evaluates to 8.</p></div><div class="section" title="Exploring lambda expressions"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Exploring lambda expressions</h2></div></div></div><p>A lambda expression can be<a id="id141" class="indexterm"/> disassembled in three main parts: parameters, the lambda operator (<code class="literal">-&gt;</code>), and the function body.</p><p>Basically, in Java language, a lambda expression represents a method in an anonymous implementation of a functional interface. In EL, a lambda expression is reduced to an anonymous function that can be passed as an argument to a method.</p><p>It is important to not confuse<a id="id142" class="indexterm"/> Java 8 lambda expressions with EL lambda expressions, but in order to understand the next examples, it is important to know the fundamentals of Java 8 lambda expressions (<a class="ulink" href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html</a>). They don't have the same syntax, but they are similar enough to not cause notable discomfort when we need to switch between them.</p><p>An EL lambda expression is a parameterized <code class="literal">ValueExpression</code> object. The body of an EL lambda expression is an EL expression. EL supports several kinds of lambda expressions. The simplest type of EL lambda expressions are immediately invoked, for<a id="id143" class="indexterm"/> example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">#{(x-&gt;x+1)(3)}</code> evaluates to 4</li><li class="listitem" style="list-style-type: disc"><code class="literal">#{((x,y,z)-&gt;x-y*z)(1,7,3)}</code> evaluates to -20</li></ul></div><p>Further, we have assigned lambda expressions. These are invoked indirectly. For example, <code class="literal">#‌{q = x-&gt;x+1; q(3)}</code> evaluates to 4.</p><p>Indirectly, invocation can be used to write functions. For example, we can write a function to calculate <code class="literal">n mod m</code> (without using the <code class="literal">%</code> operator). The following example is evaluated to 3:</p><div class="informalexample"><pre class="programlisting">#‌{modulus = (n,m) -&gt; m eq 0 ? 0 : (n lt m ? n: (modulus(n-m, m))); modulus(13,5)}</pre></div><p>We can call this function from<a id="id144" class="indexterm"/> other expressions. For example, if we want to calculate the greatest common divisor <a id="id145" class="indexterm"/>of two numbers, we can exploit the preceding function; the following example is evaluated to 5:</p><div class="informalexample"><pre class="programlisting">#‌{gcd = (n,m) -&gt; modulus(n,m) == 0 ? m: (gcd(m, modulus(n,m))); gcd(10, 15)}</pre></div><p>Lambda expressions can be passed as arguments to methods. For example, in the following example, you call a method named <code class="literal">firstLambdaAction</code>—the lambda expression is invoked from this method:</p><div class="informalexample"><pre class="programlisting">#‌{lambdaBean.firstLambdaAction(modulus = (n,m) -&gt; m eq 0 ? 0 : (n lt m ? n: (modulus(n-m, m))))}</pre></div><p>Now, the <code class="literal">firstLambdaAction</code> method is as follows:</p><div class="informalexample"><pre class="programlisting">public Object firstLambdaAction(LambdaExpression lambdaExpression) {

  //useful in case of a custom ELContext
  FacesContext facesContext = FacesContext.getCurrentInstance();
  ELContext elContext = facesContext.getELContext();
  return lambdaExpression.invoke(elContext, 8, 3);

  //or simply, default ELContext:
  //return lambdaExpression.invoke(8, 3);
}</pre></div><p>Another powerful feature of lambda expressions consists of nested lambda expressions. For example (first, is evaluated the inner expression to 7, afterwards the outer expression to as, 10 - 7): <code class="literal">#‌{(x-&gt;x-((x,y)-&gt;(x+y))(4,3))(10)}</code> evaluates to 3.</p><p>Do you think EL lambda expressions rocks? Well, get ready for more. The real power is unleashed only when we bring collection objects into equations.</p><div class="section" title="Working with collection objects"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Working with collection objects</h3></div></div></div><p>EL 3.0 provides powerful <a id="id146" class="indexterm"/>support to manipulate collection objects by applying operations in a pipeline. The methods supporting<a id="id147" class="indexterm"/> the collection operations are implemented as <code class="literal">ELResolvers</code>, and lambda expressions are indicated as arguments for these methods.</p><p>The main idea behind manipulating collection objects is based on <span class="strong"><strong>streams</strong></span><a id="id148" class="indexterm"/>. More precisely, the specific operations are accomplished as method calls to the stream of elements obtained from the collection. Many operations return streams, which can be used in other operations that return streams, and so on. In such a case, we can say that we have a chain of streams or a pipeline. The entry in the pipeline is known as the <span class="strong"><strong>source</strong></span><a id="id149" class="indexterm"/>, and the exit from the pipeline is known as the <span class="strong"><strong>terminal operation</strong></span><a id="id150" class="indexterm"/> (this operation doesn't return a stream). Between the source and terminal operation, we may have zero or more <span class="strong"><strong>intermediate operations</strong></span><a id="id151" class="indexterm"/> (all of them return streams).</p><p>The pipeline execution begins when the terminal operation starts. Because intermediate operations are lazy evaluated,<a id="id152" class="indexterm"/> they don't preserve intermediate results <a id="id153" class="indexterm"/>of the operations (an exception is the sorted operation, <a id="id154" class="indexterm"/>which needs all the elements to sort tasks).</p><p>Now, let's see some examples. We begin by declaring a set, a list, and a map—EL contains syntaxes to construct sets, lists, and maps dynamically as follows:</p><div class="informalexample"><pre class="programlisting">#‌{nr_set = {1,2,3,4,5,6,7,8,9,10}}
#‌{nr_list = [1,2,3,4,5,6,7,8,9,10]}
#‌{nr_map = {"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9,"ten":10}}</pre></div><p>Now, let's go a step further and sort the list in ascending/descending order. For this, we use the <code class="literal">stream</code>, <code class="literal">sorted</code> (this is like the <code class="literal">ORDER BY</code> statement of SQL), and <code class="literal">toList</code> methods (the latter returns a <code class="literal">List</code> that contains the elements of the source stream), as shown in the following code:</p><div class="informalexample"><pre class="programlisting">#‌{nr_list.stream().sorted((i,j)-&gt;i-j).toList()}
#‌{ nr_list.stream().sorted((i,j)-&gt;j-i).toList()}</pre></div><p>Further, let's say that we have the following list in a managed bean named <code class="literal">LambdaBean</code>:</p><div class="informalexample"><pre class="programlisting">List&lt;Integer&gt; costBeforeVAT = Arrays.asList(34, 2200, 1350, 430, 57, 10000, 23, 15222, 1);</pre></div><p>Next, we can apply 24 percent of VAT and compute the total for costs higher than 1,000 using the <code class="literal">filter</code> (this is like SQL's <code class="literal">WHERE</code> and <code class="literal">GROUP BY</code> statements), <code class="literal">map</code> (this is like SQL's <code class="literal">SELECT</code> statement), and <code class="literal">reduce</code> (this is like the aggregate functions) methods. These methods are used as follows:</p><div class="informalexample"><pre class="programlisting">#‌{(lambdaBean.costBeforeVAT.stream().filter((cost)-&gt; cost gt 1000).map((cost) -&gt; cost + .24*cost)).reduce((sum, cost) -&gt; sum + cost).get()}</pre></div><p>These were just a few examples of using collection objects in EL 3.0. A complete application named <code class="literal">ch1_4</code> is available for download in the code bundle of this chapter. Since, in this application you can see more than 70 examples, I recommend you to take a look at it. Moreover, a nice example can be found on Michael Müller's blog at <a class="ulink" href="http://blog.mueller-bruehl.de/web-development/using-lambda-expressions-with-jsf-2-2/">http://blog.mueller-bruehl.de/web-development/using-lambda-expressions-with-jsf-2-2/</a>.</p><p>But, what if we want to take advantage of lambda expressions, but we don't like to write such expressions? Well, a solution can be to write parameterized functions based on lambda expressions, and call<a id="id155" class="indexterm"/> them in the JSTL style. For example, the<a id="id156" class="indexterm"/> following function is capable of extracting a sublist of a <code class="literal">List</code>:</p><div class="informalexample"><pre class="programlisting">#{get_sublist = (list, left, right)-&gt;list.stream().substream(left, right).toList()}</pre></div><p>Now, we can call it as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;ui:repeat value="#{get_sublist(myList, from, to)}" var="t"&gt;
  #{t}
&lt;/ui:repeat&gt;</pre></div><p>In the complete application,<a id="id157" class="indexterm"/> named <code class="literal">ch1_5</code>, you can see a bunch of 21 parameterized functions that can be used with <code class="literal">List</code>s.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Summary</h1></div></div></div><p>In this chapter, we saw that EL 2.2 expressions can be used to dynamically access data (read and write) stored in JavaBeans components, to call arbitrary static and public methods, and to perform arithmetic and logic operations. Finally, we saw that EL allows us to extend its capabilities with custom resolvers. Starting with EL 3.0, we can take advantage of new operators, lambda expressions, and support when working with collection objects.</p><p>While reading this book, you will see many examples of EL expressions in real cases. For example, in the next chapter, you will use EL expressions to explore JSF communication capabilities.</p><p>See you in the next chapter, where we will discuss JSF communications.</p></div></body></html>