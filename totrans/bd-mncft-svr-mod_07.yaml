- en: Chapter 7. The Bukkit Event System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, you know how to create a plugin that will run some code when
    a command is executed. This is very useful in many situations. However, we would
    rather not be required to type in a command sometimes. We''d prefer it if the
    code could be automatically triggered to be executed. The trigger could be a specific
    event that occurs on the server, such as a block being broken, a creeper exploding,
    or a player sending a message in a chat. The Bukkit event system allows a developer
    to listen for an event and automatically run a block of code based on that event.
    By using the Bukkit event system, you can automate your server, which means less
    work for you to maintain the server in the future. In this chapter, we''ll cover
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering an event listener
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listening for an event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canceling an event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating between events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying an event as it occurs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating more plugins on your own
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing an event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the events that Bukkit provides can be found in the API documentation in
    the `org.bukkit.event` package. Each event is categorized into packages within
    `org.bukkit.event`, such as `org.bukkit.event.block`, `org.bukkit.event.player`,
    and `org.bukkit.event.world`. This makes it easy to find the event that you are
    looking for. A full list of the Bukkit events can be found at [https://hub.spigotmc.org/javadocs/spigot/org/bukkit/event/class-use/Event.html](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/event/class-use/Event.html).
    I encourage you to take a look at the list to see what type of event you can listen
    for. Each event has several methods, which give you more information and allow
    you to modify the event. For example, `BlockBreakEvent` provides methods to get
    the block that was broken and the player who broke it. Most events can also be
    canceled if you wish to not allow the events to occur. This is useful in many
    situations, such as not letting a new player place a TNT block, or preventing
    a mob from spawning.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, listening to events can aid in automating your server
    and reducing the number of commands being sent. In addition to that, they can
    simply be a lot of fun to work with. Let's look at a few examples of plugins that
    can be made using the Bukkit event system. We mentioned that you can listen to
    the player chat event and modify it as you please. You can use this to monitor
    messages and censor the offensive words that may be spoken. Placing TNT blocks
    was also mentioned. You can create a plugin that only lets players place TNT if
    they have the `build.tnt` permission node. There is also a `WeatherChangeEvent
    class` that can be canceled. That being said, there are many server administrators
    who don't like it when it rains on the server. Rain can be loud and annoying.
    Admins will issue the `/toggledownfall` command to stop the rain every time it
    starts. In this chapter, we will create a plugin that prevents rain from starting
    in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that we must do is find the appropriate event that we can listen
    for. To accomplish this, we will have a look at the Bukkit API documentation.
    Let's say that we are unfamiliar with the API. Therefore, we are unsure about
    which event we can use. We can look through the list of events until we find the
    correct one, but you may have better luck if you first find the right package.
    There are two categories that rain could fall under, namely world events or weather
    events. It is more likely that rain would be categorized under weather. So, we
    will look there first. There is no event that includes the word "rain" because
    rain is categorized with snow. Therefore, the event that we are looking for is
    the `WeatherChangeEvent class`. If you did not find a correct event to use, look
    in other packages.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are ever unable to find the event that you are looking for, then remember
    that you can ask for help on the Bukkit/Spigot forums. You can perhaps perform
    a search on the forums first to check whether anyone else was looking for the
    same information. It is possible that the event that you are attempting to listen
    for does not exist. Keep in mind that the Spigot project is not associated with
    the creators of Minecraft. Therefore, it is impossible to detect or modify some
    events.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have found the event, we wish to prevent this event from occurring.
    Viewing the `WeatherChangeEvent` class reference page, we will see several methods
    that are offered in this event. We will use the `setCancelled` method to cancel
    the event and the `toWeatherState` method to ensure that we are only preventing
    the rain from starting and not stopping.
  prefs: []
  type: TYPE_NORMAL
- en: Registering an event listener
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After deciding which event we will listen for, it is time to start programming.
    Create a new project, as described in [Chapter 3](part0026_split_000.html#OPEK1-b66e70deee6e4ed481db4b113e303f23
    "Chapter 3. Creating Your First Bukkit Plugin"), *Creating Your First Bukkit Plugin*,
    and call it `NoRain`. Don't forget to create a `plugin.yml` file as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to listen for an event, your plugin must have a class that is registered
    as a `Listener class`. We will only have one class, named `NoRain.java`, for this
    project. Therefore, we will make this a `Listener` class as well. The class declaration
    will look like the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, if this is a large project, you can make a class for the `Listener
    class`, which is similar to how the `Enchanter` project had `CommandExecutor`
    as a separate class. Also, like `CommandExecutor`, a `Listener class` will implement
    an `interface method`. The `interface method` that we wish to implement is `org.bukkit.event.Listener`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class is declared as a `Listener` class but it is still not registered
    with Bukkit. To register all the events within the listener, insert the following
    line of code in the `onEnable` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This line retrieves the `PluginManager class` and uses it to register the events.
    The `PluginManager class` is used for several things, including handling events,
    enabling/disabling plugins, and handling player permissions. Most of the time,
    you will use it to register event listeners. It has a `registerEvents` method
    that takes a `Listener` object and a `JavaPlugin` object as parameters. The only
    class that exists is both the `Listener` and `JavaPlugin`. So, we will pass the
    `this` object to both the parameters. If the `Listener` class is separated from
    the `main` class, then the line will look like the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is all that is needed within the `onEnable` method.
  prefs: []
  type: TYPE_NORMAL
- en: Listening for an event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next method that we will create is an `EventHandler method`. We will use
    the `@EventHandler` annotation to tell Bukkit which methods are event listeners.
    Create a new method that has an event of our choice as the only parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The method must be `public`, and it should not return anything. You can name
    this method anything you wish, but most programmers will keep the name similar
    to the name of the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will indicate that this method handles events. Just above the method,
    add the following annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'On the same line, we can modify some properties for the `EventHandler method`.
    A property that you are likely to add to all the `EventHandler` methods is the
    one that ignores the canceled events. Setting the `ignoreCancelled` property to
    `true` will result in the method looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If the event is already canceled by another plugin, then we don't want to bother
    listening to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other property is the event priority. By changing the priority of the `EventHandler
    method`, you can choose to listen for the event before or after other plugins.
    If the `EventHandler method` has a higher priority than another event, then it
    is called after the other `EventHandler method` and thus may override anything
    that the first `EventHandler` method has modified. There are six priority levels,
    and they are called in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: LOWEST
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: LOW
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: NORMAL
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: HIGH
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: HIGHEST
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MONITOR
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thus, the plugins with the `LOWEST` priority are called first. Imagine that
    you have a protection plugin. You would not want any other plugin to reverse its
    decision to cancel an event. Therefore, you would set the priority to `HIGHEST`
    so that no other plugins would be able to modify the event after yours. By default,
    each `EventHandler method` has a `NORMAL` priority. If you are not modifying the
    event, then you will most likely want to listen at the `MONITOR` level. The `MONITOR`
    priority should not be used when modifying the event, such as canceling it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to cancel this event before plugins that have a `NORMAL` priority even
    see it. Therefore, let''s change the priority of this event to `LOW`. Now, the
    line that is above the method looks like the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Canceling an event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we want to stop the weather from changing. To do so, we will call
    the `setCancelled` method of the event. The method takes a `Boolean` value as
    a parameter. We want `canceled` to equal `true`. Therefore, we will use the `setCancelled(true)`
    code, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This plugin will work as is. However, there is room for improvement. What if
    it is already raining in the server world? This plugin would prevent the rain
    from ever stopping. Let''s add an `if` statement so that the `WeatherChangeEvent
    class` will only be canceled if the weather is starting. The event provides us
    with a method called `toWeatherState`, which returns a `Boolean` value. This method
    will return `true` or `false`, informing us about whether the weather is starting
    or stopping respectively. This is also made clear in the API documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Canceling an event](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If `toWeatherState` returns `true`, then it is starting to rain. This is the
    case where we want to cancel the event. Now, let''s write the same thing in Java,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After adding this `if` statement, you should test your plugin. Before installing
    the plugin, log on to your server and use the `/toggledownfall` command to make
    it rain. Once it is raining, install your newly created plugin and reload the
    server. At this point, it will still be raining, but you will be able to stop
    the rain by issuing the `/toggledownfall` command again. If you cannot do so,
    then the `if` statement that you added may be incorrect; review it to find your
    mistake and test it again. Once you stop the rain, you can try to use the same
    command to start the rain again. As long as the code is correct, the rain should
    not start. If the rain does start, then verify that your event listener is being
    properly registered within the `onEnable` method. Also, verify that the server
    is enabling the correct version of the plugin, as explained in [Chapter 4](part0033_split_000.html#VF2I1-b66e70deee6e4ed481db4b113e303f23
    "Chapter 4. Testing on the Spigot Server"), *Testing on the Spigot Server*.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating among events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The plugin works exactly as intended, but what if we have a change of heart
    and begin to miss the sound of rain? Alternatively, what if our town bursts into
    flames and it must be extinguished quickly? We do not want to limit our power
    as an administrator by denying ourselves the use of the `/toggledownfall` command.
    Next, we will listen for this command to be issued, and when it is issued, we
    will allow the weather to change. Ultimately, we will still be able to control
    the weather manually, but the weather will not start on its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create another `EventHandler method`. This time, we will listen for
    a console command being sent so that we can set a Boolean flag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We will not actually be modifying this event at all. Therefore, the event priority
    will be set to `MONITOR`. We also want to ignore canceled events. The event that
    we will listen for is `PlayerCommandPreprocessEvent`, which will occur every time
    a player issues a command, whether they are for Minecraft, Bukkit, or another
    plugin. We only care about one command, namely `/toggledownfall`. So, the first
    `if` statement checks whether the message starts with `/toggledownfall`. If it
    is a different command, we will ignore it. As the event name suggests, this event
    occurs before the command is actually executed. Therefore, we must verify that
    a player has the permission to run the command. The permission node for the command
    is `minecraft.command.toggledownfall`. If these two conditions are met, then we
    want to allow rain to start on the next `WeatherChangeEvent class`. The second
    `EventHandler method` is completed by using the two `if` statements and setting
    a Boolean variable to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, a light bulb will appear, informing you that the `denyRain` symbol
    cannot be found. When you click on the bulb, you can select `Create Field denyRain
    in com.codisimus.norain.NoRain`. This will automatically create a private variable
    called `denyRain` inside the class. Note the placement of the new line of code.
    It is outside the existing method blocks and yet still inside the class. This
    is important because it defines the variable's scope. The scope of a variable
    is where it can be accessed. The `denyRain` variable is private. Therefore, no
    other class, such as a class from another plugin, can modify it. However, within
    the `NoRain` class, all the methods can access it. This is useful because if the
    variable was declared within the curly braces of the `onPlayerCommand` method,
    we would not be able to see it from the `onWeatherChange` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the plugin knows when we wish to allow the rain to start, we must
    slightly modify the `onWeatherChange` method to allow for such an exception. Currently,
    to cancel the event, we will call the `setCancelled` method with `true` as the
    parameter. If we were to pass `false` as a parameter, then the event would not
    be cancelled. The `denyRain` variable is equal to `true` when we wish to cancel
    the event. Therefore, rather than passing `true` or `false`, we can pass the value
    of `denyRain`. So, when `denyRain` is set to `false`, we will call `setCancelled`
    using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the `onWeatherChange` method, we want to reset the value of `denyRain`
    to `true`. In this way, we can ensure that we allow the weather to change only
    once each time the `/toggledownfall` command is issued. The final code looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that when we declare the Boolean `denyRain method`, we set its initial
    value to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: This completes the `NoRain` plugin. Build the JAR file and test it out on your
    server. With this new version, you will be able to use the `/toggledownfall` command
    to stop and start rain.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying an event as it occurs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Bukkit API allows a programmer to do more than just cancel an event. Depending
    on the event, you can modify many of its aspects. In this next project, we will
    modify zombies as they spawn. Every time a zombie spawns, we will give it `40`
    health rather than the default `20`. This will make zombies more difficult to
    kill.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project as you would for any plugin. We will call this plugin
    `MobEnhancer`. Similar to what we did with the `NoRain` plugin, have the `main`
    class implement `Listener` and add the following line of code to the `onEnable`
    method to register the `EventHandlers method`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For this project, we will have an `EventHandler method` that listens for mobs
    spawning. This will be the `CreatureSpawnEvent class`. This event has many methods
    that we can call to either modify the event or gain more information about it.
    We only wish to modify zombies that are spawned. Therefore, the first thing that
    we will add is an `if` statement, which will check whether the `EntityType method`
    is `ZOMBIE`. This is done by using the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Inside the curly braces, we will change the health of the `Entity class` to
    `40`. We can retrieve the `Entity` class by calling `event.getEntity()`. Once
    we have the `Entity class`, we have access to many additional methods. You can
    view all of these methods in the API documentation, which is available at [https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/Entity.html](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/Entity.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the methods is `setHealth`. Before we can set the health to `40`, we
    must set the maximum health, which can have a value of `40`. An `Entity class`
    cannot have a health of `40` when its maximum health is still `20`. These two
    lines of code will complete this plugin. The code now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first version of the `MobEnhancer` plugin is complete with this small class.
    You can test the plugin by installing it on your server. You will notice that
    zombies will be much more difficult to kill.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we declared a local variable named `health` of the `int` type and
    set its value to `40`. Alternatively, we could simply write `40` in the two lines
    that follow. However, programming the amount of health this way allows us to easily
    change it in the future. We only have to change the number in one line of code
    rather than two or more. Also, you may have noticed that the `setMaxHealth` and
    `setHealth` methods accept a variable of the `double` type. However, an `int`
    value may still be passed to the method, as it will be automatically converted
    to a `double` value with a value of `40`.`0`.
  prefs: []
  type: TYPE_NORMAL
- en: You can add more code to the plugin in order to modify the health of more types
    of entities. A list of all the `EntityType methods` can be found in the Bukkit
    API documentation under the `EntityType` class reference page at [https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/EntityType.html](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/EntityType.html).
    However, in the next chapter, we will make this plugin configurable in order to
    change the health of every type of `Entity` that spawns.
  prefs: []
  type: TYPE_NORMAL
- en: Creating more plugins on your own
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have created these two plugins, you have a hang of how to properly
    use event listeners. You now have the required knowledge to create hundreds of
    unique plugins on your own. All that you need to get started is a cool idea. Why
    don''t you try making one of the plugins that was suggested earlier in this chapter?
    For more ideas, you know where to look. The Bukkit, Spigot, and Minecraft forums
    or the API documentation are great for inspiration. For example, looking through
    the list of events, I saw the `ExplosionPrimeEvent` class, which is described
    as "**Called when an entity has made a decision to explode**". This event is called
    when a creeper makes that hissing noise that every Minecraft player dreads. When
    this happens, you can send a message to all the nearby players to make it look
    like the creeper is talking to them. First, you will create an `EventHandler method`
    for this event. You will want to return in case the entity is not a creeper. Then,
    you will want to get the entities that are near the creeper (there is a method
    for this within the `Entity` class). For each entity that you get, if it is an
    instance of a player, send them a message, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<Creeper> That sssure isss a nicccee <ItemInHand> you have there. It would
    be a ssssshame if anything happened to it.`'
  prefs: []
  type: TYPE_NORMAL
- en: In each message, you will replace `<ItemInHand>` with the type of item that
    the player is holding. By this time, I am sure that you have some ideas of your
    own that you are able to implement as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another good thing that you should know about listeners is how to unregister
    them. You may never need to do this, but if you do ever want to stop modifying
    or canceling an event, then you can use the following code within the `Listener`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This will unregister the entire class. So, if you wish to only unregister specific
    `EventHandler methods`, then you should split them up into separate classes. Unregistering
    the listeners will not be the way to go for the `NoRain` plugin, but it may be
    useful if you add a `/mobenhancer off` command. Then, a `/mobenhancer on` command
    can register the listeners again, which is similar to how we did this in the `onEnable`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both the plugins that we made in this chapter have the entire code within a
    single class. However, you may choose to separate these into the main plugin class
    and a listener class. In small plugins like these, it is not necessary. But in
    larger projects, it will keep your code much cleaner. There will be a few differences,
    such as having static variables or passing a variable to another class. In the
    next chapter, we will complete the `MobEnhancer` plugin by adding configuration
    as well as a `reload` command. We will have the `Listener` and `CommandExecutor`
    as a part of the `main` class. Once the plugin is complete, we will go over the
    differences for the same plugin as three individual classes.
  prefs: []
  type: TYPE_NORMAL
