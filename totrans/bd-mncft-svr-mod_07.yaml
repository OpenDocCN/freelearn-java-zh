- en: Chapter 7. The Bukkit Event System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. Bukkit事件系统
- en: 'At this point, you know how to create a plugin that will run some code when
    a command is executed. This is very useful in many situations. However, we would
    rather not be required to type in a command sometimes. We''d prefer it if the
    code could be automatically triggered to be executed. The trigger could be a specific
    event that occurs on the server, such as a block being broken, a creeper exploding,
    or a player sending a message in a chat. The Bukkit event system allows a developer
    to listen for an event and automatically run a block of code based on that event.
    By using the Bukkit event system, you can automate your server, which means less
    work for you to maintain the server in the future. In this chapter, we''ll cover
    the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经知道如何创建一个在执行命令时运行一些代码的插件。这在许多情况下非常有用。然而，有时我们并不想输入命令。我们更希望代码能够自动触发执行。触发器可以是服务器上发生的一个特定事件，例如方块被破坏、爬行者爆炸，或者玩家在聊天中发送消息。Bukkit事件系统允许开发者监听事件，并根据该事件自动运行一段代码。通过使用Bukkit事件系统，您可以自动化服务器，这意味着您在将来维护服务器时的工作量会减少。在本章中，我们将涵盖以下主题：
- en: Choosing an event
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个事件
- en: Registering an event listener
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册事件监听器
- en: Listening for an event
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听事件
- en: Canceling an event
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消事件
- en: Communicating between events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件之间的通信
- en: Modifying an event as it occurs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在事件发生时修改事件
- en: Creating more plugins on your own
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在自己身上创建更多插件
- en: Choosing an event
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择一个事件
- en: All the events that Bukkit provides can be found in the API documentation in
    the `org.bukkit.event` package. Each event is categorized into packages within
    `org.bukkit.event`, such as `org.bukkit.event.block`, `org.bukkit.event.player`,
    and `org.bukkit.event.world`. This makes it easy to find the event that you are
    looking for. A full list of the Bukkit events can be found at [https://hub.spigotmc.org/javadocs/spigot/org/bukkit/event/class-use/Event.html](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/event/class-use/Event.html).
    I encourage you to take a look at the list to see what type of event you can listen
    for. Each event has several methods, which give you more information and allow
    you to modify the event. For example, `BlockBreakEvent` provides methods to get
    the block that was broken and the player who broke it. Most events can also be
    canceled if you wish to not allow the events to occur. This is useful in many
    situations, such as not letting a new player place a TNT block, or preventing
    a mob from spawning.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Bukkit提供的所有事件都可以在`org.bukkit.event`包的API文档中找到。每个事件都被分类到`org.bukkit.event`包内的各个包中，例如`org.bukkit.event.block`、`org.bukkit.event.player`和`org.bukkit.event.world`。这使得查找所需的事件变得容易。Bukkit事件的完整列表可以在[https://hub.spigotmc.org/javadocs/spigot/org/bukkit/event/class-use/Event.html](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/event/class-use/Event.html)找到。我鼓励您查看列表，看看您可以监听哪种类型的事件。每个事件都有几个方法，这些方法提供了更多信息，并允许您修改事件。例如，`BlockBreakEvent`提供了获取被破坏的方块和破坏它的玩家的方法。大多数事件也可以取消，如果您不希望事件发生。这在许多情况下都很有用，例如不让新玩家放置TNT方块，或者防止怪物生成。
- en: As mentioned earlier, listening to events can aid in automating your server
    and reducing the number of commands being sent. In addition to that, they can
    simply be a lot of fun to work with. Let's look at a few examples of plugins that
    can be made using the Bukkit event system. We mentioned that you can listen to
    the player chat event and modify it as you please. You can use this to monitor
    messages and censor the offensive words that may be spoken. Placing TNT blocks
    was also mentioned. You can create a plugin that only lets players place TNT if
    they have the `build.tnt` permission node. There is also a `WeatherChangeEvent
    class` that can be canceled. That being said, there are many server administrators
    who don't like it when it rains on the server. Rain can be loud and annoying.
    Admins will issue the `/toggledownfall` command to stop the rain every time it
    starts. In this chapter, we will create a plugin that prevents rain from starting
    in the first place.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，监听事件可以帮助自动化你的服务器并减少发送的命令数量。除此之外，它们还可以非常有乐趣去操作。让我们看看一些可以使用Bukkit事件系统制作的插件示例。我们提到你可以监听玩家聊天事件并随意修改它。你可以用它来监控消息并屏蔽可能被说出的冒犯性词语。放置TNT方块也被提到了。你可以创建一个插件，只有当玩家有`build.tnt`权限节点时才允许他们放置TNT。还有一个可以取消的`WeatherChangeEvent`类。话虽如此，有许多服务器管理员不喜欢服务器下雨。雨声可能很大，很烦人。管理员会在每次雨开始时发出`/toggledownfall`命令来停止雨。在本章中，我们将创建一个插件，防止雨一开始就下起来。
- en: The first thing that we must do is find the appropriate event that we can listen
    for. To accomplish this, we will have a look at the Bukkit API documentation.
    Let's say that we are unfamiliar with the API. Therefore, we are unsure about
    which event we can use. We can look through the list of events until we find the
    correct one, but you may have better luck if you first find the right package.
    There are two categories that rain could fall under, namely world events or weather
    events. It is more likely that rain would be categorized under weather. So, we
    will look there first. There is no event that includes the word "rain" because
    rain is categorized with snow. Therefore, the event that we are looking for is
    the `WeatherChangeEvent class`. If you did not find a correct event to use, look
    in other packages.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事是找到我们可以监听的正确事件。为了完成这个任务，我们将查看Bukkit API文档。假设我们对API不熟悉。因此，我们不确定可以使用哪个事件。我们可以查看事件列表，直到找到正确的一个，但如果你首先找到正确的包，你可能会有更好的运气。雨可能属于两个类别之一，即世界事件或天气事件。雨更有可能被归类为天气。所以，我们首先会查看那里。没有包含“雨”这个词的事件，因为雨被归类在雪里。因此，我们要找的事件是`WeatherChangeEvent`类。如果你没有找到正确的事件来使用，请查看其他包。
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are ever unable to find the event that you are looking for, then remember
    that you can ask for help on the Bukkit/Spigot forums. You can perhaps perform
    a search on the forums first to check whether anyone else was looking for the
    same information. It is possible that the event that you are attempting to listen
    for does not exist. Keep in mind that the Spigot project is not associated with
    the creators of Minecraft. Therefore, it is impossible to detect or modify some
    events.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你找不到你正在寻找的事件，那么请记住，你可以在Bukkit/Spigot论坛上寻求帮助。你也许可以先在论坛上搜索，看看是否有人正在寻找相同的信息。有可能你试图监听的事件根本不存在。请记住，Spigot项目与Minecraft的创作者无关。因此，检测或修改某些事件是不可能的。
- en: Now that we have found the event, we wish to prevent this event from occurring.
    Viewing the `WeatherChangeEvent` class reference page, we will see several methods
    that are offered in this event. We will use the `setCancelled` method to cancel
    the event and the `toWeatherState` method to ensure that we are only preventing
    the rain from starting and not stopping.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经找到了事件，我们希望阻止这个事件的发生。查看`WeatherChangeEvent`类的参考页面，我们会看到在这个事件中提供了一些方法。我们将使用`setCancelled`方法来取消事件，并使用`toWeatherState`方法来确保我们只阻止雨开始，而不是停止。
- en: Registering an event listener
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册事件监听器
- en: After deciding which event we will listen for, it is time to start programming.
    Create a new project, as described in [Chapter 3](part0026_split_000.html#OPEK1-b66e70deee6e4ed481db4b113e303f23
    "Chapter 3. Creating Your First Bukkit Plugin"), *Creating Your First Bukkit Plugin*,
    and call it `NoRain`. Don't forget to create a `plugin.yml` file as well.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定我们将监听哪个事件之后，是时候开始编程了。创建一个新的项目，如[第3章](part0026_split_000.html#OPEK1-b66e70deee6e4ed481db4b113e303f23
    "第3章。创建你的第一个Bukkit插件")中所述，*创建你的第一个Bukkit插件*，并将其命名为`NoRain`。别忘了创建一个`plugin.yml`文件。
- en: 'In order to listen for an event, your plugin must have a class that is registered
    as a `Listener class`. We will only have one class, named `NoRain.java`, for this
    project. Therefore, we will make this a `Listener` class as well. The class declaration
    will look like the following line of code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了监听一个事件，你的插件必须有一个注册为`Listener class`的类。在这个项目中，我们只有一个类，名为`NoRain.java`。因此，我们将这个类也作为`Listener`类。类的声明将类似于以下代码行：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Alternatively, if this is a large project, you can make a class for the `Listener
    class`, which is similar to how the `Enchanter` project had `CommandExecutor`
    as a separate class. Also, like `CommandExecutor`, a `Listener class` will implement
    an `interface method`. The `interface method` that we wish to implement is `org.bukkit.event.Listener`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果这是一个大型项目，你可以为`Listener class`创建一个类，这类似于`Enchanter`项目有`CommandExecutor`作为单独的类。同样，像`CommandExecutor`一样，`Listener
    class`将实现一个`interface method`。我们希望实现的`interface method`是`org.bukkit.event.Listener`。
- en: 'The class is declared as a `Listener` class but it is still not registered
    with Bukkit. To register all the events within the listener, insert the following
    line of code in the `onEnable` method:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 类被声明为`Listener`类，但它还没有在Bukkit中注册。为了在监听器中注册所有事件，请在`onEnable`方法中插入以下代码行：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This line retrieves the `PluginManager class` and uses it to register the events.
    The `PluginManager class` is used for several things, including handling events,
    enabling/disabling plugins, and handling player permissions. Most of the time,
    you will use it to register event listeners. It has a `registerEvents` method
    that takes a `Listener` object and a `JavaPlugin` object as parameters. The only
    class that exists is both the `Listener` and `JavaPlugin`. So, we will pass the
    `this` object to both the parameters. If the `Listener` class is separated from
    the `main` class, then the line will look like the following line of code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码检索`PluginManager class`并使用它来注册事件。`PluginManager class`用于多个目的，包括处理事件、启用/禁用插件和处理玩家权限。大多数时候，你会用它来注册事件监听器。它有一个`registerEvents`方法，该方法接受一个`Listener`对象和一个`JavaPlugin`对象作为参数。唯一存在的类既是`Listener`也是`JavaPlugin`。因此，我们将`this`对象传递给这两个参数。如果`Listener`类与`main`类分离，那么这行代码将类似于以下代码行：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is all that is needed within the `onEnable` method.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`onEnable`方法中所需的所有内容。
- en: Listening for an event
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听事件
- en: 'The next method that we will create is an `EventHandler method`. We will use
    the `@EventHandler` annotation to tell Bukkit which methods are event listeners.
    Create a new method that has an event of our choice as the only parameter:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要创建的方法是`EventHandler method`。我们将使用`@EventHandler`注解来告诉Bukkit哪些方法是事件监听器。创建一个新的方法，该方法只有一个我们选择的事件作为唯一参数：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The method must be `public`, and it should not return anything. You can name
    this method anything you wish, but most programmers will keep the name similar
    to the name of the event.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法必须是`public`的，并且不应该返回任何内容。你可以给这个方法取任何你想要的名称，但大多数程序员会保持名称与事件名称相似。
- en: 'Next, we will indicate that this method handles events. Just above the method,
    add the following annotation:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将指示这个方法处理事件。在方法上方添加以下注解：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'On the same line, we can modify some properties for the `EventHandler method`.
    A property that you are likely to add to all the `EventHandler` methods is the
    one that ignores the canceled events. Setting the `ignoreCancelled` property to
    `true` will result in the method looking like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一行，我们可以修改`EventHandler method`的一些属性。你可能会添加到所有`EventHandler`方法中的一个属性是忽略已取消的事件。将`ignoreCancelled`属性设置为`true`将使方法看起来像这样：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the event is already canceled by another plugin, then we don't want to bother
    listening to it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件已经被其他插件取消，那么我们不想去麻烦监听它。
- en: 'The other property is the event priority. By changing the priority of the `EventHandler
    method`, you can choose to listen for the event before or after other plugins.
    If the `EventHandler method` has a higher priority than another event, then it
    is called after the other `EventHandler method` and thus may override anything
    that the first `EventHandler` method has modified. There are six priority levels,
    and they are called in the following order:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个属性是事件优先级。通过更改`EventHandler方法`的优先级，你可以选择在或其他插件之前或之后监听事件。如果`EventHandler方法`的优先级高于另一个事件，则它将在其他`EventHandler方法`之后被调用，因此可能会覆盖第一个`EventHandler方法`所做的任何修改。有六个优先级级别，它们的调用顺序如下：
- en: LOWEST
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LOWEST
- en: LOW
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LOW
- en: NORMAL
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NORMAL
- en: HIGH
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HIGH
- en: HIGHEST
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HIGHEST
- en: MONITOR
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MONITOR
- en: Thus, the plugins with the `LOWEST` priority are called first. Imagine that
    you have a protection plugin. You would not want any other plugin to reverse its
    decision to cancel an event. Therefore, you would set the priority to `HIGHEST`
    so that no other plugins would be able to modify the event after yours. By default,
    each `EventHandler method` has a `NORMAL` priority. If you are not modifying the
    event, then you will most likely want to listen at the `MONITOR` level. The `MONITOR`
    priority should not be used when modifying the event, such as canceling it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，具有`LOWEST`优先级的插件首先被调用。想象一下，你有一个保护插件。你不想任何其他插件取消你的取消事件的决定。因此，你会将优先级设置为`HIGHEST`，这样就没有其他插件能够在你的插件之后修改事件。默认情况下，每个`EventHandler方法`都有一个`NORMAL`优先级。如果你没有修改事件，那么你很可能会想在`MONITOR`级别监听。在修改事件（如取消它）时不应使用`MONITOR`优先级。
- en: 'We want to cancel this event before plugins that have a `NORMAL` priority even
    see it. Therefore, let''s change the priority of this event to `LOW`. Now, the
    line that is above the method looks like the following line of code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在具有`NORMAL`优先级的插件看到此事件之前取消此事件。因此，让我们将此事件的优先级更改为`LOW`。现在，方法上面的行看起来像以下代码行：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Canceling an event
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消事件
- en: 'Finally, we want to stop the weather from changing. To do so, we will call
    the `setCancelled` method of the event. The method takes a `Boolean` value as
    a parameter. We want `canceled` to equal `true`. Therefore, we will use the `setCancelled(true)`
    code, which is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望停止天气变化。为此，我们将调用事件的`setCancelled`方法。此方法接受一个`Boolean`值作为参数。我们希望`canceled`等于`true`。因此，我们将使用`setCancelled(true)`代码，如下所示：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This plugin will work as is. However, there is room for improvement. What if
    it is already raining in the server world? This plugin would prevent the rain
    from ever stopping. Let''s add an `if` statement so that the `WeatherChangeEvent
    class` will only be canceled if the weather is starting. The event provides us
    with a method called `toWeatherState`, which returns a `Boolean` value. This method
    will return `true` or `false`, informing us about whether the weather is starting
    or stopping respectively. This is also made clear in the API documentation:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件将按原样工作。然而，还有改进的空间。如果服务器世界中已经下雨了怎么办？这个插件将阻止雨永远停止。让我们添加一个`if`语句，以便只有当天气开始时，`WeatherChangeEvent类`才会被取消。事件提供了一个名为`toWeatherState`的方法，它返回一个`Boolean`值。此方法将返回`true`或`false`，告诉我们天气是开始还是停止。这也在API文档中得到了明确说明：
- en: '![Canceling an event](img/00038.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![取消事件](img/00038.jpeg)'
- en: 'If `toWeatherState` returns `true`, then it is starting to rain. This is the
    case where we want to cancel the event. Now, let''s write the same thing in Java,
    as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`toWeatherState`返回`true`，那么天气开始下雨。这是我们想要取消事件的情况。现在，让我们用Java写出同样的事情，如下所示：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After adding this `if` statement, you should test your plugin. Before installing
    the plugin, log on to your server and use the `/toggledownfall` command to make
    it rain. Once it is raining, install your newly created plugin and reload the
    server. At this point, it will still be raining, but you will be able to stop
    the rain by issuing the `/toggledownfall` command again. If you cannot do so,
    then the `if` statement that you added may be incorrect; review it to find your
    mistake and test it again. Once you stop the rain, you can try to use the same
    command to start the rain again. As long as the code is correct, the rain should
    not start. If the rain does start, then verify that your event listener is being
    properly registered within the `onEnable` method. Also, verify that the server
    is enabling the correct version of the plugin, as explained in [Chapter 4](part0033_split_000.html#VF2I1-b66e70deee6e4ed481db4b113e303f23
    "Chapter 4. Testing on the Spigot Server"), *Testing on the Spigot Server*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这个`if`语句后，你应该测试你的插件。在安装插件之前，登录到你的服务器并使用`/toggledownfall`命令来下雨。一旦下雨，安装你新创建的插件并重新加载服务器。此时，雨仍然在下，但你可以通过再次发出`/toggledownfall`命令来停止雨。如果你无法这样做，那么你添加的`if`语句可能是不正确的；复查它以找到你的错误并再次测试。一旦你停止了雨，你可以尝试使用相同的命令再次开始雨。只要代码正确，雨就不会开始。如果雨开始了，那么请验证你的事件监听器是否在`onEnable`方法中被正确注册。还要验证服务器是否启用了正确的插件版本，如[第4章](part0033_split_000.html#VF2I1-b66e70deee6e4ed481db4b113e303f23
    "第4章。在Spigot服务器上测试")中所述，*在Spigot服务器上测试*。
- en: Communicating among events
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件之间的通信
- en: The plugin works exactly as intended, but what if we have a change of heart
    and begin to miss the sound of rain? Alternatively, what if our town bursts into
    flames and it must be extinguished quickly? We do not want to limit our power
    as an administrator by denying ourselves the use of the `/toggledownfall` command.
    Next, we will listen for this command to be issued, and when it is issued, we
    will allow the weather to change. Ultimately, we will still be able to control
    the weather manually, but the weather will not start on its own.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 插件完全按照预期工作，但如果我们改变主意，开始怀念雨声怎么办？或者，如果我们的城镇突然起火，必须迅速扑灭怎么办？我们不希望通过拒绝使用`/toggledownfall`命令来限制我们作为管理员的力量。接下来，我们将监听这个命令的发出，并在它被发出时允许天气变化。最终，我们仍然可以手动控制天气，但天气不会自行开始。
- en: 'Let''s create another `EventHandler method`. This time, we will listen for
    a console command being sent so that we can set a Boolean flag, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再创建另一个`EventHandler`方法。这次，我们将监听控制台命令的发送，以便我们可以设置一个布尔标志，如下所示：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We will not actually be modifying this event at all. Therefore, the event priority
    will be set to `MONITOR`. We also want to ignore canceled events. The event that
    we will listen for is `PlayerCommandPreprocessEvent`, which will occur every time
    a player issues a command, whether they are for Minecraft, Bukkit, or another
    plugin. We only care about one command, namely `/toggledownfall`. So, the first
    `if` statement checks whether the message starts with `/toggledownfall`. If it
    is a different command, we will ignore it. As the event name suggests, this event
    occurs before the command is actually executed. Therefore, we must verify that
    a player has the permission to run the command. The permission node for the command
    is `minecraft.command.toggledownfall`. If these two conditions are met, then we
    want to allow rain to start on the next `WeatherChangeEvent class`. The second
    `EventHandler method` is completed by using the two `if` statements and setting
    a Boolean variable to `false`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上不会对这次活动进行任何修改。因此，活动优先级将被设置为`MONITOR`。我们还想忽略已取消的事件。我们将监听的事件是`PlayerCommandPreprocessEvent`，这个事件会在玩家发出命令时发生，无论这些命令是针对Minecraft、Bukkit还是其他插件。我们只关心一个命令，即`/toggledownfall`。因此，第一个`if`语句检查消息是否以`/toggledownfall`开头。如果是一个不同的命令，我们将忽略它。正如事件名称所暗示的，这个事件在命令实际执行之前发生。因此，我们必须验证玩家是否有权运行该命令。该命令的权限节点是`minecraft.command.toggledownfall`。如果这两个条件都满足，那么我们希望在下一个`WeatherChangeEvent`类中允许雨开始。第二个`EventHandler`方法通过使用两个`if`语句并设置一个布尔变量为`false`来完成。
- en: At this point, a light bulb will appear, informing you that the `denyRain` symbol
    cannot be found. When you click on the bulb, you can select `Create Field denyRain
    in com.codisimus.norain.NoRain`. This will automatically create a private variable
    called `denyRain` inside the class. Note the placement of the new line of code.
    It is outside the existing method blocks and yet still inside the class. This
    is important because it defines the variable's scope. The scope of a variable
    is where it can be accessed. The `denyRain` variable is private. Therefore, no
    other class, such as a class from another plugin, can modify it. However, within
    the `NoRain` class, all the methods can access it. This is useful because if the
    variable was declared within the curly braces of the `onPlayerCommand` method,
    we would not be able to see it from the `onWeatherChange` method.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，一个灯泡会出现，告诉你找不到 `denyRain` 符号。当你点击灯泡时，你可以选择 `在 com.codisimus.norain.NoRain
    中创建字段 denyRain`。这将自动在类中创建一个名为 `denyRain` 的私有变量。注意新代码行的位置。它位于现有方法块之外，但仍在类内部。这很重要，因为它定义了变量的作用域。变量的作用域是它可以被访问的地方。`denyRain`
    变量是私有的。因此，其他类，例如来自另一个插件的类，不能修改它。然而，在 `NoRain` 类内部，所有方法都可以访问它。这很有用，因为如果变量是在 `onPlayerCommand`
    方法的花括号内声明的，我们就无法从 `onWeatherChange` 方法中看到它。
- en: 'Now that the plugin knows when we wish to allow the rain to start, we must
    slightly modify the `onWeatherChange` method to allow for such an exception. Currently,
    to cancel the event, we will call the `setCancelled` method with `true` as the
    parameter. If we were to pass `false` as a parameter, then the event would not
    be cancelled. The `denyRain` variable is equal to `true` when we wish to cancel
    the event. Therefore, rather than passing `true` or `false`, we can pass the value
    of `denyRain`. So, when `denyRain` is set to `false`, we will call `setCancelled`
    using the following line of code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在插件知道我们希望在何时允许雨开始，我们必须稍微修改 `onWeatherChange` 方法以允许这种例外。目前，要取消事件，我们将使用 `true`
    作为参数调用 `setCancelled` 方法。如果我们传递 `false` 作为参数，那么事件将不会被取消。当我们要取消事件时，`denyRain` 变量等于
    `true`。因此，而不是传递 `true` 或 `false`，我们可以传递 `denyRain` 的值。所以，当 `denyRain` 设置为 `false`
    时，我们将使用以下代码行调用 `setCancelled`：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At the end of the `onWeatherChange` method, we want to reset the value of `denyRain`
    to `true`. In this way, we can ensure that we allow the weather to change only
    once each time the `/toggledownfall` command is issued. The final code looks like
    this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `onWeatherChange` 方法的末尾，我们希望将 `denyRain` 的值重置为 `true`。这样，我们可以确保每次发出 `/toggledownfall`
    命令时只允许天气改变一次。最终的代码如下：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that when we declare the Boolean `denyRain method`, we set its initial
    value to `true`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们声明布尔型 `denyRain` 方法时，我们将其初始值设置为 `true`。
- en: This completes the `NoRain` plugin. Build the JAR file and test it out on your
    server. With this new version, you will be able to use the `/toggledownfall` command
    to stop and start rain.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了 `NoRain` 插件。构建 JAR 文件并在你的服务器上测试它。使用这个新版本，你将能够使用 `/toggledownfall` 命令来停止和开始雨。
- en: Modifying an event as it occurs
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在事件发生时修改事件
- en: The Bukkit API allows a programmer to do more than just cancel an event. Depending
    on the event, you can modify many of its aspects. In this next project, we will
    modify zombies as they spawn. Every time a zombie spawns, we will give it `40`
    health rather than the default `20`. This will make zombies more difficult to
    kill.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Bukkit API 允许程序员做的不仅仅是取消一个事件。根据事件的不同，你可以修改其许多方面。在接下来的项目中，我们将修改僵尸在生成时的属性。每次僵尸生成时，我们将给它
    `40` 点生命值，而不是默认的 `20` 点。这将使僵尸更难被杀死。
- en: 'Create a new project as you would for any plugin. We will call this plugin
    `MobEnhancer`. Similar to what we did with the `NoRain` plugin, have the `main`
    class implement `Listener` and add the following line of code to the `onEnable`
    method to register the `EventHandlers method`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的项目，就像为任何插件做的那样。我们将把这个插件命名为 `MobEnhancer`。类似于我们为 `NoRain` 插件所做的那样，让 `main`
    类实现 `Listener` 并在 `onEnable` 方法中添加以下代码行以注册 `EventHandlers` 方法：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For this project, we will have an `EventHandler method` that listens for mobs
    spawning. This will be the `CreatureSpawnEvent class`. This event has many methods
    that we can call to either modify the event or gain more information about it.
    We only wish to modify zombies that are spawned. Therefore, the first thing that
    we will add is an `if` statement, which will check whether the `EntityType method`
    is `ZOMBIE`. This is done by using the following block of code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将有一个`EventHandler`方法来监听怪物生成。这将是一个`CreatureSpawnEvent`类。这个事件有许多我们可以调用的方法，要么修改事件，要么获取更多关于它的信息。我们只想修改生成的僵尸。因此，我们将首先添加一个`if`语句，检查`EntityType`方法是否为`ZOMBIE`。这是通过以下代码块完成的：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Inside the curly braces, we will change the health of the `Entity class` to
    `40`. We can retrieve the `Entity` class by calling `event.getEntity()`. Once
    we have the `Entity class`, we have access to many additional methods. You can
    view all of these methods in the API documentation, which is available at [https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/Entity.html](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/Entity.html).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在大括号内，我们将把`Entity class`的健康值改为`40`。我们可以通过调用`event.getEntity()`来检索`Entity`类。一旦我们有了`Entity`类，我们就能够访问许多额外的功能。你可以在API文档中查看所有这些方法，该文档可在[https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/Entity.html](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/Entity.html)找到。
- en: 'One of the methods is `setHealth`. Before we can set the health to `40`, we
    must set the maximum health, which can have a value of `40`. An `Entity class`
    cannot have a health of `40` when its maximum health is still `20`. These two
    lines of code will complete this plugin. The code now looks like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个方法是`setHealth`。在我们将健康值设置为`40`之前，我们必须设置最大健康值，其值可以是`40`。当实体的最大健康值仍然是`20`时，`Entity
    class`不能有`40`的健康值。这两行代码将完成此插件。现在的代码看起来是这样的：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first version of the `MobEnhancer` plugin is complete with this small class.
    You can test the plugin by installing it on your server. You will notice that
    zombies will be much more difficult to kill.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`MobEnhancer`插件的第一个版本就完成了这个小类。你可以通过在你的服务器上安装它来测试插件。你会注意到僵尸将更难被杀死。'
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that we declared a local variable named `health` of the `int` type and
    set its value to `40`. Alternatively, we could simply write `40` in the two lines
    that follow. However, programming the amount of health this way allows us to easily
    change it in the future. We only have to change the number in one line of code
    rather than two or more. Also, you may have noticed that the `setMaxHealth` and
    `setHealth` methods accept a variable of the `double` type. However, an `int`
    value may still be passed to the method, as it will be automatically converted
    to a `double` value with a value of `40`.`0`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们声明了一个名为`health`的局部变量，其类型为`int`，并将其值设置为`40`。或者，我们可以在接下来的两行中简单地写`40`。然而，以这种方式编程健康值允许我们轻松地在将来更改它。我们只需更改一行代码中的数字，而不是两行或更多。此外，你可能已经注意到`setMaxHealth`和`setHealth`方法接受`double`类型的变量。然而，仍然可以将`int`值传递给该方法，因为它将被自动转换为具有值`40.0`的`double`值。
- en: You can add more code to the plugin in order to modify the health of more types
    of entities. A list of all the `EntityType methods` can be found in the Bukkit
    API documentation under the `EntityType` class reference page at [https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/EntityType.html](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/EntityType.html).
    However, in the next chapter, we will make this plugin configurable in order to
    change the health of every type of `Entity` that spawns.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向插件中添加更多代码来修改更多类型实体的健康状态。所有`EntityType`方法的列表可以在Bukkit API文档中找到，位于`EntityType`类参考页面，具体网址为[https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/EntityType.html](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/EntityType.html)。然而，在下一章中，我们将使此插件可配置，以便更改所有类型`Entity`的生存状态。
- en: Creating more plugins on your own
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你自己的插件中创建更多插件
- en: 'Now that you have created these two plugins, you have a hang of how to properly
    use event listeners. You now have the required knowledge to create hundreds of
    unique plugins on your own. All that you need to get started is a cool idea. Why
    don''t you try making one of the plugins that was suggested earlier in this chapter?
    For more ideas, you know where to look. The Bukkit, Spigot, and Minecraft forums
    or the API documentation are great for inspiration. For example, looking through
    the list of events, I saw the `ExplosionPrimeEvent` class, which is described
    as "**Called when an entity has made a decision to explode**". This event is called
    when a creeper makes that hissing noise that every Minecraft player dreads. When
    this happens, you can send a message to all the nearby players to make it look
    like the creeper is talking to them. First, you will create an `EventHandler method`
    for this event. You will want to return in case the entity is not a creeper. Then,
    you will want to get the entities that are near the creeper (there is a method
    for this within the `Entity` class). For each entity that you get, if it is an
    instance of a player, send them a message, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了这两个插件，你对如何正确使用事件监听器有了基本的了解。你现在有了创建数百个独特插件所需的知识。你开始所需的一切就是一个酷炫的想法。你为什么不尝试制作本章前面建议的插件之一呢？更多想法，你知道该去哪里找。Bukkit、Spigot和Minecraft论坛或API文档都是寻找灵感的绝佳资源。例如，查看事件列表，我看到了`ExplosionPrimeEvent`类，它被描述为“**当实体决定爆炸时调用**”。当爬行者发出每个Minecraft玩家都害怕的嘶嘶声时，会调用此事件。当这种情况发生时，你可以向所有附近的玩家发送消息，让他们看起来像爬行者正在和他们说话。首先，你将为这个事件创建一个`EventHandler方法`。如果你得到的实体不是爬行者，你将想要返回。然后，你将想要获取靠近爬行者的实体（`Entity`类中有一个这样的方法）。对于你得到的每个实体，如果它是一个玩家的实例，就发送给他们以下消息：
- en: '`<Creeper> That sssure isss a nicccee <ItemInHand> you have there. It would
    be a ssssshame if anything happened to it.`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`<Creeper> 那个东西真的很棒，你手里拿着的《ItemInHand》。如果它出了什么问题，那就太遗憾了。`'
- en: In each message, you will replace `<ItemInHand>` with the type of item that
    the player is holding. By this time, I am sure that you have some ideas of your
    own that you are able to implement as well.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在每条消息中，你将用玩家所持物品的类型替换`<ItemInHand>`。到这个时候，我相信你已经有了一些自己的想法，并且能够将它们实现出来。
- en: 'Another good thing that you should know about listeners is how to unregister
    them. You may never need to do this, but if you do ever want to stop modifying
    or canceling an event, then you can use the following code within the `Listener`
    class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该了解关于监听器的一个好处，那就是如何注销它们。你可能永远不需要这样做，但如果你确实想停止修改或取消一个事件，那么你可以在`Listener`类中使用以下代码：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will unregister the entire class. So, if you wish to only unregister specific
    `EventHandler methods`, then you should split them up into separate classes. Unregistering
    the listeners will not be the way to go for the `NoRain` plugin, but it may be
    useful if you add a `/mobenhancer off` command. Then, a `/mobenhancer on` command
    can register the listeners again, which is similar to how we did this in the `onEnable`
    method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将注销整个类。所以，如果你只想注销特定的`EventHandler方法`，那么你应该将它们拆分到单独的类中。对于`NoRain`插件来说，注销监听器不是最佳选择，但如果你在添加`/mobenhancer
    off`命令时，它可能是有用的。然后，一个`/mobenhancer on`命令可以再次注册监听器，这与我们在`onEnable`方法中所做的方式类似。
- en: Summary
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Both the plugins that we made in this chapter have the entire code within a
    single class. However, you may choose to separate these into the main plugin class
    and a listener class. In small plugins like these, it is not necessary. But in
    larger projects, it will keep your code much cleaner. There will be a few differences,
    such as having static variables or passing a variable to another class. In the
    next chapter, we will complete the `MobEnhancer` plugin by adding configuration
    as well as a `reload` command. We will have the `Listener` and `CommandExecutor`
    as a part of the `main` class. Once the plugin is complete, we will go over the
    differences for the same plugin as three individual classes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中制作的两个插件，其全部代码都在一个类中。然而，你可以选择将它们分开到主插件类和监听器类中。在这些小插件中，这并不是必要的。但在更大的项目中，这将使你的代码更加整洁。会有一些差异，比如使用静态变量或将变量传递给另一个类。在下一章中，我们将通过添加配置以及`reload`命令来完成`MobEnhancer`插件。我们将把`Listener`和`CommandExecutor`作为`main`类的一部分。一旦插件完成，我们将回顾同一插件作为三个独立类时的差异。
