- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Putting it All Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we’ve been covering Jakarta EE APIs and specifications
    individually. In this chapter, however, we will develop an application using popular
    Jakarta EE APIs, illustrating how to use them together.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The sample application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating customer data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing customer data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating customer data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting customer data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing pagination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to develop a complete
    application combining several popular Jakarta EE APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Example source code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch15_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch15_src)
  prefs: []
  type: TYPE_NORMAL
- en: The sample application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sample application that we will develop in this chapter is a typical CRUD
    (Create, Read, Update and Delete) application. We will be using CDI to develop
    our controllers, Jakarta Persistence as our Object-Relational Mapping tool, leveraging
    Jakarta Enterprise Beans to handle transactions, plus Jakarta Faces to develop
    the user interface. We’ll cover some advanced Jakarta Faces features such as developing
    custom converters and implementing custom **Expression Language** (**EL**) Resolvers.
  prefs: []
  type: TYPE_NORMAL
- en: The application is a web-based application used to maintain customers in a database.
    It provides functionality to view all customers, views details for a single customer,
    and updates and deletes new customers.
  prefs: []
  type: TYPE_NORMAL
- en: The landing page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our application’s landing page is a very simple Facelets page, that has a simple
    command link that invokes a method on the main controller, as shown in the following
    snippet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The main controller for our application is a class called `CustomerController`.
    It is implemented as a session-scoped CDI named bean. When the user clicks on
    the link on the page, our Facelets page invokes a method called `listSetup()`
    on our controller. This method does some initialization and then directs the user
    to a page displaying all existing customers, as illustrated in the following code
    segment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `listSetup()` method in our controller invokes a `reset()` method which
    is used for pagination (more on that later), then returns a string matching the
    path of the page that displays the list of existing customers.
  prefs: []
  type: TYPE_NORMAL
- en: The first time we navigate to the page displaying the list of customers, we
    simply display a message stating that no customers have been found, as the CUSTOMERS
    table in the database is empty.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 15.1 – \uFEFF Empty Customer List](img/B21231_15_01.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 15.1 – Empty Customer List
  prefs: []
  type: TYPE_NORMAL
- en: Our Facelets page has an `<h:outputText>` tag that is rendered only if the list
    of customers is empty.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our Facelets page also has a command button labeled **New Customer**, which
    invokes logic on our controller to insert Customer data into the database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating customer data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The command button on the Facelets page displaying a list of customers invokes
    a method called `createSetup()` on our `CustomerController`, which does some initialization
    before displaying a form allowing the user to enter data for a new customer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `createSetup()` method invokes the `reset()` method, which
    simply clears some data from memory and performs some logic for pagination, then
    creates a new `Customer` object. The `Customer` class is a straightforward JPA
    Entity, it has one too many relationships with two additional JPA Entities, `Address`
    and `Telephone`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `createSetup()` method initializes the lists of `Address` and `Telephone`
    on the new instance of `Customer` to instances of `ArrayList` containing a single
    element of the corresponding type, then navigates to the Facelets page where the
    user can enter data for the new customer. See *Figure 15**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2 – Entering New Customer data](img/B21231_15_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.2 – Entering New Customer data
  prefs: []
  type: TYPE_NORMAL
- en: The markup for our page is a fairly standard Facelets page, it implements some
    custom logic to populate all drop-down menus on the page, for example, to obtain
    the options on the `addressTypeItemsAvailableSelectOne()`, on a CDI bean named
    `AddressTypeController`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `AddressTypeController.getAddressTypeItemsAvailableSelectOne()` method invokes
    a trivial method on a `getSelectItems()` on a utility class called `JSFUtil`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `JSFUtil.getSelectItems()` method iterates through the returned entities
    and returns an array of `SelectItem`, using the return value of the `toString()`
    method of each entities as the label, and the entity itself as the value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The logic to populate other drop-down menus on the page is very similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Save** button on the new customer page is implemented as a command button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The command button invokes a method called `create()` on our `CustomerController`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `CustomerController.create()` method simply invokes a similarly named `create()`
    method on our data access object, the DAO method simply inserts a new row into
    the `CUSTOMERS`, `ADDRESSES` and `TELEPHONES` database tables, which correspond
    to the `Customer`, `Address` and `Telephone` Jakarta Persistence Entities.
  prefs: []
  type: TYPE_NORMAL
- en: The `CustomerrController.create()` method then displays a success message to
    the user if the operation was successful, or an error message if the operation
    failed. It then directs the user to the page listing all customer objects. See
    *Figure 15**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 15.3 – \uFEFFPopulated Customer List](img/B21231_15_03.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 15.3 – Populated Customer List
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created a customer, our **Customer List** page displays a data
    table listing the customer we just created. It contains command links for viewing,
    editing or deleting each customer. We will cover how to view existing customer
    data in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing customer data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned in the previous section, each row on the data table on the **Customer
    List** page has a **View** command link. The markup for the command link looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `<f:param>` tag inside the command link. This tag adds a request
    parameter to the HTTP request created when the user clicks the button.
  prefs: []
  type: TYPE_NORMAL
- en: We are using an advanced Jakarta Faces technique to dynamically generate the
    value of the request parameter. We are using a custom Expression Language resolver,
    so that we can implement custom logic to our Jakarta Faces expression language.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use a custom Expression Language resolver, we need to declare it
    in our application’s `faces-config.xml` `configuration` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we register our custom Expression Language resolver by placing
    its fully qualified name inside the `<el-resolver>` tag in faces-config.xml.
  prefs: []
  type: TYPE_NORMAL
- en: The details of our Expression Language resolver are out of scope, suffice to
    say that its `getValue()` method is invoked automatically when resolving the value
    attribute of `<f:param>`, it uses Java’s reflection API to determine which method
    to call. In our specific example, it calls a method call `getConvertedAsString()`
    in a class called `JsfUtil`, passing an instance of a custom converter called
    `CustomerConverter` as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippet shows the signature of the `getValue()` method of
    our custom `ELResolver`, the GitHub repository for this book contains the complete
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After all is said and done, our `ELResolver` returns the value of the primary
    key for the corresponding `Customer` object.
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks on the `CustomerController.detailSetup()` is invoked, which
    performs some initialization before displaying customer information on the browser.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `CustomerController.detailSetup()` method simply delegates most of its logic
    to the `scalarSetup()` method, which is used every time we need to display information
    about a single customer.
  prefs: []
  type: TYPE_NORMAL
- en: '`CustomerController.scalarSetup()` invokes `JsfUtil.getObjectFromRequestParameter()`,
    passing the request parameter name, and our custom Jakarta Faces converter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`JSFUtil.getObjectFromRequestParameter()`, in turn, uses our custom converter
    to obtain an instance of our `Customer` object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, `JSFUtil` invokes the `getAsObject()` method of our custom Faces
    converter. Our converter, in turn, obtains our session-scoped `CustomerController`
    instance via the Jakarta Faces API, then invokes its `findCustomer()` method to
    obtain the corresponding instance of the `Customer` Jakarta Persistence entity,
    as shown in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Once we obtain the `Customer` instance, control is passed to the **Customer
    Detail** page, which is a basic Facelets page that displays customer information.
    See *Figure 15**.4*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 15.4 – \uFEFFThe Customer Detail page](img/B21231_15_04.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 15.4 – The Customer Detail page
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how we can display customer information, we’ll focus our
    attention on updating existing customer data.
  prefs: []
  type: TYPE_NORMAL
- en: Updating customer data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There isn’t much we haven’t already discussed when it comes to updating customer
    data. The command link labeled **Edit** on each row navigates to the **Edit Customer**
    page. The markup for the command link looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The command link uses the same technique to pass involving a custom Expression
    Language resolver we discussed in the previous section to pass the id of the customer
    to update as a request parameter, then invokes the `CustomerController.editSetup()`
    method which performs some initialization before directing the user to the `CustomerController`
    CDI bean are shown in the following code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `editSetup()` method follows the same pattern we discussed
    when we covered how to navigate to the read-only `scalarSetup()` method to obtain
    the appropriate instance of the Customer entity, then directs the user to the
    **Edit** **Customer** page.
  prefs: []
  type: TYPE_NORMAL
- en: The markup for the **Edit Customer** page is fairly trivial. It includes a number
    of input fields using binding expressions mapping to different fields on the Customer
    entity. It uses the same technique we discussed in the Creating Customer Data
    section to populate all drop-downs on the page. Upon successful navigation, the
    **Edit Customer** page is rendered as illustrated in *Figure 15**.5*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5 – Edit Customer page](img/B21231_15_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.5 – Edit Customer page
  prefs: []
  type: TYPE_NORMAL
- en: 'The `edit()` method on our `CustomerController` class. The markup Our DAO retrieves
    the customer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `edit()` method on `CustomerController`, which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `edit()` method on `CustomerController` performs a sanity check to make
    sure the ID of the customer in memory matches the ID passed as a request parameter,
    and displays an error message if this is not the case. If the sanity check is
    successful, the method invokes the `edit()` method on the `CustomerDao` data access
    object, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `edit()` method on our DAO invokes the `merge()` method on its injected
    `EntityManager`, which updates the corresponding customer data in the database.
    If there is an exception, the method rolls back the transaction and then attempts
    to retrieve the customer from the database. In case the `edit()` method can’t
    find the customer in the database, it displays an error message stating that the
    customer doesn’t exist anymore. The reason why this logic is necessary is because
    another user or process may have deleted our customer from the database while
    our user was updating it.
  prefs: []
  type: TYPE_NORMAL
- en: If the customer data is successfully updated, the user is directed to the **Customer
    Detail** page, displaying updated customer data. See *Figure 15**.6*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6 – Customer Detail page displaying updated customer data](img/B21231_15_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.6 – Customer Detail page displaying updated customer data
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss how our sample application deletes customer
    data from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting customer data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Customer List** page has a link labeled Destroy for each element on the
    table.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 15.7\uFEFF – Customer List page](img/B21231_15_07.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 15.7 – Customer List page
  prefs: []
  type: TYPE_NORMAL
- en: The markup for the **Delete** command link follows the previously discussed
    pattern of setting a request parameter with the ID of the customer to delete,
    as seen in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When clicked, the command link invokes the `destroy()` method on `CustomerController`,
    as shown in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `destroy()` method in `CustomerController` simply invokes the `destroy()`
    method on `CustomerDAO`, passing the customer ID as obtained from the request
    parameter. The controller then navigates back to the **Customer List** page and
    displays a success message upon successful deletion. If there are any exceptions
    when attempting to delete the customer, they are handled appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Our DAO retrieves the customer from the database, using the ID it receives as
    a parameter, performs a sanity check to make sure the data wasn’t deleted by another
    process and then deletes the customer from the database by invoking the `remove()`
    method on the injected `EntityManager` instance, as illustrated below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: After successfully deleting a customer from the database, the **Customer List**
    is displayed, containing a success message indicating the deletion was successful.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.8 – Successful deletion](img/B21231_15_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.8 – Successful deletion
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how our sample application creates, updates, displays and deletes
    data, including some advanced techniques it uses involving custom converters and
    a custom Expression Language resolver.
  prefs: []
  type: TYPE_NORMAL
- en: Our sample application also contains logic to handle pagination when there is
    a large number command link is displayed if thereof customers in the database.
    We will discuss this functionality in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing pagination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard Jakarta Faces data table component simply displays all elements
    on a list on the page. This works fine when we have a small number of elements
    to display, but becomes cumbersome when displaying lots of elements. In many production
    environments, it is not uncommon to have to display hundreds of elements.
  prefs: []
  type: TYPE_NORMAL
- en: Our sample application implements custom pagination logic, if there are more
    than five customers to display, it only displays five customers at a time, then
    has **Previous** and/or **Next** links displayed as appropriate to navigate between
    all customers. *Figure 15**.9* illustrates our custom pagination logic in action.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.9 – Custom pagination](img/B21231_15_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.9 – Custom pagination
  prefs: []
  type: TYPE_NORMAL
- en: Our **Customer List** page renders a **Previous** link to navigate back to the
    previous link, or a **Next** or **Remaining** link to navigate to the next page.
    The **Next** link is rendered if there are at least 5 more customers to display,
    if there are less than 5, then the **Remaining** link is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: All three links are conditionally rendered via the command link’s rendered attribute,
    which takes a boolean expression to determine if the link should be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `renderPrevLink` property on our controller.
  prefs: []
  type: TYPE_NORMAL
- en: The `next()` and `prev()` methods update the value of the `renderPrevLink` property.
    The `next()` method is invoked when either the `prev()` method is invoked when
    the `renderPrevLink` value is used to determine if the **Previous** command link
    should be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The **Next** command link is displayed if there are at least five more customers
    to display.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the logic of the `rendered` attribute is embedded on the page,
    as opposed to relying on the controller as is the case for the **Previous** command
    link.
  prefs: []
  type: TYPE_NORMAL
- en: The **Remaining** command link is displayed if there are less than five customers
    to display on the next page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This command link also embeds the logic of its rendered attribute as an expression
    on the page.
  prefs: []
  type: TYPE_NORMAL
- en: The pagination logic relies on a `PagingInfo` utility class, this class has
    methods to obtain the first and last elements to display, as logic to determine
    which elements to display on every page of our data table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As seen in previous code examples, our controller relies on the `PaginationInfo`
    utility class to implement pagination.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we illustrated how to integrate several Jakarta EE technologies
    via a sample application. We covered the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create customer data by integrating Jakarta Faces, CDI, Jakarta Enterprise
    Beans and Jakarta Persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to view customer data by integrating Jakarta Faces, CDI, Jakarta Enterprise
    Beans and Jakarta Persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to update customer data by integrating Jakarta Faces, CDI, Jakarta Enterprise
    Beans and Jakarta Persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to delete customer data by integrating Jakarta Faces, CDI, Jakarta Enterprise
    Beans and Jakarta Persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement custom pagination logic when displaying tabular data with the
    Jakarta Faces data table component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jakarta EE APIs are designed to work together, and, as seen in this chapter,
    they can be seamlessly integrated to build robust applications.
  prefs: []
  type: TYPE_NORMAL
