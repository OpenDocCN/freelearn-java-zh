["```java\nstatic final VectorSpecies<Double> VS = VectorSpecies.of(\n  double.class, VectorShape.S_512_BIT); \n```", "```java\nstatic final VectorSpecies<Double> VS = VectorSpecies.of(\n  double.class, VectorShape.S_Max_BIT); \n```", "```java\nstatic final VectorSpecies<Double> VS = \n  VectorSpecies.ofLargestShape(double.class); \n```", "```java\nstatic final VectorSpecies<Double> VS = \n  VectorSpecies.ofPreferred(double.class); \n```", "```java\nstatic final VectorSpecies<Double> VS = \n  DoubleVector.SPECIES_512; \n```", "```java\nstatic final VectorSpecies<Double> VS = \n  DoubleVector.SPECIES_MAX; \n```", "```java\nstatic final VectorSpecies<Double> VS = \n  DoubleVector.SPECIES_PREFERRED; \n```", "```java\nSystem.out.println(\"Element type: \" + VS.elementType());\nSystem.out.println(\"Shape: \" + VS.vectorShape()); \n```", "```java\nstatic final VectorSpecies<Integer> VS256 \n  = IntVector.SPECIES_256; \n```", "```java\n// [0, 0, 0, 0, 0, 0, 0, 0]\nVector<Integer> v = VS256.zero(); \n```", "```java\nIntVector v = IntVector.zero(VS256); \n```", "```java\n// [5, 5, 5, 5, 5, 5, 5, 5]\nVector<Integer> v = VS256.broadcast(5); \n```", "```java\nIntVector v = IntVector.broadcast(VS256, 5); \n```", "```java\n// [0, 0, 0, 0, 0, 0, 0, 0]\nVector<Integer> v = VS256.broadcast(0);\nIntVectorv = IntVector.broadcast(VS256, 0); \n```", "```java\nint[] varr = new int[] {0, 1, 2, 3, 4, 5, 6, 7};  \nVector<Integer> v = VS256.fromArray(varr, 0); \n```", "```java\nint[] varr = new int[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\nVector<Integer> v = VS256.fromArray(varr, 0); \n```", "```java\nint[] varr = new int[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\nVector<Integer> v = VS256.fromArray(varr, 2); \n```", "```java\nint[] varr = new int[]{0, 1, 2, 3, 4, 5};\nIntVector v = IntVector.fromArray(VS256, varr, 0); \n```", "```java\nint[] varr = new int[] {0, 1, 2, 3, 4, 5, 6, 7};\nIntVector v = IntVector.fromArray(VS256, varr, 0); \n```", "```java\nint[] varr = new int[]{0, 1, 2, 3, 4, 5, 6, 7};\nboolean[] bm = new boolean[]{\n  false, false, true, false, false, true, true, false};\nVectorMask m = VectorMask.fromArray(VS256, bm, 0);\nIntVector v = IntVector.fromArray(VS256, varr, 0, m); \n```", "```java\nint[] varr = new int[]{11, 12, 15, 17, 20, 22, 29};\nint[] imap = new int[]{0, 0, 0, 1, 1, 6, 6, 6};\nIntVector v = IntVector.fromArray(VS256, varr, 0, imap, 0); \n```", "```java\nint[] varr = new int[]{11, 12, 15, 17, 20, 22, 29};\nboolean[] bm = new boolean[]{\n  false, false, true, false, false, true, true, false};\nint[] imap = new int[]{0, 0, 0, 1, 1, 6, 6, 6};\nVectorMask m = VectorMask.fromArray(VS256, bm, 0);\nIntVector v = IntVector.fromArray(VS256, varr, 0, imap, 0, m); \n```", "```java\nIntVector v;\nMemorySegment segment;\ntry (Arena arena = Arena.ofConfined()) { \n  segment = arena.allocate(32);\n  segment.setAtIndex(ValueLayout.JAVA_INT, 0, 11);\n  segment.setAtIndex(ValueLayout.JAVA_INT, 1, 21);\n  // continue set: 12, 7, 33, 1, 3\n  segment.setAtIndex(ValueLayout.JAVA_INT, 7, 6);\n  v = IntVector.fromMemorySegment(VS256, segment, \n    0, ByteOrder.nativeOrder());\n} \n```", "```java\nint[] x = new int[]{1, 2, 3, 4, 5, 6, 7, 8};\nint[] y = new int[]{4, 5, 2, 5, 1, 3, 8, 7}; \n```", "```java\nIntVector xVector = IntVector.fromArray(\n  IntVector.SPECIES_256, x, 0);\nIntVector yVector = IntVector.fromArray(\n  IntVector.SPECIES_256, y, 0); \n```", "```java\nIntVector zVector = xVector.add(yVector); \n```", "```java\nx = {3, 6, 5, 5, 1, 2, 3, 4, 5, 6, 7, 8, 3, 6, 5, 5, 1, 2, 3, \n     4, 5, 6, 7, 8, 3, 6, 5, 5, 1, 2, 3, 4, 3, 4};\ny = {4, 5, 2, 5, 1, 3, 8, 7, 1, 6, 2, 3, 1, 2, 3, 4, 5, 6, 7, \n     8, 3, 6, 5, 5, 1, 2, 3, 4, 5, 6, 7, 8, 2, 8}; \n```", "```java\npublic static void sum(int x[], int y[], int z[]) {\n  ... \n```", "```java\nprivate static final VectorSpecies<Integer> VS256 \n  = IntVector.SPECIES_256;\n\nint upperBound = VS256.loopBound(x.length); \nfor (int i = 0; i < upperBound; i += VS256.length()) {\n  ...\n} \n```", "```java\nprivate static final VectorSpecies<Integer> VS256 \n  = IntVector.SPECIES_256;\npublic static void sum(int x[], int y[], int z[]) {\n  int upperBound = VS256.loopBound(x.length);   \n  for (int i = 0; i < upperBound; i += VS256.length()) {\n    IntVector xVector = IntVector.fromArray(VS256, x, i);\n    IntVector yVector = IntVector.fromArray(VS256, y, i);\n    IntVector zVector = xVector.add(yVector);\n    zVector.intoArray(z, i);\n  }\n} \n```", "```java\npublic static void sumMask(int x[], int y[], int z[]) {\n  int upperBound = VS256.loopBound(x.length);\n  int i = 0;\n  for (; i < upperBound; i += VS256.length()) {\n    IntVector xVector = IntVector.fromArray(VS256, x, i);\n    IntVector yVector = IntVector.fromArray(VS256, y, i);\n    IntVector zVector = xVector.add(yVector);\n    zVector.intoArray(z, i);\n  }\n**if** **(i <= (x.length -** **1****)) {** \n **VectorMask<Integer> mask** \n **= VS256.indexInRange(i, x.length);**\n**IntVector****zVector****=** **IntVector.fromArray(VS256, x, i, mask)**\n **.add(IntVector.fromArray(VS256, y, i, mask));**\n **zVector.intoArray(z, i, mask);**\n **}**\n} \n```", "```java\npublic static void sumPlus(int x[], int y[], int z[]) {\n  int upperBound = VS256.loopBound(x.length);\n  int i = 0;\n  for (; i < upperBound; i += VS256.length()) {\n    IntVector xVector = IntVector.fromArray(VS256, x, i);\n    IntVector yVector = IntVector.fromArray(VS256, y, i);\n    IntVector zVector = xVector.add(yVector);\n    zVector.intoArray(z, i);\n  }\n  for (; i < x.length; i++) {\n    z[i] = x[i] + y[i];\n  }\n} \n```", "```java\npublic static void sumUnrolled(int x[], int y[], int z[]) {\n int width = VS256.length();\n int i = 0;\n for (; i <= (x.length - width * 4); i += width * 4) {\n  IntVector s1 = IntVector.fromArray(VS256, x, i)\n      .add(IntVector.fromArray(VS256, y, i));\n  IntVector s2 = IntVector.fromArray(VS256, x, i + width)\n      .add(IntVector.fromArray(VS256, y, i + width));\n  IntVector s3 = IntVector.fromArray(VS256, x, i + width * 2)\n      .add(IntVector.fromArray(VS256, y, i + width * 2));\n  IntVector s4 = IntVector.fromArray(VS256, x, i + width * 3)\n      .add(IntVector.fromArray(VS256, y, i + width * 3));\n  s1.intoArray(z, i);\n  s2.intoArray(z, i + width);\n  s3.intoArray(z, i + width * 2);\n  s4.intoArray(z, i + width * 3);\n }\n for (; i < x.length; i++) {\n  z[i] = x[i] + y[i];\n }\n} \n```", "```java\nx = {3, 6, 5, 5, 1, 2, 3, 4, 5, 6, 7, 8, 3, 6, 5, 5, 1, 2, 3, \n     4, 5, 6, 7, 8, 3, 6, 5, 5, 1, 2, 3, 4, 3, 4};\ny = {4, 5, 2, 5, 1, 3, 8, 7, 1, 6, 2, 3, 1, 2, 3, 4, 5, 6, 7, \n     8, 3, 6, 5, 5, 1, 2, 3, 4, 5, 6, 7, 8, 2, 8};\nint[] z = new int[x.length]; \n```", "```java\nz[i] = x[i] + y[i];\nw[i] = x[i] * z[i] * y[i];\nk[i] = z[i] + w[i] * y[i]; \n```", "```java\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@BenchmarkMode({Mode.AverageTime, Mode.Throughput})\n@Warmup(iterations = 3, time = 1)\n@Measurement(iterations = 5, time = 1)\n@State(Scope.Benchmark)\n@Fork(value = 1, warmups = 0, \n    jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\npublic class Main {\n  private static final VectorSpecies<Integer> VS \n    = IntVector.SPECIES_PREFERRED;\n  ...\n  @Benchmark\n  public void computeWithMask(Blackhole blackhole) {…}\n  @Benchmark\n  public void computeNoMask(Blackhole blackhole) {…}\n  @Benchmark\n  public void computeUnrolled(Blackhole blackhole) {…}\n  @Benchmark\n  public void computeArrays(Blackhole blackhole) {…}\n} \n```", "```java\nfloat[] x = new float[]{1f, 2f, 3f, 5f, 1f, 8f};\nfloat[] y = new float[]{4f, 5f, 2f, 8f, 5f, 4f}; \n```", "```java\nprivate static final VectorSpecies<Float> VS \n  = FloatVector.SPECIES_PREFERRED;\npublic static float vectorFma(float[] x, float[] y) {\n  int upperBound = VS.loopBound(x.length);\n  FloatVector sum = FloatVector.zero(VS);\n  int i = 0;\n  for (; i < upperBound; i += VS.length()) {\n    FloatVector xVector = FloatVector.fromArray(VS, x, i);\n    FloatVector yVector = FloatVector.fromArray(VS, y, i);\n    sum = xVector.fma(yVector, sum); \n  }\n  if (i <= (x.length - 1)) {\n    VectorMask<Float> mask = VS.indexInRange(i, x.length);\n    FloatVector xVector = FloatVector.fromArray(\n      VS, x, i, mask);\n    FloatVector yVector = FloatVector.fromArray(\n      VS, y, i, mask);\n    sum = xVector.fma(yVector, sum);\n  }\n  float result = sum.reduceLanes(VectorOperators.ADD);\n  return result;\n} \n```", "```java\nfloat result = sum.reduceLanes(VectorOperators.ADD); \n```", "```java\nsum= [9.0, 42.0, 6.0, 40.0] \n```", "```java\nprivate static final VectorSpecies<Float> VS \n  = FloatVector.SPECIES_PREFERRED;\npublic static float[] mulMatrix(\n    float[] x, float[] y, int size) {\n  final int upperBound = VS.loopBound(size);\n  float[] z = new float[size * size];\n  for (int i = 0; i < size; i++) {\n    for (int k = 0; k < size; k++) {\n      float elem = x[i * size + k];\n      FloatVector eVector = FloatVector.broadcast(VS, elem);\n      for (int j = 0; j < upperBound; j += VS.length()) {\n        FloatVector yVector = FloatVector.fromArray(\n            VS, y, k * size + j);\n        FloatVector zVector = FloatVector.fromArray(\n            VS, z, i * size + j);\n        zVector = eVector.fma(yVector, zVector);\n        zVector.intoArray(z, i * size + j);\n      }\n    }\n  }\n  return z;\n} \n```", "```java\nprivate static final VectorSpecies<Integer> VS \n  = IntVector.SPECIES_PREFERRED;\npublic static void negativeFilter(\n   int pixel[], int width, int height) {\n  for (int i = 0; i <= (width * height - VS.length()); \n           i += VS.length()) {\n    IntVector alphaVector = IntVector.fromArray(VS, pixel, i)\n      .lanewise(VectorOperators.LSHR, 24).and(0xff);\n    IntVector redVector = IntVector.fromArray(VS, pixel, i)\n      .lanewise(VectorOperators.LSHR, 16).and(0xff);\n    IntVector greenVector = IntVector.fromArray(VS, pixel, i)\n      .lanewise(VectorOperators.LSHR, 8).and(0xff);\n    IntVector blueVector = IntVector.fromArray(VS, pixel, i)\n      .and(0xff);\n    IntVector subAlphaVector\n      = alphaVector.lanewise(VectorOperators.LSHL, 24);\n    IntVector subRedVector = redVector.broadcast(255)\n      .sub(redVector).lanewise(VectorOperators.LSHL, 16);\n    IntVector subGreenVector = greenVector.broadcast(255)\n      .sub(greenVector).lanewise(VectorOperators.LSHL, 8);\n    IntVector subBlueVector\n      = blueVector.broadcast(255).sub(blueVector);\n    IntVector resultVector = subAlphaVector.or(subRedVector)\n      .or(subGreenVector).or(subBlueVector);\n    resultVector.intoArray(pixel, i);\n  } \n} \n```", "```java\nMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"Java Coding Problems, First Edition\");\nmap.put(2, \"The Complete Coding Interview Guide in Java\");\nmap.put(3, \"jOOQ Masterclass\");\nMap<Integer, String> imap = Collections.unmodifiableMap(map); \n```", "```java\nMap<Integer, String> imap = Collections.unmodifiableMap(\n  new HashMap<Integer, String>() {\n    {\n      put(1, \"Java Coding Problems, First Edition\");\n      put(2, \"The Complete Coding Interview Guide in Java\");\n      put(3, \"jOOQ Masterclass\");\n    }\n  }); \n```", "```java\nMap<Integer, String> imap = Stream.of(\n  entry(1, \"Java Coding Problems, First Edition\"),\n  entry(2, \"The Complete Coding Interview Guide in Java\"),\n  entry(3, \"jOOQ Masterclass\"))\n  .collect(collectingAndThen(\n   toMap(e -> e.getKey(), e -> e.getValue()), \n   Collections::unmodifiableMap)); \n```", "```java\nMap<Integer, String> imap = Collections.emptyMap();\nMap<Integer, String> imap = Collections.singletonMap(\n  1, \"Java Coding Problems, First Edition\"); \n```", "```java\nMap<Integer, String> imap = Map.of(\n  1, \"Java Coding Problems, First Edition\",\n  2, \"The Complete Coding Interview Guide in Java\",\n  3, \"jOOQ Masterclass\"\n); \n```", "```java\nimport static java.util.Map.entry;\n...\nMap<Integer, String> imap2jdk9 = Map.ofEntries(\n  entry(1, \"Java Coding Problems, First Edition\"),\n  entry(2, \"The Complete Coding Interview Guide in Java\"),\n  entry(3, \"jOOQ Masterclass\")\n); \n```", "```java\nMap<Integer, String> imap = Map.copyOf(map); \n```", "```java\nList<String> list = new ArrayList<>();\nlist.add(\"Java Coding Problems, First Edition\");\nlist.add(\"The Complete Coding Interview Guide in Java\");\nlist.add(\"jOOQ Masterclass\");\nList<String> ilist = Collections.unmodifiableList(list); \n```", "```java\nList<String> ilist = Arrays.asList(\n  \"Java Coding Problems, First Edition\",\n  \"The Complete Coding Interview Guide in Java\",\n  \"jOOQ Masterclass\"\n); \n```", "```java\nList<String> ilist = Stream.of(\n  \"Java Coding Problems, First Edition\",\n  \"The Complete Coding Interview Guide in Java\",\n  \"jOOQ Masterclass\")\n  .collect(collectingAndThen(toList(), \n           Collections::unmodifiableList)); \n```", "```java\nList<String> ilist = Collections.emptyList();\nList<String> ilist = Collections.singletonList(\n  \"Java Coding Problems, First Edition\"); \n```", "```java\nList<String> ilist = List.of(\n  \"Java Coding Problems, First Edition\",\n  \"The Complete Coding Interview Guide in Java\",\n  \"jOOQ Masterclass\"); \n```", "```java\nList<String> ilist = List.copyOf(list); \n```", "```java\nSet<String> iset = Collections.singleton(\n  \"Java Coding Problems, First Edition\"); \n```", "```java\nList<File> roots = Stream.of(File.listRoots())\n  .collect(Collectors.toList()); \n```", "```java\nList<File> roots = Stream.of(File.listRoots())\n  .collect(Collectors.toUnmodifiableList()); \n```", "```java\ndefault List<T> toList() {\n  return (List<T>) Collections.unmodifiableList(\n    new ArrayList<>(Arrays.asList(this.toArray())));\n} \n```", "```java\nList<File> roots = Stream.of(File.listRoots()).toList(); \n```", "```java\nList<String> list = new ArrayList<>(260); \n```", "```java\nMap<Integer, String> map = new HashMap<>(260); \n```", "```java\n// accommodate 260 mappings without resizing\nMap<Integer, String> map = new HashMap<>(347); \n```", "```java\nMap<Integer, String> map = new HashMap<>(\n  (int) Math.ceil(260 / (double) 0.75)); \n```", "```java\n// accommodate 260 mappings without resizing\nMap<Integer, String> map = HashMap.newHashMap(260); \n```", "```java\nList<String> list = new ArrayList<>(\n  Arrays.asList(\"one\", \"two\", \"three\", \"four\", \"five\"));\nList<String> linkedlist = new LinkedList<>(\n  Arrays.asList(\"one\", \"two\", \"three\", \"four\", \"five\")); \n```", "```java\nString first = list.get(0); // one \n```", "```java\nString last = list.get(list.size() - 1); // five \n```", "```java\nString first = list.getFirst(); // one\nString last = list.getLast();  // five \n```", "```java\nlist.add(0, \"zero\"); // add on the first position\nlist.add(\"six\");     // add on the last position \n```", "```java\nlist.addFirst(\"zero\");\nlist.addLast(\"six\"); \n```", "```java\nlist.remove(0);                // remove the first element\nlist.remove(list.size() - 1);  // remove the last element \n```", "```java\nlist.remove(\"five\"); \n```", "```java\nlist.removeFirst();\nlist.removeLast(); \n```", "```java\nCollections.reverse(list); \n```", "```java\nList<String> reversedList = list.reversed(); \n```", "```java\nSequencedSet<String> linkedhashset = new LinkedHashSet<>(\n  Arrays.asList(\"one\", \"two\", \"three\", \"four\", \"five\")); \n```", "```java\nlinkedhashset.iterator().next();\nlinkedhashset.stream().findFirst().get(); \n```", "```java\nlinkedhashset.stream().skip(\n  linkedhashset.size() - 1).findFirst().get();\nString last = (String) linkedhashset.toArray()\n  [linkedhashset.size() - 1]; \n```", "```java\nlinkedhashset.getFirst();\nlinkedhashset.getLast(); \n```", "```java\n// cannot add on first position\nlinkedhashset.add(\"six\"); //  add on last position \n```", "```java\nlinkedhashset.addFirst(\"zero\");\nlinkedhashset.addLast(\"six\"); \n```", "```java\nlinkedhashset.remove(\"one\");\nlinkedhashset.remove(\"five\"); \n```", "```java\nlinkedhashset.removeFirst();\nlinkedhashset.removeLast(); \n```", "```java\nSequencedSet<String> reversedLhs = linkedhashset.reversed(); \n```", "```java\nSortedSet<String> sortedset = new TreeSet<>(\n  Arrays.asList(\"one\", \"two\", \"three\", \"four\", \"five\")); \n```", "```java\nsortedset.first();\nsortedset.last(); \n```", "```java\nsortedset.getFirst();\nsortedset.getLast(); \n```", "```java\nsortedset.add(\"zero\");\nsortedset.add(\"six\"); \n```", "```java\nString first = sortedset.first();\nsortedset.remove(first);\nString last = sortedset.last();\nsortedset.remove(last); \n```", "```java\nsortedset.removeFirst();\nsortedset.removeLast(); \n```", "```java\nSortedSet<String> reversedSortedSet\n  = new TreeSet<>(sortedset).descendingSet(); \n```", "```java\nSortedSet<String> reversedSortedSet = sortedset.reversed(); \n```", "```java\nSequencedMap<Integer, String> linkedhashmap\n  = new LinkedHashMap<>();\nlinkedhashmap.put(1, \"one\");\nlinkedhashmap.put(2, \"two\");\nlinkedhashmap.put(3, \"three\");\nlinkedhashmap.put(4, \"four\");\nlinkedhashmap.put(5, \"five\"); \n```", "```java\nlinkedhashmap.entrySet().iterator().next();\nlinkedhashmap.entrySet().stream().findFirst().get(); \n```", "```java\nlinkedhashmap.keySet().iterator().next();\nlinkedhashmap.keySet().stream().findFirst().get();\nlinkedhashmap.values().iterator().next();\nlinkedhashmap.values().stream().findFirst().get(); \n```", "```java\nlinkedhashmap.entrySet().stream()\n  .skip(linkedhashmap.size() - 1).findFirst().get();\nEntry<Integer, String> lastEntryLhm = (Entry<Integer, String>)\n  linkedhashmap.entrySet().toArray()[linkedhashmap.size() - 1];\nlinkedhashmap.keySet().stream()\n  .skip(linkedhashmap.size() - 1).findFirst().get();\nInteger lastKeyLhm = (Integer) linkedhashmap.keySet()\n  .toArray()[linkedhashmap.size() - 1];\nlinkedhashmap.values().stream()\n  .skip(linkedhashmap.size() - 1).findFirst().get();\nString lastValueLhm = (String) linkedhashmap.values()\n  .toArray()[linkedhashmap.size() - 1]; \n```", "```java\nEntry<Integer, String> fe = linkedhashmap.firstEntry();\nEntry<Integer, String> le = linkedhashmap.lastEntry(); \n```", "```java\nSequencedSet<Integer> keysLinkedHashMap\n  = linkedhashmap.sequencedKeySet();\nkeysLinkedHashMap.getFirst();\nkeysLinkedHashMap.getLast();\nSequencedCollection<String> valuesLinkedHashMap\n  = linkedhashmap.sequencedValues();\nvaluesLinkedHashMap.getFirst();\nvaluesLinkedHashMap.getLast(); \n```", "```java\nSequencedSet<Entry<Integer, String>> entriesLinkedHashMap\n  = linkedhashmap.sequencedEntrySet();\nentriesLinkedHashMap.getFirst();\nentriesLinkedHashMap.getLast(); \n```", "```java\nSequencedMap<Integer, String> slinkedhashmap\n  = new LinkedHashMap<>();\nslinkedhashmap.put(0, \"zero\"); // add the first entry\nslinkedhashmap.putAll(linkedhashmap);\nslinkedhashmap.put(6, \"six\");  // add the last entry \n```", "```java\nlinkedhashmap.putFirst(0, \"zero\");\nlinkedhashmap.putLast(6, \"six\"); \n```", "```java\nEntry<Integer, String> firstentrylhm\n  = linkedhashmap.entrySet().iterator().next();\nlinkedhashmap.remove(firstentrylhm.getKey());\n// or, like this\nlinkedhashmap.remove(\n  firstentrylhm.getKey(), firstentrylhm.getValue());\nEntry<Integer, String> lastEntryLhm\n  = linkedhashmap.entrySet().stream().skip(\n      linkedhashmap.size() - 1).findFirst().get();\nlinkedhashmap.remove(lastEntryLhm.getKey());\n// or, like this\nlinkedhashmap.remove(\n  lastEntryLhm.getKey(), lastEntryLhm.getValue()); \n```", "```java\nlinkedhashmap.pollFirstEntry();\nlinkedhashmap.pollLastEntry(); \n```", "```java\nSequencedMap<Integer, String> reversedlinkedhashmap\n  = new LinkedHashMap<>();\nSet<Integer> setKeys = linkedhashmap.keySet();\nLinkedList<Integer> listKeys = new LinkedList<>(setKeys);\nIterator<Integer> iterator = listKeys.descendingIterator();\nwhile (iterator.hasNext()) {\n  Integer key = iterator.next();\n  reversedlinkedhashmap.put(key, linkedhashmap.get(key));\n} \n```", "```java\nSequencedMap<Integer, String> reversedMap\n  = linkedhashmap.reversed(); \n```", "```java\nSortedMap<Integer, String> sortedmap = new TreeMap<>();\nsortedmap.put(1, \"one\");\nsortedmap.put(2, \"two\");\nsortedmap.put(3, \"three\");\nsortedmap.put(4, \"four\");\nsortedmap.put(5, \"five\"); \n```", "```java\nInteger fkey = sortedmap.firstKey(); // first key\nString fval = sortedmap.get(fkey);   // first value\nInteger lkey = sortedmap.lastKey();  // last key\nString lval = sortedmap.get(lkey);   // last value \n```", "```java\nsortedmap.firstEntry();\nsortedmap.firstEntry().getKey();\nsortedmap.firstEntry().getValue();\nsortedmap.lastEntry();\nsortedmap.lastEntry().getKey();\nsortedmap.lastEntry().getValue(); \n```", "```java\nSequencedSet<Integer> keysSortedMap\n  = sortedmap.sequencedKeySet();\nkeysSortedMap.getFirst();\nkeysSortedMap.getLast();\nSequencedCollection<String> valuesSortedMap\n  = sortedmap.sequencedValues();\nvaluesSortedMap.getFirst();\nvaluesSortedMap.getLast();\nSequencedSet<Entry<Integer, String>> entriesSortedMap\n  = sortedmap.sequencedEntrySet();\nentriesSortedMap.getFirst();\nentriesSortedMap.getLast(); \n```", "```java\nsortedmap.putFirst(0, \"zero\"); //UnsupportedOperationException\nsortedmap.putLast(6, \"six\");   //UnsupportedOperationException \n```", "```java\nInteger fkey = sortedmap.firstKey();\nString fval = sortedmap.get(fkey);\nInteger lkey = sortedmap.lastKey();\nString lval = sortedmap.get(lkey);\nsortedmap.remove(fkey);\nsortedmap.remove(fkey, fval);\nsortedmap.remove(lkey);\nsortedmap.remove(lkey, lval); \n```", "```java\nsortedmap.pollFirstEntry();\nsortedmap.pollLastEntry(); \n```", "```java\nNavigableMap<Integer, String> reversednavigablemap\n  = ((TreeMap) sortedmap).descendingMap(); \n```", "```java\nSortedMap<Integer, String> reversedsortedmap\n  = sortedmap.reversed(); \n```", "```java\npublic static class Node {\n  private Node left;\n  private Node right;\n  private int weight;\n  private String str;\n  public Node(String str) {\n    this(null, null, str.length(), str);\n  }\n  public Node(Node left, Node right, int weight) {\n    this(left, right, weight, null);\n  }\n  public Node(Node left, Node right, int weight, String str) {\n    this.left = left;\n    this.right = right;\n    this.str = str;\n    this.weight = weight;\n  }\n} \n```", "```java\npublic static char indexAt(Node node, int index) {\n   if (index > node.weight - 1) {\n    return indexAt(node.right, index - node.weight);\n  } else if (node.left != null) {\n    return indexAt(node.left, index);\n  } else {            \n    return node.str.charAt(index);\n  }\n} \n```", "```java\npublic static Node concat(Node node1, Node node2) {\n  return new Node(node1, node2, getLength(node1));\n}\nprivate static int getLength(Node node) {\n  if (node.str != null) {\n    return node.weight;\n  } else {\n    return getLength(node.left) + (node.right == null ? \n      0 : getLength(node.right));\n  }\n} \n```", "```java\npublic static Node insert(Node node, int index, String str) {\n  List<Node> splitRopes = Rope.split(node, index);\n  Node insertNode = new Node(null, null, str.length(), str);\n  Node resultNode;\n  if (splitRopes.size() == 1) {\n    if (index == 0) {\n      resultNode = Rope.concat(insertNode, splitRopes.get(0));\n    } else {\n      resultNode = Rope.concat(splitRopes.get(0), insertNode);\n    }\n  } else { \n    resultNode = Rope.concat(splitRopes.get(0), insertNode);\n    resultNode = Rope.concat(resultNode, splitRopes.get(1));\n  }\n  return resultNode;\n} \n```", "```java\npublic static Node delete(Node node, int start, int end) {\n  Node beforeNode = null;\n  Node afterNode;\n  List<Node> splitRopes1 = Rope.split(node, start);\n  if (splitRopes1.size() == 1) {\n    afterNode = splitRopes1.get(0);\n  } else {\n    beforeNode = splitRopes1.get(0);\n    afterNode = splitRopes1.get(1);\n  }\n  List<Node> splitRopes2 = Rope.split(afterNode, end - start);\n  if (splitRopes2.size() == 1) {\n    return beforeNode;\n  }\n  return beforeNode == null ? splitRopes2.get(1) : \n    Rope.concat(beforeNode, splitRopes2.get(1));\n} \n```", "```java\npublic boolean contains(Integer data) {\n  Node cursorNode = head;\n  for (int i = topLayer - 1; i >= 0; i--) {\n    while (cursorNode.next[i] != null) {\n      if (cursorNode.next[i].getData() > data) {\n        break;\n      }\n      if (cursorNode.next[i].getData().equals(data)) {\n        return true;\n      }\n      cursorNode = cursorNode.next[i];\n    }\n  }\n  return false;\n} \n```", "```java\npublic void insert(Integer data) {\n  int layer = incrementLayerNo();\n  Node newNode = new Node(data, layer);\n  Node cursorNode = head;\n  for (int i = topLayer - 1; i >= 0; i--) {\n    while (cursorNode.next[i] != null) {\n      if (cursorNode.next[i].getData() > data) {\n        break;\n      }\n      cursorNode = cursorNode.next[i];\n    }\n    if (i <= layer) {\n      newNode.next[i] = cursorNode.next[i];\n      cursorNode.next[i] = newNode;\n    }\n  }\n  size++;\n} \n```", "```java\npublic boolean delete(Integer data) {\n  Node cursorNode = head;\n  boolean deleted = false;\n  for (int i = topLayer - 1; i >= 0; i--) {\n    while (cursorNode.next[i] != null) {\n      if (cursorNode.next[i].getData() > data) {\n        break;\n      }\n      if (cursorNode.next[i].getData().equals(data)) { \n        cursorNode.next[i] = cursorNode.next[i].next[i];\n        deleted = true;\n        size--;\n        break;\n      }\n      cursorNode = cursorNode.next[i];\n    }\n  }\n  return deleted;\n} \n```", "```java\nprivate final class Node {\n  private final double[] coords;\n  private Node left;\n  private Node right;\n  public Node(double[] coords) {\n    this.coords = coords;\n  }\n  ...\n} \n```", "```java\ndouble[][] coords = {\n  {3, 5}, {1, 4}, {5, 4}, {2, 3}, {4, 2}, {3, 2}, \n  {5, 2}, {2, 1}, {2, 4}, {2, 5}\n}; \n```", "```java\npublic void insert(double[] coords) {\n  root = insert(root, coords, 0);\n}\nprivate Node insert(Node root, double[] coords, int depth) {\n  if (root == null) {\n    return newNode(coords);\n  }\n  int cd = depth % 2;\n  if (coords[cd] < root.coords[cd]) {\n    root.left = insert(root.left, coords, depth + 1);\n  } else {\n    root.right = insert(root.right, coords, depth + 1);\n  }\n  return root;\n} \n```", "```java\npublic double[] findNearest(double[] coords) {\n  Node targetNode = newNode(coords);\n  visited = 0;\n  foundDistance = 0;\n  found = null;\n  nearest(root, targetNode, 0);\n  return found.coords.clone();\n} \n```", "```java\nprivate void nearest(Node root, Node targetNode, int index) {\n  if (root == null) {\n    return;\n  }\n  visited++;\n  double theDistance = root.theDistance(targetNode);\n  if (found == null || theDistance < foundDistance) {\n    foundDistance = theDistance;\n    found = root;\n  }\n  if (foundDistance == 0) {\n    return;\n  }\n  double rootTargetDistance = root.get(index) -\n    targetNode.get(index);\n  index = (index + 1) % 2;\n  nearest(rootTargetDistance > 0 ? \n    root.left : root.right, targetNode, index);\n  if (rootTargetDistance * \n          rootTargetDistance >= foundDistance) {\n    return;\n  }\n  nearest(rootTargetDistance > 0 ? \n    root.right : root.left, targetNode, index);\n} \n```", "```java\npublic interface Zippable {\n  public Collection<? extends Zippable> getChildren();\n} \n```", "```java\npublic class Node implements Zippable {\n  private final String name;\n  private final List<Node> children;\n  public Node(final String name, final Node... children) {\n    this.name = name;\n    this.children = new LinkedList<>(Arrays.asList(children));\n  }\n  public String getName() {\n    return name;\n  }\n  @Override\n  public Collection<Node> getChildren() {\n    return this.children;\n  }\n  @Override\n  public String toString() {\n    return \"Node{\" + \"name=\" + name \n      + \", children=\" + children + '}';\n  } \n} \n```", "```java\npublic final class ZipNode<T extends Zippable>\n     implements Zippable {\n  private static final Zippable[] DUMMY = new Zippable[0];\n  private final T node;        // wrap the original tree node\n  private Zippable[] children; // list of children \n  // wrap a ZipNode without children    \n  protected ZipNode(final T node) {\n    this(node, DUMMY);\n  }\n  // wrap a ZipNode and its children    \n  protected ZipNode(final T node, Zippable[] children) {\n    if (children == null) {\n      children = new Zippable[0];\n    }\n    this.node = node;\n    this.children = children;\n  } \n```", "```java\n @Override\n  public Collection<? extends Zippable> getChildren() {\n    lazyGetChildren();\n    return (children != null) ? \n      new LinkedList<>(Arrays.asList(children)) : null;\n  } \n  // return the original node\n  public T unwrap() {\n    return node;\n  }\n  public boolean isLeaf() { \n    lazyGetChildren();\n    return children == null || children.length == 0;\n  }\n  public boolean hasChildren() {\n    lazyGetChildren(); \n    return children != null && children.length > 0;\n  }\n  protected Zippable[] children() {\n    lazyGetChildren();\n    return children;\n  }\n  protected ZipNode<T> replaceNode(final T node) {\n    lazyGetChildren();\n    return new ZipNode<>(node, children);\n  }        \n  // lazy initialization of children\n  private void lazyGetChildren() {\n    if (children == DUMMY) {           \n      Collection<? extends Zippable> nodeChildren\n        = node.getChildren();\n      children = (nodeChildren == null) ?\n        null : nodeChildren.toArray(Zippable[]::new);\n    }\n  }\n  @Override\n  public String toString() { \n    return node.toString(); // call the original toString()\n  }\n} \n```", "```java\nfinal class ZipperRange {\n  private final ZipperRange parentRange;\n  private final ZipNode<?> parentZipNode;\n  private final Zippable[] leftSiblings;\n  private final Zippable[] rightSiblings;\n  protected ZipperRange(final ZipNode<?> parentZipNode, \n      final ZipperRange parentRange, final Zippable[]  \n      leftSiblings, final Zippable[] rightSiblings) {\n    this.parentZipNode = parentZipNode;\n    this.parentRange = parentRange;\n    this.leftSiblings = (leftSiblings == null) ? \n      new Zippable[0] : leftSiblings;\n    this.rightSiblings = (rightSiblings == null) ? \n      new Zippable[0] : rightSiblings;\n  }\n  // getters omitted for brevity\n} \n```", "```java\npublic final class Cursor<T extends Zippable> {\n  private final ZipNode<T> zipNode;\n  private final ZipperRange range;\n  protected Cursor(final ZipNode<T> zipNode, \n                   final ZipperRange range) {\n    this.zipNode = zipNode;\n    this.range = range;\n  }\n  ...\n} \n```", "```java\npublic final class Zipper {\n  public static <T extends Zippable>\n        Cursor<T> createZipper(final T node) {\n    return new Cursor<>(new ZipNode<>(node),\n      new ZipperRange(null, null, null, null)); // root range\n  }\n  public static <T extends Zippable> T unwrapZipper(\n        final Cursor<T> tree) {\n    return Zipper.<T>unwrapZipper(tree.root().zipNode());\n  }\n  private static <T extends Zippable> T unwrapZipper(\n        final Zippable node) {\n    if (node instanceof ZipNode<?>) {\n      ZipNode<T> zipNode = (ZipNode<T>) node;\n      T original = zipNode.unwrap();\n      if (!zipNode.isLeaf()) {\n        Collection<T> children \n          = (Collection<T>) original.getChildren();\n        original.getChildren().clear();\n        for (Zippable zipped : zipNode.children()) {\n          children.add((T) unwrapZipper(zipped));\n        }\n      }\n    return original;\n    } else {\n      return (T) node;\n    }\n  }\n} \n```", "```java\npublic class BinomialHeap {\n  private Node head;\n  private final class Node {\n    private int key;\n    private int degree;\n    private Node parent;\n    private Node child;\n    private Node sibling;\n    public Node() {\n      key = Integer.MIN_VALUE;\n    }\n    public Node(int key) {\n      this.key = key;\n    }\n    ...\n  }\n  ...\n} \n```", "```java\npublic void insert(int key) {\n  Node node = new Node(key);\n  BinomialHeap newHeap = new BinomialHeap(node);\n  head = unionHeap(newHeap);\n} \n```", "```java\npublic int findMin() {\n  if (head == null) {\n    return Integer.MIN_VALUE;\n  } else {\n    Node min = head;\n    Node nextNode = min.sibling;\n    while (nextNode != null) {\n      if (nextNode.key < min.key) {\n        min = nextNode;\n      }\n      nextNode = nextNode.sibling;\n    }\n    return min.key;\n  }\n} \n```", "```java\npublic int extractMin() {\n  if (head == null) {\n    return Integer.MIN_VALUE;\n  }\n  Node min = head;\n  Node minPrev = null;\n  Node nextNode = min.sibling;\n  Node nextNodePrev = min;\n  while (nextNode != null) {\n    if (nextNode.key < min.key) {\n      min = nextNode;\n      minPrev = nextNodePrev;\n    }\n    nextNodePrev = nextNode;\n    nextNode = nextNode.sibling;\n  }\n  deleteTreeRoot(min, minPrev);\n  return min.key;\n} \n```", "```java\nprivate void deleteTreeRoot(Node root, Node previousNode) {\n  if (root == head) {\n    head = root.sibling;\n  } else {\n    previousNode.sibling = root.sibling;\n  }\n  Node unionHeap = null;\n  Node child = root.child;\n  while (child != null) {\n    Node nextNode = child.sibling;\n    child.sibling = unionHeap;\n    child.parent = null;\n    unionHeap = child;\n    child = nextNode;\n  }\nBinomialHeap toUnionHeap = new BinomialHeap(unionHeap);\n  head = unionHeap(toUnionHeap);\n} \n```", "```java\npublic void decreaseKey(int key, int newKey) {\n  Node found  = findByKey(key);\n  if (found != null) {\n    decreaseKey(found, newKey);\n  }\n}\nprivate void decreaseKey(Node node, int newKey) {\n  node.key = newKey;\n  goUp(node, false);\n} \n```", "```java\nprivate Node goUp(Node node, boolean goToRoot) {\n  Node parent = node.parent;\n  while (parent != null && (goToRoot\n      || node.key < parent.key)) {\n    int t = node.key;\n    node.key = parent.key;\n    parent.key = t;\n    node = parent;\n    parent = parent.parent;\n  }\n  return node;\n} \n```", "```java\npublic void delete(int key) {\n  Node found = findByKey(key);\n  if (found != null) {\n    delete(found);\n  }\n}\nprivate void delete(Node node) {\n  node = goUp(node, true);\n  if (head == node) {\n    deleteTreeRoot(node, null);\n  } else {\n    Node previousNode = head;\n    while (previousNode.sibling.key != node.key) {\n      previousNode = previousNode.sibling;\n    }\n    deleteTreeRoot(node, previousNode);\n  }\n} \n```", "```java\nprivate Node merge(BinomialHeap h1, BinomialHeap h2) {\n  if (h1.head == null) {\n    return h2.head;\n  } else if (h2.head == null) {\n    return h1.head;\n  } else {\n    Node headIt;\n    Node h1Next = h1.head;\n    Node h2Next = h2.head;\n    if (h1.head.degree <= h2.head.degree) {\n      headIt = h1.head;\n      h1Next = h1Next.sibling;\n    } else {\n      headIt = h2.head;\n      h2Next = h2Next.sibling;\n    }\n    Node tail = headIt;\n    while (h1Next != null && h2Next != null) {\n      if (h1Next.degree <= h2Next.degree) {\n        tail.sibling = h1Next;\n        h1Next = h1Next.sibling;\n      } else {\n        tail.sibling = h2Next;\n        h2Next = h2Next.sibling;\n      }\n      tail = tail.sibling;\n    }\n    if (h1Next != null) {\n      tail.sibling = h1Next;\n    } else {\n      tail.sibling = h2Next;\n    }\n    return headIt;\n  }\n} \n```", "```java\nprivate Node unionHeap(BinomialHeap heap) {\n  Node mergeHeap = merge(this, heap); \n  head = null;\n  heap.head = null;\n  if (mergeHeap == null) {\n    return null;\n  }\n  Node previousNode = null;\n  Node currentNode = mergeHeap;\n  Node nextNode = mergeHeap.sibling;\n  while (nextNode != null) {\n    if (currentNode.degree != nextNode.degree\n        || (nextNode.sibling != null\n        && nextNode.sibling.degree == currentNode.degree)) {\n**[C:****1****,****2****]** previousNode = currentNode;\n**[C:****1****,****2****]** currentNode = nextNode;\n     } else {\n       if (currentNode.key < nextNode.key) {\n**[C:****3****]**    currentNode.sibling = nextNode.sibling;\n**[C:****3****]**    linkNodes(currentNode, nextNode);\n**[C:****4****]**  } else {\n**[C:****4****]**    if (previousNode == null) {\n**[C:****4****]**      mergeHeap = nextNode;\n**[C:****4****]**    } else {\n**[C:****4****]**      previousNode.sibling = nextNode;\n**[C:****4****]**   }\n**[C:****4****]**\n**[C:****4****]**     linkNodes(nextNode, currentNode);\n**[C:****4****]**     currentNode = nextNode;\n       }\n    }\n    nextNode = currentNode.sibling;\n  }\n  return mergeHeap;\n} \n```", "```java\nprivate void linkNodes(Node minNodeTree, Node other) {\n  other.parent = minNodeTree;\n  other.sibling = minNodeTree.child;\n  minNodeTree.child = other;\n  minNodeTree.degree++;\n} \n```", "```java\npublic class Huffman {\n  private Node root;\n  private String str;\n  private StringBuilder encodedStr;\n  private StringBuilder decodedStr;\n  private final class Node {\n    private Node left;\n    private Node right;\n    private final Character character;\n    private final Integer frequency;\n    //  constructors\n  }\n  ...\n} \n```", "```java\npublic void tree(String str) {\n  this.str = str;\n  this.root = null;\n  this.encodedStr = null;\n  this.decodedStr = null;\n  Map<Character, Integer> frequency = new HashMap<>();\n  for (char character : str.toCharArray()) {\n    frequency.put(character, \n           frequency.getOrDefault(character, 0) + 1);\n  }\n  PriorityQueue<Node> queue = new PriorityQueue<>(\n    Comparator.comparingInt(ch -> ch.frequency));\n  for (Entry<Character, Integer> entry : frequency.entrySet()) {\n    queue.add(new Node(entry.getKey(), entry.getValue()));\n  }\n  while (queue.size() != 1) {\n    Node left = queue.poll();\n    Node right = queue.poll();\n    int sum = left.frequency + right.frequency;\n    queue.add(new Node(null, sum, left, right)); \n  }\n  this.root = queue.peek();\n} \n```", "```java\npublic String encode() {\n  Map<Character, String> codes = new HashMap<>();\n  encode(this.root, \"\", codes);\n  this.encodedStr = new StringBuilder();\n  for (char character : this.str.toCharArray()) {\n    this.encodedStr.append(codes.get(character));\n  }\n  return this.encodedStr.toString();\n}\nprivate void encode(Node root, String str, \n                    Map<Character, String> codes) {\n  if (root == null) {\n    return;\n  }\n  if (isLeaf(root)) {\n    codes.put(root.character, str.length() > 0 ? str : \"1\");\n  }\n  encode(root.left, str + '0', codes);\n  encode(root.right, str + '1', codes);\n} \n```", "```java\npublic String decode() {\n  this.decodedStr = new StringBuilder();\n  if (isLeaf(this.root)) { \n    int copyFrequency = this.root.frequency;\n    while (copyFrequency-- > 0) {\n      decodedStr.append(root.character);\n    }\n  } else {\n    int index = -1;\n    while (index < this.encodedStr.length() - 1) {\n      index = decode(this.root, index);\n    }\n  }\n  return decodedStr.toString();\n}\nprivate int decode(Node root, int index) {\n  if (root == null) {\n    return index;\n  }\n  if (isLeaf(root)) {\n    decodedStr.append(root.character);\n    return index;\n  }\n  index++;\n  root = (this.encodedStr.charAt(index) == '0') \n    ? root.left : root.right;\n  index = decode(root, index);\n  return index;\n}\nprivate booleanisLeaf(Node root) {\n  return root.left == null && root.right == null;\n} \n```", "```java\npublic class IntervalTree {\n  private Node root;\n  public static final class Interval {\n    private final int min, max;\n    public Interval(int min, int max) {\n      this.min = min;\n      this.max = max;\n    }\n    ...\n  }\n  private final class Node {\n    private final Interval interval;\n    private final Integer maxInterval;\n    private Node left;\n    private Node right;\n    private int size;\n    private int maxSubstree;\n    Node(Interval interval, Integer maxInterval) {\n      this.interval = interval;\n      this.maxInterval = maxInterval;\n      this.size = 1;\n      this.maxSubstree = interval.max;\n    }\n  }\n...\n} \n```", "```java\npublic void insert(Interval interval) {\n  root = insert(root, interval);\n}\nprivate Node insert(Node root, Interval interval) {\n  if (root == null) {\n    return new Node(interval, interval.max);\n  }\n  if (interval.min < root.interval.min) {\n    root.left = insert(root.left, interval);\n  } else {\n    root.right = insert(root.right, interval);\n  }\n  if (root.maxSubstree < interval.max) {\n    root.maxSubstree = interval.max;\n  }\n  return root;\n} \n```", "```java\npublic class UnrolledLinkedList<E>\n       extends AbstractList<E>\n       implements List<E>, Serializable { ... }\npublic class UnrolledLinkedList<E>\n       extends AbstractSequentialList<E>\n       implements Deque<E>, Cloneable, Serializable { ... } \n```", "```java\npublic record Author(int authorId, String name) {}\npublic record Book(int bookId, String title, int authorId) {}\nList<Author> authorsTable = Arrays.asList(\n  new Author(1, \"Author_1\"), new Author(2, \"Author_2\"),\n  new Author(3, \"Author_3\"), new Author(4, \"Author_4\"),\n  new Author(5, \"Author_5\"));\nList<Book> booksTable = Arrays.asList(\n  new Book(1, \"Book_1\", 1), new Book(2, \"Book_2\", 1),\n  new Book(3, \"Book_3\", 2), new Book(4, \"Book_4\", 3),\n  new Book(5, \"Book_5\", 3), new Book(6, \"Book_6\", 3),\n  new Book(7, \"Book_7\", 4), new Book(8, \"Book_8\", 5),\n  new Book(9, \"Book_9\", 5)); \n```", "```java\npublic record ResultRow(int authorId, String name, \n                        String title, int bookId) {} \n```", "```java\npublic static List<ResultRow> nestedLoopJoin(\n    List<Author> authorsTable, List<Book> booksTable) {\n  List<ResultRow> resultSet = new LinkedList();\n  for (Author author : authorsTable) {\n    for (Book book : booksTable) {\n      if (book.authorId() == author.authorId()) {\n        resultSet.add(new ResultRow(\n        author.authorId(), author.name(), \n          book.title(), book.bookId()));\n      }\n    }\n  }\n  return resultSet;\n} \n```", "```java\npublic static List<ResultRow> hashJoin(\n   List<Author> authorsTable, List<Book> booksTable) {\n  Map<Integer, Author> authorMap = new HashMap<>();\n  for (Author author : authorsTable) {\n    authorMap.put(author.authorId(), author);\n  }\n  List<ResultRow> resultSet = new LinkedList();\n  for (Book book : booksTable) {\n    Integer authorId = book.authorId();\n    Author author = authorMap.get(authorId);\n    if (author != null) {\n      resultSet.add(new ResultRow(author.authorId(), \n        author.name(), book.title(), book.bookId()));\n    }\n  }\n  return resultSet;\n} \n```", "```java\npublic static List<ResultRow> sortMergeJoin(\n    List<Author> authorsTable, List<Book> booksTable) {\n  authorsTable.sort(Comparator.comparing(Author::authorId));\n  booksTable.sort((b1, b2) -> {\n    int sortResult = Comparator\n           .comparing(Book::authorId)\n           .compare(b1, b2);\n    return sortResult != 0 ? sortResult : Comparator\n            .comparing(Book::bookId)\n            .compare(b1, b2);\n  });\n  List<ResultRow> resultSet = new LinkedList();\n  int authorCount = authorsTable.size();\n  int bookCount = booksTable.size();\n  int p = 0;\n  int q = 0;\n  while (p <authorCount && q < bookCount) {\n    Author author = authorsTable.get(p);\n    Book book = booksTable.get(q);\n    if (author.authorId() == book.authorId()) {\n      resultSet.add(new ResultRow(author.authorId(), \n        author.name(), book.title(), book.bookId()));\n      q++;\n    } else {\n      p++;\n    }\n  }\n  return resultSet;\n} \n```"]