- en: Chapter 1. Defining Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we develop software, we need to write code. Our code consists of packages
    with classes, and those can be dependent on the other classes and packages in
    our project. This is fine for one project, but we sometimes depend on classes
    in other projects we didn't develop ourselves, for example, we might want to use
    classes from an Apache Commons library or we might be working on a project that
    is part of a bigger, multi-project application and we are dependent on classes
    in these other projects.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, when we write software, we want to use classes outside of
    our project. Actually, we have a dependency on those classes. Those dependent
    classes are mostly stored in archive files, such as **Java Archive** (**JAR**)
    files. Such archive files are identified by a unique version number, so we can
    have a dependency on the library with a specific version.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you are going to learn how to define dependencies in your Gradle
    project. We will see how we can define the configurations of dependencies. You
    will learn about the different dependency types in Gradle and how to use them
    when you configure your build.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring dependency configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Gradle, we define dependency configurations to group dependencies together.
    A dependency configuration has a name and several properties, such as a description
    and is actually a special type of `FileCollection`. Configurations can extend
    from each other, so we can build a hierarchy of configurations in our build files.
    Gradle plugins can also add new configurations to our project, for example, the
    Java plugin adds several new configurations, such as `compile` and `testRuntime`,
    to our project. The `compile` configuration is then used to define the dependencies
    that are needed to compile our source tree. The dependency configurations are
    defined with a `configurations` configuration block. Inside the block, we can
    define new configurations for our build. All configurations are added to the project's
    `ConfigurationContainer` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example build file, we define two new configurations, where
    the `traffic` configuration extends from the `vehicles` configuration. This means
    that any dependency added to the `vehicles` configuration is also available in
    the `traffic` configuration. We can also assign a `description` property to our
    configuration to provide some more information about the configuration for documentation
    purposes. The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To see which configurations are available in a project, we can execute the
    `dependencies` task. This task is available for each Gradle project. The task
    outputs all the configurations and dependencies of a project. Let''s run this
    task for our current project and check the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that we can see our two configurations, `traffic` and `vehicles`, in the
    output. We have not defined any dependencies to these configurations, as shown
    in the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java plugin adds a couple of configurations to a project, which are used
    by the tasks from the Java plugin. Let''s add the Java plugin to our Gradle build
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To see which configurations are added, we invoke the `dependencies` task and
    look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We see six configurations in our project just by adding the Java plugin. The
    `archives` configuration is used to group the artifacts our project creates. The
    other configurations are used to group the dependencies for our project. In the
    following table, the dependency configurations are summarized:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Extends | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| compile | none | These are dependencies to compile. |'
  prefs: []
  type: TYPE_TB
- en: '| runtime | compile | These are runtime dependencies. |'
  prefs: []
  type: TYPE_TB
- en: '| testCompile | compile | These are extra dependencies to compile tests. |'
  prefs: []
  type: TYPE_TB
- en: '| testRuntime | runtime, testCompile | These are extra dependencies to run
    tests. |'
  prefs: []
  type: TYPE_TB
- en: '| default | runtime | These are dependencies used by this project and artifacts
    created by this project. |'
  prefs: []
  type: TYPE_TB
- en: Later in the chapter, we will see how we can work with the dependencies assigned
    to the configurations. In the next section, we will learn how to declare our project's
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We defined configurations or applied a plugin that added new configurations
    to our project. However, a configuration is empty unless we add dependencies to
    the configuration. To declare dependencies in our Gradle build file, we must add
    the `dependencies` configuration block. The configuration block will contain the
    definition of our dependencies. In the following example Gradle build file, we
    define the `dependencies` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the configuration block, we use the name of a dependency configuration
    followed by the description of our dependencies. The name of the dependency configuration
    can be defined explicitly in the build file or can be added by a plugin we use.
    In Gradle, we can define several types of dependencies. In the following table,
    we will see the different types we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Dependency type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| External module dependency | This is a dependency on an external module or
    library that is probably stored in a repository. |'
  prefs: []
  type: TYPE_TB
- en: '| Client module dependency | This is a dependency on an external module where
    the artifacts are stored in a repository, but the meta information about the module
    is in the build file. We can override meta information using this type of dependency.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Project dependency | This is a dependency on another Gradle project in the
    same build. |'
  prefs: []
  type: TYPE_TB
- en: '| File dependency | This is a dependency on a collection of files on the local
    computer. |'
  prefs: []
  type: TYPE_TB
- en: '| Gradle API dependency | This is a dependency on the Gradle API of the current
    Gradle version. We use this dependency when we develop Gradle plugins and tasks.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Local Groovy dependency | This is a dependency on the Groovy libraries used
    by the current Gradle version. We use this dependency when we develop Gradle plugins
    and tasks. |'
  prefs: []
  type: TYPE_TB
- en: External module dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: External module dependencies are the most common dependencies in projects. These
    dependencies refer to a module in an external repository. Later in the book, we
    will find out more about repositories, but basically, a repository stores modules
    in a central location. A module contains one or more artifacts and meta information,
    such as references to the other modules it depends on.
  prefs: []
  type: TYPE_NORMAL
- en: We can use two notations to define an external module dependency in Gradle.
    We can use a string notation or a map notation. With the map notation, we can
    use all the properties available for a dependency. The string notation allows
    us to set a subset of the properties but with a very concise syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example Gradle build file, we define several dependencies
    using the string notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The string notation has the following format: **moduleGroup:moduleName:version**.
    Before the first colon, the module group name is used, followed by the module
    name, and the version is mentioned last.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use the map notation, we use the names of the attributes explicitly and
    set the value for each attribute. Let''s rewrite our previous example build file
    and use the map notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can specify extra configuration attributes with the map notation, or we
    can add an extra configuration closure. One of the attributes of an external module
    dependency is the `transitive` attribute. We learn more about how to work with
    transitive dependencies in [Chapter 3](part0024.xhtml#aid-MSDG2 "Chapter 3. Resolving
    Dependencies"), *Resolving Dependencies*. In the next example build file, we will
    set this attribute using the map notation and a configuration closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the rest of this section, you will learn about more attributes you can use
    to configure a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Once of the advantages of Gradle is that we can write Groovy code in our build
    file. This means that we can define methods and variables and use them in other
    parts of our Gradle file. This way, we can even apply refactoring to our build
    file and make maintainable build scripts. Note that in our examples, we included
    multiple dependencies with the `com.vehicles` group name. The value is defined
    twice, but we can also create a new variable with the group name and reference
    of the variable in the dependencies configuration. We define a variable in our
    build file inside an `ext` configuration block. We use the `ext` block in Gradle
    to add extra properties to an object, such as our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sample code defines an extra variable to hold the group name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If we define an external module dependency, then Gradle tries to find a module
    descriptor in a repository. If the module descriptor is available, it is parsed
    to see which artifacts need to be downloaded. Also, if the module descriptor contains
    information about the dependencies needed by the module, those dependencies are
    downloaded as well. Sometimes, a dependency has no descriptor in the repository,
    and it is only then that Gradle downloads the artifact for that dependency.
  prefs: []
  type: TYPE_NORMAL
- en: A dependency based on a Maven module only contains one artifact, so it is easy
    for Gradle to know which artifact to download. But for a Gradle or Ivy module,
    it is not so obvious, because a module can contain multiple artifacts. The module
    will have multiple configurations, each with different artifacts. Gradle will
    use the configuration with the name `default` for such modules. So, any artifacts
    and dependencies associated with the `default` configuration are downloaded. However,
    it is possible that the `default` configuration doesn't contain the artifacts
    we need. We, therefore, can specify the `configuration` attribute for the dependency
    configuration to specify a specific configuration that we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example defines a `configuration` attribute for the dependency
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When there is no module descriptor for a dependency, only the artifact is downloaded
    by Gradle. We can use an artifact-only notation if we only want to download the
    artifact for a module with a descriptor and not any dependencies. Or, if we want
    to download another archive file, such as a TAR file, with documentation, from
    a repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the artifact-only notation, we must add the file extension to the dependency
    definition. If we use the string notation, we must add the extension prefixed
    with an `@` sign after the version. With the map notation, we can use the `ext`
    attribute to set the extension. If we define our dependency as artifact-only,
    Gradle will not check whether there is a module descriptor available for the dependency.
    In the next build file, we will see examples of the different artifact-only notations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A Maven module descriptor can use classifiers for the artifact. This is mostly
    used when a library with the same code is compiled for different Java versions,
    for example, a library is compiled for Java 5 and Java 6 with the `jdk15` and
    `jdk16` classifiers. We can use the `classifier` attribute when we define an external
    module dependency to specify which classifier we want to use. Also, we can use
    it in a string or map notation. With the string notation, we add an extra colon
    after the version attribute and specify the classifier. For the map notation,
    we can add the `classifier` attribute and specify the value we want. The following
    build file contains an example of the different definitions of a dependency with
    a classifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the following section, we will see how we can define client module dependencies
    in our build file.
  prefs: []
  type: TYPE_NORMAL
- en: Defining client module dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we define external module dependencies, we expect that there is a module
    descriptor file with information about the artifacts and dependencies for those
    artifacts. Gradle will parse this file and determine what needs to be downloaded.
    Remember that if such a file is not available on the artifact, it will be downloaded.
    However, what if we want to override the module descriptor or provide one if it
    is not available? In the module descriptor that we provide, we can define the
    dependencies of the module ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: We can do this in Gradle with client module dependencies. Instead of relying
    on a module descriptor in a repository, we define our own module descriptor locally
    in the build file. We now have full control over what we think the module should
    look like and which dependencies the module itself has. We use the `module` method
    to define a client module dependency for a dependency configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example build file, we will write a client module dependency
    for the dependency car, and we will add a transitive dependency to the driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Using project dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Projects can be part of a bigger, multi-project build, and the projects can
    be dependent on each other, for example, one project can be made dependent on
    the generated artifact of another project, including the transitive dependencies
    of the other project. To define such a dependency, we use the `project` method
    in our dependencies configuration block. We specify the name of the project as
    an argument. We can also define the name of a dependency configuration of the
    other project we depend on. By default, Gradle will look for the default dependency
    configuration, but with the `configuration` attribute, we can specify a specific
    dependency configuration to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example build file will define project dependencies on the `car` and
    `truck` projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Defining file dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can directly add files to a dependency configuration in Gradle. The files
    don''t need to be stored in a repository but must be accessible from the project
    directory. Although most projects will have module descriptors stored in a repository,
    it is possible that a legacy project might have a dependency on files available
    on a shared network drive in the company. Otherwise, we must use a library in
    our project, which is simply not available in any repository. To add file dependencies
    to our dependency configuration, we specify a file collection with the `files`
    and `fileTree` methods. The following example build file shows the usage of all
    these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The added files will not be part of the transitive dependencies of our project
    if we publish our project's artifacts to a repository, but they are if our project
    is part of a multi-project build.
  prefs: []
  type: TYPE_NORMAL
- en: Using internal Gradle and Groovy dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we write code to extend Gradle, such as custom tasks or plugins, we can
    have a dependency on the Gradle API and possibly the Groovy libraries used by
    the current Gradle version. We can use the `gradleApi` and `localGroovy` methods
    in our dependency configuration to have all the right dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are writing some Groovy code to extend Gradle, but we don''t use any
    of the Gradle API classes, we can use `localGroovy`. With this method, the classes
    and libraries of the Groovy version shipped with the current Gradle version are
    added as dependencies. The following example build script uses the Groovy plugin
    and adds a dependency to the `compile` configuration on Groovy bundled with Gradle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When we write custom tasks or plugins for Gradle, we are dependent on the Gradle
    API. We need to import some of the API''s classes in order to write our code.
    To define a dependency on the Gradle classes, we use the `gradleApi` method. This
    will include the dependencies for the Gradle version the build is executed for.
    The next example build file will show the use of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using dynamic versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now, we have set a version for a dependency explicitly with a complete
    version number. To set a minimum version number, we can use a special dynamic
    version syntax, for example, to set the dependency version to a minimum of 2.1
    for a dependency, we use a version value of 2.1.+. Gradle will resolve the dependency
    to the latest version after version 2.1.0, or to version 2.1 itself. The upper
    bound is 2.2\. In the following example, we will define a dependency on a spring-context
    version of at least 4.0.x:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To reference the latest released version of a module, we can use `latest.integration`
    as the version value. We can also set the minimum and maximum version numbers
    we want. The following table shows the ranges we can use in Gradle:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Range | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `[1.0, 2.0]` | We can use all versions greater than or equal to 1.0 and lower
    than or equal to 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| `[1.0, 2.0[` | We can use all versions greater than or equal to 1.0 and lower
    than 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| `]1.0, 2.0]` | We can use all versions greater than 1.0 and lower than or
    equal to 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| `]1.0, 2.0[` | We can use all versions greater than 1.0 and lower than 2.0
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[1.0, )` | We can use all versions greater than or equal to 1.0 |'
  prefs: []
  type: TYPE_TB
- en: '| `]1.0, )` | We can use all versions greater than 1.0 |'
  prefs: []
  type: TYPE_TB
- en: '| `(, 2.0]` | We can use all versions lower than or equal to 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| `(, 2.0[` | We can use all versions lower than 2.0 |'
  prefs: []
  type: TYPE_TB
- en: 'In the following example build file, we will set the version for the spring-context
    module to greater than `4.0.1.RELEASE` and lower than `4.0.4.RELEASE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Getting information about dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen how we can define dependencies in our build scripts. To get more
    information about our dependencies, we can use the `dependencies` task. When we
    invoke the task, we can see which dependencies belong to the available configurations
    of our project. Also, any transitive dependencies are shown. The next example
    build file defines a dependency on Spring beans and we apply the Java plugin.
    We also specify a repository in the `repositories` configuration block. We will
    learn more about repositories in the next chapter. The following code captures
    the discussion in this paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the `dependencies` task, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We see all the configurations of our project, and for each configuration, we
    see the defined dependency with the transitive dependencies. Also, we can see
    how our dynamic version `4.0.+` is resolved to version `4.0.6.RELEASE`. To only
    see dependencies for a specific configuration, we can use the `--configuration`
    option for the `dependencies` task. We must use the value of the configuration
    we want to see the dependencies for. In the following output, we see the result
    when we only want to see the dependencies for the compile configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There is also the `dependencyInsight` incubating task in Gradle. Because it
    is incubating, the functionality or syntax can change in future versions of Gradle.
    With the `dependencyInsight` task, we can find out why a specific dependency is
    in our build and to which configuration it belongs. We have to use the `--dependency`
    option, the required one, with part of the name of the dependency. Gradle will
    look for dependencies where the group, name, or version contains part of the specified
    value for the `--dependency` option. Optionally, we can specify the `--configuration`
    option to only look for the dependency in the specified configuration. If we leave
    out this option, Gradle will look for the dependency in all the configurations
    of our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s invoke the `dependencyInsight` task to find the dependencies with Spring
    in the name and in the runtime configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the output, we see how version `4.0.+` is resolved to `4.0.6.RELEASE`. We
    also see that the `spring-beans` dependency and the transitive `spring-core` dependency
    are part of the runtime configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To access the configurations, we can use the `configurations` property of the
    Gradle project object. The `configurations` property contains a collection of
    `Configuration` objects. It is good to remember that a `Configuration` object
    is an instance of `FileCollection`. So, we can reference `Configuration` in our
    build scripts where `FileCollection` is allowed. The `Configuration` object contains
    more properties we can use to access the dependencies belonging to the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example build, we will define two tasks that work with the files
    and information available from configurations in the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Buildscript dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we define dependencies, we mostly want to define them for the code we are
    developing. However, we may also want to add a dependency to the Gradle build
    script itself. We can write code in our build files, which might be dependent
    on a library that is not included in the Gradle distribution. Let's suppose we
    want to use a class from the Apache Commons Lang library in our build script.
    We must add a `buildscript` configuration closure to our build script. Within
    the configuration closure, we can define repositories and dependencies. We must
    use the special `classpath` configuration to add dependencies to. Any dependency
    added to the `classpath` configuration can be used by the code in our build file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this works with an example build file. We want to use the `org.apache.commons.lang3.RandomStringUtils`
    class inside a `randomString` task. This class can be found in the `org.apache.commons:commons-lang3`
    dependency. We define this as an external dependency for the `classpath` configuration.
    We also include a repository definition inside the `buildscript` configuration
    block so that the dependency can be downloaded. The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To include external plugins, which are not part of the Gradle distribution,
    we can also use the `classpath` configuration in the `buildscript` configuration
    block. In the next example build file, we will include the `Asciidoctor` Gradle
    plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Optional Ant task dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can reuse the existing Ant tasks in Gradle. The default tasks from Ant can
    be invoked from within our build scripts. However, if we want to use an optional
    Ant task, we must define a dependency for the classes needed by the optional Ant
    task. We create a new dependency configuration, and then we add a dependency to
    this new configuration. We can reference this configuration when setting the classpath
    for the optional Ant task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the optional Ant task SCP for the secure copying of files to/from
    a remote server. We create the `sshAntTask` configuration to add dependencies
    for the optional Ant task. We can choose any name for the configuration. To define
    the optional task, we use the `taskdef` method from the internal `ant` object.
    The method takes a `classpath` attribute, which must be the actual path of all
    files of the `sshAntTask` dependencies. The `Configuration` class provides the
    `asPath` property to return the path to the files in a platform-specific way.
    So, if we use this on a Windows computer, the file path separator is a `;` and
    for other platforms it is a `:`. The following example build file contains all
    the code to define and uses the SCP Ant task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Managing dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have already learned earlier in the chapter that we can refactor the dependency
    definitions by extracting common parts into project properties. This way, we only
    have to change a few project property values to make changes to multiple dependencies.
    In the next example build file, we will use lists to group dependencies together
    and reference those lists from the dependency definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Maven has a feature called dependency management metadata that allows us to
    define versions used for dependencies in a common part of the build file. Then,
    when the actual dependency is configured, we can leave out the version because
    it will be determined from the dependency management section of the build file.
    Gradle doesn't have such a built-in feature, but as illustrated earlier, we can
    use simple code refactoring to get a similar effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can still have declarative dependency management, as we do in Maven, in
    our Gradle build, with the external dependency management plugin by Spring. This
    plugin adds a `dependencyManagement` configuration block to Gradle. Inside the
    configuration block, we can define dependency metadata, such as the group, name,
    and version. In the `dependencies` configuration closure in our Gradle build script,
    we don''t have to specify the version anymore because it will be resolved via
    the dependency metadata in the `dependencyManagement` configuration. The following
    example build file uses this plugin and specifies dependency metadata using `dependencyManagement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To import a Maven **bill of materials** (**BOM**) provided by an organization,
    we can use the `imports` method inside the `dependencyManagement` configuration.
    In the next example, we will use the Spring IO platform BOM. In the `dependencies`
    configuration, we can leave out the version because it will be resolved via the
    BOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create and use dependency configurations
    to group together dependencies. We saw how to define several types of dependencies,
    such as external module dependency and internal dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we saw how we can add dependencies to code in Gradle build scripts with
    the `classpath` configuration and the `buildscript` configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at some maintainable ways of defining dependencies using
    code refactoring and the external dependency management plugin.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn more about how we can configure repositories
    that store dependency modules.
  prefs: []
  type: TYPE_NORMAL
