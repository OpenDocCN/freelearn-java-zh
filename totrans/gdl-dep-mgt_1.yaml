- en: Chapter 1. Defining Dependencies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章 定义依赖
- en: When we develop software, we need to write code. Our code consists of packages
    with classes, and those can be dependent on the other classes and packages in
    our project. This is fine for one project, but we sometimes depend on classes
    in other projects we didn't develop ourselves, for example, we might want to use
    classes from an Apache Commons library or we might be working on a project that
    is part of a bigger, multi-project application and we are dependent on classes
    in these other projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开发软件时，我们需要编写代码。我们的代码由包含类的包组成，而这些类可能依赖于我们项目中其他类和包。对于单个项目来说，这是可以的，但有时我们会依赖于我们未开发的项目的类，例如，我们可能想使用Apache
    Commons库中的类，或者我们可能正在开发一个更大的多项目应用程序的一部分，并且我们依赖于这些其他项目中的类。
- en: Most of the time, when we write software, we want to use classes outside of
    our project. Actually, we have a dependency on those classes. Those dependent
    classes are mostly stored in archive files, such as **Java Archive** (**JAR**)
    files. Such archive files are identified by a unique version number, so we can
    have a dependency on the library with a specific version.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，当我们编写软件时，我们希望使用项目外的类。实际上，我们对这些类有依赖。这些依赖的类大多存储在归档文件中，例如**Java归档**（**JAR**）文件。这样的归档文件由一个唯一的版本号标识，因此我们可以对具有特定版本的库有依赖。
- en: In this chapter, you are going to learn how to define dependencies in your Gradle
    project. We will see how we can define the configurations of dependencies. You
    will learn about the different dependency types in Gradle and how to use them
    when you configure your build.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何在Gradle项目中定义依赖项。我们将看到如何定义依赖项的配置。你将了解Gradle中的不同依赖类型以及如何在配置构建时使用它们。
- en: Declaring dependency configurations
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明依赖配置
- en: In Gradle, we define dependency configurations to group dependencies together.
    A dependency configuration has a name and several properties, such as a description
    and is actually a special type of `FileCollection`. Configurations can extend
    from each other, so we can build a hierarchy of configurations in our build files.
    Gradle plugins can also add new configurations to our project, for example, the
    Java plugin adds several new configurations, such as `compile` and `testRuntime`,
    to our project. The `compile` configuration is then used to define the dependencies
    that are needed to compile our source tree. The dependency configurations are
    defined with a `configurations` configuration block. Inside the block, we can
    define new configurations for our build. All configurations are added to the project's
    `ConfigurationContainer` object.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gradle中，我们定义依赖配置来将依赖项分组在一起。依赖配置有一个名称和几个属性，例如描述，实际上是一种特殊的`FileCollection`类型。配置可以相互扩展，因此我们可以在构建文件中构建配置的层次结构。Gradle插件也可以为我们添加新的配置，例如，Java插件为我们添加了几个新的配置，如`compile`和`testRuntime`。然后，`compile`配置用于定义编译源树所需的依赖项。依赖配置是用`configurations`配置块定义的。在块内部，我们可以为我们的构建定义新的配置。所有配置都添加到项目的`ConfigurationContainer`对象中。
- en: 'In the following example build file, we define two new configurations, where
    the `traffic` configuration extends from the `vehicles` configuration. This means
    that any dependency added to the `vehicles` configuration is also available in
    the `traffic` configuration. We can also assign a `description` property to our
    configuration to provide some more information about the configuration for documentation
    purposes. The following code shows this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例构建文件中，我们定义了两个新的配置，其中`traffic`配置扩展自`vehicles`配置。这意味着添加到`vehicles`配置中的任何依赖项也将在`traffic`配置中可用。我们还可以为我们的配置分配一个`description`属性，以便为文档目的提供有关配置的更多信息。以下代码展示了这一点：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To see which configurations are available in a project, we can execute the
    `dependencies` task. This task is available for each Gradle project. The task
    outputs all the configurations and dependencies of a project. Let''s run this
    task for our current project and check the output:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看项目中可用的配置，我们可以执行`dependencies`任务。这个任务适用于每个Gradle项目。该任务会输出项目的所有配置和依赖。让我们为当前项目运行这个任务并检查输出：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that we can see our two configurations, `traffic` and `vehicles`, in the
    output. We have not defined any dependencies to these configurations, as shown
    in the output.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以在输出中看到我们的两个配置，`traffic`和`vehicles`。我们没有为这些配置定义任何依赖项，如输出所示。
- en: 'The Java plugin adds a couple of configurations to a project, which are used
    by the tasks from the Java plugin. Let''s add the Java plugin to our Gradle build
    file:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Java插件向项目中添加了一些配置，这些配置由Java插件的任务使用。让我们将Java插件添加到我们的Gradle构建文件中：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To see which configurations are added, we invoke the `dependencies` task and
    look at the output:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看添加了哪些配置，我们调用`dependencies`任务并查看输出：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We see six configurations in our project just by adding the Java plugin. The
    `archives` configuration is used to group the artifacts our project creates. The
    other configurations are used to group the dependencies for our project. In the
    following table, the dependency configurations are summarized:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 只需添加Java插件，我们项目中就出现了六个配置。`archives`配置用于组合我们项目创建的工件。其他配置用于组合我们项目的依赖。在以下表中，总结了依赖配置：
- en: '| Name | Extends | Description |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 扩展 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| compile | none | These are dependencies to compile. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| compile | none | 这些是编译依赖。|'
- en: '| runtime | compile | These are runtime dependencies. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| runtime | compile | 这些是运行时依赖。|'
- en: '| testCompile | compile | These are extra dependencies to compile tests. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| testCompile | compile | 这些是编译测试的额外依赖。|'
- en: '| testRuntime | runtime, testCompile | These are extra dependencies to run
    tests. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| testRuntime | runtime, testCompile | 这些是运行测试的额外依赖。|'
- en: '| default | runtime | These are dependencies used by this project and artifacts
    created by this project. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| default | runtime | 这些是本项目使用的依赖以及本项目创建的工件。|'
- en: Later in the chapter, we will see how we can work with the dependencies assigned
    to the configurations. In the next section, we will learn how to declare our project's
    dependencies.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将看到如何与分配给配置的依赖项一起工作。在下一节中，我们将学习如何声明我们项目的依赖项。
- en: Declaring dependencies
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明依赖
- en: 'We defined configurations or applied a plugin that added new configurations
    to our project. However, a configuration is empty unless we add dependencies to
    the configuration. To declare dependencies in our Gradle build file, we must add
    the `dependencies` configuration block. The configuration block will contain the
    definition of our dependencies. In the following example Gradle build file, we
    define the `dependencies` block:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了配置或应用了一个添加新配置到我们项目的插件。然而，除非我们向配置添加依赖，否则配置是空的。为了在Gradle构建文件中声明依赖，我们必须添加`dependencies`配置块。配置块将包含我们依赖的定义。在以下示例Gradle构建文件中，我们定义了`dependencies`块：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside the configuration block, we use the name of a dependency configuration
    followed by the description of our dependencies. The name of the dependency configuration
    can be defined explicitly in the build file or can be added by a plugin we use.
    In Gradle, we can define several types of dependencies. In the following table,
    we will see the different types we can use:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置块内部，我们使用依赖配置的名称后跟我们的依赖描述。依赖配置的名称可以在构建文件中明确定义，也可以由我们使用的插件添加。在Gradle中，我们可以定义多种类型的依赖。在以下表中，我们将看到我们可以使用的不同类型：
- en: '| Dependency type | Description |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 依赖类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| External module dependency | This is a dependency on an external module or
    library that is probably stored in a repository. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 外部模块依赖 | 这是对外部模块或库的依赖，可能存储在存储库中。|'
- en: '| Client module dependency | This is a dependency on an external module where
    the artifacts are stored in a repository, but the meta information about the module
    is in the build file. We can override meta information using this type of dependency.
    |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 客户端模块依赖 | 这是外部模块的依赖，其中工件存储在存储库中，但模块的元信息在构建文件中。我们可以使用此类型的依赖来覆盖元信息。|'
- en: '| Project dependency | This is a dependency on another Gradle project in the
    same build. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 项目依赖 | 这是同一构建中另一个Gradle项目的依赖。|'
- en: '| File dependency | This is a dependency on a collection of files on the local
    computer. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 文件依赖 | 这是本地计算机上文件集合的依赖。|'
- en: '| Gradle API dependency | This is a dependency on the Gradle API of the current
    Gradle version. We use this dependency when we develop Gradle plugins and tasks.
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| Gradle API依赖 | 这是当前Gradle版本的Gradle API的依赖。我们在开发Gradle插件和任务时使用此依赖。|'
- en: '| Local Groovy dependency | This is a dependency on the Groovy libraries used
    by the current Gradle version. We use this dependency when we develop Gradle plugins
    and tasks. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 本地Groovy依赖 | 这是当前Gradle版本使用的Groovy库的依赖。我们在开发Gradle插件和任务时使用此依赖。|'
- en: External module dependencies
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部模块依赖
- en: External module dependencies are the most common dependencies in projects. These
    dependencies refer to a module in an external repository. Later in the book, we
    will find out more about repositories, but basically, a repository stores modules
    in a central location. A module contains one or more artifacts and meta information,
    such as references to the other modules it depends on.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 外部模块依赖是项目中最常见的依赖。这些依赖指的是外部仓库中的一个模块。在本书的后续部分，我们将了解更多关于仓库的信息，但基本上，仓库是将模块存储在中央位置的地方。一个模块包含一个或多个工件和元信息，例如它所依赖的其他模块的引用。
- en: We can use two notations to define an external module dependency in Gradle.
    We can use a string notation or a map notation. With the map notation, we can
    use all the properties available for a dependency. The string notation allows
    us to set a subset of the properties but with a very concise syntax.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两种表示法在Gradle中定义外部模块依赖。我们可以使用字符串表示法或映射表示法。使用映射表示法，我们可以使用所有可用的依赖属性。字符串表示法允许我们设置属性的一个子集，但具有非常简洁的语法。
- en: 'In the following example Gradle build file, we define several dependencies
    using the string notation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例Gradle构建文件中，我们使用字符串表示法定义了几个依赖项：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The string notation has the following format: **moduleGroup:moduleName:version**.
    Before the first colon, the module group name is used, followed by the module
    name, and the version is mentioned last.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串表示法具有以下格式：**moduleGroup:moduleName:version**。在第一个冒号之前使用模块组名，然后是模块名，最后是版本。
- en: 'If we use the map notation, we use the names of the attributes explicitly and
    set the value for each attribute. Let''s rewrite our previous example build file
    and use the map notation:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用映射表示法，我们将显式使用属性的名称并设置每个属性的值。让我们重写我们之前的示例构建文件并使用映射表示法：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can specify extra configuration attributes with the map notation, or we
    can add an extra configuration closure. One of the attributes of an external module
    dependency is the `transitive` attribute. We learn more about how to work with
    transitive dependencies in [Chapter 3](part0024.xhtml#aid-MSDG2 "Chapter 3. Resolving
    Dependencies"), *Resolving Dependencies*. In the next example build file, we will
    set this attribute using the map notation and a configuration closure:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用映射表示法指定额外的配置属性，或者添加一个额外的配置闭包。外部模块依赖的一个属性是`transitive`属性。我们在[第3章](part0024.xhtml#aid-MSDG2
    "第3章。解决依赖")中学习如何与传递依赖一起工作，*解决依赖*。在下一个示例构建文件中，我们将使用映射表示法和配置闭包设置此属性：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the rest of this section, you will learn about more attributes you can use
    to configure a dependency.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，你将了解你可以用来配置依赖项的更多属性。
- en: Once of the advantages of Gradle is that we can write Groovy code in our build
    file. This means that we can define methods and variables and use them in other
    parts of our Gradle file. This way, we can even apply refactoring to our build
    file and make maintainable build scripts. Note that in our examples, we included
    multiple dependencies with the `com.vehicles` group name. The value is defined
    twice, but we can also create a new variable with the group name and reference
    of the variable in the dependencies configuration. We define a variable in our
    build file inside an `ext` configuration block. We use the `ext` block in Gradle
    to add extra properties to an object, such as our project.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle的一个优点是，我们可以在构建文件中编写Groovy代码。这意味着我们可以定义方法和变量，并在Gradle文件的其它部分使用它们。这样，我们甚至可以对构建文件进行重构，并创建可维护的构建脚本。请注意，在我们的示例中，我们包含了具有`com.vehicles`组名的多个依赖项。值被定义了两次，但我们也可以在依赖项配置中创建一个新的变量，并使用该变量的组名和引用。我们在构建文件内的`ext`配置块中定义变量。我们在Gradle中使用`ext`块向对象添加额外的属性，例如我们的项目。
- en: 'The following sample code defines an extra variable to hold the group name:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码定义了一个额外的变量来保存组名：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If we define an external module dependency, then Gradle tries to find a module
    descriptor in a repository. If the module descriptor is available, it is parsed
    to see which artifacts need to be downloaded. Also, if the module descriptor contains
    information about the dependencies needed by the module, those dependencies are
    downloaded as well. Sometimes, a dependency has no descriptor in the repository,
    and it is only then that Gradle downloads the artifact for that dependency.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们定义外部模块依赖项，那么Gradle会尝试在存储库中找到一个模块描述符。如果模块描述符可用，它将被解析以查看需要下载哪些工件。此外，如果模块描述符包含有关模块所需依赖项的信息，那么这些依赖项也将被下载。有时，一个依赖项在存储库中没有描述符，这时Gradle才会下载该依赖项的工件。
- en: A dependency based on a Maven module only contains one artifact, so it is easy
    for Gradle to know which artifact to download. But for a Gradle or Ivy module,
    it is not so obvious, because a module can contain multiple artifacts. The module
    will have multiple configurations, each with different artifacts. Gradle will
    use the configuration with the name `default` for such modules. So, any artifacts
    and dependencies associated with the `default` configuration are downloaded. However,
    it is possible that the `default` configuration doesn't contain the artifacts
    we need. We, therefore, can specify the `configuration` attribute for the dependency
    configuration to specify a specific configuration that we need.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Maven模块的依赖项仅包含一个工件，因此Gradle很容易知道要下载哪个工件。但对于Gradle或Ivy模块，这并不明显，因为一个模块可以包含多个工件。该模块将具有多个配置，每个配置都有不同的工件。Gradle将为这些模块使用名为`default`的配置。因此，与`default`配置关联的任何工件和依赖项都将被下载。然而，可能`default`配置不包含我们需要的工件。因此，我们可以为依赖项配置指定`configuration`属性以指定我们需要的特定配置。
- en: 'The following example defines a `configuration` attribute for the dependency
    configuration:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例为依赖项配置定义了一个`configuration`属性：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When there is no module descriptor for a dependency, only the artifact is downloaded
    by Gradle. We can use an artifact-only notation if we only want to download the
    artifact for a module with a descriptor and not any dependencies. Or, if we want
    to download another archive file, such as a TAR file, with documentation, from
    a repository.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个依赖项没有模块描述符时，Gradle只会下载工件。如果我们只想下载具有描述符的模块的工件，而不是任何依赖项，我们可以使用仅工件符号。或者，如果我们想从存储库中下载另一个存档文件，例如带有文档的TAR文件，我们也可以使用仅工件符号。
- en: 'To use the artifact-only notation, we must add the file extension to the dependency
    definition. If we use the string notation, we must add the extension prefixed
    with an `@` sign after the version. With the map notation, we can use the `ext`
    attribute to set the extension. If we define our dependency as artifact-only,
    Gradle will not check whether there is a module descriptor available for the dependency.
    In the next build file, we will see examples of the different artifact-only notations:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用仅工件符号，我们必须将文件扩展名添加到依赖项定义中。如果我们使用字符串符号，我们必须在版本后添加一个以`@`符号为前缀的扩展名。使用映射符号时，我们可以使用`ext`属性来设置扩展名。如果我们定义我们的依赖项为仅工件，Gradle将不会检查是否为该依赖项提供了模块描述符。在下一个构建文件中，我们将看到不同工件仅符号的示例：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A Maven module descriptor can use classifiers for the artifact. This is mostly
    used when a library with the same code is compiled for different Java versions,
    for example, a library is compiled for Java 5 and Java 6 with the `jdk15` and
    `jdk16` classifiers. We can use the `classifier` attribute when we define an external
    module dependency to specify which classifier we want to use. Also, we can use
    it in a string or map notation. With the string notation, we add an extra colon
    after the version attribute and specify the classifier. For the map notation,
    we can add the `classifier` attribute and specify the value we want. The following
    build file contains an example of the different definitions of a dependency with
    a classifier:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Maven模块描述符可以使用分类器来指定工件。这通常用于为不同的Java版本编译具有相同代码的库时，例如，使用`jdk15`和`jdk16`分类器为Java
    5和Java 6编译一个库。当我们定义外部模块依赖关系以指定我们想要使用的分类器时，我们可以使用`classifier`属性。此外，我们还可以在字符串或映射符号中使用它。使用字符串符号时，我们在版本属性后添加一个额外的冒号并指定分类器。对于映射符号，我们可以添加`classifier`属性并指定我们想要的值。以下构建文件包含了一个具有分类器的依赖项不同定义的示例：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the following section, we will see how we can define client module dependencies
    in our build file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将看到如何在我们的构建文件中定义客户端模块依赖项。
- en: Defining client module dependencies
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义客户端模块依赖项
- en: When we define external module dependencies, we expect that there is a module
    descriptor file with information about the artifacts and dependencies for those
    artifacts. Gradle will parse this file and determine what needs to be downloaded.
    Remember that if such a file is not available on the artifact, it will be downloaded.
    However, what if we want to override the module descriptor or provide one if it
    is not available? In the module descriptor that we provide, we can define the
    dependencies of the module ourselves.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义外部模块依赖项时，我们期望有一个包含有关这些工件及其依赖项信息的模块描述符文件。Gradle 将解析此文件并确定需要下载的内容。请记住，如果此类文件不可用，它将被下载。然而，如果我们想覆盖模块描述符或在没有它的情况下提供它怎么办？在我们提供的模块描述符中，我们可以自己定义模块的依赖项。
- en: We can do this in Gradle with client module dependencies. Instead of relying
    on a module descriptor in a repository, we define our own module descriptor locally
    in the build file. We now have full control over what we think the module should
    look like and which dependencies the module itself has. We use the `module` method
    to define a client module dependency for a dependency configuration.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Gradle 中通过客户端模块依赖来实现这一点。我们不是依赖于存储库中的模块描述符，而是在构建文件中本地定义自己的模块描述符。现在，我们可以完全控制我们认为模块应该是什么样子，以及模块本身有哪些依赖。我们使用
    `module` 方法来定义一个客户端模块依赖项，用于依赖配置。
- en: 'In the following example build file, we will write a client module dependency
    for the dependency car, and we will add a transitive dependency to the driver:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例构建文件中，我们将为依赖项 `car` 编写一个客户端模块依赖项，并将传递依赖项添加到 `driver`：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using project dependencies
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用项目依赖项
- en: Projects can be part of a bigger, multi-project build, and the projects can
    be dependent on each other, for example, one project can be made dependent on
    the generated artifact of another project, including the transitive dependencies
    of the other project. To define such a dependency, we use the `project` method
    in our dependencies configuration block. We specify the name of the project as
    an argument. We can also define the name of a dependency configuration of the
    other project we depend on. By default, Gradle will look for the default dependency
    configuration, but with the `configuration` attribute, we can specify a specific
    dependency configuration to be used.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 项目可以是更大、多项目构建的一部分，项目之间可以相互依赖，例如，一个项目可以是另一个项目的生成工件（包括另一个项目的传递依赖项）的依赖项。为了定义这样的依赖项，我们在依赖配置块中使用
    `project` 方法。我们指定项目名称作为参数。我们还可以定义我们依赖的另一个项目的依赖配置的名称。默认情况下，Gradle 将查找默认依赖配置，但使用
    `configuration` 属性，我们可以指定要使用的特定依赖配置。
- en: 'The next example build file will define project dependencies on the `car` and
    `truck` projects:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例构建文件将定义对 `car` 和 `truck` 项目的项目依赖项：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Defining file dependencies
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义文件依赖项
- en: 'We can directly add files to a dependency configuration in Gradle. The files
    don''t need to be stored in a repository but must be accessible from the project
    directory. Although most projects will have module descriptors stored in a repository,
    it is possible that a legacy project might have a dependency on files available
    on a shared network drive in the company. Otherwise, we must use a library in
    our project, which is simply not available in any repository. To add file dependencies
    to our dependency configuration, we specify a file collection with the `files`
    and `fileTree` methods. The following example build file shows the usage of all
    these methods:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接在 Gradle 中向依赖配置添加文件。这些文件不需要存储在存储库中，但必须可以从项目目录中访问。尽管大多数项目将在存储库中存储模块描述符，但可能存在一个遗留项目依赖于公司共享网络驱动器上可用的文件。否则，我们必须在我们的项目中使用一个库，而这个库在任何存储库中都是不可用的。要向我们的依赖配置添加文件依赖项，我们使用
    `files` 和 `fileTree` 方法指定一个文件集合。以下示例构建文件显示了所有这些方法的用法：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The added files will not be part of the transitive dependencies of our project
    if we publish our project's artifacts to a repository, but they are if our project
    is part of a multi-project build.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将项目工件发布到存储库，添加的文件将不会成为我们项目的传递依赖项，但如果我们的项目是多项目构建的一部分，则它们将是。
- en: Using internal Gradle and Groovy dependencies
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内部 Gradle 和 Groovy 依赖项
- en: When we write code to extend Gradle, such as custom tasks or plugins, we can
    have a dependency on the Gradle API and possibly the Groovy libraries used by
    the current Gradle version. We can use the `gradleApi` and `localGroovy` methods
    in our dependency configuration to have all the right dependencies.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写代码以扩展 Gradle，例如自定义任务或插件时，我们可以对 Gradle API 和当前 Gradle 版本使用的 Groovy 库有依赖。我们可以在依赖配置中使用
    `gradleApi` 和 `localGroovy` 方法来确保所有正确的依赖项。
- en: 'If we are writing some Groovy code to extend Gradle, but we don''t use any
    of the Gradle API classes, we can use `localGroovy`. With this method, the classes
    and libraries of the Groovy version shipped with the current Gradle version are
    added as dependencies. The following example build script uses the Groovy plugin
    and adds a dependency to the `compile` configuration on Groovy bundled with Gradle:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在编写一些用于扩展 Gradle 的 Groovy 代码，但未使用任何 Gradle API 类，我们可以使用 `localGroovy`。使用这个方法，当前
    Gradle 版本中提供的 Groovy 版本的类和库被添加为依赖项。以下示例构建脚本使用 Groovy 插件，并将依赖项添加到 Gradle 打包的 Groovy
    的 `compile` 配置中：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When we write custom tasks or plugins for Gradle, we are dependent on the Gradle
    API. We need to import some of the API''s classes in order to write our code.
    To define a dependency on the Gradle classes, we use the `gradleApi` method. This
    will include the dependencies for the Gradle version the build is executed for.
    The next example build file will show the use of this method:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为 Gradle 编写自定义任务或插件时，我们依赖于 Gradle API。我们需要导入 API 的一些类来编写我们的代码。为了定义对 Gradle
    类的依赖，我们使用 `gradleApi` 方法。这将包括为构建执行的 Gradle 版本包含的依赖项。下一个示例构建文件将展示这个方法的使用：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using dynamic versions
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动态版本
- en: 'Until now, we have set a version for a dependency explicitly with a complete
    version number. To set a minimum version number, we can use a special dynamic
    version syntax, for example, to set the dependency version to a minimum of 2.1
    for a dependency, we use a version value of 2.1.+. Gradle will resolve the dependency
    to the latest version after version 2.1.0, or to version 2.1 itself. The upper
    bound is 2.2\. In the following example, we will define a dependency on a spring-context
    version of at least 4.0.x:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已通过完整的版本号显式设置了一个依赖项的版本。要设置最低版本号，我们可以使用特殊的动态版本语法，例如，要将依赖项版本设置为至少 2.1，我们使用版本值
    2.1.+. Gradle 将将依赖项解析为 2.1.0 版本之后的最新版本，或者解析为 2.1 版本本身。上限是 2.2\. 在以下示例中，我们将定义一个对至少为
    4.0.x 版本的 spring-context 的依赖项：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To reference the latest released version of a module, we can use `latest.integration`
    as the version value. We can also set the minimum and maximum version numbers
    we want. The following table shows the ranges we can use in Gradle:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用模块的最新发布版本，我们可以使用 `latest.integration` 作为版本值。我们还可以设置我们想要的最低和最高版本号。以下表格显示了
    Gradle 中我们可以使用的范围：
- en: '| Range | Description |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 范围 | 描述 |'
- en: '| --- | --- |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `[1.0, 2.0]` | We can use all versions greater than or equal to 1.0 and lower
    than or equal to 2.0 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `[1.0, 2.0]` | 我们可以使用所有大于或等于 1.0 且小于或等于 2.0 的版本 |'
- en: '| `[1.0, 2.0[` | We can use all versions greater than or equal to 1.0 and lower
    than 2.0 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `[1.0, 2.0[` | 我们可以使用所有大于或等于 1.0 且小于 2.0 的版本 |'
- en: '| `]1.0, 2.0]` | We can use all versions greater than 1.0 and lower than or
    equal to 2.0 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `]1.0, 2.0]` | 我们可以使用所有大于 1.0 且小于或等于 2.0 的版本 |'
- en: '| `]1.0, 2.0[` | We can use all versions greater than 1.0 and lower than 2.0
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `]1.0, 2.0[` | 我们可以使用所有大于 1.0 且小于 2.0 的版本 |'
- en: '| `[1.0, )` | We can use all versions greater than or equal to 1.0 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `[1.0, )` | 我们可以使用所有大于或等于 1.0 的版本 |'
- en: '| `]1.0, )` | We can use all versions greater than 1.0 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `]1.0, )` | 我们可以使用所有大于 1.0 的版本 |'
- en: '| `(, 2.0]` | We can use all versions lower than or equal to 2.0 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `(, 2.0]` | 我们可以使用所有小于或等于 2.0 的版本 |'
- en: '| `(, 2.0[` | We can use all versions lower than 2.0 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `(, 2.0[` | 我们可以使用所有小于 2.0 的版本 |'
- en: 'In the following example build file, we will set the version for the spring-context
    module to greater than `4.0.1.RELEASE` and lower than `4.0.4.RELEASE`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例构建文件中，我们将 spring-context 模块的版本设置为大于 `4.0.1.RELEASE` 且小于 `4.0.4.RELEASE`：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Getting information about dependencies
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取依赖信息
- en: 'We have seen how we can define dependencies in our build scripts. To get more
    information about our dependencies, we can use the `dependencies` task. When we
    invoke the task, we can see which dependencies belong to the available configurations
    of our project. Also, any transitive dependencies are shown. The next example
    build file defines a dependency on Spring beans and we apply the Java plugin.
    We also specify a repository in the `repositories` configuration block. We will
    learn more about repositories in the next chapter. The following code captures
    the discussion in this paragraph:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在我们的构建脚本中定义依赖项。要获取有关我们依赖项的更多信息，我们可以使用 `dependencies` 任务。当我们调用此任务时，我们可以看到哪些依赖项属于我们项目的可用配置。此外，任何传递依赖项也会显示出来。下一个示例构建文件定义了对
    Spring beans 的依赖项，并应用了 Java 插件。我们还在 `repositories` 配置块中指定了一个仓库。我们将在下一章中了解更多关于仓库的信息。以下代码捕捉了本段落的讨论：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we execute the `dependencies` task, we get the following output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行 `dependencies` 任务时，我们得到以下输出：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We see all the configurations of our project, and for each configuration, we
    see the defined dependency with the transitive dependencies. Also, we can see
    how our dynamic version `4.0.+` is resolved to version `4.0.6.RELEASE`. To only
    see dependencies for a specific configuration, we can use the `--configuration`
    option for the `dependencies` task. We must use the value of the configuration
    we want to see the dependencies for. In the following output, we see the result
    when we only want to see the dependencies for the compile configuration:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们项目的所有配置，并且对于每个配置，我们看到定义的依赖项及其传递依赖项。此外，我们还可以看到我们的动态版本 `4.0.+` 如何解析为版本 `4.0.6.RELEASE`。要仅查看特定配置的依赖项，我们可以在
    `dependencies` 任务中使用 `--configuration` 选项。我们必须使用我们想要查看依赖项的配置的值。在以下输出中，我们看到当我们只想查看编译配置的依赖项时，结果如下：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There is also the `dependencyInsight` incubating task in Gradle. Because it
    is incubating, the functionality or syntax can change in future versions of Gradle.
    With the `dependencyInsight` task, we can find out why a specific dependency is
    in our build and to which configuration it belongs. We have to use the `--dependency`
    option, the required one, with part of the name of the dependency. Gradle will
    look for dependencies where the group, name, or version contains part of the specified
    value for the `--dependency` option. Optionally, we can specify the `--configuration`
    option to only look for the dependency in the specified configuration. If we leave
    out this option, Gradle will look for the dependency in all the configurations
    of our project.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Gradle 中还有一个名为 `dependencyInsight` 的孵化任务。由于它是孵化状态，Gradle 的功能或语法可能在未来的版本中发生变化。使用
    `dependencyInsight` 任务，我们可以找出为什么特定的依赖项在我们的构建中，以及它属于哪个配置。我们必须使用 `--dependency`
    选项，即必需的选项，并包含依赖项名称的一部分。Gradle 将查找包含 `--dependency` 选项指定的值的部分组、名称或版本的依赖项。可选地，我们可以指定
    `--configuration` 选项，仅在该指定的配置中查找依赖项。如果我们省略此选项，Gradle 将在我们的项目的所有配置中查找依赖项。
- en: 'Let''s invoke the `dependencyInsight` task to find the dependencies with Spring
    in the name and in the runtime configuration:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用 `dependencyInsight` 任务来查找名称中包含 Spring 且在运行时配置中的依赖项：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the output, we see how version `4.0.+` is resolved to `4.0.6.RELEASE`. We
    also see that the `spring-beans` dependency and the transitive `spring-core` dependency
    are part of the runtime configuration.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们看到版本 `4.0.+` 被解析为 `4.0.6.RELEASE`。我们还看到 `spring-beans` 依赖项和传递的 `spring-core`
    依赖项是运行时配置的一部分。
- en: Accessing dependencies
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问依赖项
- en: To access the configurations, we can use the `configurations` property of the
    Gradle project object. The `configurations` property contains a collection of
    `Configuration` objects. It is good to remember that a `Configuration` object
    is an instance of `FileCollection`. So, we can reference `Configuration` in our
    build scripts where `FileCollection` is allowed. The `Configuration` object contains
    more properties we can use to access the dependencies belonging to the configuration.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问配置，我们可以使用 Gradle 项目对象的 `configurations` 属性。`configurations` 属性包含一个 `Configuration`
    对象的集合。记住，`Configuration` 对象是 `FileCollection` 的一个实例。因此，我们可以在允许 `FileCollection`
    的构建脚本中引用 `Configuration`。`Configuration` 对象包含更多我们可以用来访问属于配置的依赖项的属性。
- en: 'In the next example build, we will define two tasks that work with the files
    and information available from configurations in the project:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例构建中，我们将定义两个任务，这些任务将使用项目配置中可用的文件和信息：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Buildscript dependencies
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建脚本依赖项
- en: When we define dependencies, we mostly want to define them for the code we are
    developing. However, we may also want to add a dependency to the Gradle build
    script itself. We can write code in our build files, which might be dependent
    on a library that is not included in the Gradle distribution. Let's suppose we
    want to use a class from the Apache Commons Lang library in our build script.
    We must add a `buildscript` configuration closure to our build script. Within
    the configuration closure, we can define repositories and dependencies. We must
    use the special `classpath` configuration to add dependencies to. Any dependency
    added to the `classpath` configuration can be used by the code in our build file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义依赖时，我们通常希望为正在开发的代码定义它们。然而，我们可能还想将依赖添加到 Gradle 构建脚本本身。我们可以在构建文件中编写代码，这些代码可能依赖于
    Gradle 分发中未包含的库。假设我们想在构建脚本中使用 Apache Commons Lang 库中的一个类。我们必须在我们的构建脚本中添加一个 `buildscript`
    配置闭包。在配置闭包内，我们可以定义仓库和依赖。我们必须使用特殊的 `classpath` 配置来添加依赖。任何添加到 `classpath` 配置的依赖都可以在我们的构建文件中的代码中使用。
- en: 'Let''s see how this works with an example build file. We want to use the `org.apache.commons.lang3.RandomStringUtils`
    class inside a `randomString` task. This class can be found in the `org.apache.commons:commons-lang3`
    dependency. We define this as an external dependency for the `classpath` configuration.
    We also include a repository definition inside the `buildscript` configuration
    block so that the dependency can be downloaded. The following code shows this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例构建文件来看看它是如何工作的。我们想在 `randomString` 任务中使用 `org.apache.commons.lang3.RandomStringUtils`
    类。这个类可以在 `org.apache.commons:commons-lang3` 依赖中找到。我们将它定义为 `classpath` 配置的外部依赖。我们还在
    `buildscript` 配置块中包含了一个仓库定义，以便可以下载依赖。以下代码展示了这一点：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To include external plugins, which are not part of the Gradle distribution,
    we can also use the `classpath` configuration in the `buildscript` configuration
    block. In the next example build file, we will include the `Asciidoctor` Gradle
    plugin:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了包含 Gradle 分发之外的插件，我们也可以在 `buildscript` 配置块中使用 `classpath` 配置。在下一个示例构建文件中，我们将包含
    `Asciidoctor` Gradle 插件：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Optional Ant task dependencies
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选 Ant 任务依赖
- en: We can reuse the existing Ant tasks in Gradle. The default tasks from Ant can
    be invoked from within our build scripts. However, if we want to use an optional
    Ant task, we must define a dependency for the classes needed by the optional Ant
    task. We create a new dependency configuration, and then we add a dependency to
    this new configuration. We can reference this configuration when setting the classpath
    for the optional Ant task.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Gradle 中重用现有的 Ant 任务。Ant 的默认任务可以从我们的构建脚本中调用。然而，如果我们想使用可选的 Ant 任务，我们必须为可选
    Ant 任务所需的类定义一个依赖。我们创建一个新的依赖配置，然后向这个新配置添加一个依赖。我们可以在设置可选 Ant 任务的类路径时引用这个配置。
- en: 'Let''s add the optional Ant task SCP for the secure copying of files to/from
    a remote server. We create the `sshAntTask` configuration to add dependencies
    for the optional Ant task. We can choose any name for the configuration. To define
    the optional task, we use the `taskdef` method from the internal `ant` object.
    The method takes a `classpath` attribute, which must be the actual path of all
    files of the `sshAntTask` dependencies. The `Configuration` class provides the
    `asPath` property to return the path to the files in a platform-specific way.
    So, if we use this on a Windows computer, the file path separator is a `;` and
    for other platforms it is a `:`. The following example build file contains all
    the code to define and uses the SCP Ant task:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加可选的 Ant 任务 SCP，用于安全地将文件从远程服务器复制到/从服务器。我们创建 `sshAntTask` 配置以添加可选 Ant 任务的依赖。我们可以为配置选择任何名称。为了定义可选任务，我们使用来自内部
    `ant` 对象的 `taskdef` 方法。该方法需要一个 `classpath` 属性，它必须是 `sshAntTask` 依赖中所有文件的实际路径。`Configuration`
    类提供了 `asPath` 属性，以平台特定的方式返回文件的路径。因此，如果我们使用 Windows 计算机上的这个属性，文件路径分隔符是 `;`，而对于其他平台则是
    `:`。以下示例构建文件包含了定义和使用 SCP Ant 任务的全部代码：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Managing dependencies
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理依赖
- en: 'You have already learned earlier in the chapter that we can refactor the dependency
    definitions by extracting common parts into project properties. This way, we only
    have to change a few project property values to make changes to multiple dependencies.
    In the next example build file, we will use lists to group dependencies together
    and reference those lists from the dependency definition:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中已经了解到，我们可以通过将公共部分提取到项目属性中来重构依赖定义。这样，我们只需更改几个项目属性值，就可以对多个依赖项进行更改。在下一个示例构建文件中，我们将使用列表来分组依赖项，并从依赖定义中引用这些列表：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Maven has a feature called dependency management metadata that allows us to
    define versions used for dependencies in a common part of the build file. Then,
    when the actual dependency is configured, we can leave out the version because
    it will be determined from the dependency management section of the build file.
    Gradle doesn't have such a built-in feature, but as illustrated earlier, we can
    use simple code refactoring to get a similar effect.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 有一个名为依赖管理元数据的功能，允许我们在构建文件的公共部分定义依赖项使用的版本。然后，当实际依赖项配置时，我们可以省略版本，因为它将从构建文件的依赖管理部分确定。Gradle
    没有这样的内置功能，但如前所述，我们可以使用简单的代码重构来获得类似的效果。
- en: 'We can still have declarative dependency management, as we do in Maven, in
    our Gradle build, with the external dependency management plugin by Spring. This
    plugin adds a `dependencyManagement` configuration block to Gradle. Inside the
    configuration block, we can define dependency metadata, such as the group, name,
    and version. In the `dependencies` configuration closure in our Gradle build script,
    we don''t have to specify the version anymore because it will be resolved via
    the dependency metadata in the `dependencyManagement` configuration. The following
    example build file uses this plugin and specifies dependency metadata using `dependencyManagement`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以在我们的 Gradle 构建中使用 Maven 的声明式依赖管理，通过 Spring 的外部依赖管理插件。此插件向 Gradle 添加了一个`dependencyManagement`配置块。在配置块内部，我们可以定义依赖元数据，例如组、名称和版本。在我们的
    Gradle 构建脚本中的`dependencies`配置闭包中，我们不再需要指定版本，因为它将通过`dependencyManagement`配置中的依赖元数据来解析。以下示例构建文件使用此插件并使用`dependencyManagement`指定依赖元数据：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To import a Maven **bill of materials** (**BOM**) provided by an organization,
    we can use the `imports` method inside the `dependencyManagement` configuration.
    In the next example, we will use the Spring IO platform BOM. In the `dependencies`
    configuration, we can leave out the version because it will be resolved via the
    BOM:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入一个组织提供的 Maven **物料清单**（**BOM**），我们可以在`dependencyManagement`配置中使用`imports`方法。在下一个示例中，我们将使用
    Spring IO 平台的 BOM。在`dependencies`配置中，我们可以省略版本，因为它将通过 BOM 来解析：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to create and use dependency configurations
    to group together dependencies. We saw how to define several types of dependencies,
    such as external module dependency and internal dependencies.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何创建和使用依赖配置来分组依赖项。我们看到了如何定义几种类型的依赖项，例如外部模块依赖和内部依赖。
- en: Also, we saw how we can add dependencies to code in Gradle build scripts with
    the `classpath` configuration and the `buildscript` configuration.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还看到了如何在 Gradle 构建脚本中使用`classpath`配置和`buildscript`配置向代码中添加依赖项。
- en: Finally, we looked at some maintainable ways of defining dependencies using
    code refactoring and the external dependency management plugin.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了使用代码重构和外部依赖管理插件定义依赖项的一些可维护的方法。
- en: In the next chapter, we will learn more about how we can configure repositories
    that store dependency modules.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何配置存储依赖模块的仓库。
