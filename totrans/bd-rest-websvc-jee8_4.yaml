- en: Building Asynchronous Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll talk about the motivations and reasons for asynchronous
    processing. Then, we'll see the basic implementation of asynchronous web services
    with JAX-RS. Then, we will have a look at improving our implementation using `ManagedExecutorService`
    and server-side callbacks. Finally, we will use the asynchronous JAX-RS API client
    to make REST calls, and explore the benefits and usage scenarios of asynchronous
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter includes the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and usage scenarios of asynchronous processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing asynchronous web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ManagedExecutorService and server-side callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing asynchronous web service clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefits and usage scenarios of asynchronous processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at the motivations and reasons for
    asynchronous request processing and why this matters to you. One thing I need
    to tell you is that *the free lunch is over! concurrency counts*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1e8bd82-c2a7-4114-a74c-22c12256f700.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the number of transistors on a processor is constantly rising;
    however, the clock speed pretty much stayed constant since 2004. This means you
    need to be more concurrent in order to get more speed, and we usually do this
    by using threads.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the request processing on the server usually works in a synchronous
    mode, which means that each request is processed in a single HTTP thread. This
    is what we are used to; we had one thread and we performed request responses in
    it. Unfortunately, threads are very expensive, so under a high load with a lot
    of concurrent connections, there is a lot of wasted resources and the server does
    not scale that well. Fortunately, we have asynchronous processing options.
  prefs: []
  type: TYPE_NORMAL
- en: Basic idea
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic idea of asynchronous processing is to separate our request I/O threads
    and the request processing threads by using different thread pools. This basically
    frees up our I/O threads to receive new connections while we do the processing
    on different threads.
  prefs: []
  type: TYPE_NORMAL
- en: Goal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ultimate goal is to save memory and improve the performance of our applications
    by using or reducing context-switching, and we can also improve the throughput
    by basically separating the request I/O from the request-processing.
  prefs: []
  type: TYPE_NORMAL
- en: These are the main motivations and reasons. In the next section, we will talk
    about implementing asynchronous web services.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing asynchronous web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at implementing asynchronous REST
    resources. We'll see the basic usage of the `@Suspended` annotation and the `AsyncResponse`
    class. We'll have a look at processing and resuming on an `AsyncResponse` instance
    in a different thread, and we will also talk about the basic timeout-handling
    for asynchronous responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started and switch to code. As usual, we prepare a few templates
    for us to get started. First up, I want to show you the basic structure of an
    asynchronous resource—have a look at the signature. All you need to do is implement
    a `public void` method that has at least one parameter that uses the `@Suspended`
    annotation. As a type, it uses the `AsyncResponse` class that''s provided by the
    JAX-RS API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's start with the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to do some heavy processing in a separate thread. First up, we''ll
    start a new thread and do the calculation within the thread. To simulate some
    heavy processing, we''ll have it sleep for three seconds, then we''ll produce
    some output. To do that, we return the request thread (`requestThreadName`). We
    also need the name of the current thread, and we get that using `getCurrentThreadName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we construct a `response` from `requestThread` and `responseThread`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is the basic structure of an asynchronous REST resource. We spawn a new
    thread, process it, construct a `response`, and finally, we call the `resume`
    method on the `response`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be slightly more sophisticated, we can use `BlockingQueue` and we have a
    method called `lock`, which takes the `@Suspended` asynchronous response. We want
    to save the asynchronous response to the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Down here in the `AsyncResource` class, we have an `unlock` method where we
    want to resume the processing on this currently-locked response. We take `asyncResponse`
    from the queue—this pulls the asynchronous response from the queue—and then we
    call the `resume` method on `response`. This will basically resume the previously
    locked request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we want to add some timeout behavior and we can set a specific timeout
    on `asyncResponse`. If the timeout is exceeded, an HTTP 403 status code is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to test this, switch to your REST client. First, we send a `GET`
    request for the API thread, then we implement it. As we can see here, `"requestThread"`
    is `http-listener(3)` and `"responseThread"` is a completely different thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d39e0ec-460b-4640-868d-4f02f6e1f784.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We do the same thing for the asynchronous `GET` request; we issue a `GET` request,
    which will be blocked. We call the unlock (`DELETE`) method and get our 204 No
    Content, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d8db691-aace-40e1-b0a5-c291b8d49d3e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we switch to the already issued `GET` request, we get 503 Service Unavailable,
    as in this case we waited for too long, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/611dc3d2-ee32-4685-bcc5-41f5c09b12ee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we call the `DELETE` method and the `GET` method, we see that the `"currentThread"`
    is `http-listener(6)`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/caa80767-9038-4b6c-9499-b0de0104b69d.png)'
  prefs: []
  type: TYPE_IMG
- en: That's it for this section.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll see how you can use `ManagedExecutorService` and
    server-side callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Using ManagedExecutorService and server-side callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at using a `ManagedExecutorService`
    instance for asynchronous request processing. I'm going to show you how to use
    `CompletableFuture` to run and resume asynchronous requests. We will talk about
    using a `TimeoutHandler` instance for fine-grained timer control, and we'll be
    using `CompletionCallback` and `ConnectionCallback` instances for even further
    control of the request processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started and switch to code. As usual, we prepare a template project
    to get started. The first thing we want to do is use a `ManagedExecutorService`
    instance. Thus, we will inject this instance into our REST resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we want to use this `ManagedExecutorService` instance to do some heavy
    processing, such as processing Fibonacci numbers. We will use the `ManagedExecutorService`
    instance and call the `execute` method on it. In this `execute` method, we then
    call `asyncResponse.resume` to resume the asynchronous response and we provide `Response`, which
    in our case is the requested Fibonacci number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'What else can we do? We should provide and specify the timeout to use, as we
    saw in [Chapter 3](b73054eb-e78a-4e76-8a06-8d24aff44801.xhtml), *Content Marshalling
    with JSON-B and JSON-P*. For this case, we specify a timeout of 10 seconds. We
    also want to specify a specific timeout behavior, since maybe we do not want to
    answer with an HTTP status code of 503 in this case. Since we want to specify
    something different, we can use a `setTimeoutHandler` instance. We will register `setTimeoutHandler`
    on the asynchronous response, and in case the timeout fires, we resume the response
    with HTTP status code 202, which is accepted and we just send back a random `UUID`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also register additional callbacks. There are two types of callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CompletionCallback`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConnectionCallback`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at both of them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: CompletionCallback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CompletionCallback` is the first callback. It is called by the JAX-RS runtime
    once the request is completed. The only method you need to implement is `onComplete`.
    In case of an error, you will be passed the `throwable` error and the `"Completed
    processing."` parameter, and we can do the required logic in here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: ConnectionCallback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second type of callback that is optionally supported is `ConnectionCallback`.
    Here, you can specify a custom implementation. Currently, the only method you
    need to implement is the `onDisconnect` method, which is passed the actual `AsyncResponse`.
    This method is called if the client is connected prematurely. According to JSR
    339, the support for `ConnectionCallback` is optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Registering callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we''ve implemented the two callbacks, you can register them with the asynchronous
    response. You can call `asyncResponse.register` and pass it the class of those
    callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: CompletableFuture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we can use `CompletableFuture` as an alternative syntactic sugar way
    of using those asynchronous REST APIs. Again, we use a `ManagedExecutorService`
    instance here. The next thing we want to do is use `CompletableFuture` to run
    the Fibonacci calculation asynchronously and then apply the `asyncResponse::resume`
    method. The code will look as follows. Using `CompletableFuture`, we call the
    `runAsync` method, run our Fibonacci calculation using the supplied `executorService`,
    and then apply the `asyncResponse::resume` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what this looks like in action. Let''s switch to our REST client.
    First, we call a Fibonacci of 9, which is 34, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9a9d6d7-90eb-4e51-8557-dc697ea107c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The same goes for Fibonacci at 17, which is 1,597, and so on and so forth.
    The Fibonacci of 42 takes slightly longer as it is a really long number. We can
    see what happens if we call the Fibonacci of 49; this is a really big number and
    it should trigger the timeout of 10 seconds—we expect an HTTP status code of 202
    Accepted, which you can see here, and we get sent back a random UUID response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6adeaf3e-6f9f-4246-a6e1-f3c82095d2a2.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will talk about implementing asynchronous web service
    clients.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing asynchronous web service clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at the basic usage of asynchronous
    JAX-RS client APIs. We're using `InvocationCallback` instances to react to completed
    and failed calls. We'll also see how to do invocation-chaining of asynchronous
    client requests with `CompletableFuture`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started and switch to code. As usual, we prepared a small template
    project to get started. We'll be using a JUnit test to showcase the JAX-RS client
    APIs. We're going to set up the JAX-RS `client` instance and the JAX-RS `webTarget`
    instance for the previously implemented asynchronous service API. As you might
    remember, in the previous section, we used Fibonacci number calculations asynchronously.
    We'll rewrite the test using the asynchronous JAX-RS client APIs against our REST
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the `AsyncWebServiceClientIntegrationTest` class and start our
    tests; the first test should be pretty easy. We want to construct an asynchronous
    request and we do this the way we did it before. We use `webTarget.path` and we
    request `TEXT_PLAIN_TYPE`. Now comes the real difference: we call the `.async()`
    method and then call `.get(Long.class)`. As you can see, the return type of this
    call is `Future<long>`. Let''s rename it from `longFuture` to `fibonacci` and
    call the `assertEquals` method on that one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is pretty much all there is to using asynchronous APIs, though there is
    slightly more. You can register an invocation callback with `get` to be notified
    on completed and failed events. Then, we''ll see how we implement those callbacks.
    As you can see, instead of calling `get` for the actual `(Long.class)` type, as
    we did previously, we call the `get` of `InvocationCallback<Long>`. We can implement
    the `completed` method for a successful execution and the `failed` method for
    a failure. Again, we''ll return `Future<Long>` for a Fibonacci number and we can
    then call the `get` method on this `Future`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll see how to do invocation-chaining using `CompletableFuture`.
    This is quite interesting because we can chain several JAX-RS client calls using
    a `CompletableFuture` fluent API. Imagine we want to calculate the Fibonacci numbers
    3, 4, 5, 6, 8, and 21 and do all that in one chain call. This is what it could
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we do the first call and we use the `.async()` method, which
    returns `Future`. We'll convert this `Future` to a `CompletableFuture`, and then
    for the next calls, we use `thenApply` and we'll do that for the next one and
    so on and so forth. This will ultimately make seven calls.
  prefs: []
  type: TYPE_NORMAL
- en: Let's run this test to make sure everything's ready and it'll compile our tests.
    We can see that the first three are already successful; the `Fibonacci49WithCallback`
    should result in a 202, and then we're done.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s all the magic behind the JAX-RS asynchronous line API, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0207a312-af5c-476e-b2a0-9a213190db2e.png)'
  prefs: []
  type: TYPE_IMG
- en: Output showing asynchronous tests running successfully
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about the motivation and benefits of luminous web
    services, and how they ultimately save memory and improve the performance and
    throughput of our REST API. We then talked about the basic usage of the `@Suspended`
    annotation and the `AsyncResponse` class. We learned how to use `TimeoutHandler`
    and server-side callback instances for fine-grained control. We then used `ManagedExecutorService`
    and `CompletableFuture` for some more syntactic sugar. Finally, we talked about
    the usage of asynchronous JAX-RS client APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll talk about using server-sent events.
  prefs: []
  type: TYPE_NORMAL
