["```java\npublic class Tree<E> {\n    public static class Node<E>{\n        private E value;\n        private LinkedList<Node<E>> children;\n        private Tree<E> hostTree;\n        private Node<E> parent;\n\n        public LinkedList<Node<E>> getChildren() {\n            return children;\n        }\n\n        public E getValue() {\n            return value;\n        }\n\n        private Node(LinkedList<Node<E>> children, Tree<E> hostTree, \n        E value, Node<E> parent) {\n            this.children = children;\n            this.hostTree = hostTree;\n            this.value = value;\n            this.parent = parent;\n        }\n    }\n\n...\n}\n```", "```java\n    private Node<E> root;\n\n    public void addRoot(E value){\n        if(root == null){\n            root = new Node<>(new LinkedList<>(), this, value, null );\n        }else{\n            throw new IllegalStateException(\n                \"Trying to add new node to a non empty tree\");\n        }\n    }\n```", "```java\n    public Node<E> addNode(Node<E> parent, E value){\n        if(parent==null){\n            throw new NullPointerException(\"Cannot add child to null parent\");\n        }else if(parent.hostTree != this){\n            throw new IllegalArgumentException(\n                \"Parent node not a part of this tree\");\n        }else{\n            Node<E> newNode = new Node<>(new LinkedList<>(), this, value, parent);\n            parent.getChildren().appendLast(newNode);\n            return newNode;\n        }\n    }\n```", "```java\n    public Node<E> getRoot() {\n        return root;\n    }\n```", "```java\n    public static void main(String [] args){\n        Tree<Integer> tree = new Tree<>();\n        tree.addRoot(1);\n        Node<Integer> node1 = tree.getRoot();\n        Node<Integer> node2 = tree.addNode(node1, 5);\n        Node<Integer> node3 = tree.addNode(node1, 1);\n        Node<Integer> node4 = tree.addNode(node2, 2);\n        Node<Integer> node5 = tree.addNode(node2, 5);\n        Node<Integer> node6 = tree.addNode(node2, 9);\n        Node<Integer> node7 = tree.addNode(node3, 6);\n        Node<Integer> node8 = tree.addNode(node3, 2);\n        Node<Integer> node9 = tree.addNode(node5, 5);\n        Node<Integer> node10 = tree.addNode(node6, 9);\n        Node<Integer> node11 = tree.addNode(node6, 6);\n    }\n```", "```java\nprotected void traverseDepthFirst(OneArgumentStatement<E> processor, Node<E> current){\n    processor.doSomething(current.value);\n    current.children.forEach((n)-> traverseDepthFirst(processor, n));\n}\n```", "```java\npublic void traverseDepthFirst(OneArgumentStatement<E> processor){\n    traverseDepthFirst(processor, getRoot());\n}\n```", "```java\npublic void traverseDepthFirstUsingStack(\n    OneArgumentStatement<E> processor){\n\n    Stack<Node<E>> stack = new StackImplLinkedList<>();\n    stack.push(getRoot());\n    while(stack.peek()!=null){\n        Node<E> current = stack.pop();\n        processor.doSomething(current.value);\n        current.children.forEach((n)->stack.push(n));\n    }\n}\n```", "```java\npublic void traverseDepthFirstUsingStack(\n    OneArgumentStatement<E> processor){\n\n    Stack<Node<E>> stack = new StackImplLinkedList<>();\n    stack.push(getRoot());\n    while(stack.peek()!=null){\n        Node<E> current = stack.pop();\n        processor.doSomething(current.value);\n LinkedList<Node<E>> reverseList = new LinkedList<>();\n current.children.forEach((n)->reverseList.appendFirst(n));\n reverseList.forEach((n)->stack.push(n));\n    }\n}\n```", "```java\npublic void traverseBreadthFirst(OneArgumentStatement<E> processor){\n    Queue<Node<E>> queue = new QueueImplLinkedList<>();\n    queue.enqueue(getRoot());\n    while(queue.peek()!=null){\n        Node<E> current = queue.dequeue();\n        processor.doSomething(current.value);\n        current.children.forEach((n)->queue.enqueue(n));\n    }\n}\n```", "```java\npublic class FunctionalTree<E> {\n    private E value;\n    private LinkedList<FunctionalTree<E>> children;\n```", "```java\n    public FunctionalTree(E value, LinkedList<FunctionalTree<E>> children) {\n        this.children = children;\n        this.value = value;\n    }\n\n    public  LinkedList<FunctionalTree<E>> getChildren() {\n        return children;\n    }\n\n    public E getValue() {\n        return value;\n    }\n\n    public void traverseDepthFirst(OneArgumentStatement<E> processor){\n        processor.doSomething(value);\n        children.forEach((n)-> n.traverseDepthFirst(processor));\n    }\n\n}\n```", "```java\npublic static void main(String [] args){\n    LinkedList<FunctionalTree<Integer>> emptyList = LinkedList.emptyList();\n\n    FunctionalTree<Integer> t1 = new FunctionalTree<>(5, emptyList);\n    FunctionalTree<Integer> t2 = new FunctionalTree<>(9, emptyList);\n    FunctionalTree<Integer> t3 = new FunctionalTree<>(6, emptyList);\n\n    FunctionalTree<Integer> t4 = new FunctionalTree<>(2, emptyList);\n    FunctionalTree<Integer> t5 = new FunctionalTree<>(5, emptyList.add(t1));\n    FunctionalTree<Integer> t6 = new FunctionalTree<>(9, \n         emptyList.add(t3).add(t2));\n    FunctionalTree<Integer> t7 = new FunctionalTree<>(6, emptyList);\n    FunctionalTree<Integer> t8 = new FunctionalTree<>(2, emptyList);\n\n    FunctionalTree<Integer> t9 = new FunctionalTree<>(5,\n         emptyList.add(t6).add(t5).add(t4));\n    FunctionalTree<Integer> t10 = new FunctionalTree<>(1,\n         emptyList.add(t8).add(t7));\n\n    FunctionalTree<Integer> tree = new FunctionalTree<>(1,\n         emptyList.add(t10).add(t9));\n```", "```java\n    tree.traverseDepthFirst(System.out::print);\n}\n```", "```java\npublic class BinaryTree<E>  {\n```", "```java\n    public static class Node<E>{\n        private E value;\n        private Node<E> left;\n        private Node<E> right;\n        private Node<E> parent;\n        private BinaryTree<E> containerTree;\n\n        protected Node(Node<E> parent,\n        BinaryTree<E> containerTree, E value) {\n            this.value = value;\n            this.parent = parent;\n            this.containerTree = containerTree;\n        }\n\n        public E getValue(){\n            return value;\n        }\n    }\n```", "```java\n    private Node<E> root;\n\n    public void addRoot(E value){\n        root = new Node<>(null, this,  value);\n    }\n\n    public Node<E> getRoot(){\n        return root;\n    }\n```", "```java\n    public Node<E> addChild(Node<E> parent, E value, boolean left){\n        if(parent == null){\n            throw new NullPointerException(\"Cannot add node to null parent\");\n        }else if(parent.containerTree != this){\n            throw new IllegalArgumentException\n                   (\"Parent does not belong to this tree\");\n        }else {\n            Node<E> child = new Node<E>(parent, this, value);\n            if(left){\n                parent.left = child;\n            }else{\n                parent.right = child;\n            }\n            return child;\n        }\n    }\n```", "```java\n    public Node<E> addChildLeft(Node<E> parent, E value){\n        return addChild(parent, value, true);\n    }\n\n    public Node<E> addChildRight(Node<E> parent, E value){\n        return addChild(parent, value, false);\n    }\n\n}\n```", "```java\npublic static enum DepthFirstTraversalType{\n    PREORDER, INORDER, POSTORDER\n}\n\npublic void traverseDepthFirst(OneArgumentStatement<E> processor,\n                      Node<E> current, DepthFirstTraversalType tOrder){\n    if(current==null){\n        return;\n    }\n    if(tOrder == DepthFirstTraversalType.PREORDER){\n        processor.doSomething(current.value);\n    }\n    traverseDepthFirst(processor, current.left, tOrder);\n    if(tOrder == DepthFirstTraversalType.INORDER){\n        processor.doSomething(current.value);\n    }\n    traverseDepthFirst(processor, current.right, tOrder);\n    if(tOrder == DepthFirstTraversalType.POSTORDER){\n        processor.doSomething(current.value);\n    }\n}\n```", "```java\npublic static void main(String [] args){\n    BinaryTree<Integer> tree = new BinaryTree<>();\n    tree.addRoot(1);\n    Node<Integer> n1 = tree.getRoot();\n    Node<Integer> n2 = tree.addChild(n1, 2, true);\n    Node<Integer> n3 = tree.addChild(n1, 3, false);\n    Node<Integer> n4 = tree.addChild(n2, 4, true);\n    Node<Integer> n5 = tree.addChild(n2, 5, false);\n    Node<Integer> n6 = tree.addChild(n3, 6, true);\n    Node<Integer> n7 = tree.addChild(n3, 7, false);\n    Node<Integer> n8 = tree.addChild(n4, 8, true);\n    Node<Integer> n9 = tree.addChild(n4, 9, false);\n    Node<Integer> n10 = tree.addChild(n5, 10, true);\n\n    tree.traverseDepthFirst(System.out::print, tree.getRoot(),\n     DepthFirstTraversalType.PREORDER);\n    System.out.println();\n\n    tree.traverseDepthFirst(System.out::print, tree.getRoot(),\n     DepthFirstTraversalType.INORDER);\n    System.out.println();\n\n    tree.traverseDepthFirst(System.out::print, tree.getRoot(),\n     DepthFirstTraversalType.POSTORDER);\n    System.out.println();\n} \n```", "```java\n1 2 4 8 9 5 10 3 6 7\n8 4 9 2 10 5 1 6 3 7\n8 9 4 10 5 2 6 7 3 1\n```", "```java\npublic void traversePreOrderNonRecursive(\n    OneArgumentStatement<E> processor) {\n    Stack<Node<E>> stack = new StackImplLinkedList<>();\n    stack.push(getRoot());\n    while (stack.peek()!=null){\n        Node<E> current = stack.pop();\n        processor.doSomething(current.value);\n        if(current.right!=null)\n            stack.push(current.right);\n        if(current.left!=null)\n            stack.push(current.left);\n    }\n}\n```", "```java\npublic void traverseInOrderNonRecursive(\n  OneArgumentStatement<E> processor) {\n    class StackFame{\n        Node<E> node;\n        boolean childrenPushed = false;\n\n        public StackFame(Node<E> node, boolean childrenPushed) {\n            this.node = node;\n            this.childrenPushed = childrenPushed;\n        }\n    }\n    Stack<StackFame> stack = new StackImplLinkedList<>();\n    stack.push(new StackFame(getRoot(), false));\n    while (stack.peek()!=null){\n       StackFame current = stack.pop();\n        if(current.childrenPushed){\n            processor.doSomething(current.node.value);\n        }else{\n            if(current.node.right!=null)\n                stack.push(new StackFame(current.node.right, false));\n            stack.push(new StackFame(current.node, true));\n            if(current.node.left!=null)\n                stack.push(new StackFame(current.node.left, false));\n        }\n    }\n}\n```", "```java\npublic void traversePostOrderNonRecursive(OneArgumentStatement<E> processor) {\n    class StackFame{\n        Node<E> node;\n        boolean childrenPushed = false;\n\n        public StackFame(Node<E> node, boolean childrenPushed) {\n            this.node = node;\n            this.childrenPushed = childrenPushed;\n        }\n    }\n    Stack<StackFame> stack = new StackImplLinkedList<>();\n    stack.push(new StackFame(getRoot(), false));\n    while (stack.peek()!=null){\n        StackFame current = stack.pop();\n        if(current.childrenPushed){\n            processor.doSomething(current.node.value);\n        }else{\n stack.push(new StackFame(current.node, true));\n if(current.node.right!=null)\n stack.push(new StackFame(current.node.right, false));\n\n            if(current.node.left!=null)\n                stack.push(new StackFame(current.node.left, false));\n            }\n    }\n}\n```", "```java\npublic static void main(String [] args){\n    BinaryTree<Integer> tree = new BinaryTree<>();\n    tree.addRoot(1);\n    Node<Integer> n1 = tree.getRoot();\n    Node<Integer> n2 = tree.addChild(n1, 2, true);\n    Node<Integer> n3 = tree.addChild(n1, 3, false);\n    Node<Integer> n4 = tree.addChild(n2, 4, true);\n    Node<Integer> n5 = tree.addChild(n2, 5, false);\n    Node<Integer> n6 = tree.addChild(n3, 6, true);\n    Node<Integer> n7 = tree.addChild(n3, 7, false);\n    Node<Integer> n8 = tree.addChild(n4, 8, true);\n    Node<Integer> n9 = tree.addChild(n4, 9, false);\n    Node<Integer> n10 = tree.addChild(n5, 10, true);\n\n    tree.traverseDepthFirst((x)->System.out.print(\"\"+x), tree.getRoot(), DepthFirstTraversalType.PREORDER);\n    System.out.println();\n    tree.traverseDepthFirst((x)->System.out.print(\"\"+x), tree.getRoot(), DepthFirstTraversalType.INORDER);\n    System.out.println();\n    tree.traverseDepthFirst((x)->System.out.print(\"\"+x), tree.getRoot(), DepthFirstTraversalType.POSTORDER);\n    System.out.println();\n\n    System.out.println();\n tree.traversePreOrderNonRecursive((x)->System.out.print(\"\"+x));\n System.out.println();\n tree.traverseInOrderNonRecursive((x)->System.out.print(\"\"+x));\n System.out.println();\n tree.traversePostOrderNonRecursive((x)->System.out.print(\"\"+x));\n System.out.println();\n\n}\n```", "```java\n1 2 4 8 9 5 10 3 6 7\n8 4 9 2 10 5 1 6 3 7\n8 9 4 10 5 2 6 7 3 1\n\n1 2 4 8 9 5 10 3 6 7\n8 4 9 2 10 5 1 6 3 7\n8 9 4 10 5 2 6 7 3 1\n```"]