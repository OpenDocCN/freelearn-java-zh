<html><head></head><body>
		<div id="_idContainer133">
			<h1 id="_idParaDest-132"><em class="italic"><a id="_idTextAnchor138"/>Chapter 7</em>: GraalVM Polyglot – JavaScript and Node.js </h1>
			<p>In the previous chapter, we looked at how Truffle provides a layer to integrate other language programs to run on GraalVM. In this chapter, we will focus on JavaScript and Node.js interpreters, and in the next chapter, we will cover other runtimes, such as Java/Truffle, Python, R, and WebAssembly. We will be covering aspects of the polyglot interoperability features of Truffle and exploring the JavaScript interpreter. We will be exploring these features hands-on by writing code.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Understanding how to run non-JVM language applications on Graal, specifically JavaScript and Node</li>
				<li>Learning how to pass objects/values between applications written in different languages</li>
				<li>Understanding how to use optimization techniques to fine-tune the code</li>
			</ul>
			<p>By the end of this chapter, you will have a very clear understanding of how to build a polyglot application on GraalVM.</p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor139"/>Technical requirements</h1>
			<p>In this chapter, we will be doing a lot of hands-on coding, to explore the various guest languages that GraalVM supports. To try the code, you will need the following: </p>
			<ul>
				<li>Various language Graal runtimes: We will cover in the chapter how to install and run these runtimes.</li>
				<li>Access to GitHub: There are some sample code snippets, which are available in a Git repository. The code can be downloaded from the following link. You will find the chapter-specific code under the <strong class="source-inline">chapter7</strong> directory: <a href="https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter07/js">https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter07/js</a>.</li>
				<li>The Code in Action video for this chapter can be found at <a href="https://bit.ly/3yqu4ui">https://bit.ly/3yqu4ui</a>.</li>
			</ul>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor140"/>Understanding the JavaScript (including Node.js) Truffle interpreter</h1>
			<p>The GraalVM version of JavaScript is an ECMAScript-compliant runtime for both JavaScript, <strong class="source-inline">js</strong>, and Node.js, <strong class="source-inline">node</strong>. It supports all the features of ECMAScript 2021, at the time of writing this book. It is also Nashorn- and Rhino-compatible and provides complete support for Node.js. </p>
			<p>GraalVM Node.js uses <a id="_idIndexMarker581"/>the original Node.js source code and replaces the V8 JavaScript engine with the GraalVM JavaScript engine. The replacement is seamless, and the application developers don't have to modify any significant amount of code or configuration to run existing Node.js applications with GraalVM Node.js. GraalVM Node.js provides <a id="_idIndexMarker582"/>more features for embedding code from other languages, and accessing data and code, and interoperating code in other language. <strong class="bold">Node package manager</strong> (<strong class="bold">NPM</strong>) is also included in <strong class="source-inline">npm</strong>. </p>
			<p>In this section, apart from using JavaScript and Node as an alternate runtime for running applications, we will also explore their polyglot interoperability features. We will be walking through a lot of JavaScript and Node.js sample code to explore the polyglot capabilities of the GraalVM JavaScript runtime.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor141"/>Verifying JavaScript, Node, and npm installation and versions</h2>
			<p>JavaScript and Node.js come along <a id="_idIndexMarker583"/>with the GraalVM installation; you will <a id="_idIndexMarker584"/>find them in the <strong class="source-inline">&lt;GraalHome&gt;/bin</strong> directory. We <a id="_idIndexMarker585"/>can check if the JavaScript runtime is properly configured by checking the version number. </p>
			<p>To check the version, execute the <strong class="source-inline">js --version</strong> command. At the time of writing this book, GraalVM JavaScript 21.0.0.2 was the latest. The following is the output (note that it is GraalVM JavaScript): </p>
			<p class="source-code">GraalVM JavaScript (GraalVM EE Native 21.0.0.2)</p>
			<p>We can also ensure that we are running the right version of Node.js by calling a specific node.js version by executing the <strong class="source-inline">node --version</strong> command. In the following command, we are explicitly calling the right version. Note that the GraalVM home location might be different for you: </p>
			<p class="source-code">/Library/Java/JavaVirtualMachines/graalvm-ee-java11-21.0.0.2/Contents/Home/bin/node --version</p>
			<p class="source-code">v12.20.1</p>
			<p>Let's also <a id="_idIndexMarker586"/>make sure NPM is working by <a id="_idIndexMarker587"/>executing the <strong class="source-inline">npm --version</strong> command. The <a id="_idIndexMarker588"/>following is the <a id="_idIndexMarker589"/>command and output:</p>
			<p class="source-code">/Library/Java/JavaVirtualMachines/graalvm-ee-java11-21.0.0.2/Contents/Home/bin/npm --version</p>
			<p class="source-code">6.14.10</p>
			<p>Now that we have verified the JavaScript, Node.js, and npm installations, let's create a simple Node.js <a id="_idIndexMarker590"/>application. </p>
			<p>Go to an application folder, and execute <strong class="source-inline">npm init</strong>. This will set up the boilerplate configuration for the Node.js application. We will name the application <strong class="source-inline">graal-node-app</strong>. The following shows the console output:</p>
			<p class="source-code">/Library/Java/JavaVirtualMachines/graalvm-ee-java11-21.0.0.2/Contents/Home/bin/npm init     </p>
			<p class="source-code">package name: (npm) graal-node-app</p>
			<p class="source-code">version: (1.0.0) 1.0.0</p>
			<p class="source-code">description: </p>
			<p class="source-code">entry point: (index.js) </p>
			<p class="source-code">test command: </p>
			<p class="source-code">git repository: </p>
			<p class="source-code">keywords: </p>
			<p class="source-code">author: </p>
			<p class="source-code">license: (ISC) </p>
			<p class="source-code">About to write to /chapter7/js/npm/package.json:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "name": "graal-node-app",</p>
			<p class="source-code">  "version": "1.0.0",</p>
			<p class="source-code">  "description": "",</p>
			<p class="source-code">  "main": "index.js",</p>
			<p class="source-code">  "scripts": {</p>
			<p class="source-code">    "test": "echo \"Error: no test specified\" andand exit 1"</p>
			<p class="source-code">  },</p>
			<p class="source-code">  "author": "",</p>
			<p class="source-code">  "license": "ISC"</p>
			<p class="source-code">}</p>
			<p class="source-code">Is this OK? (yes)</p>
			<p>This creates a <a id="_idIndexMarker591"/>Node.js application and a <strong class="source-inline">package.json</strong> file with a boilerplate configuration, based on the options we selected. Let's install the <strong class="source-inline">express</strong> package by executing <strong class="source-inline">npm install --save express</strong>. This installs the <strong class="source-inline">express</strong> package in the application folder and also updates the <strong class="source-inline">package.json</strong> file (because of the <strong class="source-inline">--save</strong> argument). Here is the output:</p>
			<p class="source-code">/Library/Java/JavaVirtualMachines/graalvm-ee-java11-21.0.0.2/Contents/Home/bin/npm install --save express</p>
			<p class="source-code">npm notice created a lockfile as package-lock.json. You should commit this file.</p>
			<p class="source-code">npm WARN graal-node-app@1.0.0 No description</p>
			<p class="source-code">npm WARN graal-node-app@1.0.0 No repository field.</p>
			<p class="source-code">+ express@4.17.1</p>
			<p class="source-code">added 50 packages from 37 contributors and audited 50 packages in 6.277s</p>
			<p class="source-code">found 0 vulnerabilities</p>
			<p>You will find the <strong class="source-inline">node_modules</strong> directory, which <a id="_idIndexMarker592"/>contains all the packages that are required to run our application. Let's create an <strong class="source-inline">index.js</strong> file with the following code:</p>
			<p class="source-code">var express = require('express');</p>
			<p class="source-code">var app = express();</p>
			<p class="source-code">app.get('/', function(request, response) {</p>
			<p class="source-code">    var responseString = "&lt;h1&gt;Hello Graal Node &lt;/h1&gt;";</p>
			<p class="source-code">    response.send(responseString);</p>
			<p class="source-code">});</p>
			<p class="source-code">app.listen(8080, function() {</p>
			<p class="source-code">    console.log('Started the server at 8080')</p>
			<p class="source-code">});</p>
			<p>As you can see, it's a very simple application, which responds with an HTML <strong class="source-inline">Hello Graal Node</strong> as a header 1, when invoked at the root. The application will listen at port number <strong class="source-inline">8080</strong>. </p>
			<p>Let's run this application with the following command: </p>
			<p class="source-code">/Library/Java/JavaVirtualMachines/graalvm-ee-java11-21.0.0.2/Contents/Home/bin/node index.js </p>
			<p class="source-code">Started the server at 8080</p>
			<p>Now that we can see the output, we know that the application is listening at <strong class="source-inline">8080</strong>. Let's try to call this from the web browser at http://localhost:8080/. The following is the screenshot of the <a id="_idIndexMarker593"/>application response on the web browser: </p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/B16878_Figure_7.1.jpg" alt="Figure 7.1 – Hello Graal Node screenshot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Hello Graal Node screenshot</p>
			<p>Now that we know that the Node.js on GraalVM is working fine, let's understand the polyglot interoperability. </p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor142"/>JavaScript interoperability </h2>
			<p>In <a href="B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120"><em class="italic">Chapter 6</em></a>, <em class="italic">Truffle – An Overview</em>, we went <a id="_idIndexMarker594"/>into a lot of details about how Truffle enables polyglot support and provides an infrastructure for polyglot interoperability and polyglot embedding. In this section, we will explore these features with sample code. </p>
			<p>Let's take the Node.js application that we created in the previous section, and add an endpoint, <strong class="source-inline">/poly</strong>, in our <strong class="source-inline">index.js</strong> file. Let's create a simple Python array object, and store some <a id="_idIndexMarker595"/>numbers in the object. We will then iterate through this Python object in Node.js, to list these numbers. This shows how we can embed Python code snippets within JavaScript. </p>
			<p>The following source code shows this new endpoint, <strong class="source-inline">/poly</strong>:</p>
			<p class="source-code">var express = require('express');</p>
			<p class="source-code">var app = express();</p>
			<p class="source-code">app.get('/', function(request, response) {</p>
			<p class="source-code">    var responseString = "&lt;h1&gt;Hello Graal Node &lt;/h1&gt;";</p>
			<p class="source-code">    response.send(responseString);</p>
			<p class="source-code">});</p>
			<p class="source-code">app.get('/poly', function(request, response) {</p>
			<p class="source-code">    var responseString = "&lt;h1&gt;Hello Graal Polyglot &lt;/h1&gt;";</p>
			<p class="source-code">    var array = Polyglot.eval("python", "[1,2,3,4, 100,                              200, 300, 400]")</p>
			<p class="source-code">    responseString = responseString + "&lt;ul&gt;";</p>
			<p class="source-code">    for (let index = 0; index &lt; array.length; index++) {</p>
			<p class="source-code">        responseString = responseString + "&lt;li&gt;";</p>
			<p class="source-code">        responseString = responseString + array[index];</p>
			<p class="source-code">        responseString = responseString + "&lt;/li&gt;";</p>
			<p class="source-code">    }</p>
			<p class="source-code">    responseString = responseString + "&lt;/ul&gt;";</p>
			<p class="source-code">    response.send(responseString);</p>
			<p class="source-code">});</p>
			<p>Now let's have the code to listen at port <strong class="source-inline">8080</strong> and call the preceding function when we receive a request:</p>
			<p class="source-code">app.listen(8080, function() {</p>
			<p class="source-code">    console.log('Started the server at 8080')</p>
			<p class="source-code">});</p>
			<p>As you can <a id="_idIndexMarker596"/>see in the code, we are using the <strong class="source-inline">Polyglot.eval()</strong> method to run Python code. To let the polyglot object know that it's Python code, we are passing <strong class="source-inline">python</strong> as a parameter, and passing the Python representation of the array. Let's now run this code with <strong class="source-inline">node</strong>: </p>
			<p class="source-code">/Library/Java/JavaVirtualMachines/graalvm-ee-java11-21.0.0.2/Contents/Home/bin/node --jvm --polyglot index.js</p>
			<p class="source-code">Started the server at 8080</p>
			<p>Note that we have to pass <strong class="source-inline">--jvm</strong> and <strong class="source-inline">--polyglot</strong> arguments to node. It's very important to pass these parameters. <strong class="source-inline">--jvm</strong> tells node to <a id="_idIndexMarker597"/>run on <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>), and <strong class="source-inline">--polyglot</strong>, as the name suggests, tells node to support <strong class="source-inline">polyglot</strong>. Since Truffle and Graal run on JVM, it's important to use the <strong class="source-inline">jvm</strong> argument, even though we may not be directly using Java in our code.</p>
			<p>Let's now access this new endpoint from the browser. The following screenshot shows the output as expected:</p>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/B16878_Figure_7.2.jpg" alt="Figure 7.2 – /poly endpoint result screenshot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – /poly endpoint result screenshot</p>
			<p>As you might <a id="_idIndexMarker598"/>have noticed, the first time we called, it took time to load the page, but the subsequent calls are instantaneous. Let's just time that <a id="_idIndexMarker599"/>with curl (curl is a command-line utility to call any URLs. Please refer to <a href="https://curl.se/">https://curl.se/</a> for more details on curl and how to install curl on your machine). The following is a screenshot of a sequence of curl commands: </p>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="image/B16878_Figure_7.3.jpg" alt="Figure 7.3 – Performance of Node.js after subsequent calls &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – Performance of Node.js after subsequent calls </p>
			<p>We can see the <a id="_idIndexMarker600"/>initial load on the CPU, but subsequent calls are quick with no additional load on the CPU.</p>
			<p>Let's now explore more advanced features of polyglot interoperability. JavaScript and Java interoperability is very sophisticated. Let's explore the concepts with more complex implementations than lists. </p>
			<h3>JavaScript embedded code in Java</h3>
			<p>Let's recall the <strong class="source-inline">FibonaaciCalculator.java</strong> file that we used in previous chapters. Let's <a id="_idIndexMarker601"/>modify that <strong class="source-inline">FibonacciCalculator.java</strong> to use a JavaScript snippet and execute that JavaScript snippet within Java.</p>
			<p>Here is the modified version of the <strong class="source-inline">FibonacciCalculator</strong> with an embedded JavaScript snippet. The Java file is called <strong class="source-inline">FibonacciCalculatorPolyglot.java</strong>. You can find the full code in the Git repository:</p>
			<p class="source-code">import org.graalvm.polyglot.*;</p>
			<p class="source-code">import org.graalvm.polyglot.proxy.*;</p>
			<p>We have to import the <strong class="source-inline">polyglot</strong> classes. This implements the Truffle interoperability:</p>
			<p class="source-code">public class FibonacciCalculatorPolyglot{</p>
			<p class="source-code">    static String JS_SNIPPET =     "(function logTotalTime(param){console.log('total(from         JS) : '+param);})";</p>
			<p class="source-code">    public int[] findFibonacci(int count) {</p>
			<p class="source-code">        int fib1 = 0;</p>
			<p class="source-code">        int fib2 = 1;</p>
			<p class="source-code">        int currentFib, index;</p>
			<p class="source-code">        int [] fibNumbersArray = new int[count];</p>
			<p class="source-code">        for(index=2; index &lt; count; ++index ) {    </p>
			<p class="source-code">            currentFib = fib1 + fib2;    </p>
			<p class="source-code">            fib1 = fib2;    </p>
			<p class="source-code">            fib2 = currentFib;    </p>
			<p class="source-code">            fibNumbersArray[index - 1] = currentFib;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        return fibNumbersArray;</p>
			<p class="source-code">    }</p>
			<p>Now let's <a id="_idIndexMarker602"/>define the <strong class="source-inline">main()</strong> function, which will invoke <strong class="source-inline">findFibonacci()</strong> several times to reach the compiler threshold: </p>
			<p class="source-code">    public static void main(String args[]){    </p>
			<p class="source-code">        FibonacciCalculatorPolyglot fibCal             = new FibonacciCalculatorPolyglot();</p>
			<p class="source-code">        long startTime = System.currentTimeMillis();</p>
			<p class="source-code">        long now = 0;</p>
			<p class="source-code">        long last = startTime;</p>
			<p class="source-code">        for (int i = 1000000000; i &lt; 1000000010; i++) {</p>
			<p class="source-code">            int[] fibs = fibCal.findFibonacci(i);</p>
			<p class="source-code">            </p>
			<p class="source-code">            long total = 0;</p>
			<p class="source-code">            for (int j=0; j&lt;fibs.length; j++) {</p>
			<p class="source-code">                total += fibs[j];</p>
			<p class="source-code">            }</p>
			<p class="source-code">            now = System.currentTimeMillis();</p>
			<p class="source-code">            System.out.printf("%d (%d ms)%n", i , now – last);</p>
			<p class="source-code">            last = now;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        long endTime = System.currentTimeMillis();</p>
			<p class="source-code">        long totalTime =             System.currentTimeMillis() - startTime;</p>
			<p class="source-code">        System.out.printf("total (from Java): (%d ms)%n",                          totalTime);  </p>
			<p class="source-code">        try (Context context = Context.create()) {</p>
			<p class="source-code">            Value value = context.eval("js", JS_SNIPPET);</p>
			<p class="source-code">            value.execute(totalTime);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Let's <a id="_idIndexMarker603"/>explore this code. We have defined a static <strong class="source-inline">String</strong> variable that holds the JavaScript snippet, shown next:</p>
			<p class="source-code">static String JS_SNIPPET = "(function logTotalTime(param){console.log('total(from JS) : '+param);})";</p>
			<p>We have defined a static <strong class="source-inline">String</strong> with a simple JavaScript function that prints whatever is the parameter that is passed to it. To invoke this JavaScript code within Java, we need to first import the <strong class="source-inline">Polyglot</strong> libraries by importing the following packages:</p>
			<p class="source-code">import org.graalvm.polyglot.Context;</p>
			<p class="source-code">import org.graalvm.polyglot.Value;</p>
			<p>To invoke the JavaScript code, we first need to create an instance of the <strong class="source-inline">org.graalvm.polyglot.Context</strong> class. The <strong class="source-inline">Context</strong> object provides the polyglot context to allow the guest language code to run in the host language. A polyglot context represents the global runtime state of all installed and permitted languages.</p>
			<p>The simplest way to use the <strong class="source-inline">Context</strong> object is to create the <strong class="source-inline">Context</strong> object and use the <strong class="source-inline">eval()</strong> function in the <strong class="source-inline">Context</strong> object, to execute other language code. The following is a code snippet <a id="_idIndexMarker604"/>where we are executing a JavaScript code snippet within Java. In this case, the guest language is JavaScript, which is passed as a parameter, <strong class="source-inline">"js"</strong>, in the <strong class="source-inline">eval</strong> method in the host language, Java: </p>
			<p class="source-code">try (Context context = Context.create()) {</p>
			<p class="source-code">    Value value = context.eval("js", JS_SNIPPET);</p>
			<p class="source-code">    value.execute(totalTime);</p>
			<p class="source-code">}</p>
			<p>Now let's execute this code. Following is the screenshot of the output, after execution:</p>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="image/B16878_Figure_7.4.jpg" alt="Figure 7.4 – Output of FibonacciCalculatorPolyglot showing Java and JavaScript outputs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – Output of FibonacciCalculatorPolyglot showing Java and JavaScript outputs</p>
			<p>As you can see in the output, we have two totals printed, one is printed with Java code and the other one is printed from the JavaScript code.</p>
			<p>This opens up a lot of possibilities – imagine running machine learning code written in Python or R in Node.js web applications. We are bringing the best features of individual languages together in one VM.</p>
			<p>The <strong class="source-inline">Context</strong> object has <strong class="source-inline">ContextBuilder</strong>, which can be used to set specific environment properties. The following are some of the properties that it can set, and the relevant <strong class="source-inline">Context</strong> creates code. This <a id="_idIndexMarker605"/>can be used to control the access the guest language has to the host. The code to control the access is <strong class="source-inline">Context.newBuilder().allowXXX().build()</strong>. The following are various <strong class="source-inline">allowXXX</strong> methods that can be used for finer access control:</p>
			<ul>
				<li><strong class="source-inline">allowAllAccess(boolean)</strong>: This is the default. It provides all access to the guest language.</li>
				<li><strong class="source-inline">allowCreateProcess(boolean)</strong>: Provides control access for the guest language to create a new process.</li>
				<li><strong class="source-inline">allowCreateThread(boolean)</strong>: Provides control access for the guest language to create a new thread.</li>
				<li><strong class="source-inline">allowEnvironmentAccess(EnvironmentAccess)</strong>:  Allows control access to the environment using the provided policy.</li>
				<li><strong class="source-inline">allowHostClassLoading(boolean)</strong>: This allows the guest languages to load new host classes via a JAR or a class file. </li>
				<li><strong class="source-inline">allowIO(boolean)</strong>: Controls access to perform I/O operations. If true, the guest language can perform unrestricted I/O operations on the host system.</li>
				<li><strong class="source-inline">allowNativeAccess(boolean)</strong>: Controls guest languages to access the native interface.</li>
				<li><strong class="source-inline">allowPolyglotAccess(PolyglotAccess)</strong>: Controls polyglot access using the provided policy. <strong class="source-inline">PolyglotAccess</strong> can be used to define custom polyglot access policies on how the data, bindings, and code execution can be the controlled at a finer level. This is a custom implementation, which the guest languages can build using the <strong class="source-inline">PolyglotAccess</strong> builder. </li>
			</ul>
			<p>Refer to the Javadoc (<a href="https://www.graalvm.org/truffle/javadoc/org/graalvm/polyglot/Context.html">https://www.graalvm.org/truffle/javadoc/org/graalvm/polyglot/Context.html</a>) for more details about other methods. It is risky to give the guest language all the access; it's always better to provide fine and specific access based on the requirement.</p>
			<p>Here is an example of how we can build a <strong class="source-inline">Context</strong> object with specific access: </p>
			<p class="source-code">Context context = Context.newBuilder().allowIO(true).build();</p>
			<p>We can also load an external file <a id="_idIndexMarker606"/>using the following code snippet, which is a recommended way of embedding code. It is not a good practice to copy-paste the other language code as a string into the host language. It's a configuration management nightmare to keep the code up to date and bug-free, as the code in other languages might be developed by different developers.</p>
			<p>Following is a code snippet that shows how to load the source code as a file, rather than embedding the guest language code in the host source code:</p>
			<p class="source-code">Context ctx =    Context.newBuilder().allowAllAccess(true).build();</p>
			<p class="source-code">    File path = new File("/path/to/scriptfile");</p>
			<p class="source-code">    Source pythonScript =         Source.newBuilder("python", new File(path,            "pythonScript.py")).build();</p>
			<p class="source-code">    ctx.eval(pythonScript)</p>
			<p>In this section, we saw how we can invoke JavaScript code from Java. Now let's try to call a Java class from JavaScript.</p>
			<h3>Calling a Java class from JavaScript/Node.js</h3>
			<p>Now that we have seen how Java code can run JavaScript code, let's try to call Java code from JavaScript. Here is a very simple Java application, which prints the argument that is passed to it on a console. The name of the Java file is <strong class="source-inline">HelloGraalPolyglot.java</strong>:</p>
			<p class="source-code">public class HelloGraalPolyglot {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        System.out.println(args[0]);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Let's compile this application with <strong class="source-inline">javac HelloGraalPolyglot.java</strong>.</p>
			<p>Now let's try to call this <a id="_idIndexMarker607"/>application from the JavaScript. The following is the JavaScript code <strong class="source-inline">hellograalpolyglot.js</strong>:</p>
			<p class="source-code">var hello = Java.type('HelloGraalPolyglot');</p>
			<p class="source-code">hello.main(["Hello from JavaScript"]);</p>
			<p>It is very simple JavaScript code. We are loading the Java class using the <strong class="source-inline">Java.type()</strong> method in JavaScript, and calling the <strong class="source-inline">main()</strong> method with a <strong class="source-inline">String</strong> parameter, and passing the string <strong class="source-inline">"Hello from JavaScript"</strong>.</p>
			<p>To execute this JavaScript, we will have to pass the <strong class="source-inline">--jvm</strong> argument and <strong class="source-inline">--vm.cp</strong> to set the classpath. Here is the command:</p>
			<p class="source-code">js --jvm --vm.cp=. hellograalpolyglot.js</p>
			<p>The following shows the output of executing this command:  </p>
			<p class="source-code">js --jvm --vm.cp=. hellograalpolyglot.js</p>
			<p class="source-code">Hello from JavaScript</p>
			<p>This was a very simple example. To understand how parameters are passed and how the method return data is captured and used in JavaScript, let's try to call the <strong class="source-inline">findFibonacci()</strong> method defined in the <strong class="source-inline">FibonacciCalculator.java</strong> code, from a Node.js application. We will pass a parameter and get an array out of the method, which we will render as a web page. </p>
			<p>Let's modify <strong class="source-inline">index.js</strong> and add another endpoint, <strong class="source-inline">/fibonacci</strong>. Here is the complete source code: </p>
			<p class="source-code">app.get('/fibonacci', function(request, response) {</p>
			<p class="source-code">    var fibonacciCalculatorClass =        Java.type("FibonacciCalculatorPolyglot");</p>
			<p class="source-code">    var fibonacciCalculatorObject = new         fibonacciCalculatorClass();</p>
			<p class="source-code">    //fibonacciCalculatorClass.class.static.main([""]);</p>
			<p class="source-code">    var array =        fibonacciCalculatorObject.findFibonacci(10);</p>
			<p class="source-code">    var responseString =         "&lt;h1&gt;Hello Graal Polyglot - Fibonacci numbers &lt;/h1&gt;";</p>
			<p class="source-code">    responseString = responseString + "&lt;ul&gt;";</p>
			<p class="source-code">    for (let index = 0; index &lt; array.length; index++) {</p>
			<p class="source-code">        responseString = responseString + "&lt;li&gt;";</p>
			<p class="source-code">        responseString = responseString + array[index];</p>
			<p class="source-code">        responseString = responseString + "&lt;/li&gt;";</p>
			<p class="source-code">    }</p>
			<p class="source-code">    responseString = responseString + "&lt;/ul&gt;";</p>
			<p class="source-code">    response.send(responseString);</p>
			<p class="source-code">});</p>
			<p>In this <strong class="source-inline">node.js</strong> code, we <a id="_idIndexMarker608"/>are first loading the Java class <strong class="source-inline">FibonacciCalculatorPolyglot</strong> using the <strong class="source-inline">Java.Type()</strong> method. Then we are creating an instance of this class and calling the method directly. The output, we know, is an array. We are iterating through the array and printing the result as an HTML list.</p>
			<p>Let's run this code with the following command:</p>
			<p class="source-code">/Library/Java/JavaVirtualMachines/graalvm-ee-java11-21.0.0.2/Contents/Home/bin/node --jvm --polyglot index.js</p>
			<p class="source-code">Started the server at 8080</p>
			<p>Now let's go to http://localhost:8080/fibonacci. Here is the screenshot of the output:</p>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/B16878_Figure_7.5.jpg" alt="Figure 7.5 – Output of the Node.js application calling the FibonacciCalculator method screenshot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – Output of the Node.js application calling the FibonacciCalculator method screenshot</p>
			<p>The preceding <a id="_idIndexMarker609"/>screenshot shows the Node.js/Fibonacci endpoint working, where it is listing the first 10 Fibonacci numbers as an HTML list. </p>
			<p>In this section, we looked at how to run a JavaScript snippet within Java, invoke Java from JavaScript and invoke a Java method, pass parameters, and get results from a Java method from a Node.js application. Let's very quickly summarize the various JavaScript interoperability <a id="_idIndexMarker610"/>features:</p>
			<ul>
				<li>When we want to call Java code from JavaScript, we pass the <strong class="source-inline">--jvm</strong> argument and set <strong class="source-inline">CLASSPATH</strong> to load the right class using <strong class="source-inline">--vm.cp</strong>.</li>
				<li>We use the polyglot <strong class="source-inline">Context</strong> object in Java to run other language code. There is a special <strong class="source-inline">ScriptEngine</strong> object for running JavaScript in Java. The <strong class="source-inline">Context</strong> object wraps this and is the recommended way to run.</li>
				<li>We use <strong class="source-inline">Java.type()</strong> to load a Java class from JavaScript/Node.js.</li>
				<li>We can use <strong class="source-inline">new</strong> to create the instances of the class. </li>
				<li>Type conversion is taken care of by GraalVM between Java and JavaScript. In cases where there could be a loss of data (for example, converting from <strong class="source-inline">long</strong> to <strong class="source-inline">int</strong>) a <strong class="source-inline">TypeError</strong> is thrown.</li>
				<li>Java package resolution can be done by providing the full package path while calling <strong class="source-inline">Java.type()</strong>.</li>
				<li>Exception handling can be done naturally using <strong class="source-inline">try{}catch</strong> blocks both in Java and JavaScript. GraalVM takes care of converting the exception. </li>
				<li>In the preceding example, we looked at how Java arrays can be iterated by JavaScript. Similarly, <strong class="source-inline">Hashmap</strong> can also be used natively using the <strong class="source-inline">put()</strong> and <strong class="source-inline">get()</strong> methods.</li>
				<li>JavaScript objects can be accessed by Java code as instances of the <strong class="source-inline">com.oracle.truffle.api.interop.java.TruffleMap</strong> class.</li>
			</ul>
			<p>In this section, we looked at <a id="_idIndexMarker611"/>how we can interoperate between Java and JavaScript. Let's now explore how to build polyglot native images.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor143"/>Polyglot native images</h2>
			<p>Graal also supports <a id="_idIndexMarker612"/>creating native images of polyglot applications. To create a native image of this Java class, we have to use the <strong class="source-inline">--language</strong> argument to build the native image. The following are the various language flags we can pass to <strong class="source-inline">native-image</strong> (the Native Image builder). In <a href="B16878_05_Final_SK_ePub.xhtml#_idTextAnchor097"><em class="italic">Chapter 5</em></a>, <em class="italic">Graal Ahead-of-Time Compiler and Native Image</em>, we covered the Native Image builder in detail: </p>
			<p class="source-code">--language:nfi</p>
			<p class="source-code">--language:python</p>
			<p class="source-code">--language:regex</p>
			<p class="source-code">--language:wasm</p>
			<p class="source-code">--language:java</p>
			<p class="source-code">--language:llvm</p>
			<p class="source-code">--language:js</p>
			<p class="source-code">--language:ruby</p>
			<p>In our example, we have to pass <strong class="source-inline">--language:js</strong> to let the Native Image builder know that we are using JavaScript within our Java code. So, we need to execute the following command:</p>
			<p class="source-code">native-image --language:js FibonacciCalculatorPolyglot</p>
			<p>Following is the screenshot of the <a id="_idIndexMarker613"/>output after executing the command:</p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/B16878_Figure_7.6.jpg" alt="Figure 7.6 – Polyglot Native Image build output screenshot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – Polyglot Native Image build output screenshot</p>
			<p>The Native Image builder performs a static code analysis and builds the optimum image of our polyglot application. We should be able to find the executable <strong class="source-inline">fibonaccicalculatorpolyglot</strong> file in the directory. Let's execute the native image with the following command:</p>
			<p class="source-code">./fibonaccicalculatorpolyglot</p>
			<p>The following figure shows the <a id="_idIndexMarker614"/>screenshot of the output when we run the native image:</p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/B16878_Figure_7.7.jpg" alt="Figure 7.7 – Polyglot Native Image execution results screenshot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7 – Polyglot Native Image execution results screenshot</p>
			<p>(In this example, you might find the code is performing more slowly than in JIT mode. Please refer to <a href="B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 4</em></a>, <em class="italic">Graal Just-In-Time Compiler</em>, for more details on why this is happening.)</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor144"/>Bindings</h2>
			<p>The binding object acts as an <a id="_idIndexMarker615"/>intermediate layer between Java and JavaScript to access methods, variables, and objects between the languages. To understand how bindings work, let's write a very simple JavaScript file that has three methods – <strong class="source-inline">add()</strong>, <strong class="source-inline">subtract()</strong>, and <strong class="source-inline">multiply()</strong>. All three methods access two numbers and return a number. We also have a variable that holds a simple string. Here is the JavaScript code, <strong class="source-inline">Math.js</strong>:</p>
			<p class="source-code">var helloMathMessage = " Hello Math.js Variable";</p>
			<p class="source-code">function add(a, b) {</p>
			<p class="source-code">    return a+b;</p>
			<p class="source-code">}</p>
			<p class="source-code">function subtract(a, b) {</p>
			<p class="source-code">    return a-b;</p>
			<p class="source-code">}</p>
			<p class="source-code">function multiply(a, b) {</p>
			<p class="source-code">    return a*b;</p>
			<p class="source-code">}</p>
			<p>This JavaScript code is very simple and straightforward. </p>
			<p>Let's now write a <a id="_idIndexMarker616"/>simple Java class that loads this JavaScript file and calls the methods by passing integer parameters, and prints the result returned by JavaScript methods. This class also accesses the variable <strong class="source-inline">helloMathMessage</strong> and prints it. </p>
			<p>Let's walk through the code to understand how this works. Here is the code, <strong class="source-inline">MathJSCaller.java</strong>:</p>
			<p class="source-code">import java.io.File;</p>
			<p class="source-code">import org.graalvm.polyglot.Context;</p>
			<p class="source-code">import org.graalvm.polyglot.Source;</p>
			<p class="source-code">import org.graalvm.polyglot.Value;</p>
			<p>We are importing all the polyglot classes that implement the Truffle interoperability: </p>
			<p class="source-code">public void runMathJS() {</p>
			<p class="source-code">  Context ctx = Context.create("js");</p>
			<p class="source-code">  try {</p>
			<p class="source-code">    File mathJSFile = new File("./math.js");</p>
			<p class="source-code">    ctx.eval(Source.newBuilder("js", mathJSFile).build());</p>
			<p>In the preceding code, we are creating the <strong class="source-inline">Context</strong> object and loading the JavaScript file and building it. Once the JavaScript is loaded, then to access the method members and variable member from the JavaScript file, we are using <strong class="source-inline">Context.getBindings()</strong>. Bindings provide a layer that allows polyglot languages to access the data and method members:</p>
			<p class="source-code">    Value addFunction =        ctx.getBindings("js").getMember("add");</p>
			<p class="source-code">    Value subtractFunction =        ctx.getBindings("js").getMember("subtract");</p>
			<p class="source-code">    Value multiplyFunction =         ctx.getBindings("js").getMember("multiply");</p>
			<p class="source-code">    Value helloMathMessage =        ctx.getBindings("js").getMember("helloMathMessage");</p>
			<p class="source-code">    System.out.println("Binding Keys :" +        ctx.getBindings("js").getMemberKeys());</p>
			<p>We are just printing the <a id="_idIndexMarker617"/>binding keys to see what all members are exposed to. Now, let's access the members, by calling the methods and accessing the variable:</p>
			<p class="source-code">    Integer addResult = addFunction.execute(30, 20).asInt();</p>
			<p class="source-code">    Integer subtractResult = subtractFunction.execute(30,            20).asInt();</p>
			<p class="source-code">    Integer multiplyResult = multiplyFunction.execute(30,            20).asInt();</p>
			<p class="source-code">    System.out.println(("Add Result "+ addResult+ "        Subtract Result "+ subtractResult+ " Multiply         Result "+ multiplyResult));</p>
			<p class="source-code">    System.out.println("helloMathMessage : " +        helloMathMessage.toString());</p>
			<p class="source-code">}</p>
			<p>Finally, we are printing all the results. The complete source code is available at the Git repository link provided in the <em class="italic">Technical requirements</em> section.</p>
			<p>Now, let's run this application. The following screenshot shows the output:</p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/B16878_Figure_7.8.jpg" alt="Figure 7.8 MathJSCaller execution results &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.8 MathJSCaller execution results </p>
			<p>We can see that our <a id="_idIndexMarker618"/>program is working. It can load the JavaScript <strong class="source-inline">math.js</strong> file and call all the methods. We also see the list of binding keys, which we printed by calling <strong class="source-inline">System.out.println("Binding Keys :" + ctx.getBindings("js").getMemberKeys());</strong>. We can see the list has four keys, and they match what we have in the <strong class="source-inline">math.js</strong> file.</p>
			<p>In this example, we saw how a binding object acts as an interface to access JavaScript members from Java.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor145"/>Multithreading</h2>
			<p>JavaScript on GraalVM supports multithreading. In this section, we will explore various patterns that are <a id="_idIndexMarker619"/>supported in the context of polyglot between Java and JavaScript. </p>
			<p>A JavaScript object that is created in a thread can only be used within that thread, it cannot be accessed from another thread. For example, in our example, <strong class="source-inline">Value</strong> objects such as <strong class="source-inline">addFunction</strong>, <strong class="source-inline">subtractFunction</strong>, and so on can only be used with that thread.</p>
			<p>Let's modify our <strong class="source-inline">MathJSCaller</strong> class' <strong class="source-inline">runMathJS()</strong> method to run a thread indefinitely, to simulate a concurrent access situation. Let's modify the preceding code and call the member functions in a separate thread. Here is the code snippet:</p>
			<p class="source-code">    Thread thread = new Thread(new Runnable() {</p>
			<p class="source-code">        @Override</p>
			<p class="source-code">        public void run() {</p>
			<p class="source-code">            while (true) {</p>
			<p class="source-code">                Integer addResult =                     addFunction.execute(30, 20).asInt();</p>
			<p class="source-code">                Integer subtractResult =                    subtractFunction.execute(30, 20).asInt();</p>
			<p class="source-code">                Integer multiplyResult =                    multiplyFunction.execute(30, 20).asInt();</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    });</p>
			<p class="source-code">    thread.start();</p>
			<p>We copied the accessing of the <a id="_idIndexMarker620"/>member methods in a separate thread. Now let's call this in a loop, to simulate concurrent access, using the same <strong class="source-inline">Context</strong> object within the threads and outside the thread. The following code snippet shows calls outside the thread using the same <strong class="source-inline">Context</strong> object:</p>
			<p class="source-code">    while (true) {</p>
			<p class="source-code">        Integer addResult =             addFunction.execute(30, 20).asInt();</p>
			<p class="source-code">        Integer subtractResult =            subtractFunction.execute(30, 20).asInt();</p>
			<p class="source-code">        Integer multiplyResult =            multiplyFunction.execute(30, 20).asInt();</p>
			<p class="source-code">        }</p>
			<p class="source-code">        }  catch (Exception e) {</p>
			<p class="source-code">            System.out.println("Exception : " );</p>
			<p class="source-code">            e.printStackTrace();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p>When we run this code, at <a id="_idIndexMarker621"/>some point, when the objects are simultaneously accessed by the two threads, we should get the following exception:</p>
			<p class="source-code">$ java MathJSCallerThreaded (docker-desktop/bozo-book-library-dev)</p>
			<p class="source-code">Binding Keys :[helloMathMessage, add, subtract, multiply]</p>
			<p class="source-code">java.lang.IllegalStateException: Multi threaded access requested by thread Thread[Thread-3,5,main] but is not allowed for language(s) js.</p>
			<p class="source-code">…..</p>
			<p>To overcome this issue, it is recommended to use isolated runtimes. We can create separate <strong class="source-inline">Context</strong> objects per thread and create new instances of these objects and use them in that thread. Here is the fixed code: </p>
			<p class="source-code">    public void runMathJS() {</p>
			<p class="source-code">        Context ctx = Context.create("js");</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            File mathJSFile = new File("./math.js");</p>
			<p class="source-code">            ctx.eval(Source.newBuilder                ("js", mathJSFile).build());</p>
			<p class="source-code">            Value addFunction =               ctx.getBindings("js").getMember("add");</p>
			<p class="source-code">            Value subtractFunction =               ctx.getBindings("js").getMember("subtract");</p>
			<p class="source-code">            Value multiplyFunction =               ctx.getBindings("js").getMember("multiply");</p>
			<p class="source-code">            Value helloMathMessage =               ctx.getBindings("js")               .getMember("helloMathMessage");</p>
			<p class="source-code">            System.out.println("Binding Keys :" + ctx.            getBindings("js").getMemberKeys());</p>
			<p class="source-code">            while (true) {</p>
			<p class="source-code">                Integer addResult =                     addFunction.execute(30, 20).asInt();</p>
			<p class="source-code">                Integer subtractResult =                    subtractFunction.execute(30, 20).asInt();</p>
			<p class="source-code">                Integer multiplyResult =                    multiplyFunction.execute(30, 20).asInt();</p>
			<p class="source-code">}</p>
			<p>Now, within the thread, we are <a id="_idIndexMarker622"/>creating a separate <strong class="source-inline">Context</strong> object. The following code snippet shows the updated code:</p>
			<p class="source-code">Thread thread = new Thread(new Runnable() {</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public void run() {</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            Context ctx = Context.create("js");</p>
			<p class="source-code">            ctx.eval(Source.newBuilder("js",                mathJSFile).build());</p>
			<p class="source-code">            Value addFunction =               ctx.getBindings("js").getMember("add");</p>
			<p class="source-code">            Value subtractFunction =               ctx.getBindings("js").getMember("subtract");</p>
			<p class="source-code">            Value multiplyFunction =               ctx.getBindings("js").getMember("multiply");</p>
			<p class="source-code">            Value helloMathMessage =               ctx.getBindings("js")               .getMember("helloMathMessage");</p>
			<p class="source-code">            while (true) {</p>
			<p class="source-code">                Integer addResult =                add<a id="_idTextAnchor146"/>Function.execute(30, 20).asInt();</p>
			<p class="source-code">                Integer subtractResult =                  subtractFunction.execute(30, 20).asInt();</p>
			<p class="source-code">                Integer multiplyResult =                  multiplyFunction.execute(30, 20).asInt();</p>
			<p class="source-code">            }</p>
			<p class="source-code">        } catch (Exception e) {</p>
			<p class="source-code">            e.printStackTrace();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">});</p>
			<p class="source-code">thread.start();</p>
			<p>As we can see, in this code, we are creating a separate <strong class="source-inline">context</strong> object within the thread, which is local to the thread. This does not create an exception.</p>
			<p>The other solution to <a id="_idIndexMarker623"/>this is to access the <strong class="source-inline">context</strong> object in proper <strong class="source-inline">synchronized</strong> blocks or methods, so that the runtimes are not accessed at the same time. Here is the updated code, with a <strong class="source-inline">synchronized</strong> block:</p>
			<p class="source-code">Thread thread = new Thread(new Runnable() {</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public void run() {</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            // Solution 2</p>
			<p class="source-code">            while (true) {</p>
			<p class="source-code">                synchronized(ctx) {</p>
			<p class="source-code">                Integer addResult =                     addFunction.execute(30, 20).asInt();</p>
			<p class="source-code">                Integer subtractResult =                    subtractFunction.execute(30, 20).asInt();</p>
			<p class="source-code">                Integer multiplyResult =                    multiplyFunction.execute(30, 20).asInt();</p>
			<p class="source-code">                }</p>
			<p class="source-code">            }</p>
			<p class="source-code">        } catch (Exception e) {</p>
			<p class="source-code">            e.printStackTrace();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">});</p>
			<p class="source-code">thread.start();</p>
			<p>We can also include the whole <a id="_idIndexMarker624"/>block as a synchronized block, still using the same <strong class="source-inline">Context</strong> object:</p>
			<p class="source-code">while (true) {</p>
			<p class="source-code">    synchronized(ctx) {</p>
			<p class="source-code">        Integer addResult =             addFunction.execute(30, 20).asInt();</p>
			<p class="source-code">        Integer subtractResult =            subtractFunction.execute(30, 20).asInt();</p>
			<p class="source-code">        Integer multiplyResult =            multiplyFunction.execute(30, 20).asInt();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This will also run fine but might run slower than the previous solution, as there could be a lot of locks on the <strong class="source-inline">Context</strong> object.</p>
			<p>Java objects are thread-safe, so Java objects can be accessed between JavaScript runtimes running different threads.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor147"/>Asynchronous programming – Promise and await</h2>
			<p>Asynchronous programming is very prominent in <a id="_idIndexMarker625"/>modern distributed applications. JavaScript uses <strong class="source-inline">Promise</strong>. The <strong class="source-inline">Promise</strong> object <a id="_idIndexMarker626"/>represents the completion of an asynchronous activity, along with the final value. The <strong class="source-inline">Promise</strong> object has three states:</p>
			<ul>
				<li><strong class="bold">Pending</strong>: This <a id="_idIndexMarker627"/>state is the initial state.</li>
				<li><strong class="bold">Fulfilled</strong>: This state indicates <a id="_idIndexMarker628"/>that the operation successfully executed. </li>
				<li><strong class="bold">Rejected</strong>: This state indicates <a id="_idIndexMarker629"/>that the operation failed.</li>
			</ul>
			<p>Sometimes, we may have <a id="_idIndexMarker630"/>to have JavaScript creating a <a id="_idIndexMarker631"/>promise and the logic might be running in Java code, and when the Java code is done, it may have to fulfill or reject the promise. To handle that, Graal provides a <strong class="source-inline">PromiseExecuter</strong> interface. A Java class has to implement this interface method, <strong class="source-inline">void onPromiseCreation(Value onResolve, Value onReject);</strong>. A Java class that implements this interface can be used by JavaScript to create a <strong class="source-inline">Promise</strong> object. JavaScript can call <strong class="source-inline">await</strong> on a Java object that implements void then <strong class="source-inline">(Value onResolve</strong>, <strong class="source-inline">Value onReject);</strong> to implement asynchronous programming between JavaScript and Java.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor148"/>Summary</h1>
			<p>In this chapter, we went through the various polyglot interoperability and embedding features of GraalVM/Truffle for JavaScript and Node.js in detail. We explored all the key concepts with some real code examples, to gain a clear understanding of how JavaScript and Node.js can call, pass data, and interoperate with other language code. This is one of the salient features of GraalVM. </p>
			<p>The examples given in this chapter will help you to build and run polyglot applications that are written using the Java and JavaScript languages on the same runtime. </p>
			<p>In the next chapter, we will continue to explore R, Python, and the latest Java on Truffle. </p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor149"/>Questions</h1>
			<ol>
				<li>What JavaScript object and method is used to run other language code?</li>
				<li>What is the <strong class="source-inline">Context</strong> object in Java?</li>
				<li>How do you control the access a guest language gets to the host?</li>
				<li>How do you build a native image of a polyglot application? </li>
				<li>What is a binding?</li>
			</ol>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor150"/>Further reading</h1>
			<ul>
				<li>GraalVM Enterprise Edition (<a href="https://docs.oracle.com/en/graalvm/enterprise/19/index.html">https://docs.oracle.com/en/graalvm/enterprise/19/index.html</a>)</li>
				<li>JavaScript and Node.js reference (<a href="https://www.graalvm.org/reference-manual/js/">https://www.graalvm.org/reference-manual/js/</a>)</li>
				<li><em class="italic">Truffle: A Self-Optimizing Runtime System</em> (<a href="https://lafo.ssw.uni-linz.ac.at/pub/papers/2012_SPLASH_Truffle.pdf">https://lafo.ssw.uni-linz.ac.at/pub/papers/2012_SPLASH_Truffle.pdf</a>)</li>
				<li><em class="italic">An Object Storage Model for the Truffle Language Implementation Framework</em> (<a href="https://chrisseaton.com/rubytruffle/pppj14-om/pppj14-om.pdf">https://chrisseaton.com/rubytruffle/pppj14-om/pppj14-om.pdf</a>)</li>
			</ul>
		</div>
	</body></html>