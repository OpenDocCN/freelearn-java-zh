<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">An Application to View Countries and their GDP using JHipster</h1>
                </header>
            
            <article>
                
<p><span>As time has passed, changing business functions have required delivery teams to produce high-quality software products at a rapid pace. To meet this expectation, the IT industry has become focused on making the software development process streamlined and automated. As a result, many new platforms are emerging, with the aim of generating the code to prepare production-ready applications in no time.</span></p>
<p><span>We started our journey with a simple application developed in Spring Framework that showed the <strong>gross domestic product</strong> (<strong>GDP</strong>) information of various countries with the World Bank API, in <a href="87add83e-e65b-4b58-9ef1-113ad157a51a.xhtml">Chapter 1</a>, <em>Creating an Application to List World Countries with their GDP</em>. The Spring Framework provides a comprehensive way to develop an enterprise-ready application with ease. </span></p>
<p><span>With the birth of Spring Boot framework, development with Spring Framework has become far quicker and smarter than ever before. In subsequent chapters, we moved on to Spring Boot and explored its capabilities, specifically for integration with other Spring and third-party libraries and modules.</span></p>
<p><span>In this chapter, we will explore another framework, named JHipster, which is one step ahead in making Spring-based applications with just a few clicks, and makes Spring development joyful. We will utilize JHipster to develop the application from <a href="87add83e-e65b-4b58-9ef1-113ad157a51a.xhtml">Chapter 1</a>, <em>Creating an Application to List World Countries with their GDP, </em>showing the GDP information of various countries and showcasing how the development process</span><span> is streamlined and automated. We will cover the following interesting topics in this chapter:</span></p>
<ul>
<li>Introducing JHipster</li>
<li>Installation</li>
<li>Application creation</li>
<li>Modeling and creation of the entity</li>
<li>Creating the GDP application</li>
<li>Learn how to add customization in JHipster application</li>
<li>Other features of JHipster</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>All the code used in this chapter can be downloaded from the following GitHub link: <a href="https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter05">https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter05</a>. The code can be executed on any operating system, although it has only been tested on Windows.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing JHipster</h1>
                </header>
            
            <article>
                
<p><strong>JHipster</strong> is, in brief, a code generating tool, built on top of large collections of development, build, test, and deployment frameworks and platforms. It is a modern web application development platform, used to build all layers of a comprehensive Java-based web application, from the frontend to the database. JHipster supports various frameworks under the hood, giving the user options to choose from when starting application development.</p>
<p><span>JHipster is a free and open source platform aimed at greatly simplifying the process of generating, developing, and deploying monolithic and microservices-based applications on Spring Framework and Angular or React technologies. Before building an application in JHipster, a user will be asked various questions, in order to generate a production-ready application based on the options chosen by the user. JHipster provides the application with support for the following tools and frameworks, out of the box:</span></p>
<ul>
<li><strong>Build tool:</strong> Maven, Gradle</li>
<li><strong>Development platform:</strong> Spring Framework</li>
<li><strong>Security framework:</strong> Spring Security</li>
<li><strong>Templating:</strong> Thymeleaf</li>
<li><strong>Microservices:</strong> Netflix OSS</li>
<li><strong>RDBMS:</strong><span> H2, MySQL, Oracle, PostgreSQL, MS SQL, MariaDB</span></li>
<li><strong>Data streaming:</strong> Kafka</li>
<li><strong>DB tracker:</strong> Liquibase</li>
<li><strong>NoSQL:</strong> MonboDB, Cassandra, Couchbase, Hazelcast</li>
<li><strong>Cache implementation:</strong> Infinispan, Ehcache</li>
<li><strong>Search engine:</strong> Elasticsearch and <span><strong>Elasticsearch, Logstash, and Kibana</strong> </span>stack (<strong><span>ELK</span></strong>)</li>
<li><strong>Monitoring:</strong> Prometheus</li>
<li><strong>ORM:</strong> Hibernate</li>
<li><strong>Testing framework:</strong> Cucumber, Browsersync, Jest, Protractor test</li>
<li><strong>Load testing:</strong> Gatling</li>
<li><strong>UI:</strong> Bootstrap, HTML5, CSS3, SaaS, Redux</li>
<li><strong>JavaScript framework: </strong><span>Angular, Typescript, React, Webpack</span></li>
<li><strong>Deployment:</strong> Docker, Kubernetes, Boxfuse, Rancher</li>
<li><strong>Cloud support:</strong> Heroku, Cloud Foundry, AWS, OpenShift</li>
<li><strong>CI/CD:</strong> Jenkins, Travis CI, GitLab CI, CircleCI</li>
</ul>
<p>The code generated by JHipster is as per industry standards, best practices, and quality compliance. Along with autogenerating application code, JHipster also supports automated testing and the continuous integration and delivery of the application in a more streamlined way. This can bring great benefits to an organization, as follows:</p>
<ul>
<li class="mce-root">Creating an application with various platforms and frameworks in a uniform and controlled way.</li>
<li>Most of the boilerplate code is generated automatically, so a developer can focus on the <span>implementation of </span>business requirements. This will increase developer productivity and greatly improve the overall project delivery timeline. </li>
<li>Easy integration of changes throughout the application, from the frontend to the database table.</li>
<li>Improved code quality of the application, <span>overall</span>.</li>
<li>Different projects in the organization can share common artifacts with ease. Consequently, the overall productivity of the project teams will be improved.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing JHipster</h1>
                </header>
            
            <article>
                
<p>JHipster recommends that normal users install with <kbd>npm</kbd>. The <kbd>npm</kbd> is a package manager from <kbd>Node.js</kbd>, used to install various software. It is the world's largest software repository, where you will find thousands of pieces of open source software, in the form of packages. If <kbd>npm</kbd> is not installed, just go to the <span class="packt_screen">Downloads</span> section of the Node site (<a href="https://nodejs.org/en/download">https://nodejs.org/en/download</a>) and install the latest 64-bit <strong><span>Long Term Support</span></strong> (<strong><span>LTS</span></strong>) version, because the non-LTS version is not supported by JHipster.</p>
<p>Once <kbd>npm</kbd> is installed, run the following command to install the JHipster package from the command line:</p>
<pre><strong><span>npm install -g generator-jhipster</span></strong></pre>
<p>JHipster uses another tool, named <strong>Yeoman</strong> (<a href="http://yeoman.io/">http://yeoman.io/</a>), to generate the application code, which is installed along with the JHipster Node package. After creating an application, JHipster provides an option to build it with either Maven or Gradle. For this, JHipster will install the required wrappers for Maven and Gradle, so nothing is required explicitly, especially for building an app.</p>
<div class="packt_infobox">
<p>Local installation of JHipster can also be done with Yarn, another package manager for installing software. The process of installing JHipster with Yarn is almost identical to that of <kbd>npm</kbd>.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an application</h1>
                </header>
            
            <article>
                
<p>After installing JHipster, the next step is to create an application. Create a project directory with an appropriate name in your local machine, select this directory from Command Prompt, and execute the following command. The name of the project directory is given as <kbd>gdp</kbd>, but it can be any valid name:</p>
<pre><strong>jhipster</strong></pre>
<p>Soon after hitting this command, JHipster will start to ask a series of questions, and will decide what has to be generated based on the answers given by the user, as follows:</p>
<ol>
<li><strong>Which type of application would you like to create? </strong>There are four possible options to choose from, as follows:
<ul>
<li><strong>Monolithic application:</strong> <span>This option is used to create a self-contained application. This is the recommended option to create a simple application, so we will choose this option.</span></li>
<li><strong>Microservice application:</strong> <span>If you want to design an application based on a microservices architecture, you can choose this option.</span></li>
<li><strong>Microservice gateway:</strong> <span>The microservice gateway is used to build a microservice-based application with the UI. By default, microservice applications do not have a UI.</span></li>
<li><strong>JHipster UAA server:</strong> <span>JHipster supports creating applications with </span><span><strong>User Authentication and Authorization</strong> <em>(</em><strong>UAA</strong>)</span><span>.</span></li>
</ul>
</li>
</ol>
<ol start="2">
<li><strong>What is the base name of your application?</strong> You need to give your application a name. By default, it takes the same name as the project directory. If you want, you can give it another name.</li>
<li><strong>What is your default Java package name?</strong> Next, you need to give a Java package name. You can give an appropriate name (it will be considered as a base package, and all other Java source files will be generated in their respective packages relative to this package).</li>
<li><strong>Do you want to use the JHipster Registry to configure, monitor, and scale your application?</strong> This question concerns using the JHipster Registry in our application. The registry is extensively used in microservice-based applications, for registering various services. For a monolithic application, we can still use it because although it is a kind of registry, it concerns the health of the application, which helps us to monitor the application. It comes as a <kbd>Docker</kbd> <span>image. For simplicity, we are not going to use it, so choose</span> <span class="packt_screen">No</span> <span><span>and go ahead. </span></span></li>
</ol>
<ol start="5">
<li><strong>Which type of authentication would you like to use?</strong> Next up is the authentication mechanism. It provides three options to choose from, as follows. <span>We will select the third option (HTTP session authentication):</span>
<ol>
<li><strong>JWT Authentication:</strong> <span><strong>JSON Web Token</strong> (</span><strong>JWT</strong>), which is an open standard for transmitting information between two parties in form of JSON. Authentication is the most common use case of JWT.</li>
<li><strong>OAuth2/OIDC Authentication:</strong> JHipster provides complete support for OAuth2 with Keycloak and <span><strong>OpenID Connect</strong> (</span><strong>OIDC</strong>), which is generated <span>by default </span>when we select this option. Keyclock is an open source identity brokering and access management solution. <span><strong>Open ID Connect</strong> (</span><strong>OIDC</strong>), which is a simple identity layer on top of the OAuth2 protocol.</li>
<li><strong>HTTP session authentication:</strong> This <span>authenticates users based on sessions. </span>This is the most commonly used option.</li>
</ol>
</li>
</ol>
<ol start="6">
<li><strong>Which type of database would you like to use?</strong> Next, it will ask the type of database, we would like to use in our application. JHipster supports various SQL databases. It also supports three NoSQL databases—MongoDB, Couchbase, and Cassandra, which has a Spring data backend. We will select SQL.</li>
</ol>
<ol start="7">
<li><strong>Which production/development database would you like to use?</strong> You will be asked separate questions to select specific databases for production and development. JHipster maintains various profiles for various environments (such as development, production, and so on). It will configure the databases based on your selected options. In our case, we will select MySQL for both production and development.</li>
<li><strong>Do you want to use the Spring cache abstraction?</strong> Moving further, it will ask about the type of caching mechanism, such as Ehcache, Hazelcase, Memcached, or no cache at all; Spring cache abstraction will be used to plug any of them. We can select any of them, based on our particular business needs and the underlying hardware architecture (single node, multi-node, distributed, and so on). We will choose Ehcache (which is selected<span> by default</span>).</li>
<li><strong>Do you want to use Hibernate second level cache?</strong> Here, we have the option to use Hibernate's second-level cache. Select <span class="packt_screen">Yes</span><span> for this option.</span></li>
</ol>
<ol start="10">
<li><span><strong>Would you like to use Maven or Gradle for building the backend?</strong> You will be asked to choose either Maven or Gradle as a build tool. We will select </span><span class="packt_screen">Maven</span><span><span><span>.</span></span></span></li>
</ol>
<ol start="11">
<li><strong>Which other technologies would you like to use?</strong> Towards the end, JHipster will ask to add a few additional technologies, such as Elasticsearch, WebSocket, asynchronous messaging with Kafka, and API-first development with the OpenAPI generator. API-first is an approach to designing an application with the API first, and developing web or mobile applications on top of those APIs. Nowadays, many companies are adopting this approach, and JHipster supports it out of the box. To make the thing simple and straightforward, we will not select either of them. Since this is a multiple choice selector, you can just press <em>Enter</em> to move further without selecting any of them.</li>
<li><strong>Which Framework would you like to use for the client?</strong> The next question asks you to select a frontend framework, either Angular or React. Select <span class="packt_screen">Angular</span> and press <em>Enter</em>.</li>
<li><strong>Would you like to enable Sass stylesheet preprocessor?</strong> Next, it will ask you whether to use the <strong>syntactically awesome style sheets</strong> <em>(</em><strong>Sass</strong>) stylesheet preprocessor. Select <span class="packt_screen">Yes</span>.</li>
</ol>
<ol start="14">
<li> <strong>Would you like to enable internationalization support?</strong> If you wish to add support for internationalization, select a <span class="packt_screen">native language</span>. Select <span class="packt_screen">English</span> as an answer.</li>
<li><strong>Please choose additional languages to install:</strong> Along with your native language, you can add support for additional languages. JHipster supports around 30 languages. To make things simple, we will not add any additional language. </li>
<li><strong>Besides JUnit and Jest, which testing frameworks would you like to use?</strong> You will be asked to select unit testing frameworks on this screen. JHipster supports the Gatling, Cucumber, and Protractor frameworks, as well as the default JUnit for unit testing. Select none of them and move to the next step.</li>
<li><strong>Would you like to install other generators from the JHipster Marketplace?</strong> The last question will ask you whether to add additional modules from the JHipster marketplace. This is a collection of third-party generators that work on top of the core JHipster, with access to its variables and functions and acts like sub-generators. You can use them in your application by downloading them from the JHipster Marketplace (<a href="https://www.jhipster.tech/modules/marketplace">https://www.jhipster.tech/modules/marketplace</a><span>). We will select</span> <span class="packt_screen">No</span> <span>for this option.</span></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project structure</h1>
                </header>
            
            <article>
                
<p>Now, sit back and relax, and JHipster will start to create an application based on the options we selected. At this moment, JHipster will generate the code and project structure of our application. In brief, JHipster generates the following things to make an application ready to run:</p>
<ul>
<li>Spring Boot application</li>
<li>Angular JS application (at the frontend)</li>
<li>Liquibase changelog file (used for database table <span><strong>Data Definition Language</strong> (</span><strong>DDL</strong>) manipulation)</li>
<li>Other configuration files</li>
</ul>
<p>We can configure an <strong>integrated development environment</strong> (<strong>IDE</strong>) for further development once the application has been created. JHipster supports a wide range of IDEs, including Eclipse, IntelliJ IDEA, and Visual Studio Code. You can read more about this topic at <a href="https://www.jhipster.tech/configuring-ide">https://www.jhipster.tech/configuring-ide</a>. The application structure looks as follows: </p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a829a4fe-b517-4e16-904a-460778640e35.png" style="width:16.92em;height:26.92em;"/></p>
<p>Let's look at each Java package, as follows:</p>
<ul>
<li><kbd>com.nilangpatel.aop.logging</kbd>: This contains <strong>Aspect-Oriented Programming</strong> (<strong>AOP</strong>) advice for logging.</li>
<li><kbd>com.nilangpatel.config</kbd>: This package contains various configurations for properties, cache, database, profile, Liquibase, logging, Spring Security, metrics, web, locale, and so on, along with constants used across the application.</li>
<li><kbd>com.nilangpatel.config.audit</kbd>: JHipster provides auditing features out of the box. This package contains configurations specifically for auditing.</li>
<li><kbd>com.nilangpatel.domain</kbd>: This contains all of the model objects for the custom entities that we created, along with other core model objects.</li>
</ul>
<ul>
<li><kbd>com.nilangpatel.domain.enumeration</kbd>: This contains enumerations that we declared in the <strong>JHipster Domain Language</strong> (<strong>JDL</strong>). We will discuss JDL more in the upcoming section.</li>
<li><span><kbd>com.nilangpatel.repository</kbd>: Spring Data <strong>Java Persistence API</strong> (<strong>JPA</strong>) repositories for each custom and out-of-the-box entities, are stored here.</span></li>
<li><span><kbd>com.nilangpatel.security</kbd>: All security-related classes, such as constants for <kbd>Roles</kbd>, <kbd>UserDetail</kbd> service, and so on, are stored in this package. </span></li>
<li><span><kbd>com.nilangpatel.service</kbd>: This contains service-layer interfaces for out-of-the-box and custom entities.</span></li>
<li><span><kbd>com.nilangpatel.service.dto</kbd>: The <strong>data transfer objects</strong> (<strong>DTOs</strong>), used to transfer between the controller and the service, are kept here.</span></li>
<li><span><kbd>com.nilangpatel.service.mapper</kbd>: Mapper classes that are used to map model objects with DTOs will be stored in this package.</span></li>
<li><span><kbd>com.nilangpatel.service.util</kbd>: This package contains some utility classes. </span></li>
<li><span><kbd>com.nilangpatel.web.rest</kbd>: All <strong>Representational State Transfer</strong> (<strong>REST</strong>) controllers for each entity are generated under this package.</span></li>
<li><span><kbd>com.nilangpatel.web.rest.error</kbd>: Exceptions specific to REST calls are available here.</span></li>
<li><span><kbd>com.nilangpatel.web.rest.util</kbd>: This contains some utility classes that are used in REST calls. </span></li>
<li><span><kbd>com.nilangpatel.web.rest.vm</kbd>: This contains view models, which are mainly used in the <span class="packt_screen">Administration</span> tab in the UI.</span></li>
</ul>
<p>Along with Java classes and packages, JHipster also generates certain resources in the <kbd>src/main/resource</kbd> folder. The details are as follows:</p>
<ul>
<li><kbd>config</kbd>: This contains various configuration files, such as <kbd>application.properties</kbd> for Spring Boot with various profiles, some Liquibase configuration files, along with <kbd>changelog</kbd> files and keystore files for importing and configuring certificates for HTTPS configuration.</li>
<li><kbd>i18</kbd>: This contains property files for various languages that we selected during application creation.</li>
<li><kbd>templates</kbd>: This folder contains various mail templates, such as activation, account creation, and password reset, along with error templates.</li>
</ul>
<p>It is time to run an application. JHipster provides the following command to build an application with Maven. Make sure that you are at the project directory in the Command Prompt:</p>
<pre><strong>mvnw</strong></pre>
<p>Along with building an application, this command will deploy it on the embedded web server (which ships with Spring Boot by default). It can be accessed at <kbd>http://localhost:8080</kbd>, and looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/76273649-fcea-4793-bc5e-fadd4347a8ed.png"/></p>
<div class="packt_infobox">If an application needs to be deployed on any application server, JHipster provides a way to generate an executable WAR file, with the command <kbd>mvnw -Pprod package</kbd><em> </em>for Maven and <kbd>gradlew -Pprod bootWar</kbd> for Gradle.</div>
<p>JHipster generates a set of pages and a few users accounts to start with. Click on <span class="packt_screen">Account<span><span> | </span></span></span><span class="packt_screen">Sign in</span> to login into the application. By default, <kbd>Admin</kbd> users can log in with credentials as <kbd>admin/admin</kbd>, and normal users can log in with <kbd>user/user</kbd>. The <kbd>Admin</kbd> user has access to the <span class="packt_screen">Administration</span> menu, from where they can perform various admin functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Entity creation</h1>
                </header>
            
            <article>
                
<p>A web application has some sort of database interaction, covering basic <span><strong>Create, Read, Update, and Delete</strong> (</span><strong>CRUD</strong>) operations, as a bare minimum. It requires a good amount of effort when done manually. The following tasks need to be completed, in this case:</p>
<ul>
<li>Creating database tables, along with their relations and constraints</li>
<li>Constructing a model entity and building the <strong>data access</strong><span><strong> object</strong> (</span><strong>DAO</strong>) layer to provide the data interface with the database</li>
<li>Generating a service layer to encapsulate business logic</li>
<li>Preparing the web controller and frontend layer, along with all validations, to store the data in the respective entity table</li>
</ul>
<p>Apart from this, additional effort may be required to accommodate future changes on any layer. JHipster provides an ingenious solution to this problem. After creating an application, we need to build a data access layer, and JHipster makes this whole process automatic.</p>
<p>A concept <span>in JHipster </span>called <strong>entity generation</strong> makes this happen. Entities are the building elements of JHipster applications. The entity generation process covers various tasks, as follows:</p>
<ul>
<li>Creating database tables and maintaining their changes (through configuration)</li>
<li>Constructing a JPA model class, along with a Spring Data JPA repository</li>
<li>Creating an optional service layer to accommodate business rules</li>
<li>Creating REST controllers supporting basic CRUD operations and frontend side Angular router</li>
<li>Component and service along with HTML view including integration and performance tests</li>
</ul>
<p>Isn't it cool? Let's witness the process of making an entity and generating the code automatically.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding an entity with the CLI</h1>
                </header>
            
            <article>
                
<p>To demonstrate the process of creating an entity in JHipster, we will first create a simple entity, called <strong>Owner</strong>, with one attribute, called <strong>name</strong>. <span>The way that JHipster allows for entity creation, along with data access, the service layer, controller, and frontend layer for that entity is identical to the process of generating application code that we saw in the previous section. Both can be done with the </span><span>CLI.</span></p>
<p><span>For entity generation, <span>JHipster uses the </span>Yeoman tool internally <span>to generate the code. Let's create our first entity. Execute the following command to create an entity:</span></span></p>
<pre><strong>jhipster entity Owner</strong></pre>
<p>The <kbd>Owner</kbd> is the name of an entity. This command will create an entity for <kbd>Owner</kbd>, and will launch a wizard that asks a few questions of the user, as follows:</p>
<ol>
<li><strong>Do you want to add a field to your entity?</strong> If you wish to add a field for your entity, select <em><span class="packt_screen">y</span></em>.</li>
<li><strong>What is the name of your field?</strong> You can give the name of the attribute here. </li>
<li><strong>What is the type of your field?</strong> You need to provide the type of attribute. JHipster supports various attribute types, including <kbd>string</kbd>, <kbd>integer</kbd>, <kbd>long</kbd>, <kbd>float</kbd>, <kbd>double</kbd>, <kbd>BigDecimal</kbd>, and <kbd>LocalDate</kbd>.</li>
<li><strong>Do you want to add validation rules to your field?</strong> This concerns whether you wish to add any constraints on an attribute of the entity. Select <em><span class="packt_screen">y</span></em>.</li>
<li><strong>Which validation rules do you want to add?</strong> JHipster also allows you to add various constraints, including <kbd>required</kbd>, <kbd>unique</kbd>, <kbd>min</kbd> value, <kbd>max</kbd> value, and regular expression patterns, to validate the input. You can select more than one constraint here.</li>
</ol>
<p>The preceding process of adding attributes can be repeated to add further attributes to its type and constraints. We will create the <kbd>Owner</kbd> <span>entity </span>with the <kbd>name</kbd> <span>attribute </span>of the <kbd>String</kbd> <span>type, </span>with the <kbd>required</kbd><span> constraint. </span></p>
<p>JHipster also allows you to define a relation with another entity. Once we have finished adding attributes, it will ask us to add a relationship. Since we have created only the <kbd>Owner</kbd> entity, we will add the relationship after we add another entity. <span>We will see how to add a relationship later on.</span></p>
<p><span>At the moment, just say no (<em><span class="packt_screen">n</span></em>) to adding a relationship, and JHipster will show the next set of questions related to the service and controller layer, as follows:</span></p>
<ol start="6">
<li><strong>Do you want to use a separate service class for your business logic?</strong> In this question, we have been asked if we wish to add a service layer, and the possible options are as follows. We will select the third option:
<ol>
<li>No, the REST controller should use the repository directly; the REST controller will make a direct call to the repository. No service layer is added.</li>
<li>Yes, generate a separate service class; the service layer is added with a service class only. The REST controller will call this class for any database interaction. We can write additional business logic in the service class.</li>
<li>Yes, generate a separate service interface and implementation; in this case, the service layer is added with both interface and implementation. The clear advantage of this design is we can provide another implementation of the service interface without changing other code.</li>
</ol>
</li>
<li><strong>Do you want to use a</strong> <strong>DTO</strong><strong>?</strong> The next question is related to DTO. JHipster provides an option to create a DTO for each entity. It uses MapStruct, another code generator tool used to map Java entities to generate DTOs. B<span>asically, i</span>t is used to map the values from DTO to the model entity, and vice versa. The options for this question are as follows. We will select the second option:
<ol>
<li>No, use the entity directly; an entity object is used to pass the data throughout all of the layers.</li>
<li>Yes, generate a DTO with MapStruct; this will generate a DTO corresponding to each entity. The controller will create an instance of DTO and pass it to the service layer. The service class will map the DTO to the entity and call the repository to interact with a database. </li>
</ol>
</li>
<li><strong>Do you want to add filtering?</strong> This will provide a dynamic filtering option to search for specific entities. It uses a JPA static meta-model for filtering option. JHipster will create complete code, from the presentation to the DAO, if we choose Y<span class="packt_screen">es</span>. Though it is quite useful to have the filter option, <span>we will select </span><span class="packt_screen">No</span><span> for this question, </span>for the sake of simplicity.</li>
</ol>
<ol start="9">
<li><strong>Do you want pagination on your entity?</strong> The next question is about pagination patterns. JHipster supports the following patterns for pagination. We will select the second option:
<ol>
<li>No; this will mean no pagination. All of the records will be visible in a single page. This will create performance issues for large datasets.</li>
<li>Yes, with pagination links; this shows the pagination with links to move between pages. This is the most common pagination style.</li>
<li>Yes, with infinite scroll; this uses infinite scroll to display the data. The scroll will serve the purpose of pagination.</li>
</ol>
</li>
</ol>
<p>Now, JHipster will start to create the entity, and will ask to override certain files wherever it finds some conflicts. This is because JHipster will start to generate the code again. Keep saying yes (<span class="packt_screen">y</span>) and pressing <em>Enter</em> for all of the prompts, and finally, you will see a message saying that the entity has been created. Next, let's create another entity, called <kbd>Car</kbd>, with the attributes of <kbd>name</kbd>, <kbd>model</kbd>, and <kbd>manufacture year</kbd>. Follow the previous steps to create the <kbd>Car</kbd> entity.</p>
<div class="packt_infobox"><span>JHipster provides an option to build a relationship during the time of entity creation. So, if you have just added a single entity and are trying to create a relationship with another entity, you will get an error, saying something like the other entity has not been found. So, when building a relationship with another entity, make sure that it has been created first. </span></div>
<p>After step five, it will ask about adding a relationship. We already added an <kbd>Owner</kbd> entity and we want to establish a many-to-one relation (many <kbd>Cars</kbd> can be associated with one <kbd>Owner</kbd>). The following is a set of questions that will be asked specifically about the relationship, after step five:</p>
<ol>
<li><strong>Do you want to add a relationship to another entity? </strong>Choose <span class="packt_screen">Y</span> here. </li>
<li><strong>What is the name of the other entity?</strong> This refers to the name of the entity with which we want to set up the relationship. Give the name of the entity as <kbd>Owner</kbd> here.</li>
<li><strong>What is the name of the relationship?</strong> The default is <kbd>owner</kbd> (this is the relationship name that you want to give. By default, system will give lowercase name of other side entity name. If you wish, you can change it).</li>
<li><strong>What is the type of the relationship?</strong> The possible options are one-to-many, many-to-one, many-to-many, and one-to-one. They are quite straightforward. We will select many-to-one, as we are establishing a relationship with the <kbd>Car</kbd> entity. </li>
</ol>
<ol start="5">
<li><strong>When you display</strong> <strong>this relationship on the client side, which field from</strong> <kbd>Owner</kbd> <strong>do you want to use?</strong> This question asks whether the column name of the <kbd>Owner</kbd> entity should be displayed while showing or adding <kbd>Car</kbd> data. Internally, JHipster always uses ID columns to set the relationships between tables. Give the <kbd>name</kbd> as the answer to this question, as <kbd>Owner</kbd> has just one column(<kbd>name</kbd>).</li>
<li><strong>Do you want to add any validation rules to this relationship?</strong> This basically adds validation to the foreign key column. </li>
<li><strong>Which validation rules do you want to add?</strong> The possible validation is <span class="packt_screen">required</span>. </li>
</ol>
<p>After this, it will start to ask questions from the step 6. Complete it till step 9 to add the <kbd>Car</kbd> entity. At this moment, we have two entities—<kbd>Owner</kbd> and <kbd>Car</kbd>—with a relation between them, along with the source code of the frontend, controller, and service layers, and the DAO layer. </p>
<p>Now, it is time to build our application. The <kbd><strong>mvnw</strong></kbd> M<span>aven command </span>will not only build the application, but will deploy and run it on the embedded server. After generating the entities, when we build and deploy the application with this command, JHipster will create/update the database table corresponding to each entity. </p>
<div class="packt_infobox">Before building the application, make sure that you set the database credentials as per your local MySQL configuration in the <kbd>application-prod.yml</kbd> file, in the <kbd>src/main/resources/config</kbd> folder. The names of the properties are <kbd>spring:datasource:username</kbd> and <kbd>spring:datasource:password</kbd><em>.</em> In the absence of this, you will get an error while running the application.</div>
<p>Let's add some data for our entities. Log in with admin credentials (<kbd>admin</kbd>/<kbd>admin</kbd>), and go to <span class="packt_screen">Entities</span> | <span class="packt_screen">Owner</span> to add the owner data first. The <span class="packt_screen">Create a new Owner</span> button will be used to insert an owner record. Similarly, we can add data for the <kbd>Car</kbd> entity. Since we have created a many-to-one relationship from <kbd>Car</kbd> to <kbd>Owner</kbd> (that is, many <kbd>Car</kbd> instances are associated with one <kbd>Owner</kbd>), you will see a field where you can select an <kbd>Owner</kbd> value while adding a <kbd>Car</kbd> entity.</p>
<p>The record for the <kbd>Car</kbd> entity, along with the reference to the <kbd>Owner</kbd> entity, will look as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/18d57ab2-fc3e-4c16-93cc-0678886ad8b2.png" style="width:57.50em;height:16.33em;"/></p>
<p>The value of the <kbd>name</kbd> attribute of the <kbd>Owner</kbd> entity is visible as a reference here, which we selected when we created the relationship. This page also shows pagination of the <span>link</span> type, which we selected during the <kbd>Car</kbd> entity creation, out of the box. Apart from this, you can perform CRUD operations for each individual entity without writing a single line of code yourself. This is definitely a cool feature that saves lots of development time and effort.</p>
<div class="packt_infobox">By default, JHipster creates an <span class="packt_screen">ID</span> column as the primary key for each entity table. Defining a custom column as <span>primary key</span> is not supported out of the box for the autogeneration of code. However, if the specific column is required as the <span>primary key</span>, you will need to modify the generated source code before running it with the <kbd>mvnw</kbd> command. </div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modeling the entity</h1>
                </header>
            
            <article>
                
<p>You have seen how JHipster speeds up development by automating many things. Modeling an entity in an application previously required many activities including table generation; the creation of the DAO, services, and a presentation layer; and validations and a user interface for each individual entity.</p>
<p>Although Spring Boot provides great help in terms of writing boilerplate code, the developer still has to write a lot of code to see something happening. This is a quite tedious and logically<span> </span>repetitive job. You have seen how JHipster greatly helps in this scenario, by providing autogenerating code to build a fully functional Spring Boot application without writing a single line of code yourself.</p>
<p>Designing an entity with complete working code is just a matter of providing certain information to JHipster. At first glance, this looks great, but there is another side to the coin. Think about a scenario wherein you need to incorporate more than five dozen entities with the JHipster CLI, which is quite possible when you write an enterprise application. Sometimes, the total entities reach beyond a hundred.</p>
<p>In this scenario, writing each entity with the CLI and providing all metadata, along with relationships with other entities, is painful. As a workaround, JHipster provides a graphical tool, where we can design all of the entities in one go. The aim is to simplify the process of defining a relationship with the visual tool, rather than doing it the classical way, with questions and answers. There are two options to visually model the entities, as follows:</p>
<ul>
<li>Modeling with <strong>Unified Modeling Language</strong> (<strong>UML</strong>)</li>
<li>Modeling with JDL</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modeling with UML</h1>
                </header>
            
            <article>
                
<p>In this option, we need to design all of the entities as a class diagram, and then import it into JHipster to generate the code for all of them in one go. So, the whole process is divided into two parts that work independently, as follows:</p>
<ul>
<li>Designing a class diagram of entities with a visual tool</li>
<li>Exporting the class diagram and importing it into JHipster</li>
</ul>
<p>During the early phase of application development, the class diagram is mainly used to design domain models. Showing <span>the attributes and operations of a class, along with its relationship with other classes, t</span>he class diagram describes a static view of an application. The classes used in the class diagram are directly mapped to the object-oriented language, and are also used to model the database tables.</p>
<p>JHipster has provided the benefit of this process in the generation of application code. A separate tool, called JHipster UML, has been designed; it reads the class diagram to generate the entity structure. It can be installed from the Git repository, or as a separate <kbd>npm</kbd> package, with the following command:</p>
<pre><strong>//For Global installation</strong><br/><strong>npm install -g jhipster-uml</strong><br/><br/><strong>//For local installation</strong><br/><strong>npm install jhipster-uml --dev</strong></pre>
<p>Most of the tools that are available today allow for exporting the class diagram into an XMI format. JHipster UML reads <span>XMI </span>files and generates entities. Since this tool generates entities in JHipster from class diagrams, the attribute type selection is limited to the list of JHipster-supported types. The list of JHipster-supported attribute types, along with possible validation rules for each attribute type, is as follows:</p>
<table border="1" style="border-collapse: collapse;width: 99.7966%">
<tbody>
<tr>
<td style="width: 5%"><strong>No.</strong></td>
<td style="width: 26%"><strong>Attribute type</strong></td>
<td style="width: 65.9346%"><strong>Possible validations</strong></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign" style="width: 5%">1</td>
<td style="width: 26%"><kbd>string</kbd></td>
<td style="width: 65.9346%"><span><kbd>required</kbd>, <kbd>minlength</kbd>, <kbd>maxlength</kbd>, <kbd>pattern</kbd></span></td>
</tr>
<tr>
<td style="width: 5%">2</td>
<td style="width: 26%"><kbd><span>integer</span></kbd></td>
<td style="width: 65.9346%"><span><kbd>required</kbd>, <kbd>min</kbd>, <kbd>max</kbd></span></td>
</tr>
<tr>
<td style="width: 5%">3</td>
<td style="width: 26%"><kbd><span>long</span></kbd></td>
<td style="width: 65.9346%"><span><kbd>required</kbd>, <kbd>min</kbd>, <kbd>max</kbd></span></td>
</tr>
<tr>
<td style="width: 5%">4</td>
<td style="width: 26%"><kbd><span>BigDecimal</span></kbd></td>
<td style="width: 65.9346%"><span><kbd>required</kbd>, <kbd>min</kbd>, <kbd>max</kbd></span></td>
</tr>
<tr>
<td style="width: 5%">5</td>
<td style="width: 26%"><kbd><span>float</span></kbd></td>
<td style="width: 65.9346%"><span><kbd>required</kbd>, <kbd>min</kbd>, <kbd>max</kbd></span></td>
</tr>
<tr>
<td style="width: 5%">6</td>
<td style="width: 26%"><kbd><span>double</span></kbd></td>
<td style="width: 65.9346%"><span><kbd>required</kbd>, <kbd>min</kbd>, <kbd>max</kbd></span></td>
</tr>
<tr>
<td style="width: 5%">7</td>
<td style="width: 26%"><kbd><span>enum</span></kbd></td>
<td style="width: 65.9346%"><kbd><span>required</span></kbd></td>
</tr>
<tr>
<td style="width: 5%">8</td>
<td style="width: 26%"><kbd><span>Boolean</span></kbd></td>
<td style="width: 65.9346%"><kbd><span>required</span></kbd></td>
</tr>
<tr>
<td style="width: 5%">9</td>
<td style="width: 26%"><kbd><span>LocalDate</span></kbd></td>
<td style="width: 65.9346%"><kbd><span>required</span></kbd></td>
</tr>
<tr>
<td style="width: 5%">10</td>
<td style="width: 26%"><kbd><span>ZonedDateTime</span></kbd></td>
<td style="width: 65.9346%"><kbd><span>required</span></kbd></td>
</tr>
<tr>
<td style="width: 5%">11</td>
<td style="width: 26%"><kbd><span>blob</span></kbd></td>
<td style="width: 65.9346%"><span><kbd>required</kbd>, <kbd>minbytes</kbd>, <kbd>maxbytes</kbd></span></td>
</tr>
<tr>
<td style="width: 5%">12</td>
<td style="width: 26%"><kbd><span>AnyBlob</span></kbd></td>
<td style="width: 65.9346%"><span><kbd>required</kbd>, <kbd>minbytes</kbd>, <kbd>maxbytes</kbd></span></td>
</tr>
<tr>
<td style="width: 5%">13</td>
<td style="width: 26%"><kbd><span>ImageBlob</span></kbd></td>
<td style="width: 65.9346%"><span><kbd>required</kbd>, <kbd>minbytes</kbd>, <kbd>maxbytes</kbd></span></td>
</tr>
<tr>
<td style="width: 5%">14</td>
<td style="width: 26%"><kbd><span>TextBlob</span></kbd></td>
<td style="width: 65.9346%"><span><kbd>required</kbd>, <kbd>minbytes</kbd>, <kbd>maxbytes</kbd></span></td>
</tr>
</tbody>
</table>
<p> </p>
<p>First, we need to design the class diagram for each domain model, along with the relationships between them. JHipster recommends using the following tools to generate a class diagram:</p>
<ul>
<li>Modelio</li>
<li>UML Designer</li>
<li>GenMyModel</li>
</ul>
<p>Out of these, the first two are completely open source, Eclipse-based graphical tools, and can be downloaded from their respective sites, while the third is a browser-based free tool and can be used directly on the web (with certain limitations). Once the class diagram is ready, export it to an XMI file and execute the following command in Command Prompt to generate the entity structure. Make sure that you are at the project directory when you execute this command:</p>
<pre><strong>jhipster-uml &lt;class-diagram.xmi&gt;</strong></pre>
<p>This will generate the entity structure. JHipster UML also provides various options to specify the pagination pattern, such as whether you want to use DTO or add service classes for each of your entities. It can be given along with the previous command, as follows:</p>
<pre><strong>// If you wish to use DTO. The possible values would be MapStruct</strong><br/><strong>jhipster-uml &lt;class-diagram.xmi&gt; --dto &lt;value&gt;</strong><br/><br/><strong>//Type of pagination pattern.The possible values are [pager,pagination,infinite-scroll]</strong><br/><strong>jhipster-uml &lt;class-diagram.xmi&gt; --paginate &lt;value&gt;</strong><br/><br/><strong>//If you need to add service layer with class and implementation. The values would be [serviceClass,serviceImpl]</strong><br/><strong>jhipster-uml &lt;class-diagram.xmi&gt; --service &lt;value&gt;</strong></pre>
<p>Based on the options that you have provided, JHipster UML generates entities and other source code. Finally, you need to execute the <kbd>mvnw</kbd> command, so that it will create/modify the required entity tables in the database, along with the Liquibase changelog file, and deploy the application to the server. While defining the relationships between the classes in a class diagram, you need to make sure that they are allowed in JHipster. The supported relationships are as follows:</p>
<ul>
<li>A bidirectional one-to-many relationship</li>
<li>A unidirectional many-to-one <span>relationship</span></li>
<li>A many-to-many <span>relationship</span></li>
<li>A bidirectional one-to-one <span>relationship</span></li>
<li>A unidirectional one-to-one <span>relationship</span></li>
</ul>
<p>Out of the box, a unidirectional one-to-many relationship is not supported by the JHipster code generator. JHipster recommends using a bidirectional one-to-many relationship instead.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modeling with JHipster Domain Language studio</h1>
                </header>
            
            <article>
                
<p>Designing the domain models as a class diagram and then generating the source code based on that is a pretty quick way to create entities in JHipster. Consequently, it saves time, compared to creating them one by one with the CLI. However, you still need to rely on third-party applications to work with JHipster. There is the chance that JHipster has very limited support for a specific version, or, in the worst case, is totally incompatible.</p>
<p>As a solution, JHipster provides a separate tool, called <strong>JDL studio</strong>. It is an online tool to create entities and build relationships between them. The clear benefit of using JDL studio is that it has been designed and maintained by the JHipster team, so there is almost no chance of version incompatibility and other issues. You can be confident when using the stable version. In case of any issues, you can easily get updates or support from the official JHipster issue tracker.</p>
<p>Creating entities with JDL studio is even more simple than modeling the entities with UML. <strong>JHipster Domain Language</strong> (<strong><span>JDL</span></strong>), it is a domain language that's used to construct entities with pretty simple and easy-to-use syntax in a single file (or sometimes, multiple files).</p>
<p>There are two ways to work with JDL. You can use either the <span>JHipster IDE </span>or the <span>online JDL-Studio (</span><a href="https://start.jhipster.tech/jdl-studio">https://start.jhipster.tech/jdl-studio</a><span>)</span>. The JHipster IDE is a plugin or extension for well-known IDEs, including Eclipse, Visual Studio, and Atom. The online JDL-Studio is a browser-based IDE, with which you can construct entities and their relationship in script form, which is written in JDL. You can relate it with writing SQL script for creating a database table and their relationship.</p>
<p>For sake of simplicity, we will look at a simple example of creating an entity with the online JDL-Studio. While writing a definition for each entity, JDL-Studio draws the entity diagram with their relationships side by side. <span>When opening the online JDL-Studio, you will see some sample entities, along with their relationships and other parameters, by default, to give you some ideas on how to start working with it.</span></p>
<p><span>Let's create <kbd>School</kbd> and <kbd>Teacher</kbd> entities, along with their relationship (one-to-many), in the online JDL-Studio. Open the URL and add the definition of these entities, as follows:</span></p>
<pre>entity School {<br/>  name String required<br/>    eduType EducationType required<br/>    noOfRooms Integer required min(5) max(99)<br/>}<br/>enum EducationType {<br/>  PRIMARY, SECONDARY, HIGHER_SECONDARY <br/>}<br/>entity Teacher {<br/>  name String required<br/>    age Integer min(21) max(58)<br/>}<br/>// defining multiple one-to-many relationships with comments<br/>relationship OneToMany {<br/>  School{teacher} to Teacher{school(name) required}<br/>}<br/>// Set pagination options<br/>paginate School with infinite-scroll<br/>paginate Teacher with pagination<br/><br/>// Use data transfer objects (DTO)<br/>dto * with mapstruct<br/><br/>// In case if DTO is not required for specific (comma separated)entities.<br/>// dto * with mapstruct except School<br/><br/>// Set service options to all except few<br/>service all with serviceImpl<br/><br/>// In case if service layer is not required for certain <br/>// (comma separated) entities. Just uncomment below line<br/>// service all with serviceImpl except School</pre>
<p>Each entity can be defined with the <kbd>entity</kbd> keyword, along with its attributes and data type. We can also define certain validations on each attribute. These validations not only impose the respective constraints at the database table level, but also at the frontend side. The <kbd>maxlength</kbd> validation denotes the maximum column length of the given attribute. The <kbd>min</kbd> and <kbd>max</kbd> validations describe the minimum and maximum values to be entered. The relationship between the entities can be defined with the following syntax:</p>
<pre>relationship (OneToMany | ManyToOne | OneToOne | ManyToMany) {<br/>  &lt;OWNER entity&gt;[{&lt;Relationship name&gt;[(&lt;Display field&gt;)]}] to &lt;DESTINATION entity&gt;[{&lt;Relationship name&gt;[(&lt;Display field&gt;)]}]<br/>}</pre>
<p>The <kbd>relationship</kbd> can be used with various options, as follows:</p>
<ul>
<li><kbd>(OneToMany | ManyToOne | OneToOne | ManyToMany)</kbd>: The possible types of relationship.</li>
<li><kbd>OWNER entity</kbd>: The owner entity of the relationship. It can also be described as the source of the relationship. The owning side entity must be on the left side.</li>
<li><kbd>DESTINATION entity</kbd>: This is the other-side entity where the relationship ends, the destination.</li>
<li><kbd>Relationship name</kbd>: This is the name of the field that represents the other-side type.</li>
<li><kbd>Display field</kbd>: While adding records for the entity, JHipster shows an other-side entity drop-down menu on the screen. This attribute shows the field name of the other-side entity that would be displayed in the drop-down menu. By default, it is the ID (primary key) of the other-side entity.</li>
<li><kbd>required</kbd>: This determines whether the other-side entity is required to be selected in the drop-down menu.</li>
</ul>
<p>The <kbd>paginate</kbd>, <kbd>dto</kbd>, and <kbd>service</kbd> keywords are used to define the configuration options for the pagination pattern, whether DTO needs to be generated, and <span>whether </span>a service layer with the implementation should be generated, respectively. They are quite straightforward and you can relate it to the respective options while creating the entity with the CLI. JHipster also supports mass (with <kbd>*</kbd>) and exclude options (with the <kbd>except</kbd> keyword), which are quite powerful and convenient. In short, various entity sub-generator features, like the field type, validations, relationships, DTOs, services, enumeration, and so on, are supported. JDL-Studio generates a diagram based on the definition of our entities, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/33f9fd8b-cf14-4061-85c7-5bfc4034b784.png" style="width:20.42em;height:17.67em;"/></p>
<p>In this example, we have defined a bidirectional relationship. If a unidirectional relationship is required, you <span>just </span>need to remove the name or relationship on both sides. For example, the unidirectional relationship between the <kbd>School</kbd> and <kbd>Teacher</kbd> entities can be defined as follows:</p>
<pre>relationship OneToMany {<br/>  School to Teacher<br/>}</pre>
<p>JHipster does not support a unidirectional, one-to-many relationship, but this is what it looks like. While defining the relationship, you need to aware of the <span>relationships </span>supported by JHipster, which we discussed in the previous section. </p>
<div class="packt_infobox">Along with generating the entity code, JDL is also used to create applications from scratch, along with the deployment options. So, instead of using the question-and-answer-based approach with the CLI, you can define all of the configuration options in a single JDL file and create an application in one shot.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating an entity using a model</h1>
                </header>
            
            <article>
                
<p>We have defined the entities in JDL studio. Now, we will instruct JHipster to generate entities, along with database tables and source code. This process involves the following two tasks:</p>
<ul>
<li>Exporting the entity definitions</li>
<li>Importing a JDL file to generate the required artifacts</li>
</ul>
<p>From JDL-Studio, you can export the definitions as a JDL <span>(<kbd>.jh</kbd>) </span>file. JHipster provides a sub-generator that will be used to import the JDL file, with the following command:</p>
<pre><strong>jhipster import-jdl &lt;your_jdl_file.jh&gt;</strong></pre>
<p>Needless to say, you need to execute this command under the JHipster project directory. Upon successful build and deployment, you will see the <kbd>School</kbd> and <kbd>Teacher</kbd> entities from the <span class="packt_screen">Entities</span> menu. You can also verify that the respective tables are generated. If an application has a large number of entities, it is quite difficult to put all of them in a single JDL file. If there is an error in one entity, the entire process of generating entities will not work properly. In the worst case, if multiple teams are working, then it will create maintenance problems.</p>
<p>JHipster has addressed this issue by allowing multiple JDL files, so that related entities can be grouped into individual JDL files. The <kbd>import-jdl</kbd> sub-generator allows importing multiple files separated by spaces. Upon executing this command for the first time, it will generate entities and all of the source code. You need to build and deploy the application with the <kbd>mvnw</kbd> command so that the necessary database changes will be reflected.</p>
<p>Second and subsequently, <kbd>import-jdl</kbd> will only regenerate the entities that have changed. If you wish to generate all of the entities from scratch again, you will need to add the <kbd>- force</kbd> <span>option.</span> Please be aware that this option will erase all customization applied to the entities. Certain validations are caught at the time that we build and deploy the application with the <kbd>mvnw</kbd> command, as follows:</p>
<ul>
<li>The <kbd>maxlength</kbd> and <kbd>minlength</kbd> validations are not allowed on columns of type <kbd>integer</kbd>, <kbd>long</kbd>, <kbd>BigDecimal</kbd>, <kbd>LocalDate</kbd>, <kbd>Boolean</kbd>, <kbd>enum</kbd>, <kbd>double</kbd>, and so on.</li>
<li>If the service layer is escaped for a given entity, then JHipster shows a warning if the DTO option with <kbd>mapstruct</kbd> is selected for that entity. In this situation, the application may not work properly.</li>
<li>While adding a single-line comment, you need to put one space after <kbd>//</kbd>, or else JHipster will show errors and the entities will not be generated properly.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Showing the national gross domestic product</h1>
                </header>
            
            <article>
                
<p>Now that you have an idea about how to create an application and model the entities, we will start creating an application that shows the GDP of various countries with JHipster. We'll do this to showcase the ability to apply customization in auto-generated code by JHipster.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application and entity creation</h1>
                </header>
            
            <article>
                
<p>Refer to the <em>Create an Application</em> section to create a new application, naming it <kbd>gdp</kbd>. We are going to build an application with similar functionality to that which we created with Spring Framework in <a href="87add83e-e65b-4b58-9ef1-113ad157a51a.xhtml">Chapter 1</a>, <em>Creating an Application to List World Countries with their GDP</em>. To show the GDP data of various countries, we took the reference of a sample country, city and country language data from MySQL databases (<a href="https://dev.mysql.com/doc/index-other.html">https://dev.mysql.com/doc/index-other.html</a>) and used a REST service to fetch the GDP data for a given country through the World Bank API (<a href="https://datahelpdesk.worldbank.org/knowledgebase/articles/898614-aggregate-api-queries">https://datahelpdesk.worldbank.org/knowledgebase/articles/898614-aggregate-api-queries</a>). We will use the same reference to build an application with JHipster.</p>
<p>To make it simple, we will use columns which are necessary to fulfill the purpose of the application. It is important to understand the table structure first. The database tables and their relationship details will be as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bef82c37-c2d0-4ecd-bfdd-2c6bf417b7d9.png" style="width:40.83em;height:17.00em;"/></p>
<p>Let's define the entities first. JHipster recommends JDL for entity and code generation so we will use it to create our entity structure and generate our service layer, REST controllers, and DTO, along with a set of components for the frontend layer. The JDL script would be as follows:</p>
<pre>entity Country{<br/>  code String required maxlength(3)<br/>    name String required maxlength(52)<br/>    continent Continent required<br/>    region String required maxlength(26)<br/>    surfaceArea Float required<br/>    population Integer required<br/>    lifeExpectancy Float<br/>    localName String required maxlength(45)<br/>    governmentForm String required maxlength(45)<br/>}<br/>entity City{<br/>  name String required maxlength(35)<br/>    district String required maxlength(20)<br/>    population Integer required<br/>}<br/><br/>entity CountryLanguage{<br/>    language String required<br/>    isOfficial TrueFalse required<br/>    percentage Float required<br/>}<br/><br/>enum Continent {<br/>  ASIA, EUROPE, NORTH_AMERICA, AFRICA, OCEANIA, ANTARCTICA, SOUTH_AMERICA<br/>}<br/><br/>enum TrueFalse{<br/>  T, F<br/>}<br/><br/>// Set pagination options<br/>paginate Country, City, CountryLanguage with pagination<br/><br/>// Use data transfer objects (DTO)<br/>dto * with mapstruct<br/><br/>// Set service options. Alternatively 'Service all with sericeImpl can be used<br/>service all with serviceImpl<br/><br/>relationship OneToMany{<br/>  Country{city} to City {country(name) required}<br/>  Country{countryLanguage} to CountryLanguage{country(name) required}<br/>}<br/>filter Country</pre>
<p class="mce-root">This script contains the entity definition for respective tables, along with <kbd>enum</kbd> for <kbd>Continent</kbd> and <kbd>TrueFalse</kbd>. We also defined a pagination pattern, DTO structure, and service layer with the <kbd>Service</kbd> class and interface (<kbd>serviceImpl</kbd>), along with a type of relationship. The <kbd>Country</kbd> will have one-to-many relationships with both <kbd>City</kbd> and <kbd>CountryLanguage</kbd>. </p>
<p class="mce-root">The <kbd>country(name)</kbd> in the relationship, on the other side it will show the country name as a reference, instead of the default <kbd>ID</kbd> of the country. Give special attention to the last option—<kbd>filter</kbd>. This declares the <kbd>filter</kbd> option for the <kbd>Country</kbd> entity, which is used to apply various filtering criteria while fetching records for the entity. We will explore this in more <span>detail </span>in the <em>Developing custom screens</em> section. The JDL diagram should look as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e0bc985b-b705-49ba-80c6-8600ee143d69.png" style="width:31.67em;height:33.83em;"/></p>
<p>Since we have omitted a few columns in each table provided by MySQL, the required changes also need to be made in the respective insert script of these tables. You will find the modified insert script in the <kbd>download</kbd> folder of the project structure. At this moment, you have to apply the insert script <span>before moving further.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling enumeration data with a database in JHipster </h1>
                </header>
            
            <article>
                
<p>Next, we'll run the application and verify that JHipster has created three entities and that they are available in the <span class="packt_screen">Entities</span> menu to perform various CRUD operations. The first time we run the application, we will get an error, as follows:</p>
<pre><strong>org.springframework.dao.InvalidDataAccessApiUsageException: Unknown name value [Asia] for enum class [com.nilangpatel.domain.enumeration.Continent]; nested exception is java.lang.IllegalArgumentException: Unknown name value [Asia] for enum class [com.nilangpatel.domain.enumeration.Continent] at org.springframework.orm.jpa.EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(EntityManagerFactoryUtils.java:367) ....</strong></pre>
<p>This error occurs while fetching continent data and trying to map it with the <kbd>Continent</kbd> enum data type.  The root cause is that we have defined the type of the <kbd>continent</kbd> column of the <kbd>Country</kbd> entity as a <kbd>Continent</kbd> enum. The actual value in that column, which is added through an insert script (from the MySQL site) is not exactly the same as the <kbd>Continent</kbd> enum values.  For example, the actual value in the database is <kbd>Asia</kbd>, while the corresponding enum is <kbd>ASIA</kbd>.</p>
<p>Another value of the <kbd>continent</kbd> column is <kbd>North America</kbd>, while the corresponding enum is <kbd>NORTH_AMERICA</kbd>. <span>Because of the limitations of enum in Java, we can't put a space in the middle of the value, and that is the reason we kept the values as </span><kbd>NORTH_AMERICA</kbd><span>,</span> <kbd>SOUTH_AMERICA</kbd>, and so on<span>. Because of this limitation, along with the case difference, you will get the previous exception while running the application.</span></p>
<p>As a workaround, we need to provide some sort of mapping of actual values in the database column, to enum values in Java. For this, we will use the JPA attribute converter mechanism. It is basically used to define a method to convert database values to Java representations of an attribute and vice versa. Open the <kbd>Country.java</kbd> class at the <kbd>com.nilangpatel.domain</kbd> package and update the annotation declaration for the <kbd>continent</kbd> attribute as follows:</p>
<pre>@NotNull<br/>//@Enumerated(EnumType.STRING) // commented original<br/>@Convert(converter=ContinentEnumConvertor.class) // added newly<br/>@Column(name = "continent", nullable = false)<br/>private Continent continent;       </pre>
<p>Originally, it was defined as <kbd>@Enumerated(EnumType.STRING)</kbd>, which was commented out with an added <kbd>@Convert</kbd> annotation. This annotation requires implementation of the <kbd>javax.persistence.AttributeConverter</kbd> interface. The implementation is provided by the <kbd>ContinentEnumConvertor</kbd> <span>custom class </span>as follows:</p>
<pre>public class ContinentEnumConvertor implements AttributeConverter&lt;Continent, String&gt;{<br/>  @Override<br/>  public String convertToDatabaseColumn(Continent continent) {<br/>    return continent.getName();<br/>  }<br/>  @Override<br/>  public Continent convertToEntityAttribute(String continentValue) {<br/>    return Continent.getContinent(continentValue);<br/>  }<br/>}</pre>
<p>These two methods will convert the values between the database and the corresponding enum value in Java. We also need to do necessary changes in the <kbd>Continent</kbd> enum class, as follows:</p>
<pre>public enum Continent {<br/>  ASIA("Asia"), EUROPE("Europe"), NORTH_AMERICA("North America"), AFRICA("Africa"), OCEANIA("Oceania"), ANTARCTICA("Antarctica"), SOUTH_AMERICA("South America");<br/>    private String name;<br/>  Continent(String name){<br/>    this.name=name;<br/>  }<br/>  public String getName() {<br/>    return this.name;<br/>  }<br/>  public static Continent getContinent(String name) {<br/>    Continent returnContinent = null;<br/>    switch(name){<br/>      case "Asia": returnContinent = Continent.ASIA;break;<br/>      case "Europe": returnContinent = Continent.EUROPE;break;<br/>      case "North America": returnContinent = Continent.NORTH_AMERICA;break;<br/>      case "Africa": returnContinent = Continent.AFRICA;break;<br/>      case "Oceania": returnContinent = Continent.OCEANIA;break;<br/>      case "Antarctica": returnContinent = Continent.ANTARCTICA;break;<br/>      case "South America": returnContinent = Continent.SOUTH_AMERICA;break;<br/>      default: returnContinent = null;<br/>    }<br/>    return returnContinent;<br/>  }<br/>}</pre>
<p>Run the application, and you will see the entities and JHipster allows to perform CRUD operation to only logged in user. However you will still see that the continent values are rendered as enum values, such as <span><kbd>ASIA</kbd>, <kbd>NORTH_AMERICA</kbd>, and so on, </span>instead of the actual database column values. </p>
<p>The reason for this is that, when enabling internationalization support at the time of application creation, JHipster generates the display value for various labels, error messages, and various enumerations. It nicely creates the key-value pair in a separate file for each artifact. These files are generated for each language-specific folder, under the <kbd>src/main/webapp/i18n</kbd> folder. For example, the language keys and their value for the <kbd>Country</kbd> <span>entity are</span> created in the <kbd>src/main/webapp/i18n/en/country.json</kbd> file.</p>
<p>Since our application only <span>has </span>one language, <kbd>English</kbd>, the language keys are only generated for the <kbd>English</kbd> language, under the <kbd>en</kbd> folder, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c191091e-0820-4a1f-8179-e321890ce937.png" style="width:15.17em;height:33.67em;"/></p>
<p>The keys and values are created in a JSON format. To understand its structure, open the <kbd>country.json</kbd> file, which looks as follows:</p>
<pre>{<br/>    "gdpApp": {<br/>        "country": {<br/>            "home": {<br/>                "title": "Countries",<br/>                "createLabel": "Create a new Country",<br/>            },<br/>            "created": "A new Country is created with identifier {{ param }}",<br/>            "delete": {<br/>                "question": "Are you sure you want to delete Country {{ id }}?"<br/>            },<br/>            "detail": {<br/>                "title": "Country"<br/>            },<br/>            "code": "Code",<br/>            "name": "Name",<br/>            "continent": "Continent",<br/>          ....<br/>        }<br/>    }<br/>}</pre>
<p>The title is accessible with the <kbd>gdpApp.country.home.title</kbd> <span>key. </span>This will be used in the HTML template. Open the <kbd>country.component.html</kbd> file under the <kbd>/src/main/webapp/app/entities/country</kbd> folder, and you will see the following code to use this key:</p>
<pre>&lt;div&gt;<br/>    &lt;h2 id="page-heading"&gt;<br/>        &lt;span jhiTranslate="gdpApp.country.home.title"&gt;Countries&lt;/span&gt;<br/>    ....</pre>
<p>JHipster has created various modules to support validations, enums, reading and parsing JSON, and so on. One of them, <kbd>translation</kbd>, supports internationalization. These are installed during JHipster installation as a <kbd>jhipster-core</kbd> package, under the <kbd>node_modules</kbd> folder created under the project directory. If you need to add further labels, you can place the key in the respective JSON file and use <kbd>jhiTranslate</kbd> to render the value. </p>
<p>Now, back to our problem of showing the enum values on the screen for the <kbd>Country</kbd> entity, instead of the actual database value. This happens because the translation in <kbd>continent.json</kbd> is generated with an enum value, by default. You can change it as follows in order to show correct continent values on the screen:</p>
<pre> "ASIA": "Asia",<br/> "EUROPE": "Europe",<br/> "NORTH_AMERICA": "North America",<br/> "AFRICA": "Africa",<br/> "OCEANIA": "Oceania",<br/> "ANTARCTICA": "Antarctica",<br/> "SOUTH_AMERICA": "South America",</pre>
<p>Everything should work as expected now. The admin is able to see all three entities, and can perform CRUD operations properly. We will now develop custom screens to show the GDP data by <span>country</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Filter provision in service, persistence, and the REST controller layer</h1>
                </header>
            
            <article>
                
<p><span>Let's recall that, while creating the entities with JDL, we set the <span class="packt_screen">filter</span> option for the <kbd>Country</kbd> entity in the JDL script, at the end. Let's look at how this makes a difference to the service, persistence, and REST controller layers. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The persistence layer</h1>
                </header>
            
            <article>
                
<p><span>When we add a filter option for any entity, JHipster makes the necessary changes to the repository interface corresponding to that entity. In our case, the <kbd>CountryRepository</kbd> is now extending the <kbd>JpaSpecificationExecutor</kbd> interface, which is used to add <kbd>Specification</kbd> capabilities to the repository, as follows:</span></p>
<pre>public interface CountryRepository extends JpaRepository&lt;Country, Long&gt;, JpaSpecificationExecutor&lt;Country&gt;</pre>
<p>Spring Data JPA provides a <kbd>Specification</kbd> interface to execute the criteria query, which is used to retrieve values from the database with various criteria on database columns. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The service layer</h1>
                </header>
            
            <article>
                
<p>In the service layer, JHipster generates a separate class as <kbd>xxxQueryService</kbd>, under the service package. For the <kbd>Country</kbd> entity, a new service class, <kbd>CountryQueryService</kbd>, is created. The purpose of this class is to retrieve the data with the filtering criteria, so it contains only fetch methods, which look as follows:</p>
<pre> public Page&lt;CountryDTO&gt; findByCriteria(CountryCriteria criteria, Pageable page) {<br/>     log.debug("find by criteria : {}, page: {}", criteria, page);<br/>     final Specification&lt;Country&gt; specification = createSpecification(criteria);<br/>     return countryRepository.findAll(specification, page)<br/>            .map(countryMapper::toDto);<br/> }</pre>
<p>JHipster generates a <span><strong>Plain Old Java Object</strong> (</span><strong>POJO</strong>) class for each entity that is declared with the filter option. This is used to pass the filter values from the frontend to the service layer. In our case, JHipster generates a <kbd>CountryCriteria</kbd> class that serves this purpose for the <kbd>Country</kbd> entity. This class contains various filters for each corresponding field in the domain object. I<span>f filters are not applied, this will bring all of the entities.</span></p>
<p>JHipster has created various filter types, corresponding to each wrapper class type. For any custom type, it creates an inner class that extends the<span> </span><kbd>io.github.jhipster.service.filter.Filter</kbd> class. The <kbd>CountryCriteria</kbd> class looks as follows:</p>
<pre>public class CountryCriteria implements Serializable {<br/>    /**<br/>     * Class for filtering Continent<br/>     */<br/>    public static class ContinentFilter extends Filter&lt;Continent&gt; {<br/>    }<br/>    private static final long serialVersionUID = 1L;<br/>    private LongFilter id;<br/>    private StringFilter code;<br/>    private StringFilter name;<br/>    private ContinentFilter continent;<br/>    private StringFilter region;<br/>    private FloatFilter surfaceArea;<br/>    private IntegerFilter population;<br/>    private FloatFilter lifeExpectancy;<br/>    private StringFilter localName;<br/>    private StringFilter governmentForm;<br/>    private LongFilter cityId;<br/>    private LongFilter countryLanguageId;<br/> //setters and getters<br/>}</pre>
<p class="mce-root">The <kbd>continent</kbd> <span>attribute </span>in the <kbd>Country</kbd> <span>domain class </span>is of the enum <span>type</span>, so JHipster has created an inner filter class of <kbd>ContinentFilter</kbd>, and for other attributes of the type wrapper class, it uses corresponding filters. From the frontend, you need to pass search text as a request parameter in a specific way, based on the type of the attribute as follows. Consider the attribute name as <kbd>abc</kbd><em>:</em></p>
<ul>
<li>If attribute <kbd>abc</kbd> is of the string <span>type</span>:
<ul>
<li><kbd>abc.contains=&lt;seach_text&gt;</kbd>: List down all entities where the value of <kbd>abc</kbd> contains <kbd>search_text</kbd>.</li>
</ul>
</li>
<li>If attribute <kbd>abc</kbd> is of <span>any </span>number <span>type</span> (float, long, double, integer) or the date:
<ul>
<li><kbd>abc.greaterThan=&lt;search_text&gt;</kbd>: List down all entities where <span>the value of </span><kbd>abc</kbd><em> </em>is greater than <kbd>search_text</kbd>.</li>
<li><kbd>abc.lessThan=&lt;search_text&gt;</kbd>: <span><span>List down all the entities where the value of <kbd>abc</kbd><em> </em>is less than <kbd>search_text</kbd>.</span></span></li>
<li><kbd>abc.greaterOrEqualThan=&lt;search_text&gt;</kbd>:<strong> </strong><span>List down all the entities where the value of <kbd>abc</kbd><em> </em>is greater than or equals to <kbd>search_text</kbd>.</span></li>
<li><kbd>abc.lessOrEqualThan=&lt;search_text&gt;</kbd>:<strong> </strong><span>List down all the entities where the value of <kbd>abc</kbd><em> </em>is less than or equal to <kbd>search_text</kbd>.</span></li>
</ul>
</li>
<li>If attribute <kbd>abc</kbd> is of a custom type:
<ul>
<li><kbd>abc.equals=&lt;search_text&gt;</kbd>: <span>List down all of the entities where the value of <kbd>abc</kbd> is exactly similar to <kbd>search_text</kbd>.</span></li>
<li><kbd>abc.in=&lt;comma separated search_text values&gt;</kbd>: <span>List down all of the entities where a value of <kbd>abc</kbd><em> </em>is within the list of <kbd>search_text</kbd>.</span></li>
<li><kbd>abc.specified=true</kbd>: <span>List down all of the entities where the value of <kbd>abc</kbd><em> </em>is not null, which means specified.</span></li>
<li><kbd>abc.specified=false</kbd>: <span>List down all entities where the value of <kbd>abc</kbd><em> </em>is null, which means not specified.</span></li>
</ul>
</li>
</ul>
<p>These rules can be combined for more than one attributes to form a complex query. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The REST controller layer</h1>
                </header>
            
            <article>
                
<p>When applying the filter option, JHipster also makes necessary changes to the REST controller. <span>For example, all <kbd>get</kbd> methods of REST controller <kbd>CountryResouce</kbd> for entity <kbd>Country</kbd> are now taking <kbd>CountryCriteria</kbd> as a parameter to support filtering operations, as follows:</span></p>
<pre> @GetMapping("/countries")<br/> @Timed<br/> public ResponseEntity&lt;List&lt;CountryDTO&gt;&gt; getAllCountries(<br/>     CountryCriteria criteria, Pageable pageable) {<br/><br/>     log.debug("REST request to get Countries by criteria: {}", criteria);<br/>     Page&lt;CountryDTO&gt; page = countryQueryService.findByCriteria(criteria, pageable);<br/>     HttpHeaders headers = PaginationUtil.<br/>                 generatePaginationHttpHeaders(page, "/api/countries");<br/>     return ResponseEntity.ok().headers(headers).body(page.getContent());<br/> }</pre>
<p>This is how the filter option impacts the persistence, service, and REST controller layer code generation. With single-filter configuration, JHipster makes all of the necessary changes. However, the REST controllers generated for each entity are protected with Spring Security, by default. You can verify this in the <kbd>config()</kbd> method of the <kbd>com.nilangpatel.config.SecurityConfiguration</kbd> class, as follows:</p>
<pre>    public void configure(HttpSecurity http) throws Exception {<br/>        ....<br/>        .and()<br/>            .authorizeRequests()<br/>            .antMatchers("/api/register").permitAll()<br/>            .antMatchers("/api/activate").permitAll()<br/>            .antMatchers("/api/authenticate").permitAll()<br/>            .antMatchers("/api/account/reset-password/init").permitAll()<br/>            .antMatchers("/api/account/reset-password/finish").permitAll()<br/>            .antMatchers("/api/**").authenticated()<br/>            ....<br/>    }</pre>
<p>Apart from the register, activate, authenticate, and reset password operations, all other URLs (<kbd>/api/**</kbd>) are restricted to logged-in users. But, in our case, we want to show the country GDP data to regular users, without logins. For this, we need to create a custom REST controller with a different URL pattern, as follows:</p>
<pre>@RestController<br/>@RequestMapping("/api/open")<br/>public class GenericRestResource {<br/>  private final Logger log = LoggerFactory.getLogger(GenericRestResource.class);<br/>  private final CountryQueryService countryQueryService;<br/><br/>    public GenericRestResource(CountryQueryService countryQueryService) {<br/>        this.countryQueryService = countryQueryService;<br/>    }<br/><br/>    @GetMapping("/search-countries")<br/>    @Timed<br/>    public ResponseEntity&lt;List&lt;CountryDTO&gt;&gt; getAllCountriesForGdp(<br/>                CountryCriteria criteria, Pageable pageable) {<br/>        log.debug("REST request to get a page of Countries");<br/>        Page&lt;CountryDTO&gt; page = countryQueryService.findByCriteria<br/>             (criteria, pageable);<br/>        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(<br/>             page, "/api/open/search-countries");<br/>        return ResponseEntity.ok().headers(headers).body(page.getContent());<br/>    }<br/>    @GetMapping("/show-gdp/{id}")<br/>    @Timed<br/>    public ResponseEntity&lt;CountryDTO&gt; getCountryDetails(@PathVariable Long id) {<br/>        log.debug("Get Country Details to show GDP information");<br/>        CountryDTO countryDto = new CountryDTO();<br/>        Optional&lt;CountryDTO&gt; countryData = countryService.findOne(id);<br/>        return ResponseEntity.ok().body(countryData.orElse(countryDto));<br/>    }<br/>}</pre>
<p>The first method is similar to what it has auto-generated in <kbd>CountryResource</kbd>. The second method will be used to show the GDP data, and we will use it while creating that screen. The URL pattern map to this controller is <kbd>/api/open</kbd>. The purpose of creating a separate REST controller is to make it accessible without a login, by configuring its URL pattern with Spring Security in the <kbd>configure</kbd> method of <kbd>SecurityConfiguration</kbd>, as follows:</p>
<pre>public void configure(HttpSecurity http) throws Exception {<br/>   ....<br/>    .antMatchers("/api/activate").permitAll()<br/>    <strong>.antMatchers("/api/open/**").permitAll()</strong><br/>    .antMatchers("/api/authenticate").permitAll()<br/>    ....<br/>}</pre>
<p>This controller is now accessible publicly. We will use the controller methods while constructing a frontend layer with Angular in the <em>Develop custom screens</em> section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a filter option to existing entities</h1>
                </header>
            
            <article>
                
<p><span>If the entities are already generated without the filter option, and you want to add it later on, you will need to perform certain steps. The following are two possible approaches:</span></p>
<ol>
<li><span>With Command Prompt, do the following:</span>
<ol>
<li>Open the entity's JSON file under the <kbd>.jhipster</kbd> folder, inside of the project directory. For example, for a <kbd>Country</kbd> entity, you will see a file named <kbd>Country.json</kbd> inside of the <kbd>.jhipster</kbd> folder.</li>
<li>If the value of the <kbd>service</kbd> key is <kbd>no</kbd>, change it to either <kbd>serviceClass</kbd> or <kbd>serviceImpl</kbd><em>.</em> The service layer option has to be enabled for the filtering option.</li>
<li>Change the value of the key <kbd>jpaMetamodelFiltering</kbd> to <kbd>true</kbd>.</li>
<li>Regenerate the entity with the <kbd>jhipster entity &lt;entity_name&gt;</kbd> command. </li>
</ol>
</li>
</ol>
<ol start="2">
<li>With JDL, do the following:
<ol>
<li>Add a line containing <kbd>filter &lt;entity_name&gt;</kbd><em> </em>to the JDL script file.</li>
<li>Re-import the definition with the <kbd>jhipster jhipster-jdl &lt;jdl_file&gt;</kbd> command.</li>
</ol>
</li>
</ol>
<p>In both of these scenarios, the customization will be reverted while regenerating the entities, so make a proper back-up before performing this task.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing custom screens</h1>
                </header>
            
            <article>
                
<p>By default, JHipster only shows the entities to logged-in users. <span>The aim of our application is to show the GDP data of a given country to the end user. To achieve this, the country data must be visible publicly. In other words, it must be accessible without a login. To make it more user-friendly, we will design the flow in two different screens.</span></p>
<p><span>The first screen will list all the countries available in the system. Selecting any of them will show the actual GDP of that country on the second screen, with a graphical presentation. These are the custom screens that we need to develop from scratch and plug into the JHipster project structure, which we will do in this section.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The search country screen</h1>
                </header>
            
            <article>
                
<p>In this screen, we will list of all of the countries available in the system with pagination. It is identical to the <em>Country</em> entity screen but available to all users (without login). For better user experience, we will add filters to find a specific country on this screen. It looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6bec5ea1-5a09-4947-8ad2-73df7292f760.png" style="width:40.17em;height:16.33em;"/></p>
<p>This screen has two filters. The first filter will match the search text in the country name (<kbd>contains</kbd> criteria), while the second will compare the selected continent (<kbd>equals</kbd> criteria). These filters help the user to find their desired country instantly. To make it simpler, we have added just a few columns of information about each country, which seems appropriate for this screen. At the end of each country record, the <span class="packt_screen">View</span> button will navigate a user to the second screen, where it shows the GDP information of that country. </p>
<p>JHipster provides either <strong>Angular</strong> or <strong>React</strong> as an option to develop the frontend. We have chosen Angular to create this application. Consequently, all of our out-of-the-box screens are generated with the Angular framework. Since this is a custom screen, we need to use various Angular artifacts to develop it. Create a <kbd>gdp</kbd> folder inside of the <kbd>/src/webapp/app</kbd> folder, and, in the next subsection, we'll create Angular artifacts inside of it, to construct custom screens.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an Angular service</h1>
                </header>
            
            <article>
                
<p>Angular is a modular framework wherein we write many components, each for a specific purpose. Many times, we are in need of some common functionalities shared across multiple components. Additionally, we may need to fetch records from the database with a REST call. This is where creating an Angular service makes perfect sense. For our GDP application, we need to fetch country data in the Angular service as follows:</p>
<pre>@Injectable({ providedIn: 'root'})<br/>export class CountryGDPService {<br/>    public searchCountryUrl = SERVER_API_URL + 'api/open/search-countries';<br/>    public showGDPUrl = SERVER_API_URL + 'api/open/show-gdp';<br/>    constructor(private http: HttpClient) { }<br/>    query(req?: any): Observable&lt;EntityArrayResponseType&gt; {<br/>        const options = createRequestOption(req);<br/>        return this.http.get&lt;ICountry[]&gt;(this.searchCountryUrl, <br/>            { params: options, observe: 'response' });<br/>    }<br/>    find(id: number): Observable&lt;EntityResponseType&gt; {<br/>        return this.http.get&lt;ICountry&gt;(`${this.showGDPUrl}/${id}`, <br/>               { observe: 'response' });<br/>    }<br/>}</pre>
<p>The <kbd>query</kbd> method is used to fetch all of the countries with various request parameters sent by the <kbd>search-country</kbd> component. The second method, <kbd>find</kbd>, is used to fetch a specific country, based on a given <kbd>id</kbd> value. This service class uses the <kbd>HttpClient</kbd> module, which is <span>provided by the Angular framework out of the box, </span>to make a REST call to the newly created REST controller.</p>
<p>The <kbd>api/open/search-countries</kbd> and <kbd>api/open/show-gdp</kbd> URLs are used to make calls to the REST controller methods, <kbd>getAllCountriesForGdp()</kbd> and <kbd>getCountryDetails()</kbd>, respectively. However, the <kbd>find()</kbd> method of service component is <span>dynamically </span>passing the <kbd>id</kbd> value into the URL with the <kbd>${this.showGDPUrl}/${id}</kbd> <span>expression. </span>This service class is common for both of the screens.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Angular router</h1>
                </header>
            
            <article>
                
<p>The next artifact is the Angular router. The Angular router is used to manage application navigation and routing between various components. The <span>Angular router </span><span>uses a </span>browser URL to map it to a specific component. It does various types of processing on the browser URL, such as parsing to verify that the URL is valid; doing a redirect if that option is given; matching the component against the URL segment; validating if the given URL is accessible with the set of guards; running the associate resolves to dynamically add the data; and finally, activating the component and performing navigation. We will write the Angular router as follows:</p>
<pre>@Injectable({ providedIn: 'root' })<br/>export class CountryGDPResolve implements Resolve&lt;ICountry&gt; {<br/>    constructor(private service: CountryGDPService) {}<br/><br/>    resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;Country&gt; {<br/>        const id = route.params['id'] ? route.params['id'] : null;<br/>        if (id) {<br/>            return this.service.find(id).pipe(<br/>                filter((response: HttpResponse&lt;Country&gt;) =&gt; response.ok),<br/>                map((country: HttpResponse&lt;Country&gt;) =&gt; country.body)<br/>            );<br/>        }<br/>        return of(new Country());<br/>    }<br/>}<br/><br/>export const countryGDPRoute: Routes = [<br/>    {<br/>        path: 'countries',<br/>        component: SearchCountryComponent,<br/>        resolve: {<br/>            pagingParams: JhiResolvePagingParams<br/>        },<br/>        data: {<br/>            defaultSort: 'name,asc',<br/>            pageTitle: 'gdpApp.country.home.title'<br/>        },<br/>    },<br/>    {<br/>        path: 'showGDP/:id',<br/>        component: CountryGDPComponent,</pre>
<pre>        resolve: {<br/>            country: CountryGDPResolve<br/>        }<br/>    },<br/>];</pre>
<p>It comprises a <kbd>resolve</kbd> class (<kbd>CountryGDPResolve</kbd>) and a route array. The <kbd>resolve</kbd> class fetches the full country model data, based on a country ID when a user clicks on <span class="packt_screen">View</span> button to initiate a transition to the second screen. It uses a service component to make a REST call and fetch country information. The router array holds the configuration mapping of components and the URLs by which they will be triggered. This Angular router is also common for both screens.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Angular modules</h1>
                </header>
            
            <article>
                
<p>As we know, Angular is a modular framework. A module in Angular is used to group related components, pipes, directives, and services, to form an independent unit, which can be combined with other modules to form a complete application. A <strong>module</strong> can control which components, services, and other artifacts are hidden and visible to other modules, in much the same way that a Java class has public and private methods. We will use a single module called <kbd>CountryGDPModule</kbd>, as follows:</p>
<pre>const ENTITY_STATES = [...countryGDPRoute];<br/><br/>@NgModule({<br/>    imports: [GdpSharedModule, RouterModule.forChild(ENTITY_STATES)],<br/>    declarations: [<br/>        SearchCountryComponent,<br/>        CountryGDPComponent,<br/>    ],<br/>    entryComponents: [SearchCountryComponent , CountryGDPComponent],<br/>    schemas: [CUSTOM_ELEMENTS_SCHEMA]<br/>})<br/>export class CountryGDPModule {}</pre>
<p>It defines all of the components and routers that are necessary to be part of this module. It is common for both screens.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an Angular component to show the country list</h1>
                </header>
            
            <article>
                
<p>Next, we will write a component to show the country list on the first screen. A component is a basic building block with which we create our Angular application. Every Angular application has at least one component. The component holds application data and logic to show the data in the HTML template associated with it. We will write a separate component for each of the screens in our application. For the first screen, we will write a <kbd>search-country</kbd> component, as follows:</p>
<pre>@Component({<br/>  selector: 'jhi-search-country',<br/>  templateUrl: './search-country.component.html',<br/>})<br/>export class SearchCountryComponent implements OnInit {<br/>    countries: ICountry[];<br/>    routeData: any;<br/>    totalItems: any;<br/>    queryCount: any;<br/>    itemsPerPage: any;<br/>    page: any;<br/>    predicate: any;<br/>    previousPage: any;<br/>    reverse: any;<br/><br/>    // variables for country name and continent filters.<br/>    nameFilter: String;<br/>    continentFilter: String;<br/><br/>   constructor(<br/>        private countryGDPService: CountryGDPService,<br/>        private activatedRoute: ActivatedRoute,<br/>        private router: Router,<br/>    ) {<br/>        this.itemsPerPage = ITEMS_PER_PAGE;<br/>        this.routeData = this.activatedRoute.data.subscribe(data =&gt; {<br/>            this.page = data.pagingParams.page;<br/>            this.previousPage = data.pagingParams.page;<br/>            this.reverse = data.pagingParams.ascending;<br/>            this.predicate = data.pagingParams.predicate;<br/>        });<br/>    }<br/><br/>   loadAll() {<br/>        this.countryGDPService<br/>            .query({<br/>                page: this.page - 1,<br/>                size: this.itemsPerPage,<br/>                sort: this.sort(),<br/>                'name.contains': this.nameFilter,<br/>                'continent.equals' : this.continentFilter<br/>            })<br/>            .subscribe(<br/>                (res: HttpResponse&lt;ICountry[]&gt;) =&gt; this.paginateCountries(res.body, res.headers),<br/>            );<br/>    }<br/> .....<br/>   <br/>}</pre>
<p>An Angular component can be created with the <kbd>@component()</kbd> decorator. The <kbd>SearchCountryComponent</kbd> <span>class </span>represents the <kbd>search-country</kbd> component. It is defined with certain variables that are used for pagination and filtering purposes. The object of <kbd>CountryGDPService</kbd> is injected into the component class through a constructor, which will be used in other methods to fetch country data. The constructor is initialized with pagination variables, which are used to handle pagination on the first screen.</p>
<p>Soon after the component class is initialized with the constructor, Angular will call the <kbd>ngOnInit()</kbd> method. In this method, we are initializing a few parameters and making a call to other methods with <kbd>loadAll()</kbd>. This method calls the <kbd>query()</kbd> method of the <span><kbd>countryGDPService</kbd> object t</span>o fetch the country info.</p>
<p>The <kbd>query()</kbd> method takes various pagination and filtering parameters. The <kbd>page</kbd>, <kbd>size</kbd>, and <kbd>sort</kbd> are pagination parameters, while <kbd>name.contains</kbd> and <kbd>continent.equals</kbd> are filtering parameters. They are eventually submitted to the REST controller through <kbd>CountryGDPService</kbd>. </p>
<p>The <kbd>name.contains</kbd> <span>filtering parameter </span>is used to filter the country data, based on the <kbd>name</kbd> attribute. Since it is of the type <kbd>String</kbd>, we have used the <kbd>contains</kbd> criteria. Similarly, the other filtering parameter, <kbd>continent.equals</kbd>, is used to filter the data for the <kbd>continent</kbd> attribute. Since it is of the type <kbd>enum</kbd>, we are using the <kbd>equals</kbd> criteria. This is what we have seen in the <em>Service layer</em> section, under the <em>Filter provision in service, persistence, and the REST controller layer</em> subsection.</p>
<p class="mce-root">The other functions, like <kbd>searchCountries()</kbd>, <kbd>trackId()</kbd>, <kbd>loadPage()</kbd>, and so on, are called from the HTML template directly associated with the <kbd>search-country</kbd> component. You can see it in the source code of the chapter from GitHub at <a href="https://github.com/PacktPublishing/Spring-5.0-Blueprints/tree/master/chapter04">https://github.com/PacktPublishing/Spring-5.0-Blueprints/tree/master/chapter04</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Angular template to show the country list</h1>
                </header>
            
            <article>
                
<p>Finally, we need an HTML template to render the country data on the screen. Each Angular component has one HTML template associated with a <kbd>@Component</kbd> decorator. For our first screen to show the list of countries, the HTML template looks as follows:</p>
<pre>&lt;form name="searchCountriesForm" novalidate (ngSubmit)="searchCountries()"&gt;<br/>    &lt;div class="container mb-5"&gt;<br/>        &lt;div class="row"&gt;<br/>            &lt;div class="col-6"&gt;<br/>                &lt;label class="form-control-label" <br/>                jhiTranslate="gdpApp.country.name" for="nameFilter"&gt;Name&lt;/label&gt; <br/>                &lt;input type="text" class="form-control" <br/>                name="nameFilter" id="nameFilter" [(ngModel)]="nameFilter" maxlength="52"/&gt;<br/>            &lt;/div&gt;<br/>            &lt;div class="col-4"&gt;<br/>                &lt;label class="form-control-label" jhiTranslate="gdpApp.country.continent"<br/>                for="continentFilter"&gt;Continent&lt;/label&gt;<br/>                &lt;select class="form-control" name="continentFilter" <br/>                    [(ngModel)]="continentFilter" id="continentFilter"&gt;<br/>                    &lt;option value=""&gt;<br/>                        {{'gdpApp.Continent.ALL' | translate}}&lt;/option&gt;<br/>                    &lt;option value="ASIA"&gt;<br/>                        {{'gdpApp.Continent.ASIA' | translate}}&lt;/option&gt;<br/>                    &lt;option value="EUROPE"&gt;<br/>                        {{'gdpApp.Continent.EUROPE' | translate}}&lt;/option&gt;<br/>                    &lt;option value="NORTH_AMERICA"&gt;<br/>                        {{'gdpApp.Continent.NORTH_AMERICA' | translate}}&lt;/option&gt;<br/>                    &lt;option value="AFRICA"&gt;<br/>                        {{'gdpApp.Continent.AFRICA' | translate}}&lt;/option&gt;<br/>                    &lt;option value="OCEANIA"&gt;<br/>                        {{'gdpApp.Continent.OCEANIA' | translate}}&lt;/option&gt;<br/>                    &lt;option value="ANTARCTICA"&gt;<br/>                        {{'gdpApp.Continent.ANTARCTICA' | translate}}&lt;/option&gt;<br/>                    &lt;option value="SOUTH_AMERICA"&gt;<br/>                        {{'gdpApp.Continent.SOUTH_AMERICA' | translate}}&lt;/option&gt;<br/>                &lt;/select&gt;<br/>            &lt;/div&gt;<br/>            &lt;div class="col-2 align-self-end"&gt;<br/>                &lt;label class="form-control-label" for="search-countries"&gt;&lt;/label&gt;<br/>                &lt;button type="submit" id="search-countries" class="btn btn-primary"&gt;<br/>                        &lt;fa-icon [icon]="'search'"&gt;&lt;/fa-icon&gt;&lt;span&gt;Search&lt;/span&gt;<br/>                &lt;/button&gt;<br/>            &lt;/div&gt; <br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>&lt;/form&gt; <br/>&lt;div class="table-responsive" *ngIf="countries"&gt;<br/>    &lt;table class="table table-striped"&gt;<br/>        &lt;thead&gt;<br/>        &lt;tr jhiSort [(predicate)]="predicate" <br/>                [(ascending)]="reverse" [callback]="transition.bind(this)"&gt;<br/>        &lt;th jhiSortBy="code"&gt;&lt;span jhiTranslate="gdpApp.country.code"&gt;<br/>                Code&lt;/span&gt; &lt;fa-icon [icon]="'sort'"&gt;&lt;/fa-icon&gt;&lt;/th&gt;<br/>        &lt;th jhiSortBy="name"&gt;&lt;span jhiTranslate="gdpApp.country.name"&gt;<br/>                Name&lt;/span&gt; &lt;fa-icon [icon]="'sort'"&gt;&lt;/fa-icon&gt;&lt;/th&gt;<br/>        &lt;th jhiSortBy="continent"&gt;&lt;span jhiTranslate="gdpApp.country.continent"&gt;<br/>                Continent&lt;/span&gt; &lt;fa-icon [icon]="'sort'"&gt;&lt;/fa-icon&gt;&lt;/th&gt;<br/>        &lt;th jhiSortBy="region"&gt;&lt;span jhiTranslate="gdpApp.country.region"&gt;<br/>                Region&lt;/span&gt; &lt;fa-icon [icon]="'sort'"&gt;&lt;/fa-icon&gt;&lt;/th&gt;<br/>        &lt;th jhiSortBy="surfaceArea"&gt;&lt;span jhiTranslate="gdpApp.country.surfaceArea"&gt;<br/>                Area&lt;/span&gt; &lt;fa-icon [icon]="'sort'"&gt;&lt;/fa-icon&gt;&lt;/th&gt;<br/>        &lt;th&gt;&lt;/th&gt;<br/>        &lt;/tr&gt;<br/>        &lt;/thead&gt;<br/>        &lt;tbody&gt;<br/>        &lt;tr *ngFor="let country of countries ;trackBy: trackId"&gt;<br/>            &lt;td&gt;{{country.code}}&lt;/td&gt;<br/>            &lt;td&gt;{{country.name}}&lt;/td&gt;<br/>            &lt;td jhiTranslate="{{'gdpApp.Continent.' + country.continent}}"&gt;<br/>                {{country.continent}}&lt;/td&gt;<br/>            &lt;td&gt;{{country.region}}&lt;/td&gt;<br/>            &lt;td&gt;{{country.surfaceArea}}&lt;/td&gt;<br/>            &lt;td class="text-right"&gt;<br/>                &lt;div class="btn-group flex-btn-group-container"&gt;<br/>                    &lt;button type="submit"<br/>                            [routerLink]="['/showGDP', country.id ]"<br/>                            class="btn btn-info btn-sm"&gt;<br/>                        &lt;fa-icon [icon]="'eye'"&gt;&lt;/fa-icon&gt;<br/>                        &lt;span class="d-none d-md-inline" <br/>                         jhiTranslate="entity.action.view"&gt;View GDP&lt;/span&gt;<br/>                    &lt;/button&gt;<br/>                &lt;/div&gt;<br/>            &lt;/td&gt;<br/>        &lt;/tr&gt;<br/>        &lt;/tbody&gt;<br/>    &lt;/table&gt;<br/>&lt;/div&gt;<br/>&lt;div *ngIf="countries &amp;&amp; countries.length"&gt;<br/>    &lt;div class="row justify-content-center"&gt;<br/>        &lt;jhi-item-count [page]="page" [total]="queryCount" <br/>            [itemsPerPage]="itemsPerPage"&gt;&lt;/jhi-item-count&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="row justify-content-center"&gt;<br/>        &lt;ngb-pagination [collectionSize]="totalItems" <br/>            [(page)]="page" [pageSize]="itemsPerPage" [maxSize]="5" [rotate]="true" <br/>            [boundaryLinks]="true" (pageChange)="loadPage(page)"&gt;&lt;/ngb-pagination&gt;<br/>    &lt;/div&gt;<br/>&lt;/div&gt;</pre>
<p>The HTML <kbd>form</kbd> is used to render the filtering options, with the country name as a text field and the continent as a drop-down menu. After the filter form, it shows the countries in a tabular format, with the pagination at the bottom. The last column of each row has a <span class="packt_screen">View</span> button, which opens the next screen using the <kbd>/showGDP</kbd> URL and passing the <kbd>id</kbd> of the current country. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Showing the GDP screen</h1>
                </header>
            
            <article>
                
<p>This screen shows the basic data of a selected country, along with the GDP data, in a graphical representation. We will use the World Bank API to fetch the information in a JSON format and supply it to a chart module to render a graph of the GDP data. This screen looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ff24ec52-92a5-4f89-8c02-abab43bf5ecd.png" style="width:65.75em;height:22.58em;"/></p>
<p>This screen uses the same service, router, and module artifacts that we created for the first screen, but will use a separate component and HTML template, as you will see in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An Angular component to show country GDP</h1>
                </header>
            
            <article>
                
<p>The <kbd>show-gdp</kbd> component takes the country data from the first screen, makes a call to the World Bank API, and fetches the data in a JSON format, before finally sending it to the chart module to render the graph. This component looks as follows:</p>
<pre>@Component({<br/>  selector: 'jhi-show-gdp',<br/>  templateUrl: './show-gdp.component.html',<br/>  })<br/>export class CountryGDPComponent implements OnInit {<br/>    currentCountry: ICountry;<br/>    data: IGdpData[];<br/>    preGDPUrl = 'http://api.worldbank.org/v2/countries/';<br/>    postGDPUrl = '/indicators/NY.GDP.MKTP.CD?format=json&amp;per_page=' + 10;<br/>    year = [];<br/>    gdp = [];<br/>    chart = [];<br/>    noDataAvailale: any;<br/>    constructor(<br/>        private activatedRoute: ActivatedRoute,<br/>        private httpClient: HttpClient<br/>    ) {<br/>        this.activatedRoute.data.subscribe(data =&gt; {<br/>            this.currentCountry = data.country;<br/>        });<br/>    }<br/>    ngOnInit() {<br/>        const gdpUrl = this.preGDPUrl + this.currentCountry.code <br/>                       + this.postGDPUrl;<br/>        this.httpClient.get(gdpUrl).subscribe(res =&gt; {<br/>            this.noDataAvailale = true;<br/>            const gdpDataArr = res[1];<br/>            if ( gdpDataArr ) {<br/>                this.noDataAvailale = false;<br/>                gdpDataArr.forEach(y =&gt; {<br/>                    this.year.push(y.date);<br/>                    this.gdp.push(y.value);<br/>                });<br/>                this.year = this.year.reverse();<br/>                this.gdp = this.gdp.reverse();<br/><br/>                this.chart = new Chart('canvas', {<br/>                    type: 'line',<br/>                    data: {<br/>                        labels: this.year,<br/>                        datasets: [<br/>                            {<br/>                            data: this.gdp,<br/>                            borderColor: '#3cba9f',<br/>                            fill: true<br/>                            }<br/>                        ]<br/>                    },<br/>                    options: {<br/>                    legend: {<br/>                        display: false<br/>                    },<br/>                    scales: {<br/>                        xAxes: [{<br/>                            display: true<br/>                        }],<br/>                        yAxes: [{<br/>                            display: true<br/>                        }],<br/>                      }<br/>                    }<br/>                });<br/>            }<br/>        });<br/>    }<br/>}</pre>
<p>In the constructor of this component, we are getting the selected country from the Angular router. In the <kbd>resolve()</kbd> method of the <kbd>CountryGDPResolve</kbd> class, we are fetching the country object from the <kbd>ID</kbd> parameter in the URL, and this object is then available to this component through the router, because we have provided a resolve configuration to this component in <kbd>countryGDPRoute</kbd>, as follows:</p>
<pre>    {<br/>        path: 'showGDP/:id',<br/>        component: CountryGDPComponent,<br/>        resolve: {<br/>            country: CountryGDPResolve<br/>        }<br/>    }</pre>
<p>Once we get the country information, we will make our calls to the World Bank API. The URL for this is as follows:</p>
<p><a href="http://api.worldbank.org/v2/countries/IND/indicators/NY.GDP.MKTP.CD?format=json&amp;per_page=10">http://api.worldbank.org/v2/countries/<strong>IND</strong>/indicators/NY.GDP.MKTP.CD?format=json&amp;per_page=10</a>.</p>
<p>In this URL, the country code is inserted dynamically, from the country data that is given by the router. The <kbd>per_page</kbd> attribute returns the GDP data for that many numbers of years. The preceding example shows the last ten years' worth of GDP data for the country India. After getting the JSON data, we are iterating and preparing two arrays, <kbd>year</kbd> and <kbd>gdp</kbd>, and passing them to the chart module to generate a chart on the screen. The chart module can be installed as a node module, with the <kbd>npm install chart.js</kbd> command.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Angular template to show country GDP</h1>
                </header>
            
            <article>
                
<p>Finally, the template for the <kbd>show-gdp</kbd> component will render the chart and show the country GDP data. The template looks as follows:</p>
<pre>&lt;div class="container"&gt;<br/>    &lt;h2 id="page-heading"&gt;<br/>        &lt;span&gt; GDP data for country &lt;b&gt;{{currentCountry.name}}&lt;/b&gt;&lt;/span&gt;<br/>    &lt;/h2&gt;<br/>    &lt;br/&gt;<br/>    &lt;div class="row"&gt;<br/>        &lt;div class="col-4"&gt;<br/>            &lt;dl class="row"&gt;<br/>                &lt;dt class="col-sm-4"&gt;Code&lt;/dt&gt;<br/>                &lt;dd class="col-sm-8"&gt;{{currentCountry.code}}&lt;/dd&gt;<br/>                &lt;dt class="col-sm-4"&gt;Name&lt;/dt&gt;<br/>                &lt;dd class="col-sm-8"&gt;{{currentCountry.name}}&lt;/dd&gt;<br/>                &lt;dt class="col-sm-4"&gt;Continent&lt;/dt&gt;<br/>                &lt;dd class="col-sm-8"&gt;{{'gdpApp.Continent.' + <br/>                    currentCountry.continent | translate }}&lt;/dd&gt;<br/>                &lt;dt class="col-sm-4"&gt;Region&lt;/dt&gt;<br/>                &lt;dd class="col-sm-8"&gt;{{currentCountry.region}}&lt;/dd&gt;<br/>                &lt;dt class="col-sm-4"&gt;Surface Area&lt;/dt&gt;<br/>                &lt;dd class="col-sm-8"&gt;{{currentCountry.surfaceArea}}&lt;/dd&gt;<br/>                &lt;dt class="col-sm-4"&gt;&lt;/dt&gt;<br/>                &lt;dd class="col-sm-8"&gt;<br/>                    &lt;div class="btn-group"&gt;<br/>                        &lt;button type="submit"<br/>                                [routerLink]="['/countries']"<br/>                                class="btn btn-info btn-sm"&gt;<br/>                            &lt;span class="d-none d-md-inline"&gt;Back&lt;/span&gt;<br/>                        &lt;/button&gt;<br/>                    &lt;/div&gt;<br/>                &lt;/dd&gt;<br/>            &lt;/dl&gt;<br/>        &lt;/div&gt;<br/>        &lt;div class="col-8"&gt;<br/>            &lt;div *ngIf="noDataAvailale"&gt;<br/>                GDP data for &lt;b&gt;{{currentCountry.name}}&lt;/b&gt; is not available<br/>            &lt;/div&gt; <br/>            &lt;div *ngIf="chart"&gt;<br/>                &lt;canvas id="canvas"&gt;{{ chart }}&lt;/canvas&gt;<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>&lt;/div&gt;</pre>
<p>It shows a few details about the selected country, followed by a placeholder for the chart. The <kbd>noDataAvailale</kbd> <span>variable </span>is used to show a message, in the case that there is no GDP data available for the selected country. It is set in the <kbd>show-gdp</kbd> component while making the World Bank API call.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hooking the GDP module into AppModule</h1>
                </header>
            
            <article>
                
<p>Everything is done now. Our GDP module is ready for execution. The last step is to plug it into the JHipster project structure. You have seen that a module is comprised of multiple artifacts, such as components, pipes, services, and routers. Multiple modules are grouped together to form an application.</p>
<p>Every Angular application has at least one module, known as a root module, and it is used to bootstrap the application. Usually, this module is known as <kbd>AppModule</kbd>, by convention. Since the frontend of our application is built on top of Angular, there is an <kbd>AppModule</kbd>. The <kbd>app.module.ts</kbd> file under the <kbd>/src/main/webapp/app</kbd> folder represents an <kbd>AppModule</kbd>.</p>
<p>We need to configure our custom module in <kbd>AppModule</kbd> to make it in action. This can be achieved by adding our module to the <kbd>imports</kbd> declaration under <kbd>@NgModule</kbd>, in the <kbd>app.module.ts</kbd> file, as follows:</p>
<pre>@NgModule({<br/>    imports: [<br/>        ....<br/>        GdpHomeModule,<br/>        GdpAccountModule,<br/>        // jhipster-needle-angular-add-module JHipster will add new module here<br/>        GdpEntityModule,<br/>        CountryGDPModule</pre>
<p>Upon adding entities into an application, JHipster generates a common module called <kbd>XXXEntityModule</kbd>, that holds the references of all the artifacts related to all entities. Soon after the entities are generated, JHipster adds this module entry to the import array inside of <kbd>@NgModule</kbd>. We have added another entry for the GDP module (<kbd>CountryGDPModule</kbd>). This is how any custom module can be plugged into <kbd>AppModule</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating navigation</h1>
                </header>
            
            <article>
                
<p>Our module is ready, and is also plugged into <kbd>AppModule</kbd>, to put it into action. However, one small thing is still missing, which is to locate the navigation to launch the GDP module. The best option is to put the navigation link into the navigation bar at the top of the page. JHipster provides a navigation bar as a separate module out of the box, and it shows various links. A few of them are publicly visible, and others are only for logged-in and <kbd>Admin</kbd> users.</p>
<p>To add the link, we need to modify the navigation template file, <kbd>navbar.component.html</kbd>, under the <kbd>/src/main/webapp/app/layouts/navbar</kbd> folder as follows:</p>
<pre>&lt;div class="navbar-collapse collapse" id="navbarResponsive" <br/>            [ngbCollapse]="isNavbarCollapsed" [ngSwitch]="isAuthenticated()"&gt;<br/>        &lt;ul class="navbar-nav ml-auto"&gt;<br/>            &lt;li class="nav-item" routerLinkActive="active" <br/>                [routerLinkActiveOptions]="{exact: true}"&gt;<br/>                &lt;a class="nav-link" routerLink="/" (click)="collapseNavbar()"&gt;<br/>                    &lt;span&gt;<br/>                        &lt;fa-icon icon="home"&gt;&lt;/fa-icon&gt;<br/>                        &lt;span jhiTranslate="global.menu.home"&gt;Home&lt;/span&gt;<br/>                    &lt;/span&gt;<br/>                &lt;/a&gt;<br/>            &lt;/li&gt;<br/>            <strong>&lt;li class="nav-item" routerLinkActive="active" </strong><br/><strong>                    [routerLinkActiveOptions]="{exact: true}"&gt;</strong><br/><strong>                &lt;a class="nav-link" routerLink="/countries" <br/>                        (click)="collapseNavbar()"&gt;</strong><br/><strong>                    &lt;span&gt;</strong><br/><strong>                        &lt;fa-icon icon="list"&gt;&lt;/fa-icon&gt;</strong><br/><strong>                        &lt;span&gt;Countries&lt;/span&gt;</strong><br/><strong>                    &lt;/span&gt;</strong><br/><strong>                &lt;/a&gt;</strong><br/><strong>            &lt;/li&gt;</strong><br/>          ....</pre>
<p>We have added HTML code, highlighted in bold, to show the <span class="packt_screen">Countries</span> menu item in the navigation bar. This looks as follows: </p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bfe81b78-3808-4a2a-8b98-6ec49ceea2f8.png" style="width:19.33em;height:2.25em;"/></p>
<p>The path for <kbd>routerLink</kbd> is defined as <span class="packt_screen">Countries</span>, which ultimately triggers the <kbd>t=the search-country</kbd> component to show the country list with the filter option on the first screen. This is how you can add custom screens in JHipster project. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other JHipster features</h1>
                </header>
            
            <article>
                
<p>So far, you have seen how to create fully-fledged and production-ready applications with JHipster. You have seen how to create entities and define a relationship between them. We <span>have </span>also added custom screens and developed various artifacts, so that you could learn how to add customized code to an application generated by the JHipster ecosystem.</p>
<p>These are some of the great features that not only make the developer's life easier, but also more productive, by automating lots of processes. We will look at these now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">IDE support</h1>
                </header>
            
            <article>
                
<p>At the beginning of this chapter, you saw how to create an application with the JHipster CLI by answering various questions. This is more than sufficient to start working with JHipster. However, to become more productive, it is recommended to use an IDE for development. JHipster supports a wide range of IDEs, including Eclipse, Visual Studio Code, IntelliJ IDEA, and so on. While working with an IDE (or a simple text editor), you need to make sure to exclude a certain folder from doing indexing, like <kbd>node_modules</kbd>, <kbd>build</kbd>, and <kbd>target</kbd>, to reduce the initial loading time of the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting screens out of the box</h1>
                </header>
            
            <article>
                
<p>JHipster provides several screens out of the box. Broadly, they can be categorized into three different groups, as follows:</p>
<ul>
<li>Home and login screens</li>
<li><span>Administration</span></li>
<li>Account management</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Home and login screens</h1>
                </header>
            
            <article>
                
<p>Upon starting, JHipster shows the home screen with a welcome message. This is the default home page and you can change it as per your application needs. In local development, by default, the<span> </span><kbd>dev</kbd><span> </span>profile is selected, so you will see a<span> </span><span class="packt_screen">development</span><span> </span>tab at the top-left corner. On the top section of the page, you will see a navigation menu. Without have logged in, it will show the following menu items:</p>
<ul>
<li><span class="packt_screen">Home</span>: A link to show a home page.</li>
<li><span class="packt_screen">Language</span>: This is conditional. This menu will be only visible if you have selected more than one language.</li>
<li><span class="packt_screen">Account</span>: This shows child menu items, such as <span class="packt_screen">Sign in</span><span> </span>and<span> </span><span class="packt_screen">Register</span>.</li>
</ul>
<p>Upon clicking on the<span> </span><span class="packt_screen">Sign in</span><span> </span>option, you will see a login page, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/42169da4-3411-4be0-a3f6-debe10692372.png" style="width:23.08em;height:23.50em;"/></p>
<p>This screen covers<span> </span><span class="packt_screen">Remember me</span>,<span> <span class="packt_screen">Did you forget</span></span> <span class="packt_screen">forget <span>your </span>password?</span><span>, </span>and<span> </span><span class="packt_screen">Register a new account</span><span> </span>features. The forgotten password feature requires email verification. For this, you need to configure SMTP with JHipster in the application properties file. By default, JHipster creates the following two users:</p>
<ul>
<li><strong>Administrator</strong>: <span class="packt_screen">Username<span>—</span></span><kbd>admin</kbd>, <span class="packt_screen">Password</span><span>—</span><kbd>admin</kbd>, <span class="packt_screen">role</span><span>—</span><kbd>admin</kbd>.</li>
<li><strong>User</strong>: <span class="packt_screen">Username</span><span>—</span><kbd>user</kbd>, <span class="packt_screen">Password</span><span>—</span><kbd>user</kbd>, <span class="packt_screen">role</span><span>—</span><kbd>user</kbd>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Account management</h1>
                </header>
            
            <article>
                
<p>JHipster facilitates login features out of the box. It also incorporates account management with this. The account screen provided by JHipster supports various actions in the form of child menus, as follows:</p>
<ul>
<li><strong>Settings</strong>: This screen allows for updating the user account details, such as the first and last name, email address, and language. The language drop-down menu shows all available languages in the system, which are configured during the creation of the application. </li>
<li><strong>Password</strong>: This screen is used to update the currently logged-in user's password.</li>
<li><strong>Registration</strong>: This screen is used to register new users into the system. It is only available when a user is not logged in. Soon after a user is created, an activation flow will be started, with an activation email and verification. The SMTP configuration needs to be done in the application properties for sending an email. Please note that if OAuth is selected as an authentication mechanism during the application creation, JHipster will not show this screen.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Administration</h1>
                </header>
            
            <article>
                
<p>Upon signing in with administrator credentials, you will see a navigation menu with the <span class="packt_screen">Administration</span> option. It covers various modules used to manage the whole application. It is useful for development, as well as monitoring the application.</p>
<p>It comprises various child menus, as described in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">User management</h1>
                </header>
            
            <article>
                
<p>This is a one-stop screen that's used to manage the registered users of the application. You can add a new user and modify, delete, or activate/deactivate existing users from this screen. It also shows the list of users with various attributes, such as <kbd>ID</kbd>, <kbd>username</kbd>, <kbd>email</kbd>, <kbd>Activate/Deactivate</kbd>, <kbd>Language</kbd>, <kbd>Roles</kbd>, <kbd>Created date</kbd>, <kbd>Modify by</kbd>, and <kbd>Modify date with pagination support</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Metrics</h1>
                </header>
            
            <article>
                
<p>JHipster provides various screens to analyze the performance of the application and other metrics, as follows:</p>
<ul>
<li><strong>JVM Metrics</strong>: This shows JVM-specific statistics, like memory utilization, thread counts, thread dump, and garbage collection details.</li>
<li><strong>HTTP requests</strong>: Aggregated details of HTTP requests, with their status code is shown for this metric.</li>
<li><strong>Service statistics</strong>: Details of the execution time of various <span>out-of-the-box and custom </span>services are shown here. It is useful to see the usage of various services.</li>
<li><strong>Cache statistics</strong>: The details of the entity cache are covered in this metric.</li>
<li><strong>DataSource statistics</strong>: The data source details will be shown here.</li>
</ul>
<p>The Refresh button is given to update the metrics with the latest value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Health</h1>
                </header>
            
            <article>
                
<p>This screen shows various pieces of information related to application health, such as the underlying database and disk space. It is used make decisions about data storage well in advance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuration</h1>
                </header>
            
            <article>
                
<p>This screen shows the current configuration applied to the application. It is especially useful for troubleshooting an application in case of any issue arising, or to check for the possibility of further performance improvement. It covers Spring Framework specific configurations, server configurations, system environment configurations, and application properties. Since this involves sensitive data, only the administrator can see it, by default.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Audit</h1>
                </header>
            
            <article>
                
<p>JHipster provides an audit log for user authentication. Since authentication is done by Spring Security in JHipster, it captures security-specific events specifically for authentication, and stores them in a database at the separate Spring data repository. They are useful from a security point of view. This screen shows all of this data in tabular format, with pagination.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logs</h1>
                </header>
            
            <article>
                
<p>This screen shows, various application log levels, such as <kbd>TRACE</kbd>, <kbd>DEBUG</kbd>, <kbd>INFO</kbd>, <kbd>WARN</kbd>, <kbd>ERROR</kbd>, and <kbd>OFF</kbd> at runtime, for classes and packages. It also allows for updating the log level for individual classes and packages. This is helpful while troubleshooting the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">API</h1>
                </header>
            
            <article>
                
<p>JHipster uses Swagger, a framework used to describe the structure of APIs. As you have seen, JHipster supports entity creation, and also exposes the REST API. It uses Swagger to document the entity REST API. JHipster also provides a user interface to interact with the API using sample data, and returns the output.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Maintaining code quality </h1>
                </header>
            
            <article>
                
<p>JHipster generates lots of boilerplate code while creating an application and entities. It follows best practices while generating the code, in order to maintain the quality. However, JHipster just creates the application code the first time, and the user must add custom code based on the business needs later on.</p>
<p>To maintain the code quality even after adding the customized code, JHipster allows analyzing the complete application code with Sonar—a tool designed specifically for monitoring code quality. The code is analyzed using <strong>SonarCloud</strong><em><span>—</span></em><span>the </span>cloud version of the Sonar. For this, you must commit the code in Git.</p>
<p>You also can analyze the code on a local Sonar server. For this, you must set up and run the Sonar server locally. The default port on which the Sonar server runs is <kbd>9000</kbd>, so you need to make sure that the Sonar port configured in <kbd>pom.xml</kbd> (if the build type is Maven) is the same. Execute the <kbd>mvnw test sonar:sonar</kbd> command, and you will see the code analysis in Sonar, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4c03dcee-921f-4fbc-9805-2cb2b2a2f6b5.png"/></p>
<p>This helps to maintain the code quality even after adding custom code to the application. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Microservice support</h1>
                </header>
            
            <article>
                
<p>In this chapter, we created a monolithic application using JHipster. However, it also allows users to create microservice-based applications. The microservice-based architecture splits the whole monolithic application (both the frontend and backend) into small and independent modular services. It is a unique way of doing software development that has grown rapidly in the last couple of years.</p>
<p>Each modular service can interact with other services through a unique and simple API. The microservice architecture has many advantages over a monolithic design, such as independent development and deployment, managing fail-over with ease, the fact that developers can work in the independent team, making continuous delivery, and so on. </p>
<p>Generally, a microservice architecture does not have any frontend layer, but JHipster supports a microservice gateway with a frontend to handle web traffic. It works as a proxy microservice for the end user. In short, a user can interact with a microservice through a gateway. The JHipster microservice model is comprised of one gateway service, one registry, and at least one or more microservice applications that we can create with JHipster with a backend code, which can be accessed with an API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Docker support</h1>
                </header>
            
            <article>
                
<p>Docker is an open source software platform that supports containers, making application deployment portable and self-contained. It is used to package the entire application (<span>including SQL and NoSQL databases, Sonar configuration, and so on</span>) and its dependencies together as a single container image, to deploy and test on any environment.</p>
<p>JHipster provides support for Docker out of the box for monolithic and microservice-based applications. Docker was developed for Linux, but has separate versions for macOS and Windows. JHipster only creates a Dockerfile at the time of application generation. The Dockerfile holds the set of instructions used by Docker containers to build a Docker image. </p>
<p>JHipster also supports pulling Docker images from the Docker Hub. This is an online registry that's used to publish public and private Docker images. This greatly helps in using third-party tools without <span>local </span>installation, as Docker images can be pulled and run on a local container.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Profile management</h1>
                </header>
            
            <article>
                
<p>The profile is a set of configurations for a specific environment, like development, testing, production, and so on. JHipster supports profile management, and comes with two profiles—<kbd>dev</kbd> and <kbd>prod</kbd>—out of the box. By default, it uses the <kbd>dev</kbd> profile. JHipster provides a separate application properties file for each profile.</p>
<p>In production, you need to enable the production profile with the <kbd>./mvnw -Pprod</kbd> <span>command </span>for Maven and the <kbd>./gradlew -Pprod</kbd> command for Gradle. If you need to export an executable WAR file in production, you can use the command <kbd>./mvnw -Pprod package</kbd> for Maven, and <kbd>./gradlew -Pprod package</kbd> for Gradle.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Live reload</h1>
                </header>
            
            <article>
                
<p>One of the most challenging factors in the software development process, in terms of time management, is recompiling the code, deploying it, and restarting the server to see the changes you made. Generally, the frontend code written in JavaScript does not require compilation, and can immediately reflect the changes upon browser refresh. Nevertheless, the latest frontend frameworks require some sort of transpilation after making changes in the script file.</p>
<p>In this situation, for any single code change, typically, you need to build, deploy, and restart the server. This will badly impact developer productivity. To avoid this, JHipster supports a mechanism called <strong>live reload</strong>. JHipster generates a Spring Boot-based application with the <kbd>DevTools</kbd> module to refresh the changes on the server without doing a cold restart. This is enabled by default, so whenever any Java code changes occur, it will automatically refresh them on the server. The live reloads for any frontend code can be achieved through <strong>BrowserSync</strong>, which can be started with the <kbd>npm start</kbd> command, and is accessible at <kbd>http://localhost:9000</kbd><em>.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing support</h1>
                </header>
            
            <article>
                
<p>Testing is an integral part of any software development process. It provides quality assurance of the application or product. While creating an application and entities, JHipster creates various automated unit test cases for both the frontend and backend (or the server side). </p>
<p>The server-side unit test cases are generated in the <kbd>/src/test/java</kbd> folder. They cover various layers of the application, such as the repository, service, security, REST API, and pagination. They are grouped in respective packages. You can run individual test cases from the IDE, or run all test cases from the Command Prompt with the <kbd>mvnw test</kbd> command. Make sure that you are in the application directory when you execute this command. In the case of Gradle, you will need to execute the <kbd>gradle test</kbd> command.</p>
<p>Frontend (or client-side) unit testing can be executed with the <kbd>npm test</kbd> command. This will execute various JavaScript test cases for the typescript residing in the <kbd>/src/test/javascript/spec</kbd> folder. JHipster also supports end-to-end client-side test cases with the Jest <span>framework, by default. Optionally, other frameworks, such as <strong>Gatling</strong>, <strong>Cucumber</strong>, and <strong>Protractor</strong>, can also be used for client-side end-to-end testing. </span> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Upgrading JHipster</h1>
                </header>
            
            <article>
                
<p>Unlike other frameworks, upgrading JHipster is a painless process. A subgenerator called <strong>JHipster upgrade</strong> is used to upgrade an existing application for the new version, without removing any custom changes that have been added since the application was created the first time. This is quite useful, especially when a new version of JHipster is released with known bug fixes and security patches. JHipster upgrades can be executed with the following command:</p>
<pre><strong>jhipster upgrade</strong></pre>
<p>To make the whole upgrade process automated, JHipster take the help of Git with the following steps:</p>
<ul>
<li>The preceding command checks whether a new version of JHipster is available, unless the <kbd>--force</kbd> flag is given explicitly. If this option is given, the upgrade sub-generator will be triggered, irrespective of the latest version being installed.</li>
<li>The whole upgrade process depends on Git, so if an application is not initialized with Git (if Git is not installed), JHipster will initialize Git and commit the current code to the master branch.</li>
</ul>
<ul>
<li>JHipster will check for any uncommitted local code. The upgrade process fails if the code is not committed. </li>
<li>Next, it will check if a <kbd>jhipster_upgrade</kbd> branch is available in Git. If not, this will be created. This branch is dedicated to the JHipster upgrade process, so it should never be updated manually.</li>
<li>JHipster will check out the <kbd>jhipster_upgrade</kbd> branch.</li>
<li>At this point, JHipster is upgraded with the latest version.</li>
<li>The current project directory is cleaned and the application is generated from scratch, with the entities.</li>
<li>The generated code will then <span>be </span>committed to the <kbd>jhipster_upgrade</kbd> branch.</li>
<li>Finally, the <kbd>jhipster_upgrade</kbd> branch will be merged with the original branch from which the <kbd>jhipster_upgrade</kbd> command was launched. </li>
<li>In the case of any conflicts, you will need to resolve and commit them manually.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Continuous integration support</h1>
                </header>
            
            <article>
                
<p>Automated testing <span>greatly </span>helps in making the system bug-free, even after adding new functionalities. JHipster creates unit and integration test cases for generated code that will be helpful up to some extent. In a real scenario, we need to add further unit test cases targeted for custom business implementations; for example, you might have added few custom screens, controller and service layer for which you need to write additional unit test cases. </p>
<p>Also, we need to add integration test cases for newly introduced APIs. Apart from that, we also need to add client-side test cases for frontend customization.</p>
<p>Presently, testing and continuous integration have become an integral part of the software development process. Testing will help to produce a quality product, while continuous integration is nothing but constantly merging and testing newly introduced code changes, which assists in identifying potential bugs. This happens with the combination of executing automated units, integration, and end-to-end test cases against the code. A classic example is triggering the automated test suite on every commit on Git; or, more efficiently, running it as per a predefined schedule.</p>
<p>The benefits of an automated testing model can be achieved by putting a continuous integration process in place, to make sure that new code changes do not introduce regressions to the stable version. This assures the merging of new changes and deploying to production with confidence.</p>
<p>The continuous testing, integration, and continuous deployment results in a concept called <strong>Continuous Integration/Continuous Deployment</strong> (<strong><span>CI/CD</span></strong>), which performs continuous integration, testing, and deploying the code. Continuous delivery can be achieved through various CI/CD tools. JHipster provides elegant support for well known CI/CD tools available in the market today, such as Jenkins, Travis CI, GitLab CI, and Circle CI.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Community support and documentation</h1>
                </header>
            
            <article>
                
<p>No matter how good a software framework or product is, its popularity comes from how easily users can get help from documentation and the community. JHipster has very nice documentation on their official site, which is more than sufficient to start working with it.</p>
<p>Apart from the official GitHub forum, there are plenty of other resources and forums available, in which you can easily get help with any issue or problem while working with JHipster. Additionally, the developers provide professional help in terms of answering questions on time and providing bug fixes as a priority. This really helps to attract developers and organizations to start to work with <span>JHipster</span>. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The JHipster Marketplace</h1>
                </header>
            
            <article>
                
<p>Who doesn't like to use reusable components or modules that fit business requirements? This would greatly save development time. As an open source software, the JHipster team not only produces a great masterpiece in the form of the framework, but also maintains a repository of reusable modules, called the <strong>Marketplace</strong>.</p>
<p>You can download various modules, as per your needs, and plug them directly in your application. You can contribute your module back to the Marketplace, so that other community users can get the benefit of that module. This is a great platform provided by JHipster to share a piece of reusable code with the community.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This has really been a great journey, exploring a new framework for building a powerful web application. JHipster is a really great tool for crafting a modern and production-ready application <span>in no time. With lots of things happening automatically, JHipster not only makes a developer's job easier, but also improves the overall project delivery schedule.</span></p>
<p>At the beginning of this chapter, we explored the basics of JHipster as a framework, along with an installation guide. Moving forward, you learned how JHipster generates application code with a question-and-answer approach. It uses another tool, called <strong>Yeoman</strong>, to generate application code. </p>
<p>Implementing domain objects as entities and supporting complete CRUD operations is t<span>he most important part of any application. In the next step, we learned how JHipster provides support for modeling domain objects through entity generation. Entity generation can be done with three options: the classic Yeoman-based option, the UML approach, and by using JDL-Studio. We have looked at all of them in detail. </span></p>
<p>After covering these features, we started to create an application to show GDP information by country. This required us to build custom screens, and we discovered how to add customization in an application generated with JHipster. We also collected a few details of generated code in various layers, including the persistence, service, REST controller, and frontend layer, which will help us to accommodate any future customization.</p>
<p>Towards the end, we looked at some unseen features that demonstrate what a robust platform JHipster is, and how it allows us to build a Spring-based, enterprise-grade application with ease. In the next chapter, you will learn how to create a Spring-based application with a microservice architecture, and how this is different and can be beneficial, as compared to a monolithic application.</p>


            </article>

            
        </section>
    </body></html>