<html><head></head><body>
<p class="calibre1">from the specified string, ignoring delimiters. </p>
<p class="calibre1">Scanner skip(Pattern</p>
<p class="calibre1">This method is almost the same as the previous one</p>
<p class="calibre1">pattern)</p>
<p class="calibre1">but gets Pattern as an argument instead of String. </p>
<p class="calibre1">String</p>
<p class="calibre1">Attempts to find the next occurrence of a pattern</p>
<p class="calibre1">findWithinHorizon(String</p>
<p class="calibre1">constructed from the specified string, ignoring</p>
<p class="calibre1">pattern, int horizon)</p>
<p class="calibre1">delimiters. </p>
<p class="calibre1">String</p>
<p class="calibre1">This method is almost the same as the previous one</p>
<p class="calibre1">findWithinHorizon(Pattern</p>
<p class="calibre1">but gets Pattern as an argument instead of String. </p>
<p class="calibre1">pattern, int horizon)</p>
<p class="calibre1"/>
<p class="calibre1">In addition to the two hasNext() methods mentioned in the preceding table using regular expression, the Scanner class also provides several overloaded hasNext methods that return true if the next available token in the input can be retrieved for that</p>
<p class="calibre1"><a id="p108"/>particular type. For example: hasNextInt(), hasNextDouble(), hasNextBoolean(), hasNextByte(), hasNextFloat(), hasNextLong(), hasNextShort(), hasNextBigInteger(), hasNextBigDecimal(), hasNext(). </p>
<p class="calibre1">Similarly, there are several overloaded next methods that scan the input to return the next token for that particular type. For example: nextextInt(), nextextDouble(), nextextBoolean(), nextextByte(), nextextFloat(), nextextLong(), nextextShort(), nextextBigInteger(), nextextBigDecimal(), nextext(). </p>
<p class="calibre1">For the complete reference of the Scanner class refer to</p>
<p class="calibre1">https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html. </p>
<p class="calibre1">Suppose there is an input text delimited by two exclamation marks. The data is structured in the following sequence:</p>
<p class="calibre1">animal!!id!!weight </p>
<p class="calibre1">The animal name is a string, id is an integer number, and weight is a double number. </p>
<p class="calibre1">With this structure, here is an example input:</p>
<p class="calibre1">Tiger!!123!!221.2!!Fox!!581!!52.50 </p>
<p class="calibre1">Given that there are two animals, here is how we can use the Scanner class to parse this input data in Java:</p>
<p class="calibre1">final String input = "Tiger!!123!!221.2!!Fox!!581!!52.50"; final int MAX_COUNT = 2; </p>
<p class="calibre1">String animal; </p>
<p class="calibre1">int id; </p>
<p class="calibre1">double weight; </p>
<p class="calibre1">Scanner scanner = new Scanner(input).useDelimiter("!!"); for (int i=0; i&lt;MAX_COUNT; i++) </p>
<p class="calibre1">{ </p>
<p class="calibre1">animal = scanner.next(); </p>
<p class="calibre1">id = scanner.nextInt(); </p>
<p class="calibre1">weight = scanner.nextDouble(); </p>
<p class="calibre1">System.out.printf("animal=[%s], id=[%d], weight=[%.2f]%n", animal, id, weight); </p>
<p class="calibre1">} </p>
<p class="calibre1">scanner.close(); </p>
<p class="calibre1">This is what is happening in this code:</p>
<p class="calibre1">new Scanner(input) is the code to construct a scanner using the input string scanner.useDelimiter("!!") sets the delimiter regular expression as "!!" </p>
<p class="calibre1">scanner.next() gets the next string token from the constructed scanner scanner.nextInt() gets the next int token from the scanner scanner.nextDouble() gets the next double token from the scanner scanner.close() closes the scanner object; we cannot generate further tokens from the scanner after this method call</p>
<p class="calibre1">As you can guess, we will get the following output from the preceding code: animal=[Tiger], id=[123], weight=[221.20] </p>
<p class="calibre1">animal=[Fox], id=[581], weight=[52.50] </p>
<p class="calibre1">Let's parse a more complex input data to understand the use of the Scanner class better. </p>
<p class="calibre1">Here is the complete code listing:</p>
<p class="calibre1">package example.regex; </p>
<p class="calibre1"><a id="p109"/>import java.util.*; </p>
<p class="calibre1">public class ScannerApi </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main (String[] args) </p>
<p class="calibre1">{  </p>
<p class="calibre1">final String str = "London:Rome#Paris:1234:Munich///Moscow"; Scanner scanner = new Scanner(str); </p>
<p class="calibre1">scanner.useDelimiter("\\p{Punct}+"); </p>
<p class="calibre1">final String cityPattern = "\\p{L}+"; </p>
<p class="calibre1">while(scanner.hasNext()) { </p>
<p class="calibre1">if(scanner.hasNext(cityPattern)) { </p>
<p class="calibre1">System.out.println(scanner.next()); </p>
<p class="calibre1">} </p>
<p class="calibre1">else { </p>
<p class="calibre1">scanner.next(); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">scanner.close(); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">This is what is happening in this code:</p>
<p class="calibre1">new Scanner(str) is the code to construct a scanner using the input string</p>
<p class="calibre1">* scanner.useDelimiter("\\p{Punct}+") sets the delimiter regular expression as one or more punctuation characters</p>
<p class="calibre1">We are using "\\p{L}+" as the acceptable city name pattern, which means one or more Unicode letters</p>
<p class="calibre1">scanner.hasNext(cityPattern) returns true if the next token from the scanner matches cityPattern</p>
<p class="calibre1">scanner.next() retrieves the next string token from the scanner scanner.close() closes the scanner object; we cannot generate further tokens from the scanner after this method call</p>
<p class="calibre1">Upon compiling and running the preceding code, it will produce the following output: London </p>
<p class="calibre1">Rome </p>
<p class="calibre1">Paris </p>
<p class="calibre1">Munich </p>
<p class="calibre1">Moscow </p>
<p class="calibre1"><a id="p110"/><b class="calibre3">Summary</b></p>
<p class="calibre1">In this chapter, you were introduced to Java programs using regular expressions using the String and Scanner classes. We discussed the methods available in these two APIs that are related to regular expression handling and how we can make use of those methods in our code. </p>
<p class="calibre1">In the next chapter, we will cover the Pattern and Matcher classes, which are the most important classes for programs using regular expressions. </p>
<p class="calibre1"><a id="p111"/><b class="calibre3">Introduction to Java Regular</b></p>
<p class="calibre1"><b class="calibre3">Expression APIs - Pattern</b></p>
<p class="calibre1"><b class="calibre3">and Matcher Classes</b></p>
<p class="calibre1">In this chapter, we will introduce you to dedicated Java APIs for writing programs using regular expressions. Java provides a package, java.util.regex, which contains all the classes and interfaces for handling regular expressions. This package is in the java.base module, so we do not explicitly declare its use in the module-info.java source file. The java.base module is automatically required by all modules, and it contains the most important and basic JDK packages and classes. Regular expressions is such an important topic and tool that Java 9 experts decided to keep it inside the java.base module. </p>
<p class="calibre1">We will cover the following classes and interfaces from this package: The MatchResult interface</p>
<p class="calibre1">Using Pattern class</p>
<p class="calibre1">Using Matcher class</p>
<p class="calibre1">Various methods of Pattern and Matcher classes and how to use them for solving problems involving regular expressions</p>
<p class="calibre1"><a id="p112"/><b class="calibre3">The MatchResult interface</b></p>
<p class="calibre1">MatchResult is an interface for representing the result of a match operation. This interface is implemented by the Matcher class. This interface contains query methods used to determine the results of a match against a regular expression. The match boundaries, groups, and group boundaries can only be retrieved but not modified through this interface. Here is a list of important methods provided in this interface: Method</p>
<p class="calibre1">Description</p>
<p class="calibre1">Name</p>
<p class="calibre1">int start()</p>
<p class="calibre1">Returns the start index of the match in the input</p>
<p class="calibre1">int start(int</p>
<p class="calibre1">Returns the start index of the specified capturing group</p>
<p class="calibre1">group)</p>
<p class="calibre1">int end()</p>
<p class="calibre1">Returns the offset after the last character matched</p>
<p class="calibre1">int end(int</p>
<p class="calibre1">Returns the offset after the last character of the subsequence group)</p>
<p class="calibre1">captured by the given group during this match</p>
<p class="calibre1">String</p>
<p class="calibre1">Returns the input substring matched by the previous match group()</p>
<p class="calibre1">String</p>
<p class="calibre1">Returns the input subsequence captured by the given group during group(int</p>
<p class="calibre1">the previous match operation</p>
<p class="calibre1">group)</p>
<p class="calibre1">int</p>
<p class="calibre1">Returns the number of capturing groups in this match result's groupCount()</p>
<p class="calibre1">pattern</p>
<p class="calibre1"/>
<p class="calibre1">Let's take an example to understand this interface better. </p>
<p class="calibre1">Suppose, the input string is a web server response line from HTTP response headers: HTTP/1.1 302 Found </p>
<p class="calibre1">Our regex pattern to parse this line is as follows:</p>
<p class="calibre1"><a id="p113"/>HTTP/1\.[01] (\d+) [a-zA-Z]+ </p>
<p class="calibre1">Note that there is only one captured group that captures integer status code. </p>
<p class="calibre1">Let's look at this code listing to understand the various methods of the MatchResult interface better:</p>
<p class="calibre1">package example.regex; </p>
<p class="calibre1">import java.util.regex.*; </p>
<p class="calibre1">public class MatchResultExample </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main(String[] args) </p>
<p class="calibre1">{ </p>
<p class="calibre1">final String re = "HTTP/1\\.[01] (\\d+) [a-zA-Z]+"; final String str = "HTTP/1.1 302 Found"; </p>
<p class="calibre1">final Pattern p = Pattern.compile(re); </p>
<p class="calibre1">Matcher m = p.matcher(str); </p>
<p class="calibre1">if (m.matches()) </p>
<p class="calibre1">{ </p>
<p class="calibre1">MatchResult mr = m.toMatchResult(); </p>
<p class="calibre1">// print count of capturing groups </p>
<p class="calibre1">System.out.println("groupCount(): " + mr.groupCount()); </p>
<p class="calibre1">// print complete matched text </p>
<p class="calibre1">System.out.println("group(): " + mr.group()); </p>
<p class="calibre1">// print start position of matched text </p>
<p class="calibre1">System.out.println("start(): " + mr.start()); </p>
<p class="calibre1">// print end position of matched text </p>
<p class="calibre1">System.out.println("end(): " + mr.end()); </p>
<p class="calibre1">// print 1st captured group </p>
<p class="calibre1">System.out.println("group(1): " + mr.group(1)); </p>
<p class="calibre1">// print 1st captured group's start position </p>
<p class="calibre1">System.out.println("start(1): " + mr.start(1)); </p>
<p class="calibre1">// print 1st captured group's end position </p>
<p class="calibre1">System.out.println("end(1): " + mr.end(1)); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">We retrieve a MatchResult instance after calling the required Pattern and Matcher methods (discussed in the next section). After compiling and running the preceding code, we will get the following output, which shows the use of the various methods of this interface:</p>
<p class="calibre1">groupCount(): 1 </p>
<p class="calibre1">group(): HTTP/1.1 302 Found </p>
<p class="calibre1">start(): 0 </p>
<p class="calibre1">end(): 18 </p>
<p class="calibre1">group(1): 302 </p>
<p class="calibre1">start(1): 9 </p>
<p class="calibre1">end(1): 12</p>
<p class="calibre1"><a id="p114"/><b class="calibre3">The Pattern class</b></p>
<p class="calibre1">The Pattern class represents the compiled form of a string regular expression. So far, we have provided all the regular expressions as strings. Each String regular expression must be compiled into an instance of the Pattern class before the Java regex engine can execute it. An instance of the Pattern class is used to create a Matcher object to match input text against the regular expression. </p>
<p class="calibre1">Let's list down the important and useful methods from the Pattern class first: Method Signature</p>
<p class="calibre1">Description</p>
<p class="calibre1">Static Pattern compile(String</p>
<p class="calibre1">Compiles the given String regular expression into a </p>
<p class="calibre1">regex)</p>
<p class="calibre1">Compiles the given String regular expression into a Pattern instance with the given flags. Flags can be one or more of </p>
<p class="calibre1">Static Pattern compile(String</p>
<p class="calibre1">CASE_SENSITIVE, UNICODE_CHARACTER_CLASS and a few others. Check the regex, int flags)</p>
<p class="calibre1">Java Pattern API at</p>
<p class="calibre1">http://download.java.net/java/jdk9/docs/api/java/util/regex/Pattern.html for all flags and their descriptions. </p>
<p class="calibre1">Matcher matcher(CharSequence</p>
<p class="calibre1">Creates a matcher instance to match the given input against this input)</p>
<p class="calibre1">compiled pattern. </p>
<p class="calibre1">Returns a literal pattern string for the specified string. After quoting the String, regex meta characters or escape sequences in the input string will just be literals without any special meaning. </p>
<p class="calibre1">String quote(String str)</p>
<p class="calibre1">the given string in \\Q and \\E escape constructs. These special escape constructs are used to make a wrapped string as a literal string, thus removing all the special meanings of regex meta and special characters. </p>
<p class="calibre1">asPredicate</p>
<p class="calibre1">Predicate&lt;String&gt; </p>
<p class="calibre1">()</p>
<p class="calibre1">Creates a Predicate of a string to match the input string. </p>
<p class="calibre1">Predicate&lt;String&gt; asPredicate ()</p>
<p class="calibre1">Stream&lt;String&gt; </p>
<p class="calibre1">Splits the given input string using this pattern and creates a stream splitAsStream(CharSequence</p>
<p class="calibre1">from the given input sequence around the matches of this pattern</p>
<p class="calibre1"><a id="p115"/>input)</p>
<p class="calibre1">(added in Java 8). </p>
<p class="calibre1">Splits the given input sequence around the matches of this pattern. It is String[] split(CharSequence input)</p>
<p class="calibre1">the same as String.split(String regex). </p>
<p class="calibre1">Splits the given input sequence around the matches of this pattern. The String[] split(CharSequence input, </p>
<p class="calibre1">limit parameter controls the number of times the pattern is applied and, int limit)</p>
<p class="calibre1">therefore, affects the length of the resulting array. It is the same as String.split(String regex, int limit). </p>
<p class="calibre1"/>
<p class="calibre1">The Pattern class has a static method that can be called to match a string against a regular expression. This is as follows:</p>
<p class="calibre1">boolean matches(String regex, CharSequence input) </p>
<p class="calibre1">It can be used instead of the following:</p>
<p class="calibre1">final Pattern p = Pattern.compile(regex); </p>
<p class="calibre1">Matcher m = p.matcher(input); </p>
<p class="calibre1">m.matches(); </p>
<p class="calibre1">This is actually the JDK9 implementation of this method. Although it is simpler and shorter to call this method instead of three lines, it is recommended to use the methods compile(), matcher(), and matches() separately if we perform matching against the same regular expression many times. In such a case, we can invoke compile() only the first time and keep the compiled pattern and avoid recompilation each time the matching is performed. </p>
<p class="calibre1"><a id="p116"/><img src="index-116_1.jpg" alt="Image 16" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Examples using the Pattern</b></p>
<p class="calibre1"><b class="calibre3">class</b></p>
<p class="calibre1">Let's look at a few examples to understand some of these methods. </p>
<p class="calibre1">To compile a regular expression for decimal numbers, we can use the following code snippet:</p>
<p class="calibre1">final String decimalPattern = "^[+-]?\\d*\\.?\\d+$"; Final Pattern pattern = Pattern.compile(decimalPattern); </p>
<p class="calibre1">The static method, Pattern.compile, compiles a string regex and returns a Pattern instance. </p>
<p class="calibre1">To match text between ## and ## that may include newlines as well, we can use the following compiled pattern:</p>
<p class="calibre1">final String re = "##.*?##"; </p>
<p class="calibre1">Final Pattern pattern = Pattern.compile(re, Pattern.DOTALL); Here, we are using two parameters: the Pattern.compile method and passing DOTALL as a flag in the second parameter, since we want to match the newline as well as using our lazy pattern .*?. </p>
<p class="calibre1"> <i class="calibre4">Note the use of lazy pattern .*? instead of greedy .* so that we match</i> <i class="calibre4">the shortest match between ## and ##. </i></p>
<p class="calibre1">We can also write the preceding code snippet using the inline mode modifier, (?s): final String re = "(?s)##.*?##"; </p>
<p class="calibre1">Final Pattern pattern = Pattern.compile(re); </p>
<p class="calibre1">If we want to match a string that contains a subsequence, +-*/., surrounded by one or more white spaces on both the sides, then we can use the following code: package example.regex; </p>
<p class="calibre1">import java.util.*; </p>
<p class="calibre1">import java.util.regex.*; </p>
<p class="calibre1">class PatternQuoteExample </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main (String[] args) </p>
<p class="calibre1">{ </p>
<p class="calibre1">String input = "Math operators: +-*/.   "; </p>
<p class="calibre1">boolean result; </p>
<p class="calibre1">String quoted = Pattern.quote("+-*/."); </p>
<p class="calibre1">System.out.println(quoted); </p>
<p class="calibre1">// regex using standard escaping </p>
<p class="calibre1">result = input.matches(".*\\s+\\+-\\*/\\.\\s+.*"); System.out.println(result); </p>
<p class="calibre1">// regex Using Pattern.quote around our search string </p>
<p class="calibre1">result = input.matches(".*\\s+" + quoted + "\\s+.*"); </p>
<p class="calibre1"><a id="p117"/>    System.out.println(result); </p>
<p class="calibre1">// regex Using \Q and \E around our search string </p>
<p class="calibre1">result = input.matches(".*\\s+\\Q+-*/.\\E\\s+.*"); System.out.println(result); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">After compiling and running this code, will quoted string as: "\Q+-*/.\E" and then print true for all the three cases as the call to matches succeeds all the times. However, an important difference is the use of Pattern.quote in the second case, which handles the quoting of special regex characters in the search string, such as +, *, . </p>
<p class="calibre1">Then, in the third case, we just wrap our search string using \\Q and \\E, which is the same as calling Pattern.quote with our search string. </p>
<p class="calibre1">To split an input text on two pipes or ||, we can use following code: package example.regex; </p>
<p class="calibre1">import java.util.*; </p>
<p class="calibre1">import java.util.regex.*; </p>
<p class="calibre1">class PatternSplitExample </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main (String[] args) </p>
<p class="calibre1">{ </p>
<p class="calibre1">final String input = "value1||value2||value3"; </p>
<p class="calibre1">final Pattern p = Pattern.compile(Pattern.quote("||")); </p>
<p class="calibre1">// call split and print each element from generated array </p>
<p class="calibre1">// using stream API </p>
<p class="calibre1">Arrays.stream(p.split(input)) </p>
<p class="calibre1">.forEach(System.out::println); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">Consider the following few points about this code:</p>
<p class="calibre1">We call Pattern.quote to avoid escaping double pipe string We call Pattern.compile to compile our string regex and get back a compiled Pattern object</p>
<p class="calibre1">We use a generated pattern instance to call the split method by supplying an input string that we want to operate on</p>
<p class="calibre1">Java 8 added a new method, splitAsStream, which returns a stream containing the substring from the given input sequence around the matches of this pattern. Using splitAsStream, we can simplify the preceding class as follows: package example.regex; </p>
<p class="calibre1">import java.util.*; </p>
<p class="calibre1">import java.util.regex.*; </p>
<p class="calibre1">class PatternSplitStreamExample  </p>
<p class="calibre1">{  </p>
<p class="calibre1">public static void main (String[] args) throws java.lang.Exception  </p>
<p class="calibre1">{  </p>
<p class="calibre1">final String input = "value1||value2||value3"; </p>
<p class="calibre1">final Pattern p = Pattern.compile(Pattern.quote("||")); </p>
<p class="calibre1">// call splitAsStream and print each element from generated stream p.splitAsStream(input) </p>
<p class="calibre1">.forEach(System.out::println); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">Note the use of the splitAsStream method instead of the Arrays.stream() static method</p>
<p class="calibre1"><a id="p118"/>in this class. Creating an array performs the whole split. When Pattern returns a stream, it can do the splitting only when it is needed. If we, for example, limit the stream to work up only the first 10 elements, then the splitting does not need to do the splitting for further elements. </p>
<p class="calibre1">It is true even if some of the implementations just do the splitting and return an array based stream from splitAsStream(). A different implementation of the JDK is free to use a better solution only if we use splitAsStream() but has no choice if we use split() and convert to stream afterward. </p>
<p class="calibre1"><a id="p119"/><b class="calibre3">Filtering a list of tokens</b></p>
<p class="calibre1"><b class="calibre3">using the asPredicate()</b></p>
<p class="calibre1"><b class="calibre3">method</b></p>
<p class="calibre1">As noted in the preceding table, the asPredicate() method creates a predicate that can be used to match an input string. Let's look at an example code listing to understand this method better:</p>
<p class="calibre1">package example.regex; </p>
<p class="calibre1">import java.util.List; </p>
<p class="calibre1">import java.util.stream.*; </p>
<p class="calibre1">import java.util.regex.*; </p>
<p class="calibre1">public class AsPredicateExample </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main(String[] args) </p>
<p class="calibre1">{ </p>
<p class="calibre1">final String[] monthsArr =  </p>
<p class="calibre1">{"10", "0", "05", "09", "12", "15", "00", "-1", "100"}; final Pattern validMonthPattern =  </p>
<p class="calibre1">Pattern.compile("^(?:0?[1-9]|1[00-2])$"); </p>
<p class="calibre1">List&lt;String&gt; filteredMonths = Stream.of(monthsArr) </p>
<p class="calibre1">.filter(validMonthPattern.asPredicate()) </p>
<p class="calibre1">.collect(Collectors.toList()); </p>
<p class="calibre1">System.out.println(filteredMonths); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">This code has a list of month numbers as an array of String. The valid months are between 1 and 12 with an optional 0 before the single-digit months. </p>
<p class="calibre1">We use the following regex pattern for a valid month number:</p>
<p class="calibre1">^(?:0?[1-9]|1[00-2])$ </p>
<p class="calibre1">We use the return value of the asPredicate() method to filter the stream of string array containing all the input month values. </p>
<p class="calibre1">After compiling and running, the preceding code will print the following output, which is a filtered list from the original list containing all the valid month numbers:</p>
<p class="calibre1">[10, 05, 09, 12] </p>
<p class="calibre1"><a id="p120"/><b class="calibre3">The Matcher class</b></p>
<p class="calibre1">An instance of the Matcher class performs various match operations on a character sequence by interpreting a compiled regular expression represented by an instance of Pattern. This is how we use this class to match a regex:</p>
<p class="calibre1">We create a matcher instance from a pattern by invoking the pattern's matcher method that requires the input sequence as argument</p>
<p class="calibre1">The instance of matcher is used to perform three types of match operations using these three methods, each returning a Boolean value (true indicates success): matches</p>
<p class="calibre1">find</p>
<p class="calibre1">lookingAt</p>
<p class="calibre1">These methods perform the matching in the following manner: The matches method attempts to match the  <i class="calibre4">complete input sequence</i> using the matcher's pattern</p>
<p class="calibre1">The find method  <i class="calibre4">searches</i> the input sequence for the next substring that matches the pattern</p>
<p class="calibre1">The lookingAt method attempts to match the input sequence using the matcher's pattern  <i class="calibre4">at the start position</i>. </p>
<p class="calibre1">Let's list down all the important methods from the Matcher class here: Method Signature</p>
<p class="calibre1">Description</p>
<p class="calibre1">Using the matcher's pattern attempts to find</p>
<p class="calibre1">boolean find()</p>
<p class="calibre1">the next matching substring of the input text. </p>
<p class="calibre1">This is the same as the previous, except that</p>
<p class="calibre1">boolean find(int start)</p>
<p class="calibre1">the search starts at the start position. </p>
<p class="calibre1">boolean matches()</p>
<p class="calibre1">Attempts to match the complete input text.. </p>
<p class="calibre1">Attempts to match the input text, starting at</p>
<p class="calibre1">boolean lookingAt()</p>
<p class="calibre1">the beginning of the region. It does not need to</p>
<p class="calibre1">match the complete input text. </p>
<p class="calibre1">Returns the complete input text matched by</p>
<p class="calibre1">String group()</p>
<p class="calibre1">the previous match. </p>
<p class="calibre1"><a id="p121"/>String group(int group)</p>
<p class="calibre1">Returns the input text captured by the</p>
<p class="calibre1">specified group number during the previous</p>
<p class="calibre1">match operation. </p>
<p class="calibre1">Returns the input text captured by the given</p>
<p class="calibre1">String group(String groupName)</p>
<p class="calibre1">named group during the previous match</p>
<p class="calibre1">operation. </p>
<p class="calibre1">Returns the number of capturing groups in this</p>
<p class="calibre1">int groupCount()</p>
<p class="calibre1">matcher's pattern. </p>
<p class="calibre1">Returns the start index of the previous match</p>
<p class="calibre1">int start()</p>
<p class="calibre1">operation. </p>
<p class="calibre1">Returns the start position of the text captured</p>
<p class="calibre1">int start(int group)</p>
<p class="calibre1">by the given group number during the</p>
<p class="calibre1">previous match operation. </p>
<p class="calibre1">Returns the start position of the text captured</p>
<p class="calibre1">int start(int groupName)</p>
<p class="calibre1">by the given named group during the previous</p>
<p class="calibre1">match operation. </p>
<p class="calibre1">Returns the end position of the previous match</p>
<p class="calibre1">int end()</p>
<p class="calibre1">operation. </p>
<p class="calibre1">Returns the end position of the text captured</p>
<p class="calibre1">int end(int group)</p>
<p class="calibre1">by the given group number during the</p>
<p class="calibre1">previous match operation. </p>
<p class="calibre1">Returns the end position of the text captured</p>
<p class="calibre1">int end(int groupName)</p>
<p class="calibre1">by the given named group during the previous</p>
<p class="calibre1">match operation. </p>
<p class="calibre1">Matcher</p>
<p class="calibre1">Appends the given replacement text to the</p>
<p class="calibre1">appendReplacement(StringBuffer</p>
<p class="calibre1">string buffer after the last character of the</p>
<p class="calibre1">buffer, String replacement)</p>
<p class="calibre1">previous match in the string buffer. </p>
<p class="calibre1">This method reads characters from the input</p>
<p class="calibre1">text, starting at the append position, and</p>
<p class="calibre1">appends them to the given string buffer. It is</p>
<p class="calibre1">StringBuffer</p>
<p class="calibre1">intended to be invoked after one or more</p>
<p class="calibre1">appendTail(StringBuffer buffer)</p>
<p class="calibre1">invocations of the appendReplacement method in</p>
<p class="calibre1"><a id="p122"/>order to copy the remainder of the input text to the buffer. </p>
<p class="calibre1">Returns a literal replacement String for the</p>
<p class="calibre1">Static String</p>
<p class="calibre1">specified String. It makes backslashes and</p>
<p class="calibre1">quoteReplacement(String s)</p>
<p class="calibre1">dollar signs to be treated literally. </p>
<p class="calibre1">Using the current matcher's pattern, it replaces</p>
<p class="calibre1">String replaceAll(String</p>
<p class="calibre1">all the matched substrings of the input text</p>
<p class="calibre1">replacement)</p>
<p class="calibre1">with the given replacement string. </p>
<p class="calibre1">Using the current matcher's pattern, it replaces</p>
<p class="calibre1">String replaceFirst(String</p>
<p class="calibre1">the first matched substring of the input text</p>
<p class="calibre1">replacement)</p>
<p class="calibre1">with the given replacement string. </p>
<p class="calibre1">Resets this matcher object and initializes all</p>
<p class="calibre1">Matcher reset()</p>
<p class="calibre1">the internal states. </p>
<p class="calibre1">Matcher reset(CharSequence</p>
<p class="calibre1">Resets this matcher object with a new input</p>
<p class="calibre1">input)</p>
<p class="calibre1">text and initializes all the internal states. </p>
<p class="calibre1">Returns the match result of the matcher that</p>
<p class="calibre1">represents state of the match. This method is</p>
<p class="calibre1">MatchResult toMatchResult()</p>
<p class="calibre1">usually called after one of the</p>
<p class="calibre1">find/matches/lookingAt method calls. </p>
<p class="calibre1">Matcher usePattern(Pattern</p>
<p class="calibre1">Updates the pattern used by this matcher to</p>
<p class="calibre1">newPattern)</p>
<p class="calibre1">find new matches. </p>
<p class="calibre1"><a id="p123"/><b class="calibre3">Examples using the Matcher</b></p>
<p class="calibre1"><b class="calibre3">class</b></p>
<p class="calibre1">The Matcher class represents the main regular expression engine in Java that provides all the functionality and features required to match regular expressions against input. </p>
<p class="calibre1">Let's look at some important methods of this class with practical examples to understand their use. </p>
<p class="calibre1"><a id="p124"/><b class="calibre3">Method Boolean lookingAt()</b></p>
<p class="calibre1">The lookingAt()method attempts to match the input against the pattern, starting from the  <i class="calibre4">beginning</i> of the input but without requiring that the entire region be matched against the pattern. The following code demonstrates it:</p>
<p class="calibre1">package example.regex; </p>
<p class="calibre1">import java.util.regex.*; </p>
<p class="calibre1">class MatcherLookingatExample </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main (String[] args) </p>
<p class="calibre1">{ </p>
<p class="calibre1">final Pattern pattern1 = Pattern.compile("master[a-z]*"); final Pattern pattern2 = Pattern.compile("master"); final Pattern pattern3 = Pattern.compile("regular"); String input = "mastering regular expressions"; Matcher matcher = pattern1.matcher(input); </p>
<p class="calibre1">System.out.printf("[%s] =&gt; [%s]: %s%n", input, matcher.pattern(), matcher.lookingAt()); </p>
<p class="calibre1">// update the matcher's pattern  with a new pattern </p>
<p class="calibre1">matcher.usePattern(pattern2); </p>
<p class="calibre1">System.out.printf("[%s] =&gt; [%s]: %s%n", input, matcher.pattern(), matcher.lookingAt()); </p>
<p class="calibre1">// update the matcher's pattern  with a new pattern </p>
<p class="calibre1">matcher.usePattern(pattern3); </p>
<p class="calibre1">System.out.printf("[%s] =&gt; [%s]: %s%n", input, matcher.pattern(), matcher.lookingAt()); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">Upon compiling and running, the preceding code produces following output:</p>
<p class="calibre1">[mastering regular expressions] =&gt; [master[a-z]*]: true </p>
<p class="calibre1">[mastering regular expressions] =&gt; [master]: true </p>
<p class="calibre1">[mastering regular expressions] =&gt; [regular]: false </p>
<p class="calibre1">You can see that the lookingAt()method returns true only when we supply patterns that are at the starting of the input, such as master[a-z]* and master, but returns false when we supply a pattern that is in the middle, such as regular. </p>
<p class="calibre1"><a id="p125"/><b class="calibre3">The matches() method</b></p>
<p class="calibre1">The matches() method attempts to match the entire region against the pattern and returns true only if the entire region matches against the pattern. </p>
<p class="calibre1">Let's look at the following code to understand the use of this method better: package example.regex; </p>
<p class="calibre1">import java.util.regex.*; </p>
<p class="calibre1">class MatcherMatchesExample </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main (String[] args) </p>
<p class="calibre1">{ </p>
<p class="calibre1">final Pattern pattern1 = Pattern.compile("mastering"); final Pattern pattern2 = Pattern.compile("mastering.*"); final Pattern pattern3 = Pattern.compile("regular.*"); String input = "mastering regular expressions"; Matcher matcher = pattern1.matcher(input); </p>
<p class="calibre1">System.out.printf("[%s] =&gt; [%s]: %s%n", input, matcher.pattern(), matcher.matches()); </p>
<p class="calibre1">// update the matcher ppattern  with a new pattern </p>
<p class="calibre1">matcher.usePattern(pattern2); </p>
<p class="calibre1">System.out.printf("[%s] =&gt; [%s]: %s%n", input, matcher.pattern(), matcher.matches()); </p>
<p class="calibre1">// update the matcher ppattern  with a new pattern </p>
<p class="calibre1">matcher.usePattern(pattern3); </p>
<p class="calibre1">System.out.printf("[%s] =&gt; [%s]: %s%n", input, matcher.pattern(), matcher.matches()); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">This will give following output after running:</p>
<p class="calibre1">[mastering regula expressions] =&gt; [mastering]: false </p>
<p class="calibre1">[mastering regula expressions] =&gt; [mastering.*]: true </p>
<p class="calibre1">[mastering regula expressions] =&gt; [regular.*]: false </p>
<p class="calibre1">As you can see, we get true only when our pattern matches the entire region from the start to end, which is using this regex: mastering.*</p>
<p class="calibre1"><a id="p126"/><b class="calibre3">The find() and find(int start)</b></p>
<p class="calibre1"><b class="calibre3">methods</b></p>
<p class="calibre1">These find methods attempt to find the next subsequence of the input sequence that matches the pattern. These methods return true only if a subsequence of the input matches this matcher's pattern. If multiple matches can be found in the text, then the find() method will find the first, and then for each subsequent call to find(), it will move to the next match. </p>
<p class="calibre1">An example code will make it clearer:</p>
<p class="calibre1">package example.regex; </p>
<p class="calibre1">import java.util.regex.*; </p>
<p class="calibre1">class MatcherFindExample </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main (String[] args) </p>
<p class="calibre1">{ </p>
<p class="calibre1">final String input = "some text &lt;value1&gt; anything &lt;value2&gt;&lt;value3&gt; here"; </p>
<p class="calibre1">/* Part 1 */ </p>
<p class="calibre1">final Pattern pattern = Pattern.compile("&lt;([^&lt;&gt;]*)&gt;"); Matcher matcher = pattern.matcher(input); </p>
<p class="calibre1">while (matcher.find()) { </p>
<p class="calibre1">System.out.printf("[%d] =&gt; [%s]%n", </p>
<p class="calibre1">matcher.groupCount(), matcher.group(1)); </p>
<p class="calibre1">} </p>
<p class="calibre1">/* Part 2 */ </p>
<p class="calibre1">// now use similar pattern but use a named group and reset the </p>
<p class="calibre1">// matcher </p>
<p class="calibre1">matcher.usePattern(Pattern.compile("&lt;(?&lt;name&gt;[^&lt;&gt;]*)&gt;")); matcher.reset(); </p>
<p class="calibre1">while (matcher.find()) { </p>
<p class="calibre1">System.out.printf("[%d] =&gt; [%s]%n", </p>
<p class="calibre1">matcher.groupCount(), matcher.group("name")); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">This will output the following:</p>
<p class="calibre1">[1] =&gt; [value1] </p>
<p class="calibre1">[1] =&gt; [value2] </p>
<p class="calibre1">[1] =&gt; [value3] </p>
<p class="calibre1">[1] =&gt; [value1] </p>
<p class="calibre1">[1] =&gt; [value2] </p>
<p class="calibre1">[1] =&gt; [value3] </p>
<p class="calibre1">As you can see in the preceding code, we are extracting all the text that is inside the angular brackets using a negated character class, [^&lt;&gt;]*, inside a capturing group. </p>
<p class="calibre1">In Part 1 of the code, we use regular captured group and matcher.group(1) to extract and print the subsequence captured in group number 1. The numbering of the groups starts each time we execute find() and the previous captures are wiped off. Even though it is in a loop, it is always group(1) in the example because for each iteration, there can be more than one group. </p>
<p class="calibre1"><a id="p127"/>In Part 2, we use a named capturing group and an overloaded method call to matcher.group("name") to extract the subsequence captured by the given group name. </p>
<p class="calibre1"><a id="p128"/><img src="index-128_1.jpg" alt="Image 17" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">The</b></p>
<p class="calibre1"><b class="calibre3">appendReplacement(StringBuffer</b></p>
<p class="calibre1"><b class="calibre3">sb, String replacement)</b></p>
<p class="calibre1"><b class="calibre3">method</b></p>
<p class="calibre1">This method is intended to be used in a loop together with the appendTail and find methods. Once we get a match using the find() method, we can call the appendReplacement() method to operate on each match and replace the matched text. </p>
<p class="calibre1">Finally, it appends the replaced text to StringBuffer. It reads characters from the input sequence, starting at the append position, and appends them to the given string buffer. </p>
<p class="calibre1">It stops after reading the last character preceding the previous match, that is, the character at index start() - 1. </p>
<p class="calibre1">The replacement string may contain references to subsequences captured during the previous match. All the rules of replacement reference we String.replaceAll apply to this method also. </p>
<p class="calibre1">The appendReplacement() method keeps track of what has been copied into StringBuffer, so we can keep searching for matches using find() in a loop, until no more matches are found in the input text. There will be an example following the next section. </p>
<p class="calibre1"> <i class="calibre4">Java 9 has another overloaded signature of this method to start</i> <i class="calibre4">accepting StringBuilder instead of StringBuffer as the first parameter. </i></p>
<p class="calibre1"><a id="p129"/><img src="index-129_1.jpg" alt="Image 18" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">The</b></p>
<p class="calibre1"><b class="calibre3">appendTail(StringBuffer sb)</b></p>
<p class="calibre1"><b class="calibre3">method</b></p>
<p class="calibre1">This method reads characters from the input sequence, starting at the append position, and appends them to the given string buffer. It is intended to be invoked after one or more invocations of the appendReplacement method in order to copy the remainder of the input sequence. </p>
<p class="calibre1"> <i class="calibre4">Just like in the case of the appendReplacement() method, there is also an</i> <i class="calibre4">overloaded version of the appendTail() method that accepts</i> <i class="calibre4">StringBuilder, which is not synchronized, instead of StringBuffer, which</i> <i class="calibre4">is synchronized. </i></p>
<p class="calibre1"><a id="p130"/><b class="calibre3">Example of the</b></p>
<p class="calibre1"><b class="calibre3">appendReplacement and</b></p>
<p class="calibre1"><b class="calibre3">appendTail methods</b></p>
<p class="calibre1">Let's look at a complete program to the understand use of these methods. </p>
<p class="calibre1">Consider the following input:</p>
<p class="calibre1">&lt;n1=v1 n2=v2 n3=v3&gt; n1=v1 n2=v2 abc=123 &lt;v=pq id=abc&gt; v=pq We need to write code to swap each name-value pair enclosed in angular brackets, &lt; and &gt;, while leaving the name-value pairs outside the angular brackets unchanged. </p>
<p class="calibre1">After running our code, it should produce the following output:</p>
<p class="calibre1">&lt;v1=n1 v2=n2 v3=n3&gt; n1=v1 n2=v2 abc=123 &lt;pq=v abc=id&gt; v=pq To solve this problem, we have to first find each match enclosed in angular brackets using the find method in a loop. Inside the loop, we will have to replace each name-value pair using the appendReplacement method. Finally, outside the loop, we will use the appendTail method to append the remaining characters after our last match. </p>
<p class="calibre1">Here is the full code:</p>
<p class="calibre1">package example.regex; </p>
<p class="calibre1">import java.util.regex.*; </p>
<p class="calibre1">class MatcherAppendExample </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main (String[] args) </p>
<p class="calibre1">{ </p>
<p class="calibre1">final String input = "&lt;n1=v1 n2=v2 n3=v3&gt; n1=v1 n2=v2 abc=</p>
<p class="calibre1">123 &lt;v=pq id=abc&gt; v=pq"; </p>
<p class="calibre1">// pattern1 to find all matches between &lt; and &gt; </p>
<p class="calibre1">final Pattern pattern = Pattern.compile("&lt;[^&gt;]+&gt;"); </p>
<p class="calibre1">// pattern1 to find each name=value pair  </p>
<p class="calibre1">final Pattern pairPattern = Pattern.compile("(\\w+)=(\\w+)"); Matcher enclosedPairs = pattern.matcher(input); </p>
<p class="calibre1">StringBuilder sbuf = new StringBuilder(); </p>
<p class="calibre1">// call find in a loop and call appendReplacement for each match while (enclosedPairs.find())  </p>
<p class="calibre1">{ </p>
<p class="calibre1">Matcher pairMatcher = pairPattern.matcher(enclosedPairs.group()); </p>
<p class="calibre1">// replace name=value with value=name in each match  </p>
<p class="calibre1">enclosedPairs.appendReplacement(sbuf, </p>
<p class="calibre1">pairMatcher.replaceAll("$2=$1")); </p>
<p class="calibre1">} </p>
<p class="calibre1">// appendTail to append remaining character to buffer   </p>
<p class="calibre1">enclosedPairs.appendTail(sbuf); </p>
<p class="calibre1">System.out.println(sbuf); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1"><a id="p131"/>Upon compiling and running, the preceding code will produce the following output:</p>
<p class="calibre1">&lt;v1=n1 v2=n2 v3=n3&gt; n1=v1 n2=v2 abc=123 &lt;pq=v abc=id&gt; v=pq As you can see, the final output has all the name=value pairs swapped inside the angular brackets. </p>
<p class="calibre1"><a id="p132"/><b class="calibre3">Summary</b></p>
<p class="calibre1">In this chapter, you learned about the most important regular expression handling Java classes. The Matcher and Pattern classes are heavy and complex tools that can be used to get really far when it comes to string manipulation. We have seen an example of a compound task, transforming name-value pairs inside a string, enclosed between angular brackets. If you imagine how hard it would have been without regular expressions and these classes, then you realize the power you now have in your hand after this chapter; it is almost wizard-level. </p>
<p class="calibre1">In the next chapter, we will move on to advanced topics of regular expressions, such as zero-width assertions, using the lookahead and lookbehind assertions, atomic groups, and so on. </p>
<p class="calibre1"><a id="p133"/><b class="calibre3">Exploring Zero-Width</b></p>
<p class="calibre1"><b class="calibre3">Assertions, Lookarounds, </b></p>
<p class="calibre1"><b class="calibre3">and Atomic Groups</b></p>
<p class="calibre1"/>
<p class="calibre1">You will learn about zero-width assertions in Java regular expressions. We will cover various zero-width assertions and their usage patterns. We will then move on to learn the important topic of lookahead and lookbehind assertions in Java regular expressions and how to use them to solve some important problems. We will also discuss the use of atomic groups in Java regular expressions. </p>
<p class="calibre1">We will cover the following topics in this chapter:</p>
<p class="calibre1">Zero-width assertions</p>
<p class="calibre1">Previous match boundary</p>
<p class="calibre1">Atomic groups</p>
<p class="calibre1">Lookahead assertions: positive and negative</p>
<p class="calibre1">Lookbehind assertions: positive and negative</p>
<p class="calibre1">Capturing text from overlapping matches</p>
<p class="calibre1">Capturing groups inside lookahead and lookbehind groups</p>
<p class="calibre1">Lookbehind limitations in Java regular expressions</p>
<p class="calibre1"><a id="p134"/><img src="index-134_1.jpg" alt="Image 19" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Zero-width assertions</b></p>
<p class="calibre1">Zero-width or zero-length assertion in regular expressions means that there is a zero-length match that does not change the current position of the pointer in the input string. These assertions do not consume characters in the string but only assert whether a match is possible or not, giving us a binary true or false match result. </p>
<p class="calibre1">Although many zero-width assertions are denoted inside parentheses, like groups, we will soon see that they do not capture any text. Zero-width assertions have no real meaning in back-references or in replacements. </p>
<p class="calibre1"> <i class="calibre4">We have already discussed a few zero-width assertions in the previous</i> <i class="calibre4">chapters, such as anchors and boundary assertions. </i></p>
<p class="calibre1">The Java regular expression engine allows many predefined zero-width assertions, including the ones we have discussed already, such as start, end anchors, and word boundaries. </p>
<p class="calibre1"><a id="p135"/><b class="calibre3">Predefined zero-width</b></p>
<p class="calibre1"><b class="calibre3">assertions</b></p>
<p class="calibre1">Zero-width</p>
<p class="calibre1">Description</p>
<p class="calibre1">Assertion</p>
<p class="calibre1">\b</p>
<p class="calibre1">Asserts a word boundary</p>
<p class="calibre1">\B</p>
<p class="calibre1">Asserts anywhere except at a word boundary</p>
<p class="calibre1">^</p>
<p class="calibre1">Asserts position only at the beginning of a line</p>
<p class="calibre1">$</p>
<p class="calibre1">Asserts position only at the end of a line</p>
<p class="calibre1">\A</p>
<p class="calibre1">Asserts position only at the beginning of a string</p>
<p class="calibre1">\z</p>
<p class="calibre1">Asserts position only at the end of a string</p>
<p class="calibre1">Asserts position only at the end of a string or before the line break</p>
<p class="calibre1">\Z</p>
<p class="calibre1">at the end of a string (if present)</p>
<p class="calibre1">Asserts position at the end of the previous match or at the start of</p>
<p class="calibre1">\G</p>
<p class="calibre1">the string for the very first match</p>
<p class="calibre1"><a id="p136"/><b class="calibre3">Regex defined zero-width</b></p>
<p class="calibre1"><b class="calibre3">assertions</b></p>
<p class="calibre1">Regex defined zero-width assertions use ( and ) and there is a ? after the opening (. </p>
<p class="calibre1">There are two assertions: positive, denoted by the = character, and negative, denoted by the ! character. If the assertion is backward-looking then the ? character is followed by a &lt; character. Thus, (?=...) is a positive lookahead assertion and (?&lt;!...) is a negative lookbehind assertion. </p>
<p class="calibre1">The positive lookahead assertion ensures that the string matches the pattern after the current position. For example, abc(?=K) ensures that (?=pattern)</p>
<p class="calibre1">the characters "abc" in the checked strings are followed by the letter</p>
<p class="calibre1">"K", but this check does not consume the character "K". </p>
<p class="calibre1">The negative lookahead assertion ensures that the string does not match the pattern after the current position. For example, abc(?!Z) (?!pattern)</p>
<p class="calibre1">ensures that the characters "abc" in the checked string are not followed by the letter "Z", but this check does not consume the character "Z". </p>
<p class="calibre1">The positive lookbehind assertion ensures that the string matches the (? </p>
<p class="calibre1">pattern before the current position. For example, (?&lt;=P)abc ensures</p>
<p class="calibre1">&lt;=pattern)</p>
<p class="calibre1">that the characters "abc" in the checked string are preceded by the letter "P", but this check does not consume the character "P". </p>
<p class="calibre1">The negative lookbehind assertion ensures that the string does not match the pattern before the current position. For example, (?&lt;!Q)abc (? </p>
<p class="calibre1">ensures that the characters " </p>
<p class="calibre1">&lt;!pattern)</p>
<p class="calibre1">abc" in the checked string are not</p>
<p class="calibre1">preceded by the letter "Q", but this check does not consume the character "Q". </p>
<p class="calibre1"/>
<p class="calibre1">In the next section, we will look into more details of the \G boundary assertions, and then, you will learn about the lookahead and lookbehind assertions. However, before the lookarounds, we will discuss atomic groups, which are an important construct and topic to ease the understanding of the behavior of the lookahead and lookbehind assertions. </p>
<p class="calibre1"><a id="p137"/><b class="calibre3">\G boundary assertion</b></p>
<p class="calibre1">\G is a zero-width assertion. It is also a boundary matcher that asserts positions at the end of the previous match or at the start of the string, such as the \A assertion for the very first match. The Java regex engine remembers the position of \G within the context of a Matcher instance. If Matcher is instantiated again or is reset, then the position of \G is also initialized to the start of the string. </p>
<p class="calibre1">For example, consider the following input:</p>
<p class="calibre1">,,,,,123,45,67 </p>
<p class="calibre1">Consider that we need to replace every comma that occurs only at the start of the input with a hyphen so that we have the same number of hyphens as the number of commas at the start. Our final output should be the following:</p>
<p class="calibre1">-----123,45,67 </p>
<p class="calibre1">We cannot just do replaceAll by matching each comma, since that will also replace the comma after 123 and 45, and moreover, we want the same number of hyphens as the number of commas in the input string. </p>
<p class="calibre1">For cases like this, we can use the \G assertion and use this Java code snippet: input = input.replaceAll("\\G,", "-"); Since \G matches the start of the line the first time, it will assert the position just before the first comma. Subsequently, it matches the positions after each comma, since \G matches the positions at the end of the previous match. It will stop matching when the control reaches the digit 1. Each of these matches is replaced by a single hyphen, thus giving us the same number of hyphens in the replaced string as the number of leading commas in the original input. </p>
<p class="calibre1">Let's look at another full example to understand the use of \G better. </p>
<p class="calibre1">Here is a sample input:</p>
<p class="calibre1">{%var1%, %var2%, %var3%} {%var4%, %var5%, %var6%} </p>
<p class="calibre1">Our task is to replace the % characters with the # (hash) characters in the first {...}</p>
<p class="calibre1">section only. We can assume that { and } are perfectly balanced. The expected output is as follows:</p>
<p class="calibre1">{#var1#, #var2#, #var3#} {%var4%, %var5%, %var6%} </p>
<p class="calibre1">Note how the output has % replaced with # in only the first pair of {...}. </p>
<p class="calibre1">Here is a code listing to solve this problem:</p>
<p class="calibre1">package example.regex; </p>
<p class="calibre1">class GBoundaryMatcher </p>
<p class="calibre1">{</p>
<p class="calibre1">public static void main (String[] args)</p>
<p class="calibre1">{  </p>
<p class="calibre1">String input = "{%var1%, %var2%, %var3%} " + </p>
<p class="calibre1">"{%var4%, %var5%, %var6%}"; </p>
<p class="calibre1">final String re = "(^[^{]*\\{|\\G(?!^),\\h*)%([^%]+)%"; </p>
<p class="calibre1"><a id="p138"/>    // now use above regex in replaceAll method String repl = input.replaceAll(re, "$1#$2#"); </p>
<p class="calibre1">System.out.println(repl); </p>
<p class="calibre1">}</p>
<p class="calibre1">} </p>
<p class="calibre1">Here is how this regex is doing the job in this code. </p>
<p class="calibre1">We use this regex to match our pattern:</p>
<p class="calibre1">"(^[^{]*\\{|\\G(?!^),\\h*)%([^%]+)%" </p>
<p class="calibre1">The preceding regex has two groups, as follows:</p>
<p class="calibre1">(^[^{]*\\{|\\G(?!^),\\h*)</p>
<p class="calibre1">This is the captured group number one. We are using alternation to select two possible patterns here:</p>
<p class="calibre1">^[^{]*\\{: This matches all text up to the first { from the start. </p>
<p class="calibre1">\\G(?!^),\\h*: This matches text from the end of the previous match followed by a comma and zero or more horizontal whitespaces. (?!^) is a negative lookahead to avoid matching \G at the start position. This is needed because \G also successfully asserts the start of the input string in the first use. </p>
<p class="calibre1">The %([^%]+)% pattern is our captured group number two. It is the substring surrounded by the % characters. </p>
<p class="calibre1">In the replacement, we use the following:</p>
<p class="calibre1">$1#$2# </p>
<p class="calibre1">This basically puts back the first group's captured text and wraps the second captured group in # instead of % to get the required output. </p>
<p class="calibre1">Once we compile and run the preceding code, it shows the following output:</p>
<p class="calibre1">{#var1#, #var2#, #var3#} {%var4%, %var5%, %var6%}</p>
<p class="calibre1"><a id="p139"/><img src="index-139_1.jpg" alt="Image 20" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Atomic groups</b></p>
<p class="calibre1">An atomic group is a non-capturing group that throws away all the alternative positions remembered by any token inside the group when the matching process exits the group after the first match of the pattern inside the group. Thus, it avoids backtracking to attempt all the alternatives present in the group. </p>
<p class="calibre1">Here is the syntax:</p>
<p class="calibre1">(?&gt;regex) </p>
<p class="calibre1">Here, the regex may contain alternative patterns. On the other hand, a non-atomic group will allow backtracking; it will try to find the first match and then if the matching ahead fails, it will backtrack and try to find the next match in alternation, until a match for the entire expression is found or all the possibilities are exhausted. </p>
<p class="calibre1">To understand it better, let's take an example of a regular expression using a non-atomic group:</p>
<p class="calibre1">^foo(d|die|lish)$</p>
<p class="calibre1">The input string here is foodie. </p>
<p class="calibre1">It will match the starting pattern foo and then the first alternative d. It fails at this time because the end anchor, $, requires that we must be at the end of the input string, but we still have two characters, i and e, to be matched. Then, the engine attempts to match the second alternative die. This match operation succeeds, as the $ anchor asserts true since the input ends there and stops matching further with a successful match returned. </p>
<p class="calibre1"> <i class="calibre4">Even if we use a non-capturing group instead of a capturing group</i> <i class="calibre4">here to make it ^foo(?:d|die|lish)$, it will have the same effect while</i> <i class="calibre4">matching. </i></p>
<p class="calibre1">Now, take an example of the same regular expression using an <b class="calibre3">atomic group</b>:</p>
<p class="calibre1">^foo(?&gt;d|die|lish)$ </p>
<p class="calibre1">Note the use of ?&gt; after ( to make it an atomic non-capturing group. </p>
<p class="calibre1">Let's see what happens when we apply the preceding regex against the same input string, that is, foodie. </p>
<p class="calibre1">It will match the starting pattern, foo, and then its first alternative, d. It fails because the $ anchor asserts false since the input does not end at food. However, because of the use of the atomic group, the regex engine gives up immediately and doesn't backtrack. </p>
<p class="calibre1">Since the regex engine throws away all the alternative positions remembered inside the atomic group, it does not attempt to match the second alternative die, which would have been a successful match for a non-atomic group. Finally, this match operation fails with no match. </p>
<p class="calibre1">You need to remember a simple but important fact that the alternation tries its alternatives from left to right and always attempts to complete the match using the</p>
<p class="calibre1"><a id="p140"/><img src="index-140_1.jpg" alt="Image 21" class="calibre2"/></p>
<p class="calibre1">leftmost alternative. Therefore, whenever listing all the options in an alternation, it is good practice to place the longest matches first and then use the other alternatives to place shorter matches. </p>
<p class="calibre1">Using this principle, we can make some small changes to our atomic group to make it work. </p>
<p class="calibre1">Here is the working regex:</p>
<p class="calibre1"/>
<p class="calibre1">^foo(?&gt;lish|die|d)$ </p>
<p class="calibre1">We have the same input string, foodie. </p>
<p class="calibre1">Note that we have the same alternatives in this atomic group but with a different order. Since d is a prefix of die, we are placing the die alternative on the left-hand side of d so that the regex engine can first attempt to match foodie before attempting food. </p>
<p class="calibre1">Here is the full code listing running these examples:</p>
<p class="calibre1"/>
<p class="calibre1">package example.regex; </p>
<p class="calibre1">class AtomicGroupExample </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main (String[] args) </p>
<p class="calibre1">{ </p>
<p class="calibre1">final String input = "foodie"; </p>
<p class="calibre1">// regex with non-atomic group </p>
<p class="calibre1">final String nonAtomicRegex = "foo(d|die|lish)"; </p>
<p class="calibre1">// regex with an atomic group </p>
<p class="calibre1">final String atomicRegex = "foo(?&gt;d|die|lish)"; </p>
<p class="calibre1">// regex with an alternate atomic group with correct order final String atomicRegexImproved = "foo(?&gt;lish|die|d)"; </p>
<p class="calibre1">// now execute all 3 regex against same input </p>
<p class="calibre1">System.out.printf("%s: %s%n", </p>
<p class="calibre1">nonAtomicRegex, input.matches(nonAtomicRegex)); </p>
<p class="calibre1">System.out.printf("%s: %s%n", </p>
<p class="calibre1">atomicRegex, input.matches(atomicRegex)); </p>
<p class="calibre1">System.out.printf("%s: %s%n", </p>
<p class="calibre1">atomicRegexImproved , input.matches(atomicRegexImproved)); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">After compiling and running the code, it will generate the following output: foo(?:d|die|lish): true </p>
<p class="calibre1">foo(?&gt;d|die|lish): false </p>
<p class="calibre1">foo(?&gt;lish|die|d): true </p>
<p class="calibre1"> <i class="calibre4">Since the atomic group prevents the regex engine from backtracking by</i> <i class="calibre4">exiting from the evaluation of all the alternatives inside the group, the</i> <i class="calibre4">atomic group usually provides a significant gain in performance while</i> <i class="calibre4">evaluating a largely sized text with multiple options in alternation. </i></p>
<p class="calibre1"><a id="p141"/><b class="calibre3">Lookahead assertions</b></p>
<p class="calibre1">Positive and negative lookahead assertions are zero-width assertions that allow for certain regular expression-based checks to be performed on the text that is ahead (or on the right-hand side) of the current position. The regex engine holds on to the current position after evaluating the lookahead pattern. We can chain multiple lookahead expressions one after another, but the regex engine does not move the control after checking all the lookaheads. Lookahead assertions can help solve some complex regex problems, which are not possible or are very difficult to solve without lookahead support. The Java regular expression engine, like many other regular expression flavors, allows the use of variable-length quantifiers such as * and + in lookahead patterns. </p>
<p class="calibre1">There are two types of lookahead assertions: positive lookahead and negative lookahead. </p>
<p class="calibre1"><a id="p142"/><b class="calibre3">Positive lookahead</b></p>
<p class="calibre1">A positive lookahead assertion asserts true if the pattern inside the lookahead is matched. </p>
<p class="calibre1">The following is its syntax:</p>
<p class="calibre1">(?=...) </p>
<p class="calibre1">For example, \d+(?=##) asserts that there must be a string, ##, immediately after matching one or more digits. </p>
<p class="calibre1"><a id="p143"/><b class="calibre3">Negative lookahead</b></p>
<p class="calibre1">A negative lookahead assertion asserts true if the pattern inside the lookahead is not matched. </p>
<p class="calibre1">The following is its syntax:</p>
<p class="calibre1">(?!...) </p>
<p class="calibre1">For example, abc(?!xyz) asserts that there cannot be a string, xyz, immediately after matching the string abc. </p>
<p class="calibre1"><a id="p144"/><b class="calibre3">Lookbehind assertions</b></p>
<p class="calibre1">Positive and negative lookbehind assertions are zero-width assertions that allow for certain regex-based checks to be performed on the text that precedes (or is on the left-hand side) of the current position. The regex engine holds on to the current position after evaluating the lookbehind pattern. We can chain multiple lookbehind expressions one after another, but the regex engine does not move the control after checking all the lookbehind assertions. Lookbehind assertions can also help solve some complex problems that are not possible or are very difficult to solve without lookbehind support. Up to Java version 8, the Java regular expression engine didn't allow the use of variable-length quantifiers such as * and + in lookbehind patterns. </p>
<p class="calibre1">With Java 9, the Java regex engine now allows the use of these quantifiers in lookbehind assertions. </p>
<p class="calibre1">There are two types of lookbehind assertions: positive lookbehind and negative lookbehind. </p>
<p class="calibre1"><a id="p145"/><b class="calibre3">Positive lookbehind</b></p>
<p class="calibre1">A positive lookbehind assertion asserts true if the pattern inside the lookbehind is matched. </p>
<p class="calibre1">Here is its syntax:</p>
<p class="calibre1">(?&lt;=...) </p>
<p class="calibre1">For example, (?&lt;=##)\d+ asserts that there must be a ## string just before matching one or more digits. </p>
<p class="calibre1"><a id="p146"/><b class="calibre3">Negative lookbehind</b></p>
<p class="calibre1">A negative lookbehind assertion asserts true if the pattern inside the lookbehind is not matched. </p>
<p class="calibre1">Here is its syntax:</p>
<p class="calibre1">(?&lt;!...) </p>
<p class="calibre1">For example, (?&lt;!xyz)abc asserts that there cannot be the string, xyz, just before matching the string, abc. </p>
<p class="calibre1">Here are a few important points about lookaround regex patterns: Lookaround patterns are atomic. Like atomic groups, once a lookaround pattern is matched, the regex engine exits immediately from that lookaround, returning just a true or false assertion. </p>
<p class="calibre1">Lookaround patterns don't move from the current position. All patterns are evaluated from the current position. The position remains the same after the lookaround assertions are completed. </p>
<p class="calibre1">If a regular expression uses multiple lookaround assertions next to each other, then the order of those expressions is not important. </p>
<p class="calibre1">Lookaround patterns are usually used in complex input validations, for splitting the input before or after the specified patterns, and for finding overlapping matches. </p>
<p class="calibre1">Let's look at some examples to understand the use of lookahead and lookbehind expressions. </p>
<p class="calibre1">To match an integer number with one or more digits that doesn't allow all zeroes, we can use the following:</p>
<p class="calibre1">^(?!0+$)\d+$ </p>
<p class="calibre1">(?!0+$) is a negative lookahead expression that will assert failure if we have one or more zeroes till the end, ahead of the current position, which is the start of the input string in our example. </p>
<p class="calibre1">Given an input text with @ characters, we need to match @ only if there is a word character at the next position. We can use a positive lookahead regex here, as follows:</p>
<p class="calibre1">@(?=\w) </p>
<p class="calibre1">Here, (?=\w) means a positive lookahead that asserts true when there is a word character next to @. </p>
<p class="calibre1">To match an input string that doesn't allow the string zzz anywhere, we can use a negative lookahead such as this:</p>
<p class="calibre1">^(?!.*zzz) </p>
<p class="calibre1">To match a dot that is not followed or preceded by a digit, we can use negative lookahead and negative lookbehind conditions, as follows:</p>
<p class="calibre1"><a id="p147"/>(?&lt;!\d)\.(?!\d) </p>
<p class="calibre1">Here, we are using two assertions:</p>
<p class="calibre1">(?&lt;!\d) is a negative lookbehind condition that asserts that there is no digit preceding a dot</p>
<p class="calibre1">(?!\d) is a negative lookahead condition that asserts that there is no digit following a dot</p>
<p class="calibre1">This will match the dot in ip.address, .net, and abc. but won't match the dot in 25.78, 12., and .987. </p>
<p class="calibre1">Next, we need to match an input that must not contain the repetition of the @, #, or %</p>
<p class="calibre1">characters. </p>
<p class="calibre1">We will need to use a negative lookahead pattern that contains a capturing group and a back-reference to check repetition:</p>
<p class="calibre1">^(?!.*([@#%])\1) </p>
<p class="calibre1">(?!.*([@#%])\1) is a negative lookahead assertion that matches and captures the given special characters in the first capturing group. Using back-reference \1, we check duplication of the captured character. The pattern inside the negative lookahead .*</p>
<p class="calibre1">([@#%])\1 makes sure that we don't have a duplicated @, #, or % character at any position ahead of the current position. </p>
<p class="calibre1">Now, suppose that we need to find a search term in a long text with the following conditions:</p>
<p class="calibre1">1.  The search term is at the start or preceded by a whitespace. </p>
<p class="calibre1">2.  The search term is at the end or followed by a whitespace. </p>
<p class="calibre1">3.  The search term may contain non-word characters as well. </p>
<p class="calibre1">To solve this, we can use a regular expression with a positive lookahead and a positive lookbehind like this:</p>
<p class="calibre1">(?&lt;=^|\h)searchTerm(?=\h|$) </p>
<p class="calibre1">Here, (?&lt;=^|\h) is a positive lookbehind that asserts that the search term is at the start position or is preceded by a horizontal whitespace. </p>
<p class="calibre1">(?=\h|$) is a positive lookahead that asserts that the search term is at the end position or is followed by a horizontal whitespace. </p>
<p class="calibre1">Match a string containing one or more word characters but doesn't allow any of the characters to repeat. </p>
<p class="calibre1">To solve this problem, we need to use a capturing group, back-reference, and a negative lookahead like this:</p>
<p class="calibre1">^(?:(\w)(?!.*\1))+$ </p>
<p class="calibre1">Here, we are matching and capturing each character in the first captured group. Each word character is asserted by a negative lookahead (?!.*\1), where \1 is the backreference of the first captured group. The negative lookahead (?!.*\1) asserts that we don't have another occurrence of the captured character in the string ahead. Finally, we wrap the whole expression in a non-capturing group to be able to use the quantifier</p>
<p class="calibre1">+ to match one or more word non-repeating characters. </p>
<p class="calibre1"><a id="p148"/>Suppose we need to scan a line of text and place a colon in every third position from right to left. However, we should not place a colon at the start position. </p>
<p class="calibre1">This should convert abcd into a:bcd and 123456 will be converted to 123:456, but abc must not become :abc. </p>
<p class="calibre1">To solve this, we can use a lookahead regex, as in this code listing: package example.regex; </p>
<p class="calibre1">import java.util.regex.*; </p>
<p class="calibre1">class LookAroundExample1 </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main (String[] args) </p>
<p class="calibre1">{ </p>
<p class="calibre1">final String[] inputs = </p>
<p class="calibre1">{"abcd98732", "pqrn", "qwerty12345678xyz", "123"}; final Pattern p = Pattern.compile("(?!^)(?=(.{3})+$)"); for (String s: inputs) </p>
<p class="calibre1">{ </p>
<p class="calibre1">Matcher m = p.matcher(s); </p>
<p class="calibre1">System.out.printf("%s =&gt; %s%n", s, m.replaceAll(":")); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">After running this code, we'll get the following output:</p>
<p class="calibre1">abcd98732 =&gt; abc:d98:732 </p>
<p class="calibre1">pqrn =&gt; p:qrn </p>
<p class="calibre1">qwerty12345678xyz =&gt; qw:ert:y12:345:678:xyz </p>
<p class="calibre1">123 =&gt; 123 </p>
<p class="calibre1">As you can see, this code places a colon in every third position, going from right to left. Let's see what happens during the matching of the regular expression: (?!^) is a negative lookahead to avoid matching at the position. </p>
<p class="calibre1">(?=(.{3})+$) is a positive lookahead that finds all the positions that have one or more three-character sets, ahead of the current position. This will first match the position where the first : has to be inserted, then the second, and so on. This may at first seem like something contradicting with atomic groups and the non-backtracking behaviour of a lookahead group. But it essentially is not. It is not contradicting because the lookahead itself is not backtracking. The regular expression matching is backtracking and evaluates the lookahead assertion again and again for each and every character position. </p>
<p class="calibre1">Now, suppose that we have to replace all the commas that are outside the innermost parentheses with a semi-colon, assuming all the parentheses are balanced, not nested, and unescaped in the input text. </p>
<p class="calibre1">To solve this problem, we can use a negative lookahead expression, such as this one:</p>
<p class="calibre1">,(?![^()]*\)) </p>
<p class="calibre1">This one matches a comma followed by a negative lookahead assertion that asserts false when we have a right ) following zero or more characters and not containing (</p>
<p class="calibre1">and ). Since we know that ( and ) are balanced, this check ensures that we match a comma that is outside ( and ). </p>
<p class="calibre1">Here is the full code listing to see this regex in action: package example.regex; </p>
<p class="calibre1">import java.util.regex.*; </p>
<p class="calibre1"><a id="p149"/>class LookAroundExample2 </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main (String[] args) </p>
<p class="calibre1">{ </p>
<p class="calibre1">String input = "var1,var2,var3 (var1,var2,var3) var4,var5,var6 (var4,var5,var6)"; final Pattern p = Pattern.compile(",(?![^()]*\\))"); Matcher m = p.matcher(input); </p>
<p class="calibre1">System.out.printf("%s%n", m.replaceAll(";")); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">When we run the preceding code, it gives the following output, replacing all the commas outside the parentheses:</p>
<p class="calibre1">var1;var2;var3 (var1,var2,var3) var4;var5;var6 (var4,var5,var6) Next, suppose that we need to validate a password string with the following constraints:</p>
<p class="calibre1">At least one uppercase English letter</p>
<p class="calibre1">At least one lowercase English letter</p>
<p class="calibre1">At least one digit</p>
<p class="calibre1">At least one special character (non-word character)</p>
<p class="calibre1">Minimum six and maximum twelve in length</p>
<p class="calibre1">No whitespace allowed anywhere</p>
<p class="calibre1">Here is the solution:</p>
<p class="calibre1">To check for six to twelve non-whitespace characters, we can use the following:</p>
<p class="calibre1">^\S{6,12}$ </p>
<p class="calibre1">For the remaining conditions, we need to use multiple lookahead expressions, one for each condition. Let's build the lookahead patterns one by one. </p>
<p class="calibre1">To ensure that there is at least one uppercase letter in the input, we can use this lookahead assertion:</p>
<p class="calibre1">(?=.*[A-Z]) </p>
<p class="calibre1">This means that we have to check for the presence of an uppercase letter after zero or more characters. </p>
<p class="calibre1">Similarly, to ensure that there is at least one lowercase letter in the input, we can use this lookahead assertion:</p>
<p class="calibre1">(?=.*[a-z]) </p>
<p class="calibre1">Similarly, to ensure there is at least one digit in the input, we can use the following: (?=.*\d) </p>
<p class="calibre1">Similarly, to ensure there is at least one non-word character in the input, we can use the following:</p>
<p class="calibre1">(?=.*\W) </p>
<p class="calibre1">As mentioned earlier, the order of these lookahead patterns does not matter, so we keep them in any order in our regular expression. Putting it all together, our final regular expression will be as follows:</p>
<p class="calibre1">^(?=.*[A-Z])(?=.*[a-z])(?=.*\d)(?=.*\W)\S{6,12}$ </p>
<p class="calibre1"><a id="p150"/>Here is the full Java code to make this regex work: package example.regex; </p>
<p class="calibre1">import java.util.regex.*; </p>
<p class="calibre1">class LookAroundPasswordValidation </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main (String[] args) </p>
<p class="calibre1">{ </p>
<p class="calibre1">// build a Pattern using our regex </p>
<p class="calibre1">final Pattern p = Pattern.compile( </p>
<p class="calibre1">"^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*\\W)\\S{6,12}$" ); </p>
<p class="calibre1">// input strings to be tested against our regex </p>
<p class="calibre1">String[] inputs = { "abZ#45", "$$$f5P###", "abc123", "xyz-7612", </p>
<p class="calibre1">"AbC@#$qwer", "xYz@#$ 1278" }; </p>
<p class="calibre1">for (String s: inputs) </p>
<p class="calibre1">{ </p>
<p class="calibre1">Matcher m = p.matcher( s ); </p>
<p class="calibre1">System.out.printf( "%s =&gt; %s%n", s, m.matches() ); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">After compiling and running this code, we will get the following output: abZ#45 =&gt; true </p>
<p class="calibre1">$$$f5P### =&gt; true </p>
<p class="calibre1">abc123 =&gt; false </p>
<p class="calibre1">xyz-7612 =&gt; false </p>
<p class="calibre1">AbC@#$qwer =&gt; false </p>
<p class="calibre1">xYz@#$1278 =&gt; false </p>
<p class="calibre1">This output basically shows a true value for all the strings that pass all our password rules and false, otherwise. </p>
<p class="calibre1"><a id="p151"/><b class="calibre3">Capturing text from</b></p>
<p class="calibre1"><b class="calibre3">overlapping matches</b></p>
<p class="calibre1">Lookahead patterns are also very useful for situations where we want to match and capture text from overlapping matches. </p>
<p class="calibre1">Let's consider the following input string as an example:</p>
<p class="calibre1">thathathisthathathatis </p>
<p class="calibre1">Suppose that we need to count the occurrence of the string, that, in this input, including all overlapping occurrences. </p>
<p class="calibre1">Note that there are three independent that substrings in the input string, but there are two additional overlapping matches that we need to match and count. Here are the start-end positions of overlapping the substring that:</p>
<p class="calibre1">Positions 0-3 3-6 10-13 13-16 16-19 </p>
<p class="calibre1">A simple search using the regex that will give us a match count of three because we miss out all the overlapping matches. To be able to match the overlapping matches, we need to use the lookahead pattern because lookahead patterns are zero-length. </p>
<p class="calibre1">These patterns don't consume any characters; they just assert the presence of the required text ahead, based on the patterns used inside the lookahead, and the current position doesn't change. So, the solution is to use a lookahead regex as follows: (?=that) </p>
<p class="calibre1">Here is the full code to see this regex working in action: package example.regex; </p>
<p class="calibre1">import java.util.regex.Matcher; </p>
<p class="calibre1">import java.util.regex.Pattern; </p>
<p class="calibre1">class LookaheadOverlapping </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main (String[] args) </p>
<p class="calibre1">{ </p>
<p class="calibre1">final String kw = "that"; </p>
<p class="calibre1">final String regex = "(?=" + kw+ ")"; final String string = "thathathisthathathatis"; final Pattern pattern = Pattern.compile(regex); </p>
<p class="calibre1">final Matcher matcher = pattern.matcher(string); </p>
<p class="calibre1">int count = 0; while (matcher.find()) </p>
<p class="calibre1">{ </p>
<p class="calibre1">System.out.printf("Start: %d\tEnd:%d%n", </p>
<p class="calibre1">matcher.start(), matcher.start() + kw.length() -1); </p>
<p class="calibre1">count++; </p>
<p class="calibre1">} </p>
<p class="calibre1">System.out.printf("Match count: %d%n", count); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">Once we run and compile the preceding class, we will get the following output: Start: 0 End:3 </p>
<p class="calibre1">Start: 3 End:6 </p>
<p class="calibre1">Start: 10 End:13 </p>
<p class="calibre1">Start: 13 End:16 </p>
<p class="calibre1">Start: 16 End:19 </p>
<p class="calibre1">Match count: 5</p>
<p class="calibre1"><a id="p152"/>You can see from this output that all the Start, End positions of the overlapping matches and, more importantly, the count of the overlapping matches, which is 5. </p>
<p class="calibre1">Here is another code listing that finds all the three character strings that have 'a' as the middle letter and the same word character before and after the letter 'a'. For example, bab, zaz, kak, dad, 5a5, and _a_ should be matched:</p>
<p class="calibre1">package example.regex; </p>
<p class="calibre1">import java.util.regex.Matcher; </p>
<p class="calibre1">import java.util.regex.Pattern; </p>
<p class="calibre1">class LookaheadOverlappingMatches </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main(String[] args) </p>
<p class="calibre1">{ </p>
<p class="calibre1">final String regex = "(?=(\\w)a\\1)"; </p>
<p class="calibre1">final String string = "5a5akaktjzazbebbobabababsab"; final Matcher matcher = Pattern.compile(regex) </p>
<p class="calibre1">.matcher(string); </p>
<p class="calibre1">int count = 0; while (matcher.find()) </p>
<p class="calibre1">{ </p>
<p class="calibre1">final int start = matcher.start(); </p>
<p class="calibre1">final int end = start + 2; </p>
<p class="calibre1">System.out.printf("Start: %2d\tEnd:%2d %s%n", </p>
<p class="calibre1">start, end, string.substring(start,end+1)); </p>
<p class="calibre1">count++; </p>
<p class="calibre1">} </p>
<p class="calibre1">System.out.printf("Match count: %d%n", count); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">This code generates the following output:</p>
<p class="calibre1">Start: 0 End: 2 5a5 </p>
<p class="calibre1">Start: 4 End: 6 kak </p>
<p class="calibre1">Start: 9 End:11 zaz </p>
<p class="calibre1">Start: 17 End:19 bab </p>
<p class="calibre1">Start: 19 End:21 bab </p>
<p class="calibre1">Start: 21 End:23 bab </p>
<p class="calibre1">Match count: 6 </p>
<p class="calibre1"><a id="p153"/><b class="calibre3">Be careful with capturing</b></p>
<p class="calibre1"><b class="calibre3">groups inside a lookahead or</b></p>
<p class="calibre1"><b class="calibre3">lookbehind atomic group</b></p>
<p class="calibre1">You learned to use capturing groups inside lookahead or lookbehind patterns in the preceding examples. However, you must remember that lookaround expressions are zero-width atomic groups. The regex engine exits from these groups as soon as an assertion is evaluated to true or false. Due to this fact, there is no backtracking inside these groups. </p>
<p class="calibre1">Consider the following three regular expressions. The first one is without any lookahead or atomic group, the second regex uses a lookahead expression, and the third regex uses an atomic group. Note that in each of the regex patterns, we use a capturing group to match and capture zero or more word characters inside the outer group:</p>
<p class="calibre1">#(?:(\w*))\w*_\1 </p>
<p class="calibre1">#(?=(\w*))\w*_\1 </p>
<p class="calibre1">#(?&gt;(\w*))\w*_\1 </p>
<p class="calibre1">Suppose that we apply the preceding three regex patterns against the following input:</p>
<p class="calibre1">#abc_abc </p>
<p class="calibre1">The first regex, #(?:(\w+)).*_\1, will find a successful match with group 1 as "abc". </p>
<p class="calibre1">Next, it matches _ and back-references \1 to complete the match. Since the capturing group (\w*) initially matches the complete input, "abc_abc", the regex engine backtracks multiple times to make this a successful match. </p>
<p class="calibre1">The second regex will fail to match because (\w+) inside the lookahead will match and capture "abc_abc", and when the regex engine exits the lookahead group, it is not able to find a match with .*_\1, as there is no further input and the engine won't backtrack to complete the match like it does in the first regex. </p>
<p class="calibre1">The third regex with an atomic group will also fail to match due to the same reason; the regex engine won't backtrack after matching the string inside an atomic group. </p>
<p class="calibre1"><a id="p154"/><b class="calibre3">Lookbehind limitations in</b></p>
<p class="calibre1"><b class="calibre3">Java regular expressions</b></p>
<p class="calibre1">Like many other regular expression engines, the Java regex engine does not allow a variable-length text without an obvious maximum length match in the lookbehind regex pattern. This means that we cannot use the * or + quantifiers in a lookbehind pattern. However, the Java regex engine allows for limited or finite repetition in a lookbehind regex. This gives us a workaround for doing so in Java regular expressions by using limiting quantifiers in lookbehind expressions. </p>
<p class="calibre1">This means that we cannot use the following lookbehind regex to check filenames ending with extensions:</p>
<p class="calibre1">(?&lt;=\w\.\w+)$ </p>
<p class="calibre1">However, we could change the preceding pattern to the following with a finite repetition, and now this pattern will be allowed by the Java regex engine: (?&lt;=\w\.\w{1,99})$ </p>
<p class="calibre1">However, it limits the number of word characters in the lookbehind after the dot to be from 1 to 99 instead of open-ended one or more word characters, as is the case with the</p>
<p class="calibre1">+ quantifier. However, you should use such a feature with caution and check the performance of the resulting regular expression. The Java lookbehind implementation also had quite a few bugs in the earlier versions. Some of these bugs have been resolved but one can still get unexpected results while using complex lookbehind regular expressions in Java. </p>
<p class="calibre1">Java 9, however, allows regex patterns without an obvious maximum-length restriction in lookbehind assertions. This will allow programmers to use the lookbehind regex patterns without any maximum length match, such as the following regex in the previous example:</p>
<p class="calibre1">(?&lt;=\w\.\w+)$ </p>
<p class="calibre1"><a id="p155"/><b class="calibre3">Summary</b></p>
<p class="calibre1">In this chapter, we learned zero-width assertions and how they are crucial for solving some important matching problems. We discussed the boundary matcher, \G, and its usefulness in solving some problems. We discovered the idea behind atomic groups and understood how they can improve the overall regex performance. Then, we covered all the important lookahead and lookbehind patterns. We covered some interesting matching, validation, and splitting problems that are solved using lookarounds. </p>
<p class="calibre1">In the next chapter, we will continue to learn advanced concepts of Java regular expressions, such as union and intersection within character classes, and negated character classes. </p>
<p class="calibre1"><a id="p156"/><b class="calibre3">Understanding the Union, </b></p>
<p class="calibre1"><b class="calibre3">Intersection, and</b></p>
<p class="calibre1"><b class="calibre3">Subtraction of Character</b></p>
<p class="calibre1"><b class="calibre3">Classes</b></p>
<p class="calibre1">Some regular expression engines allow composite character classes, or character classes inside other character classes. The Java regular expression engine also supports many of these features, and we will discuss these features in this chapter. </p>
<p class="calibre1">We will cover the following topics in this chapter:</p>
<p class="calibre1">The union of character classes</p>
<p class="calibre1">The intersection of character classes</p>
<p class="calibre1">The subtraction of character classes</p>
<p class="calibre1">The advantages of using composite character classes</p>
<p class="calibre1"><a id="p157"/><b class="calibre3">The union of character</b></p>
<p class="calibre1"><b class="calibre3">classes</b></p>
<p class="calibre1">The union of character classes will match a character that would be matched by any of the composing character classes. Essentially, this is the definition of the union operation in general. In regular expressions, it is possible to create unions of character classes by simply writing a character class inside another. </p>
<p class="calibre1">You may remember that character classes open with the [ character and close with the</p>
<p class="calibre1">] character, and we can list characters and character ranges between the opening and closing brackets. </p>
<p class="calibre1">In addition to those, we can use other character sets inside the brackets, and the resulting set will be the union of all these character classes. This way, there is no union operator to create the composition of these character classes; we just simply write them inside each other. </p>
<p class="calibre1">For example, consider the following composite character class:</p>
<p class="calibre1">[A-D[PQR]] </p>
<p class="calibre1">This matches any character in the range of A to D or any single character P, Q, or R. This regular expression can also be written as follows:</p>
<p class="calibre1">[A-DPQR] </p>
<p class="calibre1">We can also create a union of more than two character classes, such as as in the following regular expression:</p>
<p class="calibre1">[A-D[P-S][X-Z]] </p>
<p class="calibre1">This matches any character in the range of A to D, any character in the range of P to S, or any character in the range from X to Z. This regular expression can also be written as follows:</p>
<p class="calibre1">[A-DP-SX-Z] </p>
<p class="calibre1">The union of character classes can also be used with a negated inner character class, and this is where character class unions really start to shine and give us extra value. </p>
<p class="calibre1">We get to see a good use of the union operation only when we use the union of various character classes with a negated character class. </p>
<p class="calibre1">Let's consider, for example, the following code listing on the union with a negated character class:</p>
<p class="calibre1">package example.regex; </p>
<p class="calibre1"/>
<p class="calibre1">import java.util.regex.*; </p>
<p class="calibre1"/>
<p class="calibre1">public class UnionExample </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main(String[] args) </p>
<p class="calibre1">{ </p>
<p class="calibre1">final String re = "[#@.[^\\p{Punct}\\s]]"; </p>
<p class="calibre1">final String[] arr = new String[] { </p>
<p class="calibre1"><a id="p158"/>      "A", "#", "@", "1", "5", " ", "\n", ":", ".", "a", "%", "-", "3" </p>
<p class="calibre1">}; </p>
<p class="calibre1">for (String s: arr) </p>
<p class="calibre1">{ </p>
<p class="calibre1">System.out.printf("[%s] %s%n", s, </p>
<p class="calibre1">(s.matches(re) ? "matches" : "does not match")); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">This regex has the following negated character class:</p>
<p class="calibre1">[^\\p{Punct}\\s] </p>
<p class="calibre1">The preceding negated character class allows any character that is not a punctuation and not a space character. Now, suppose that we want to allow a few selected punctuation characters, @, #, and ., or in other words, the [@#.] character class. In this scenario, the union comes handy. We make a composite character class that uses a union of both these cases, as follows:</p>
<p class="calibre1">[#@.[^\\p{Punct}\\s]] </p>
<p class="calibre1">Now, this composite character class will allow the [@#.] characters, or any character that is not a punctuation and not a space character. </p>
<p class="calibre1">Once we compile and run the preceding code, we'll get the following output:</p>
<p class="calibre1">[A] matches </p>
<p class="calibre1">[#] matches </p>
<p class="calibre1">[@] matches </p>
<p class="calibre1">[1] matches </p>
<p class="calibre1">[5] matches </p>
<p class="calibre1">[ ] does not match </p>
<p class="calibre1">[ </p>
<p class="calibre1">] does not match </p>
<p class="calibre1">[:] does not match </p>
<p class="calibre1">[.] matches </p>
<p class="calibre1">[a] matches </p>
<p class="calibre1">[%] does not match </p>
<p class="calibre1">[-] does not match </p>
<p class="calibre1">[3] matches </p>
<p class="calibre1"/>
<p class="calibre1">You can see the output of "matches" for all the character sets that are not included inside our negated character class or allowed by the [#@.] character class. It returns</p>
<p class="calibre1">"does not match" for all other cases. </p>
<p class="calibre1"><a id="p159"/><b class="calibre3">The intersection of character</b></p>
<p class="calibre1"><b class="calibre3">classes</b></p>
<p class="calibre1">The intersection operation on character classes results in a composite class that contains every character allowed by <b class="calibre3">all</b> of its operand (inner) classes or, in other words, matches characters that belong to all the character classes in the composite character class pattern. The intersection operator is as follows:</p>
<p class="calibre1">&amp;&amp; </p>
<p class="calibre1">For example, consider the following composite character class using the &amp;&amp; operator:</p>
<p class="calibre1">[A-Z&amp;&amp;[PQR]] </p>
<p class="calibre1">This matches any character that is in the range of A to Z and is one of the single P, Q, or R characters. However, the preceding regular expression can also be simply written as follows:</p>
<p class="calibre1">[PQR] </p>
<p class="calibre1">The following composite character class using intersection matches the digits, 5 and 6, since only these two digits belong to all the three character classes:</p>
<p class="calibre1">[1-7&amp;&amp;[3-6]&amp;&amp;[5-8]] </p>
<p class="calibre1">To see this regex in action, let's use this complete code: package example.regex; </p>
<p class="calibre1"/>
<p class="calibre1">import java.util.regex.*; </p>
<p class="calibre1"/>
<p class="calibre1">public class IntersectionExample </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main(String[] args) </p>
<p class="calibre1">{ </p>
<p class="calibre1">final Pattern p = Pattern.compile("[1-7&amp;&amp;[3-6]&amp;&amp;[5-8]]"); for (int i=0; i&lt;10; i++) </p>
<p class="calibre1">{ </p>
<p class="calibre1">String s = String.valueOf(i); </p>
<p class="calibre1">Matcher m = p.matcher(s); </p>
<p class="calibre1">System.out.printf("[%s] %s%n", s, </p>
<p class="calibre1">(m.matches() ? "matches" : "does not match")); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">When we compile and run the preceding code, we will see the following output:</p>
<p class="calibre1">[0] does not match </p>
<p class="calibre1">[1] does not match </p>
<p class="calibre1">[2] does not match </p>
<p class="calibre1">[3] does not match </p>
<p class="calibre1">[4] does not match </p>
<p class="calibre1">[5] matches </p>
<p class="calibre1">[6] matches </p>
<p class="calibre1">[7] does not match </p>
<p class="calibre1">[8] does not match </p>
<p class="calibre1">[9] does not match </p>
<p class="calibre1"/>
<p class="calibre1">As you can see, it shows "matches" only for the digits, 5 and 6. </p>
<p class="calibre1"><a id="p160"/>Let's take another example, which involves matching a non-whitespace character that is not a Unicode letter. We know we can use the following regex using a positive lookahead:</p>
<p class="calibre1">(?=\S)\P{L} </p>
<p class="calibre1">We can also use an intersection operation to write this example, as follows:</p>
<p class="calibre1">[\\S&amp;&amp;[\\P{L}]] </p>
<p class="calibre1">Due to the use of the &amp;&amp; operator here, it matches a character that satisfies both the properties, \S (non-whitespace) and \P{L} (non-letters). </p>
<p class="calibre1">Note that the inner square brackets are optional when not using a negated character class in an intersection operation. Hence, the preceding regex can also be written as follows:</p>
<p class="calibre1">[\\S&amp;&amp;\\P{L}] </p>
<p class="calibre1">Similarly, to match an uppercase Greek letter, we can use the intersection of the following two classes:</p>
<p class="calibre1">\p{InGreek}: This matches a character in the Greek block</p>
<p class="calibre1">\p{Lu}: This matches an uppercase Unicode letter</p>
<p class="calibre1">By combining these two character classes with intersection, we can make a single composite character class, as follows:</p>
<p class="calibre1">[\p{InGreek}&amp;&amp;[\p{Lu}]] </p>
<p class="calibre1">To test the preceding regex, let's pick some Greek letters and write a simple Java code, such as the following, to test our regex against the selected Greek letters: package example.regex; </p>
<p class="calibre1"/>
<p class="calibre1">import java.util.regex.*; </p>
<p class="calibre1"/>
<p class="calibre1">public class UppercaseGreekIntersectionExample </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main(String[] args) </p>
<p class="calibre1">{ </p>
<p class="calibre1">final Pattern p = Pattern.compile("[\\p{InGreek}&amp;&amp;[\\p{Lu}]]"); final String[] arr = new String[] { </p>
<p class="calibre1">"Γ", "Δ", "Θ", "Ξ", "Π", "Σ", "Φ", "α", "β", "γ", "δ", "ε", "A", "P", "e", "r" </p>
<p class="calibre1">}; </p>
<p class="calibre1"/>
<p class="calibre1">for (String s: arr)  </p>
<p class="calibre1">{ </p>
<p class="calibre1">Matcher m = p.matcher(s); </p>
<p class="calibre1">System.out.printf("[%s] %s%n", s, </p>
<p class="calibre1">(m.matches() ? "matches" : "does not match")); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">When we run the preceding class, it prints the following output:</p>
<p class="calibre1">[Γ] matches</p>
<p class="calibre1">[Δ] matches </p>
<p class="calibre1">[Θ] matches </p>
<p class="calibre1">[Ξ] matches </p>
<p class="calibre1">[Π] matches </p>
<p class="calibre1">[Σ] matches </p>
<p class="calibre1">[Φ] matches </p>
<p class="calibre1">[α] does not match </p>
<p class="calibre1">[β] does not match </p>
<p class="calibre1">[γ] does not match </p>
<p class="calibre1">[δ] does not match </p>
<p class="calibre1"><a id="p161"/>[ε] does not match </p>
<p class="calibre1">[A] does not match </p>
<p class="calibre1">[P] does not match </p>
<p class="calibre1">[e] does not match </p>
<p class="calibre1">[r] does not match </p>
<p class="calibre1"/>
<p class="calibre1">As you can see, "matches" is only printed for the uppercase Greek letters. For all the other letters, it prints "does not match". </p>
<p class="calibre1"><a id="p162"/><img src="index-162_1.jpg" alt="Image 22" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">The subtraction of character</b></p>
<p class="calibre1"><b class="calibre3">classes</b></p>
<p class="calibre1">Suppose we have to match characters that belong to one class but not to another in a composite character class pattern. There is no separate operator for the subtraction operation. Subtraction is performed by using the intersection operator, &amp;&amp;, and a negated inner character class. </p>
<p class="calibre1"> <i class="calibre4">A regular expression is usually more readable if we write the larger set</i> <i class="calibre4">in front and the one we want to subtract from it after the &amp;&amp; operator. </i></p>
<p class="calibre1">For example, consider the following composite character class:</p>
<p class="calibre1">[0-9&amp;&amp;[^3-6]] </p>
<p class="calibre1">It will match the digits, 0 to 9, except the digits, 3 to 6. This character class can also be written as a union of two character classes:</p>
<p class="calibre1">[[0-2][7-9]] </p>
<p class="calibre1">We can also just use a simple character class, as follows:</p>
<p class="calibre1">[0-27-9]  </p>
<p class="calibre1"/>
<p class="calibre1">In order to match all the English consonant uppercase letters, we can subtract five vowels from uppercase letters, such as in the following regex:</p>
<p class="calibre1">[A-Z&amp;&amp;[^AEIOU]] </p>
<p class="calibre1">We can also reverse the order of the two sets used in the preceding regex and use the following regex:</p>
<p class="calibre1">[[^AEIOU]&amp;&amp;A-Z]  </p>
<p class="calibre1">Suppose we want to match all punctuation characters except four basic math operators: +, -, *, and /. We can use the following composite character class using the subtraction operation:</p>
<p class="calibre1">[\p{Punct}&amp;&amp;[^+*/-]] </p>
<p class="calibre1">Here is a test class that tests the preceding subtraction character class: package example.regex; </p>
<p class="calibre1"/>
<p class="calibre1">import java.util.regex.*; </p>
<p class="calibre1"/>
<p class="calibre1">public class SubtractionExample </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main(String[] args) </p>
<p class="calibre1">{ </p>
<p class="calibre1">final Pattern p = Pattern.compile("[\\p{Punct}&amp;&amp;[^+*/-]]"); final String[] arr = new String[] { </p>
<p class="calibre1">"!", "@", "#", "$", "%", "+", "-", "*", "/", "1", "M", "d" </p>
<p class="calibre1">}; </p>
<p class="calibre1"/>
<p class="calibre1"><a id="p163"/>    for (String s: arr)  </p>
<p class="calibre1">{ </p>
<p class="calibre1">Matcher m = p.matcher(s); </p>
<p class="calibre1">System.out.printf("[%s] %s%n", s, </p>
<p class="calibre1">(m.matches() ? "matches" : "does not match")); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">This program produces the following output when we run it after compilation:</p>
<p class="calibre1">[!] matches </p>
<p class="calibre1">[@] matches </p>
<p class="calibre1">[#] matches </p>
<p class="calibre1">[$] matches </p>
<p class="calibre1">[%] matches </p>
<p class="calibre1">[+] does not match </p>
<p class="calibre1">[-] does not match </p>
<p class="calibre1">[*] does not match </p>
<p class="calibre1">[/] does not match </p>
<p class="calibre1">[1] does not match </p>
<p class="calibre1">[M] does not match </p>
<p class="calibre1">[d] does not match </p>
<p class="calibre1">As is evident from this output, it allows all the punctuation characters except the four listed math operators. </p>
<p class="calibre1"><a id="p164"/><b class="calibre3">Why should you use</b></p>
<p class="calibre1"><b class="calibre3">composite character classes? </b></p>
<p class="calibre1">We should use composite character classes for the following reasons: To create new custom character classes from predefined Unicode blocks. For example, to match all the letters in an Arabic Unicode block, we can use the following:</p>
<p class="calibre1">[\p{InArabic}&amp;&amp;\p{L}] </p>
<p class="calibre1">To avoid potentially slower lookahead or lookbehind patterns by using the intersection or subtraction operation on multiple character classes. </p>
<p class="calibre1">To enhance the readability of the regular expression. </p>
<p class="calibre1"><a id="p165"/><b class="calibre3">Summary</b></p>
<p class="calibre1">In this chapter, we discussed composite and inner character classes. We found out how we can use the union, intersection, and subtraction operations to combine simple character classes and make a completely different character class to suit our requirements. You learned some good usage patterns of composite character classes for solving tricky problems. Note how we could avoid more complex lookahead and lookbehind assertions by using the union and intersection of character classes. </p>
<p class="calibre1">In the next chapter, we will discuss the pitfalls of some poorly written regular expressions, and you will learn ways to avoid them. You will also learn some important optimizing tips and performance improvement methods for writing complex regular expressions. </p>
<p class="calibre1"><a id="p166"/><b class="calibre3">Regular Expression Pitfalls, </b></p>
<p class="calibre1"><b class="calibre3">Optimization, and</b></p>
<p class="calibre1"><b class="calibre3">Performance Improvements</b></p>
<p class="calibre1">Regular expressions, if not written well may perform poorly. They may run slowly, and when they are executed frequently in some code, they may be the source of high CPU utilization. To avoid these problems, regular expressions have to be crafted carefully, understanding the possible pitfalls, and they also have to be tested thoroughly. We will be covering the following topics in this chapter: Common pitfalls and ways to avoid them while writing regular expressions How to test your regex functionality and performance</p>
<p class="calibre1">Optimization and performance enhancing tips</p>
<p class="calibre1">Catastrophic backtracking and how to avoid it</p>
<p class="calibre1"><a id="p167"/><b class="calibre3">Common pitfalls and ways to</b></p>
<p class="calibre1"><b class="calibre3">avoid them while writing</b></p>
<p class="calibre1"><b class="calibre3">regular expressions</b></p>
<p class="calibre1">Let's discuss some common mistakes people make while building regular expressions to solve various problems. </p>
<p class="calibre1"><a id="p168"/><b class="calibre3">Do not forget to escape regex</b></p>
<p class="calibre1"><b class="calibre3">metacharacters outside a</b></p>
<p class="calibre1"><b class="calibre3">character class</b></p>
<p class="calibre1">You learned that all the special metacharacters, such as *, +, ?, ., |, (, ), [, {, ^, $, and so on, need to be escaped if the intent is to match them literally. I often see cases where programmers leave them unescaped, thus giving a totally different meaning to the regular expression. The Java regex API that we discussed in <a href="#p111">Chapter 5, </a>  <i class="calibre4">Introduction</i> <i class="calibre4">to Java Regular Expressions APIs - Pattern and Matcher Classes</i>, throws a non-checked exception if a regex pattern is wrongly formatted and cannot be compiled. </p>
<p class="calibre1"><a id="p169"/><b class="calibre3">Avoid escaping every non-</b></p>
<p class="calibre1"><b class="calibre3">word character</b></p>
<p class="calibre1">Some programmers overdo escaping, thinking that they need to escape every non-word character such as colon, hyphen, semicolon, forward slash, and whitespace, which is not correct. They end up writing a regular expression as follows:</p>
<p class="calibre1">^https?\:\/\/(www\.)?example\.com$ </p>
<p class="calibre1">The preceding regex pattern uses excessive escaping. This pattern still works, but it is not very readable. The colon and forward slash have no special meaning in regex; hence, it is better to write this regex in the following way:</p>
<p class="calibre1">^https?://(www\.)?example\.com$ </p>
<p class="calibre1"><a id="p170"/><b class="calibre3">Avoid unnecessary capturing</b></p>
<p class="calibre1"><b class="calibre3">groups to reduce memory</b></p>
<p class="calibre1"><b class="calibre3">consumption</b></p>
<p class="calibre1">We come across so many examples of regular expressions on the internet that promote unnecessary capturing groups. If we are not extracting any substring or not using a group in backreferences, then it is better to avoid capturing groups by using one or more of the following ways:</p>
<p class="calibre1">1.  We can use character classes in certain cases. Consider the following capturing group:</p>
<p class="calibre1">(a|e|i|o|u) </p>
<p class="calibre1">So, instead of using the preceding regex, we can use the following:</p>
<p class="calibre1">[aeiou]</p>
<p class="calibre1">2.  We can use a non-capturing group by placing a ?: at the start of the group. </p>
<p class="calibre1">Consider the following regex:</p>
<p class="calibre1">(red|blue|white) </p>
<p class="calibre1">Instead of the previous regex, we can use the following:</p>
<p class="calibre1">(?:red|blue|white) </p>
<p class="calibre1">3.  To write a regex to match an integer or decimal number there is no need to use the following regex:</p>
<p class="calibre1">^(\d*)(\.?)(\d+)$ </p>
<p class="calibre1">We can just rewrite it by removing unnecessary groups, as follows:</p>
<p class="calibre1">^\d*\.?d+$ </p>
<p class="calibre1">4.  Sometimes, a regex may contain multiple problems, such as the ones we discussed in the previous subsection:</p>
<p class="calibre1">^https?\:\/\/(www\.)?example\.com$ </p>
<p class="calibre1">Not only does this regex use excessive escaping but there is also an unnecessary capturing group in this regex. Hence, by applying these fixes, the preceding regex can be better written as follows:</p>
<p class="calibre1">^https?://(?:www\.)?example\.com$  </p>
<p class="calibre1"><a id="p171"/><b class="calibre3">However, don't forget to use</b></p>
<p class="calibre1"><b class="calibre3">the required group around</b></p>
<p class="calibre1"><b class="calibre3">alternation</b></p>
<p class="calibre1">Often, we see regex patterns that use alternation, and around the alternation, we use anchors or boundary matchers without safeguarding the alternation expression in a group. Note that the ^, $, \A, \Z, \z anchors and the \b boundary matcher have a higher precedence than the alternation character, | (pipe)</p>
<p class="calibre1">So, consider a regular expression written as follows:</p>
<p class="calibre1">^com|org|net$ </p>
<p class="calibre1">It will also match computer, organization, and internet, though the intent probably was to match only com, net, and org. This is because the start anchor, ^, is being applied to com only and the end anchor, $, is being applied to net, whereas org is not anchored at all. </p>
<p class="calibre1">This regular expression should be written as follows to match only com, org, and net correctly:</p>
<p class="calibre1">^(?:com|org|net)$ </p>
<p class="calibre1"><a id="p172"/><b class="calibre3">Use predefined character</b></p>
<p class="calibre1"><b class="calibre3">classes instead of longer</b></p>
<p class="calibre1"><b class="calibre3">versions</b></p>
<p class="calibre1">We discussed predefined character classes and Unicode character classes in<a href="https://cdp.packtpub.com/java_9_regular_expressions/wp-admin/post.php?post=78&amp;action=edit"> Chapter 2</a>, <i class="calibre4">Understanding the Core Concepts of Java Regular Expressions</i>. We need to make good use of it. So use \d instead of [0-9] or \D instead of [^0-9], and use \w instead of</p>
<p class="calibre1">[a-zA-Z_0-9] or \W instead of [^a-zA-Z_0-9]. </p>
<p class="calibre1"><a id="p173"/><b class="calibre3">Use the limiting quantifier</b></p>
<p class="calibre1"><b class="calibre3">instead of repeating a</b></p>
<p class="calibre1"><b class="calibre3">character or pattern</b></p>
<p class="calibre1"><b class="calibre3">multiple times</b></p>
<p class="calibre1">The MAC address of a computer is a unique identifier assigned to network interfaces at the time of manufacturing. MAC addresses are 6 bytes or 48 bits in length and are written in the nn:nn:nn:nn:nn:nn format, where each n represents a hexadecimal digit. </p>
<p class="calibre1">To match a MAC address, one can write the following regex:</p>
<p class="calibre1">^[A-F0-9]{2}:[A-F0-9]{2}:[A-F0-9]{2}:[A-F0-9]{2}:[A-F0-9]{2}:[A-F0-9]{2}$ </p>
<p class="calibre1">However, it is much cleaner and more readable to write the regex as follows:</p>
<p class="calibre1">^(?:[A-F\d]{2}:){5}[A-F\d]{2}$ </p>
<p class="calibre1">Note how short and readable this regex pattern has become when compared to the previous regex. </p>
<p class="calibre1"><a id="p174"/><b class="calibre3">Do not use an unescaped</b></p>
<p class="calibre1"><b class="calibre3">hyphen in the middle of a</b></p>
<p class="calibre1"><b class="calibre3">character class</b></p>
<p class="calibre1">We know that most of the special regex metacharacters are treated literally inside the character class and we do not need to escape them inside the character class. </p>
<p class="calibre1">However, if an unescaped hyphen is used between two characters, then it makes it a range between the previous and the next character of the hyphen. </p>
<p class="calibre1">As an illustrative example, let's consider this character class expression to match the four basic math operators, +,-,*,/:</p>
<p class="calibre1">[*+-/] </p>
<p class="calibre1">The way it is written, this character class has a hyphen between the + and / characters. </p>
<p class="calibre1">This makes the character class match all the characters that fall between + (0x2A) and /</p>
<p class="calibre1">(0x2F), as per the ASCII table. Due to this reason, the preceding pattern will also match the comma (,), that is, 0x2C, and DOT (.), that is, 0x2E, characters. </p>
<p class="calibre1">An unescaped hyphen can be safely used at the first or last positions in a character class to avoid making a range. With that in mind, we can correct this character class by using any of the following forms:</p>
<p class="calibre1">[-*+/] </p>
<p class="calibre1">[*+/-] </p>
<p class="calibre1">[*+\-/] </p>
<p class="calibre1"><a id="p175"/><b class="calibre3">The mistake of calling</b></p>
<p class="calibre1"><b class="calibre3">matcher.goup() without a</b></p>
<p class="calibre1"><b class="calibre3">prior call to matcher.find(), </b></p>
<p class="calibre1"><b class="calibre3">matcher.matches(), or</b></p>
<p class="calibre1"><b class="calibre3">matcher.lookingAt()</b></p>
<p class="calibre1">This annoying mistake is found in many programs. As the heading says, these are cases where programmers call any of the group() methods without a prior call to the find, matches, or lookingAt methods. A matcher is created using the pattern.matcher(String) method call, but we need to invoke one of these three methods to perform a match operation. </p>
<p class="calibre1">If we call matcher.group() without calling one of these three methods, then the code will throw a java.lang.IllegalStateException exception, as the following code is doing: package example.regex; </p>
<p class="calibre1"/>
<p class="calibre1">import java.util.regex.*; </p>
<p class="calibre1"/>
<p class="calibre1">public class MissingMethodCall  </p>
<p class="calibre1">{  </p>
<p class="calibre1">public static void main(String[] args)  </p>
<p class="calibre1">{  </p>
<p class="calibre1">final Pattern p = Pattern.compile("(\\d*)\\.?(\\d+)"); final String input = "123.75"; </p>
<p class="calibre1"/>
<p class="calibre1">Matcher m = p.matcher(input); </p>
<p class="calibre1">System.out.printf("Number Value [%s], Decimal Value [%s]%n", m.group(1), m.group(2)); </p>
<p class="calibre1">}  </p>
<p class="calibre1">} </p>
<p class="calibre1">Note that the code calls m.group(1) and m.group(2) right after it instantiates the matcher object from a pattern instance. Once compiled and executed, this code will throw an unwanted java.lang.IllegalStateException exception, indicating that the matcher instance is not in the correct state to return group information. </p>
<p class="calibre1">In order to fix this code, insert a call to any one of the three methods (find, matches, or lookingAt) to perform a match operation, as shown in the following code: package example.regex; </p>
<p class="calibre1"/>
<p class="calibre1">import java.util.regex.*; </p>
<p class="calibre1"/>
<p class="calibre1">public class RightMethodCall </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main(String[] args) </p>
<p class="calibre1">{ </p>
<p class="calibre1">final Pattern p = Pattern.compile("(\\d*)\\.?(\\d+)"); final String input = "123.75"; </p>
<p class="calibre1"/>
<p class="calibre1">Matcher m = p.matcher(input); </p>
<p class="calibre1"/>
<p class="calibre1">if (m.find()) // or m.lookingAt() or m.matches() </p>
<p class="calibre1"><a id="p176"/>    { </p>
<p class="calibre1">System.out.printf("Integer Part [%s], Fractional Part [%s]%n", m.group(1), m.group(2)); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">Now, this code will produce the correct output, as follows: Integer Part [123], Fractional Part [75] </p>
<p class="calibre1"><a id="p177"/><b class="calibre3">Do not use regular</b></p>
<p class="calibre1"><b class="calibre3">expressions to parse XML /</b></p>
<p class="calibre1"><b class="calibre3">HTML data</b></p>
<p class="calibre1">Using regular expressions to parse XML or HTML text is probably the most frequently committed mistake. Although regular expressions are very useful, they have their limitations and these limits are usually met when trying to use them for XML or HTML parsing. HTML and XML are not regular languages by nature. </p>
<p class="calibre1">Luckily, there are other tools in Java for that purpose. The JDK contains readily available classes to parse these formats and convert them to <b class="calibre3">Document Object Model</b> (<b class="calibre3">DOM</b>), or to work with them on the fly using the SAX parsing model. </p>
<p class="calibre1">Do not use regular expressions for certain tasks when there are more specific parsers for the purpose. The fact that there are other readily available tools gives you a hint that probably regular expressions, in such a case, are not the best tools. After all, that is the reason why the programmers of the XML and HTML parsers started their work. </p>
<p class="calibre1"><a id="p178"/><b class="calibre3">How to test and benchmark</b></p>
<p class="calibre1"><b class="calibre3">your regular expression</b></p>
<p class="calibre1"><b class="calibre3">performance</b></p>
<p class="calibre1">There are several free online regular expression tools available that tell you the number of steps to match a regex pattern against a given set of inputs and also provide you valuable debug info. You should also write your unit test cases. Here is a list of some online tools that can be used:</p>
<p class="calibre1">Use jshell available with Java 9 to quickly test your regex Use RegexMatchers, a utility class with static methods, to test your regex in JUnit; check <a href="http://matchers.jcabi.com/regex-matchers.html">http://matchers.jcabi.com/regex-matchers.html</a></p>
<p class="calibre1"><a href="https://regex101.com/">regex101.com</a></p>
<p class="calibre1"><a href="http://www.regexplanet.com/">www.regexplanet.com</a></p>
<p class="calibre1"><a href="http://www.rexegg.com/">www.rexegg.com</a></p>
<p class="calibre1"><a href="https://www.debuggex.com/">www.debuggex.com</a></p>
<p class="calibre1"><a href="http://regexper.com">regexper.com</a></p>
<p class="calibre1"><a href="https://www.regexbuddy.com/">regexbuddy.com </a>(not free) Use the Java/JUnit regex-tester library from <a href="https://github.com/nickawatts/regex-tester">https://github.com/nickawatts/regex-tester</a></p>
<p class="calibre1">In addition to these tools, you can yourself write your own comprehensive unit test cases using JUnit in your favorite Java IDE and check the timings and other matching information. </p>
<p class="calibre1">Here is an example of JUnit code using the RegExMatchers library: package example.regex; </p>
<p class="calibre1"/>
<p class="calibre1">import com.jcabi.matchers.RegexMatchers; </p>
<p class="calibre1">import org.hamcrest.MatcherAssert; </p>
<p class="calibre1">import org.junit.Test; </p>
<p class="calibre1"/>
<p class="calibre1">public class RegexTest </p>
<p class="calibre1">{ </p>
<p class="calibre1">@Test </p>
<p class="calibre1">public void matchesDecimalNumberPattern() </p>
<p class="calibre1">{  </p>
<p class="calibre1">MatcherAssert.assertThat( </p>
<p class="calibre1">"[+-]?\\d*\\.?\\d+", </p>
<p class="calibre1">RegexMatchers.matchesPattern("-145.78") </p>
<p class="calibre1">); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">You are encouraged to use this library to build your own test cases and ensure that your regex passes all the edge cases. </p>
<p class="calibre1"><a id="p179"/><b class="calibre3">Catastrophic or exponential</b></p>
<p class="calibre1"><b class="calibre3">backtracking</b></p>
<p class="calibre1">Regular expression engines can be broadly categorized into two types: 1.  The <b class="calibre3">Non-deterministic Finite Automation</b> (<b class="calibre3">NFA</b>) engine 2.  The <b class="calibre3">Deterministic Finite Automation</b> (<b class="calibre3">DFA</b>) engine The DFA engines do not evaluate each character more than once to find a match. On the other hand, the NFA engines support backtracking, which means that each character in the input can be evaluated multiple times by the regex engine. The Java regular expression engine is an NFA engine. </p>
<p class="calibre1">Regex engines backtrack or give back one position at a time to make various attempts to match a given pattern when using the greedy quantifier or trying alternations. </p>
<p class="calibre1">Similarly, when using lazy quantifiers, the regex engine moves forward one position at a time to attempt matching. </p>
<p class="calibre1">Regex engines usually take less time to find a positive match in the given input as compared to returning a failure for a non-match. The NFA regex engines need to evaluate all the possible permutations before returning a failure. </p>
<p class="calibre1">For example, in a regular expression that uses nested repetition quantifiers, the regex engine backtracks excessively while matching a long input text. A catastrophic backtracking problem usually occurs when the regex engine fails to make a negative match towards the end of the string and after attempting far too many permutations. </p>
<p class="calibre1">As an example, check the following regex with nested quantifiers:</p>
<p class="calibre1">^(\w+)*$ </p>
<p class="calibre1">Suppose we test it against an input text that does not have a word character in the end, such as this input string:</p>
<p class="calibre1">abcdefghijklmno: </p>
<p class="calibre1">We know that due to the presence of a non-word character (colon) at the end of the input, the match will fail. However, due to the presence of nested compound quantifiers, (\w+)*, the regex engine backtracks excessively and makes a lot of attempts to match the input before giving up. </p>
<p class="calibre1">Excessive backtracking may also be caused by two or more alternatives that are mutually exclusive and can match the same string in the input. For example, having a regex pattern like this one to match the text between the %% tags:</p>
<p class="calibre1">%%(.|\s)+%% </p>
<p class="calibre1">This regex may also cause catastrophic backtracking for failed cases, such as the following input string with a missing closing tag:</p>
<p class="calibre1">%%        something    here    abcd     123 </p>
<p class="calibre1"><a id="p180"/>The problem here is that the alternations in (.|\s) are not mutually exclusive, as dot can also match the same whitespace that is matched by \s, except the newline character. </p>
<p class="calibre1">Here is a complete program listing that demonstrates a dynamically building regex getting slower with every iteration of the loop and eventually causing catastrophic backtracking:</p>
<p class="calibre1">package example.regex; </p>
<p class="calibre1"/>
<p class="calibre1">import java.util.regex.Matcher; </p>
<p class="calibre1">import java.util.regex.Pattern; </p>
<p class="calibre1"/>
<p class="calibre1">public class CatastropicBacktracking </p>
<p class="calibre1">{ </p>
<p class="calibre1">public static void main(String[] args) </p>
<p class="calibre1">{ </p>
<p class="calibre1">final int MAX = 30; </p>
<p class="calibre1"/>
<p class="calibre1">for (int i = 1; i &lt; MAX; i++) </p>
<p class="calibre1">{ </p>
<p class="calibre1">StringBuilder sb1 = new StringBuilder(i); </p>
<p class="calibre1">StringBuilder sb2 = new StringBuilder(i); </p>
<p class="calibre1"/>
<p class="calibre1">for (int j = i; j &gt; 0; j--) </p>
<p class="calibre1">{ </p>
<p class="calibre1">sb1.append('a'); </p>
<p class="calibre1">sb2.append("a?"); </p>
<p class="calibre1">} </p>
<p class="calibre1"/>
<p class="calibre1">sb2.append(sb1); </p>
<p class="calibre1"/>
<p class="calibre1">final Pattern p = Pattern.compile("^" + sb2.toString() + "$"); Matcher m = p.matcher(sb1.toString()); </p>
<p class="calibre1"/>
<p class="calibre1">long start = System.nanoTime(); </p>
<p class="calibre1">m.matches(); </p>
<p class="calibre1">long end = System.nanoTime(); </p>
<p class="calibre1"/>
<p class="calibre1">System.out.printf("%s:: ( %sms ) :: Pattern &lt;%s&gt;, Input &lt;%s&gt;%n", i, (end - start)/1_000_000, sb2, sb1); </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">} </p>
<p class="calibre1">When you compile and run the preceding program and look at the generated output, you will note an output as follows:</p>
<p class="calibre1"/>
<p class="calibre1">1:: ( 0ms ) :: Pattern &lt;a?a&gt;, Input &lt;a&gt; </p>
<p class="calibre1">2:: ( 0ms ) :: Pattern &lt;a?a?aa&gt;, Input &lt;aa&gt; </p>
<p class="calibre1">3:: ( 0ms ) :: Pattern &lt;a?a?a?aaa&gt;, Input &lt;aaa&gt; 4:: ( 0ms ) :: Pattern &lt;a?a?a?a?aaaa&gt;, Input &lt;aaaa&gt; 5:: ( 0ms ) :: Pattern &lt;a?a?a?a?a?aaaaa&gt;, Input &lt;aaaaa&gt; 6:: ( 0ms ) :: Pattern &lt;a?a?a?a?a?a?aaaaaa&gt;, Input &lt;aaaaaa&gt; 7:: ( 0ms ) :: Pattern &lt;a?a?a?a?a?a?a?aaaaaaa&gt;, Input &lt;aaaaaaa&gt; 8:: ( 0ms ) :: Pattern &lt;a?a?a?a?a?a?a?a?aaaaaaaa&gt;, Input &lt;aaaaaaaa&gt; 9:: ( 0ms ) :: Pattern &lt;a?a?a?a?a?a?a?a?a?aaaaaaaaa&gt;, Input &lt;aaaaaaaaa&gt; 10:: ( 0ms ) :: Pattern &lt;a?a?a?a?a?a?a?a?a?a?aaaaaaaaaa&gt;, Input &lt;aaaaaaaaaa&gt; 11:: ( 0ms ) :: Pattern &lt;a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaa&gt;, Input &lt;aaaaaaaaaaa&gt; 12:: ( 0ms ) :: Pattern &lt;a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaa&gt;, Input &lt;aaaaaaaaaaaa&gt; 13:: ( 10ms ) :: Pattern &lt;a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaa&gt;, Input &lt;aaaaaaaaaaaaa&gt; 14:: ( 1ms ) :: Pattern &lt;a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaa&gt;, Input &lt;aaaaaaaaaaaaaa&gt; 15:: ( 15ms ) :: Pattern &lt;a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaa&gt;, Input &lt;aaaaaaaaaaaaaaa&gt; 16:: ( 18ms ) :: Pattern &lt;a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaa&gt;, Input &lt;aaaaaaaaaaaaaaaa&gt; 17:: ( 29ms ) :: Pattern &lt;a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaa&gt;, Input &lt;aaaaaaaaaaaaaaaaa&gt; 18:: ( 22ms ) :: Pattern &lt;a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaa&gt;, Input &lt;aaaaaaaaaaaaaaaaaa&gt; 19:: ( 51ms ) :: Pattern &lt;a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaa&gt;, Input &lt;aaaaaaaaaaaaaaaaaaa&gt; 20:: ( 97ms ) :: Pattern &lt;a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaa&gt;, Input &lt;aaaaaaaaaaaaaaaaaaaa&gt; 21:: ( 188ms ) :: Pattern &lt;a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaa&gt;, Input &lt;aaaaaaaaaaaaaaaaaaaaa&gt; 22:: ( 441ms ) :: Pattern &lt;a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaa&gt;, Input &lt;aaaaaaaaaaaaaaaaaaaaaa&gt; 23:: ( 1003ms ) :: Pattern &lt;a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaa&gt;, Input &lt;aaaaaaaaaaaaaaaaaaaaaaa&gt; 24:: ( 1549ms ) :: Pattern &lt;a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaa&gt;, Input &lt;aaaaaaaaaaaaaaaaaaaaaaaa&gt; 25:: ( 3010ms ) :: Pattern &lt;a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaa&gt;, Input &lt;aaaaaaaaaaaaaaaaaaaaaaaaa&gt; 26:: ( 5884ms ) :: Pattern &lt;a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaa&gt;, Input &lt;aaaaaaaaaaaaaaaaaaaaaaaaaa&gt; </p>
<p class="calibre1"><a id="p181"/>27:: ( 12588ms ) :: Pattern &lt;a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaaa&gt;, Input &lt;aaaaaaaaaaaaaaaaaaaaaaaaaaa&gt; 28:: ( 24765ms ) :: Pattern &lt;a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaaaa&gt;, Input &lt;aaaaaaaaaaaaaaaaaaaaaaaaaaaa&gt; 29:: ( 51679ms ) :: Pattern &lt;a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaaaaa&gt;, Input &lt;aaaaaaaaaaaaaaaaaaaaaaaaaaaaa&gt; Note how the execution time grows rapidly on higher values of the counter i, especially after 25. </p>
<p class="calibre1"><a id="p182"/><b class="calibre3">How to avoid catastrophic</b></p>
<p class="calibre1"><b class="calibre3">backtracking</b></p>
<p class="calibre1">Here are some tips to keep in mind while handling situations with catastrophic or excessive backtracking in your regex:</p>
<p class="calibre1">When you write regular expressions, make sure they fail fast without spending a lot of unnecessary steps in backtracking. </p>
<p class="calibre1">When using nested repetition operators or quantifiers, make sure that there is only one unique way to match the a string. </p>
<p class="calibre1">Make good judicious use of atomic groups and possessive quantifiers to avoid excessive backtracking. </p>
<p class="calibre1">You should avoid having too many optional matches that are not mutually exclusive in an alternation pattern. </p>
<p class="calibre1">Be very careful when using a free-flowing pattern such as .* or .+ in your regex. </p>
<p class="calibre1">Wherever possible, use negated character classes for cutting down the backtracking steps and for better performance. </p>
<p class="calibre1">Avoid matching hugely sized text using a single regex. It is better to match smaller strings using your regex and call matcher.find() in a loop to get multiple matches. If needed, use another inner pattern to match and examine the matches found by the main pattern. </p>
<p class="calibre1">The regex with the nested quantifier that caused catastrophic backtracking is as follows:</p>
<p class="calibre1">^(\w+)*$ </p>
<p class="calibre1">We can make use of possessive quantifiers to disallow any backtracking, as follows:</p>
<p class="calibre1">^(\w+)*+$ </p>
<p class="calibre1">You will note a massive jump in this improved regex in any of the benchmarks or regex testing tools, as suggested earlier. </p>
<p class="calibre1">Also, in the alternation regex example, we found that this regex causes excessive backtracking for failed cases:</p>
<p class="calibre1">%%(.|\s)%% </p>
<p class="calibre1">It can be converted to the following regex to avoid excessive backtracking:</p>
<p class="calibre1">%%(\S|\s)+%% </p>
<p class="calibre1">It is even better to avoid the group and use a character class, as follows:</p>
<p class="calibre1">%%[\S\s]+%%  </p>
<p class="calibre1">Note the use of \S instead of dot to make alternatives mutually exclusive. </p>
<p class="calibre1">A regex that can cause excessive backtracking is as follows:</p>
<p class="calibre1">^(?:.*:)+#$ </p>
<p class="calibre1"><a id="p183"/>In the preceding regex example, if we use a negated character class instead of .*, then we can avoid catastrophic backtracking:</p>
<p class="calibre1">^(?:[^:]+:)+#$ </p>
<p class="calibre1">The regex engine doesn't backtrack excessively because the negated character class, </p>
<p class="calibre1">[^:], matches any character except a colon instead of the dot that matches everything, including the colon. </p>
<p class="calibre1">Consider another example with this regex pattern that has the nested repetition operator, +:</p>
<p class="calibre1">%(?:[p-s]+|ye|wo)+% </p>
<p class="calibre1">This regex pattern attempts to match a string that starts with the following conditions: Must start with %</p>
<p class="calibre1">% must be followed by one or more alternations: letters p,q,r,s or the string ye or wo</p>
<p class="calibre1">Must end with another %</p>
<p class="calibre1">Now test this regex pattern against the input string, as follows:</p>
<p class="calibre1">%yeqpsrwospqr </p>
<p class="calibre1">Obviously, the regex pattern is not going to match because the last % is missing. </p>
<p class="calibre1">However, note that the starting % and all the following letters will match the regex pattern before the last %. Due to this, the regex engine will backtrack several times while making attempts to match the complete input before finally giving up. </p>
<p class="calibre1">When testing this regex on the  <i class="calibre4">regex101</i> website's debugger, it shows the following: match 1 failed in 748 steps </p>
<p class="calibre1">748 may be a quite a big number for the number of steps taken to fail the match for a small-sized input. Regex patterns such as this can slow down your application considerably. Some of them can even hang your code for many hours or days due to the catastrophic backtracking behavior. </p>
<p class="calibre1">Now, to prevent this catastrophic backtracking behavior, let's consider the two options the we recommended earlier:</p>
<p class="calibre1">1.  Use a possessive quantifier, as follows:</p>
<p class="calibre1">%(?:[p-s]+|ye|wo)++% </p>
<p class="calibre1">On testing the preceding pattern on the same site, we get the following in the debugger:</p>
<p class="calibre1">match 1 failed in 33 steps </p>
<p class="calibre1">2.  Use an atomic group, as follows:</p>
<p class="calibre1">%(?&gt;[p-s]+|ye|wo)+% </p>
<p class="calibre1">On testing the preceding pattern on the same site, we get the following in the debugger:</p>
<p class="calibre1">match 1 failed in 36 steps </p>
<p class="calibre1"><a id="p184"/>You can notice that by using any of the aforementioned techniques, we make the regex engine fail sooner and avoid the unnecessarily high number of backtracking steps. </p>
<p class="calibre1"><a id="p185"/><b class="calibre3">Optimization and</b></p>
<p class="calibre1"><b class="calibre3">performance enhancement</b></p>
<p class="calibre1"><b class="calibre3">tips</b></p>
<p class="calibre1">Let's discuss some optimization techniques and performance enhancement guidelines. </p>
<p class="calibre1"><a id="p186"/><b class="calibre3">Use a compiled form of</b></p>
<p class="calibre1"><b class="calibre3">regular expressions</b></p>
<p class="calibre1">Compile your string regex pattern using the Pattern.compile(String) method call followed by calls to the Matcher APIs instead of calling shorthand methods in string, such as matches(), replaceAll, and replaceFirst, especially when these matching or replacement methods are invoked repeatedly inside a loop. Repeated calls to String.matches() or any other regex-based method defined in the String API will compile the String regex pattern every time; this can be very time-consuming for a complex regex pattern. </p>
<p class="calibre1"><a id="p187"/><b class="calibre3">Use a negated character</b></p>
<p class="calibre1"><b class="calibre3">class instead of the greedy</b></p>
<p class="calibre1"><b class="calibre3">and slow .* or .+</b></p>
<p class="calibre1">Wherever possible, use negated character classes instead of the potential performance draining patterns (.* or .+), as follows:</p>
<p class="calibre1">param1=[^&amp;]+&amp;param2=[^&amp;]+&amp;param3=[^&amp;]+$ </p>
<p class="calibre1">Avoid using slow-performing quantifiers, as follows:</p>
<p class="calibre1">param1=.+&amp;param2=.+param3=.+$ </p>
<p class="calibre1"><a id="p188"/><b class="calibre3">Avoid unnecessary grouping</b></p>
<p class="calibre1">Avoiding unnecessary captured groups in your regex. If grouping is required in your regex, then use non-capturing groups to save the overall memory footprint of the regex pattern while executing. </p>
<p class="calibre1"><a id="p189"/><b class="calibre3">Use lazy quantifiers</b></p>
<p class="calibre1"><b class="calibre3">strategically instead of</b></p>
<p class="calibre1"><b class="calibre3">greedy quantifiers that cause</b></p>
<p class="calibre1"><b class="calibre3">excessive backtracking</b></p>
<p class="calibre1">Suppose we need to match an input that contains three complete words,  <i class="calibre4">start</i>,  <i class="calibre4">middle</i>, and  <i class="calibre4">end</i>, separated by non-whitespace characters. </p>
<p class="calibre1">Consider using the following pattern with a lazy quantifier:</p>
<p class="calibre1">\bstart\b\S+?\bmiddle\b\S+?\bend\b </p>
<p class="calibre1">Instead of using the following pattern, our match will be faster if we use the preceding pattern:</p>
<p class="calibre1">\bstart\b\S+\bmiddle\b\S+\bend\b </p>
<p class="calibre1"><a id="p190"/><b class="calibre3">Make use of possessive</b></p>
<p class="calibre1"><b class="calibre3">quantifiers to avoid</b></p>
<p class="calibre1"><b class="calibre3">backtracking</b></p>
<p class="calibre1">Recall that we discussed in an earlier chapter how a possessive quantifier is used for fail-fast paradigm. Wherever possible, make good use of possessive quantifiers to tell the regex engine to avoid backtracking. </p>
<p class="calibre1">Suppose we need to write a regex to match the text between two markers, @START@ and</p>
<p class="calibre1">@END@. It is given that the semicolon is now allowed between two markers. </p>
<p class="calibre1">We can write this regex with the + or greedy quantifier, as follows:</p>
<p class="calibre1">@START@[^;]+@END@ </p>
<p class="calibre1">However, it is better to use the ++ or possessive quantifier in the regex, as follows:</p>
<p class="calibre1">@START@[^;]++@END@ </p>
<p class="calibre1">This regex will be faster to execute for failed matches, such as the following string:</p>
<p class="calibre1">@START@ abc 123 foo @XYZ@  </p>
<p class="calibre1"><a id="p191"/><b class="calibre3">Extract common repeating</b></p>
<p class="calibre1"><b class="calibre3">substrings out of alternation</b></p>
<p class="calibre1">Consider the following pattern:</p>
<p class="calibre1">(playground|player|playing) </p>
<p class="calibre1">Instead of using the preceding pattern, it is better to extract the common substring, play, and move it to the left of alternation, as follows: play(ground|er|ing) </p>
<p class="calibre1"><a id="p192"/><b class="calibre3">Use atomic group to avoid</b></p>
<p class="calibre1"><b class="calibre3">backtracking and fail fast</b></p>
<p class="calibre1">Recall from<a href="#p133"> Chapter 6</a>,  <i class="calibre4">Exploring Zero-Width Assertions, Lookarounds, and Atomic</i> <i class="calibre4">Groups, </i> that an atomic group is a non-capturing group that exits the group and throws away all the alternative positions remembered by any token inside the group, after the first match of the pattern inside the group. Thus, it avoids backtracking to attempt all the alternatives present in the group. </p>
<p class="calibre1">Due to this very characteristic of atomic groups, the use of atomic groups in certain scenarios saves many unnecessary backtracking steps and speeds up the overall regex execution. </p>
<p class="calibre1">So, use this atomic group:</p>
<p class="calibre1">\btra(?&gt;ck|ce|ining|de|in|nsit|ns|uma)\b </p>
<p class="calibre1">It is better to use the preceding atomic group instead of the following non-capturing group:</p>
<p class="calibre1">\btra(?:ck|ce|ining|de|in|nsit|ns|uma)\b </p>
<p class="calibre1">The difference in behavior will be evident when matching an input string, such as <i class="calibre4">tracker</i>, which fails to match. </p>
<p class="calibre1"><a id="p193"/><b class="calibre3">Summary</b></p>
<p class="calibre1">In the final chapter of this book, we discussed some common mistakes people make while writing regular expressions. These mistakes often cause some exceptions to be thrown at runtime or cause the regular expressions to fail the match unexpectedly. </p>
<p class="calibre1">Then, you learned the various ways to avoid such mistakes. </p>
<p class="calibre1">We discussed catastrophic backtracking in regular expressions and the tricks to avoid excessive backtracking. By minimizing the backtracking steps, regular expressions can become really efficient. </p>
<p class="calibre1">You learned the testing and benchmarking techniques for regular expressions. Finally, we covered many regex optimization and performance enhancing tips in detail. We hope these tips help you understand the building blocks of regular expressions and write better-performing regular expressions to solve complex parsing and matching problems. </p>
<p class="calibre1">This book was downloaded from AvaxHome! </p>
<p class="calibre1">Visit my blog for more new books:</p>
<p class="calibre1"><a href="https://tr.im/avaxhome">www.avxhm.se/blogs/AlenMiler</a></p>
<p class="calibre1"><a id="p194"/><b class="calibre3">Inhaltsverzeichnis</b></p>
<p class="calibre1">Preface</p>
<p class="calibre1">16</p>
<p class="calibre1">What this book covers</p>
<p class="calibre1">17</p>
<p class="calibre1">What you need for this book</p>
<p class="calibre1">18</p>
<p class="calibre1">Who this book is for</p>
<p class="calibre1">19</p>
<p class="calibre1">Conventions</p>
<p class="calibre1">20</p>
<p class="calibre1">Reader feedback</p>
<p class="calibre1">21</p>
<p class="calibre1">Customer support</p>
<p class="calibre1">22</p>
<p class="calibre1">Downloading the example code</p>
<p class="calibre1">23</p>
<p class="calibre1">Errata</p>
<p class="calibre1">24</p>
<p class="calibre1">Piracy</p>
<p class="calibre1">25</p>
<p class="calibre1">Questions</p>
<p class="calibre1">26</p>
<p class="calibre1">Getting Started with Regular Expressions</p>
<p class="calibre1">27</p>
<p class="calibre1">Introduction to regular expressions</p>
<p class="calibre1">28</p>
<p class="calibre1">A bit of history of regular expressions</p>
<p class="calibre1">29</p>
<p class="calibre1">Various flavors of regular expressions</p>
<p class="calibre1">30</p>
<p class="calibre1">What type of problems need regular expressions to solve</p>
<p class="calibre1">31</p>
<p class="calibre1">The basic rules of regular expressions</p>
<p class="calibre1">32</p>
<p class="calibre1">Constructs of the standard regular expression and meta</p>
<p class="calibre1">33</p>
<p class="calibre1">characters</p>
<p class="calibre1">Some basic regular expression examples</p>
<p class="calibre1">36</p>
<p class="calibre1">Eager matching</p>
<p class="calibre1">38</p>
<p class="calibre1">The effect of eager matching on regular expression alternation 39</p>
<p class="calibre1">Summary</p>
<p class="calibre1">41</p>
<p class="calibre1">Understanding the Core Constructs of Java Regular</p>
<p class="calibre1">42</p>
<p class="calibre1">Expressions</p>
<p class="calibre1">Understanding the core constructs of regular expressions</p>
<p class="calibre1">43</p>
<p class="calibre1">Quantifiers</p>
<p class="calibre1">44</p>
<p class="calibre1">Basic quantifiers</p>
<p class="calibre1">45</p>
<p class="calibre1">Examples using quantifiers</p>
<p class="calibre1">46</p>
<p class="calibre1">Greedy versus reluctant (lazy) matching using quantifiers 47</p>
<p class="calibre1">Possessive quantifiers</p>
<p class="calibre1">48</p>
<p class="calibre1">Boundary constructs</p>
<p class="calibre1">50</p>
<p class="calibre1">Examples using boundary constructs</p>
<p class="calibre1">51</p>
<p class="calibre1">Character classes</p>
<p class="calibre1">52</p>
<p class="calibre1">Examples of character classes</p>
<p class="calibre1">53</p>
<p class="calibre1">Range inside a character class</p>
<p class="calibre1">54</p>
<p class="calibre1">Examples of character range</p>
<p class="calibre1">55</p>
<p class="calibre1">Escaping special regex metacharacters and escaping rules inside 56</p>
<p class="calibre1">the character classes</p>
<p class="calibre1">Escaping inside a character class</p>
<p class="calibre1">57</p>
<p class="calibre1"><a id="p195"/>Examples of escaping rules inside the character class 58</p>
<p class="calibre1">Literally matching a string that may contain special regex 59</p>
<p class="calibre1">metacharacters</p>
<p class="calibre1">Negated character classes</p>
<p class="calibre1">60</p>
<p class="calibre1">Examples of negated character classes</p>
<p class="calibre1">61</p>
<p class="calibre1">Predefined shorthand character classes</p>
<p class="calibre1">62</p>
<p class="calibre1">POSIX character classes</p>
<p class="calibre1">63</p>
<p class="calibre1">Unicode support in Java regular expressions</p>
<p class="calibre1">64</p>
<p class="calibre1">Commonly used Unicode character properties</p>
<p class="calibre1">65</p>
<p class="calibre1">Negation of the preceding regex directives</p>
<p class="calibre1">66</p>
<p class="calibre1">Unicode scripts support</p>
<p class="calibre1">67</p>
<p class="calibre1">Examples of matching Unicode text in regular</p>
<p class="calibre1">69</p>
<p class="calibre1">expressions</p>
<p class="calibre1">Double escaping in a Java String when defining regular</p>
<p class="calibre1">70</p>
<p class="calibre1">expressions</p>
<p class="calibre1">Embedded regular expression mode modifiers</p>
<p class="calibre1">71</p>
<p class="calibre1">The placement of embedded modes in a Java regular</p>
<p class="calibre1">73</p>
<p class="calibre1">expression</p>
<p class="calibre1">Disabling mode modifiers</p>
<p class="calibre1">74</p>
<p class="calibre1">Summary</p>
<p class="calibre1">75</p>
<p class="calibre1">Working with Groups, Capturing, and References</p>
<p class="calibre1">76</p>
<p class="calibre1">Capturing groups</p>
<p class="calibre1">77</p>
<p class="calibre1">Group numbering</p>
<p class="calibre1">78</p>
<p class="calibre1">Named groups</p>
<p class="calibre1">80</p>
<p class="calibre1">Non-capturing groups</p>
<p class="calibre1">81</p>
<p class="calibre1">Advantages of non-capturing groups</p>
<p class="calibre1">82</p>
<p class="calibre1">Back references</p>
<p class="calibre1">83</p>
<p class="calibre1">Back reference of a named group</p>
<p class="calibre1">85</p>
<p class="calibre1">Replacement reference of a named group</p>
<p class="calibre1">86</p>
<p class="calibre1">Forward references</p>
<p class="calibre1">87</p>
<p class="calibre1">Invalid (non-existing) backward or forward references</p>
<p class="calibre1">89</p>
<p class="calibre1">Summary</p>
<p class="calibre1">90</p>
<p class="calibre1">Regular Expression Programming Using Java String and</p>
<p class="calibre1">91</p>
<p class="calibre1">Scanner APIs</p>
<p class="calibre1">Introduction to the Java String API for regular expressions' </p>
<p class="calibre1">92</p>
<p class="calibre1">evaluation</p>
<p class="calibre1">Method - boolean matches(String regex)</p>
<p class="calibre1">93</p>
<p class="calibre1">Example of the matches method</p>
<p class="calibre1">94</p>
<p class="calibre1">Method - String replaceAll(String regex, String replacement) 96</p>
<p class="calibre1">Examples of the replaceAll method</p>
<p class="calibre1">97</p>
<p class="calibre1">Method - String replaceFirst(String regex, String replacement) 99</p>
<p class="calibre1">Examples of the replaceFirst method</p>
<p class="calibre1">100</p>
<p class="calibre1">Methods - String split methods</p>
<p class="calibre1">101</p>
<p class="calibre1"><a id="p196"/>The limit parameter rules</p>
<p class="calibre1">102</p>
<p class="calibre1">Examples of the split method</p>
<p class="calibre1">103</p>
<p class="calibre1">Example of the split method using the limit parameter</p>
<p class="calibre1">104</p>
<p class="calibre1">Using regular expressions in Java Scanner API</p>
<p class="calibre1">106</p>
<p class="calibre1">Summary</p>
<p class="calibre1">110</p>
<p class="calibre1">Introduction to Java Regular Expression APIs - Pattern and 111</p>
<p class="calibre1">Matcher Classes</p>
<p class="calibre1">The MatchResult interface</p>
<p class="calibre1">112</p>
<p class="calibre1">The Pattern class</p>
<p class="calibre1">114</p>
<p class="calibre1">Examples using the Pattern class</p>
<p class="calibre1">116</p>
<p class="calibre1">Filtering a list of tokens using the asPredicate() method 119</p>
<p class="calibre1">The Matcher class</p>
<p class="calibre1">120</p>
<p class="calibre1">Examples using the Matcher class</p>
<p class="calibre1">123</p>
<p class="calibre1">Method Boolean lookingAt()</p>
<p class="calibre1">124</p>
<p class="calibre1">The matches() method</p>
<p class="calibre1">125</p>
<p class="calibre1">The find() and find(int start) methods</p>
<p class="calibre1">126</p>
<p class="calibre1">The appendReplacement(StringBuffer sb, String replacement) 128</p>
<p class="calibre1">method</p>
<p class="calibre1">The appendTail(StringBuffer sb) method</p>
<p class="calibre1">129</p>
<p class="calibre1">Example of the appendReplacement and appendTail methods</p>
<p class="calibre1">130</p>
<p class="calibre1">Summary</p>
<p class="calibre1">132</p>
<p class="calibre1">Exploring Zero-Width Assertions, Lookarounds, and</p>
<p class="calibre1">133</p>
<p class="calibre1">Atomic Groups</p>
<p class="calibre1">Zero-width assertions</p>
<p class="calibre1">134</p>
<p class="calibre1">Predefined zero-width assertions</p>
<p class="calibre1">135</p>
<p class="calibre1">Regex defined zero-width assertions</p>
<p class="calibre1">136</p>
<p class="calibre1">\G boundary assertion</p>
<p class="calibre1">137</p>
<p class="calibre1">Atomic groups</p>
<p class="calibre1">139</p>
<p class="calibre1">Lookahead assertions</p>
<p class="calibre1">141</p>
<p class="calibre1">Positive lookahead</p>
<p class="calibre1">142</p>
<p class="calibre1">Negative lookahead</p>
<p class="calibre1">143</p>
<p class="calibre1">Lookbehind assertions</p>
<p class="calibre1">144</p>
<p class="calibre1">Positive lookbehind</p>
<p class="calibre1">145</p>
<p class="calibre1">Negative lookbehind</p>
<p class="calibre1">146</p>
<p class="calibre1">Capturing text from overlapping matches</p>
<p class="calibre1">151</p>
<p class="calibre1">Be careful with capturing groups inside a lookahead or</p>
<p class="calibre1">153</p>
<p class="calibre1">lookbehind atomic group</p>
<p class="calibre1">Lookbehind limitations in Java regular expressions</p>
<p class="calibre1">154</p>
<p class="calibre1">Summary</p>
<p class="calibre1">155</p>
<p class="calibre1">Understanding the Union, Intersection, and Subtraction of 156</p>
<p class="calibre1">Character Classes</p>
<p class="calibre1">The union of character classes</p>
<p class="calibre1">157</p>
<p class="calibre1"><a id="p197"/>The intersection of character classes</p>
<p class="calibre1">159</p>
<p class="calibre1">The subtraction of character classes</p>
<p class="calibre1">162</p>
<p class="calibre1">Why should you use composite character classes? </p>
<p class="calibre1">164</p>
<p class="calibre1">Summary</p>
<p class="calibre1">165</p>
<p class="calibre1">Regular Expression Pitfalls, Optimization, and Performance 166</p>
<p class="calibre1">Improvements</p>
<p class="calibre1">Common pitfalls and ways to avoid them while writing regular 167</p>
<p class="calibre1">expressions</p>
<p class="calibre1">Do not forget to escape regex metacharacters outside a character 168</p>
<p class="calibre1">class</p>
<p class="calibre1">Avoid escaping every non-word character</p>
<p class="calibre1">169</p>
<p class="calibre1">Avoid unnecessary capturing groups to reduce memory</p>
<p class="calibre1">170</p>
<p class="calibre1">consumption</p>
<p class="calibre1">However, don't forget to use the required group around</p>
<p class="calibre1">171</p>
<p class="calibre1">alternation</p>
<p class="calibre1">Use predefined character classes instead of longer versions 172</p>
<p class="calibre1">Use the limiting quantifier instead of repeating a character or 173</p>
<p class="calibre1">pattern multiple times</p>
<p class="calibre1">Do not use an unescaped hyphen in the middle of a character 174</p>
<p class="calibre1">class</p>
<p class="calibre1">The mistake of calling matcher.goup() without a prior call to 175</p>
<p class="calibre1">matcher.find(), matcher.matches(), or matcher.lookingAt() Do not use regular expressions to parse XML / HTML data</p>
<p class="calibre1">177</p>
<p class="calibre1">How to test and benchmark your regular expression performance 178</p>
<p class="calibre1">Catastrophic or exponential backtracking</p>
<p class="calibre1">179</p>
<p class="calibre1">How to avoid catastrophic backtracking</p>
<p class="calibre1">182</p>
<p class="calibre1">Optimization and performance enhancement tips</p>
<p class="calibre1">185</p>
<p class="calibre1">Use a compiled form of regular expressions</p>
<p class="calibre1">186</p>
<p class="calibre1">Use a negated character class instead of the greedy and slow .*</p>
<p class="calibre1">187</p>
<p class="calibre1">or .+</p>
<p class="calibre1">Avoid unnecessary grouping</p>
<p class="calibre1">188</p>
<p class="calibre1">Use lazy quantifiers strategically instead of greedy quantifiers 189</p>
<p class="calibre1">that cause excessive backtracking</p>
<p class="calibre1">Make use of possessive quantifiers to avoid backtracking</p>
<p class="calibre1">190</p>
<p class="calibre1">Extract common repeating substrings out of alternation</p>
<p class="calibre1">191</p>
<p class="calibre1">Use atomic group to avoid backtracking and fail fast</p>
<p class="calibre1">192</p>
<p class="calibre1">Summary</p>
<p class="calibre1">193</p>
<p class="calibre1"><a id="outline"/></p>

<h1 class="calibre5" id="calibre_pb_0">Document Outline</h1>
<ul class="calibre6">
<li class="calibre7"><a href="index_split_000.html#p16">Preface</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_000.html#p17">What this book covers</a></li>
<li class="calibre7"><a href="index_split_000.html#p18">What you need for this book</a></li>
<li class="calibre7"><a href="index_split_000.html#p19">Who this book is for</a></li>
<li class="calibre7"><a href="index_split_000.html#p20">Conventions</a></li>
<li class="calibre7"><a href="index_split_000.html#p21">Reader feedback</a></li>
<li class="calibre7"><a href="index_split_000.html#p22">Customer support</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p23">Downloading the example code</a></li>
<li class="calibre7"><a href="index_split_000.html#p24">Errata</a></li>
<li class="calibre7"><a href="index_split_000.html#p25">Piracy</a></li>
<li class="calibre7"><a href="index_split_000.html#p26">Questions</a></li>
</ul>
</li>
</ul>
</li>
<li class="calibre7"><a href="index_split_000.html#p27">Getting Started with Regular Expressions</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_000.html#p28">Introduction to regular expressions</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p29">A bit of history of regular expressions</a></li>
<li class="calibre7"><a href="index_split_000.html#p30">Various flavors of regular expressions</a></li>
<li class="calibre7"><a href="index_split_000.html#p31">What type of problems need regular expressions to solve</a></li>
<li class="calibre7"><a href="index_split_000.html#p32">The basic rules of regular expressions</a></li>
<li class="calibre7"><a href="index_split_000.html#p33">Constructs of the standard regular expression and meta characters</a></li>
<li class="calibre7"><a href="index_split_000.html#p36">Some basic regular expression examples</a></li>
<li class="calibre7"><a href="index_split_000.html#p38">Eager matching</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p39">The effect of eager matching on regular expression alternation</a></li>
</ul>
</li>
</ul>
</li>
<li class="calibre7"><a href="index_split_000.html#p41">Summary</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_000.html#p42">Understanding the Core Constructs of Java Regular Expressions</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_000.html#p43">Understanding the core constructs of regular expressions</a></li>
<li class="calibre7"><a href="index_split_000.html#p44">Quantifiers</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p45">Basic quantifiers</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p46">Examples using quantifiers</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_000.html#p47">Greedy versus reluctant (lazy) matching using quantifiers</a></li>
<li class="calibre7"><a href="index_split_000.html#p48">Possessive quantifiers</a></li>
<li class="calibre7"><a href="index_split_000.html#p50">Boundary constructs</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p51">Examples using boundary constructs</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_000.html#p52">Character classes</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p53">Examples of character classes</a></li>
<li class="calibre7"><a href="index_split_000.html#p54">Range inside a character class</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p55">Examples of character range</a></li>
</ul>
</li>
</ul>
</li>
<li class="calibre7"><a href="index_split_000.html#p56">Escaping special regex metacharacters and escaping rules inside the character classes</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p57">Escaping inside a character class</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p58">Examples of escaping rules inside the character class</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_000.html#p59">Literally matching a string that may contain special regex metacharacters</a></li>
<li class="calibre7"><a href="index_split_000.html#p60">Negated character classes</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p61">Examples of negated character classes</a></li>
</ul>
</li>
</ul>
</li>
<li class="calibre7"><a href="index_split_000.html#p62">Predefined shorthand character classes</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p63">POSIX character classes</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_000.html#p64">Unicode support in Java regular expressions</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p65">Commonly used Unicode character properties</a></li>
<li class="calibre7"><a href="index_split_000.html#p66">Negation of the preceding regex directives</a></li>
<li class="calibre7"><a href="index_split_000.html#p67">Unicode scripts support</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p69">Examples of matching Unicode text in regular expressions</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_000.html#p70">Double escaping in a Java String when defining regular expressions</a></li>
<li class="calibre7"><a href="index_split_000.html#p71">Embedded regular expression mode modifiers</a></li>
<li class="calibre7"><a href="index_split_000.html#p73">The placement of embedded modes in a Java regular expression</a></li>
<li class="calibre7"><a href="index_split_000.html#p74">Disabling mode modifiers</a></li>
</ul>
</li>
</ul>
</li>
<li class="calibre7"><a href="index_split_000.html#p75">Summary</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_000.html#p76">Working with Groups, Capturing, and References</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_000.html#p77">Capturing groups</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p78">Group numbering</a></li>
<li class="calibre7"><a href="index_split_000.html#p80">Named groups</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_000.html#p81">Non-capturing groups</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p82">Advantages of non-capturing groups</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_000.html#p83">Back references</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p85">Back reference of a named group</a></li>
<li class="calibre7"><a href="index_split_000.html#p86">Replacement reference of a named group</a></li>
<li class="calibre7"><a href="index_split_000.html#p87">Forward references</a></li>
<li class="calibre7"><a href="index_split_000.html#p89">Invalid (non-existing) backward or forward references</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_000.html#p90">Summary</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_000.html#p91">Regular Expression Programming Using Java String and Scanner APIs</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_000.html#p92">Introduction to the Java String API for regular expressions' evaluation</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p93">Method - boolean matches(String regex)</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p94">Example of the matches method</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_000.html#p96">Method - String replaceAll(String regex, String replacement)</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p97">Examples of the replaceAll method</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_000.html#p99">Method - String replaceFirst(String regex, String replacement)</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p100">Examples of the replaceFirst method</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_000.html#p101">Methods - String split methods</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p102">The limit parameter rules</a></li>
<li class="calibre7"><a href="index_split_000.html#p103">Examples of the split method</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_000.html#p104">Example of the split method using the limit parameter</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="calibre7"><a href="index_split_000.html#p106">Using regular expressions in Java Scanner API</a></li>
<li class="calibre7"><a href="index_split_001.html#p110">Summary</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_001.html#p111">Introduction to Java Regular Expression APIs - Pattern and Matcher Classes</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_001.html#p112">The MatchResult interface</a></li>
<li class="calibre7"><a href="index_split_001.html#p114">The Pattern class</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_001.html#p116">Examples using the Pattern class</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_001.html#p119">Filtering a list of tokens using the asPredicate() method</a></li>
</ul>
</li>
</ul>
</li>
<li class="calibre7"><a href="index_split_001.html#p120">The Matcher class</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_001.html#p123">Examples using the Matcher class</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_001.html#p124">Method Boolean lookingAt()</a></li>
<li class="calibre7"><a href="index_split_001.html#p125">The matches() method</a></li>
<li class="calibre7"><a href="index_split_001.html#p126">The find() and find(int start) methods</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_001.html#p128">The appendReplacement(StringBuffer sb, String replacement) method</a></li>
<li class="calibre7"><a href="index_split_001.html#p129">The appendTail(StringBuffer sb) method</a></li>
<li class="calibre7"><a href="index_split_001.html#p130">Example of the appendReplacement and appendTail methods</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_001.html#p132">Summary</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_001.html#p133">Exploring Zero-Width Assertions, Lookarounds, and Atomic Groups</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_001.html#p134">Zero-width assertions</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_001.html#p135">Predefined zero-width assertions</a></li>
<li class="calibre7"><a href="index_split_001.html#p136">Regex defined zero-width assertions</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_001.html#p137">\G boundary assertion</a></li>
<li class="calibre7"><a href="index_split_001.html#p139">Atomic groups</a></li>
<li class="calibre7"><a href="index_split_001.html#p141">Lookahead assertions</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_001.html#p142">Positive lookahead</a></li>
<li class="calibre7"><a href="index_split_001.html#p143">Negative lookahead</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_001.html#p144">Lookbehind assertions</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_001.html#p145">Positive lookbehind</a></li>
<li class="calibre7"><a href="index_split_001.html#p146">Negative lookbehind</a></li>
<li class="calibre7"><a href="index_split_001.html#p151">Capturing text from overlapping matches</a></li>
<li class="calibre7"><a href="index_split_001.html#p153">Be careful with capturing groups inside a lookahead or lookbehind atomic group</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_001.html#p154">Lookbehind limitations in Java regular expressions</a></li>
</ul>
</li>
</ul>
</li>
<li class="calibre7"><a href="index_split_001.html#p155">Summary</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_001.html#p156">Understanding the Union, Intersection, and Subtraction of Character Classes</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_001.html#p157">The union of character classes</a></li>
<li class="calibre7"><a href="index_split_001.html#p159">The intersection of character classes</a></li>
<li class="calibre7"><a href="index_split_001.html#p162">The subtraction of character classes</a></li>
<li class="calibre7"><a href="index_split_001.html#p164">Why should you use composite character classes? </a></li>
<li class="calibre7"><a href="index_split_001.html#p165">Summary</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_001.html#p166">Regular Expression Pitfalls, Optimization, and Performance Improvements</a>
<ul class="calibre8">
<li class="calibre7"><a href="index_split_001.html#p167">Common pitfalls and ways to avoid them while writing regular expressions</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_001.html#p168">Do not forget to escape regex metacharacters outside a character class</a></li>
<li class="calibre7"><a href="index_split_001.html#p169">Avoid escaping every non-word character</a></li>
<li class="calibre7"><a href="index_split_001.html#p170">Avoid unnecessary capturing groups to reduce memory consumption</a></li>
<li class="calibre7"><a href="index_split_001.html#p171">However, don't forget to use the required group around alternation</a></li>
<li class="calibre7"><a href="index_split_001.html#p172">Use predefined character classes instead of longer versions</a></li>
<li class="calibre7"><a href="index_split_001.html#p173">Use the limiting quantifier instead of repeating a character or pattern multiple times</a></li>
<li class="calibre7"><a href="index_split_001.html#p174">Do not use an unescaped hyphen in the middle of a character class</a></li>
<li class="calibre7"><a href="index_split_001.html#p175">The mistake of calling matcher.goup() without a prior call to matcher.find(), matcher.matches(), or matcher.lookingAt()</a></li>
<li class="calibre7"><a href="index_split_001.html#p177">Do not use regular expressions to parse XML / HTML data</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_001.html#p178">How to test and benchmark your regular expression performance</a></li>
<li class="calibre7"><a href="index_split_001.html#p179">Catastrophic or exponential backtracking</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_001.html#p182">How to avoid catastrophic backtracking</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_001.html#p185">Optimization and performance enhancement tips</a>
<ul class="calibre9">
<li class="calibre7"><a href="index_split_001.html#p186">Use a compiled form of regular expressions</a></li>
<li class="calibre7"><a href="index_split_001.html#p187">Use a negated character class instead of the greedy and slow .* or .+</a></li>
<li class="calibre7"><a href="index_split_001.html#p188">Avoid unnecessary grouping</a></li>
<li class="calibre7"><a href="index_split_001.html#p189">Use lazy quantifiers strategically instead of greedy quantifiers that cause excessive backtracking</a></li>
<li class="calibre7"><a href="index_split_001.html#p190">Make use of possessive quantifiers to avoid backtracking</a></li>
<li class="calibre7"><a href="index_split_001.html#p191">Extract common repeating substrings out of alternation</a></li>
<li class="calibre7"><a href="index_split_001.html#p192">Use atomic group to avoid backtracking and fail fast</a></li>
</ul>
</li>
<li class="calibre7"><a href="index_split_001.html#p193">Summary</a></li>
</ul>
</li>
</ul><p class="calibre1"/>


</body></html>