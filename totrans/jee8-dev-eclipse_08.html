<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating Web Services</h1>
                
            
            <article>
                
<p class="calibre3">In the last chapter, we learned how to create web applications in Java using MVC frameworks. In this chapter, we will learn how to implement web services in Java. </p>
<p class="calibre3">We will cover<span class="calibre12"> the</span> following topics:</p>
<ul class="calibre10">
<li class="calibre11">Java object binding and serialization using JAXB and JSON-B</li>
<li class="calibre11">Implementing and consuming RESTful web services</li>
<li class="calibre11">Implementing and consuming SOAP web services</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What is a web service?</h1>
                
            
            <article>
                
<p class="calibre3">In <a target="_blank" href="part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter</span> <span>7</span></a>, <em class="calibre21">Creating JEE Applications with EJB</em>, we learned that EJBs can be used to create distributed applications. EJBs can act as glue and help different JEE applications in the enterprise to communicate with each other. However, what if the enterprise wants to let its partners or customers make use of some of the application functionality? For example, an airline might want to let its partners make online reservations.</p>
<p class="calibre3">One option is for the partner to redirect its customers to the airline website, but this would not provide a unified experience to users. A better way to handle this would be for the airline to expose its reservation APIs to partners, who can integrate these APIs into their own applications, providing a unified user experience. This is an example of a distributed application, and EJBs can be used for this.</p>
<p class="calibre3">However, for EJBs to work in such scenarios, where API calls cross enterprise boundaries, the clients of the APIs also need to be implemented in Java. As we know, this is not practical. Some of the airline partners in this example may have their applications implemented using different programming platforms, such as .NET and PHP.</p>
<p class="calibre3">Web services are useful in situations such as the one mentioned here. Web services are self-contained APIs that are based on open standards and are platform independent. They are widely used for communication between disparate systems. There are mainly two types of web service implementations:</p>
<ul class="calibre10">
<li class="calibre11">Simple Object Access Protocol (SOAP)-based</li>
<li class="calibre11">Representational State Transfer (RESTful) services</li>
</ul>
<p class="calibre3">For many years, SOAP-based web services were quite popular, but recently, RESTful services have been gaining ground because of the simplicity in their implementation and consumption.</p>
<p class="calibre3">Web services provide a common integration platform and offer <strong class="calibre5">service-oriented architecture</strong> (<strong class="calibre5">SOA</strong>) in which certain components expose services for consumption by other components or applications. The consumer of such services can create an entire application by assembling a number of such loosely coupled services, possibly from different sources.</p>
<p class="calibre3">In this chapter, we will see how to develop and consume both SOAP and RESTful services by using JEE and Eclipse. However, first it would be useful to understand how to convert Java objects to XML and JSON, and vice versa, because both REST and SOAP web service implementations need to perform these operations. <span class="calibre12">First, we will take a look at</span><span class="calibre12"> </span><span class="calibre12">JAXB, Java XML binding, using which you can bind Java objects to both XML and JSON. Then we will take a look at JSON-B (a new specification added in JEE 8) for Java JSON binding.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">JAXB</h1>
                
            
            <article>
                
<p class="calibre3">JAXB provides an easy way to convert XML or JSON representations of data into Java objects and vice versa. Using simple annotations, you can have a JAXB implementation create XML or JSON data from a Java object or create a Java object from XML or JSON.</p>
<div class="packt_infobox"><br class="calibre26"/>
To understand how Java data types are mapped to XML schema types in JAXB, refer to <a href="https://docs.oracle.com/javase/tutorial/jaxb/intro/bind.html" class="calibre17"><span class="calibre23">https://docs.oracle.com/javase/tutorial/jaxb/intro/bind.html</span></a>.</div>
<p class="calibre3">The following are a few important JAXB annotations:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre13">@XmlRootElement</kbd>: This annotation specifies<span> the</span> root element of the XML document and is typically used at the class level.</li>
<li class="calibre11"><kbd class="calibre13">@XmlElement</kbd>: This annotation specifies an XML element that is not a root element. Java class members can be marked as <kbd class="calibre13">XMLElement</kbd> when the class is annotated with <kbd class="calibre13">@XmlRootElement</kbd>.</li>
<li class="calibre11"><kbd class="calibre13">@XmlAttribute</kbd>: This annotation marks a member of the Java class as an attribute of the parent XML element.</li>
<li class="calibre11"><kbd class="calibre13">@XmlAccessorType</kbd>: This annotation is specified at the class level. It lets you control how class fields are serialized to XML or JSON. Valid values are <kbd class="calibre13">XmlAccessType.FIELD</kbd> (every non-static and non-<kbd class="calibre13">@XmlTransient</kbd> field is serialized), <kbd class="calibre13">XmlAccessType.PROPERTY</kbd> (every pair of getter/setter that is not annotated with <kbd class="calibre13">@XmlTransient</kbd> is serialized), <kbd class="calibre13">XmlAccessType.NONE</kbd> (no fields are serialized, unless specific fields are annotated for serialization), and <kbd class="calibre13">XmlAccessType.PUBLIC_MEMBER</kbd> (all public getter/setter pairs are serialized, unless annotated with <kbd class="calibre13">@XmlTransient</kbd>).</li>
<li class="calibre11"><kbd class="calibre13">@XMLTransient</kbd>: This annotation specifies a member or getter/setter pair that is not to be serialized.</li>
</ul>
<div class="packt_tip"><br class="calibre26"/>
For the complete list of JAXB annotations, refer to <span class="calibre23"><a href="https://jaxb.java.net/tutorial/section_6_1-JAXB-Annotations.html#JAXB" class="calibre17">https://jaxb.java.net/tutorial/section_6_1-JAXB-Annotations.html#JAXB</a></span>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">A JAXB example</h1>
                
            
            <article>
                
<p class="calibre3">Let's create a Maven project to try out JAXB APIs. Select the <span class="calibre12">File</span> | <span class="calibre12">Maven Project</span> menu:</p>
<div class="mce-root1"><img src="../images/00188.jpeg" class="calibre198"/></div>
<div class="packt_figure1">Figure 9.1: Create a Maven project for a JAXB example</div>
<p class="calibre3">Make sure that the project is configured to use JRE 1.7 or later. Let's now create two classes, <kbd class="calibre13">Course</kbd> and <kbd class="calibre13">Teacher</kbd>. We want to serialize instances of these classes to XML and back. Create these classes in the <kbd class="calibre13">packt.jee.eclipse.jaxb.example</kbd> package. Here is the source code of<span class="calibre12"> the</span> <kbd class="calibre13">Course</kbd> class:</p>
<pre class="calibre25">package packt.jee.eclipse.jaxb.example; 
//Skipped imports 
 
@XmlRootElement 
@XmlAccessorType(XmlAccessType.FIELD) 
public class Course { 
  @XmlAttribute 
  private int id; 
  @XmlElement(namespace="http://packt.jee.eclipse.jaxb.example") 
  private String name; 
  private int credits; 
  @XmlElement(name="course_teacher") 
  private Teacher teacher; 
 
  public Course() {} 
 
  public Course (int id, String name, int credits) { 
    this.id = id; 
    this.name = name; 
    this.credits = credits; 
  } 
 
  //Getters and setters follow 
} </pre>
<p class="calibre3">When a <kbd class="calibre13">Course</kbd> is marshalled to an XML document, we want<span class="calibre12"> the</span> <kbd class="calibre13">course</kbd> element to be the root. Therefore, the class is annotated with <kbd class="calibre13">@XmlRootElement</kbd>.</p>
<div class="packt_tip"><br class="calibre26"/>
Marshalling is the process of writing the data, typically an object, to a format link XML or JSON. Unmarshalling is the process of reading the data from a format and creating an object.</div>
<p class="calibre3">You can specify a different name for the root element (other than the class name) by specifying the <kbd class="calibre13">name</kbd> attribute, for example:</p>
<pre class="calibre25">@XmlRootElement(name="school_course") </pre>
<p class="calibre3">The <kbd class="calibre13">id</kbd> field is marked as an attribute of the root element. You don't have to mark fields specifically as elements if there are public getters/setters for them. However, if you want to set additional attributes, then you need to annotate them with <kbd class="calibre13">@XmlElement</kbd>. For example, we have specified a namespace for<span class="calibre12"> the</span> <kbd class="calibre13">name</kbd> field. The <kbd class="calibre13">credits</kbd> field is not annotated, but it will still be marshalled as an XML element.</p>
<p class="calibre3">Here is the source code for<span class="calibre12"> the</span> <kbd class="calibre13">Teacher</kbd> class:</p>
<pre class="calibre25">package packt.jee.eclipse.jaxb.example; 
 
public class Teacher { 
  private int id; 
  private String name; 
 
  public Teacher() {} 
 
  public Teacher (int id, String name) { 
    this.id = id; 
    this.name = name; 
  } 
 
  //Getters and setters follow 
} </pre>
<p class="calibre3">We are not annotating<span class="calibre12"> the</span> <kbd class="calibre13">Teacher</kbd> class for JAXB because we are not going to marshal it directly. It will be marshalled by JAXB when an instance of <kbd class="calibre13">Course</kbd> is marshalled.</p>
<p class="calibre3">Let's create<span class="calibre12"> the</span> <span class="calibre12"><kbd class="calibre13">JAXBExample</kbd> </span>class with the <kbd class="calibre13">main</kbd> method:</p>
<pre class="calibre25">package packt.jee.eclipse.jaxb.example; 
 
//Skipped imports 
 
public class JAXBExample { 
 
  public static void main(String[] args) throws Exception { 
    doJAXBXml(); 
 
  } 
 
  //Create XML from Java object and then vice versa 
  public static void doJAXBXml() throws Exception { 
    Course course = new Course(1,"Course-1", 5); 
    course.setTeacher(new Teacher(1, "Teacher-1")); 
 
    JAXBContext context = JAXBContext.newInstance(Course.class); 
 
    //Marshall Java object to XML 
    Marshaller marshaller = context.createMarshaller(); 
    //Set option to format generated XML 
    marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, <br class="title-page-name"/>     true); 
    StringWriter stringWriter = new StringWriter(); 
    //Marshal Course object and write to the StringWriter 
    marshaller.marshal(course, stringWriter); 
    //Get String from the StringWriter 
    String courseXml = stringWriter.getBuffer().toString(); 
    stringWriter.close(); 
    //Print course XML 
    System.out.println(courseXml); 
 
    //Now unmarshall courseXML to create Course object 
    Unmarshaller unmarshaller = context.createUnmarshaller(); 
    //Create StringReader from courseXml 
    StringReader stringReader = new StringReader(courseXml); 
    //Create StreamSource which will be used by JAXB unmarshaller 
    StreamSource streamSource = new StreamSource(stringReader); 
    Course unmarshalledCourse = <br class="title-page-name"/>     unmarshaller.unmarshal(streamSource, Course.class).getValue();    <br class="title-page-name"/>     System.out.println("-----------------nUnmarshalled course name - " 
        + unmarshalledCourse.getName()); 
    stringReader.close(); 
   } 
} </pre>
<p class="calibre3">To marshal or unmarshal using JAXB, we first create <kbd class="calibre13">JAXBContext</kbd>, passing it a Java class that needs to be worked on. Then, we create the marshaller or unmarshaller, set the relevant properties, and perform the operation. The code is quite simple. We first marshal the <kbd class="calibre13">Course</kbd> instance to XML, and then use the same XML output to unmarshal it back to a <kbd class="calibre13">Course</kbd> instance. Right-click on the class and select <span class="calibre12">Run As</span> | <span class="calibre12">Java Application</span>. You should see the following output in the console:</p>
<pre class="calibre25">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt; 
&lt;course id="1" &gt; 
    &lt;ns2:name&gt;Course-1&lt;/ns2:name&gt; 
    &lt;credits&gt;5&lt;/credits&gt; 
    &lt;course_teacher&gt; 
        &lt;id&gt;1&lt;/id&gt; 
        &lt;name&gt;Teacher-1&lt;/name&gt; 
    &lt;/course_teacher&gt; 
&lt;/course&gt; 
 
----------------- 
Unmarshalled course name - Course-1 </pre>
<p class="calibre3">Let's now see how to marshal a Java object to JSON and back. JSON support in JAXB is not available out of the box in JDK. We will have to use an external library that supports JAXB APIs with JSON. One such library is EclipseLink MOXy (<a href="https://eclipse.org/eclipselink/#moxy" class="calibre9"><span>https://eclipse.org/eclipselink/#moxy</span></a>). We will use this library to marshal an instance of <kbd class="calibre13">Course</kbd> to JSON.</p>
<p class="calibre3">Open <kbd class="calibre13">pom.xml</kbd> and add the dependency on EclipseLink:</p>
<pre class="calibre25">  &lt;dependencies&gt; 
    &lt;dependency&gt; 
      &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt; 
      &lt;artifactId&gt;eclipselink&lt;/artifactId&gt; 
      &lt;version&gt;2.6.1-RC1&lt;/version&gt; 
    &lt;/dependency&gt; 
  &lt;/dependencies&gt; </pre>
<p class="calibre3">We also need to set<span class="calibre12"> the</span> <kbd class="calibre13">javax.xml.bind.context.factory</kbd> property to make<span class="calibre12"> the</span> JAXB implementation use EclipseLink's <kbd class="calibre13">JAXBContextFactory</kbd>. Create the <kbd class="calibre13">jaxb.properties</kbd> file in the same package as the classes whose instances are to be marshalled. In this case, create the file in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.eclipse.jaxb.example</kbd> package. Set the following property in this file:</p>
<pre class="calibre25">javax.xml.bind.context.factory=org.eclipse.persistence.jaxb.JAXBContextFactory </pre>
<p class="calibre3">This is very important. If you do not set this property, then the example won't work. Next, open <kbd class="calibre13">JAXBExample.java</kbd> and add the following method:</p>
<pre class="calibre25">  //Create JSON from Java object and then vice versa 
  public static void doJAXBJson() throws Exception { 
 
    Course course = new Course(1,"Course-1", 5); 
    course.setTeacher(new Teacher(1, "Teacher-1")); 
 
    JAXBContext context = JAXBContext.newInstance(Course.class); 
 
    //Marshal Java object to JSON 
    Marshaller marshaller = context.createMarshaller(); 
    //Set option to format generated JSON 
    marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, <br class="title-page-name"/>     true);    marshaller.setProperty(MarshallerProperties.MEDIA_TYPE, <br class="title-page-name"/>     "application/json");    marshaller.setProperty(MarshallerProperties.JSON_INCLUDE_ROOT, <br class="title-page-name"/>     true); 
 
    StringWriter stringWriter = new StringWriter(); 
    //Marshal Course object and write to the StringWriter 
    marshaller.marshal(course, stringWriter); 
    //Get String from the StringWriter 
    String courseJson = stringWriter.getBuffer().toString(); 
    stringWriter.close(); 
    //Print course JSON 
    System.out.println(courseJson); 
 
    //Now, unmarshall courseJson to create Course object 
    Unmarshaller unmarshler = context.createUnmarshaller(); 
    unmarshler.setProperty(MarshallerProperties.MEDIA_TYPE, <br class="title-page-name"/>     "application/json");    unmarshler.setProperty(MarshallerProperties.JSON_INCLUDE_ROOT, <br class="title-page-name"/>     true); 
 
    //Create StringReader from courseJson 
    StringReader stringReader = new StringReader(courseJson); 
    //Create StreamSource which will be used by JAXB unmarshaller 
    StreamSource streamSource = new StreamSource(stringReader); 
    Course unmarshalledCourse = unmarshler.unmarshal(streamSource, <br class="title-page-name"/>     Course.class).getValue();    <br class="title-page-name"/>    System.out.println("-----------------nUnmarshalled course name - " + unmarshalledCourse.getName()); 
    stringReader.close(); 
  } </pre>
<p class="calibre3">Much of the code is the same as in<span class="calibre12"> the</span> <kbd class="calibre13">doJAXBXml</kbd> method. Specific changes are as follows:</p>
<ul class="calibre10">
<li class="calibre11">We set the <kbd class="calibre13">marshaller</kbd> property for generating the JSON output (<kbd class="calibre13">application/json</kbd>)</li>
<li class="calibre11">We set another <kbd class="calibre13">marshaller</kbd> property to include the JSON root in the output</li>
<li class="calibre11">We set the corresponding properties on <kbd class="calibre13">unmarshaller</kbd></li>
</ul>
<p class="calibre3">Modify the main method to call <kbd class="calibre13">doJAXBJson</kbd>, instead of <kbd class="calibre13">doJAXBXml</kbd>. When you run the application, you should see the following output:</p>
<pre class="calibre25">{ 
   "course" : { 
      "id" : 1, 
      "name" : "Course-1", 
      "credits" : 5, 
      "course_teacher" : { 
         "id" : 1, 
         "name" : "Teacher-1" 
      } 
   } 
} 
----------------- 
Unmarshalled course name - Course-1 </pre>
<div class="packt_tip"><br class="calibre26"/>
We have covered the basics of JAXB in this chapter. For a detailed tutorial on JAXB, refer to <a href="https://docs.oracle.com/javase/tutorial/jaxb/intro/index.html" class="calibre17"><span class="calibre23">https://docs.oracle.com/javase/tutorial/jaxb/intro/index.html</span></a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">JSON-B</h1>
                
            
            <article>
                
<p class="calibre3">JSON-B is a new specification included in JEE 8. Using a simple annotation you can convert Java objects to JSON and vice versa. JSON-B has one important annotation, <kbd class="calibre13">@JsonProperty</kbd>. Specifying this annotation for a class member marks it for serialization to or from JSON.</p>
<p class="calibre3">JSON-B provides<span class="calibre12"> the</span> <kbd class="calibre13">JsonbBuilder</kbd><span class="calibre12"> </span>class, using which you can perform actual serialization. Let's learn how to use JSON-B with a simple application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">A JSON-B example</h1>
                
            
            <article>
                
<p class="calibre3">Let's create a Maven project, with <span class="calibre12">Group Id</span> as <span class="calibre12"><span class="calibre12">JAXBExample</span> and <span class="calibre12">Artifact Id</span> as <span class="calibre12">JSONBExampleProject</span>. JSON-B is not a part of the JDK, so we will need to add Maven dependencies for libraries that provide JSON-B APIs and their implementation. In this example, we will use Eclipse's Yasson (<a href="https://projects.eclipse.org/projects/ee4j.yasson" class="calibre9">https://projects.eclipse.org/projects/ee4j.yasson</a>) implementation of JSON-B. We will add the following dependencies in <kbd class="calibre13">pom.xml</kbd>:</span></p>
<pre class="calibre25"><span><span>  <span> </span></span></span><span>&lt;</span>dependency<span>&gt;<br class="title-page-name"/></span><span>  <span> </span><span> </span></span><span>&lt;</span><span>groupId</span><span>&gt;</span>javax.json.bind<span>&lt;/</span><span>groupId</span><span>&gt;<br class="title-page-name"/></span><span>  <span> </span><span> </span></span><span>&lt;</span><span>artifactId</span><span>&gt;</span>javax.json.bind-<span>api</span><span>&lt;/</span><span>artifactId</span><span>&gt;<br class="title-page-name"/></span><span><span>  <span> </span><span> </span></span></span><span>&lt;</span>version<span>&gt;</span><span>1.0</span><span>&lt;/</span>version<span>&gt;<br class="title-page-name"/></span><span><span>  <span> </span></span></span><span>&lt;/</span>dependency<span>&gt;<br class="title-page-name"/><br class="title-page-name"/></span><span><span>  <span> </span></span></span><span>&lt;</span>dependency<span>&gt;<br class="title-page-name"/></span><span>  <span> </span><span> </span></span><span>&lt;</span><span>groupId</span><span>&gt;</span>org.eclipse<span>&lt;/</span><span>groupId</span><span>&gt;<br class="title-page-name"/></span><span><span>  <span> </span><span> </span></span></span><span>&lt;</span>artifactId<span>&gt;</span><span>yasson</span><span>&lt;/</span>artifactId<span>&gt;<br class="title-page-name"/></span><span><span>  <span> </span><span> </span></span></span><span>&lt;</span>version<span>&gt;</span><span>1.0.1</span><span>&lt;/</span>version<span>&gt;<br class="title-page-name"/></span><span><span>  <span> </span></span></span><span>&lt;/</span>dependency<span>&gt;<br class="title-page-name"/><br class="title-page-name"/></span><span><span>  <span> </span></span></span><span>&lt;</span>dependency<span>&gt;<br class="title-page-name"/></span><span>  <span> </span><span> </span></span><span>&lt;</span><span>groupId</span><span>&gt;</span>org.glassfish<span>&lt;/</span><span>groupId</span><span>&gt;<br class="title-page-name"/></span><span><span>  <span> </span><span> </span></span></span><span>&lt;</span>artifactId<span>&gt;</span><span>javax.json</span><span>&lt;/</span>artifactId<span>&gt;<br class="title-page-name"/></span><span><span>  <span> </span><span> </span></span></span><span>&lt;</span>version<span>&gt;</span><span>1.1.2</span><span>&lt;/</span>version<span>&gt;<br class="title-page-name"/></span><span><span>  <span> </span></span></span><span>&lt;/</span>dependency<span>&gt;<br class="title-page-name"/></span><span><span>  </span></span><span>&lt;/</span>dependencies<span>&gt;</span></pre>
<p class="calibre3">Dependency on <kbd class="calibre13">javax.json</kbd> from GlassFish is added because<span class="calibre12"> the</span> <kbd class="calibre13">yasson</kbd> implementation depends on its JSON-P implementation.</p>
<p class="calibre3"><span class="calibre12">Let's now create the <kbd class="calibre13">Course</kbd> and <kbd class="calibre13">Teacher</kbd> classes as we created them in the previous section for JAXB, but with JSON-B annotations. Create both classes in </span><span class="calibre12">the</span><span class="calibre12"> </span><kbd class="calibre13">packt.jee.eclipse.jsonb.example</kbd> <span class="calibre12">package. Here is the source code for<span class="calibre12"> the</span></span> <kbd class="calibre13">Course</kbd> <span class="calibre12">class:</span></p>
<pre class="calibre25">package packt.jee.eclipse.jsonb.example;<br class="title-page-name"/>import javax.json.bind.annotation.JsonbProperty;<br class="title-page-name"/><br class="title-page-name"/>public class Course {<br class="title-page-name"/> @JsonbProperty<br class="title-page-name"/> private int id;<br class="title-page-name"/> <br class="title-page-name"/> @JsonbProperty<br class="title-page-name"/> private String name;<br class="title-page-name"/> <br class="title-page-name"/> @JsonbProperty<br class="title-page-name"/> private int credits;<br class="title-page-name"/> <br class="title-page-name"/> @JsonbProperty("course_teacher")<br class="title-page-name"/> private Teacher teacher;<br class="title-page-name"/><br class="title-page-name"/> //skipped constructors, getters and setters to save space<br class="title-page-name"/>}</pre>
<p class="calibre3">We have annotated members of<span class="calibre12"> the</span> <kbd class="calibre13">Course</kbd> class with <kbd class="calibre13">@JsonbProperty</kbd>. If you want to change<span class="calibre12"> the</span> name of the field in JSON then you can specify it as a parameter to <kbd class="calibre13">@JsonbProperty</kbd>; for example, in the previous code we are mapping<span class="calibre12"> the</span> <kbd class="calibre13">teacher</kbd> field to<span class="calibre12"> the</span> <kbd class="calibre13">course_teacher</kbd> name in JSON.</p>
<p class="calibre3">The <kbd class="calibre13">Teacher</kbd> class is the same as the one we created in the section for JAXB. Let's now create the main application class, called <kbd class="calibre13">JSONBExample</kbd>, in which we will convert an instance of <kbd class="calibre13">Course</kbd> to <kbd class="calibre13">String</kbd> and then from <kbd class="calibre13">String</kbd> back to an instance of the <kbd class="calibre13">Course</kbd> object:</p>
<pre class="calibre25">package packt.jee.eclipse.jsonb.example;<br class="title-page-name"/>import javax.json.bind.Jsonb;<br class="title-page-name"/>import javax.json.bind.JsonbBuilder;<br class="title-page-name"/>public class JSONBExample {<br class="title-page-name"/>  public static void main(String[] args) throws Exception {<br class="title-page-name"/>    Course course = new Course(1,"Course-1", 5);<br class="title-page-name"/>    course.setTeacher(new Teacher(1, "Teacher-1"));<br class="title-page-name"/> <br class="title-page-name"/>    // Serialize to JSON string<br class="title-page-name"/>    Jsonb jsonb = JsonbBuilder.create();<br class="title-page-name"/>    String courseJson = jsonb.toJson(course, Course.class);<br class="title-page-name"/>    System.out.println(courseJson);<br class="title-page-name"/> <br class="title-page-name"/>    // De-serialize fromd JSON string<br class="title-page-name"/>    Course deserializedCourse = jsonb.fromJson(courseJson, Course.class);<br class="title-page-name"/>    System.out.println(deserializedCourse.getName());<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre3">To serialize an instance of<span class="calibre12"> the</span> <kbd class="calibre13">Course</kbd> class, we are first creating an instance of <kbd class="calibre13">JsonBuilder</kbd> and then calling<span class="calibre12"> the</span> <kbd class="calibre13">toJson</kbd> method on that. To de-serialize<span class="calibre12"> the</span> JSON representation of<span class="calibre12"> the</span> <kbd class="calibre13">Course</kbd> class from String, we are calling <kbd class="calibre13">fromJson</kbd> on the same instance of <kbd class="calibre13">JsonBuilder</kbd>. If you run the application, you should see a JSON string for the course object we created.</p>
<div class="packt_tip"><br class="calibre26"/>
For further details on JSON-B, refer to <a href="http://json-b.net/index.html" class="calibre17">http://json-b.net/index.html.</a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">RESTful web services</h1>
                
            
            <article>
                
<p class="calibre3">We will start learning web services with RESTful services because they are widely used and are easy to implement. REST is not necessarily a protocol but an architectural style, and is typically based on HTTP. RESTful web services act on resources on the server, and actions are based on HTTP methods (<kbd class="calibre13">Get</kbd>, <kbd class="calibre13">Post</kbd>, <kbd class="calibre13">Put</kbd>, and <kbd class="calibre13">Delete</kbd>). The state of resources is transferred over HTTP in either XML or JSON format, although JSON is more popular. Resources on the server are identified by URLs. For example, to get details of a course with ID <kbd class="calibre13">10</kbd>, you can use the HTTP <kbd class="calibre13">GET</kbd> method with the following URL: <kbd class="calibre13">http://&lt;server_address&gt;:&lt;port&gt;/course/10</kbd>. Notice that the parameter is part of the base URL. To add a new <kbd class="calibre13">Course</kbd> or modify a <kbd class="calibre13">Course</kbd>, you can use either <kbd class="calibre13">POST</kbd> or <kbd class="calibre13">PUT</kbd> methods. Furthermore,<span class="calibre12"> the</span> <kbd class="calibre13">DELETE</kbd> method can be used to delete a <kbd class="calibre13">Course</kbd> by using the same URL as that used for getting the course, that is, <kbd class="calibre13">http://&lt;server_address&gt;:&lt;port&gt;/course/10</kbd>.</p>
<p class="calibre3">Resource URLs in RESTful web services can be nested too; for example, to get all courses in a particular department (with, say, an ID of <kbd class="calibre13">20</kbd>), the REST URL can be as follows: <kbd class="calibre13">http://&lt;server_address&gt;:&lt;port&gt;/department/20/courses</kbd>.</p>
<div class="packt_infobox"><br class="calibre26"/>
Refer to <a href="https://en.wikipedia.org/wiki/Representational_state_transfer" class="calibre17"><span class="calibre23">https://en.wikipedia.org/wiki/Representational_state_transfer</span></a> for more details on the properties of RESTful web services and HTTP methods used for acting on REST resources on the server.</div>
<p class="calibre3">The Java specification for working with RESTful web services is called JAX-RS, Java API for RESTful services (<a href="https://jax-rs-spec.java.net/" class="calibre9"><span>https://jax-rs-spec.java.net/</span></a>). Project Jersey (<a href="https://jersey.java.net/" class="calibre9"><span>https://jersey.java.net/</span></a>) is the reference implementation of this specification. We will use this reference implementation this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating RESTful web services using Jersey</h1>
                
            
            <article>
                
<p class="mce-root">We will create a web service for the <em class="calibre21">Course Management</em> example that we have been developing in this book. The web service will have methods to get all courses and create a new course. To keep the example simple, we will not write the data access code (you can use the JDBC or JDO APIs that we learned in previous chapters), but will hardcode the data.</p>
<p class="calibre3">First, create a Maven web project. Select <span class="calibre12">File</span> | <span class="calibre12">New</span> | <span class="calibre12">Maven Project</span>. Select the <span class="calibre12">Create a Simple Project</span> checkbox on the first page of the wizard and click <span class="calibre12">Next</span>:</p>
<div class="mce-root1"><br class="title-page-name"/>
<img src="../images/00189.jpeg" class="calibre199"/></div>
<div class="packt_figure1">Figure 9.2: Create a Maven project for a RESTful web service</div>
<p class="calibre3">Enter the project configuration details and click <span class="calibre12">Finish</span>. Make sure that the packaging is <kbd class="calibre13">war</kbd>.</p>
<p class="calibre3">Since we are going to use the <kbd class="calibre13">Jersey</kbd> library for the JAX-RS implementation, we will add its Maven dependency into the project. Open <kbd class="calibre13">pom.xml</kbd> and add the following dependency:</p>
<pre class="calibre25">  &lt;dependencies&gt; 
    &lt;dependency&gt; 
      &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt; 
      &lt;artifactId&gt;jersey-container-servlet&lt;/artifactId&gt; 
      &lt;version&gt;2.26&lt;/version&gt; 
    &lt;/dependency&gt; 
  &lt;/dependencies&gt; </pre>
<p class="calibre3">Using<span class="calibre12"> the</span> JAX-RS <kbd class="calibre13">@Path</kbd> annotation, we can convert any Java class into a REST resource. The value passed to<span class="calibre12"> the</span> <kbd class="calibre13">@Path</kbd> annotation is a relative URI of the resource. Methods in the implementation class, to be executed for different HTTP methods, are annotated with one of the following annotations: <kbd class="calibre13">@GET</kbd>, <kbd class="calibre13">@PUT</kbd>, <kbd class="calibre13">@POST</kbd>, or <kbd class="calibre13">@DELETE</kbd>. The <kbd class="calibre13">@Path</kbd> annotation can also be used at<span class="calibre12"> the</span> method level for a sub-resource path (the main resource or the root resource path is at the class level, again using<span class="calibre12"> the</span> <kbd class="calibre13">@Path</kbd> annotation). We can also specify the MIME type that previous methods produce/consume by using<span class="calibre12"> the</span> <kbd class="calibre13">@Produces</kbd> or <kbd class="calibre13">@Consumes</kbd> annotations, respectively.</p>
<p class="calibre3">Before we create a web service implementation class, let's create some utility classes, more specifically in this case DTOs.</p>
<p class="calibre3">Create<span class="calibre12"> the</span> <kbd class="calibre13">Course</kbd> and <kbd class="calibre13">Teacher</kbd> classes in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.eclipse.rest.ws.dto</kbd> package. We will also annotate them with the JAXB annotations. Here is the source code for<span class="calibre12"> the</span> <kbd class="calibre13">Teacher</kbd> class:</p>
<pre class="calibre25">package packt.jee.eclipse.rest.ws.dto; 
 
import javax.xml.bind.annotation.XmlAccessType; 
import javax.xml.bind.annotation.XmlAccessorType; 
import javax.xml.bind.annotation.XmlAttribute; 
import javax.xml.bind.annotation.XmlElement; 
import javax.xml.bind.annotation.XmlRootElement; 
 
@XmlRootElement 
@XmlAccessorType(XmlAccessType.FIELD) 
public class Teacher { 
 
  @XmlAttribute 
  private int id; 
 
  @XmlElement(name="teacher_name") 
  private String name; 
 
  //constructors 
  public Course() {} 
 
  public Course (int id, String name, int credits, Teacher <br class="title-page-name"/>   teacher) { 
    this.id = id; 
    this.name = name; 
    this.credits = credits; 
    this.teacher = teacher; 
  } 
 
  //Getters and setters follow 
} </pre>
<p class="calibre3">The following is the source code for<span class="calibre12"> the</span> <kbd class="calibre13">Course</kbd> class, which we will use for marshalling to XML and JSON in the subsequent sections:</p>
<pre class="calibre25">package packt.jee.eclipse.rest.ws.dto; 
 
import javax.xml.bind.annotation.XmlAccessType; 
import javax.xml.bind.annotation.XmlAccessorType; 
import javax.xml.bind.annotation.XmlAttribute; 
import javax.xml.bind.annotation.XmlElement; 
import javax.xml.bind.annotation.XmlRootElement; 
 
@XmlRootElement 
@XmlAccessorType(XmlAccessType.FIELD) 
public class Course { 
 
  @XmlAttribute 
  private int id; 
 
  @XmlElement(name="course_name") 
  private String name; 
 
  private int credits; 
 
  private Teacher teacher; 
 
  //constructors 
  public Teacher() {} 
 
  public Teacher (int id, String name) { 
    this.id = id; 
    this.name = name; 
  } 
 
  //Getters and setters follow 
} </pre>
<p class="calibre3">We have annotated<span class="calibre12"> the</span> <kbd class="calibre13">id</kbd> fields in both classes as <kbd class="calibre13">@XMLAttribute</kbd>. If objects of these classes are marshalled (converted from Java objects) to XML, <kbd class="calibre13">Course id</kbd> and <kbd class="calibre13">Teacher id</kbd> would be attributes (instead of elements) of the root element (<kbd class="calibre13">Course</kbd> and <kbd class="calibre13">Teacher</kbd>, respectively). If no field annotation is specified and if public getters/setters for an attribute are present, then it is considered an XML element with the same name.</p>
<p class="calibre3">We have specifically used<span class="calibre12"> the</span> <kbd class="calibre13">@XMLElement</kbd> annotation for <kbd class="calibre13">name</kbd> fields because we want to rename them as <kbd class="calibre13">course_name</kbd> or <kbd class="calibre13">teacher_name</kbd> when marshalled to XML.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing a REST GET request</h1>
                
            
            <article>
                
<p class="calibre3">Let's now implement the RESTful web service class. Create<span class="calibre12"> the</span> <kbd class="calibre13">CourseService</kbd> class in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.eclipse.rest.ws.services</kbd> package:</p>
<pre class="calibre25">package packt.jee.eclipse.rest.ws.services; 
 
import javax.ws.rs.GET; 
import javax.ws.rs.Path; 
import javax.ws.rs.PathParam; 
import javax.ws.rs.Produces; 
import javax.ws.rs.core.MediaType; 
 
import packt.jee.eclipse.rest.ws.dto.Course; 
import packt.jee.eclipse.rest.ws.dto.Teacher; 
 
@Path("/course") 
public class CourseService { 
 
  @GET 
  @Produces (MediaType.APPLICATION_XML) 
  @Path("get/{courseId}") 
  public Course getCourse (@PathParam("courseId") int id) { 
 
    //To keep the example simple, we will return 
    //hardcoded values here. However, you could get 
    //data from database using, for example, JDO or JDBC 
 
    return new Course(id,"Course-" + id, 5, new Teacher(2, <br class="title-page-name"/>     "Teacher1")); 
  } 
} </pre>
<p class="calibre3">The <kbd class="calibre13">@Path</kbd> annotation specifies that resources made available by this class will be accessible by relative URI <kbd class="calibre13">"/course"</kbd>.</p>
<p class="calibre3">The <kbd class="calibre13">getCourse</kbd> method has many annotations. Let's discuss them one at a time.</p>
<p class="calibre3">The <kbd class="calibre13">@GET</kbd> annotation specifies that when the relative URI (as specified by <kbd class="calibre13">@Path</kbd> on <kbd class="calibre13">CourseService</kbd> class) <kbd class="calibre13">"/course"</kbd> is called using the HTTP <kbd class="calibre13">GET</kbd> method, then this method will be invoked.</p>
<p class="calibre3"><kbd class="calibre13">@Produces</kbd> (<kbd class="calibre13">MediaType.APPLICATION_JSON</kbd>) specifies that this method generates a JSON output. If the client specifies the accepted MIME types, then this annotation would be used to resolve the method to be called, if more than one method is annotated with <kbd class="calibre13">@GET</kbd> (or, for that matter, any of the other HTTP method annotations). For example, if we have a method called <kbd class="calibre13">getCourseJSON</kbd> annotated with <kbd class="calibre13">@GET</kbd> , but producing data with different MIME types (as specified by <kbd class="calibre13">@Produces</kbd>), then the appropriate method will be selected on the basis of the MIME type requested by the client. The MIME type in<span class="calibre12"> the</span> <kbd class="calibre13">@Produces</kbd> annotation also tells<span class="calibre12"> the</span> JAX-RS implementation MIME type of the response to be created, when marshalling the Java object that is returned from that method. For example, in<span class="calibre12"> the</span> <kbd class="calibre13">getCourse</kbd> method we return an instance of <kbd class="calibre13">Course</kbd>, and the MIME type specified in <kbd class="calibre13">@Produces</kbd> tells Jersey to generate an XML representation of this instance.</p>
<p class="calibre3">The <kbd class="calibre13">@Path</kbd> annotation can also be used at the method level to specify sub-resources. The value specified in <kbd class="calibre13">@Path</kbd> at the method level is relative to the path value specified at the class level. The resource (in this case, <kbd class="calibre13">Course</kbd>) with ID <kbd class="calibre13">20</kbd> can be accessed as <kbd class="calibre13">/course/get/20</kbd>. The complete URL can be <kbd class="calibre13">http://&lt;server-address&gt;:&lt;port&gt;/&lt;app-name&gt;/course/get/10</kbd>. Parameter names in the path value are enclosed in <kbd class="calibre13">{}</kbd> in annotations.</p>
<p class="calibre3">Path parameters need to be identified in method arguments by using<span class="calibre12"> the</span> <kbd class="calibre13">@PathParam</kbd> annotation and<span class="calibre12"> the</span> name of the parameter as its value. The JAX-RS implementation framework matches the path parameters with arguments matching <kbd class="calibre13">@PathParam</kbd> annotations and appropriately passes parameter values to the method.</p>
<p class="calibre3">To keep the example simple and to keep the focus on implementation of RESTful web services, we are not going to implement any business logic in this method. We could get data from the database by using, for example, JDO or JDBC APIs (and we have seen examples of how to use these APIs in earlier chapters), but we are just going to return some hardcoded data. The method returns an instance of<span class="calibre12"> the</span> <kbd class="calibre13">Course</kbd> class. The JAX-RS implementation would convert this object into an XML representation by using JAXB when the data is finally returned to the client.</p>
<p class="calibre3">We need to tell the Jersey framework what packages it needs to scan to look for REST resources. There are two ways to do this:</p>
<ul class="calibre10">
<li class="calibre11">Configuring<span> the</span> Jersey servlet in <kbd class="calibre13">web.xml</kbd> (see <a href="https://jersey.java.net/nonav/documentation/latest/user-guide.html#deployment.servlet" class="calibre9"><span>https://jersey.java.net/nonav/documentation/latest/user-guide.html#deployment.servlet</span></a>).</li>
<li class="calibre11">For Servlet 3.x containers, we could create a subclass of <kbd class="calibre13">javax.ws.rs.core.Application</kbd>. Tomcat 8.0, which we have been using in this book, is a Servlet 3.x container.</li>
</ul>
<p class="calibre3">We will use the second option to create a subclass of <kbd class="calibre13">Application</kbd>. However, instead of directly subclassing <kbd class="calibre13">Application</kbd>, we will subclass<span class="calibre12"> the</span> <kbd class="calibre13">ResourceConfig</kbd> class of Jersey, which in turn extends <kbd class="calibre13">Application</kbd>.</p>
<p class="calibre3">Create<span class="calibre12"> the</span> <kbd class="calibre13">CourseMgmtRESTApplication</kbd> class in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.eclipse.rest.ws</kbd> package:</p>
<pre class="calibre25">package packt.jee.eclipse.rest.ws; 
 
import javax.ws.rs.ApplicationPath; 
 
import org.glassfish.jersey.server.ResourceConfig; 
 
@ApplicationPath("services") 
public class CourseMgmtRESTApplication extends ResourceConfig { 
 
  public CourseMgmtRESTApplication () { 
    packages("packt.jee.eclipse.rest.ws.services"); 
  } 
 
} </pre>
<p class="calibre3">We have used<span class="calibre12"> the</span> <kbd class="calibre13">@ApplicationPath</kbd> annotation to specify URL mapping for REST services implemented using JAX-RS. All <kbd class="calibre13">@Path</kbd> URIs on resource implementation classes will be relative to this path. For example, the <kbd class="calibre13">"/course"</kbd> URI that we specified for<span class="calibre12"> the</span> <kbd class="calibre13">CourseService</kbd> class would be relative to <kbd class="calibre13">"services"</kbd>, specified in the <kbd class="calibre13">@ApplicationPath</kbd> annotation.</p>
<p class="calibre3">Before we deploy the application and test our service, we need to generate<span class="calibre12"> </span><kbd class="calibre13">web.xml</kbd>. Right-click on the project in <span class="calibre12">Project Explorer</span> and select <span class="calibre12">Java EE Tools</span> | <span class="calibre12">Generate Deployment Descriptor Stub</span>. This will create <kbd class="calibre13">web.xml</kbd> in the <kbd class="calibre13">WEB-INF</kbd> folder. We don't need to modify it for this example.</p>
<p class="calibre3">Configure Tomcat in Eclipse as described in the <em class="calibre21">Installing Tomcat</em> section of <a target="_blank" href="part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 1</span></a>, <em class="calibre21">Introducing JEE and Eclipse</em>, and in the <em class="calibre21">Configuring Tomcat in Eclipse</em> section of <a target="_blank" href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre21">Creating a Simple JEE Web Application</em>. To deploy the web application, right-click on the configured Tomcat server in the <span class="calibre12">Servers</span> view and select the <span class="calibre12">Add and Remove</span> option. Add the current project.</p>
<p class="calibre3">Start the Tomcat server by right-clicking on the configured server in the <kbd class="calibre13">Servers</kbd> view and selecting <span class="calibre12">Start</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing the REST GET request in the browser</h1>
                
            
            <article>
                
<p class="calibre3">In this section, we will test the web service we created in the previous section in the browser. To test the web service, browse to <kbd class="calibre13"><span>http://localhost:8080/CourseManagementREST/services/course/get/10</span></kbd>.</p>
<p class="calibre3">You should see the following XML displayed in the browser:</p>
<pre class="calibre25">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt; 
&lt;course id="10"&gt; 
  &lt;course_name&gt;Course-10&lt;/course_name&gt; 
  &lt;credits&gt;5&lt;/credits&gt; 
  &lt;teacher id="2"&gt; 
    &lt;teacher_name&gt;Teacher1&lt;/teacher_name&gt; 
  &lt;/teacher&gt; 
&lt;/course&gt;</pre>
<p class="calibre3">Instead of generating an XML response, let's say we want to create a JSON response, because it would be much easier to consume a JSON response from JavaScript in a web page than an XML response. To create a JSON response, we need to change the value of<span class="calibre12"> the</span> <kbd class="calibre13">@Produces</kbd> annotation in<span class="calibre12"> the</span> <kbd class="calibre13">CourseService</kbd> class. Currently, it is set to <kbd class="calibre13">MediaType.APPLICATION_XML</kbd> and we want to set it to <kbd class="calibre13">MediaType.APPLICATION_JSON</kbd>:</p>
<pre class="calibre25">public class CourseService { 
 
  @GET 
  @Produces (MediaType.APPLICATION_JSON) 
  @Path("get/{courseId}") 
  public Course getCourse (@PathParam("courseId") int id) { 
... 
} 
} </pre>
<p class="calibre3">We also need to add libraries to create<span class="calibre12"> the</span> JSON response. Open<span class="calibre12"> the</span> <kbd class="calibre13">pom.xml</kbd> of the project and add the following dependency:</p>
<pre class="calibre25">    &lt;dependency&gt; 
      &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt; 
      &lt;artifactId&gt;jersey-media-json-jackson&lt;/artifactId&gt; 
      &lt;version&gt;2.18&lt;/version&gt; 
    &lt;/dependency&gt; </pre>
<p class="calibre3">Restart the Tomcat server and browse to<span class="calibre12"> the</span> <kbd class="calibre13">http://localhost:8080/CourseManagementREST/services/course/get/10</kbd> URL again. This time, you should see a JSON response:</p>
<pre class="calibre25">{ 
    id: 10, 
    credits: 5, 
    teacher: { 
        id: 2, 
        teacher_name: "Teacher1" 
    }, 
    course_name: "Course-10" 
} </pre>
<p class="calibre3">Let's create two versions of<span class="calibre12"> the</span> <kbd class="calibre13">getCourse</kbd> method, one that produces XML and the other that produces JSON. Replace<span class="calibre12"> the</span> <kbd class="calibre13">getCourse</kbd> function with the following code:</p>
<pre class="calibre25">  @GET 
  @Produces (MediaType.APPLICATION_JSON) 
  @Path("get/{courseId}") 
  public Course getCourseJSON (@PathParam("courseId") int id) { 
 
    return createDummyCourse(id); 
 
  } 
 
  @GET 
  @Produces (MediaType.APPLICATION_XML) 
  @Path("get/{courseId}") 
  public Course getCourseXML (@PathParam("courseId") int id) { 
 
    return createDummyCourse(id); 
 
  } 
 
  private Course createDummyCourse (int id) { 
    //To keep the example simple, we will return 
    //hardcoded value here. However, you could get 
    //data from database using, for example, JDO or JDBC 
 
    return new Course(id,"Course-" + id, 5, new Teacher(2, <br class="title-page-name"/>     "Teacher1")); 
  } </pre>
<p class="calibre3">We have added<span class="calibre12"> the</span> <kbd class="calibre13">createDummyCourse</kbd> method, which has the same code that we had earlier in<span class="calibre12"> the</span> <kbd class="calibre13">getCourse</kbd> method. We now have two versions of<span class="calibre12"> the</span> <kbd class="calibre13">getCourse</kbd> method: <kbd class="calibre13">getCourseXML</kbd> and <kbd class="calibre13">getCourseJSON</kbd>, producing the XML and JSON responses, respectively.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a Java client for the REST GET web service</h1>
                
            
            <article>
                
<p class="calibre3">Let's now create a Java client application that calls the previous web service. Create a simple Maven project and call it <kbd class="calibre13">CourseManagementRESTClient</kbd>:</p>
<div class="mce-root1"><br class="title-page-name"/>
<img src="../images/00190.jpeg" class="calibre200"/></div>
<div class="packt_figure1">Figure 9.3: Create a JAX-RS client project</div>
<p class="calibre3">Open <kbd class="calibre13">pom.xml</kbd> and add a dependency for<span class="calibre12"> the</span> Jersey client module:</p>
<pre class="calibre25">  &lt;dependencies&gt; 
    &lt;dependency&gt; 
      &lt;groupId&gt;org.glassfish.jersey.core&lt;/groupId&gt; 
      &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; 
      &lt;version&gt;2.18&lt;/version&gt; 
    &lt;/dependency&gt; 
  &lt;/dependencies&gt;</pre>
<p class="calibre3">Create a Java class called <kbd class="calibre13">CourseManagementRESTClient</kbd> in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.eclipse.rest.ws.client</kbd> package:</p>
<div class="mce-root1"><img src="../images/00191.jpeg" class="calibre201"/></div>
<div class="packt_figure1">Figure 9.4: Create a REST client main class</div>
<p class="calibre3">You could invoke a RESTful web service using <kbd class="calibre13">java.net.HttpURLConnection</kbd> or other external HTTP client libraries. But JAX-RS client APIs make this task a lot easier, as you can see in the following code:</p>
<pre class="calibre25">package packt.jee.eclipse.rest.ws.client; 
 
import javax.ws.rs.client.Client; 
import javax.ws.rs.client.ClientBuilder; 
import javax.ws.rs.client.WebTarget; 
import javax.ws.rs.core.MediaType; 
import javax.ws.rs.core.Response; 
 
/** 
 * This is a simple test class for invoking RESTful web service 
 * using JAX-RS client APIs 
 */ 
public class CourseManagementClient { 
 
  public static void main(String[] args) { 
 
testGetCoursesJSON(); 
 
  } 
 
  //Test getCourse method (XML or JSON) of CourseService 
  public static void testGetCoursesJSON() { 
    //Create JAX-RS client 
    Client client = ClientBuilder.newClient(); 
    //Get WebTarget for a URL 
    WebTarget webTarget = <br class="title-page-name"/> client.target("http://localhost:8080/CourseManagementREST/services/course"); 
    //Add paths to URL 
    webTarget = webTarget.path("get").path("10"); 
 
    //We could also have create webTarget in one call with the full URL - 
    //WebTarget webTarget = <br class="title-page-name"/> client.target("http://localhost:8080/CourseManagementREST/services/course/get/10"); 
 
 
    //Execute HTTP get method 
    Response response = <br class="title-page-name"/>     webTarget.request(MediaType.APPLICATION_JSON).get(); 
 
    //Check response code. 200 is OK 
    if (response.getStatus() != 200) { 
      System.out.println("Error invoking REST web service - " + <br class="title-page-name"/>       response.getStatusInfo().getReasonPhrase()); 
      return; 
    } 
 
    //REST call was successful. Print the response 
    System.out.println(response.readEntity(String.class)); 
  } 
} </pre>
<div class="packt_tip"><br class="calibre26"/>
For a detailed description of how to use the JAX-RS client APIs, refer to <a href="https://jersey.java.net/documentation/latest/client.html" class="calibre17"><span class="calibre23">https://jersey.java.net/documentation/latest/client.html</span></a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing a REST POST request</h1>
                
            
            <article>
                
<p class="calibre3">We saw an example of how to implement an HTTP <kbd class="calibre13">GET</kbd> request by using JAX-RS. Let's now implement a <kbd class="calibre13">POST</kbd> request. We will implement a method to add a course in<span class="calibre12"> the</span> <kbd class="calibre13">CourseService</kbd> class, which is our web service implementation class in<span class="calibre12"> the</span> <kbd class="calibre13">CourseManagementREST</kbd> project.</p>
<p class="calibre3">As in the case of the <kbd class="calibre13">getCourse</kbd> method, we won't actually access the database but will simply write a dummy method to save the data. Again, the idea is to keep the example simple and focus only on the JAX-RS APIs and implementation. Open <kbd class="calibre13">CourseService.java</kbd> and add<span class="calibre12"> the</span> following methods:</p>
<pre class="calibre25">  @POST 
  @Consumes (MediaType.APPLICATION_JSON) 
  @Produces (MediaType.APPLICATION_JSON) 
  @Path("add") 
  public Course addCourse (Course course) { 
 
    int courseId = dummyAddCourse(course.getName(), <br class="title-page-name"/>     course.getCredits()); 
 
    course.setId(courseId); 
 
    return course; 
  } 
 
  private int dummyAddCourse (String courseName, int credits) { 
 
    //To keep the example simple, we will just print 
    //parameters we received in this method to console and not 
    //actually save data to database. 
    System.out.println("Adding course " + courseName + ", credits <br class="title-page-name"/> = " + credits); 
 
    //TODO: Add course to database table 
 
    //return hard-coded id 
    return 10; 
  } </pre>
<p class="calibre3">The <kbd class="calibre13">addCourse</kbd> method produces and consumes JSON data. It is invoked when the resource path (web service endpoint URL) has the following relative path: <kbd class="calibre13">"/course/add"</kbd>. Recall that<span class="calibre12"> the</span> <kbd class="calibre13">CourseService</kbd> class is annotated with the following path: <kbd class="calibre13">"/course"</kbd>. So, the relative path for<span class="calibre12"> the</span> <kbd class="calibre13">addCourse</kbd> method becomes the path specified at the class level and at the method level (which in this case is <kbd class="calibre13">"add"</kbd>). We are returning a new instance of <kbd class="calibre13">Course</kbd> from <kbd class="calibre13">addCourse</kbd>. Jersey creates<span class="calibre12"> the</span> appropriate JSON representation of this class on the basis of JAXB annotations in<span class="calibre12"> the</span> <kbd class="calibre13">Course</kbd> class. We have already added the dependency in the project on a Jersey module that handles JSON format (in <kbd class="calibre13">pom.xml</kbd>, we added a dependency on <kbd class="calibre13">jersey-media-json-jackson</kbd>).</p>
<p class="calibre3">Restart the Tomcat server for these changes to take effect.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Writing a Java client for the REST POST web service</h1>
                
            
            <article>
                
<p class="calibre3">We will now add a test method in the <kbd class="calibre13">CourseManagementClient</kbd> class, <span class="calibre12">in the </span><kbd class="calibre13">CourseManagementRESTClient</kbd><span class="calibre12"> project:</span></p>
<pre class="calibre25">  //Test addCourse method (JSON version) of CourseService 
  public static void testAddCourseJSON() { 
 
    //Create JAX-RS client 
    Client client = ClientBuilder.newClient(); 
 
    //Get WebTarget for a URL 
    WebTarget webTarget = <br class="title-page-name"/> client.target("http://localhost:8600/CourseManagementREST/services/course/add"); 
 
    //Create JSON representation of Course, 
    //with course_name and credits fields. Instead of creating 
    //JSON manually, you could also use JAXB to create JSON from 
    //Java object. 
    String courseJSON = "{"course_name":"Course-4", <br class="title-page-name"/>     "credits":5}"; 
 
    //Execute HTTP post method 
    Response response = webTarget.request(). 
        post(Entity.entity(courseJSON, <br class="title-page-name"/>         MediaType.APPLICATION_JSON_TYPE)); 
 
    //Check response code. 200 is OK 
    if (response.getStatus() != 200) { 
      //Print error message 
      System.out.println("Error invoking REST Web Service - " + <br class="title-page-name"/>       response.getStatusInfo().getReasonPhrase() + 
          ", Error Code : " + response.getStatus()); 
      //Also dump content of response message 
      System.out.println(response.readEntity(String.class)); 
      return; 
    } 
 
    //REST call was successful. Print the response 
    System.out.println(response.readEntity(String.class)); 
  } </pre>
<p class="calibre3">We need to send input data (<kbd class="calibre13">Course</kbd> information) in JSON format. Although we have hardcoded JSON in our example, you could use JAXB or any other library that converts a Java object into JSON.</p>
<p class="calibre3">Note that we are executing the request using<span class="calibre12"> the</span> HTTP <kbd class="calibre13">POST</kbd> method <kbd class="calibre13">webTarget.request().post(...)</kbd>. We have also set<span class="calibre12"> the</span> content type of the request to <kbd class="calibre13">"application/JSON"</kbd>, because our web service to add <kbd class="calibre13">Course</kbd> consumes the JSON format. We have done this by creating the entity and setting its content type to <kbd class="calibre13">JSON</kbd>:</p>
<pre class="calibre25">//Execute HTTP post method 
Response response = <br class="title-page-name"/> webTarget.request().post(Entity.entity(courseJSON, 
       MediaType.APPLICATION_JSON_TYPE)); </pre>
<p class="calibre3">Now modify<span class="calibre12"> the</span> <kbd class="calibre13">main</kbd> method of<span class="calibre12"> the</span> <kbd class="calibre13">CourseManagementClient</kbd> class to call<span class="calibre12"> the</span> <kbd class="calibre13">testAddCourseJSON</kbd> method. Right-click on the class and select <span class="calibre12">Run As</span> | <span class="calibre12">Java Application</span>. You should see <kbd class="calibre13">Course</kbd> information in JSON format printed in the console. Also, check the Tomcat console in Eclipse. There, you should see the console message that we printed in<span class="calibre12"> the</span> <kbd class="calibre13">CourseService.dummyAddCourse</kbd> method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Invoking a POST RESTful web service from JavaScript</h1>
                
            
            <article>
                
<p class="calibre3">Here is a simple example of how to invoke our RESTful web service to add a course from JavaScript:</p>
<pre class="calibre25">&lt;!DOCTYPE html&gt; 
&lt;html&gt; 
&lt;head&gt; 
&lt;meta charset="UTF-8"&gt; 
&lt;title&gt;Add Course - JSON&lt;/title&gt; 
 
&lt;script type="text/javascript"&gt; 
 
  function testAddCourseJSON() { 
 
    //Hardcoded course information to keep example simple. 
    //This could be passed as arguments to this function 
    //We could also use HTML form to get this information from <br class="title-page-name"/>     users 
    var courseName = "Course-4"; 
    var credits = 4; 
 
    //Create XMLHttpRequest 
    var req = new XMLHttpRequest(); 
 
    //Set callback function, because we will have XMLHttpRequest 
    //make asynchronous call to our web service 
    req.onreadystatechange = function () { 
      if (req.readyState == 4 &amp;&amp; req.status == 200) { 
        //HTTP call was successful. Display response 
        document.getElementById("responseSpan").innerHTML = <br class="title-page-name"/>         req.responseText; 
      } 
    }; 
 
    //Open request to our REST service. Call is going to be asyc 
    req.open("POST", <br class="title-page-name"/> "http://localhost:8080/CourseManagementREST/services/course/add", <br class="title-page-name"/> true); 
    //Set request content type as JSON 
    req.setRequestHeader("Content-type", "application/JSON"); 
 
    //Create Course object and then stringify it to create JSON <br class="title-page-name"/>     string 
    var course = { 
      "course_name": courseName, 
      "credits" : credits 
    }; 
 
    //Send request. 
    req.send(JSON.stringify(course)); 
  } 
&lt;/script&gt; 
 
&lt;/head&gt; 
&lt;body&gt; 
  &lt;button type="submit" onclick="return testAddCourseJSON();"&gt;Add <br class="title-page-name"/>   Course using JSON&lt;/button&gt; 
  &lt;p/&gt; 
  &lt;span id="responseSpan"&gt;&lt;/span&gt; 
&lt;/body&gt; 
&lt;/html&gt; </pre>
<p class="calibre3">If you want to test this code, create an HTML file, say <kbd class="calibre13">addCourseJSON.html</kbd>, in<span class="calibre12"> the</span> <kbd class="calibre13">src/main/webapp</kbd> folder of<span class="calibre12"> the</span> <kbd class="calibre13">CourseManagementREST</kbd> project. Then, browse to <kbd class="calibre13">http://localhost:8080/CourseManagementREST/addCourseJSON.html</kbd>. Click<span class="calibre12"> the</span> <span class="calibre12">Add Course using JSON</span> button. The response is displayed in the same page.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a RESTful web service with form POST</h1>
                
            
            <article>
                
<p class="calibre3">We have created RESTful web services so far with HTTP <kbd class="calibre13">GET</kbd> and <kbd class="calibre13">POST</kbd> methods. The web service using <span class="calibre12">the</span> <kbd class="calibre13">POST</kbd> method took input in the JSON format. We can also have<span class="calibre12"> the</span> <kbd class="calibre13">POST</kbd> method in the web service take input from HTML form elements. Let's create a method that handles the data posted from a HTML form. Open <kbd class="calibre13">CourseService.java</kbd> from<span class="calibre12"> the</span> <kbd class="calibre13">CourseManagementREST</kbd> project. Add the following method:</p>
<pre class="calibre25">@POST 
@Consumes (MediaType.APPLICATION_FORM_URLENCODED) 
@Path("add") 
public Response addCourseFromForm (@FormParam("name") String courseName, 
    @FormParam("credits") int credits) throws URISyntaxException { 
 
  dummyAddCourse(courseName, credits); 
 
  return Response.seeOther(new <br class="title-page-name"/> URI("../addCourseSuccess.html")).build(); 
} </pre>
<p class="calibre3">The method is marked to handle form data by specifying<span class="calibre12"> the</span> <kbd class="calibre13">@Consume</kbd> annotation with the following value: <kbd class="calibre13">"application/x-www-form-urlencoded"</kbd>. Just as we mapped parameters in<span class="calibre12"> the</span> path in<span class="calibre12"> the</span> <kbd class="calibre13">getCourse</kbd> method with <kbd class="calibre13">@PathParam</kbd>, we map the form fields to method arguments using<span class="calibre12"> the</span> <kbd class="calibre13">@FormParam</kbd> annotation. Finally, once we successfully save the course, we want the client to be redirected to <kbd class="calibre13">addCourseSuccess.html</kbd>. We do this by calling the <kbd class="calibre13">Response.seeOther</kbd> method. The <kbd class="calibre13">addCourseFromForm</kbd> method returns the <kbd class="calibre13">Response</kbd> object.</p>
<div class="packt_infobox"><br class="calibre26"/>
Refer to <a href="https://jersey.java.net/documentation/latest/representations.html" class="calibre17"><span class="calibre23">https://jersey.java.net/documentation/latest/representations.html</span></a> for more information on how to configure <kbd class="calibre48">Response</kbd> from the web service.</div>
<p class="calibre3">We need to create <kbd class="calibre13">addCourseSuccess.html</kbd> to complete this example. Create this file in the <kbd class="calibre13">src/main/webapp</kbd> folder of<span class="calibre12"> the</span> <kbd class="calibre13">CourseManagementREST</kbd> project with<span class="calibre12"> the</span> following content:</p>
<pre class="calibre25">&lt;h3&gt;Course added successfully&lt;/h3&gt; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a Java client for a form-encoded RESTful web service</h1>
                
            
            <article>
                
<p class="calibre3">Let's now create a test method for calling the previous web service that consumes form-encoded data. Open <kbd class="calibre13">CourseManagementClient.java</kbd> from<span class="calibre12"> the</span> <kbd class="calibre13">CourseManagementRESTClient</kbd> project and add the following method:</p>
<pre class="calibre25">  //Test addCourse method (Form-Encoded version) of CourseService 
  public static void testAddCourseForm() { 
 
    //create JAX-RS client 
    Client client = ClientBuilder.newClient(); 
 
    //Get WebTarget for a URL 
    WebTarget webTarget = <br class="title-page-name"/> client.target("http://localhost:8600/CourseManagementREST/services/course/add"); 
 
    //Create Form object and populate fields 
    Form form = new Form(); 
    form.param("name", "Course-5"); 
    form.param("credits", "5"); 
 
    //Execute HTTP post method 
    Response response = webTarget.request(). 
        post(Entity.entity(form, <br class="title-page-name"/>         MediaType.APPLICATION_FORM_URLENCODED)); 
 
    //check response code. 200 is OK 
    if (response.getStatus() != 200) { 
      //Print error message 
      System.out.println("Error invoking REST Web Service - " + <br class="title-page-name"/>       response.getStatusInfo().getReasonPhrase() + 
          ", Error Code : " + response.getStatus()); 
      //Also dump content of response message 
      System.out.println(response.readEntity(String.class)); 
      return; 
    } 
 
    //REST call was successful. Print the response 
    System.out.println(response.readEntity(String.class)); 
  } </pre>
<p class="calibre3">Notice that the form data is created by creating an instance of<span class="calibre12"> the</span> <kbd class="calibre13">Form</kbd> object and setting its parameters. The <kbd class="calibre13">POST</kbd> request is encoded with <kbd class="calibre13">MediaType.APPLICATION_FORM_URLENCODED</kbd>, which has the following value: <kbd class="calibre13">"application/x-www-form-urlencoded"</kbd>.</p>
<p class="calibre3">Now, modify<span class="calibre12"> the</span> <kbd class="calibre13">main</kbd> method to call <kbd class="calibre13">testAddCourseForm</kbd>. Then, run the application by right-clicking the class and selecting <span class="calibre12">Run As</span> | <span class="calibre12">Java Application</span>. You should see the success message (from <kbd class="calibre13">addCourseSuccess.html</kbd>) printed in the console.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">A RESTful web service using JSON-B</h1>
                
            
            <article>
                
<p class="calibre3">In the previous section, we implemented the RESTful web service using JAXB. As mentioned earlier, JEE 8 has added a new specification for JSON binding, called JSON-B. In this section, we will learn how to modify our web service to use JSON-B. </p>
<p class="calibre3">There is really not much that we need to change in the code to switch from JAXB to JSON-B. We will need to use<span class="calibre12"> the</span> <kbd class="calibre13">@JsonbProperty</kbd> annotation of JSON-B to specify field binding in<span class="calibre12"> the</span> <kbd class="calibre13">Course</kbd> class, instead of<span class="calibre12"> the</span><kbd class="calibre13"> @XmlAttribute</kbd> annotation of JAXB. Then, we will need to add Maven dependencies to include libraries that provide JSON-B APIs and its implementations. Replace<span class="calibre12"> the</span> dependencies section in pom.xml with<span class="calibre12"> the</span> following: </p>
<pre class="calibre25"><span><span>  </span></span><span>&lt;</span>dependencies<span>&gt;<br class="title-page-name"/></span><span><span>  <span> </span></span></span><span>&lt;</span>dependency<span>&gt;<br class="title-page-name"/></span><span>  <span> </span><span> </span></span><span>&lt;</span><span>groupId</span><span>&gt;</span>org.glassfish.jersey.containers<span>&lt;/</span><span>groupId</span><span>&gt;<br class="title-page-name"/></span><span>  <span> </span><span> </span></span><span>&lt;</span><span>artifactId</span><span>&gt;</span>jersey-container-<span>servlet</span><span>&lt;/</span><span>artifactId</span><span>&gt;<br class="title-page-name"/></span><span><span>  <span> </span><span> </span></span></span><span>&lt;</span>version<span>&gt;</span><span>2.26</span><span>&lt;/</span>version<span>&gt;<br class="title-page-name"/></span><span><span>  <span> </span></span></span><span>&lt;/</span>dependency<span>&gt;<br class="title-page-name"/></span><span><span>  <span> </span></span></span><span>&lt;</span>dependency<span>&gt;<br class="title-page-name"/></span><span>  <span> </span><span> </span></span><span>&lt;</span><span>groupId</span><span>&gt;</span>org.glassfish.jersey.media<span>&lt;/</span><span>groupId</span><span>&gt;<br class="title-page-name"/></span><span>  <span> </span><span> </span></span><span>&lt;</span><span>artifactId</span><span>&gt;</span>jersey-media-<span>json</span>-binding<span>&lt;/</span><span>artifactId</span><span>&gt;<br class="title-page-name"/></span><span><span>  <span> </span><span> </span></span></span><span>&lt;</span>version<span>&gt;</span><span>2.26</span><span>&lt;/</span>version<span>&gt;<br class="title-page-name"/></span><span><span>  <span> </span></span></span><span>&lt;/</span>dependency<span>&gt;<br class="title-page-name"/></span><span><span>  <span> </span></span></span><span>&lt;</span>dependency<span>&gt;<br class="title-page-name"/></span><span>  <span> </span><span> </span></span><span>&lt;</span><span>groupId</span><span>&gt;</span>org.glassfish.jersey.inject<span>&lt;/</span><span>groupId</span><span>&gt;<br class="title-page-name"/></span><span><span>  <span> </span><span> </span></span></span><span>&lt;</span>artifactId<span>&gt;</span><span>jersey-hk2</span><span>&lt;/</span>artifactId<span>&gt;<br class="title-page-name"/></span><span><span>  <span> </span><span> </span></span></span><span>&lt;</span>version<span>&gt;</span><span>2.26</span><span>&lt;/</span>version<span>&gt;<br class="title-page-name"/></span><span><span>  <span> </span></span></span><span>&lt;/</span>dependency<span>&gt;<br class="title-page-name"/></span><span><span>  </span></span><span>&lt;/</span>dependencies<span>&gt;</span><span> </span></pre>
<p class="calibre3">Dependency on <kbd class="calibre13">jersey-container-servlet</kbd> has not changed. However, we have replaced dependency on <kbd class="calibre13">jersey-media-json-jackson</kbd> <span class="calibre12">with</span><kbd class="calibre13"> jersey-media-json-binding</kbd><span class="calibre12"><span class="calibre12"> and <kbd class="calibre13">jersey-hk2</kbd>. The Jersey framework automatically handles conversion of Java objects to JSON when the web service method is annotated with:</span></span></p>
<pre class="calibre25"><span>@Produces</span><span> (MediaType.</span>APPLICATION_JSON<span>)</span></pre>
<p class="calibre3">This is specified in<span class="calibre12"> the</span> <kbd class="calibre13">CourseService</kbd> class.</p>
<p class="calibre3">A separate project for this section, named <kbd class="calibre13">CourseManagementREST-JSONB</kbd>, is made available in the accompanying source code for this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">SOAP web services</h1>
                
            
            <article>
                
<p class="calibre3"><strong class="calibre5">Simple Object Access Protocol</strong> (<strong class="calibre5">SOAP</strong>) is a specification from <strong class="calibre5">World Wide Web Consortium</strong> (<strong class="calibre5">W3C</strong>) (<a href="http://www.w3.org/TR/2007/REC-soap12-part0-20070427/" class="calibre9"><span>http://www.w3.org/TR/2007/REC-soap12-part0-20070427/</span></a>). Although we are referring to SOAP-based web services here, SOAP is one of the specifications used to implement XML-based web services. There are a few other specifications required to implement SOAP web services, which we will see later. One of the premises of SOAP web services <span class="calibre12"><span class="calibre12">is </span></span>the dynamic discovery and invocation of services. For example, an application can look for a service from the central directory and invoke it dynamically. However, in practice, very few enterprises would be willing to invoke services dynamically without testing them, so this aspect of SOAP web services is less utilized.</p>
<p class="calibre3">W3C has defined many specifications for SOAP web services, for example, specifications for messages, auto discovery, security, and service orchestration. However, at a minimum, we need to understand the following specification before we develop SOAP web services.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">SOAP</h1>
                
            
            <article>
                
<p class="calibre3">SOAP defines the format of a message exchange between the web service provider and the consumer:</p>
<div class="mce-root1"><img src="../images/00192.jpeg" class="calibre202"/></div>
<div class="packt_figure1">Figure 9.5: SOAP message structure</div>
<p class="calibre3">The top element in a <strong class="calibre5">SOAP Message</strong> is <strong class="calibre5">SOAP Envelope</strong>. It contains a <strong class="calibre5">SOAP Header (Optional)</strong> and a <strong class="calibre5">SOAP Body</strong>. The <strong class="calibre5">SOAP Body</strong> actually contains the message payload (for processing by the consumer) and optionally <strong class="calibre5">SOAP Fault (Optional)</strong>, if there is any error.</p>
<p class="calibre3">The SOAP header provides extensibility to the SOAP message. It can contain information such as user credentials, transaction management, and message routing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">WSDL</h1>
                
            
            <article>
                
<p class="calibre3">As the name suggests, <strong class="calibre5">Web Service Description Language</strong> (<strong class="calibre5">WSDL</strong>) describes web services; in particular, it describes data types used (schemas), input and output messages, operations (methods), and binding and service endpoints:</p>
<div class="mce-root1"><img src="../images/00193.gif" class="calibre203"/></div>
<div class="packt_figure1">Figure 9.6: WSDL structure</div>
<p class="calibre3">Although you don't necessarily need to understand the details of WSDL when creating web services in Java, it is good to know the basic structure of WSDL. WSDLs are typically meant to be produced and processed by programs, and developers are not expected to hand-code them. Here are some of the elements in WSDL:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre13">definitions</kbd>: This is the root element of WSDL.</li>
<li class="calibre11"><kbd class="calibre13">Import</kbd>: This element allows you to import elements from an external file. This way, you can make the WSDL file modular.</li>
<li class="calibre11"><kbd class="calibre13">Types</kbd>: This element defines the schema for different data types used in the WSDL.</li>
<li class="calibre11"><kbd class="calibre13">Messages</kbd>: This element defines<span> the</span> format of input and output messages exchanged between the web service and the client.</li>
<li class="calibre11"><kbd class="calibre13">PortType</kbd>: This defines methods or operations supported by the web service. Each operation in <kbd class="calibre13">PortType</kbd> can declare request and response messages. Operations in <kbd class="calibre13">PortType</kbd> refer to messages defined in a message element.</li>
</ul>
<p class="calibre3">Although in <em class="calibre21">Figure 9.6</em>, <span class="calibre12">the</span> <kbd class="calibre13">binding</kbd> element looks the same as <kbd class="calibre13">PortType</kbd>, it actually specifies the transport protocol bound to operations and message type (<strong class="calibre5">remote procedure call</strong> or <strong class="calibre5">document type</strong>) and encoding (encoded or literal) for messages of each operation declared in <kbd class="calibre13">PortType</kbd>. The typical transport protocol is HTTP, but it could be other protocols such as JMS and SMTP. The difference between <span class="calibre12">the</span><span class="calibre12"> </span><span class="calibre12">RPC and</span><span class="calibre12"> d</span><span class="calibre12">ocument types is that the RPC message type contains</span><span class="calibre12"> the</span> <span class="calibre12">name of the remote method in the message, whereas</span><span class="calibre12"> the</span> <span class="calibre12">document type does not contain the method name. The name of the method to process the payload in a document type message is either derived from the endpoint URL or from information in the header. However, there is another type called <strong class="calibre5">document wrapped</strong>, which does contain the name of the method as the enclosing element for the actual message payload.</span></p>
<p class="calibre3">The <kbd class="calibre13">Service</kbd> element contains<span class="calibre12"> the</span> actual location of each web service endpoint.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">UDDI</h1>
                
            
            <article>
                
<p class="calibre3"><strong class="calibre5">Universal Description, Discovery and Integration</strong> (<strong class="calibre5">UDDI</strong>) is a directory of web services where you can publish your own web services or search for existing web services. The directory could be global or could be local to the enterprise. UDDI is also a web service with operations supported for publishing and searching contents.</p>
<div class="packt_infobox"><br class="calibre26"/>
We will not be focusing on UDDI in this book, but you can visit <span class="calibre23"><a href="http://docs.oracle.com/cd/E14571_01/web.1111/e13734/uddi.htm#WSADV226" class="calibre17">http://docs.oracle.com/cd/E14571_01/web.1111/e13734/uddi.htm#WSADV226</a> for more information</span>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Developing web services in Java</h1>
                
            
            <article>
                
<p class="calibre3">There are many frameworks around for developing web services in Java. New frameworks have evolved as specifications have changed. Some of the popular frameworks for developing web services in Java over the years are Apache Axis (<a href="https://axis.apache.org/axis/" class="calibre9"><span>https://axis.apache.org/axis/</span></a>), Apache Axis2 (<a href="http://axis.apache.org/axis2/java/core/" class="calibre9"><span>http://axis.apache.org/axis2/java/core/</span></a>), Apache CFX (<a href="http://cxf.apache.org/" class="calibre9"><span>http://cxf.apache.org/</span></a>), and GlassFish Metro (<a href="https://metro.java.net/" class="calibre9"><span>https://metro.java.net/</span></a>).</p>
<p class="calibre3">Earlier implementations of web service frameworks were based on the <strong class="calibre5">JAX-RPC</strong> (<strong class="calibre5">Java API for XML-based RPC</strong>) specification (<a href="http://www.oracle.com/technetwork/java/docs-142876.html" class="calibre9"><span>http://www.oracle.com/technetwork/java/docs-142876.html</span></a>). JAX-RPC was replaced with <strong class="calibre5">Java API for XML Web Services</strong> (<strong class="calibre5">JAX-WS</strong>) in JEE 5. JAX-WS makes development of web services easier by supporting annotations. In this chapter, we will learn how to create and consume web services using JAX-WS. Continuing with the example (<em class="calibre21">Course Management</em>) that we have been following in this book, we will create web services to get all courses and add new courses.</p>
<p class="calibre3">First, let's create a Maven web project. Select <span class="calibre12">File</span> | <span class="calibre12">New</span> | <span class="calibre12">Maven Project</span>. Select<span class="calibre12"> the</span> <span class="calibre12">Create a simple project</span> option:</p>
<div class="mce-root1"><img src="../images/00194.jpeg" class="calibre204"/></div>
<div class="packt_figure1">Figure 9.7: New Maven Project</div>
<p class="calibre3">Click <span class="calibre12">Next</span>. Enter <span class="calibre12">Group Id</span>, <span class="calibre12">Artifact id</span>, and <span class="calibre12">Version</span> in the next page. Select the <kbd class="calibre13">war</kbd> packaging:</p>
<div class="mce-root1"><br class="title-page-name"/>
<img src="../images/00195.jpeg" class="calibre205"/></div>
<div class="packt_figure1">Figure 9.8: Enter artifact details</div>
<p class="calibre3">Click <span class="calibre12">Finish</span> to complete the wizard.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a web service implementation class</h1>
                
            
            <article>
                
<p class="calibre3">JAX-WS annotations were added in Java EE 5.0. Using these annotations, we can turn any Java class (including POJOs) into a web service. Use<span class="calibre12"> the</span> <kbd class="calibre13">@Webservice</kbd> annotation to make any Java class a web service. This annotation can be used either on an interface or on a Java class. If a Java class is annotated with <kbd class="calibre13">@Webservice</kbd>, then all public methods in the class are exposed in the web service. If a Java interface is annotated with <kbd class="calibre13">@Webservice</kbd>, then the implementation class still needs to be annotated with <kbd class="calibre13">@Webservice</kbd> and with<span class="calibre12"> the</span> <kbd class="calibre13">endpointInterface</kbd> attribute and its value as the interface name.</p>
<p class="calibre3">Before we create the web service implementation class, let's create a few helper classes. The first one is the <kbd class="calibre13">Course</kbd> data transfer object. This is the same class that we created in previous chapters. Create<span class="calibre12"> the</span> <kbd class="calibre13">Course</kbd> class in the <kbd class="calibre13">packt.jee.eclipse.ws.soap</kbd> package:</p>
<pre class="calibre25">package packt.jee.eclipse.ws.soap; 
 
public class Course { 
  private int id; 
  private String name; 
  private int credits; 
 
  //Setters and getters follow here 
} </pre>
<p class="calibre3">Let's now create the web service implementation class <kbd class="calibre13">CourseManagementService</kbd> in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.eclipse.ws.soap</kbd> package:</p>
<pre class="calibre25">package packt.jee.eclipse.ws.soap; 
 
import java.util.ArrayList; 
import java.util.List; 
 
import javax.jws.WebService; 
 
@WebService 
public class CourseManagementService { 
 
  public List&lt;Course&gt; getCourses() { 
    //Here courses could be fetched from database using, 
    //for example, JDBC or JDO. However, to keep this example 
    //simple, we will return hardcoded list of courses 
 
    List&lt;Course&gt; courses = new ArrayList&lt;Course&gt;(); 
 
    courses.add(new Course(1, "Course-1", 4)); 
    courses.add(new Course(2, "Course-2", 3)); 
 
    return courses; 
  } 
 
  public Course getCourse(int courseId) { 
    //Here again, we could get course details from database using 
    //JDBC or JDO. However, to keep this example 
    //simple, we will return hardcoded course 
 
    return new Course(1,"Course-1",4); 
  } 
} </pre>
<p class="calibre3"><kbd class="calibre13">CourseManagementService</kbd> has<span class="calibre12"> the</span> following two methods: <kbd class="calibre13">getCourses</kbd> and <kbd class="calibre13">getCourse</kbd>. To keep the example simple, we have hardcoded the values, but you can very well fetch data from a database, for example, using the JDBC or JDO APIs that we have discussed earlier in this book. The class is annotated with <kbd class="calibre13">@WebService</kbd>, which tells<span class="calibre12"> the</span> JAX-WS implementation to treat this class as a web service. All methods in this class will be exposed as web service operations. If you want a specific method to be exposed, you could use <kbd class="calibre13">@WebMethod</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using JAX-WS reference implementation (Glassfish Metro)</h1>
                
            
            <article>
                
<p class="calibre3">Annotating a class with <kbd class="calibre13">@WebService</kbd> is not enough to implement a web service. We need a library that implements JAX-WS specification. There are a number of JAX-WS frameworks available, for example, Axis2, Apache CFX, and Glassfish Metro. In this chapter, we will use<span class="calibre12"> the</span> Glassfish Metro implementation, which is also a reference implementation (<a href="https://jax-ws.java.net/" class="calibre9"><span>https://jax-ws.java.net/</span></a>) of JAX-WS from Oracle.</p>
<p class="calibre3">Let's add Maven dependency for the JAX-WS framework. Open <kbd class="calibre13">pom.xml</kbd> and add the following dependency:</p>
<pre class="calibre25">  &lt;dependencies&gt; 
    &lt;dependency&gt; 
      &lt;groupId&gt;com.sun.xml.ws&lt;/groupId&gt; 
      &lt;artifactId&gt;jaxws-rt&lt;/artifactId&gt; 
      &lt;version&gt;2.2.10&lt;/version&gt; 
    &lt;/dependency&gt; 
  &lt;/dependencies&gt; </pre>
<p class="calibre3">Replace<span class="calibre12"> the</span> <span class="calibre12">previous</span><span class="calibre12"> </span><span class="calibre12">version number with the latest version of the framework. The Metro framework also requires you to declare web service endpoints in the configuration file called</span> <kbd class="calibre13">sun-jaxws.xml</kbd><span class="calibre12">. Create the </span><kbd class="calibre13">sun-jaxws.xml</kbd> <span class="calibre12">file in the </span><kbd class="calibre13">src/main/webapp/WEB-INF</kbd> <span class="calibre12">folder and add the endpoint as follows:</span></p>
<pre class="calibre25">&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;endpoints  <br class="title-page-name"/> version="2.0"&gt; 
  &lt;endpoint name="CourseService" implementation="packt.jee.eclipse.ws.soap.CourseManagementService" 
        url-pattern="/courseService" /&gt; 
&lt;/endpoints&gt; </pre>
<p class="calibre3">The endpoint implementation is the fully qualified name of our web service implementation class. <kbd class="calibre13">url-pattern</kbd> is just like servlet mapping that you specify in <kbd class="calibre13">web.xml</kbd>. In this case, any relative URL starting with <kbd class="calibre13">/courseService</kbd> would result in the invocation of our web service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Inspecting WSDL</h1>
                
            
            <article>
                
<p class="calibre3">We are done with implementing our web service. As you can see, JAX-WS really makes it very easy to develop web services. Let's now inspect<span class="calibre12"> the</span> WSDL of our web service. Configure Tomcat in Eclipse as described in <em class="calibre21">Installing Tomcat</em> section of <a target="_blank" href="part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 1</span></a>, <em class="calibre21">Introducing JEE and Eclipse</em> and in the <em class="calibre21">Configuring Tomcat in Eclipse</em> section of <a target="_blank" href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre21">Creating a Simple JEE Web Application</em>. To deploy the web application, right-click on the configured Tomcat server in <span class="calibre12">Servers</span> view and select<span class="calibre12"> the</span> <span class="calibre12">Add and Remove</span> option:</p>
<div class="mce-root1"><img src="../images/00196.jpeg" class="calibre206"/></div>
<div class="packt_figure1">Figure 9.9: Add a project to Tomcat</div>
<p class="calibre3">Add the project and click <span class="calibre12">Finish</span>.</p>
<p class="calibre3">Start the Tomcat server by right-clicking on the configured server in<span class="calibre12"> the</span> <span class="calibre12">Servers</span> view and selecting <span class="calibre12">Start</span>.</p>
<p class="calibre3">To inspect<span class="calibre12"> the</span> WSDL of our web service, browse to <kbd class="calibre13">http://localhost:8080/CourseMgmtWSProject/courseService?wsdl</kbd> (assuming that Tomcat is running on port <kbd class="calibre13">8080</kbd>). The following WSDL should be generated (see<span class="calibre12"> the</span> description following <em class="calibre21">Figure 9.6</em> in the <q class="calibre207">WSDL</q><span class="calibre12"> s</span><span class="calibre12">ection</span> <span class="calibre12">to understand<span class="calibre12"> the</span> structure of the WSDL generated here):</span></p>
<pre class="calibre25">&lt;definitions 
   
   <br class="title-page-name"/>    <br class="title-page-name"/>    <br class="title-page-name"/>    <br class="title-page-name"/> targetNamespace="http://soap.ws.eclipse.jee.packt/" 
  name="CourseManagementServiceService"&gt; 
  &lt;types&gt; 
    &lt;xsd:schema&gt; 
      &lt;xsd:import namespace="http://soap.ws.eclipse.jee.packt/" 
schemaLocation="http://localhost:8080/CourseMgmtWSProject/courseService?xsd=1" /&gt; 
    &lt;/xsd:schema&gt; 
  &lt;/types&gt; 
  &lt;message name="getCourses"&gt; 
    &lt;part name="parameters" element="tns:getCourses" /&gt; 
  &lt;/message&gt; 
  &lt;message name="getCoursesResponse"&gt; 
    &lt;part name="parameters" element="tns:getCoursesResponse" /&gt; 
  &lt;/message&gt; 
  &lt;message name="getCourse"&gt; 
    &lt;part name="parameters" element="tns:getCourse" /&gt; 
  &lt;/message&gt; 
  &lt;message name="getCourseResponse"&gt; 
    &lt;part name="parameters" element="tns:getCourseResponse" /&gt; 
  &lt;/message&gt; 
  &lt;portType name="CourseManagementService"&gt; 
    &lt;operation name="getCourses"&gt; 
      &lt;input 
wsam:Action="http://soap.ws.eclipse.jee.packt/CourseManagementService/getCoursesRequest" 
        message="tns:getCourses" /&gt; 
      &lt;output 
wsam:Action="http://soap.ws.eclipse.jee.packt/CourseManagementService/getCoursesResponse" 
        message="tns:getCoursesResponse" /&gt; 
    &lt;/operation&gt; 
    &lt;operation name="getCourse"&gt; 
      &lt;input 
wsam:Action="http://soap.ws.eclipse.jee.packt/CourseManagementService/getCourseRequest" 
        message="tns:getCourse" /&gt; 
      &lt;output 
wsam:Action="http://soap.ws.eclipse.jee.packt/CourseManagementService/getCourseResponse" 
        message="tns:getCourseResponse" /&gt; 
    &lt;/operation&gt; 
  &lt;/portType&gt; 
  &lt;binding name="CourseManagementServicePortBinding" <br class="title-page-name"/>   type="tns:CourseManagementService"&gt; 
    &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" 
      style="document" /&gt; 
    &lt;operation name="getCourses"&gt; 
      &lt;soap:operation soapAction="" /&gt; 
      &lt;input&gt; 
        &lt;soap:body use="literal" /&gt; 
      &lt;/input&gt; 
      &lt;output&gt; 
        &lt;soap:body use="literal" /&gt; 
      &lt;/output&gt; 
    &lt;/operation&gt; 
    &lt;operation name="getCourse"&gt; 
      &lt;soap:operation soapAction="" /&gt; 
      &lt;input&gt; 
        &lt;soap:body use="literal" /&gt; 
      &lt;/input&gt; 
      &lt;output&gt; 
        &lt;soap:body use="literal" /&gt; 
      &lt;/output&gt; 
    &lt;/operation&gt; 
  &lt;/binding&gt; 
  &lt;service name="CourseManagementServiceService"&gt; 
    &lt;port name="CourseManagementServicePort" <br class="title-page-name"/>     binding="tns:CourseManagementServicePortBinding"&gt; 
      &lt;soap:address 
location="http://localhost:8080/CourseMgmtWSProject/courseService" <br class="title-page-name"/> /&gt; 
    &lt;/port&gt; 
  &lt;/service&gt; 
&lt;/definitions&gt; </pre>
<p class="calibre3">Notice that the schema (see the definitions of the <kbd class="calibre13">/types/xsd:schemas</kbd> element) for this web service is imported in the previous WSDL. You can see the schema generated at <kbd class="calibre13">http://localhost:8080/CourseMgmtWSProject/courseService?xsd=1</kbd>:</p>
<pre class="calibre25">&lt;xs:schema  
   version="1.0" 
  targetNamespace="http://soap.ws.eclipse.jee.packt/"&gt; 
 
  &lt;xs:element name="getCourse" type="tns:getCourse" /&gt; 
  &lt;xs:element name="getCourseResponse" <br class="title-page-name"/>   type="tns:getCourseResponse" /&gt; 
  &lt;xs:element name="getCourses" type="tns:getCourses" /&gt; 
  &lt;xs:element name="getCoursesResponse" <br class="title-page-name"/> type="tns:getCoursesResponse" /&gt; 
 
  &lt;xs:complexType name="getCourses"&gt; 
    &lt;xs:sequence /&gt; 
  &lt;/xs:complexType&gt; 
  &lt;xs:complexType name="getCoursesResponse"&gt; 
    &lt;xs:sequence&gt; 
      &lt;xs:element name="return" type="tns:course" minOccurs="0" 
        maxOccurs="unbounded" /&gt; 
    &lt;/xs:sequence&gt; 
  &lt;/xs:complexType&gt; 
  &lt;xs:complexType name="course"&gt; 
    &lt;xs:sequence&gt; 
      &lt;xs:element name="credits" type="xs:int" /&gt; 
      &lt;xs:element name="id" type="xs:int" /&gt; 
      &lt;xs:element name="name" type="xs:string" minOccurs="0" /&gt; 
    &lt;/xs:sequence&gt; 
  &lt;/xs:complexType&gt; 
  &lt;xs:complexType name="getCourse"&gt; 
    &lt;xs:sequence&gt; 
      &lt;xs:element name="arg0" type="xs:int" /&gt; 
    &lt;/xs:sequence&gt; 
  &lt;/xs:complexType&gt; 
  &lt;xs:complexType name="getCourseResponse"&gt; 
    &lt;xs:sequence&gt; 
      &lt;xs:element name="return" type="tns:course" minOccurs="0" /&gt; 
    &lt;/xs:sequence&gt; 
  &lt;/xs:complexType&gt; 
&lt;/xs:schema&gt;</pre>
<p class="calibre3">The schema document defines data types for<span class="calibre12"> the</span> <kbd class="calibre13">getCourse</kbd> and <kbd class="calibre13">getCourses</kbd> methods and their responses (<kbd class="calibre13">getCoursesResponse</kbd> and <kbd class="calibre13">getCourseResponse</kbd>), and also for<span class="calibre12"> the</span> <kbd class="calibre13">Course</kbd> class. It also declares members of the <kbd class="calibre13">Course</kbd> data type (<kbd class="calibre13">id</kbd>, <kbd class="calibre13">credits</kbd>, and <kbd class="calibre13">name</kbd>). Notice that<span class="calibre12"> the</span> <kbd class="calibre13">getCourse</kbd> data type has one child element (which is an argument to the call to<span class="calibre12"> the</span> <kbd class="calibre13">getCourse</kbd> method in <kbd class="calibre13">CourseManagementService</kbd>) called <kbd class="calibre13">arg0</kbd>, which is actually the course ID of<span class="calibre12"> the</span> <kbd class="calibre13">int</kbd> type. Further, notice<span class="calibre12"> the</span> definition of <kbd class="calibre13">getCoursesResponse</kbd>. In our implementation class, <kbd class="calibre13">getCourses</kbd> returns <kbd class="calibre13">List&lt;Course&gt;</kbd>, which is translated in WSDL (or types in WSDL) as a sequence of course types.</p>
<p class="calibre3">The following four messages are defined in the previous WSDL: <kbd class="calibre13">getCourses</kbd>, <kbd class="calibre13">getCoursesResponse</kbd>, <kbd class="calibre13">getCourse</kbd>, and <kbd class="calibre13">getCourseResponse</kbd>. Each message contains a part element that refers to data types declared in types (or schema).</p>
<p class="calibre3">The <kbd class="calibre13">PortType</kbd> name is the same as the web service implementation class called <kbd class="calibre13">CourseManagementService</kbd> and operations of the port are the same as public methods of the class. The input and output of each operation refers to messages already defined in the WSDL.</p>
<p class="calibre3">The binding defines the network transport type, which in this case is HTTP, and the style of message in the SOAP body, which is of the document type. We have not defined any message type in our web service implementation, but the JAX-WS reference implementation (Glassfish Metro) has set a default message type to <kbd class="calibre13">document</kbd>. Binding also defines the message encoding type for<span class="calibre12"> the</span> input and output messages of each operation.</p>
<p class="calibre3">Finally,<span class="calibre12"> the</span> <kbd class="calibre13">Service</kbd> element specifies<span class="calibre12"> the </span>location of the port, which is the URL that we access to invoke the web service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing a web service using an interface</h1>
                
            
            <article>
                
<p class="calibre3">All methods declared in our web service implementation class, <kbd class="calibre13">CourseManagementService</kbd>, are exposed as web service operations. However, if you want to expose only a limited set of methods from the <span class="calibre12">web service</span> implementation class, then you can use<span class="calibre12"> the</span> Java interface. For example, if we want to expose only<span class="calibre12"> the</span> <kbd class="calibre13">getCourses</kbd> method as a <span class="calibre12">web service</span> operation, then we can create an interface, let's say <kbd class="calibre13">ICourseManagementService</kbd>:</p>
<pre class="calibre25">package packt.jee.eclipse.ws.soap; 
 
import java.util.List; 
 
import javax.jws.WebService; 
 
@WebService 
public interface ICourseManagementService { 
  public List&lt;Course&gt; getCourses(); 
} </pre>
<p class="calibre3">The implementation class also needs to be annotated with <kbd class="calibre13">@WebService</kbd>, with<span class="calibre12"> the</span> <kbd class="calibre13">endpointInterface</kbd> attribute set to the interface name:</p>
<pre class="calibre25">package packt.jee.eclipse.ws.soap; 
 
import java.util.ArrayList; 
import java.util.List; 
 
import javax.jws.WebService; 
 
@WebService <br class="title-page-name"/> (endpointInterface="packt.jee.eclipse.ws.soap.ICourseManagementService") 
public class CourseManagementService implements ICourseManagementService { 
 
  //getCourses and getCourse methods follow here 
} </pre>
<p class="calibre3">Now, restart Tomcat and inspect the WSDL. You will notice that only the <kbd class="calibre13">getCourses</kbd> operation is defined in the WSDL.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Consuming a web service using JAX-WS</h1>
                
            
            <article>
                
<p class="calibre3">Let's now create a simple Java console app to consume the web service we created earlier. Select <span class="calibre12">File</span> | <span class="calibre12">New</span> | <span class="calibre12">Maven Project</span>. Select<span class="calibre12"> the</span> <span class="calibre12">Create a simple project</span> option on the first page and click <span class="calibre12">Next</span>. Enter<span class="calibre12"> the</span> following configuration details:</p>
<div class="mce-root1"><img src="../images/00197.jpeg" class="calibre208"/></div>
<div class="packt_figure1">Figure 9.10: Create a Maven project for the web service client</div>
<p class="calibre3">Make sure that the <span class="calibre12">Packaging</span> type is <kbd class="calibre13">jar</kbd>. Click <span class="calibre12">Finish</span>.</p>
<p class="calibre3">We will now generate a stub and a supporting class on the client side for invoking the web service. We will use<span class="calibre12"> the</span> <strong class="calibre5">wsimport</strong> tool to generate client classes. We will specify the package for the generated classes by using the <kbd class="calibre13">-p</kbd> option and the WSDL location to generate client classes. The wsimport tool is part of the JDK and should be available in<span class="calibre12"> the</span> <kbd class="calibre13">&lt;JDK_HOME&gt;/bin</kbd> folder, if you are using JDK 1.7 or later.</p>
<p class="calibre3">Change the folder to <kbd class="calibre13">&lt;project_home&gt;/src//main/java</kbd> and run the following command:</p>
<pre class="calibre25"><strong class="calibre1">wsimport -keep -p packt.jee.eclipse.ws.soap.client http://localhost:8080/CourseMgmtWSProject/courseService?wsdl</strong>
  </pre>
<p class="calibre3">The <kbd class="calibre13">-keep</kbd> flag instructs <kbd class="calibre13">wsimport</kbd> to keep the generated file and not delete it.</p>
<p class="calibre3">The <kbd class="calibre13">-p</kbd> option specifies<span class="calibre12"> the</span> package name for the generated classes.</p>
<p class="calibre3">The last argument is the WSDL location for the web service. In <span class="calibre12">Package Explorer</span> or <span class="calibre12">Project Explorer</span> of Eclipse, refresh the client project to see<span class="calibre12"> the</span> generated files. The files should be in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.eclipse.ws.soap.client</kbd> package.</p>
<p class="calibre3"><kbd class="calibre13">wsimport</kbd> generates a client-side class for each type defined in the schema (in the types element of WSDL). Therefore, you will find <kbd class="calibre13">Course</kbd>, <kbd class="calibre13">GetCourse</kbd>, <kbd class="calibre13">GetCourseResponse</kbd>, <kbd class="calibre13">GetCourses</kbd>, and <kbd class="calibre13">GetCoursesResponse</kbd> classes. Furthermore, it generates classes for<span class="calibre12"> the</span> <kbd class="calibre13">portType</kbd> (<kbd class="calibre13">CourseManagementService</kbd>) and <kbd class="calibre13">service</kbd> (<kbd class="calibre13">CourseManagementServiceService</kbd>) elements of the WSDL. Additionally, it creates an <kbd class="calibre13">ObjectFactory</kbd> class that creates Java objects from XML using JAXB.</p>
<p class="calibre3">Let's now write the code to actually call the web service. Create<span class="calibre12"> the</span> <kbd class="calibre13">CourseMgmtWSClient</kbd> class in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.eclipse.ws.soap.client.test</kbd> package:</p>
<pre class="calibre25">package packt.jee.eclipse.ws.soap.client.test; 
 
import packt.jee.eclipse.ws.soap.client.Course; 
import packt.jee.eclipse.ws.soap.client.CourseManagementService; 
import packt.jee.eclipse.ws.soap.client.CourseManagementServiceService; 
 
public class CourseMgmtWSClient { 
 
  public static void main(String[] args) { 
    CourseManagementServiceService service = new <br class="title-page-name"/> CourseManagementServiceService();    CourseManagementService port = <br class="title-page-name"/>     service.getCourseManagementServicePort(); 
 
    Course course = port.getCourse(1); 
    System.out.println("Course name = " + course.getName()); 
  } 
 
} </pre>
<p class="calibre3">We first create<span class="calibre12"> the</span> <kbd class="calibre13">Service</kbd> object and then get the port from it. The <kbd class="calibre13">port</kbd> object has operations defined for the web service. We then call the actual web service method on the <kbd class="calibre13">port</kbd> object. Right-click on the class and select <span class="calibre12">Run As</span> | <span class="calibre12">Java Application</span>. The output should be<span class="calibre12"> the</span> name of the course that we hardcoded in the web service implementation, which is <kbd class="calibre13">Course-1</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Specifying an argument name in a web service operation</h1>
                
            
            <article>
                
<p class="calibre3">As mentioned earlier, when WSDL was created for our <kbd class="calibre13">Course</kbd> web service, the argument for<span class="calibre12"> the</span> <kbd class="calibre13">getCourse</kbd> operation name was created as <kbd class="calibre13">arg0</kbd>. You can verify this by browsing to <kbd class="calibre13">http://localhost:8080/CourseMgmtWSProject/courseService?xsd=1</kbd> and checking<span class="calibre12"> the</span> <kbd class="calibre13">getCourse</kbd> type:</p>
<pre class="calibre25">&lt;xs:complexType name="getCourse"&gt; 
     &lt;xs:sequence&gt; 
         &lt;xs:element name="arg0" type="xs:int"/&gt; 
     &lt;/xs:sequence&gt; 
&lt;/xs:complexType&gt; </pre>
<p class="calibre3">Thus, the client-side-generated code (by <kbd class="calibre13">wsimport</kbd>) in <kbd class="calibre13">CourseManagementService.getCourse</kbd> also names the argument as <kbd class="calibre13">arg0</kbd>. It would be nice to give a meaningful name to arguments. This could be done easily be adding<span class="calibre12"> the</span> <kbd class="calibre13">@WSParam</kbd> annotation in our web service implementation class, <kbd class="calibre13">CourseManagementService</kbd>:</p>
<pre class="calibre25">public Course getCourse(@WebParam(name="courseId") int courseId) {...} </pre>
<p class="calibre3">Restart Tomcat after this change and browse to the WSDL schema URL (<kbd class="calibre13">http://localhost:8080/CourseMgmtWSProject/courseService?xsd=1</kbd>) again. You should now see a proper argument name in<span class="calibre12"> the</span> <kbd class="calibre13">getCourse</kbd> type:</p>
<pre class="calibre25">&lt;xs:complexType name="getCourse"&gt; 
     &lt;xs:sequence&gt; 
         &lt;xs:element name="courseId" type="xs:int"/&gt; 
     &lt;/xs:sequence&gt; 
&lt;/xs:complexType&gt; </pre>
<p class="calibre3">Generate the client-side code again by using <kbd class="calibre13">wsimport</kbd>, and you will see that argument of<span class="calibre12"> the</span> <kbd class="calibre13">getCourse</kbd> method is named <kbd class="calibre13">courseId</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Inspecting SOAP messages</h1>
                
            
            <article>
                
<p class="calibre3">Although you don't necessarily need to understand the SOAP messages passed between the web service and the client, sometimes inspecting SOAP messages exchanged between the two could help debug some of the issues.</p>
<p class="calibre3">You can print request and response SOAP messages when running the client quite easily by setting<span class="calibre12"> the</span> following system property:</p>
<p class="calibre3"><kbd class="calibre13">com.sun.xml.internal.ws.transport.http.client.HttpTransportPipe.dump=true</kbd></p>
<p class="calibre3">In Eclipse, right-click on<span class="calibre12"> the</span> <kbd class="calibre13">CourseMgmtWSClient</kbd> class and select <span class="calibre12">Run As</span> | <span class="calibre12">Run Configurations</span>. Click on<span class="calibre12"> the</span> <span class="calibre12">Arguments</span> tab and specify<span class="calibre12"> the</span> following VM argument:</p>
<p class="calibre3"><kbd class="calibre13">Dcom.sun.xml.internal.ws.transport.http.client.HttpTransportPipe.dump=true</kbd></p>
<div class="mce-root1"><img src="../images/00198.jpeg" class="calibre209"/></div>
<div class="packt_figure1">Figure 9.11: Set VM arguments</div>
<p class="calibre3">Click <span class="calibre12">Run</span>. You will see request and response SOAP messages printed in the <span class="calibre12">Console</span> window in Eclipse. After formatting the request message, this is what the request SOAP message looks like:</p>
<pre class="calibre25">&lt;?xml version="1.0" ?&gt; 
&lt;S:Envelope &gt; 
  &lt;S:Body&gt; 
    &lt;ns2:getCourse &gt; 
      &lt;courseId&gt;1&lt;/courseId&gt; 
    &lt;/ns2:getCourse&gt; 
  &lt;/S:Body&gt; 
&lt;/S:Envelope&gt; </pre>
<p class="calibre3">The response is as follows:</p>
<pre class="calibre25">&lt;?xml version='1.0' encoding='UTF-8'?&gt; 
&lt;S:Envelope &gt; 
  &lt;S:Body&gt; 
    &lt;ns2:getCourseResponse <br class="title-page-name"/>     &gt; 
      &lt;return&gt; 
        &lt;credits&gt;4&lt;/credits&gt; 
        &lt;id&gt;1&lt;/id&gt; 
        &lt;name&gt;Course-1&lt;/name&gt; 
      &lt;/return&gt; 
    &lt;/ns2:getCourseResponse&gt; 
  &lt;/S:Body&gt; 
&lt;/S:Envelope&gt; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Handling interfaces in RPC-style web services</h1>
                
            
            <article>
                
<p class="calibre3">Recall that the message style for our web service implementation class is <kbd class="calibre13">Document</kbd> and the encoding is <kbd class="calibre13">literal</kbd>. Let's change the style to RPC. Open <kbd class="calibre13">CourseManagementService.java</kbd> and change the style of the SOAP binding from <kbd class="calibre13">Style.DOCUMENT</kbd> to <kbd class="calibre13">Style.RPC</kbd>:</p>
<pre class="calibre25">@WebService 
@SOAPBinding(style=Style.RPC, use=Use.LITERAL) 
public class CourseManagementService {...} </pre>
<p class="calibre3">Restart Tomcat. In the Tomcat console, you might see the following error:</p>
<pre class="calibre25">    <strong class="calibre1">Caused by: com.sun.xml.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions</strong>
    <strong class="calibre1">java.util.List is an interface, and JAXB can't handle interfaces.</strong>
    <strong class="calibre1">  this problem is related to the following location:</strong>
    <strong class="calibre1">    at java.util.List</strong></pre>
<p class="calibre3">This problem is caused by<span class="calibre12"> the</span> following method definition in<span class="calibre12"> the</span> <kbd class="calibre13">CourseManagementService</kbd> class:</p>
<pre class="calibre25">  public List&lt;Course&gt; getCourses() {...} </pre>
<p class="calibre3">In RPC-style SOAP binding, JAX-WS uses JAXB, and JAXB cannot marshal interfaces very well. A blog entry at <a href="https://community.oracle.com/blogs/kohsuke/2006/06/06/jaxb-and-interfaces" class="calibre9"><span>https://</span>community.oracle.com/blogs/kohsuke/2006/06/06/jaxb-and-interfaces</a> tries to explain the reason for this. The workaround is to create a wrapper for <kbd class="calibre13">List</kbd> and annotate it with <kbd class="calibre13">@XMLElement</kbd>. So, create a new class called <kbd class="calibre13">Courses</kbd> in the same package:</p>
<pre class="calibre25">package packt.jee.eclipse.ws.soap; 
 
import java.util.List; 
 
import javax.xml.bind.annotation.XmlAnyElement; 
import javax.xml.bind.annotation.XmlRootElement; 
 
@XmlRootElement 
public class Courses { 
  @XmlAnyElement 
  public List&lt;Course&gt; courseList; 
 
  public Courses() { 
 
  } 
 
  public Courses (List&lt;Course&gt; courseList) { 
    this.courseList = courseList; 
  } 
} </pre>
<p class="calibre3">Then, modify<span class="calibre12"> the</span> <kbd class="calibre13">getCourses</kbd> method of <kbd class="calibre13">CourseManagementService</kbd> to return<span class="calibre12"> the</span> <kbd class="calibre13">Courses</kbd> object instead of <kbd class="calibre13">List&lt;Course&gt;</kbd>:</p>
<pre class="calibre25">  public Courses getCourses() { 
    //Here, courses could be fetched from database using, 
    //for example, JDBC or JDO. However, to keep this example 
    //simple, we will return hardcoded list of courses 
 
    List&lt;Course&gt; courses = new ArrayList&lt;Course&gt;(); 
 
    courses.add(new Course(1, "Course-1", 4)); 
    courses.add(new Course(2, "Course-2", 3)); 
 
    return new Courses(courses); 
  } </pre>
<p class="calibre3">Restart Tomcat. This time, the application should be deployed in Tomcat without any error. Re-generate the client classes by using <kbd class="calibre13">wsimport</kbd>, run the client application, and verify the results.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Handling exceptions</h1>
                
            
            <article>
                
<p class="calibre3">In JAX-WS, a Java exception thrown from a web service is mapped to SOAP fault when the XML payload is sent to the client. On the client side, JAX-WS maps SOAP fault to either <kbd class="calibre13">SOAPFaultException</kbd> or to the application-specific exception. The client code could wrap the web service call in a <kbd class="calibre13">try...catch</kbd> block to handle exceptions thrown from the web service.</p>
<div class="packt_tip"><br class="calibre26"/>
For a good description of how SOAP exceptions are handled in JAX-WS, refer to <a href="https://docs.oracle.com/cd/E24329_01/web.1211/e24965/faults.htm#WSADV624" class="calibre17"><span class="calibre23">https://docs.oracle.com/cd/E24329_01/web.1211/e24965/faults.htm#WSADV624</span></a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre3">Web services are a very useful technology for enterprise application integration. They allow disparate systems to communicate with each other. Web service APIs are typically self-contained and lightweight.</p>
<p class="calibre3">There are broadly two types of web services: SOAP-based and RESTful. SOAP-based web services are XML-based and provide many features such as security, attachments, and transactions. RESTful web services can exchange data by using XML or JSON. RESTful JSON web services are quite popular because they can be easily consumed from JavaScript code.</p>
<p class="calibre3">In this chapter, we learned how to develop and consume RESTful and SOAP-based web services by using the latest Java specifications, JAX-RS and JAX-WS.</p>
<p class="calibre3">In the next chapter, we will take a look at another technology for application integration: asynchronous programming using <strong class="calibre5">Java Messaging Service</strong> (<strong class="calibre5"><span class="calibre12">JMS</span></strong>).</p>


            </article>

            
        </section>
    </body></html>