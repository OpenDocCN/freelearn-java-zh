<html><head></head><body>
<div class="book" title="Chapter&#xA0;5.&#xA0;Efficient Searching &#x2013; Binary Search and Sorting"><div class="book" id="11C3M2-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. Efficient Searching – Binary Search and Sorting</h1></div></div></div><p class="calibre8">What is searching? Searching is trying to locate a given value in a collection of values. For example, you<a id="id215" class="calibre1"/> are given an array of integers, and your problem is to check whether the integer <span class="strong"><em class="calibre12">5</em></span> is in that array. This is a search problem. In addition to just deciding whether the element <span class="strong"><em class="calibre12">5</em></span> is in the array, we may be interested in its location as well when it is found. This is also a search problem.</p><p class="calibre8">Another interesting take on it would be to imagine a dictionary, that is, an array of values and associated values. For example, you have an array of names of students and their marks, as shown in the following table:</p><div class="informalexample"><table border="1" class="calibre17"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre23">Name</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre23">Marks</p>
</th></tr></thead><tbody class="calibre24"><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">Tom</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">63</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">Harry</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">70</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">Merry</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">65</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">Aisha</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">85</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">Abdullah</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">72</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">…</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">...</p>
</td></tr></tbody></table></div><p class="calibre8">The list continues. Suppose, our system lets the student view his/her own marks. They would type their name and the system would show their marks. For simplicity, let's assume that there are no duplicate names. Now, we have to search for the name provided and return the corresponding values. This is, thus, another search problem. As we will see, search problems are quite ubiquitous in programming.</p><p class="calibre8">In this chapter, you will learn the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Search algorithms</li><li class="listitem">Efficient searching in a sorted list</li><li class="listitem">Some sorting algorithms</li></ul></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Efficient Searching &#x2013; Binary Search and Sorting">
<div class="book" title="Search algorithms"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec28" class="calibre1"/>Search algorithms</h1></div></div></div><p class="calibre8">Suppose <a id="id216" class="calibre1"/>you are given an array of values and you are required to check whether a particular value is in that array, what is the most natural way to find that element? Well, it seems that the natural way is to go through each element one by one and check whether they match the given value. If any one does, we have found that element and we can return the index; if not, we can return <code class="email">-1</code> at the end of processing all the elements to report that such an element could not be found. This is what we would <a id="id217" class="calibre1"/>call a <span class="strong"><strong class="calibre2">linear search</strong></span>. The following demonstrates a linear search algorithm in an array:</p><div class="informalexample"><pre class="programlisting">    public static &lt;E, F extends E&gt; int linearSearch(E[] values, 
    valueToLookup) { 
        for (int i = 0; i &lt; values.length; i++) { 
            if (values[i].equals(valueToLookup)) { 
                return i; 
            } 
        } 
        return -1; 
    }</pre></div><p class="calibre8">The function <code class="email">linearSearch</code> takes an array of values and a value to search in it, and returns the index if the value is found. If not, it returns a special value, <code class="email">-1</code>. The program simply goes through each element and checks whether the current element matches with the value to lookup; if it does, then it just returns the current index, otherwise it keeps looking. At the end of the array, it returns the special value, <code class="email">-1</code>. Now the following piece of code should return <code class="email">-1</code> in the first case and the value <code class="email">5</code> in the second case:</p><div class="informalexample"><pre class="programlisting">        Integer[] integers = new Integer[]{232,54,1,213,654,23,6,72,21}; 
        System.out.println(ArraySearcher.linearSearch(integers,5)); 
        System.out.println(ArraySearcher.linearSearch(integers,23));</pre></div><p class="calibre8">Now, if we want to solve the student-marks problem described in the introduction of this chapter, we just <a id="id218" class="calibre1"/>need to have the marks of the students stored in a different array in the same order, as follows:</p><div class="informalexample"><pre class="programlisting">    static String[] students = new String[]{"Tom","Harry","Merry","Aisha", "Abdullah"}; 
    static int[] marks = new int[]{63,70, 65, 85, 72}; </pre></div><p class="calibre8">Now we can write a function to search for a name:</p><div class="informalexample"><pre class="programlisting">    public static Integer marksForName(String name){ 
        int index = linearSearch(students, name); 
        if(index&gt;=0){ 
            return marks[index]; 
        }else{ 
            return null; 
        } 
    }</pre></div><p class="calibre8">First, we look for the name of the students in the list of students. If the name is found, the corresponding index would be assigned to the variable index and the value would be greater than or equal to zero. In such a case, we return the marks stored in the same index as of the marks array. If it is not found, we return null. To lookup the marks for Merry, for example, we call as shown here:</p><div class="informalexample"><pre class="programlisting">        System.out.println(marksForName("Merry"));</pre></div><p class="calibre8">We correctly obtain her marks, that are, <code class="email">65</code>.</p><p class="calibre8">What is the complexity of linear search? We have a <code class="email">for</code> loop that moves through each element of an array of length <span class="strong"><em class="calibre12">n</em></span> (say); in the worst case, we would go through all the elements, so the worst case complexity is <span class="strong"><em class="calibre12">θ(n)</em></span>. Even on an average, we would be visiting half the elements before we hit the correct element, so the average case complexity is <span class="strong"><em class="calibre12">θ(n/2) = θ(n)</em></span>.</p></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Efficient Searching &#x2013; Binary Search and Sorting">
<div class="book" title="Search algorithms">
<div class="book" title="Binary search"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec37" class="calibre1"/>Binary search</h2></div></div></div><p class="calibre8">Is a linear <a id="id219" class="calibre1"/>search the best we can do? Well, it turns out that if <a id="id220" class="calibre1"/>we are looking at an arbitrary array, this is what we have to do. After all, in an arbitrary array, there is no way to know whether an element is there without potentially looking at all of them. More specifically, we cannot say for sure that some element does not exist, without verifying all the elements. The reason is that the value of one element does not say anything about the values of the other elements.</p><p class="calibre8">But, what information can one element have about other elements in an array? One way to make elements have information about the other elements is to have a sorted array instead of just an arbitrary array. What is a sorted array? A sorted array is an array that has all the elements arranged in order of their values. When an array is sorted, every element contains the information that everything on the left is smaller than that particular element, and everything on the right is bigger (or the other way round if the order of the elements is opposite, but we will consider the arrays that are sorted in an increasing order from left to right). This<a id="id221" class="calibre1"/> information can, amazingly, make this <a id="id222" class="calibre1"/>search a lot faster. Here is what we do:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Check the middle element of the array. If it matches the element we are searching for, we are done.</li><li class="listitem">If the middle element is smaller than the value we are searching for, search on the subarray on the right of the current array. This is because everything on the left is even smaller.</li><li class="listitem">If the middle element is bigger than the value we are searching for, search only in the left sub-array.</li></ul></div><p class="calibre8">To avoid creating copies of the array while creating a sub-array, we just pass on the whole array, but we remember the start and end positions we are looking at. The start is included in the range and end is excluded. So, only elements on the right of the start position and the left of the end position are included in the subarray being searched. The following figure gives a visual understanding of binary search:</p><div class="mediaobject"><img src="../images/00027.jpeg" alt="Binary search" class="calibre9"/><div class="caption"><p class="calibre15">Figure 1: Binary Search.</p></div></div><p class="calibre10"> </p><p class="calibre8">An arrow representing moving one element to another during the search.</p><p class="calibre8">But, before<a id="id223" class="calibre1"/> implementing this algorithm, we need to <a id="id224" class="calibre1"/>understand the concept of <code class="email">Comparable</code>. <code class="email">Comparable</code> is an interface in the Java standard library that looks like this:</p><div class="informalexample"><pre class="programlisting">package java.lang; 
public interface Comparable&lt;T&gt; { 
    public int compareTo(T o); 
} </pre></div><p class="calibre8">Any class implementing this interface has to compare a different object with itself. It is required that the type parameter, <span class="strong"><em class="calibre12">T</em></span>, must be instantiated with the same class that implements it, like this:</p><div class="informalexample"><pre class="programlisting">public class Integer implements Comparable&lt;Integer&gt;{
    public int compareTo(Integer o){
        …
    } 
}</pre></div><p class="calibre8">The <code class="email">compareTo</code> method intends to compare an object of the same type. If the current object (the one that the <code class="email">this</code> reference refers to) is smaller than the object passed, <code class="email">compareTo</code> must return a negative value. If the object passed is smaller, the method must return a positive value. Otherwise, if they are equal, it must return <code class="email">0</code>. The following conditions are<a id="id225" class="calibre1"/> required to be fulfilled by the <code class="email">compareTo</code> method:</p><div class="book"><ul class="itemizedlist"><li class="listitem">If <code class="email">a.compareTo(b) == 0</code>, then <code class="email">a.equals(b)</code> must be <code class="email">true</code></li><li class="listitem">If <code class="email">a.compareTo(b) &lt; 0</code> and b<code class="email">.compareTo(c) &lt; 0</code>, then <code class="email">a.compareTo(c) &lt;0</code></li><li class="listitem">If <code class="email">a.compareTo(b) &lt;0</code>, then <code class="email">b.compareTo(a) &gt; 0</code></li><li class="listitem">If <code class="email">b.equals(c)</code> is true and <code class="email">a.compareTo(b) &lt;0</code>, then <code class="email">a.compareTo(c) &lt;0</code></li><li class="listitem">If <code class="email">b.equals(c)</code> is true and <code class="email">a.compareTo(b) &gt;0</code>, then <code class="email">a.compareTo(c) &gt;0</code></li></ul></div><p class="calibre8">Basically, the<a id="id226" class="calibre1"/> conditions are the same for a total order where equality is represented by the equals method. It basically generalizes the concept of the <code class="email">&lt;</code> and <code class="email">&lt;=</code> operators, which are there for numbers. Of course, the <code class="email">compareTo</code> method for the <code class="email">Wrapper</code> objects are implemented exactly as the <code class="email">&lt;</code> and <code class="email">&lt;=</code> operators are on the primitives inside them.</p><p class="calibre8">Now, we write the search function to do the search, as per the preceding steps:</p><div class="informalexample"><pre class="programlisting">    private static &lt;E extends Comparable&lt;E&gt;, 
      F extends E&gt; int binarySearch( E[] sortedValues, 
      F valueToSearch, int start, int end) { 
        if(start&gt;=end){ 
            return -1; 
        } 
        int midIndex = (end+start)/2; 
        int comparison = sortedValues[midIndex].compareTo(valueToSearch); 
        if(comparison==0){ 
            return midIndex; 
        }else if(comparison&gt;0){ 
            return binarySearch(sortedValues, valueToSearch, start, midIndex); 
        }else{ 
            return binarySearch(sortedValues, valueToSearch, midIndex+1, end); 
        } 
    }</pre></div><p class="calibre8">Note that in this case, we have mandated that the objects in the array must be comparable so that we can know if an object is greater than or less than another object. It does not matter exactly how this relationship is determined; the array must be sorted using the same comparison – that the comparison between two consecutive elements will make sure the element on<a id="id227" class="calibre1"/> the left is  smaller than the one on the right, as<a id="id228" class="calibre1"/> provided by <code class="email">Comparable</code>.</p><p class="calibre8">The first <code class="email">if</code> condition checks whether the array passed is empty, if so, obviously the element to be searched is not found and we return <code class="email">-1</code> to represent this. Then, we find the <code class="email">midIndex</code> and recursively search for the element in either the left or the right subarray. Once we have this function, we create another wrapper function to run the search without having to mention the start and the end positions:</p><div class="informalexample"><pre class="programlisting">    public static &lt;E extends Comparable&lt;E&gt;, F extends E&gt; int binarySearch( 
            E[] sortedValues, F valueToSearch) { 
        return binarySearch(sortedValues, valueToSearch, 0, sortedValues.length); 
    }</pre></div><div class="book" title="Complexity of the binary search algorithm"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch05lvl3sec11" class="calibre1"/>Complexity of the binary search algorithm</h3></div></div></div><p class="calibre8">In every step, we are partitioning the total array into two parts, barring the one element that we are <a id="id229" class="calibre1"/>comparing. In the worst case, that is, the case where the element searched is not present in the array, we will have to get down all the way to the point where we are dealing with an empty array, in which case we return <code class="email">-1</code> and stop recursing. We must have had an array of only one element in the previous step. For our analysis, we will consider this step as the last step. So, let's have a sorted array of <span class="strong"><em class="calibre12">n</em></span> elements and <span class="strong"><em class="calibre12">T(.)</em></span> is the time required for searching in the array. So, we have the following:</p><div class="informalexample"><pre class="programlisting">T(n) = T((n-1)/2) + C, where C is a constant.</pre></div><p class="calibre8">In general, the two search branches in every step would be of different sizes, one potentially being of size one less than that of the other part. But we will ignore these small differences, which hardly matter for a large <span class="strong"><em class="calibre12">n</em></span>. Hence, we will work with the following equation:</p><div class="informalexample"><pre class="programlisting">T(n) = T(n/2) + C</pre></div><p class="calibre8">Now, let's assume that <span class="strong"><em class="calibre12">n</em></span> is an integral power of <span class="strong"><em class="calibre12">2</em></span> so that <span class="strong"><em class="calibre12">n = 2m</em></span> for some integer <span class="strong"><em class="calibre12">m</em></span>. So, we have this:</p><div class="informalexample"><pre class="programlisting">T(2m) = T(2m-1) + C</pre></div><p class="calibre8">Now we take another function <span class="strong"><em class="calibre12">S(.)</em></span>, such that <span class="strong"><em class="calibre12">S(m) = T(2m)</em></span> for all <span class="strong"><em class="calibre12">m</em></span>. Then, we have:</p><div class="informalexample"><pre class="programlisting">S(m) = S(m-1) + C</pre></div><p class="calibre8">This is the formula for an arithmetic progression. And hence, we have this:</p><div class="informalexample"><pre class="programlisting">S(m) = mC + D, where D is also a constant.
=&gt; T(2m) = mC + D
=&gt; T(n) = C lg(n) + D</pre></div><p class="calibre8">So, we have the asymptotic complexity of <span class="strong"><em class="calibre12">T(n)</em></span>:</p><div class="informalexample"><pre class="programlisting">T(n) = O(lg(n))</pre></div><p class="calibre8">The function, <span class="strong"><em class="calibre12">T(n)</em></span>, grows only as fast as the logarithm of the size of the array passed, which is really slow. This makes binary search an extremely efficient algorithm.</p><p class="calibre8">To sort <a id="id230" class="calibre1"/>of field test the algorithms, we run both linear and binary search algorithms on an array of a hundred million elements with the following code:</p><div class="informalexample"><pre class="programlisting">        int arraySize = 100000000; 
        Long array[] = new Long[arraySize]; 
        array[0] = (long)(Math.random()*100); 
        for(int i=1;i&lt;array.length;i++){ 
            array[i] = array[i-1] + (long)(Math.random()*100); 
        } 

        //let us look for an element using linear and binary search 
        long start = System.currentTimeMillis(); 
        linearSearch(array, 31232L); 
        long linEnd = System.currentTimeMillis(); 
        binarySearch(array, 31232L); 
        long binEnd = System.currentTimeMillis(); 

        System.out.println("linear search time :=" + (linEnd -start)); 
        System.out.println("binary search time :=" + (binEnd -linEnd));</pre></div><p class="calibre8">On my computer, the linear search took 282 milliseconds and binary search took 0 milliseconds. Also, note that the value we are looking for is expected to be quite near to the beginning of the array; in case of values near the middle, a binary search would have an even higher advantage.</p></div></div></div></div>

<div class="book" title="Sorting"><div class="book" id="12AK82-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec29" class="calibre1"/>Sorting</h1></div></div></div><p class="calibre8">Okay, so we are <a id="id231" class="calibre1"/>convinced that if we have a sorted array, it takes a lot less time to find an element in it. But how do we get a sorted array? An arbitrary array is unlikely to be sorted. The algorithm of getting a sorted array out of an arbitrary array while keeping all the elements same, that is, by only rearranging the elements of an input array, is called sorting. There are a lot of algorithms for sorting. But in this chapter, we will start with a few simple ones that are not efficient. In the next chapter, we will explore efficient sorting algorithms.</p></div>

<div class="book" title="Sorting">
<div class="book" title="Selection sort"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec38" class="calibre1"/>Selection sort</h2></div></div></div><p class="calibre8">This is the <a id="id232" class="calibre1"/>most natural algorithm for sorting. We choose each position of the <a id="id233" class="calibre1"/>array and find the element in the array that belongs in that position. The functional definition of selection sort is as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Find the minimum element in an array</li><li class="listitem">Swap this element with the first element of the array</li><li class="listitem">Sort the rest of the array after the first element recursively</li></ul></div><p class="calibre8">Finding the minimum element has the functional structure as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Consider the array as a composition of the first element and the rest of the array.</li><li class="listitem">Find the index of the minimum element in the rest of the array.</li><li class="listitem">Compare this element with the first element. If this element is smaller than the first element, then it is the minimum element in the entire array. Otherwise, the first element is the minimum element.</li></ul></div><p class="calibre8">Instead of making copies of the array, we represent subarrays by simply storing the starting index we want to consider, and then we work on the index recursively.</p><p class="calibre8">First, we write a function to find the index of the minimum element in a given array, starting from a position:</p><div class="informalexample"><pre class="programlisting">    public static &lt;E extends Comparable&lt;E&gt;&gt; int findMin(E[] array, int start){ </pre></div><p class="calibre8">Then, we check whether the start position is the last position in the array, in which case we just simply return the start position as there are no more elements:</p><div class="informalexample"><pre class="programlisting">        if(start==array.length-1){ 
            return start; 
        } </pre></div><p class="calibre8">We find the index of the minimum element in the array to the right of the current start position and compare that element with the current start element. We return whichever has the <a id="id234" class="calibre1"/>minimum element, as demonstrated in the following:</p><div class="informalexample"><pre class="programlisting">        int restMinIndex = findMin(array, start+1); 
        E restMin = array[restMinIndex]; 
        if(restMin.compareTo(array[start])&lt;0){ 
            return restMinIndex; 
        }else { 
            return start; 
        } 
    }</pre></div><p class="calibre8">The <code class="email">swap</code> function <a id="id235" class="calibre1"/>swaps or interchanges two elements in the array at the given positions. This function is pretty straightforward:</p><div class="informalexample"><pre class="programlisting">    public static &lt;E&gt; void swap(E[] array, int i, int j){ 
        if(i==j) 
            return; 
        E temp = array[i]; 
        array[i]=array[j]; 
        array[j] = temp; 
    }</pre></div><p class="calibre8">With the <code class="email">findMin</code> and <code class="email">swap</code> functions in our repository, we can finally put down the <code class="email">selectionSort</code> algorithm. We start off by passing the position zero as the value of the start parameter:</p><div class="informalexample"><pre class="programlisting">    public static &lt;E extends Comparable&lt;E&gt;&gt; void selectionSort(
    E[] array, int start){ </pre></div><p class="calibre8">Firstly, there is no sorting to be done if the array is empty:</p><div class="informalexample"><pre class="programlisting">        if(start&gt;=array.length){ 
            return; 
        } </pre></div><p class="calibre8">Now, we just find the index of the minimum element and swap the current position with the index of the minimum position. This will put the minimum element in the current position:</p><div class="informalexample"><pre class="programlisting">        int minElement = findMin(array, start); 
        swap(array,start, minElement); </pre></div><p class="calibre8">Then, we recursively sort the rest of the array:</p><div class="informalexample"><pre class="programlisting">        selectionSort(array, start+1); 
    }</pre></div><p class="calibre8">Now, we can write a wrapper function to just do <code class="email">selectionSort</code> without having to pass a start index:</p><div class="informalexample"><pre class="programlisting">    public static &lt;E extends Comparable&lt;E&gt;&gt; void selectionSort( 
    E[] array) { 
        selectionSort(array, 0); 
    }</pre></div><p class="calibre8">We can <a id="id236" class="calibre1"/>test our code by creating an arbitrary array and then sorting it using our algorithm:</p><div class="informalexample"><pre class="programlisting">        Integer[] array = new Integer[]{10, 5, 2, 3, 78, 53, 3}; 
        selectionSort(array); 
        System.out.println(Arrays.toString(array));</pre></div><p class="calibre8">And the output would be as follows:</p><div class="informalexample"><pre class="programlisting">[2, 3, 3, 5, 10, 53, 78]</pre></div><p class="calibre8">Note how all the<a id="id237" class="calibre1"/> elements are repositioned in ascending order, which means that the array is sorted.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note06" class="calibre1"/>Note</h3><p class="calibre8">The  form of selection sort shown is not functional in a strict sense because we are modifying the contents of an array. A truly functional sort of an array will make a copy of the array on every modification. However, this is very expensive. On the other hand, thinking of the algorithm in terms of smaller versions of the same problem, like we have done, does make the algorithm simpler to understand. I tried to hit a sweet spot where I have the simplicity of the recursive algorithm, but don't have to keep creating copies of the array.</p></div><div class="book" title="Complexity of the selection sort algorithm"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch05lvl3sec12" class="calibre1"/>Complexity of the selection sort algorithm</h3></div></div></div><p class="calibre8">To compute the <a id="id238" class="calibre1"/>complexity of the selection sort algorithm, first we have to compute the complexity of the <code class="email">findMin</code> and <code class="email">swap</code> functions. Let's start with the <code class="email">findMin</code> function. As with any recursive function, we start with assuming that with an array of length <span class="strong"><em class="calibre12">n</em></span> (in this case, the effective length of the array, starting from the start position), it takes us <span class="strong"><em class="calibre12">T(n)</em></span> time to compute the <code class="email">findMin</code> function. While recursively calling itself, it passes on an effective array of length <span class="strong"><em class="calibre12">n-1</em></span>. So, we have the following equation:</p><div class="informalexample"><pre class="programlisting">T(n) = T(n-1) + A where A is a constants
=&gt; T(n) – T(n-1) = A, so it is an arithmetic progression
=&gt; T(n) = An + B where B is a constant
=&gt; T(n) = θ(n)</pre></div><p class="calibre8">Now, let's move on to the <code class="email">swap</code> function. It has no recursion and no loops, so the complexity is constant or <span class="strong"><em class="calibre12">θ(1)</em></span>.</p><p class="calibre8">Finally, we are ready to compute the complexity of the function <code class="email">selectionSort</code>. Say, for an effective length <span class="strong"><em class="calibre12">n</em></span> of an array, the time taken is <span class="strong"><em class="calibre12">T(n)</em></span>. It calls itself with effective length <span class="strong"><em class="calibre12">n-1</em></span>, it also calls <code class="email">findMin</code> and <code class="email">swap</code> functions, which are <span class="strong"><em class="calibre12">θ(n)</em></span> and <span class="strong"><em class="calibre12">θ(1)</em></span>, respectively. So, we have this:</p><div class="informalexample"><pre class="programlisting">T(n) = T(n-1) + θ(n) + θ(1)</pre></div><p class="calibre8">Note that some <a id="id239" class="calibre1"/>expressions that are <span class="strong"><em class="calibre12">θ (n)</em></span> have been written as <span class="strong"><em class="calibre12">θ (n)</em></span> itself. It should be read as, "<span class="strong"><em class="calibre12">Some function of n that has the asymptotic complexity, θ (n)</em></span>." It turns out, for computing complexity of <span class="strong"><em class="calibre12">T(n)</em></span>, we don't have to actually know the actual expression, we can simply put <span class="strong"><em class="calibre12">Cn</em></span> and <span class="strong"><em class="calibre12">D</em></span> for functions that are <span class="strong"><em class="calibre12">θ (n)</em></span> and <span class="strong"><em class="calibre12">θ (1)</em></span>, respectively, where <span class="strong"><em class="calibre12">C</em></span> and <span class="strong"><em class="calibre12">D</em></span> are constants. So, we form the following equation:</p><div class="informalexample"><pre class="programlisting">T(n) = T(n-1) + Cn + D
=&gt; T(n) – T(n-1) = Cn + D</pre></div><p class="calibre8">Similarly, <span class="strong"><em class="calibre12">T(n-1) - T(n-2) = C(n-1) + D</em></span> and so on. If we stack these equations, we get the following:</p><div class="informalexample"><pre class="programlisting">T(n) – T(n-1) = Cn + D
 T(n-1) – T(n-2) = C(n-1) + D
 T(n-2) – T(n-3) = C(n-2) + D
 T(n-3) – T(n-4) = C(n-3) + D
…
 T(1) – T(0) = C(1) + D</pre></div><p class="calibre8">Adding both sides, we get this:</p><div class="mediaobject"><img src="../images/00028.jpeg" alt="Complexity of the selection sort algorithm" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">So, the selection <a id="id240" class="calibre1"/>sort has a complexity of <span class="strong"><em class="calibre12">θ(n2)</em></span>, where <span class="strong"><em class="calibre12">n</em></span> is the size of the array being sorted. Now, we will see the next sorting algorithm, which is the insertion sort.</p></div></div></div>

<div class="book" title="Sorting">
<div class="book" title="Insertion sort"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec39" class="calibre1"/>Insertion sort</h2></div></div></div><p class="calibre8">In selection sort, we first selected a position and then found the element that should sit there. In the<a id="id241" class="calibre1"/> insertion sort, we do the opposite; we first select an element <a id="id242" class="calibre1"/>and then insert the element into position where it should sit. So, for every element, we first find out where it should be and then we insert the element in the right place. So, we first see how to insert an element into a sorted array. The idea is that we are given an array of sorted elements and we are supposed to insert another element in the correct position, so that the resulting array remains sorted. We will consider a simpler problem. We are given an array that is sorted except for the last element. Our job is to insert the last element in the correct position. The recursive way to achieve this insertion is as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">If the element to be inserted is bigger than the end element of the sorted array, it belongs in the end and the insertion is complete.</li><li class="listitem">Otherwise, we swap the last element with the element to be inserted and recursively insert this element in the rest of the smaller array in front of it.</li></ul></div><p class="calibre8">We do it with the following function. The function takes an array and a position that represents this last position:</p><div class="informalexample"><pre class="programlisting">    public static &lt;E extends Comparable&lt;E&gt;&gt; void insertElementSorted( 
    E[] array, int valueIndex) { 

        if (valueIndex &gt; 0 &amp;&amp; array[valueIndex].compareTo(array[valueIndex - 1]) &lt; 0) { 
            swap(array, valueIndex, valueIndex - 1); 
            insertElementSorted(array, valueIndex - 1); 
        } 

    }</pre></div><p class="calibre8">If the last position or the <code class="email">valueIndex</code> is <code class="email">0</code>, there is nothing to be done, as the element is already in the correct position, that is, <code class="email">0</code>. There is no array to the left of <code class="email">valueIndex</code> in this case. If not, we compare the last element to the previous element. Since the array on the left is presumed to be sorted, the previous element is the largest element in the sorted part of the array. If the last element is bigger than even this one, there is nothing more to be done. If not, we swap the last element with the previous one and run the insertion recursively on the array with one less element. The last element has moved to the previous position and it must now be compared with the element before that, and so on.</p><p class="calibre8">With the insertion function available for sorted arrays, we are now ready to write the algorithm for an insertion sort. In every step of the insertion sort, we consider a boundary in the array. Everything on the left of the boundary has already been sorted. Our job in the current step is to insert the element at the boundary index into the left sorted array, which we achieve using the <code class="email">insertElementSorted</code> function. We implement this sort with the <a id="id243" class="calibre1"/>following simple strategy. In any step, we do the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">We first sort <a id="id244" class="calibre1"/>the left-hand side of the boundary so that our assumption about it being sorted is achieved</li><li class="listitem">Then we invoke the <code class="email">insertElementSorted</code> function to insert the current boundary element in the sorted array</li></ul></div><p class="calibre8">Of course, when <code class="email">boundary</code> is zero, it means that there is no array to be sorted and we simply return:</p><div class="informalexample"><pre class="programlisting">    public static &lt;E extends Comparable&lt;E&gt;&gt; void insertionSort( 
    E[] array, int boundary) { 
        if(boundary==0){ 
            return; 
        } 
        insertionSort(array, boundary-1); 
        insertElementSorted(array, boundary); 
    }</pre></div><div class="book" title="Complexity of insertion sort"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch05lvl3sec13" class="calibre1"/>Complexity of insertion sort</h3></div></div></div><p class="calibre8">To compute the <a id="id245" class="calibre1"/>complexity of insertion sort, we must first compute it for the <code class="email">insertElementSorted</code> function. Let the time taken for an array of effective length (that is, from <span class="strong"><em class="calibre12">zero to boundary-1</em></span>), <span class="strong"><em class="calibre12">n</em></span> be <span class="strong"><em class="calibre12">T(n)</em></span>. From there, we recursively call it with <span class="strong"><em class="calibre12">n-1</em></span>. So, we have the following:</p><div class="informalexample"><pre class="programlisting">T(n) = T(n-1) + C where C is a constant 
=&gt; T(n) = θ(n)</pre></div><p class="calibre8">Let's now assume that the time taken for sorting an array of <span class="strong"><em class="calibre12">n</em></span> elements is <span class="strong"><em class="calibre12">S(n)</em></span>. Apart from the base case, it calls itself with one less argument and then calls the <code class="email">insertElementSorted</code> function with an array of effective length <span class="strong"><em class="calibre12">n-1</em></span>. Thus, we have this:</p><div class="informalexample"><pre class="programlisting">S(n) = S(n-1) + T(n) + D where D is a constant.</pre></div><p class="calibre8">Again, when <span class="strong"><em class="calibre12">n</em></span> is large, <span class="strong"><em class="calibre12">T(n) = θ(n)</em></span>; hence, it can be approximated by <span class="strong"><em class="calibre12">An</em></span> where <span class="strong"><em class="calibre12">A</em></span> is a constant. So, we have this:</p><div class="informalexample"><pre class="programlisting">S(n)  = S(n-1) + An + D
=&gt; S(n) – S(n-1) = An + D,</pre></div><p class="calibre8">Since this is true for all <span class="strong"><em class="calibre12">n</em></span>, we have:</p><div class="informalexample"><pre class="programlisting"> S(n) – S(n-1) = An + D
 S(n-1) – S(n-2) = A(n-1) + D
 S(n-2) – S(n-3) = A(n-2) + D
…
 S(1) – S(0) = A + D</pre></div><p class="calibre8">Summing <a id="id246" class="calibre1"/>both sides, we get the following:</p><p class="calibre8"> </p><div class="mediaobject"><img src="../images/00029.jpeg" alt="Complexity of insertion sort" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">
</p><p class="calibre8">Thus, insertion sort has the same asymptotic complexity as selection sort.</p></div></div></div>

<div class="book" title="Sorting">
<div class="book" title="Bubble sort"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec40" class="calibre1"/>Bubble sort</h2></div></div></div><p class="calibre8">Another <a id="id247" class="calibre1"/>interesting sorting algorithm is a bubble sort. Unlike the previous <a id="id248" class="calibre1"/>algorithms, this one works at a very local level. The strategy is as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Scan through the array, searching pairs of consecutive elements that are ordered wrongly. Then find <span class="strong"><em class="calibre12">a j</em></span>, such that <span class="strong"><em class="calibre12">array[j+1] &lt; array[j]</em></span>.</li><li class="listitem">Whenever such a pair is found, swap them and continue searching until the end of the array and then back from the beginning again.</li><li class="listitem">Stop when a scan through the entire array does not even find a single pair.</li></ul></div><p class="calibre8">The code that does this is as follows:</p><div class="informalexample"><pre class="programlisting">    public static &lt;E extends Comparable&lt;E&gt;&gt; void bubbleSort( 
    E[] array) { 
        boolean sorted = false; 
        while (!sorted) { 
            sorted = true; 
            for (int i = 0; i &lt; array.length - 1; i++) { 
                if (array[i].compareTo(array[i + 1]) &gt; 0) { 
                    swap(array, i, i + 1); 
                    sorted = false; 
                } 
            } 
        } 
    }</pre></div><p class="calibre8">The flag, <code class="email">sorted</code>, keeps track of whether any inverted pairs were found during a scan. Each iteration of the <code class="email">while</code> loop is a scan through the entire array, the scan being done inside the <code class="email">for</code> loop. In the <code class="email">for</code> loop, we are, of course, checking each pair of elements, and if an inverted pair is found, we swap them. We stop when <code class="email">sorted</code> is <code class="email">true</code>, that is, when we have not found a single inverted pair in the entire array.</p><p class="calibre8">To see that this <a id="id249" class="calibre1"/>algorithm will indeed sort the array, we have to check two things:</p><div class="book"><ul class="itemizedlist"><li class="listitem">When there <a id="id250" class="calibre1"/>are no inverted pairs, the array is sorted. This justifies our stopping condition.<div class="note" title="Note"><h3 class="title2"><a id="note07" class="calibre1"/>Note</h3><p class="calibre8">This is, of course, true because when there are no inverted pairs, we have that for all <span class="strong"><em class="calibre12">j&lt; array.length-1</em></span>, we have <span class="strong"><em class="calibre12">array[j+1]&gt;=array[j]</em></span>. This is the definition of an array being in an increasing order, that is, the array being sorted.</p></div></li><li class="listitem">Irrespective of the input, the program will eventually reach the preceding condition after a finite number of steps. That is to say that we need the program to finish in a finite number of steps. To see this, we need to understand the concept of <span class="strong"><strong class="calibre2">inversions</strong></span>. We will explore them in the next section.</li></ul></div><div class="book" title="Inversions"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch05lvl3sec14" class="calibre1"/>Inversions</h3></div></div></div><p class="calibre8">Inversion in<a id="id251" class="calibre1"/> an array is a pair of elements that are wrongly ordered. The pair <a id="id252" class="calibre1"/>may be close together or very far apart in the array. For example, take the following array:</p><div class="informalexample"><pre class="programlisting">Integer[] array = new Integer[]{10, 5, 2, 3, 78, 53, 3};</pre></div><p class="calibre8">How many inversions does the array have? Let us count: </p><div class="informalexample"><pre class="programlisting">10&gt;5, 10&gt;2, 10&gt;3, 10&lt;78,  10&lt;53, 10&gt;3
            5&gt;2,    5&gt;3,     5&lt;78,    5&lt;53,   5&gt;3
                  ,    2&lt;3,     2&lt;78,    2&lt;53,   2&lt;3
                             ,        3&lt;78,    3&lt;53,   3=3
                                               , 78&gt;53,  78&gt;3
                                                          53&gt;3</pre></div><p class="calibre8">In this listing, every element is compared with the elements following it. There is an inversion when there is a greater-than sign, highlighted by bold characters. Counting the bold ones, we see there are 10 inversions.</p><p class="calibre8">For any input array, there is a number of inversions. In a sorted array, the number of inversions would be zero. Now, think about what happens to the number of inversions when a swap is made. A swap interchanges a pair of consecutive elements, thus breaking one inversion (the swap happens only when there is an inversion between consecutive elements). To see this more clearly, consider the following case of a swap between <span class="strong"><em class="calibre12">j</em></span> and <span class="strong"><em class="calibre12">j+1</em></span> indexes:</p><div class="informalexample"><pre class="programlisting"> …......., j, j+1, …....</pre></div><p class="calibre8">Let's take the <span class="strong"><em class="calibre12">j<sup class="calibre14">th</sup></em></span> element first. Let it have <span class="strong"><em class="calibre12">x</em></span> number of inversions with the left part of the array. Since these elements are on the left, all inversions of this type are with elements greater than the <span class="strong"><em class="calibre12">j<sup class="calibre14">th</sup></em></span> element. When the <span class="strong"><em class="calibre12">j<sup class="calibre14">th</sup></em></span> element moves to the <span class="strong"><em class="calibre12">(j+1)<sup class="calibre14">th</sup></em></span> position, they still remain to the left, and the only element added to the left of the <span class="strong"><em class="calibre12">j<sup class="calibre14">th</sup></em></span> element is the element it is swapped with. Hence, no changes to the number of inversion happens to the <span class="strong"><em class="calibre12">j<sup class="calibre14">th</sup></em></span> element, other than the one due to the <span class="strong"><em class="calibre12">(j+1)<sup class="calibre14">th</sup></em></span> element. The same logic can be applied to the inversions with it in the right part of the array, and also to both sides of the array for the <span class="strong"><em class="calibre12">(j+1)<sup class="calibre14">th</sup></em></span> element. Because of the swap, one inversion is broken between <span class="strong"><em class="calibre12">j<sup class="calibre14">th</sup></em></span> and <span class="strong"><em class="calibre12">(j+1)<sup class="calibre14">th</sup></em></span> elements. Hence, the number of inversions reduce by exactly one in each inversion. This means the number of swaps in bubble sort would be exactly equal to the number of inversions in the input array, which is finite. And since each scan through the array requires a swap in the previous scan, the total number of scans is at most one more that the number of swaps; this is finite too. This makes sure that the algorithm always finishes.</p></div><div class="book" title="Complexity of the bubble sort algorithm"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch05lvl3sec15" class="calibre1"/>Complexity of the bubble sort algorithm</h3></div></div></div><p class="calibre8">To understand the complexity of a bubble sort, we have to count the number of steps. Is the number <a id="id253" class="calibre1"/>of steps equal to the number of swaps? The answer is, not really. In case of asymptotic analysis, we must always count the step that happens a maximum number of times. In this case, that step is comparison. How many comparisons are there per scan of the array? <span class="strong"><em class="calibre12">n-1</em></span> of course. So, now the analysis of complexity is reduced to the number of scans we need to sort the array.</p><p class="calibre8">Let's see what happens to the maximum element after the first scan. Let's say the maximum element is at the index <span class="strong"><em class="calibre12">j</em></span>. So, it will be compared with the element at <span class="strong"><em class="calibre12">j+1</em></span>. For simplicity, let's assume that all elements are different. Now, since it is the maximum element, the element at the <span class="strong"><em class="calibre12">j+1</em></span> position will be less than it, and hence it will be swapped. Now the maximum element is at the position, <span class="strong"><em class="calibre12">j+1</em></span>, and is being compared with the element at position, <span class="strong"><em class="calibre12">j+2</em></span>, and the same thing happens. It will continue until the maximum element is at the end of the array. If the elements are not unique, the same will happen to the rightmost maximum element. In the next cycle, the maximum element will already be at the end of the array, and we will hit the second maximum (or another maximum element) somewhere in the array. Now, since one maximum element is at the end of the array, we can think of the rest of the array apart from the last element. In this array, the current maximum is the maximum and it will reach the end of the current part of the array at the end of the current scan.</p><p class="calibre8">This shows that at the end of each scan, at least one element reaches the correct final position without altering the correct positions of the ones that got there before the scan, which means that at the end of <span class="strong"><em class="calibre12">n</em></span> scans, all of the elements would be in the correct position and the array would be sorted. That is to say that after at most <span class="strong"><em class="calibre12">n</em></span> scans, the bubble sort would be complete. In each of those scans, there are <span class="strong"><em class="calibre12">O(n)</em></span> operations. So, the worst case complexity of bubble sort is <span class="strong"><em class="calibre12">O(n2).</em></span>
</p><p class="calibre8">This is not the end of this analysis; we still have to show that there is a case that takes that many steps, and only then can we have a theta bound on the worst case. We take the case where all the elements are sorted in the opposite order, that is, they are in a decreasing order and are all distinct. In such a case, every element has an inversion with all the others. This means that each one of the <span class="strong"><em class="calibre12">n</em></span> elements have an inversion with <span class="strong"><em class="calibre12">n-1</em></span> other elements, that is, <span class="strong"><em class="calibre12">n(n-1)</em></span> inversions in total. But since each inversion would be counted twice, once from each of the elements that are members of the inversion, it is actually <span class="strong"><em class="calibre12">n(n-1)/2</em></span>. Now, note that the maximum number of swaps that can be done in one scan is <span class="strong"><em class="calibre12">n-1</em></span>, which will happen if every comparison results in a swap because there are <span class="strong"><em class="calibre12">n-1</em></span> comparisons per scan. So, we will need at least <span class="strong"><em class="calibre12">(n(n-1)/2)/(n-1) = n/2</em></span> scans to complete all the swaps, each requiring <span class="strong"><em class="calibre12">n-1</em></span> comparisons. So, the complexity is at least <span class="strong"><em class="calibre12">n(n-1)/2 = Ω(n2)</em></span>. Of course then, the worst case is at least this much complex because the worst case is, by <a id="id254" class="calibre1"/>definition, the most complex case.</p><p class="calibre8">So, the worst case is both <span class="strong"><em class="calibre12">O(n2)</em></span> and <span class="strong"><em class="calibre12">Ω(n2)</em></span>, that is to say that it is <span class="strong"><em class="calibre12">θ(n2)</em></span>.</p></div></div></div>

<div class="book" title="A problem with recursive calls"><div class="book" id="1394Q2-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec30" class="calibre1"/>A problem with recursive calls</h1></div></div></div><p class="calibre8">A problem <a id="id255" class="calibre1"/>with recursive calls is that they are expensive; a method invocation entails considerable overhead on the processor. It is, in general, better to avoid invoking methods if you want to improve performance to the last bit. On top of that, there is a limit to the depth of function calls that you can go to, before the program breaks. This is because a program has a stack to enable method invocation semantics, that actually gets a new element containing all variables and the position of the current instruction to the stack. This stack does not grow indefinitely, but instead is fixed in size; usually, it can hold a few thousand values, which means that if your method invocation is deeper than that, it will break and the program will exit with an error. This means that our insertion sort will break for an array containing more than a few thousand entries. On the other hand, it is generally easier to explain an algorithm in a functional form. To balance between these two aspects, we need to be able to convert to and from the recursive and non-recursive versions of the same algorithm. We will do this step by step from the simplest form to the more complicated form.</p></div>

<div class="book" title="A problem with recursive calls">
<div class="book" title="Tail recursive functions"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec41" class="calibre1"/>Tail recursive functions</h2></div></div></div><p class="calibre8">A recursive function is called a tail recursive function if all the recursive calls to itself in the function <a id="id256" class="calibre1"/>are the last operations. I say it like there are <a id="id257" class="calibre1"/>multiple calls and all of them must be the last operations. How is that possible? I mean there can be different calls from different conditional branches of the code inside the function. However, whenever the function calls itself that must be the last operation in that conditional branch of the function. For example, take our binary search algorithm again:</p><div class="informalexample"><pre class="programlisting">   private static &lt;E extends Comparable&lt;E&gt;, F extends E&gt; int binarySearch( 
        E[] sortedValues, F valueToSearch, int start, int end) { 
        if(start&gt;=end){ 
            return -1; 
        } 
        int midIndex = (end+start)/2; 
        int comparison = sortedValues[midIndex].compareTo(valueToSearch); 
        if(comparison==0){ 
            return midIndex; 
        }else if(comparison&gt;0){ 
            return binarySearch(sortedValues, valueToSearch, start, midIndex); 
        }else{ 
            return binarySearch(sortedValues, valueToSearch, midIndex+1, end); 
        } 
    }</pre></div><p class="calibre8">Note that the function calls itself in two different conditional branches. However, in each branch, the recursive call is the last operation. There is nothing to be done after the call to itself. This is a tail recursive function.</p><p class="calibre8">Tail recursive<a id="id258" class="calibre1"/> functions can be turned into a loop absolutely<a id="id259" class="calibre1"/> mechanically. In fact, all functional language compilers do this automatically during compiler optimization. The Java compiler, however, does not do this because Java generally prefers loops over recursion in the code, at least until very recently. But we can do this conversion by ourselves.</p><p class="calibre8">The idea is that since there are no more operations after the recursive call, the program does not have to remember the values of the variables of the calling function. So, they can simply be overwritten by the values of the same variables of the called function instead, and we just have to process the code of the function again. So, the following is the mechanical procedure to achieve this:</p><p class="calibre8">Wrap the entire content in an infinite <code class="email">while</code> loop.</p><p class="calibre8">Replace all recursive calls by updating the values of the parameters to the values that are passed in the recursive calls.</p><p class="calibre8">The following shows this update in the binary search algorithm:</p><div class="informalexample"><pre class="programlisting">    private static &lt;E extends Comparable&lt;E&gt;, F extends E&gt; int binarySearchNonRecursive( 
        E[] sortedValues, F valueToSearch, int start, int end) { 
        <span class="strong"><strong class="calibre2">while(true) { </strong></span>
            if (start &gt;= end) { 
                return -1; 
            } 
            int midIndex = (end + start) / 2; 
            int comparison = sortedValues[midIndex]
                               .compareTo(valueToSearch); 
            if (comparison == 0) { 
                return midIndex; 
            } else if (comparison &gt; 0) { 
                <span class="strong"><strong class="calibre2">end = midIndex; </strong></span>
            } else { 
                <span class="strong"><strong class="calibre2">start = midIndex + 1; </strong></span>
            } 
       <span class="strong"><strong class="calibre2"> } </strong></span>
    }</pre></div><p class="calibre8">Note that we <a id="id260" class="calibre1"/>updated only those arguments that changed, which is only one update per branch in this case. This will produce the exact same<a id="id261" class="calibre1"/> result as the earlier function, but now it would not cause a stack overflow. This conversion is not really required in case of a binary search though, because you need only <span class="strong"><em class="calibre12">lg n</em></span> steps to search an array of length <span class="strong"><em class="calibre12">n</em></span>. So, if your allowed depth of invocation is <span class="strong"><em class="calibre12">1000</em></span>, then you can search in an array of maximum size of <span class="strong"><em class="calibre12">21000</em></span> elements. This number is way more than the total number of atoms in the entire universe, and hence we will never be able to store an array of that enormous size. But the example shows the principle of converting a tail recursion into a loop.</p><p class="calibre8">Another example is the <code class="email">insertElementSorted</code> function, used in our insertion sort algorithm:</p><div class="informalexample"><pre class="programlisting">          public static &lt;E extends Comparable&lt;E&gt;&gt; void insertElementSorted( 
            E[] array, int valueIndex) { 

              if (valueIndex &gt; 0 &amp;&amp; array[valueIndex].compareTo(array[valueIndex - 1]) &lt; 0) { 
                swap(array, valueIndex, valueIndex - 1); 
                insertElementSorted(array, valueIndex - 1); 
        } 

    }</pre></div><p class="calibre8">Note that there is no operation pending after the recursive call to itself. But we need to be a little more careful here. Note that the invocation only happens inside a code branch. The else case is implicit here, which is <code class="email">else { return; }</code>. We need to make it explicit in our code first, as shown below:</p><div class="informalexample"><pre class="programlisting">     public static &lt;E extends Comparable&lt;E&gt;&gt; void insertElementSorted( 
     E[] array, int valueIndex) { 

        if (valueIndex &gt; 0 &amp;&amp; array[valueIndex].compareTo(array[valueIndex - 1]) &lt; 0) { 
            swap(array, valueIndex, valueIndex - 1); 
            insertElementSorted(array, valueIndex - 1); 
        }<span class="strong"><strong class="calibre2"> else{</strong></span>
<span class="strong"><strong class="calibre2">         return;</strong></span>
<span class="strong"><strong class="calibre2">        } </strong></span>
     }</pre></div><p class="calibre8">Now we can <a id="id262" class="calibre1"/>use our old technique to make it non-recursive, that is, to wrap it in an infinite loop and replace recursive calls with argument <a id="id263" class="calibre1"/>updates: </p><div class="informalexample"><pre class="programlisting">   public static &lt;E extends Comparable&lt;E&gt;&gt; void insertElementSortedNonRecursive( 
        E[] array, int valueIndex) { 
        <span class="strong"><strong class="calibre2">while(true) { </strong></span>
            if (valueIndex &gt; 0 &amp;&amp; array[valueIndex].compareTo(array[valueIndex - 1]) &lt; 0) { 
                swap(array, valueIndex, valueIndex - 1); 
                <span class="strong"><strong class="calibre2">valueIndex =  valueIndex – 1; </strong></span>
            }else{ 
                return; 
            } 
        <span class="strong"><strong class="calibre2">} </strong></span>

    }</pre></div><p class="calibre8">This gives the exact same result as the previous recursive version of the function. So, the corrected steps would be as follows:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, make all implicit branches explicit and all implicit returns explicit.</li><li class="listitem" value="2">Wrap the entire content in an infinite while loop.</li><li class="listitem" value="3">Replace all recursive calls by updating the values of the parameters to the values that are passed in the recursive calls.</li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="A problem with recursive calls">
<div class="book" title="Non-tail single recursive functions"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec42" class="calibre1"/>Non-tail single recursive functions</h2></div></div></div><p class="calibre8">By single <a id="id264" class="calibre1"/>recursion, I mean that the<a id="id265" class="calibre1"/> function invokes itself at most once per conditional branch of the function. They may be tail-recursive, but they are not always so. Consider the example of the recursion of our insertion sort algorithm:</p><div class="informalexample"><pre class="programlisting">   public static &lt;E extends Comparable&lt;E&gt;&gt; void insertionSort( 
        E[] array, int boundary) { 
        if(boundary==0){ 
            return; 
        } 
        insertionSort(array, boundary-1); 
        insertElementSorted(array, boundary); 
    }</pre></div><p class="calibre8">Note that the function calls itself only once, so it is a single recursion. But since we have a call to <code class="email">insertElementSorted</code> after the recursive call to itself, it is not a tail recursive function, which means that we cannot use the earlier method. Before doing this though, let's consider a simpler example. Take the factorial function:</p><div class="informalexample"><pre class="programlisting">    public static BigInteger factorialRecursive(int x){ 
        if(x==0){ 
            return BigInteger.ONE; 
        }else{ 
            return factorialRecursive(x-1).multiply(BigInteger.valueOf(x)); 
        } 
    }</pre></div><p class="calibre8">First, note<a id="id266" class="calibre1"/> that the function is singly<a id="id267" class="calibre1"/> recursive, because there is at most one recursive call per branch of the code. Also, note that it is not tail recursive because you have to do a multiplication after the recursive call.</p><p class="calibre8">To convert this into a loop, we must first figure out the actual order of the numbers being multiplied. The function calls itself until it hits <code class="email">0</code>, at which point, it returns <code class="email">1</code>. So, the multiplication actually starts from <code class="email">1</code> and then accumulates the higher values.</p><p class="calibre8">Since it accumulates the values on its way up, we need an accumulator (that is a variable storing one value) to collect this value in a loop version. The steps are as follows: </p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, make all implicit branches explicit and all implicit returns explicit.</li><li class="listitem" value="2">Create an accumulator of the same type as the return type of the function. This is to store intermediate return values. The starting value of the accumulator is the value returned in the base case of the recursion.</li><li class="listitem" value="3">Find the starting value of the recursion variable, that is, the one that is getting smaller in each recursive invocation. The starting value is the value that causes the next recursive call to fall in the base case.</li><li class="listitem" value="4">The exit value of the recursion variable is the same as the one passed to the function originally.</li><li class="listitem" value="5">Create a loop and make the recursion variable your loop variable. Vary it from the start value to the end value calculated earlier in a way to represent how the value changes from higher depth to lower depth of recursion. The higher depth value comes before the lower depth value.</li><li class="listitem" value="6">Remove the recursive call.</li></ol><div class="calibre13"/></div><p class="calibre8">What is the initial value of the accumulator <code class="email">prod</code>? It is the same as the value that is returned in the exit branch of the recursion, that is, <code class="email">1</code>. What is the highest value being multiplied? It is <code class="email">x</code>. So we can now convert it to the following loop:</p><div class="informalexample"><pre class="programlisting">   public static BigInteger factorialRecursiveNonRecursive(int x){ 
        BigInteger prod = BigInteger.ONE; 
        for(int i=1;i&lt;=x;i++){ 
            prod = prod.multiply(BigInteger.valueOf(x)); 
        } 
        return prod; 
    }</pre></div><p class="calibre8">Now let's <a id="id268" class="calibre1"/>consider the <code class="email">insertionSort</code> algorithm. What is the accumulator? It is the same thing that would be the final <a id="id269" class="calibre1"/>output, that is, an array of sorted elements. What is the starting value? It is the same that is returned in the recursive version in the exit branch. This is an array of length zero. What is the final value? The array of sorted elements of the length provided to sort. Again, just like our recursive version, we represent these partial arrays with, simply, a boundary value. So, the code is as follows:</p><div class="informalexample"><pre class="programlisting">    public static &lt;E extends Comparable&lt;E&gt;&gt; void insertionSortNonRecursive( 
        E[] array) { 
        for(int boundary = 0;boundary&lt;array.length;boundary++) { 
            insertElementSortedNonRecursive(array, boundary); 
        } 
    } </pre></div><p class="calibre8">Note that in this case, the function <code class="email">return</code> type is <code class="email">void</code>. But what we are really returning is the sorted array; we just resorted to modifying the same array to avoid creating duplicate arrays.</p><p class="calibre8">The most general case is the multiple recursion, that is, the function calls itself multiple times in the same conditional branch of the function. This case cannot be done without a stack. In case of a recursive call, we use the method-invocation stack. Otherwise, we can even use an external stack. Since we do not have such an example in this chapter, we defer its explanation to the next chapter, where we will have an example.</p></div></div>
<div class="book" title="Summary" id="147LC1-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec31" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we saw how to do an efficient search in an ordered array. This search is called a binary search. You also learned some methods of obtaining an ordered array out of an unordered one. This process is called sorting. We saw three basic algorithms of sorting. Although they are not particularly efficient, they are simple to understand the concept. You also learned how to convert a recursive algorithm to a non-recursive one that uses a loop. In the next chapter, we will see efficient sorting algorithms.</p></div></body></html>