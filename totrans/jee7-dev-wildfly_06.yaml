- en: Chapter 6. Developing Applications with JBoss JMS Provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Messaging is a method of communication between software components and applications.
    **Java Message Service** (**JMS**) is a Java API—designed originally by Sun—that
    allows applications to create, send, receive, and read messages. The new 2.0 version
    of the API has been introduced with JSR 343 ([https://jcp.org/en/jsr/detail?id=343](https://jcp.org/en/jsr/detail?id=343)).
  prefs: []
  type: TYPE_NORMAL
- en: Messaging differs from other standard protocols, such as **Remote Method Invocation**
    (**RMI**) or **Hypertext Transfer Protocol** (**HTTP**), in two ways. First, the
    conversation is mediated by a messaging server so it's not a two-way conversation
    between peers. Second, the sender and the receiver need to know what message format
    and what destination to use. This is in contrast to tightly coupled technologies,
    such as Remote Method Invocation (RMI), that require an application to know about
    a remote application's methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction to message-oriented systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The building blocks of the JBoss messaging subsystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up proof of concept programming examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use JMS and resource adapters to integrate with external systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A short introduction to JMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JMS defines a vendor-neutral (but Java-specific) set of programming interfaces
    to interact with asynchronous messaging systems. Messaging enables distributed
    communication that is loosely coupled. The whole messaging interchange is a two-step
    process where a component sends a message to a destination that is in turn retrieved
    by the recipient with the mediation of the JMS server. In JMS, there are two types
    of destinations: topics and queues. These have different semantics, which are
    explained next.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a point-to-point model, messages are sent from producers to consumers via
    queues. A given queue might have multiple receivers, but only one receiver would
    be able to consume each of the messages. Only the first receiver who requests
    the message will get it, while the others will not, as shown in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A short introduction to JMS](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A message sent to a **topic**, on the other hand, might be received by multiple
    parties. Messages published on a specific topic are sent to all the message consumers
    who have registered (subscribed) themselves to receive messages on that topic.
    A subscription can be **durable** or **nondurable**. A nondurable subscriber can
    only receive messages that are published while it is **active**. A nondurable
    subscription does not guarantee the delivery of a message; it might deliver the
    same message more than once. A durable subscription, on the other hand, guarantees
    that the consumer receives the message exactly once, as depicted in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A short introduction to JMS](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As far as message consumption is concerned, even though JMS is inherently asynchronous,
    the JMS specification allows messages to be consumed in either of the following
    two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchronously**: A subscriber or a receiver explicitly fetches the message
    from the destination by calling the `receive()` method of any `MessageConsumer`
    instance. The `receive()` method can block until a message arrives or can take
    a time out if a message does not arrive within a specified time limit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronously**: With the asynchronous mode, the client must implement the
    `javax.jms.MessageListener` interface and overwrite the `onMessage()` method.
    Whenever a message arrives at the destination, the JMS provider delivers the message
    by calling the listener''s `onMessage` method, which acts on the contents of the
    message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A JMS message consists of a header, properties, and a body. The message headers
    provide a fixed set of metadata fields that describe the message with information
    such as where the message is going and when it is received. The properties are
    a set of key-value pairs used for application-specific purposes, usually to help
    filter messages quickly when they are received. Finally, the body contains whatever
    data is being sent to the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JMS API supports two delivery modes for messages to specify whether or
    not the messages are lost if the JMS provider fails, indicated by the following
    constants:'
  prefs: []
  type: TYPE_NORMAL
- en: The **persistent** delivery mode, which is the default, instructs the JMS provider
    to take extra care to ensure that a message is not lost in transit in the case
    of a JMS provider failure. A message sent with this delivery mode is logged to
    stable storage when it is sent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **nonpersistent** delivery mode does not require the JMS provider to store
    the message or otherwise guarantee that it is not lost if the provider fails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The building blocks of JMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic building blocks of any JMS application consist of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Administered objects—connection factories and destinations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sessions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message producers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message consumers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connection factory**: This object encapsulates a set of connection configuration
    parameters that have been defined by an administrator. A client uses it to create
    a connection with a JMS provider. A connection factory hides provider-specific
    details from JMS clients and abstracts administrative information into objects
    in the Java programming language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destination**: This is the component a client uses to specify the target
    of messages it produces and the source of messages it consumes. In the **point-to-point**
    (**PTP**) messaging domain, destinations are called queues; in the **publish/subscribe
    (pub/sub)** messaging domain, destinations are called topics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection**: This encapsulates a virtual connection with a JMS provider.
    A connection could represent an open TCP/IP socket between a client and a provider
    service. You use a connection to create one or more sessions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session**: This is a single-threaded context for producing and consuming
    messages. You use sessions to create message producers, message consumers, and
    messages. Sessions serialize the execution of message listeners and provide a
    transactional context with which to group a set of sends and receives into an
    atomic unit of work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message producer**: This is an object created by a session and is used to
    send messages to a destination. The PTP form of a message producer implements
    the `QueueSender` interface. The pub/sub form implements the `TopicPublisher`
    interface. From JMS 2.0, it is possible to rely only on the `JMSProducer` interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message consumer**: This is an object created by a session and is used to
    receive messages sent to a destination. A message consumer allows a JMS client
    to register interest in a destination with a JMS provider. The JMS provider manages
    the delivery of messages from a destination to the registered consumers of the
    destination. The PTP form of message consumer implements the `QueueReceiver` interface.
    The pub/sub form implements the `TopicSubscriber` interface. The latest JMS version
    supports a new `JMSConsumer` API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JBoss messaging subsystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JBoss AS has used different JMS implementations across its releases, such as
    JBoss MQ and JBoss Messaging. Since JBoss AS 6.0, the default JMS provider is
    **HornetQ** ([http://www.jboss.org/hornetq](http://www.jboss.org/hornetq)), which
    provides a multiprotocol, embeddable, high-performant, and clusterable messaging
    system.
  prefs: []
  type: TYPE_NORMAL
- en: At its core, HornetQ is designed simply as a set of **Plain Old Java Objects**
    (**POJOs**) with few dependencies on external JAR files. In fact, the only one
    JAR dependency is the Netty library, which leverages the Java **New Input-Output**
    (**NIO**) API to build high-performance network applications.
  prefs: []
  type: TYPE_NORMAL
- en: Because of its easily adaptable architecture, HornetQ can be embedded in your
    own project or instantiated in any dependency injection framework such as JBossMicrocontainer,
    Spring, or Google Guice.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we will cover a scenario where HornetQ is integrated into the
    WildFly subsystem as a module, as shown in the following diagram. This diagram
    depicts how the JCA Adapter and the HornetQ server fit in the overall picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The JBoss messaging subsystem](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating and using connection factories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is the job of the connection factory that encapsulates the connection's parameters
    to create new JMS connections. A connection factory is bound to the **Java Naming
    Directory Index** (**JNDI**) and can be looked up by both local and remote clients,
    provided they supply the correct environment parameters. Since a connection factory
    can be reused multiple times in your code, it's the kind of object that can be
    conveniently cached by a remote client or a message-driven bean.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of connection-factory instances is included in the `full` and
    `full-ha` server configurations. You can choose either of the server configurations
    using the `–c` command argument, for instance, `standalone.bat –c standalone-full.xml`.
    We will cover the configuration profiles in depth in [Chapter 9](part0048_split_000.html#page
    "Chapter 9. Managing the Application Server"), *Managing the Application Server*.
    For now, just remember to start your server with the full configuration profile
    whenever you need JMS.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can inspect the connection factories in the overall JMS configuration,
    which is available by surfing the admin console and navigating to **Configuration**
    | **Messaging Destinations** | **Connection Factories**, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and using connection factories](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the previous screenshot, there are the following two out-of-the-box
    connection-factory definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**InVmConnectionFactory**: This connection factory is bound under the `java:/ConnectionFactory`
    entry and is used when the server and client are part of the same process (that
    is, they are running on the same JVM).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RemoteConnectionFactory**: This connection factory is bounded under the `java:jboss/exported/jms/RemoteConnectionFactory`
    entry, and as the name implies, it can be used using Netty as the connector when
    JMS connections are provided by a remote server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to change the connection factory''s JNDI binding, the simplest
    choice is to go through the server configuration file (for example, `standalone-full.xml`,
    for a standalone mode):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The connection factory can be injected just like any other Java EE resource;
    the following code fragment shows how a stateless EJB gets the default connection
    factory injected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to use the messaging subsystem, you have to start WildFly using a
    Java EE full profile, which includes the messaging subsystem. So, for example,
    if you want to start a standalone server instance that is JMS-aware, you can simply
    use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using JMS destinations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Along with the definition of connection factories, you will need to learn how
    to configure JMS destinations (queues and topics).
  prefs: []
  type: TYPE_NORMAL
- en: This can be achieved with a variety of instruments. Since we have started dealing
    with the web console, just navigate to the **Configuration** tab and pick the
    **Messaging** subsystem from the left panel. Select **Destinations** and click
    on the **View** central link.
  prefs: []
  type: TYPE_NORMAL
- en: 'From there, you can use the upper menu tab that contains a set of options,
    the first one of which—named **Queues/Topics**—can be used to configure your JMS
    destinations, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using JMS destinations](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now click on the **Add** button. You should see the following dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using JMS destinations](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter the mandatory name for your destination and its JNDI. You can optionally
    choose to define your JMS destination as either of the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Durable**: This option allows the JMS server to hold on to a message in case
    the subscriber is temporarily unavailable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selector**: This option allows a filter to the JMS destination (we will cover
    this in greater detail later in this chapter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on the **Save** button and verify that the queue has been enlisted among
    the JMS destinations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding change will reflect in the server configuration file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It's worth noting that the JMS configuration usually differs on every application
    server. In this chapter, we will cover only the approach used in WildFly, but
    the key concepts between different providers stay the same.
  prefs: []
  type: TYPE_NORMAL
- en: Adding message-driven beans to your application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we do the configuration, we can start coding a JMS message consumer, such
    as a message-driven bean.
  prefs: []
  type: TYPE_NORMAL
- en: '**Message-driven beans** (**MDBs**) are stateless, server-side, and transaction-aware
    components that process asynchronous JMS messages.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important aspects of message-driven beans is that they can consume
    and process messages concurrently. This capability provides a significant advantage
    over traditional JMS clients, which must be custom built to manage resources,
    transactions, and security in a multithreaded environment. MDB containers manage
    concurrency automatically so the bean developer can focus on the business logic
    of processing the messages. An MDB can receive hundreds of JMS messages from various
    applications and process them all at the same time because numerous instances
    of it can be executed concurrently in the container.
  prefs: []
  type: TYPE_NORMAL
- en: From the semantic point of view, an MDB is classified as an enterprise bean,
    just like a session or entity bean, but there are some important differences.
    At first, the message-driven bean does not have component interfaces. These are
    absent because the message-driven bean is not accessible via the Java RMI API;
    it responds only to asynchronous messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as the entity and session beans have well-defined life cycles, so does
    the MDB bean. The MDB instance''s life cycle has two states, **Does not Exist**
    and **Method ready Pool**, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding message-driven beans to your application](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When a message is received, the EJB container checks to see whether any MDB
    instance is available in the pool. If a bean is available in the free pool, JBoss
    uses that instance. Once an MDB instance's `onMessage()` method is returned, the
    request is complete and the instance is placed back in the free pool. This results
    in the best response time, as the request is served without waiting for a new
    instance to be created.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the other hand, if all the instances in the pool are busy, the new request
    will be serialized since it's guaranteed that the same instance will not be allowed
    to serve multiple clients at the same time. Also, if a client sends out multiple
    messages to the server containing an MDB, there is no guarantee that the same
    MDB instance will be used for each message or that the messages will be processed
    in the order in which the client sent them. This means that the application should
    be designed to handle messages that arrive out of order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of MDBs in the pool is configured in the EJB pool, which can be
    reached from the console by navigating to **Configuration** | **Container** |
    **EJB 3** | **Bean Pools** as depicted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding message-driven beans to your application](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The bean pool's configuration is contained in the bean pool central tab, which
    holds both the stateless and MDB pool configurations. The default value for the
    MDB's max pool size is 20 units.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to override pools for specific beans. You can use either
    the JBoss-specific `org.jboss.ejb3.annotation.Pool` annotation or the `jboss-ejb3.xml`
    deployment descriptor. For more information on overriding pools for the chosen
    beans, visit [https://docs.jboss.org/author/display/WFLY8/EJB3+subsystem+configuration+guide](https://docs.jboss.org/author/display/WFLY8/EJB3+subsystem+configuration+guide).
  prefs: []
  type: TYPE_NORMAL
- en: If no bean instances are available, the request will be blocked until an active
    MDB completes a method call or the transaction times out.
  prefs: []
  type: TYPE_NORMAL
- en: Cooking message-driven beans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will now add a message-driven bean to our application from the previous chapter,
    which will be used to intercept messages when a new ticket is booked. For the
    purpose of our example, we will just trace whether the JMS message has been received;
    however, you can also use it for more complex purposes such as notifying external
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Java class, say `BookingQueueReceiver`, and enter the package name
    as `com.packtpub.wflydevelopment.chapter6.jms`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once done, let''s add the MDB configuration via an annotation, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here we have connected the MDB to our `ticketQueue` destination `[1]` bound
    at `java:jboss/jms/queue/ticketQueue`. The purpose of this component will be to
    trace the message receipt via `java.util.Logger`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java EE 7 introduces an additional way of the queue definition. Now, you don''t
    have to add a queue from the application server management tool. It is possible
    to define queues and their properties in the code using some basic annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Then, in `BookingQueueReceiver`, you can just change `propertyValue = "java:jboss/jms/queue/ticketQueue"`
    to `propertyValue = BookingQueueDefinition.BOOKING_QUEUE`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the JMS producer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we''re done with the JMS consumer, we need a component that will take
    care of sending JMS messages. For this purpose, we will add an Application Scoped
    CDI Bean, say `BookingQueueProducer`, which gets injected in the JMS resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This might be a bit shocking for those who have used the previous versions
    of the JMS. For those who haven''t, in the following code we present this code''s
    equivalent in JMS 1.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Code amount change is impressive. API simplification was one of the major features
    of the new JMS version, and the specification authors did great work on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can use your service to notify some application-specific actions.
    For example, we will inject `BookingQueueProducer` into the `BookerService` bean
    and send a message whenever a user is registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'From JMS 2.0, messages can be sent asynchronously, but then it is important
    to control whether the operations are successful or not. To do this, we have to
    create an object that implements the `CompletionListener` interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'During the `send` operation, we have to specify the asynchronous and use this
    `listener` object. To do this, inject `BookingCompletionListener` to `BookingQueueProducer`
    and send messages with an updated call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, appropriate listener methods will be executed when the message `send`
    is completed or failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Compiling and deploying the application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have based our code on the JPA application from the previous chapter. Thanks
    to `javaee-api`, you don''t have to add any new project dependencies in order
    to use JMS! The only thing you have to do is to start WildFly in full profile
    using, for example, `standalone-full.xml standalone-full.xml`—the standard full
    profile configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, when switching to another server configuration, you will need to recreate
    all the example resources, such as data sources, that were set up initially for
    your standalone configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Now deploy your application using either Eclipse's Server view or Maven and
    access the application at `http://localhost:8080/ticket-agency-jms/`.
  prefs: []
  type: TYPE_NORMAL
- en: Everything should work just like the earlier JPA project; however, in your application
    server console, you should notice the messages that confirm a seat has been booked.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying which message to receive using selectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Message selectors allow an MDB to be more selective about the messages it receives
    from a particular topic or queue. Message selectors use message properties as
    criteria in conditional expressions. Message properties, upon which message selectors
    are based, are additional headers that can be assigned to a message. They give
    the application developer the ability to attach more information to a message.
    This information can be stored using several primitive values (`boolean`, `byte`,
    `short`, `int`, `long`, `float`, and `double`) or as `String`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s suppose that we want to process two kinds of messages with
    the same queue:'
  prefs: []
  type: TYPE_NORMAL
- en: A trace message indicating that a user has booked a seat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A warning message indicating that an error has occurred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hence, our `sendMessage` method can be changed slightly to include a `String`
    property that can be attached to the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in our application context, we might use the `sendMessage` method, attaching
    a `LOW` value for priority when the user is registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, we could attach a `HIGH` priority when an error occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'From the MDB perspective, all you need to do in order to filter through messages
    is include the message selector as part of your `ActivationConfigProperty` class
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'At the same time, you can deploy another MDB that is in charge of consuming
    messages that are sent with a `LOW` priority:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When talking about filtering, we have to say a few words concerning performance.
    In HornetQ queues and topics, there are filtering messages on a different stage.
    In the case of queues, properties are filtered when they have already been received
    by the listener, while in topics, they are filtered before being added. Keep in
    mind this is not guaranteed by JMS specification (since a specification describes
    the API) and might act differently in other implementations. There are a lot of
    performance options that can be tuned in JMS providers; however, most of the configurations
    must be specifically chosen for every project. Be sure to check additional tuning
    tips in HornetQ's documentation at [http://docs.jboss.org/hornetq/2.4.0.Final/docs/user-manual/html_single/#perf-tuning](http://docs.jboss.org/hornetq/2.4.0.Final/docs/user-manual/html_single/#perf-tuning).
  prefs: []
  type: TYPE_NORMAL
- en: Transaction and acknowledgment modes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to control the overall performance and reliability of an asynchronous
    messaging system, we need to take two factors into account: persisting of messages
    and acknowledgment. Let''s take a look at those characteristics.'
  prefs: []
  type: TYPE_NORMAL
- en: Reliability of the system is focused on the ability to deliver messages exactly
    once. This means that no message is lost, and there are no duplicates. For most
    systems, it is a strong requirement that you don't miss or duplicate any orders
    (like in an e-commerce site). However, usually it is not a problem to miss an
    update from the stock market because a newer one would overwrite it in a moment.
    Of course, additional features such as reliability come at a price, and in the
    case of JMS, the price is paid in performance. The more reliable the system, the
    lower its message throughput is.
  prefs: []
  type: TYPE_NORMAL
- en: When a message is processed, it can be held only in the memory or persisted
    somewhere on the disk. Messages stored in the memory are lost in the case of a
    failure or when the messaging service is stopped. Persisted messages can be retrieved
    from the disk after the service is restarted and therefore delivered to the consumers
    at least once (but still without any guarantees about the acknowledgment). Without
    this mechanism, messages can potentially be lost in the system because a failure
    might occur before they are delivered. However, the overhead of storing them can
    have a serious impact on the system's performance characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgment is important to inform the JMS service that the message was really
    received and processed by the consumer. Different levels of acknowledgments can
    be used to avoid duplicates or to trigger JMS to send the message once more, possibly
    to another consumer. A JMS provider will ensure that an acknowledged message is
    delivered only once. The application is responsible for properly handling rolled
    back messages that were redelivered (such messages are marked with the `JMSRedelivered`
    header).
  prefs: []
  type: TYPE_NORMAL
- en: 'If the consumer session is handled in a transaction, then the messages are
    acknowledged only when the transaction is committed. However, there is an option
    to disable transactional message-driven beans and manually handle the acknowledgment.
    In this case, there are the following three types of acknowledgement options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AUTO_ACKNOWLEDGE**: With this, the consumed messages are being acknowledged
    automatically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DUPS_OK_ACKNOWLEDGE**: With this, the delivered messages are being lazily
    acknowledged; this means that the client might receive some duplicated messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CLIENT_ACKNOWLEDGES**: With this, the client manually acknowledges received
    messages using the `acknowledge` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The modes can be set when you retrieve `JMSContext` from a connection factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is an integer flag that accepts the values mentioned previously
    along with a `SESSION_TRANSACTED` entry (which is the standard mode for JTA-managed
    message-driven beans).
  prefs: []
  type: TYPE_NORMAL
- en: Using JMS to integrate with external systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we mentioned that the JCA adaptor handles
    the communication between the application server and the HornetQ server.
  prefs: []
  type: TYPE_NORMAL
- en: As a matter of fact, one possible way to perform **Enterprise Application Integration**
    (**EAI**) is via **Java Connector Architecture** (**JCA**), which can be used
    to drive JMS's inbound and outbound connections.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, Java connectors were intended to access legacy transaction servers
    on mainframes in a synchronous request/reply mode, and this is how the majority
    of the connectors worked in the beginning. The standard is currently evolving
    toward more asynchronous and two-way connectivity; this is exactly the case with
    JMS communication, which is inherently asynchronous (but also offers the capability
    of simulating a synchronous request/response mode). In the next section, we will
    show you how to use a Java Resource Adapter to enable communication between JBoss'
    HornetQ Messaging system and a standalone instance of the Apache ActiveMQ broker
    (which can be used, for instance, by a non-Java EE application).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**JMS/JCA integration versus web services**'
  prefs: []
  type: TYPE_NORMAL
- en: If we are discussing EAI, we cannot help but talk about the difference between
    web services, which is the de facto standard for integrating heterogeneous systems.
  prefs: []
  type: TYPE_NORMAL
- en: One advantage of using the JMS/JCA integration is that it provides support for
    resource adaptation, which maps the Java EE security, transaction, and communication
    pooling to the corresponding EIS technology. This makes this technology fairly
    attractive, especially if you are trying to connect some existing, well-consolidated,
    and homogeneous systems (remember that if you are using JMS as the driver, you
    are bound to a Java-to-Java interaction).
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you are planning to connect different business partners
    (for example, Java and .NET applications) or simply build a new system from scratch
    with no clear interactions defined, it would be better to use web services for
    transport and connection.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about web services in [Chapter 7](part0038_split_000.html#page
    "Chapter 7. Adding Web Services to Your Applications"), *Adding Web Services to
    Your Applications*, which should provide you with quite a complete overview of
    your EAI alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: A real-world example – HornetQ and ActiveMQ integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will provide an example scenario, which includes an external
    component such as the Apache ActiveMQ (Apache 2.0 open source licensed) message
    broker that fully implements **Java Message Service 1.1** (**JMS**). Another application
    could be communicating with our ticketing system using this broker, but in our
    sample, we will simulate the external system using the ActiveMQ administration
    console.
  prefs: []
  type: TYPE_NORMAL
- en: In order to run this example, we will need to pick up the ActiveMQ resource
    adapter, `activemq-rar-5.9.0.rar`, which can be downloaded from the Maven repository
    at [http://repo1.maven.org/maven2/org/apache/activemq/activemq-rar/5.9.0/](http://repo1.maven.org/maven2/org/apache/activemq/activemq-rar/5.9.0/).
    You will also need the ActiveMQ broker, which you can download from [https://activemq.apache.org/activemq-590-release.html](https://activemq.apache.org/activemq-590-release.html).
    Simply extract the binary distribution and run the `/apache-activemq-5.9.0/bin/activemq.bat`
    file to start the broker.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the ActiveMQ resource adapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Resource adapters (`.rar`) can be deployed using either WildFly management instruments
    or by copying the resource adapter into the deployments directory for standalone
    servers. Before doing this, we need to configure the Resource adapter in your
    server configuration. This can be done by adding the configuration to the JCA
    subsystem or (suggested choice) by creating a JCA descriptor of the external resource.
  prefs: []
  type: TYPE_NORMAL
- en: JCA descriptors can be created by using an utility contained in JBoss' JCA implementation
    named **IronJacamar** ([http://www.jboss.org/ironjacamar](http://www.jboss.org/ironjacamar)).
    Within IronJacamar 1.1 or later distributions (accessible at [http://www.jboss.org/ironjacamar/downloads](http://www.jboss.org/ironjacamar/downloads)),
    you can find a resource adapter information tool (`rar-info.bat`) that can be
    used to create the resource adapter deployment descriptor by generating a report
    file containing all the necessary information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rar-info.bat` tool can be found in the `doc/as` folder of your IronJacamar
    distribution. So let''s move to this folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now issue the following command, which assumes that you have saved your resource
    adapter in the `/usr/doc` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Troubleshooting the rar-info shell**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rar-info` command shell includes a set of libraries that are used to execute
    the main utility class. In order to inspect the JMS adapter, however, you need
    to manually edit the shell file and add `jboss-jms-api_2.0_spec-1.0.0.Final` and
    `jboss-transaction-api_1.2_spec-1.0.0.Final.jar` to the classpath. Those JAR files
    are contained in the main folder under `JBOSS_HOME/modules/system/layers/base/javax/jms/api/`
    and `JBOSS_HOME/modules/system/layers/base/javax/transaction/api/`. Simply add
    paths for them in the `rar-info.bat` file (separated by character); for example,
    refer to the following (assuming the jars are in the same directory as `rar-info.bat`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will generate a file called `activemq-rar-5.9.0-report.txt`, which will
    provide you with the required information to construct your own JBoss' JCA configuration
    file that needs to be named `ironjacamar.xml`. Feel free to check out its contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, you can find a sample `ironjacamar.xml` file that defines
    a new queue (`java:jboss/activemq/queue/TicketQueue`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this file contains the definition of ActiveMQ connection factories
    along with the mapping of JMS administration objects, which will be imported by
    the resource adapter. The `ironjacamar.xml` file needs to be copied into the `META-INF`
    folder of `activemq-rar-5.9.0.rar` (you can open the RAR file using the compressed
    files manager of your choice, for example, 7-Zip).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Additional configuration requirements of the resource adapter**'
  prefs: []
  type: TYPE_NORMAL
- en: Along with the `ironjacamar.xml` file, there is another configuration file that
    is contained in the `META-INF` folder of your `activemq-rar-5.9.0.rar` file. The
    `ra.xml` file is the standard JCA configuration file and describes the resource-adapter-related
    attribute's type and its deployment properties. We, however, do not need to alter
    its contents for our basic sample.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have completed the configuration, let''s deploy the resource adapter
    (`activemq-rar-5.9.0.rar`) into our WildFly and check that the JCA factories and
    objects have been correctly bound to the application server. After the deployment,
    you should see the following similar messages in WildFly''s console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Consuming ActiveMQ messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Well done! The hardest part is done. Now in order to consume JMS messages sent
    by the ActiveMQ broker, we will add a `@ResourceAdapter` annotation to a message-driven
    bean. This MDB will intercept bookings from the ActiveMQ broker. In order to be
    able to use the `@ResourceAdapter` annotation, we will need to add a JBoss-specific
    dependency to our `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Our new annotated message bean is presented as follows (note that the property
    `destinationType` is the destination now):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a message is received, it is written to a console. This means that it
    is time to deploy our application. If your ActiveMQ broker is running, you should
    see the following similar messages during the deployment phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now it is time to test our connection using the ActiveMQ console, which will
    send a message straight to the ActiveMQ broker. ActiveMQ 5.9.0 is equipped with
    a bundled **hawt.io** console. It is a pluggable web dashboard that can be configured
    to administer various applications. One of them is ActiveMQ. And, one of the benefits
    of using this console is that you can deploy it on almost any JVM-based container,
    including WildFly. Check out [http://hawt.io/](http://hawt.io/) along with the
    ActiveMQ plugin ([http://hawt.io/plugins/activemq/](http://hawt.io/plugins/activemq/))
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From Version 5.10.0, ActiveMQ is not prebundled with hawt.io anymore. You can
    prepare your own hawt.io console by following the guidelines available at [http://hawt.io/getstarted/index.html](http://hawt.io/getstarted/index.html);
    installing the ActiveMQ plugin; or (which we strongly recommend) using Version
    5.9.0 in your samples, which is conveniently preconfigured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to `http://localhost:8161/hawtio/` and log in using the `admin/admin` credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Consuming ActiveMQ messages](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After the login, you should see the hawt.io web console. It is worth noting
    that it was created using Twitter Bootstrap, the same front-end framework that
    we are using in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the first tab (ActiveMQ) and you should see a tree that represents the
    current configuration of the broker. Find the node `localhost/Queue/`. When you
    expand it, you should see the queue we defined earlier in our resource adapter:
    `java_jboss/activemq/queue/TicketQueue`. After selecting it, you can choose the
    **Send** tab on the right-hand side. You should see a screen similar to the following
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Consuming ActiveMQ messages](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter the desired message into the big text area in the center and click on
    the **Send Message** button. After switching to our WildFly console, we should
    see a log entry with the message we passed to the ActiveMQ broker, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Consuming ActiveMQ messages](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! If you have gone successfully through this example, you have
    just mastered a real-world integration scenario. To make the sample more realistic,
    you could improve the message bean so that it would book tickets if the message
    were to contain the required information (for example, message `55,10` would book
    a seat with ID 55 for 10$). Feel free to experiment!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed JBoss' message-oriented middleware that allows
    you to loosely couple heterogeneous systems together while typically providing
    reliability, transactions, and many other features.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to configure JMS destinations using the web console and create some
    message-driven beans, which are the standard way to consume messages from within
    the EJB container.
  prefs: []
  type: TYPE_NORMAL
- en: We will now move on to another component, which is typically used for integrating
    heterogeneous systems—web services.
  prefs: []
  type: TYPE_NORMAL
