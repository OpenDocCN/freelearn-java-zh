<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;JSF Scopes &#x2013; Lifespan and Use in Managed Beans Communication"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. JSF Scopes – Lifespan and Use in Managed Beans Communication</h1></div></div></div><p>If programming is an art, then working correctly with scopes is a part of it!</p><p>This affirmation is generally true, not just in JSF. Should I use the session scope now, or the request scope? Do I have too many session beans? Can I inject this scope into that scope? Is this session object too big? How many times have you asked yourself these kinds of questions? I know ... many times! Maybe in this chapter you will find answers to some of these questions and you will fortify your knowledge about working with JSF scopes.</p><p>We have a lot to accomplish; therefore, let's have a short overview of what you will see in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">JSF scopes versus CDI scopes</li><li class="listitem" style="list-style-type: disc">Request scope, session scope, view scope, application scope, conversation scope, flow scope, none scope, dependent scope, and custom scope</li><li class="listitem" style="list-style-type: disc">Beans injection</li></ul></div><div class="section" title="JSF scopes versus CDI scopes"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>JSF scopes versus CDI scopes</h1></div></div></div><p>Even a JSF beginner might <a id="id284" class="indexterm"/>have heard about JSF managed beans (regular JavaBeans classes managed by JSF) and CDI beans (regular JavaBeans classes managed by CDI), and<a id="id285" class="indexterm"/> knows that JSF supports JSF scopes and CDI scopes. Starting with Java EE 6, CDI is recognized as the managed bean framework, besides EJBs. This causes confusion among programmers, because EJBs, CDIs, and JSF managed beans raise a critical question: which one to use and when?</p><p>Focusing on JSF, the unanimous answer is that CDI beans are more powerful than JSF beans. But, when you know right from the start that CDI will not be a part of your application or you are running the application inside a servlet container (which does not have CDI support by default, like Apache Tomcat), then JSF beans is the right choice. In other words, when you need a simple way to define beans and a neat mechanism for a dependency injection, then JSF bean will do the job, but when you need heavy artillery, such as events, type safe injection, automatic injection, producer methods, and interceptors, then CDI will represent the complete solution.</p><p>Moreover, NetBeans IDE 8.0 warns us that the JSF bean's annotations will be deprecated in the next JSF version, while the <a id="id286" class="indexterm"/>CDI beans are recommended instead (as shown in the following screenshot). This warning and the new JSF 2.2 flow scope, introduced <a id="id287" class="indexterm"/>as a dependency on CDI, are powerful signals that JSF and CDI become closer and closer:</p><div class="mediaobject"><img src="graphics/6466EN_03_01.jpg" alt="JSF scopes versus CDI scopes"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>CDI beans are much powerful than JSF beans; therefore, use CDI beans whenever possible.</p></div></div><p>So, strong arguments indicate CDI is often the right choice, but there are still instances where it is effective to use JSF beans, as you will soon discover.</p><p>JSF bean's main annotations (such as <code class="literal">@ManagedBean</code> and scopes annotations) are defined in the package <code class="literal">javax.faces.bean</code>, while CDI's main annotations are defined in the <code class="literal">javax.inject</code> (such as, <code class="literal">@Named</code>) and <code class="literal">javax.enterprise.context</code> (such as, scopes) packages.</p><p>A JSF managed bean is annotated with <code class="literal">@ManagedBean</code>, which allows us to inject it in to another bean (not CDI beans!) and to access the bean properties and methods from JSF pages using EL expressions. A CDI bean is annotated with <code class="literal">@Named</code>, which provides an EL name to be used in view technologies, such as JSP or Facelets.</p><p>Typically, a JSF bean is declared as shown in the following code:</p><div class="informalexample"><pre class="programlisting">package <span class="emphasis"><em>package_name</em></span>;

import javax.faces.bean.ManagedBean;
import javax.faces.bean.jsfScoped;

@ManagedBean
@<span class="emphasis"><em>jsf</em></span>Scoped
public class JSFBeanName {
...
}</pre></div><p>The JSF bean, <code class="literal">@ManagedBean</code>, supports an optional parameter, <code class="literal">name</code>. The provided name can be used to reference the bean from JSF pages in the following manner:</p><div class="informalexample"><pre class="programlisting">@ManagedBean(name="<span class="emphasis"><em>custom name</em></span>")</pre></div><p>A CDI bean has the same shape, with<a id="id288" class="indexterm"/> different annotations, as<a id="id289" class="indexterm"/> shown in the following code:</p><div class="informalexample"><pre class="programlisting">package <span class="emphasis"><em>package_name</em></span>;

import javax.inject.Named;
import javax.enterprise.context.cdiScoped;

@Named
@<span class="emphasis"><em>cdi</em></span>Scoped
public class CDIBeanName {
...
}</pre></div><p>The CDI bean, <code class="literal">@Named</code>, supports an optional parameter, <code class="literal">value</code>. The provided name can be used to reference the bean from JSF pages in the following manner:</p><div class="informalexample"><pre class="programlisting">@Named(value="<span class="emphasis"><em>custom name</em></span>")</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>Notice that CDI annotations cannot be mixed with JSF annotations in the same bean, only in the same application. For example, you cannot define a bean using <code class="literal">@ManagedBean</code> and a CDI scope (or any other combination between them), but you can have, in the same application, a managed bean (or more) and a CDI bean (or more).</p></div></div><p>In the following figure, you can see a short overview of JSF 2.2 scopes:</p><div class="mediaobject"><img src="graphics/6466EN_03_02.jpg" alt="JSF scopes versus CDI scopes"/></div><p>In the<a id="id290" class="indexterm"/> next section, you will <a id="id291" class="indexterm"/>see how each JSF/CDI scope works.</p></div></div>
<div class="section" title="The request scope"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>The request scope</h1></div></div></div><p>The <span class="strong"><strong>request scope</strong></span><a id="id292" class="indexterm"/> is bound to the HTTP request-response life cycle.</p><p>The request scope is very useful in any web application, and an object defined in the request scope usually has a short lifespan; beans live as long as the HTTP request-response lives. When the container accepts an HTTP request from the client, the specified object is attached to the request scope and it is released when the container has finished transmitting the response to that request. A new HTTP request always comes in a new request scope object. In short, a request scope represents a user's interaction with a web application in a single HTTP request. Commonly, a request scope is useful for simple GET requests that expose some<a id="id293" class="indexterm"/> data to the user without requiring to store the data.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>The request scope is present in JSF and CDI and functions in the same way. It can be used for nonrich AJAX and non-AJAX requests. For JSF managed beans (<code class="literal">@ManagedBean</code>), this is the default scope, when none is specified.</p></div></div><p>For example, let's suppose that we have a predefined list of tennis players, and we randomly extract them one-by-one from this list and store them in another list. The current generated player and<a id="id294" class="indexterm"/> the list of extracted players are managed bean's properties and their values are rendered in a JSF page.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>The request scope annotation is <code class="literal">@RequestScoped</code> and is defined in the <code class="literal">javax.enterprise.context</code> package for CDI, and in the <code class="literal">javax.faces.bean</code> package for JSF.</p></div></div><p>The code for the CDI bean can be written as follows:</p><div class="informalexample"><pre class="programlisting">@Named
@RequestScoped
public class PlayersBean {

  final String[] players_list = {"Nadal, Rafael (ESP)","Djokovic, Novak (SRB)", "Ferrer, David (ESP)", "Murray, Andy (GBR)", "Del Potro, Juan Martin (ARG)"};

  private ArrayList players = new ArrayList();
  private String player;

  //getters and setters
      
  public void newPlayer() {
    int nr = new Random().nextInt(4);
    player = players_list[nr];
    players.add(player);
  }
}</pre></div><p>The relevant<a id="id295" class="indexterm"/> part of the JSF page is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:body&gt;
  Just generated:
  &lt;h:outputText value="#{playersBean.player}"/&gt;&lt;br/&gt;

  List of generated players:
  &lt;h:dataTable var="t" value="#{playersBean.players}"&gt;
    &lt;h:column&gt;
      &lt;h:outputText value="#{t}"/&gt;
    &lt;/h:column&gt;
  &lt;/h:dataTable&gt;       
  &lt;h:form&gt;
    &lt;h:commandButton value="Get Players In Same View" actionListener="#{playersBean.newPlayer()}"/&gt;
    &lt;h:commandButton value="Get Players With Page Forward" actionListener="#{playersBean.newPlayer()}" action="index.xhtml"/&gt;
    &lt;h:commandButton value="Get Players With Page Redirect" actionListener="#{playersBean.newPlayer()}" action="index.xhtml?faces-redirect=true;"/&gt;
  &lt;/h:form&gt;
&lt;/h:body&gt;</pre></div><p>When you click on the button labeled <span class="strong"><strong>Get Players With Page Forward</strong></span> or <span class="strong"><strong>Get Players In Same View</strong></span>, you will see something as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_03_03.jpg" alt="The request scope"/></div><p>Since a request scope lives<a id="id296" class="indexterm"/> as long as the HTTP request-response lives and page forward implies a single HTTP request-response, you will see the player extracted at the current request and the list of extracted players, which will always only contain this player. The list is created for each request and filled with the current player, which makes the list useless.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>The request scope doesn't lose the object's state while forwarding, because the source page and the destination page (the forwarded page) are part of the same request-response cycle. This is not true in the case of redirect actions.</p></div></div><p>When you click on the button labeled <span class="strong"><strong>Get Players With Page Redirect</strong></span>, you will see something as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_03_04.jpg" alt="The request scope"/></div><p>The current extracted <a id="id297" class="indexterm"/>player and the list content is not available in this case, because a JSF redirect implies two requests, instead of one as in the forward case.</p><p>Programmatically, you can access the request map<a id="id298" class="indexterm"/> using the following code:</p><div class="informalexample"><pre class="programlisting">FacesContext context = FacesContext.getCurrentInstance();
Map&lt;String, Object&gt; requestMap = context.getExternalContext().getRequestMap();</pre></div><p>Submitting a form defined in page 1 to page 2 via a bean, and then you have the following cases:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the same view or forward is used, then the data is available for display on page 2</li><li class="listitem" style="list-style-type: disc">If redirect is used, then data will be lost and not available for display on page 2</li></ul></div><p>The JSF version<a id="id299" class="indexterm"/> of the CDI beans is as follows:</p><div class="informalexample"><pre class="programlisting">import javax.faces.bean.ManagedBean;
import javax.faces.bean.RequestScoped;

@ManagedBean
@RequestScoped
public class PlayersBean {
  ...
}</pre></div><p>And it works the same as the CDI bean!</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>A method annotated with <code class="literal">@PostConstruct</code> will be called for each request, since each request requires a separate instance of the request scoped bean.</p></div></div><p>The case of the CDI bean is<a id="id300" class="indexterm"/> wrapped into the application named <code class="literal">ch3_1_1</code>, while the case of the JSF bean is wrapped into application named <code class="literal">ch3_1_2</code>.</p></div>
<div class="section" title="The session scope"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>The session scope</h1></div></div></div><p>The <span class="strong"><strong>session scope</strong></span><a id="id301" class="indexterm"/> lives across multiple HTTP request-response cycles (theoretical unlimited).</p><p>The request scope is very useful in any web application when you need a single interaction per HTTP request-response cycle. However, when you need objects visible for any HTTP request-response cycle that belongs to a user session, then you need a session scope; in this case, the bean lives as long as the HTTP session lives. The session scope allows you to create and bind objects to a session. It gets created upon the first HTTP request involving this bean in the session and gets destroyed when the HTTP session is invalidated.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>The session scope is present in JSF and CDI and it functions the same way in both. Commonly, it is used for AJAX and non-AJAX requests that process user-specific data (such as credentials, shopping carts, and so on).</p></div></div><p>Therefore, the first HTTP request initializes the session and stores the objects, while the subsequent requests have access<a id="id302" class="indexterm"/> to these objects for further tasks. A session invalidation occurs when the browser is closed, a timeout is fired, the logout is clicked, or a programmatic subroutine forces it. Normally, each time you need to preserve data across the whole session (multiple requests and pages), the session scope is the right choice.</p><p>For example, you can add the session scope to the previous applications of this chapter for storing the list of randomly extracted players across multiple requests.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>The session scope annotation is <code class="literal">@SessionScoped</code> and is defined in the <code class="literal">javax.enterprise.context</code> package for CDI, and in the <code class="literal">javax.faces.bean</code> package for JSF.</p></div></div><p>The CDI bean is modified as follows:</p><div class="informalexample"><pre class="programlisting">import java.io.Serializable;
import javax.enterprise.context.SessionScoped;
import javax.inject.Named;

@Named
@SessionScoped
public class PlayersBean implements Serializable{
  ...
}</pre></div><p>Alternatively, the JSF version is as follows:</p><div class="informalexample"><pre class="programlisting">import java.io.Serializable;
import javax.faces.bean.ManagedBean;
import javax.faces.bean.SessionScoped;

@ManagedBean
@SessionScoped
public class PlayersBean implements Serializable{
  ...
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>Notice that the session scope bean might get passivated by the container and should be capable of passivity, which means that the session beans should be serializable (implement the <code class="literal">java.io.Serializable</code> interface); refer to the capability to persist/restore session data to/from the hard disk.</p></div></div><p>The session objects lives across forward and redirect mechanisms. In the following screenshot, you can see the<a id="id303" class="indexterm"/> current extracted player and the list of extracted players after several requests belonging to the same session:</p><div class="mediaobject"><img src="graphics/6466EN_03_05.jpg" alt="The session scope"/></div><p>Now the list is not useless anymore! You can add methods for manipulating its content, such as order or delete.</p><p>Programmatically, you can access<a id="id304" class="indexterm"/> the session map as follows:</p><div class="informalexample"><pre class="programlisting">FacesContext context = FacesContext.getCurrentInstance();
Map&lt;String, Object&gt; sessionMap = context.getExternalContext().getSessionMap();</pre></div><p>Also, you can<a id="id305" class="indexterm"/> invalidate a session as follows:</p><div class="informalexample"><pre class="programlisting">FacesContext.getCurrentInstance().getExternalContext().invalidateSession();</pre></div><p>Obviously, data submitted through forms across the session scope will be available in subsequent requests.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>A method annotated with <code class="literal">@PostConstruct</code> will be called only once during a session, when the session bean is instantiated. Subsequent requests will use this instance, so it can be a good place to add initialization stuff.</p></div></div><p>The case of the CDI bean is<a id="id306" class="indexterm"/> wrapped into the application named <code class="literal">ch3_2_1</code>, while the case of the JSF bean is wrapped into the application named <code class="literal">ch3_2_2</code>.</p></div>
<div class="section" title="The view scope"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>The view scope</h1></div></div></div><p>The <span class="strong"><strong>view scope</strong></span><a id="id307" class="indexterm"/> lives as long as you are navigating in the same JSF view in the browser window/tab.</p><p>The view scope is useful when you need to preserve data over multiple requests without leaving the current JSF view by clicking on a link, returning a different action outcome, or any other interaction that dumps<a id="id308" class="indexterm"/> the current view. It gets created upon an HTTP request and gets destroyed when you postback to a different view; as long as you postback to the same view, the view scope is alive.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note38"/>Note</h3><p>Notice that the view scope bean might get passivated by the container and should be capable of passivity by implementing the <code class="literal">java.io.Serializable</code> interface.</p></div></div><p>Since the view scope is particularly useful when you are editing some objects while staying in the same view, it can be the perfect choice for rich AJAX requests. Moreover, since the view scope is bounded to the current view, it does not reflect the stored information in another window or tab of a browser; this is an issue specific to the session scope!</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note39"/>Note</h3><p>In order to keep the view active, the bean methods (actions/listeners) must return <code class="literal">null</code> or <code class="literal">void</code>.</p></div></div><p>The view scope is not available in CDI, but JSF 2.2 has introduced it through the new annotation, <code class="literal">@ViewScoped</code>. This is defined in the <code class="literal">javax.faces.view.ViewScoped</code> package and it is compatible with CDI. Do not confuse this <code class="literal">@ViewScoped</code> with the one defined in the <code class="literal">javax.faces.bean</code> package, which is JSF compatible!</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note40"/>Note</h3><p>The view scope annotation is <code class="literal">@ViewScoped</code> and is defined in the <code class="literal">javax.faces.view</code> package for CDI, and in the <code class="literal">javax.faces.bean</code> package for JSF.</p></div></div><p>You can see the view scope in action by<a id="id309" class="indexterm"/> modifying the <code class="literal">PlayersBean</code> scope as follows:</p><div class="informalexample"><pre class="programlisting">import java.io.Serializable;
import javax.faces.view.ViewScoped;
import javax.inject.Named;

@Named
@ViewScoped
public class PlayersBean implements Serializable{
  ...
}</pre></div><p>Firing multiple HTTP requests by clicking on the button labeled <span class="strong"><strong>Get Players In Same View</strong></span> will reveal something like<a id="id310" class="indexterm"/> the following screenshot. Notice the action method (<code class="literal">newPlayer</code>) returns void and the button doesn't contain the <code class="literal">action</code> attribute, which means that you are in the same JSF view during the execution of these requests.</p><div class="mediaobject"><img src="graphics/6466EN_03_06.jpg" alt="The view scope"/></div><p>The other two buttons contain the <code class="literal">action</code> attribute and indicate an explicit navigation, which means that the current view is changed at every request and the data is lost.</p><p>You can easily adapt <code class="literal">PlayersBean</code> (and any other bean) to use the JSF version of <code class="literal">@ViewScoped</code> as follows:</p><div class="informalexample"><pre class="programlisting">import java.io.Serializable;
import javax.faces.bean.ManagedBean;
import javax.faces.bean.ViewScoped;

@ManagedBean
@ViewScoped
public class PlayersBean implements Serializable{
  ...
}</pre></div><p>Data submitted through forms across the view scope will be available in subsequent requests as long as you are in the same view.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note41"/>Note</h3><p>A method annotated with <code class="literal">@PostConstruct</code> will be called only when the view scoped bean is instantiated. Subsequent requests, from this view, will use this instance. As long as you are in the same view, this method will not be called again; therefore, it can be a good place to add initialization stuff specific to the current view.</p></div></div><p>The case of the CDI bean is<a id="id311" class="indexterm"/> wrapped into the application named <code class="literal">ch3_6_1</code>, while the case of the JSF bean is wrapped into the application named <code class="literal">ch3_6_2</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note42"/>Note</h3><p>Starting with JSF 2.2, we can use the <code class="literal">UIViewRoot.restoreViewScopeState(FacesContext context, Object state)</code> method for restoring the view scope when it is not available. This will be exemplified in <a class="link" href="ch12.html" title="Chapter 12. Facelets Templating">Chapter 12</a>, <span class="emphasis"><em>Facelets Templating</em></span>.</p></div></div></div>
<div class="section" title="The application scope"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>The application scope</h1></div></div></div><p>The <span class="strong"><strong>application scope</strong></span><a id="id312" class="indexterm"/> lives as long as the web application lives.</p><p>An application scope extends the session scope with the shared state across all users' interactions with a web application; this scope lives as long as the web application lives. Since the beans in the application scope lives until the application shuts down (or they are programmatically removed), we can say that this scope lives most. More precisely, objects settled on the application scope can be accessed from any page that is part of the application (for example, JSF, JSP, and XHTML).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note43"/>Note</h3><p>The application scope should be used only for data that is safe to be shared. Since an application scoped bean is shared by all users, you need to be sure that the bean has an immutable state or you need to synchronize access.</p></div></div><p>Usually, application scope objects are used as counters, but they can be used for many other tasks, such as initializations and navigations. For example, the application scope can be used to count how many users are online or to share that information with all users. Practically, it can be used to<a id="id313" class="indexterm"/> share data among all sessions, such as constants, common settings, and tracking variables.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note44"/>Note</h3><p>The application scope annotation is <code class="literal">@ApplicationScoped</code> and is defined in the <code class="literal">javax.enterprise.context</code> package for CDI, and in the <code class="literal">javax.faces.bean</code> package for JSF.</p></div></div><p>If you put the <code class="literal">PlayersBean</code> managed bean in the application scope, then the list of randomly extracted players will be available across all sessions. You can do it as shown in the following code:</p><div class="informalexample"><pre class="programlisting">import javax.enterprise.context.ApplicationScoped;
import javax.inject.Named;

@Named
@ApplicationScoped
public class PlayersBean {
  ...
}</pre></div><p>The JSF version is shown in the following code:</p><div class="informalexample"><pre class="programlisting">import javax.faces.bean.ApplicationScoped;
import javax.faces.bean.ManagedBean;

@ManagedBean
@ApplicationScoped
public class PlayersBean {
  ...
}</pre></div><p>For testing<a id="id314" class="indexterm"/> the application scope, you need to open multiple browsers or use multiple machines.</p><p>Be careful when you provide data from an application scoped bean to multiple sessions beans (for example, using injection), since the data shared by all sessions can be modified by each session separately. This can lead to inconsistent data across multiple users; therefore, be sure that the exposed application data isn't modified in sessions.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note45"/>Note</h3><p>A method annotated with <code class="literal">@PostConstruct</code> will be called only when the application scoped bean is instantiated. Subsequent requests will use this instance. Usually, this happens when the application starts; therefore, place inside this method the initialization tasks specific to the application in the context of this bean.</p></div></div><p>Programmatically, you can access<a id="id315" class="indexterm"/> the application map using the following code:</p><div class="informalexample"><pre class="programlisting">FacesContext context = FacesContext.getCurrentInstance();
Map&lt;String, Object&gt; applicationMap = context.getExternalContext().getApplicationMap();</pre></div><p>The case of the CDI bean is wrapped into the application named <code class="literal">ch3_3_1</code>, while the case of the JSF bean is wrapped into the application named <code class="literal">ch3_3_2</code>.</p></div>
<div class="section" title="The conversation scope"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>The conversation scope</h1></div></div></div><p>The <span class="strong"><strong>conversation scope</strong></span><a id="id316" class="indexterm"/> allows developers to demarcate the lifespan of the session scope.</p><p>The conversation scope is committed to the user's interaction with JSF applications and represents a unit of work from the point of view of the user; a bean in this scope is able to follow a conversation with a user. We may charge the conversation scope as a developer-controlled session scope across multiple invocations of the JSF life cycle; while session scoped lives across unlimited requests, the conversation scopes lives only across a limited number of requests.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note46"/>Note</h3><p>The conversation scope bean might get passivated by the container and should be capable of passivity by implementing the <code class="literal">java.io.Serializable</code> interface.</p></div></div><p>The developer can explicitly set the conversation scope boundaries and can start, stop, or propagate the conversation scope based on the business logic flow. All long-running conversations are scoped to a particular HTTP servlet session and may not cross session boundaries. In addition, conversation scope keeps the state associated with a particular Web browser window/tab in a JSF application.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note47"/>Note</h3><p>The conversation scope annotation is <code class="literal">@ConversationScoped</code> and is defined in the <code class="literal">javax.enterprise.context</code> package for CDI. This scope is not available in JSF!</p></div></div><p>Dealing with the conversation<a id="id317" class="indexterm"/> scope is slightly different from the rest of the scopes. First, you mark the bean with <code class="literal">@ConversationScope</code>, represented by the <code class="literal">javax.enterprise.context.ConversationScoped</code> class. Second, CDI provides a built-in bean (<code class="literal">javax.enterprise.context.Conversation</code>) for controlling the life cycle of conversations in a JSF application—its main responsibility is to manage the conversation context. This bean may be obtained by injection, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">private @Inject Conversation conversation;</pre></div><p>By default, the <code class="literal">Conversation</code> object is in transient state and it should be transformed into a long-running conversation by calling the <code class="literal">begin</code> method. You also need to prepare for the destruction of the conversation by calling the <code class="literal">end</code> method.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note48"/>Note</h3><p>If we try to call the <code class="literal">begin</code> method when the conversation is active, or the <code class="literal">end</code> method when the conversation is inactive, <code class="literal">IllegalStateException</code> will be thrown. We can avoid this by testing the transitivity state of the <code class="literal">Conversation</code> objects using the method named <code class="literal">isTransient</code>, which returns a Boolean value.</p></div></div><p>Now, add the <code class="literal">begin</code>, <code class="literal">end</code>, and <code class="literal">isTransient</code> methods together to the following conversations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For start conversation, the code is as follows:<div class="informalexample"><pre class="programlisting">if (conversation.isTransient()) {
  conversation.begin();
}</pre></div></li><li class="listitem" style="list-style-type: disc">For stop conversation, the code is as follows:<div class="informalexample"><pre class="programlisting">if (!conversation.isTransient()) {
  conversation.end();
}</pre></div></li></ul></div><p>For example, you can add<a id="id318" class="indexterm"/> the conversation scope in <code class="literal">PlayersBean</code> as follows:</p><div class="informalexample"><pre class="programlisting">@Named
@ConversationScoped
public class PlayersBean implements Serializable {

<span class="strong"><strong>  private @Inject</strong></span>
<span class="strong"><strong>  Conversation conversation;</strong></span>

  final String[] players_list = {"Nadal, Rafael (ESP)","Djokovic, Novak (SRB)", "Ferrer, David (ESP)", "Murray, Andy (GBR)", "Del Potro, Juan Martin (ARG)"};
  private ArrayList players = new ArrayList();
  private String player;

  public PlayersBean() {
  }

  //getters and setters

  public void newPlayer() {
    int nr = new Random().nextInt(4);
    player = players_list[nr];
    players.add(player);
  }   

<span class="strong"><strong>  public void startPlayerRnd() {</strong></span>
<span class="strong"><strong>    if (conversation.isTransient()) {</strong></span>
<span class="strong"><strong>      conversation.begin();</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  }</strong></span>

<span class="strong"><strong>  public void stopPlayerRnd() {</strong></span>
<span class="strong"><strong>    if (!conversation.isTransient()) {</strong></span>
<span class="strong"><strong>      conversation.end();</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>Besides injecting the built-in CDI bean, notice that you have defined a method (<code class="literal">startPlayerRnd</code>) for demarcating the conversation start point and another method (<code class="literal">stopPlayerRnd</code>) for demarcating the conversation stop point. In this example, both the methods are exposed to the<a id="id319" class="indexterm"/> user through two buttons, but you can control the conversation programmatically by calling them conditionally.</p><p>Running the example inside a conversation will reveal something as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_03_07.jpg" alt="The conversation scope"/></div><p>The list of randomly extracted players will be empty or will contain only the current extracted player until the button labeled <span class="strong"><strong>Start Conversation</strong></span> is clicked. At that moment the list will be stored in session, until the button labeled <span class="strong"><strong>Stop Conversation</strong></span> is clicked.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note49"/>Note</h3><p>During the conversation, the user may execute AJAX/non-AJAX requests against the bean or perform navigations to other pages that still reference this same managed bean. The bean<a id="id320" class="indexterm"/> will keep its state across user interactions using a <span class="strong"><strong>conversation identifier</strong></span><a id="id321" class="indexterm"/> generated by the container, and this is why the conversation scope can be the right choice when you need to implement wizards. But it might be a good idea to take into account the new JSF 2.2 flow scope as well, which solves several gaps of the conversation scope. See the upcoming section!</p></div></div><p>In this example, the conversation <a id="id322" class="indexterm"/>context automatically propagates with any JSF faces request or redirection (this facilitates the implementation of the common POST-then-redirect pattern), but it does<a id="id323" class="indexterm"/> not automatically propagate with non-faces requests, such as links. In this case, you need to include the unique identifier of the conversation as a request parameter. The CDI specification reserves the request parameter <code class="literal">cid</code> for this use. The following code will propagate the conversation context over a link:</p><div class="informalexample"><pre class="programlisting">&lt;h:link outcome="/link.xhtml" value="Conversation Propagation"&gt;
  &lt;f:param name="cid" value="#{conversation.id}"/&gt;
&lt;/h:link&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note50"/>Note</h3><p>A method annotated with <code class="literal">@PostConstruct</code> will be called for each request as long as the bean is not involved in a conversation. When the conversation begins, the method is called for that instance and subsequent requests will use this instance until the conversation ends. Therefore, be careful how you manage this method content.</p></div></div><p>This example is wrapped into the application named <code class="literal">ch3_4</code> and is available in the code bundle of this chapter.</p></div>
<div class="section" title="The flow scope"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>The flow scope</h1></div></div></div><p>The <span class="strong"><strong>flow scope</strong></span><a id="id324" class="indexterm"/> allows developers to group pages/views and demarcate the group with entry/exit points.</p><p>Between the request scope and the session scope, we have the CDI flow scope. This scope exists for a while in Spring Web Flow or ADF flow, and now is available in JSF 2.2 as well. Basically, the flow scope allows us to demarcate a set of related pages/views (usually, logic related) with an entry point (known as <span class="strong"><strong>start node</strong></span>) <a id="id325" class="indexterm"/>and an<a id="id326" class="indexterm"/> exit point (known as <span class="strong"><strong>return node</strong></span>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note51"/>Note</h3><p>The flow scope is a good choice for applications that contain wizards, such as multiscreen subscriptions/registrations, bookings, and shopping carts. Generally speaking, any chunk of an application that has a logical start point and an end point can be encapsulated into the flow scope.</p></div></div><p>In the same application, we can define multiple flows, which can be seen as modules that are reusable and capable to communicate. They can be called sequentially, can be encapsulated as Matrioska dolls or can create any custom design. Moreover, it is very easy to move, delete, or add a flow into such an application just by plugging in/out the entry and exit point.</p><p>To understand the benefits of<a id="id327" class="indexterm"/> using the flow scope, you have to identify some disadvantages of the applications that don't use it. They are listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Each application is a big flow, but usually pages do not follow any intuitive logical design. Apparently, a disordered order governs even when pages are logically related, such as pages of a wizard or of a shopping cart.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note52"/>Note</h3><p>The flow scope allows us to define logical units of work.</p></div></div></li><li class="listitem" style="list-style-type: disc">Reusing pages can be a difficult task to accomplish, since pages are so tied up to UI components and user interaction.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note53"/>Note</h3><p>The flow scope provides reusability.</p></div></div></li><li class="listitem" style="list-style-type: disc">CDI provides conversation scope capable of stretching over several pages, but the flow scope fits better for JSF.</li><li class="listitem" style="list-style-type: disc">As the conversation scope, the flow scope covers a set of pages/views, but it has several main advantages, such as it is much more flexible, doesn't need that clumsy begin/end operation, flow scoped beans are created and destroyed automatically when the user enters or exists into/from a flow, provides easy-to-use support for inbound/outbound parameters, and prehandlers and posthandlers. A normal flow cannot be opened in multiple windows/tabs because information travels between pages with the session scope.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note54"/>Note</h3><p>Data in a flow is scoped to that flow alone; therefore, flows can be opened in multiple windows/tabs.</p></div></div></li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>nodes</strong></span> define the entry and <a id="id328" class="indexterm"/>exit points of a flow and there are five types of nodes, which are listed as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>View</strong></span>: This represents any JSF page in the application that participates in the flow. It is known as a <span class="strong"><strong>view node</strong></span> of the flow.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The method call</strong></span>: This indicates an invocation of a method using EL. The called method may return an outcome that indicates which node should be navigated next.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Switch</strong></span>: The <code class="literal">switch</code> case statements are a substitute for long <code class="literal">if</code> statements. The cases are represented by EL expressions and are evaluated to Boolean values. Each case is accompanied by an outcome that will be used when the condition is evaluated to <code class="literal">true</code>. There is also a default outcome that will be used when all cases are evaluated to <code class="literal">false</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The flow call</strong></span>: This is used to call another flow in the current flow—these are transition points between flows. The called flow (known as inner or nested flow) is nested in the flow that calls it (known as calling flow or outer flow). When the nested flow finishes its tasks, it will return a view node from the calling flow, which means that the calling flow will have control only after the nested flow's lifespan comes to an end.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The flow return</strong></span>: This can be used for returning an outcome to the calling flow.</li></ul></div></li></ul></div><p>Flows can pass parameters from one to the other. Parameters sent by a flow to another flow are known<a id="id329" class="indexterm"/> as <span class="strong"><strong>outbound parameters</strong></span>, while parameters received by a flow from another flow are<a id="id330" class="indexterm"/> known as <span class="strong"><strong>inbound parameters</strong></span>.</p><p>Well, at this point, you should have enough information about the flow scope to develop some examples. But, before doing this, you need to be aware of some tags, annotations, and conventions.</p><p>The flow definition<a id="id331" class="indexterm"/> is based on a set of conventions over configuration. A flow has a name, a folder in the web root of the application reflecting the flow name, and a view representing the start node that also reflects the flow name. This folder groups the pages/views that belong to the same flow.</p><p>In order to use a flow, you need to <a id="id332" class="indexterm"/>accomplish some configuration tasks. These can be done through a configuration file or programmatically. If you choose the first approach, then the configuration file can be limited to one flow, which means that it is stored in the flow folder and is named in the format <span class="emphasis"><em>flowname</em></span><code class="literal">-flow.xml</code>, or you can use the <code class="literal">faces-config.xml</code> file for having all flows in a single place.</p><p>Since our first example uses<a id="id333" class="indexterm"/> the configuration file, we need to use tags. The main tags used for configuring a flow are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">&lt; flow-definition&gt;</code>: This tag contains an <code class="literal">id</code> attribute that uniquely identifies the flow. The value of this ID is the flow name used to reference the flow from JSF pages or beans.</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;view&gt;</code>: It is nested in the <code class="literal">&lt;flow-definition&gt;</code> tag and indicates the JSF pages that represent the flow nodes; it associates an explicit ID to each page (Facelet) path (further, you can refer to each page by its ID). The page path is mapped in a <code class="literal">&lt;vdl-document&gt;</code> tag, nested in the <code class="literal">&lt;view&gt;</code> tag. The presence of this tag is optional, but as a convention, at least the <code class="literal">&lt;view&gt;</code> tag indicating the start node (start page) is present, especially if you want to set another start node besides the default one, which is represented by the page in the flow with the same name (ID) as the flow. Further, you can use the optional <code class="literal">&lt;start-node&gt;</code><span class="emphasis"><em>ID</em></span><code class="literal">&lt;/start-node&gt;</code> tag and indicate the ID of the <code class="literal">&lt;view&gt;</code> tag that maps the custom starting page. As an alternative, the start node of the flow can be indicated by setting the value of the <code class="literal">id</code> attribute of a <code class="literal">&lt;view&gt;</code> tag as the flow ID, and the content of the encapsulated <code class="literal">&lt;vdl-document&gt;</code> tag as the path of the custom starting page. When you refer to the flow ID, JSF will go to that page and automatically put you in the flow.</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;flow-return&gt;</code>: It is nested in the <code class="literal">&lt;flow-definition&gt;</code> tag and returns an outcome to the calling flow. You can refer to it through the value of the <code class="literal">id</code> attribute. There are at least three ways of getting out of a flow: using <code class="literal">&lt;flow-return&gt;</code>, using <code class="literal">&lt;flow-call&gt;</code> (presented later), or by abandoning the flow.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note55"/>Note</h3><p>We just said that a flow is identified by an ID (by a name). But, when the same flow name is defined in multiple documents (like in big projects that use multiple packaged flows from different vendors), there is one more ID needed. This ID is known as the <span class="strong"><strong>document ID</strong></span>. Thus, when you need to identify a flow whose name appears in different documents, we need the flow ID and the defining document ID. Most of the time the document ID is omitted; therefore, it is not demonstrated in this section. In this section, you will see just a few hints about it.</p></div></div><p>In order to define the simplest flow, <a id="id334" class="indexterm"/>you need to be aware of the following diagram:</p><div class="mediaobject"><img src="graphics/6466EN_03_08.jpg" alt="The flow scope"/></div><div class="section" title="The simple flow"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>The simple flow</h2></div></div></div><p>With these three tags, <code class="literal">&lt;start-node&gt;</code> and/or <code class="literal">&lt;view&gt;</code>, <code class="literal">&lt;flow-return&gt;</code>, and <code class="literal">&lt;from-outcome&gt;</code>, you can configure a simple flow, like a peddling registration form. Let's suppose that a tennis player<a id="id335" class="indexterm"/> registers online to a tournament through a flow<a id="id336" class="indexterm"/> made up of two JSF pages (the flow name will be <code class="literal">registration</code>): a page containing a form used for collecting data and a confirmation page. Moreover, there will be two pages outside the flow, one for entering into the flow (like the first page of the website), and one that is called after confirmation.</p><p>In the following diagram, you can see an image of our flow:</p><div class="mediaobject"><img src="graphics/6466EN_03_09.jpg" alt="The simple flow"/></div><p>Let's have a look at the code for the first page that is outside the flow and outside the registration folder (<code class="literal">index.xhtml</code>) as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:body&gt;
  &lt;h1&gt;&lt;b&gt;In flow ? 
  #{null != facesContext.application.flowHandler.currentFlow}
  &lt;/b&gt;&lt;/h1&gt;&lt;br/&gt;&lt;br/&gt;   
  Flow Id: #{facesContext.application.flowHandler.currentFlow.id}
  REGISTER NEW PLAYER
  &lt;h:form&gt;
    &lt;h:commandButton value="Start Registration" action="registration" immediate="true"/&gt;
  &lt;/h:form&gt;
&lt;/h:body&gt;</pre></div><p>Two important things can be observed here. First, the following lines:</p><div class="informalexample"><pre class="programlisting">  #{null != facesContext.application.flowHandler.currentFlow}
  #{facesContext.application.flowHandler.currentFlow.id}</pre></div><p>The first line returns a<a id="id337" class="indexterm"/> Boolean value indicating whether the current page is or is not in a flow. Obviously, the <code class="literal">index.xhtml</code> page is not in a flow; therefore, <code class="literal">false</code> will be returned. You can use it for tests. The second line displays the ID of the current flow.</p><p>Further, you need to take <a id="id338" class="indexterm"/>a look at the value of the attribute <code class="literal">action</code> of the <code class="literal">&lt;h:commandButton&gt;</code> tag. This value is the name (ID) of our flow; after the window context is enabled, JSF will search the indicated flow and navigate to the start node of the flow. By default, the window context is disabled.</p><p>Therefore, when the button labeled <span class="strong"><strong>Start Registration</strong></span> is clicked, the application steps in the registration flow and loads the start node page represented by<a id="id339" class="indexterm"/> the <code class="literal">registration.xhtml</code> page. The code for this page is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:body&gt;
  &lt;h1&gt;&lt;b&gt;First page in the 'registration' flow&lt;/b&gt;&lt;/h1&gt;
  &lt;h1&gt;&lt;b&gt;In flow ? 
  #{null != facesContext.application.flowHandler.currentFlow}
  &lt;/b&gt;&lt;/h1&gt;&lt;br/&gt;&lt;br/&gt; 

  You are registered as:#{flowScope.value}
  &lt;h:form prependId="false"&gt;
    Name &amp;amp; Surname: 
    &lt;h:inputText id="nameSurnameId" value="#{flowScope.value}" /&gt;
    &lt;h:commandButton value="Register To Tournament" action="confirm"/&gt;           
    &lt;h:commandButton value="Back(exit flow)" action="taskFlowReturnIndex"/&gt;  
  &lt;/h:form&gt;
&lt;/h:body&gt;</pre></div><p>Since we are in the flow, <code class="literal">currentFlow</code> will return <code class="literal">true</code>.</p><p>It is more important to focus on the implicit object, <code class="literal">flowScope</code>; however, as you know from <a class="link" href="ch01.html" title="Chapter 1. Dynamic Access to JSF Application Data through Expression Language (EL 3.0)">Chapter 1</a>, <span class="emphasis"><em>Dynamic Access to JSF Application Data through Expression Language (EL 3.0)</em></span>, the <code class="literal">flowScope</code> implicit object (which indicates the current flow) is used for sharing data through the entire flow and maps to <code class="literal">facesContext.getApplication().getFlowHandler().getCurrentFlowScope()</code>. For example, the value of the <code class="literal">&lt;h:inputText&gt;</code> tag can be put into the <code class="literal">flowScope</code> object and can be read from the flow scope in the next page, as follows:</p><div class="informalexample"><pre class="programlisting">#{flowScope.value}</pre></div><p>The button labeled <span class="strong"><strong>Register To Tournament</strong></span> navigates to the second page in the flow, <code class="literal">confirm.xhtml</code>; this is a usual navigation case, there is nothing to say here. But the other button navigates outside<a id="id340" class="indexterm"/> the flow (to <code class="literal">index.xhtml</code>) by indicating the<a id="id341" class="indexterm"/> ID of a flow return. In the configuration file, this flow return is as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;flow-return id="taskFlowReturnIndex"&gt;
  &lt;from-outcome&gt;/index&lt;/from-outcome&gt;
&lt;/flow-return&gt;</pre></div><p>The code of the <code class="literal">confirm.xhtml</code> page<a id="id342" class="indexterm"/> is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:body&gt;
  &lt;h1&gt;&lt;b&gt;Second page in the 'registration' flow&lt;/b&gt;&lt;/h1&gt;
  &lt;h1&gt;&lt;b&gt;In flow ? 
  #{null != facesContext.application.flowHandler.currentFlow}
  &lt;/b&gt;&lt;/h1&gt;&lt;br/&gt;&lt;br/&gt; 
  You are registered as:#{flowScope.value}
  &lt;h:form prependId="false"&gt;           
    &lt;h:commandButton value="Back (still in flow)" action="registration"/&gt;
    &lt;h:commandButton value="Next (exit flow)" action="taskFlowReturnDone"/&gt;
  &lt;/h:form&gt;
&lt;/h:body&gt;</pre></div><p>This page displays the data that was entered and stored on the flow scope along with both the buttons. The first button navigates back to the <code class="literal">registration.xhtml</code> page, while the other one navigates to the <code class="literal">done.xhtml</code> page, which is outside the flow. The flow return is identified by the ID, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;flow-return id="taskFlowReturnDone"&gt;
  &lt;from-outcome&gt;/done&lt;/from-outcome&gt;
&lt;/flow-return&gt;</pre></div><p>The <code class="literal">done.xhtml</code> page<a id="id343" class="indexterm"/> just checks to see if the page is in flow and displays a simple message, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:body&gt;
  &lt;h1&gt;&lt;b&gt;In flow ? 
  #{null != facesContext.application.flowHandler.currentFlow}
  &lt;/b&gt;&lt;/h1&gt;&lt;br/&gt;&lt;br/&gt;        
  REGISTER NEW PLAYER ENDED        
&lt;/h:body&gt;</pre></div><p>The final step is to define the flow in a configuration file. Since you have a single flow, you can create a file <code class="literal">registration-flow.xml</code> in the <code class="literal">registration</code> folder. The following is the<a id="id344" class="indexterm"/> code of the<a id="id345" class="indexterm"/> <code class="literal">registration-flow.xml</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;faces-config version="2.2" 
  
  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
  http://xmlns.jcp.org/xml/ns/javaee/web-facesconfig_2_2.xsd"&gt;
    
  &lt;flow-definition id="registration"&gt;
    &lt;view id="registration"&gt;
      &lt;vdl-document&gt;/registration/registration.xhtml&lt;/vdl-document&gt;
    &lt;/view&gt;
    &lt;flow-return id="taskFlowReturnIndex"&gt;
      &lt;from-outcome&gt;/index&lt;/from-outcome&gt;
    &lt;/flow-return&gt;
    &lt;flow-return id="taskFlowReturnDone"&gt;
      &lt;from-outcome&gt;/done&lt;/from-outcome&gt;
    &lt;/flow-return&gt;
  &lt;/flow-definition&gt;    
&lt;/faces-config&gt;</pre></div><p>You can also place the<a id="id346" class="indexterm"/> following code inside the <code class="literal">faces-config.xml</code> file<a id="id347" class="indexterm"/> in the <code class="literal">&lt;faces-flow-definition&gt;</code> tag:</p><div class="informalexample"><pre class="programlisting">&lt;faces-flow-definition&gt;
  &lt;flow-definition id="registration"&gt;
  ...
&lt;/faces-flow-definition&gt;</pre></div><p>This example is wrapped into the application named <code class="literal">ch3_7_1</code> that is available in the code bundle of this chapter.</p></div><div class="section" title="Flows with beans"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Flows with beans</h2></div></div></div><p>Beside pages, a flow can<a id="id348" class="indexterm"/> contain beans. A bean defined in a flow is annotated with <code class="literal">@FlowScoped</code>; this is a CDI annotation that <a id="id349" class="indexterm"/>enables automatic activation (when the scope is entered) and passivation (when the scope is exited). The <code class="literal">@FlowScoped</code> bean requires an attribute named <code class="literal">value</code> that contains the flow ID. The data stored in such a bean is available in all pages that belong to that flow.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note56"/>Note</h3><p>The flow scope bean might get passivated by the container and should be capable of passivity by implementing the <code class="literal">java.io.Serializable</code> interface.</p></div></div><p>Adding a bean in the registration<a id="id350" class="indexterm"/> flow can modify the initial diagram, as shown in the following diagram:</p><div class="mediaobject"><img src="graphics/6466EN_03_10.jpg" alt="Flows with beans"/></div><p>As you can see, the bean will store<a id="id351" class="indexterm"/> the data collected from the registration form in the flow scope (in the previous example, this data was passed using the <code class="literal">flowScope</code> implicit object). The button labeled <span class="strong"><strong>Register To Tournament</strong></span> will call the <code class="literal">registrationAction</code> bean method, which will decide if the data is valid and return the flow back to the <code class="literal">registration.xhtml</code> page or next to the <code class="literal">confirm.xhtml</code> page.</p><p>The <code class="literal">registration.xhtml</code> page's code is modified as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:body&gt;
  &lt;h1&gt;&lt;b&gt;First page in the 'registration' flow&lt;/b&gt;&lt;/h1&gt;
  &lt;h1&gt;&lt;b&gt;In flow ? 
  #{null != facesContext.application.flowHandler.currentFlow}
  &lt;/b&gt;&lt;/h1&gt;&lt;br/&gt;&lt;br/&gt; 
  Your registration last credentials:
  #{registrationBean.playerName} #{registrationBean.playerSurname}
  &lt;h:form prependId="false"&gt;
    Name: &lt;h:inputText value="#{registrationBean.playerName}"/&gt;
    Surname: &lt;h:inputText value="#{registrationBean.playerSurname}"/&gt;
    &lt;h:commandButton value="Register To Tournament" action="#{registrationBean.registrationAction()}"/&gt; 
    &lt;h:commandButton value="Back (exit flow)" action="taskFlowReturnIndex"/&gt;  
  &lt;/h:form&gt;
&lt;/h:body&gt;</pre></div><p>The code<a id="id352" class="indexterm"/> of <code class="literal">RegistrationBean</code> is<a id="id353" class="indexterm"/> as follows:</p><div class="informalexample"><pre class="programlisting">@Named
@FlowScoped(value="registration")
public class RegistrationBean implements Serializable {

  private String playerName;
  private String playerSurname;

  ...
  //getters and setters
  ...
    
  public String getReturnValue() {
    return "/done";
  }
     
  public String registrationAction(){
        
    //simulate some registration conditions
    Random r= new Random();
    int nr = r.nextInt(10);
        
    if(nr &lt; 5){
      playerName="";
      playerSurname="";
      FacesContext.getCurrentInstance().addMessage("password",
      new FacesMessage(FacesMessage.SEVERITY_ERROR, "Registration failed!",""));
      return "registration";
    } else {
      return "confirm";
    }
  }
}</pre></div><p>The code is self explanatory,<a id="id354" class="indexterm"/> but what about the <code class="literal">getReturnValue</code> method? Well, this is just an example of how a flow scoped bean can indicate the outcome of a flow return. Instead of using the following code:</p><div class="informalexample"><pre class="programlisting">&lt;flow-return id="taskFlowReturnDone"&gt;
  &lt;from-outcome&gt;/done&lt;/from-outcome&gt;
&lt;/flow-return&gt;</pre></div><p>You can use the following code:</p><div class="informalexample"><pre class="programlisting">&lt;flow-return id="taskFlowReturnDone"&gt;
  &lt;from-outcome&gt;#{registrationBean.returnValue}&lt;/from-outcome&gt;
&lt;/flow-return&gt;</pre></div><p>This example is wrapped into<a id="id355" class="indexterm"/> the application named <code class="literal">ch3_7_2</code> that is available<a id="id356" class="indexterm"/> in the code bundle of this chapter.</p></div><div class="section" title="Nested flows"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Nested flows</h2></div></div></div><p>Well, now let's complicate things by adding another flow under the existing one. Let's suppose that after the registration, the<a id="id357" class="indexterm"/> player has to indicate the day and the hour when he is available to play the first match. This can be accomplished in a new flow<a id="id358" class="indexterm"/> named <code class="literal">schedule</code>. The <code class="literal">registration</code> flow will call the <code class="literal">schedule</code> flow and will pass some parameters to it. The <code class="literal">schedule</code> flow will return in the <code class="literal">registration</code> flow, which will provide a simple button for navigation outside the <code class="literal">registration</code> flow.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note57"/>Note</h3><p>The nested flow returns only in the calling flow. You have to refer to a page of the calling flow in the <code class="literal">&lt;flow-return&gt;</code> tag of the nested flow, including the pages returned by the calling flow.</p></div></div><p>Passing parameters is a thing that requires more tags in the configuration tag. Therefore, you need to know the following tags:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;flow-call&gt;</code>: This calls <a id="id359" class="indexterm"/>another flow in the current flow. This tag requires the <code class="literal">id</code> attribute. The value of this attribute will be used to refer to this flow call.</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;flow-reference&gt;</code>: This<a id="id360" class="indexterm"/> is nested in the <code class="literal">&lt;flow-call&gt;</code> tag and contains the ID of the flow that must be called.</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;outbound-parameter&gt;</code>: This is<a id="id361" class="indexterm"/> nested in the <code class="literal">&lt;flow-call&gt;</code> tag and defines parameters that must be passed to the called flow.</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;inbound-parameter&gt;</code>: This defines<a id="id362" class="indexterm"/> the parameters passed from another flow.</li></ul></div><p>In order to see these tags at work, you need to take a look at the application flow. The diagram of the application will change as follows:</p><div class="mediaobject"><img src="graphics/6466EN_03_11.jpg" alt="Nested flows"/></div><p>We resume our<a id="id363" class="indexterm"/> discussion from the <code class="literal">confirm.xhtml</code> page (defined in the <code class="literal">registration</code> flow). From this page, we want to navigate to the <code class="literal">schedule.xhtml</code> page, which is available in the <code class="literal">schedule</code> flow (the <code class="literal">schedule</code> folder). For this, we can add a new button, labeled <span class="strong"><strong>Schedule</strong></span>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:form prependId="false"&gt; 
  &lt;h:commandButton value="Back (still in flow)" action="registration"/&gt;
<span class="strong"><strong>  &lt;h:commandButton id="Next" value="Schedule" action="callSchedule" /&gt;            </strong></span>
  &lt;h:commandButton value="Next (exit flow)" action="taskFlowReturnDone"/&gt;
&lt;/h:form&gt;</pre></div><p>The button's <code class="literal">action</code> attribute<a id="id364" class="indexterm"/> value is the ID of the <code class="literal">&lt;flow-call&gt;</code> tag. When the button is clicked, JSF locates the corresponding <code class="literal">&lt;flow-call&gt;</code> tag and follows the flow with the ID indicated by the <code class="literal">&lt;flow-id&gt;</code> tag, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;flow-call id="callSchedule"&gt;
  &lt;flow-reference&gt;
    &lt;flow-id&gt;schedule&lt;/flow-id&gt;
  &lt;/flow-reference&gt;   
...
&lt;/flow-call&gt;</pre></div><p>Moreover, we want to pass several parameters from the <code class="literal">registration</code> flow to the <code class="literal">schedule</code> flow: the player name and surname (stored in the flow scoped <code class="literal">RegistrationBean</code> bean) and a constant representing some registration code (it can also be generated based on certain rules). This can be accomplished by the <code class="literal">&lt;outbound-parameter&gt;</code> tag, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;flow-call id="callSchedule"&gt;
  &lt;flow-reference&gt;
    &lt;flow-id&gt;schedule&lt;/flow-id&gt;
  &lt;/flow-reference&gt;   
<span class="strong"><strong>  &lt;outbound-parameter&gt;</strong></span>
<span class="strong"><strong>    &lt;name&gt;playernameparam&lt;/name&gt;</strong></span>
<span class="strong"><strong>    &lt;value&gt;#{registrationBean.playerName}&lt;/value&gt;</strong></span>
<span class="strong"><strong>  &lt;/outbound-parameter&gt;         </strong></span>
<span class="strong"><strong>  &lt;outbound-parameter&gt;</strong></span>
<span class="strong"><strong>    &lt;name&gt;playersurnameparam&lt;/name&gt;</strong></span>
<span class="strong"><strong>    &lt;value&gt;#{registrationBean.playerSurname}&lt;/value&gt;</strong></span>
<span class="strong"><strong>  &lt;/outbound-parameter&gt; </strong></span>
<span class="strong"><strong>  &lt;outbound-parameter&gt;</strong></span>
<span class="strong"><strong>    &lt;name&gt;playerregistrationcode&lt;/name&gt;</strong></span>
<span class="strong"><strong>    &lt;value&gt;349CF0YO122&lt;/value&gt;</strong></span>
<span class="strong"><strong>  &lt;/outbound-parameter&gt; </strong></span>
&lt;/flow-call&gt;</pre></div><p>The <code class="literal">schedule.xhtml</code> page displays <a id="id365" class="indexterm"/>a hello message based on the received parameters and a form that allows to the<a id="id366" class="indexterm"/> player to enter the day and hour when he is available for playing the first match, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:body&gt;
  &lt;h1&gt;&lt;b&gt;First page in the 'schedule' flow&lt;/b&gt;&lt;/h1&gt;
  &lt;h1&gt;&lt;b&gt;In flow ? 
  #{null != facesContext.application.flowHandler.currentFlow}
  &lt;/b&gt;&lt;/h1&gt;&lt;br/&gt;&lt;br/&gt; 
  Hello, #{flowScope.name} #{flowScope.surname} (#{scheduleBean.regcode})
  &lt;h:form prependId="false"&gt;
    Day: &lt;h:inputText value="#{scheduleBean.day}"/&gt;
    Starting At Hour: &lt;h:inputText value="#{scheduleBean.hourstart}"/&gt;     
    &lt;h:commandButton value="Save" action="success"/&gt;
  &lt;/h:form&gt;
&lt;/h:body&gt;</pre></div><p>Notice that the name and surname are obtained from the flow scope using the <code class="literal">flowScope</code> object, while the registration code is obtained from the flow scoped <code class="literal">ScheduleBean</code>; this bean stores the day, hour (received from the player), and registration code (received from the <code class="literal">registration</code> flow). Each piece of information received from the registration bean was guided to the place of storage using the <code class="literal">&lt;inbound-parameter&gt;</code> tag in the <code class="literal">schedule-flow.xml</code> file, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;flow-definition id="schedule"&gt;
  &lt;view id="schedule"&gt;
    &lt;vdl-document&gt;/schedule/schedule.xhtml&lt;/vdl-document&gt;
  &lt;/view&gt;   
    
<span class="strong"><strong>  &lt;inbound-parameter&gt;</strong></span>
<span class="strong"><strong>    &lt;name&gt;playernameparam&lt;/name&gt;</strong></span>
<span class="strong"><strong>    &lt;value&gt;#{flowScope.name}&lt;/value&gt;</strong></span>
<span class="strong"><strong>  &lt;/inbound-parameter&gt;</strong></span>
<span class="strong"><strong>  &lt;inbound-parameter&gt;</strong></span>
<span class="strong"><strong>    &lt;name&gt;playersurnameparam&lt;/name&gt;</strong></span>
<span class="strong"><strong>    &lt;value&gt;#{flowScope.surname}&lt;/value&gt;</strong></span>
<span class="strong"><strong>  &lt;/inbound-parameter&gt;                </strong></span>
<span class="strong"><strong>  &lt;inbound-parameter&gt;</strong></span>
<span class="strong"><strong>    &lt;name&gt;playerregistrationcode&lt;/name&gt;</strong></span>
<span class="strong"><strong>    &lt;value&gt;#{scheduleBean.regcode}&lt;/value&gt;</strong></span>
<span class="strong"><strong>  &lt;/inbound-parameter&gt;                         </strong></span>
&lt;/flow-definition&gt;</pre></div><p>After the day and hour are inserted, the <a id="id367" class="indexterm"/>button labeled <span class="strong"><strong>Save</strong></span> should save the data and navigate to the <code class="literal">success.xhtml</code> page, which is a simple page that displays all<a id="id368" class="indexterm"/> data provided by the player. From this page, we can return to the calling flow, <code class="literal">registration</code>, via a simple button labeled <span class="strong"><strong>Exit Registration</strong></span>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:body&gt;
  &lt;h1&gt;&lt;b&gt;Second page in the 'schedule' flow&lt;/b&gt;&lt;/h1&gt;
  &lt;h1&gt;&lt;b&gt;In flow ?
  #{null != facesContext.application.flowHandler.currentFlow}
  &lt;/b&gt;&lt;/h1&gt;&lt;br/&gt;&lt;br/&gt; 
  You are registered as
  #{flowScope.name} #{flowScope.surname} (#{scheduleBean.regcode})
  You will play first match 
  #{scheduleBean.day} after #{scheduleBean.hourstart} 
  &lt;h:button value="Exit Registration" outcome="taskFlowReturnThanks"/&gt;
&lt;/h:body&gt;</pre></div><p>The outcome, <code class="literal">taskFlowReturnThanks</code>, is defined in the <code class="literal">schedule-flow.xml</code> file as follows:</p><div class="informalexample"><pre class="programlisting">&lt;flow-return id="taskFlowReturnThanks"&gt;
  &lt;from-outcome&gt;/registration/thanks.xhtml&lt;/from-outcome&gt;
&lt;/flow-return&gt;</pre></div><p>The <code class="literal">thanks.xhtml</code> page is just a final step before the user exists from the <code class="literal">registration</code> flow, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:body&gt;       
  &lt;h1&gt;&lt;b&gt;Third page in the 'registration' flow&lt;/b&gt;&lt;/h1&gt;
  &lt;h1&gt;&lt;b&gt;In flow ? #{null != facesContext.application.flowHandler.currentFlow}&lt;/b&gt;&lt;/h1&gt;&lt;br/&gt;&lt;br/&gt;
  Thanks for your patience, Mr :#{registrationBean.playerName} 
  #{registrationBean.playerSurname}&lt;br/&gt;
  &lt;b&gt;We wish you beautiful games!&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;
  &lt;h:button value="Bye Bye, #{registrationBean.playerSurname}" outcome="taskFlowReturnDone"/&gt;
&lt;/h:body&gt;</pre></div><p>If you want to jump over the <code class="literal">thanks.xhtml</code> page, directly outside of both flows, then you can define the flow return, <code class="literal">taskFlowReturnThanks</code>, to point out the <code class="literal">done.xhtml</code> page, which is <a id="id369" class="indexterm"/>returned by the calling flow via the <code class="literal">taskFlowReturnDone</code> flow return. Therefore, we can use the following code:</p><div class="informalexample"><pre class="programlisting">&lt;flow-return id="taskFlowReturnThanks"&gt;          
  &lt;from-outcome&gt;taskFlowReturnDone&lt;/from-outcome&gt;
&lt;/flow-return&gt;</pre></div><p>This example is wrapped<a id="id370" class="indexterm"/> into the application named <code class="literal">ch3_7_3</code> that is available in the code bundle of this chapter.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note58"/>Note</h3><p>Flows can be configured declaratively or programmatically using the JSF 2.2 <code class="literal">FlowBuilder</code> API.</p></div></div></div><div class="section" title="Configuring flows programmatically"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Configuring flows programmatically</h2></div></div></div><p>In all the previous examples, you saw how to configure a flow using the declarative approach. But, flows can be<a id="id371" class="indexterm"/> configured programmatically also. The steps for configuring a flow programmatically are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a class and name it as the flow. This is more like a convention, not a requirement!</li><li class="listitem">In this class, write a method as shown in the following code; the <code class="literal">@FlowDefinition</code> annotation<a id="id372" class="indexterm"/> is a class-level annotation that allows the flow definition to be defined using the <code class="literal">FlowBuilder</code> API. The name of this method can be any valid name, but <code class="literal">defineFlow</code> is like a convention. So, the name <code class="literal">defineFlow</code> is not mandatory, and you can even define more flows in the same class as long as you have annotated them correctly.<div class="informalexample"><pre class="programlisting">@Produces
@FlowDefinition
public Flow defineFlow(@FlowBuilderParameter FlowBuilder flowBuilder) {
  ...
}</pre></div></li><li class="listitem">Use the <code class="literal">FlowBuilder</code> API to configure the flow.</li></ol></div><p>Using the <code class="literal">FlowBuilder</code> API<a id="id373" class="indexterm"/> is pretty straightforward and intuitive. For example, you can write the <code class="literal">registration-flow.xml</code> file programmatically, as follows:</p><div class="informalexample"><pre class="programlisting">public class Registration implements Serializable {        

  @Produces
  @FlowDefinition
  public Flow defineFlow(@FlowBuilderParameter FlowBuilder flowBuilder) {
        
    String flowId = "registration";
    flowBuilder.id("", flowId);
    flowBuilder.viewNode(flowId, "/" + flowId + "/" + flowId + ".xhtml").markAsStartNode();
    flowBuilder.viewNode("confirm-id", "/" + flowId + "/confirm.xhtml");
    flowBuilder.viewNode("thanks-id", "/" + flowId + "/thanks.xhtml");
    flowBuilder.returnNode("taskFlowReturnIndex").fromOutcome("/index");
    flowBuilder.returnNode("taskFlowReturnDone").fromOutcome("#{registrationBean.returnValue}");

    flowBuilder.flowCallNode("callSchedule").flowReference("", "schedule").outboundParameter("playernameparam", "#{registrationBean.playerName}"). outboundParameter("playersurnameparam", "#{registrationBean.playerSurname}").outboundParameter("playerregistrationcode", "349CF0YO122");

    return flowBuilder.getFlow();
  }
}</pre></div><p>As you can see, for <a id="id374" class="indexterm"/>each tag used in the declarative approach, there is a corresponding method in the <code class="literal">FlowBuilder</code> API. For example, the <code class="literal">flowBuilder.id</code> method accepts two arguments: the first one represents the document ID (usually, an empty space), and the second one represents the flow ID.</p><p>The <code class="literal">schedule-flow.xml</code> file can be programmatically<a id="id375" class="indexterm"/> translated as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public class Schedule implements Serializable {

  @Produces
  @FlowDefinition
  public Flow defineFlow(@FlowBuilderParameter FlowBuilder flowBuilder) {

    String flowId = "schedule";
    flowBuilder.id("", flowId);
    flowBuilder.viewNode(flowId, "/" + flowId + "/" + flowId + ".xhtml").markAsStartNode();
    flowBuilder.viewNode("success-id", "/" + flowId + "/success.xhtml");
    flowBuilder.returnNode("taskFlowReturnThanks").fromOutcome("/registration/thanks.xhtml");
 
    flowBuilder.inboundParameter("playernameparam", "#{flowScope.name}");
    flowBuilder.inboundParameter("playersurnameparam", "#{flowScope.surname}");
    flowBuilder.inboundParameter("playerregistrationcode", "#{scheduleBean.regcode}");             
                
    return flowBuilder.getFlow();
  }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note59"/>Note</h3><p>A method annotated with <code class="literal">@PostConstruct</code> will be called when the application enters into the current flow and the flow scoped bean is instantiated, while subsequent requests will use this instance until the flow is dumped. This is repeated if the application enters in this flow again. So, initializations specific to the current flow can be placed here.</p></div></div><p>This example is<a id="id376" class="indexterm"/> wrapped into the application named <code class="literal">ch3_7_5</code> that is available in the code bundle of this chapter.</p><p>Declarative and <a id="id377" class="indexterm"/>programmatic configurations can be mixed in the same application. For example, check the application named <code class="literal">ch3_7_4</code>, which uses programmatic configuration for the <code class="literal">registration</code> flow and declarative configuration for the <code class="literal">schedule</code> flow.</p></div><div class="section" title="Flows and navigation cases"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>Flows and navigation cases</h2></div></div></div><p>Navigation cases can be used<a id="id378" class="indexterm"/> for navigating inside flows. At this <a id="id379" class="indexterm"/>moment, when you click on the button labeled <span class="strong"><strong>Register To Tournament</strong></span>, the flow goes in the <code class="literal">confirm.xhtml</code> page based on implicit navigation. But we can easily exemplify an explicit navigation in the flow by replacing the value of the <code class="literal">action</code> attribute as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Register To Tournament" action="confirm_outcome"/&gt;</pre></div><p>Now, <code class="literal">confirm_outcome</code> cannot be automatically fetched to the <code class="literal">confirm.xhtml</code> page; therefore, in the <code class="literal">registration-flow.xml</code> file, we can add an explicit navigation case, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;navigation-rule&gt;
  &lt;from-view-id&gt;/registration/registration.xhtml&lt;/from-view-id&gt;
  &lt;navigation-case&gt;
    &lt;from-outcome&gt;confirm_outcome&lt;/from-outcome&gt;
    &lt;to-view-id&gt;/registration/confirm.xhtml&lt;/to-view-id&gt;
    &lt;redirect/&gt;           
  &lt;/navigation-case&gt; 
&lt;/navigation-rule&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note60"/>Note</h3><p>When you need to use a navigation case to enter in a flow, you will have to specify the <code class="literal">&lt;to-flow-document-id&gt;</code><span class="emphasis"><em>document_ID</em></span><code class="literal">&lt;/to-flow-document-id&gt;</code> statement nested in the <code class="literal">&lt;navigation-case&gt;</code> tag. If there is no document ID, that uses <code class="literal">&lt;to-flow-document-id/&gt;</code>. Moreover a <code class="literal">&lt;h:button&gt;</code> (or <code class="literal">&lt;h:link&gt;</code>) can be used to enter in such a flow, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:button id="..." value="<span class="emphasis"><em>enter flow</em></span>" outcome="<span class="emphasis"><em>flow</em></span>"&gt;
  &lt;f:attribute name="to-flow-document-id" value="unique"/&gt;
&lt;/h:button&gt;</pre></div><p>If you choose to write a programmatic navigation case, then JSF 2.2 comes with a method named, <code class="literal">getToFlowDocumentId</code>, which should be overridden for indicating the document ID.</p></div></div><p>At this point, everything<a id="id380" class="indexterm"/> comes to normal. Therefore, we can use <a id="id381" class="indexterm"/>explicit navigation cases for navigation between the flow's pages. The complete application is named <code class="literal">ch3_11_1</code>.</p><p>In order to accomplish the same thing in a programmatic fashion, you need to use the <code class="literal">NavigationCaseBuilder</code> API, as shown in the following code; this is the same navigation case, so we have used only the needed methods:</p><div class="informalexample"><pre class="programlisting">flowBuilder.navigationCase().fromViewId("/registration/registration.xhtml").fromOutcome("confirm_outcome").toViewId("/registration/confirm.xhtml").redirect();</pre></div><p>This example is wrapped in the complete application named <code class="literal">ch3_11_2</code>.</p><p>Moreover, you can even use a custom navigation handler. The<a id="id382" class="indexterm"/> new <code class="literal">NavigationHandlerWrapper</code> class (added in JSF 2.2) provides a simple implementation of the <code class="literal">NavigationHandler</code> class. Therefore, we can easily extend it to prove a navigation case using a custom navigation handler, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public class CustomNavigationHandler extends NavigationHandlerWrapper {

  private NavigationHandler configurableNavigationHandler;

  public CustomNavigationHandler() {}

  public CustomNavigationHandler(NavigationHandler configurableNavigationHandler){
    this.configurableNavigationHandler = configurableNavigationHandler;
  }

  @Override
  public void handleNavigation(FacesContext context, String fromAction, String outcome) {

    if (outcome.equals("confirm_outcome")) {
      outcome = "confirm";
    }

    getWrapped().handleNavigation(context, fromAction, outcome);
  }

  @Override
  public NavigationHandler getWrapped() {
    return configurableNavigationHandler;
  }
}</pre></div><p>Finally, a quick<a id="id383" class="indexterm"/> configuration<a id="id384" class="indexterm"/> in the <code class="literal">faces-config.xml</code> file is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;application&gt;        
  &lt;navigation-handler&gt;           
    book.beans.CustomNavigationHandler
  &lt;/navigation-handler&gt;        
&lt;/application&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note62"/>Note</h3><p>When the flow has a document ID, you need to override the <code class="literal">handleNavigation(FacesContext context, String fromAction, String outcome, String toFlowDocumentId)</code> method.</p></div></div><p>The complete<a id="id385" class="indexterm"/> application<a id="id386" class="indexterm"/> is named <code class="literal">ch3_11_3</code>.</p></div><div class="section" title="Inspecting flow navigation cases"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Inspecting flow navigation cases</h2></div></div></div><p>Whatever approach you choose for using navigation cases inside flows, you can always inspect them via the <code class="literal">ConfigurableNavigationHandler.inspectFlow</code> method. This method is invoked by<a id="id387" class="indexterm"/> the flow system to cause the flow to be inspected for navigation rules. You can easily override <a id="id388" class="indexterm"/>it to obtain information about navigation cases, by writing a custom <a id="id389" class="indexterm"/>configurable navigation handler. The easiest way to accomplish this is to extend the new <code class="literal">ConfigurableNavigationHandlerWrapper</code> class (introduced in JSF 2.2), which represents a simple<a id="id390" class="indexterm"/> implementation of <code class="literal">ConfigurableNavigationHandler</code>. For example, the following snippet of code sends in log information about each found navigation case:</p><div class="informalexample"><pre class="programlisting">public class CustomConfigurableNavigationHandler extends ConfigurableNavigationHandlerWrapper {

  private final static Logger logger = Logger.getLogger(CustomConfigurableNavigationHandler.class.getName());
  private ConfigurableNavigationHandler configurableNavigationHandler;

  public CustomConfigurableNavigationHandler() {}

  public CustomConfigurableNavigationHandler(ConfigurableNavigationHandler configurableNavigationHandler){
    this.configurableNavigationHandler = configurableNavigationHandler;
  }

  @Override
  public void inspectFlow(FacesContext context, Flow flow) {
    getWrapped().inspectFlow(context, flow);
    if (flow.getNavigationCases().size() &gt; 0) {
      Map&lt;String, Set&lt;NavigationCase&gt;&gt; navigationCases = flow.getNavigationCases();
      for (Map.Entry&lt;String, Set&lt;NavigationCase&gt;&gt; entry : navigationCases.entrySet()) {
        logger.log(Level.INFO, "Navigation case: {0}", entry.getKey());
        for (NavigationCase nc : entry.getValue()) {
          logger.log(Level.INFO, "From view id: {0}", nc.getFromViewId());
          logger.log(Level.INFO, "From outcome: {0}", nc.getFromOutcome());
          logger.log(Level.INFO, "To view id: {0}", nc.getToViewId(context));
          logger.log(Level.INFO, "Redirect: {0}", nc.isRedirect());
        }
      }
    }
  }

  @Override
  public ConfigurableNavigationHandler getWrapped() {
    return configurableNavigationHandler;
  }
}</pre></div><p>If you attach this<a id="id391" class="indexterm"/> custom configurable navigation handler<a id="id392" class="indexterm"/> to one of the preceding three examples, then you will get information about the presented navigation case. The complete example is named <code class="literal">ch3_15</code>.</p></div><div class="section" title="Using the initializer and finalizer"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Using the initializer and finalizer</h2></div></div></div><p>By using the <code class="literal">FlowBuilder</code> API, we can attach callback methods that will be automatically<a id="id393" class="indexterm"/> called when a flow<a id="id394" class="indexterm"/> is created and right before it is destroyed. The <code class="literal">FlowBuilder.initializer</code> method has the following signatures, which are<a id="id395" class="indexterm"/> called when the<a id="id396" class="indexterm"/> flow is created:</p><div class="informalexample"><pre class="programlisting">public abstract FlowBuilder initializer(String methodExpression)
public abstract FlowBuilder initializer(javax.el.MethodExpression methodExpression)</pre></div><p>The <code class="literal">FlowBuilder.finalizer</code> signature is<a id="id397" class="indexterm"/> called <a id="id398" class="indexterm"/>before the flow is destroyed, as follows:</p><div class="informalexample"><pre class="programlisting">public abstract FlowBuilder finalizer(String methodExpression)
public abstract FlowBuilder finalizer(javax.el.MethodExpression methodExpression)</pre></div><p>For example, the <code class="literal">initializer</code> method can be used to pass external parameters into a flow. Let's suppose that in the <code class="literal">index.xhtml</code> page (outside the flow), when we click on the button labeled <span class="strong"><strong>Start Registration</strong></span>, we want to pass the tournament name and place into the flow, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:form prependId="false"&gt;
  &lt;h:inputHidden id="tournamentNameId" value="Roland Garros"/&gt;
  &lt;h:inputHidden id="tournamentPlaceId" value="France"/&gt;
  &lt;h:commandButton value="Start Registration" action="registration"/&gt;
&lt;/h:form&gt;</pre></div><p>These two parameters must be available when the flow starts, because the wrapped information is<a id="id399" class="indexterm"/> displayed in the <code class="literal">registration.xhml</code> page (the start node of the flow) via two properties from <code class="literal">RegistrationBean</code>, namely <code class="literal">tournamentName</code> and <code class="literal">tournamentPlace</code>. For this, we need to call a method from <code class="literal">RegistrationBean</code> capable of extracting this information and store it in these two properties, as<a id="id400" class="indexterm"/> shown in the following code:</p><div class="informalexample"><pre class="programlisting">//initializer method
public void tournamentInitialize() {
  tournamentName = FacesContext.getCurrentInstance().getExternalContext().getRequestParameterMap().get("tournamentNameId");
  tournamentPlace = FacesContext.getCurrentInstance().getExternalContext().getRequestParameterMap().get("tournamentPlaceId");
}</pre></div><p>Now is the interesting part, because<a id="id401" class="indexterm"/> we can use the <code class="literal">initializer</code> method to<a id="id402" class="indexterm"/> indicate the <code class="literal">tournamentInitialize</code> method<a id="id403" class="indexterm"/> as the callback method that should be invoked when the flow is created. This can be done in the <code class="literal">registration-flow.xml</code> file as follows:</p><div class="informalexample"><pre class="programlisting">&lt;initializer&gt;
  #{registrationBean.tournamentInitialize()}
&lt;/initializer&gt;</pre></div><p>So, at this moment, we can use the tournament name and place right from the beginning of the flow and during the flow's lifespan.</p><p>Going further, another simple scenario can be the justification for using a <code class="literal">finalizer</code> method. Let's suppose that we count the registered players via an application scoped bean named <code class="literal">PlayersCounterBean</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@Named
@ApplicationScoped
public class PlayersCounterBean {

  private int count = 0;

  public int getCount() {
    return count;
  }

  public void addPlayer() {
    count++;
  }
}</pre></div><p>The <code class="literal">count</code> variable should<a id="id404" class="indexterm"/> be increased when the player exits the flow, and the registration is successfully done; therefore, we can place a <code class="literal">finalizer</code> method in the <code class="literal">registration-flow.xml</code> file as follows:</p><div class="informalexample"><pre class="programlisting">&lt;finalizer&gt;
  #{registrationBean.tournamentFinalize()}
&lt;/finalizer&gt;</pre></div><p>The <code class="literal">tournamentFinalize</code> method is implemented<a id="id405" class="indexterm"/> in <code class="literal">RegistrationBean</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@Named
@FlowScoped(value = "registration")
public class RegistrationBean {

  @Inject
  private PlayersCounterBean playersCounterBean;
  ...
  //finalizer method
  public void tournamentFinalize() {
    playersCounterBean.addPlayer();
  }
}</pre></div><p>Since the <code class="literal">PlayersCounterBean</code> is an <a id="id406" class="indexterm"/>application bean, we can use its goodies outside the flow. The <a id="id407" class="indexterm"/>complete application is named <code class="literal">ch3_12_1</code>.</p><p>The same output can<a id="id408" class="indexterm"/> be programmatically achieved using the following code:</p><div class="informalexample"><pre class="programlisting">flowBuilder.initializer("#{registrationBean.tournamentInitialize(param['tournamentNameId'], param['tournamentPlaceId'])}");
flowBuilder.finalizer("#{registrationBean.tournamentFinalize()}");</pre></div><p>For the sake of variation, in this case we didn't extract the parameter values using the request parameter <code class="literal">Map</code>. We preferred to use the implicit object <code class="literal">param</code> and to pass the values as arguments<a id="id409" class="indexterm"/> of the <code class="literal">tournamentInitialize</code> method as follows:</p><div class="informalexample"><pre class="programlisting">//initializer method
public void tournamentInitialize(String tn, String tp) {
  tournamentName = tn;
  tournamentPlace = tp;
}</pre></div><p>The complete<a id="id410" class="indexterm"/> application is named <code class="literal">ch3_12_2</code>.</p></div><div class="section" title="Using the flow switch"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Using the flow switch</h2></div></div></div><p>The <code class="literal">switch</code> case statements are a<a id="id411" class="indexterm"/> substitute for long <code class="literal">if</code> statements and are useful to do conditional outcome mapping. In order to see it at work, we can suppose that for<a id="id412" class="indexterm"/> each tournament we have a separate <code class="literal">confirm.xhtml</code> page. Let's have the four grand slams in tennis and the associated XHTML confirmation pages, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Roland Garros and <code class="literal">confirm_rg.xhtml</code></li><li class="listitem" style="list-style-type: disc">Wimbledon and <code class="literal">confirm_wb.xhtml</code></li><li class="listitem" style="list-style-type: disc">US Open and <code class="literal">confirm_us.xhtml</code></li><li class="listitem" style="list-style-type: disc">Australian Open and <code class="literal">confirm_ao.xhtml</code></li></ul></div><p>The name and place of the tournament are passed in the flow via a simple form (one form per tournament), as follows (you already know from the preceding section how this information may be obtained inside the flow):</p><div class="informalexample"><pre class="programlisting">&lt;h:form prependId="false"&gt;
  &lt;h:inputHidden id="tournamentNameId" value="Australian Open"/&gt;
  &lt;h:inputHidden id="tournamentPlaceId" value="Australia"/&gt;
  &lt;h:commandButton value="Start Registration (Australian Open)" action="registration"/&gt;
&lt;/h:form&gt;</pre></div><p>Now, after clicking on the button labeled <span class="strong"><strong>Register To...</strong></span>, we need to choose the right confirmation page. For this, we can use a programmatic switch, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public class Registration implements Serializable {

  @Produces
  @FlowDefinition
  public Flow defineFlow(@FlowBuilderParameter FlowBuilder flowBuilder) {

    String flowId = "registration";
    flowBuilder.id("", flowId);
    flowBuilder.viewNode(flowId, "/" + flowId + "/" + flowId + ".xhtml").markAsStartNode();
    flowBuilder.viewNode("no-tournament-id", "/" + flowId + "/notournament.xhtml");
    flowBuilder.viewNode("confirm-rg-id", "/" + flowId + "/confirm_rg.xhtml");
    flowBuilder.viewNode("confirm-wb-id", "/" + flowId + "/confirm_wb.xhtml");
    flowBuilder.viewNode("confirm-us-id", "/" + flowId + "/confirm_us.xhtml");
    flowBuilder.viewNode("confirm-ao-id", "/" + flowId + "/confirm_ao.xhtml");
    flowBuilder.returnNode("taskFlowReturnDone").fromOutcome("#{registrationBean.returnValue}");

    flowBuilder.switchNode("confirm-switch-id").defaultOutcome("no-tournament-id").switchCase().condition("#{registrationBean.tournamentName eq 'Roland Garros'}").fromOutcome("confirm-rg-id").condition("#{registrationBean.tournamentName eq 'Wimbledon'}").fromOutcome("confirm-wb-id").condition("#{registrationBean.tournamentName eq 'US Open'}").fromOutcome("confirm-us-id").condition("#{registrationBean.tournamentName eq 'Australian Open'}").fromOutcome("confirm-ao-id");
    flowBuilder.initializer("#{registrationBean.tournamentInitialize(param['tournamentNameId'],param['tournamentPlaceId'])}");
    flowBuilder.finalizer("#{registrationBean.tournamentFinalize()}");

    return flowBuilder.getFlow();
  }
}</pre></div><p>Notice that when no <a id="id413" class="indexterm"/>condition is evaluated to <code class="literal">true</code>, the selected node will be the <code class="literal">notournament.xhtml</code> page, which represents the default outcome. This is just a<a id="id414" class="indexterm"/> simple XHMTL page containing some specific text.</p><p>The complete application is named <code class="literal">ch3_13</code>. Declaratively, this can be achieved in the <code class="literal">registration-flow.xml</code> file as shown in the following code. You can use <code class="literal">&lt;view&gt;</code> tags to hide the outcome's path behind some IDs (map outcomes to pages), as we saw in the programmatic example:</p><div class="informalexample"><pre class="programlisting">&lt;switch id="confirm-switch-id"&gt;
  &lt;default-outcome&gt;
    /registration/notournament.xhtml
  &lt;/default-outcome&gt;
  &lt;case&gt;
    &lt;if&gt;#{registrationBean.tournamentName eq 'Roland Garros'}&lt;/if&gt;
    &lt;from-outcome&gt;/registration/confirm_rg.xhtml&lt;/from-outcome&gt;
  &lt;/case&gt;
  &lt;case&gt;
    &lt;if&gt;#{registrationBean.tournamentName eq 'Wimbledon'}&lt;/if&gt;
    &lt;from-outcome&gt;/registration/confirm_wb.xhtml&lt;/from-outcome&gt;
  &lt;/case&gt;
  &lt;case&gt;
    &lt;if&gt;#{registrationBean.tournamentName eq 'US Open'}&lt;/if&gt;
    &lt;from-outcome&gt;/registration/confirm_us.xhtml&lt;/from-outcome&gt;
  &lt;/case&gt;
  &lt;case&gt;
    &lt;if&gt;#{registrationBean.tournamentName eq 'Australian Open'}&lt;/if&gt;
    &lt;from-outcome&gt;/registration/confirm_ao.xhtml&lt;/from-outcome&gt;
  &lt;/case&gt;
&lt;/switch&gt;</pre></div><p>So, switch can be useful when <a id="id415" class="indexterm"/>you don't want to map each outcome<a id="id416" class="indexterm"/> to a single page.</p><p>This example wasn't wrapped in a complete application.</p></div><div class="section" title="Packaging flows"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Packaging flows</h2></div></div></div><p>Flows act as logical units of work; therefore, they are portable across multiple applications. The portability<a id="id417" class="indexterm"/> is obtained by packaging the flow artifacts in a JAR file. Further, the JAR file can be added in any application <code class="literal">CLASSPATH</code> and the flow is ready to be used. To package a flow, you need to follow some conventions, which are listed as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Explicitly define the flows in the <code class="literal">faces-config.xml</code> file.</li><li class="listitem">In the JAR root, create a <code class="literal">META-INF</code> folder.</li><li class="listitem">Add the <code class="literal">faces-config.xml</code> file in this folder.</li><li class="listitem">Add the <code class="literal">beans.xml</code> file in this folder.</li><li class="listitem">In the same folder, <code class="literal">META-INF</code>, create a subfolder named <code class="literal">flows</code>.</li><li class="listitem">In the <code class="literal">flows</code> folder, add all nodes (pages) of the flow.</li><li class="listitem">In the JAR root, outside the <code class="literal">META-INF</code> folder, add all the Java code (classes) needed by the flow.</li></ol></div><p>Based on the preceding steps, the flow described in the <span class="emphasis"><em>Flows with beans</em></span> section can be packaged in a JAR file named <code class="literal">registration.jar</code>, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_03_12.jpg" alt="Packaging flows"/></div><p>The complete <a id="id418" class="indexterm"/>application that uses this JAR file is named <code class="literal">ch3_14</code>.</p></div><div class="section" title="Programmatic flow scope"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec47"/>Programmatic flow scope</h2></div></div></div><p>Programmatically speaking, the flow scope can be accessed via the <code class="literal">javax.faces.flow.FlowHandler</code> class. After obtaining a <code class="literal">FlowHandler</code> class's object, you can easily access the<a id="id419" class="indexterm"/> current flow, add a new flow, and <a id="id420" class="indexterm"/>manipulate the flow map represented by <code class="literal">#{flowScope}</code>, as follows:</p><div class="informalexample"><pre class="programlisting">FacesContext context = FacesContext.getCurrentInstance();
Application application = context.getApplication();
FlowHandler flowHandler = application.getFlowHandler();

//get current flow
Flow flow = flowHandler.getCurrentFlow();
Flow flowContext = flowHandler.getCurrentFlow(context);     

//add flow
flowHandler.addFlow(context, <span class="emphasis"><em>flow</em></span>);

//get access to the Map that backs #{flowScope}
Map&lt;Object,Object&gt; flowMap = flowHandler.getCurrentFlowScope();  </pre></div><p>Obviously, the <code class="literal">FlowHandler</code> class is the most important class involved in the interaction between runtime and the faces flow feature. This is an abstract class that can be extended to provide a custom flow handler implementation. In order to do that, you can start by creating a new <code class="literal">FlowHandlerFactory</code> class, which is used by the <code class="literal">Application</code> class to create the singleton instance of the <code class="literal">FlowHandler</code> class. This class has a simple implementation named <code class="literal">FlowHandlerFactoryWrapper</code>, which can be easily extended to return a custom flow handler, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public class CustomFlowHandlerFactory extends FlowHandlerFactoryWrapper {

  private FlowHandlerFactory flowHandlerFactory;
    
  public CustomFlowHandlerFactory(){}
    
  public CustomFlowHandlerFactory(FlowHandlerFactory flowHandlerFactory){
    this.flowHandlerFactory = flowHandlerFactory;
  }
    
  @Override
  public FlowHandler createFlowHandler(FacesContext context){
    FlowHandler customFlowHandler = new CustomFlowHandler(getWrapped().createFlowHandler(context));
    return customFlowHandler;
  }
    
  @Override
  public FlowHandlerFactory getWrapped() {
    return this.flowHandlerFactory;
  }    
}</pre></div><p>This factory should<a id="id421" class="indexterm"/> be configured in the <code class="literal">faces-config.xml</code> file, as shown<a id="id422" class="indexterm"/> in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;factory&gt;
  &lt;flow-handler-factory&gt;
    book.beans.CustomFlowHandlerFactory
  &lt;/flow-handler-factory&gt;
&lt;/factory&gt;</pre></div><p>Further, the <code class="literal">CustomFlowHandler</code> class represents an extension of the <code class="literal">FlowHandler</code> class. Since the <code class="literal">FlowHandler</code> class is an abstract class, you need to provide an implementation for each of its methods, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public class CustomFlowHandler extends FlowHandler {

  private FlowHandler flowHandler;

  public CustomFlowHandler() {}

  public CustomFlowHandler(FlowHandler flowHandler) {
    this.flowHandler = flowHandler;
  }

  ...
  //Overrided methods
  ...

}</pre></div><p>For example, you know from the previous sections that the <code class="literal">registration</code> flow passed several outbound parameters to the nested <code class="literal">schedule</code> flow. You saw how to accomplish that declaratively, in the <code class="literal">registration-flow.xml</code> file, and programmatically, via the <code class="literal">FlowBuilder</code> API, in the <code class="literal">Registration</code> class. You can do the same thing from a custom flow handler in<a id="id423" class="indexterm"/> the method named, <code class="literal">transition</code>, which is <a id="id424" class="indexterm"/>capable to perform a transition between a source flow (for example, <code class="literal">registration</code>) and a target flow (for example, <code class="literal">schedule</code>). When the <code class="literal">registration</code> flow calls the <code class="literal">schedule</code> flow, you can write the following code:</p><div class="informalexample"><pre class="programlisting">@Override
public void transition(FacesContext context, Flow sourceFlow, Flow targetFlow, FlowCallNode outboundCallNode, String toViewId) {
  if ((sourceFlow != null) &amp;&amp; (targetFlow != null)) {
    if ((sourceFlow.getStartNodeId().equals("registration")) &amp;&amp; 
      (targetFlow.getStartNodeId().equals("schedule"))) {
    
      FlowCallNode flowCallNode = sourceFlow.getFlowCalls().get("callSchedule");
      Map&lt;String, Parameter&gt; outboundParameters = flowCallNode.getOutboundParameters();

      CustomParameter playernameparamO = new CustomParameter("playernameparam", "#{registrationBean.playerName}");
      CustomParameter playersurnameparamO = new CustomParameter("playersurnameparam", "#{registrationBean.playerSurname}");
      CustomParameter playerregistrationcodeO = new CustomParameter("playerregistrationcode","349CF0YO122");

      outboundParameters.put("playernameparam", playernameparamO);
      outboundParameters.put("playersurnameparam", playersurnameparamO);
      outboundParameters.put("playerregistrationcode", playerregistrationcodeO);
    }
  }
  flowHandler.transition(context, sourceFlow, targetFlow, outboundCallNode, toViewId);
}</pre></div><p>The target inbound<a id="id425" class="indexterm"/> parameters can be accessed as<a id="id426" class="indexterm"/> follows (the <code class="literal">Map</code> parameter cannot be altered):</p><div class="informalexample"><pre class="programlisting">Map&lt;String, Parameter&gt; inboundParameters = targetFlow.getInboundParameters();</pre></div><p>Flow parameters<a id="id427" class="indexterm"/> are represented by the <code class="literal">javax.faces.flow.Parameter</code> abstract class. The <code class="literal">CustomParameter</code> class provides an implementation<a id="id428" class="indexterm"/> as follows:</p><div class="informalexample"><pre class="programlisting">public class CustomParameter extends Parameter {

  private String name;
  private String value;

  public CustomParameter(String name, String value) {
    this.name = name;
    this.value = value;
  }

  @Override
  public String getName() {
    return name;
  }

  @Override
  public ValueExpression getValue() {
    return createValueExpression(value, String.class);
  }

  private ValueExpression createValueExpression(String exp, Class&lt;?&gt; cls) {
    FacesContext facesContext = FacesContext.getCurrentInstance();
    ELContext elContext = facesContext.getELContext();
    return facesContext.getApplication().getExpressionFactory().
    createValueExpression(elContext, exp, cls);
  }
}</pre></div></div></div>
<div class="section" title="Dependent pseudo-scope"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Dependent pseudo-scope</h1></div></div></div><p>This is the <a id="id429" class="indexterm"/>default<a id="id430" class="indexterm"/> scope of a CDI bean (<code class="literal">@Named</code>) when nothing is specified. In this case, an object exists to serve exactly one bean and has the same life cycle as that bean; an instance<a id="id431" class="indexterm"/> of a dependent scoped bean is not shared between different users or different points of injection. It can also be explicitly specified by annotating the bean with the <code class="literal">@Dependent</code> annotation and importing <code class="literal">javax.enterprise.context.Dependent</code>. This scope is available only in CDI and is the only <span class="strong"><strong>non-contextual</strong></span> scope.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note63"/>Note</h3><p>All CDI scopes, except this one, are known as<a id="id432" class="indexterm"/> <span class="strong"><strong>normal</strong></span> scopes. More details about normal scopes versus pseudo-scopes can be found in the <span class="emphasis"><em>Normal scopes and pseudo-scopes</em></span> section at <a class="ulink" href="http://docs.jboss.org/cdi/spec/1.0/html/contexts.html">http://docs.jboss.org/cdi/spec/1.0/html/contexts.html</a>.</p></div></div><p>If you put the <code class="literal">PlayersBean</code> in the<a id="id433" class="indexterm"/> dependent scope, then the current extracted player and the list of randomly extracted players (which will be empty or will contain this player) is available only inside the bean, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">import javax.enterprise.context.Dependent;
import javax.inject.Named;

@Named
@Dependent
public class PlayersBean {
  ...
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note64"/>Note</h3><p>A method annotated with <code class="literal">@PostConstruct</code> will be called for each request. Actually, it might be called multiple times during the same request, if the bean is used in several EL expressions. Initially, there is one instance of the bean, and this instance is reused if the bean EL name appears multiple times in the EL expression, but is not reused in the case of another EL expression or in the case of a re-evaluation of the same EL expression.</p></div></div><p>This example is<a id="id434" class="indexterm"/> wrapped into the application named <code class="literal">ch3_5</code> that is available in the code bundle of this chapter.</p></div>
<div class="section" title="The none scope"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>The none scope</h1></div></div></div><p>The <span class="strong"><strong>none scoped</strong></span> beans<a id="id435" class="indexterm"/> lives to serve other beans.</p><p>The none scope<a id="id436" class="indexterm"/> seems to be the black sheep of JSF scopes. Even its name doesn't inspire something useful. Practically, a managed bean in this scope lives as long as a single EL expression evaluation and is not visible in any JSF page. If the application scope lives the longest, this scope lives the shortest. But, if you inject the none scoped managed beans in other managed beans, then they will live as long as their hosts. Actually, this is their job, to serve other beans.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note65"/>Note</h3><p>The none scoped objects used in the configuration file indicate managed beans that are used by other managed beans in the application.</p></div></div><p>So, whenever you need a humble managed bean that is ready to be a part of a cool scope, such as a request or a session, you can annotate it with <code class="literal">@NoneScoped</code>, available in the <code class="literal">javax.faces.bean</code> package. Moreover, objects with the none scope can use other objects with the none scope.</p></div>
<div class="section" title="The custom scope"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>The custom scope</h1></div></div></div><p>When none of the previous scopes<a id="id437" class="indexterm"/> meet your application needs, you have to pay attention to the JSF 2 custom scope. Most likely, you will never want to write a custom scope, but if it is necessary, then, in this section, you can see how to accomplish this task.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note66"/>Note</h3><p>The custom scope annotation is <code class="literal">@CustomScoped</code> and is defined in the <code class="literal">javax.faces.bean</code> package. It is not available in CDI!</p></div></div><p>In order to implement a<a id="id438" class="indexterm"/> custom scope, let's suppose that you want to control the life cycle of several beans that live in the application scope. Normally they live as long as the application lives, but you want to be able to add/remove them from the application scope at certain moments of the application flow. Of course, there are many approaches to do that, but remember that we look for a reason to implement a custom scope; therefore, we will try to write a custom scope nested in the application scope that will allow us to add/remove a batch of beans. Creating and destroying the scope itself will be reflected in creating and destroying the beans, which means that you don't need to refer to each bean.</p><p>Actually, since this is just a demo, we will use only two beans: one will stay in the classical application scope (it can be useful for comparison of the application and custom scope lifespan), while the other one will be added/destroyed through the custom scope. The application purpose<a id="id439" class="indexterm"/> is not relevant; you should focus on the technique used to write a custom scope and paper over the assumptions and gaps. Think more on the lines that you can use this knowledge when you really need to implement a custom scope.</p><div class="section" title="Writing the custom scope class"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec48"/>Writing the custom scope class</h2></div></div></div><p>The custom scope is<a id="id440" class="indexterm"/> represented by a class that extends the <code class="literal">ConcurrentHashMap&lt;String, Object&gt;</code> class. We need to allow concurrent access to an usual map because the exposed data may be accessed concurrently from multiple browsers. The code of the <code class="literal">CustomScope</code> class is as follows:</p><div class="informalexample"><pre class="programlisting">public class CustomScope extends ConcurrentHashMap&lt;String, Object&gt; {
    
  public static final String SCOPE = "CUSTOM_SCOPE";

  public CustomScope(){
    super();
  }
 
  public void scopeCreated(final FacesContext ctx) {
 
    ScopeContext context = new ScopeContext(SCOPE, this);
    ctx.getApplication().publishEvent(ctx, PostConstructCustomScopeEvent.class, context);
    }
 
  public void scopeDestroyed(final FacesContext ctx) {
 
    ScopeContext context = new ScopeContext(SCOPE,this);
    ctx.getApplication().publishEvent(ctx, PreDestroyCustomScopeEvent.class, context);
  } 
}</pre></div><p>When our scope is created/destroyed, other components will be informed through events. In the <code class="literal">scopeCreated</code> method, you register <code class="literal">PostConstructCustomScopeEvent</code>, while in the <code class="literal">scopeDestroyed</code> method, you register <code class="literal">PreDestroyCustomScopeEvent</code>.</p><p>Now we have a custom scope, it is time to see how to declare a bean in this scope. Well, this is not hard and <a id="id441" class="indexterm"/>can be done with the <code class="literal">@CustomScoped</code> annotations and an EL expression, as follows:</p><div class="informalexample"><pre class="programlisting">import javax.faces.bean.CustomScoped;
import javax.faces.bean.ManagedBean;

@ManagedBean
@CustomScoped("#{CUSTOM_SCOPE}")
public class SponsoredLinksBean {
  ...
}</pre></div></div><div class="section" title="Resolving a custom scope EL expression"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec49"/>Resolving a custom scope EL expression</h2></div></div></div><p>At this point, JSF will<a id="id442" class="indexterm"/> iterate over the chain of existing resolvers in order to resolve the custom scope EL expression. Obviously, this attempt <a id="id443" class="indexterm"/>will end with an error, since no existing resolver will be able to satisfy this EL expression. So, you need to write a custom resolver as you saw in <a class="link" href="ch01.html" title="Chapter 1. Dynamic Access to JSF Application Data through Expression Language (EL 3.0)">Chapter 1</a>, <span class="emphasis"><em>Dynamic Access to JSF Application Data through Expression Language (EL 3.0)</em></span>. Based on that, you should obtain something as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public class CustomScopeResolver extends ELResolver {

  private static final Logger logger = Logger.getLogger(CustomScopeResolver.class.getName());

  @Override
  public Object getValue(ELContext context, Object base, Object property) {

    logger.log(Level.INFO, "Get Value property : {0}", property);

    if (property == null) {
      String message = MessageUtils.getExceptionMessageString(MessageUtils.NULL_PARAMETERS_ERROR_MESSAGE_ID, "property");
      throw new PropertyNotFoundException(message);
    }

    FacesContext facesContext = (FacesContext) context.getContext(FacesContext.class);

    if (base == null) {
      Map&lt;String, Object&gt; applicationMap = facesContext.getExternalContext().getApplicationMap();
      CustomScope scope = (CustomScope) applicationMap.get(CustomScope.SCOPE);

      if (CustomScope.SCOPE.equals(property)) {
        logger.log(Level.INFO, "Found request | base={0} property={1}", new Object[]{base, property});
        context.setPropertyResolved(true);
        return scope;
      } else {
        logger.log(Level.INFO, "Search request | base={0} property={1}", new Object[]{base, property});
        if (scope != null) {
          Object value = scope.get(property.toString());
          if (value != null) {
            logger.log(Level.INFO, "Found request | base={0} property={1}", new Object[]{base, property});
            context.setPropertyResolved(true);
          }else {
            logger.log(Level.INFO, "Not found request | base={0} property={1}", new Object[]{base, property});
            context.setPropertyResolved(false);
          }
          return value;
        } else {
          return null;
        }
      }
    }

      if (base instanceof CustomScope) {

        CustomScope baseCustomScope = (CustomScope) base;
          Object value = baseCustomScope.get(property.toString());
        logger.log(Level.INFO, "Search request | base={0} property={1}", new Object[]{base, property});

        if (value != null) {
          logger.log(Level.INFO, "Found request | base={0} property={1}", new Object[]{base, property});
          context.setPropertyResolved(true);
        } else {
          logger.log(Level.INFO, "Not found request | base={0} property={1}", new Object[]{base, property});
          context.setPropertyResolved(false);
        }

      return value;
    }

    return null;
  }

  @Override
  public Class&lt;?&gt; getType(ELContext context, Object base, Object property) {
    return Object.class;
  }

  @Override
  public void setValue(ELContext context, Object base, Object property, Object value) {

    if (base != null) {
      return;
    }

    context.setPropertyResolved(false);

    if (property == null) {
      String message = MessageUtils.getExceptionMessageString(MessageUtils.NULL_PARAMETERS_ERROR_MESSAGE_ID, "property");
      throw new PropertyNotFoundException(message);
    }

    if (CustomScope.SCOPE.equals(property)) {
      throw new PropertyNotWritableException((String) property);
    }
  }

  @Override
  public boolean isReadOnly(ELContext context, Object base, Object property) {
    return true;
  }

  @Override
  public Iterator&lt;FeatureDescriptor&gt; getFeatureDescriptors(ELContext context, Object base) {
    return null;
  }

  @Override
  public Class&lt;?&gt; getCommonPropertyType(ELContext context, Object base) {
    if (base != null) {
      return null;
    }
    return String.class;
  }
}</pre></div><p>Do not forget to put the following resolver into the chain by adding it in the <code class="literal">faces-config.xml</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;el-resolver&gt;book.beans.CustomScopeResolver&lt;/el-resolver&gt;</pre></div><p>Done! So far, you have created a custom scope, you put a bean into this scope, and learned that the brand new resolver provides access to this bean.</p><p>The custom scope<a id="id444" class="indexterm"/> must be stored somewhere, so <a id="id445" class="indexterm"/>nested in the application scope can be a choice (of course, other scopes can also be a choice, depending on your needs). When the scope is created, it has to be placed in the application map, and when it is destroyed, it has to be removed from the application map. The question is when to create it and when to destroy it? And the answer is, <span class="emphasis"><em>it depends</em></span>. Most likely, this is a decision strongly tied to the application flow.</p></div><div class="section" title="Controlling the custom scope lifespan with action listeners"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec50"/>Controlling the custom scope lifespan with action listeners</h2></div></div></div><p>Using action listeners can be<a id="id446" class="indexterm"/> a good practice even if it involves<a id="id447" class="indexterm"/> control from view declaration. Let's suppose that the button labeled <span class="strong"><strong>START</strong></span> will add the custom scope in the application map, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="START"&gt;
  &lt;f:actionListener type="book.beans.CreateCustomScope" /&gt;
&lt;/h:commandButton&gt;</pre></div><p>The following <code class="literal">CreateCustomScope</code> class is a <a id="id448" class="indexterm"/>straightforward action listener as it implements the <code class="literal">ActionListener</code> interface:</p><div class="informalexample"><pre class="programlisting">public class CreateCustomScope implements ActionListener {

  private static final Logger logger = Logger.getLogger(CreateCustomScope.class.getName());

  @Override
  public void processAction(ActionEvent event) throws AbortProcessingException {

    logger.log(Level.INFO, "Creating custom scope ...");

    FacesContext context = FacesContext.getCurrentInstance();
    Map&lt;String, Object&gt; applicationMap = context.getExternalContext().getApplicationMap();
    CustomScope customScope = (CustomScope) applicationMap.get(CustomScope.SCOPE);

    if (customScope == null) {
      customScope = new CustomScope();
      applicationMap.put(CustomScope.SCOPE, customScope);

      customScope.scopeCreated(context);
    } else {
      logger.log(Level.INFO, "Custom scope exists ...");
    }
  }
}</pre></div><p>Following the same <a id="id449" class="indexterm"/>approach, the button<a id="id450" class="indexterm"/> labeled <span class="strong"><strong>STOP</strong></span> will remove the custom scope from the application map as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="STOP"&gt;
  &lt;f:actionListener type="book.beans.DestroyCustomScope" /&gt;
&lt;/h:commandButton&gt;</pre></div><p>The following <code class="literal">DestroyCustomScope</code> class is the <a id="id451" class="indexterm"/>action listener <a id="id452" class="indexterm"/>as it implements the <code class="literal">ActionListener</code> interface:</p><div class="informalexample"><pre class="programlisting">public class DestroyCustomScope implements ActionListener {

  private static final Logger logger = Logger.getLogger(DestroyCustomScope.class.getName());

  @Override
  public void processAction(ActionEvent event) throws AbortProcessingException {

    logger.log(Level.INFO, "Destroying custom scope ...");

    FacesContext context = FacesContext.getCurrentInstance();
    Map&lt;String, Object&gt; applicationMap = context.getExternalContext().getApplicationMap();
    CustomScope customScope = (CustomScope) applicationMap.get(CustomScope.SCOPE);

    if (customScope != null) {             
      customScope.scopeDestroyed(context);
      applicationMap.remove(CustomScope.SCOPE);
    } else {
      logger.log(Level.INFO, "Custom scope does not exists ...");
    }
  }
}</pre></div><p>This example is<a id="id453" class="indexterm"/> wrapped into the application named <code class="literal">ch3_8</code> that is available in the code bundle of this chapter. Just a run and a<a id="id454" class="indexterm"/> quick look over the code will<a id="id455" class="indexterm"/> clarify that the spaghetti-code is missing here.</p></div><div class="section" title="Controlling the custom scope lifespan with the navigation handler"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec51"/>Controlling the custom scope lifespan with the navigation handler</h2></div></div></div><p>Another approach is to control the custom <a id="id456" class="indexterm"/>scope lifespan based on the page's navigation. This solution is more flexible<a id="id457" class="indexterm"/> and is hidden from the user. You can write a custom navigation handler by extending <code class="literal">NavigationHandler</code>. The next implementation puts the custom scope in the application map when the navigation reaches the page named <code class="literal">sponsored.xhtml</code>, and will remove it from the application map in any other navigation case. The code of the <code class="literal">CustomScopeNavigationHandler</code> class is as<a id="id458" class="indexterm"/> follows:</p><div class="informalexample"><pre class="programlisting">public class CustomScopeNavigationHandler extends NavigationHandler {

  private static final Logger logger = Logger.getLogger(CustomScopeNavigationHandler.class.getName());
  private final NavigationHandler navigationHandler;

  public CustomScopeNavigationHandler(NavigationHandler navigationHandler) {
    this.navigationHandler = navigationHandler;
  }

  @Override
  public void handleNavigation(FacesContext context, String fromAction, String outcome) {

    if (outcome != null) {
      if (outcome.equals("sponsored")) {
        logger.log(Level.INFO, "Creating custom scope ...");

        Map&lt;String, Object&gt; applicationMap = context.getExternalContext().getApplicationMap();
        CustomScope customScope = (CustomScope) applicationMap.get(CustomScope.SCOPE);

        if (customScope == null) {
          customScope = new CustomScope();
          applicationMap.put(CustomScope.SCOPE, customScope);

          customScope.scopeCreated(context);
        } else {
          logger.log(Level.INFO, "Custom scope exists ...");
        }
      } else {
        logger.log(Level.INFO, "Destroying custom scope ...");

        Map&lt;String, Object&gt; applicationMap = context.getExternalContext().getApplicationMap();
        CustomScope customScope = (CustomScope) applicationMap.get(CustomScope.SCOPE);

        if (customScope != null) {
          customScope.scopeDestroyed(context);
          applicationMap.remove(CustomScope.SCOPE);
        } else {
          logger.log(Level.INFO, "Custom scope does not exist");
        }
      } 
    }

    navigationHandler.handleNavigation(context, fromAction, outcome);
  }
}</pre></div><p>Do not forget to register the following<a id="id459" class="indexterm"/> navigation<a id="id460" class="indexterm"/> handler in the <code class="literal">faces-config.xml</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;navigation-handler&gt;
  book.beans.CustomScopeNavigationHandler
&lt;/navigation-handler&gt;</pre></div><p>This example is wrapped into the<a id="id461" class="indexterm"/> application named <code class="literal">ch3_9</code> that is available in the code bundle of this chapter. A quick look over the code will clarify that the spaghetti-code is missing here.</p><p>As I said earlier, JSF 2.2 comes with a wrapper class for <code class="literal">NavigationHandler</code>. This is a simple implementation that can be <a id="id462" class="indexterm"/>easily extended by developers. An instance of the class being wrapped is returned in<a id="id463" class="indexterm"/> the <code class="literal">getWrapped</code> method. For example, you can rewrite the <code class="literal">CustomScopeNavigationHandler</code> class, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public class CustomScopeNavigationHandler extends NavigationHandlerWrapper {

  private static final Logger logger = Logger.getLogger(CustomScopeNavigationHandler.class.getName());
  private final NavigationHandler navigationHandler;

  public CustomScopeNavigationHandler(NavigationHandler navigationHandler){         
    this.navigationHandler = navigationHandler;
  }   

 @Override
  public void handleNavigation(FacesContext context, String fromAction, String outcome) {

    if (outcome != null) {
      if (outcome.equals("sponsored")) {
        logger.log(Level.INFO, "Creating custom scope ...");

        Map&lt;String, Object&gt; applicationMap = context.getExternalContext().getApplicationMap();
        CustomScope customScope = (CustomScope) applicationMap.get(CustomScope.SCOPE);

        if (customScope == null) {
          customScope = new CustomScope();
          applicationMap.put(CustomScope.SCOPE, customScope);

          customScope.scopeCreated(context);
        } else {
          logger.log(Level.INFO, "Custom scope exists ...");
        }
      } else {
        logger.log(Level.INFO, "Destroying custom scope ...");

        Map&lt;String, Object&gt; applicationMap = context.getExternalContext().getApplicationMap();
        CustomScope customScope = (CustomScope) applicationMap.get(CustomScope.SCOPE);

        if (customScope != null) {
          customScope.scopeDestroyed(context);
          applicationMap.remove(CustomScope.SCOPE);
        } else {
          logger.log(Level.INFO, "Custom scope does not exist");
        }
      }
    }

    getWrapped().handleNavigation(context, fromAction, outcome);
  }

  @Override
  public NavigationHandler getWrapped() {
    return navigationHandler;
  }
}</pre></div><p>This example is wrapped into the<a id="id464" class="indexterm"/> application<a id="id465" class="indexterm"/> named <code class="literal">ch3_10</code> that is available in the code bundle of this chapter.</p></div></div>
<div class="section" title="Managed bean instantiation"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Managed bean instantiation</h1></div></div></div><p>By default, a managed bean is instantiated at first reference to it (a request, for example)—this is known as <span class="strong"><strong>lazy instantiation</strong></span>. You can alter the default behavior by adding the <code class="literal">eager</code> attribute and set its value to <code class="literal">true</code>. This will instantiate the managed bean when the application starts, before any request<a id="id466" class="indexterm"/> is made. But, it is important to know that this works only for application scoped beans and the eager instantiated bean is placed<a id="id467" class="indexterm"/> in the application scope, as shown in the following lines of code:</p><div class="informalexample"><pre class="programlisting">@ManagedBean(eager=true)
@ApplicationScoped</pre></div></div>
<div class="section" title="Beans injection"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Beans injection</h1></div></div></div><p>Normally, solutions depend on the concrete functional requirements, but finding the right solutions is what makes the<a id="id468" class="indexterm"/> difference between developers. Sometimes, developers get stuck or make mistakes when they work with objects in a scope that uses objects from another scope. From the following figure, you can seek some guidance for dealing with some of the most popular cases:</p><div class="mediaobject"><img src="graphics/6466EN_03_13.jpg" alt="Beans injection"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note67"/>Note</h3><p>As you can see, there are some restrictions. As a general rule in JSF, don't use objects that have shorter lifespan than the objects you are calling it from. In other words, use objects whose lifespan is the same as, or longer than, the object being injected into. Breaking this rule will end up in a JSF exception.</p></div></div><p>The logic behind this rule can be explained through the two most common mistakes, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Use request objects in session objects</strong></span>: This is a bad thing, because we will have lots of requests (lots of instances) and only one session (one instance). Usually, requests belong to all users, while a session is one per user; therefore, it is unclear <a id="id469" class="indexterm"/>request object is injected? To be more clear, lots of requests means lots of associated beans, while a session means one bean. Now, it is illogical to inject one particular instance and skip all others. Moreover, how and when will you fetch the correct instance, since the request objects are transient, and usually, have a short lifespan! Even if you find a plausible use case, JSF will not allow you to do this via JSF managed beans.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Use session objects in application objects</strong></span>: The same logic can be applied further when we want to use session objects in application objects. Sessions are many as users, but the application is only one; therefore, you cannot inject all sessions in the application ... it is useless! Of course, you may want to fetch a certain session to the application, but you have to be sure that the pointed session exists; this is not a problem if you are interested in the session of the current user, but it may be an issue if you are interested in sessions of other users. Moreover, if there are many sessions, you have to correctly identify the desired session. Even if you find a plausible use case, JSF will not allow you to do this via JSF managed beans.</li></ul></div><p>Nevertheless, for CDI, these cases are not such a big issue. When you are using an object that has a shorter lifespan than the object you are calling it from (for example, injecting a request scoped bean into a session scoped bean), CDI classifies the use case as a mismatched injection and fixes the issue via CDI proxies. For each request, the CDI proxy re-establishes the connection to a live instance of the request scoped bean.</p><p>Even when we follow the<a id="id470" class="indexterm"/> written rules, we are still vulnerable to the unwritten rules. One of the unwritten rules that can cause undesirable results is named <span class="strong"><strong>overuse</strong></span> or <span class="strong"><strong>abuse</strong></span>. The following are some cases to avoid:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Overusing a view scoped bean for request scoped data may affect memory.</li><li class="listitem" style="list-style-type: disc">Overusing a request scoped bean for view scoped data may cause forms with unexpected behavior.</li><li class="listitem" style="list-style-type: disc">Overusing an application scoped bean for request/view/session scoped data may cause an undesirably wide visibility of data across users and will affect memory.</li><li class="listitem" style="list-style-type: disc">Overusing a session scoped bean for request/view data may cause an undesirably wide visibility of data across multiple browser windows/tabs in that session. As you know, view data are specific to a single browser window/tab, which allows us to open multiple tabs and keeps the data integrity while switching between tabs. On the other hand, if this data was exposed via the session scope, then the modifications in one window/tab will be reflected in the browser session; therefore, switching between tabs will lead to an apparently strange behavior, known as inconsistency of data. In case of using the session scope for request/view data, will also affect memory, since request/view scopes are meant to have a shorter lifespan than session scope.</li></ul></div><p>Starting with JSF 2.0, managed beans can be injected (dependency injection) into the property of another managed bean using the <code class="literal">@ManagedProperty</code> annotation. You already know that from the previous chapter, where an example is provided.</p><p>Another way to inject beans is to use the <code class="literal">@Inject</code> annotation, which is part of the CDI powerful injection mechanism.</p><p>So when do we use <code class="literal">@ManagedProperty</code> and when do we use <code class="literal">@Inject</code> ? Well, we know that both of them do the same thing in different ways and different containers, so maybe it is a good idea to use <code class="literal">@ManagedProperty</code> when you are working in a servlet container or just don't need CDI. Another good argument for <code class="literal">@ManagedProperty</code> is that you can use EL with it. But, if you are in a proper CDI environment where you can exploit CDI benefits, such as proxy scope leak prevention or better deploy-time dependency, then use CDI.</p><p>The pacifist approach will <a id="id471" class="indexterm"/>combine these two in the same application. In this case, you have two options: to avoid any interaction between the managed beans and CDI beans or, obviously, to encourage the interaction between them for better performance. If you choose the second option, then it is important to keep in mind some simple rules of injection as shown in the following figure:</p><div class="mediaobject"><img src="graphics/6466EN_03_14.jpg" alt="Beans injection"/></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Summary</h1></div></div></div><p>In this chapter, we have browsed through an overview of JSF/CDI scopes. It begins with an open discussion about JSF scopes versus CDI scopes, meant to provide a few advantages/disadvantages of choosing either one (or both). After a short overview of JSF/CDI scopes, each scope was detailed by covering fundamental knowledge, such as definition, usability, functionality, restrictions, and examples.</p><p>The chapter ends with a bunch of thoughts regarding beans injections. You can find several rules, tips, and bad practices commonly used in JSF applications mentioned out here.</p><p>See you in the next two chapters, where we will cover many kinds of JSF artifacts and configuration stuff.</p></div></body></html>