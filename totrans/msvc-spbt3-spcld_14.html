<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer333" class="Basic-Text-Frame">
    <h1 class="chapterNumber">14</h1>
    <h1 id="_idParaDest-358" class="chapterTitle">Understanding Distributed Tracing</h1>
    <p class="normal">In this chapter, we will learn how to use distributed tracing to better understand how our microservices cooperate, for example, in fulfilling a request sent to the external API. Being able to utilize distributed tracing is essential for being able to manage a system landscape of cooperating microservices. As already described in <em class="chapterRef">Chapter 8</em>, <em class="italic">Introduction to Spring Cloud</em>, Micrometer Tracing will be used to collect trace information, and Zipkin will be used for the storage and visualization of said trace information.</p>
    <p class="normal">In this chapter, we will learn about the following topics:</p>
    <ul>
      <li class="bulletList">Introducing distributed tracing with Micrometer Tracing and Zipkin.</li>
      <li class="bulletList">How to add distributed tracing to the source code.</li>
      <li class="bulletList">How to programmatically add information to the traces.</li>
      <li class="bulletList">How to perform distributed tracing, visualizing both successful and unsuccessful API requests. We will see how both synchronous and asynchronous processing can be visualized.</li>
    </ul>
    <h1 id="_idParaDest-359" class="heading-1">Technical requirements</h1>
    <p class="normal">For instructions on how to install the tools used in this book and how to access the source code for this book, see:</p>
    <ul>
      <li class="bulletList"><em class="chapterRef">Chapter 21</em>, <em class="italic">Installation Instructions for macOS</em></li>
      <li class="bulletList"><em class="chapterRef">Chapter 22</em>, <em class="italic">Installation Instructions for Microsoft Windows with WSL 2 and Ubuntu</em></li>
    </ul>
    <p class="normal">The code examples in this chapter all come from the source code in <code class="inlineCode">$BOOK_HOME/Chapter14</code>.</p>
    <p class="normal">If you want to view the changes applied to the source code in this chapter, that is, see what it took to add distributed tracing using Micrometer Tracing and Zipkin, you can compare it with the source code for <em class="chapterRef">Chapter 13</em>, <em class="italic">Improving Resilience Using Resilience4j</em>. You can use your favorite <code class="inlineCode">diff</code> tool and compare the two folders, <code class="inlineCode">$BOOK_HOME/Chapter13</code> and <code class="inlineCode">$BOOK_HOME/Chapter14</code>.</p>
    <h1 id="_idParaDest-360" class="heading-1">Introducing distributed tracing with Micrometer Tracing and Zipkin</h1>
    <p class="normal">To recapitulate <em class="chapterRef">Chapter 8</em>, <em class="italic">Introduction to Spring Cloud</em>, in reference to the <em class="italic">Using Micrometer Tracing and Zipkin for distributed tracing</em> section, the tracing<a id="_idIndexMarker934"/> information from a complete<a id="_idIndexMarker935"/> workflow is called a <strong class="keyWord">trace</strong> or a <strong class="keyWord">trace tree</strong>, and sub-parts of the tree, for<a id="_idIndexMarker936"/> example, the basic<a id="_idIndexMarker937"/> units of work, are called <strong class="keyWord">spans</strong>. Spans can consist of sub-spans<a id="_idIndexMarker938"/> forming the trace tree. Metadata<a id="_idIndexMarker939"/> can be added to a trace<a id="_idIndexMarker940"/> and its spans<a id="_idIndexMarker941"/> as key-value pairs called <strong class="keyWord">tags</strong>. The Zipkin UI can visualize a trace tree and its spans as follows:</p>
    <figure class="mediaobject"><img src="../Images/B19825_14_01.png" alt="Graphical user interface, application  Description automatically generated" width="755" height="259"/></figure>
    <p class="packt_figref">Figure 14.1: Example of a trace with its spans</p>
    <p class="normal">Micrometer Tracing is used to collect trace information, propagate trace contexts (for example, trace and span IDs) in calls to other microservices and export the trace information into trace analysis tools like Zipkin. The handling<a id="_idIndexMarker942"/> of the trace information is done under the hood, by a <strong class="keyWord">tracer</strong>. Micrometer supports<a id="_idIndexMarker943"/> auto-configuration of tracers based on <strong class="keyWord">OpenTelemetry</strong> (<a href="https://opentelemetry.io/"><span class="url">https://opentelemetry.io/</span></a>) or <strong class="keyWord">OpenZipkin Brave (</strong><a href="https://github.com/openzipkin/brave"><span class="url">https://github.com/openzipkin/brave</span></a><strong class="keyWord">)</strong>. Exporting the trace information<a id="_idIndexMarker944"/> into a trace<a id="_idIndexMarker945"/> analysis tool is done by a <strong class="keyWord">reporter</strong>.</p>
    <p class="normal">By default, trace headers<a id="_idIndexMarker946"/> are propagated between microservices using <strong class="keyWord">W3C trace context</strong> headers (<a href="https://www.w3.org/TR/trace-context/"><span class="url">https://www.w3.org/TR/trace-context/</span></a>), most importantly the <code class="inlineCode">traceparent</code> header, but can<a id="_idIndexMarker947"/> be configured to use OpenZipkin’s <code class="inlineCode">B3</code> headers. In this chapter, we will use the W3C trace context headers. In <em class="chapterRef">Chapter 18,</em> we will use the <code class="inlineCode">B3</code> headers.</p>
    <p class="normal">A sample W3C trace context <code class="inlineCode">traceparent</code> header looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">traceparent:"00-2425f26083814f66c985c717a761e810-fbec8704028cfb20-01"
</code></pre>
    <p class="normal">The value of the <code class="inlineCode">traceparent</code> header contains four parts, separated by a <code class="inlineCode">-</code>:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">00</code>, indicates the version used. Will always be “<code class="inlineCode">00</code>" using the current specification.</li>
      <li class="bulletList"><code class="inlineCode">124…810</code>, is the trace ID.</li>
      <li class="bulletList"><code class="inlineCode">fbe…b20</code> is the span ID.</li>
      <li class="bulletList"><code class="inlineCode">01</code>, the last part, contains various flags. The only flag supported by the current specification is a flag named <code class="inlineCode">sampled</code>, with the value <code class="inlineCode">01</code>. It means that the caller is recording the trace data for this request. We will configure our microservices to record trace data for all requests, so this flag will always have the value of <code class="inlineCode">01</code>. </li>
    </ul>
    <p class="normal">Use of OpenZipkin Brave <code class="inlineCode">B3</code> headers will look like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">X</span>-B<span class="hljs-number">3</span>-TraceId:<span class="hljs-string">"64436ea679e8eb6e6fa028bb3459e703"</span>
<span class="hljs-keyword">X</span>-B<span class="hljs-number">3</span>-SpanId:<span class="hljs-string">"120678270898ddd5"</span>
<span class="hljs-keyword">X</span>-B<span class="hljs-number">3</span>-ParentSpanId:<span class="hljs-string">"</span><span class="hljs-string">3c431d3d01987c22"</span>
<span class="hljs-keyword">X</span>-B<span class="hljs-number">3</span>-Sampled:<span class="hljs-string">"1"</span>
</code></pre>
    <p class="normal">The header names are self-explanatory, and we can see that headers are not only provided for the trace and span ID but also for the parent span’s ID.</p>
    <p class="normal">Traces and spans are created automatically by Spring Boot for incoming traffic, both for incoming HTTP requests and messages received by Spring Cloud Stream. If an incoming request contains a trace ID, it will be used when creating spans; if not, a new trace id will be created. Trace and span IDs are automatically propagated to outgoing traffic, either as HTTP requests or by sending messages using Spring Cloud Stream.</p>
    <p class="normal">If required, extra trace info can be added<a id="_idIndexMarker948"/> programmatically, either by adding custom spans or by adding custom<a id="_idIndexMarker949"/> tags to all spans created by a microservice. This is done by using <strong class="keyWord">Micrometer Observability</strong> (<a href="https://micrometer.io/docs/observation"><span class="url">https://micrometer.io/docs/observation</span></a>) and its <code class="inlineCode">Observation</code> API.</p>
    <p class="normal">The initial release of Micrometer Tracing together with Spring Boot 3 came with some limitations for supporting distributed tracing in reactive clients. This affects the microservices used in this book that use Project Reactor under the hood. In the section <em class="italic">Adding workarounds for lacking support of reactive clients</em>, we will learn how to mitigate these shortcomings.</p>
    <p class="normal">Zipkin comes with native support for storing trace information either in memory, or in a database such as Apache Cassandra, Elasticsearch, or MySQL. Added to this, a number of extensions<a id="_idIndexMarker950"/> are available. For details, refer to <a href="https://zipkin.io/pages/extensions_choices.html"><span class="url">https://zipkin.io/pages/extensions_choices.html</span></a>. In this chapter, we will store the trace information in memory.</p>
    <p class="normal">With<a id="_idIndexMarker951"/> Micrometer Tracing<a id="_idIndexMarker952"/> and Zipkin<a id="_idIndexMarker953"/> introduced, let’s see what<a id="_idIndexMarker954"/> changes are required in the source code to enable distributed tracing.</p>
    <h1 id="_idParaDest-361" class="heading-1">Adding distributed tracing to the source code</h1>
    <p class="normal">In this section, we will learn how<a id="_idIndexMarker955"/> to update the source code<a id="_idIndexMarker956"/> to enable distributed tracing. This can be done with the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add dependencies to the build files to bring in Micrometer Tracing with a tracer implementation and a reporter.</li>
      <li class="numberedList">Add a Zipkin server to the Docker Compose files.</li>
      <li class="numberedList">Configure the microservices to send trace information to Zipkin.</li>
      <li class="numberedList">Add workarounds for the lacking support of reactive clients.</li>
      <li class="numberedList">Add code for creating custom spans and custom tags in existing spans.</li>
    </ol>
    <p class="normal">We will go through<a id="_idIndexMarker957"/> each of the steps<a id="_idIndexMarker958"/> in turn.</p>
    <h2 id="_idParaDest-362" class="heading-2">Adding dependencies to build files</h2>
    <p class="normal">To be able to utilize Micrometer Tracing<a id="_idIndexMarker959"/> and the ability to export trace information<a id="_idIndexMarker960"/> to Zipkin, we need to add a dependency to the selected tracer and reporter to the Gradle project build files, <code class="inlineCode">build.gradle</code>.</p>
    <p class="normal">This is accomplished by adding the following two lines:</p>
    <pre class="programlisting code"><code class="hljs-code">implementation <span class="hljs-string">'io.micrometer:micrometer-tracing-bridge-otel'</span>
implementation <span class="hljs-string">'io.opentelemetry:opentelemetry-exporter-zipkin'</span>
</code></pre>
    <p class="normal">For the review service, a dependency has also been added to enable trace information regarding SQL database operations. It looks like:</p>
    <pre class="programlisting code"><code class="hljs-code">implementation <span class="hljs-string">'net.ttddyy.observation:datasource-micrometer-spring-boot:1.0.0'</span>
</code></pre>
    <p class="normal">This library can create spans for the SQL operations executed by the review service. These spans will contain information about the SQL query that was executed and its execution time.</p>
    <h2 id="_idParaDest-363" class="heading-2">Adding configuration for Micrometer Tracing and Zipkin</h2>
    <p class="normal">Configuration for using Micrometer Tracing<a id="_idIndexMarker961"/> and Zipkin is added<a id="_idIndexMarker962"/> to the common configuration<a id="_idIndexMarker963"/> file, <code class="inlineCode">config-repo/application.yml</code>. In the default<a id="_idIndexMarker964"/> profile, it is specified that trace information will be sent to Zipkin using the following URL:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">management.zipkin.tracing.endpoint: http://zipkin:9411/api/v2/spans</span>
</code></pre>
    <p class="normal">By default, Micrometer Tracing only sends 10% of the traces to Zipkin. To ensure that all traces are sent to Zipkin, the following property is added to the default profile:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">management.tracing.sampling.probability:</span> <span class="hljs-number">1.0</span>
</code></pre>
    <p class="normal">We also want trace and span IDs to be written to logs; this will enable us to correlate log output from cooperating microservices that, for example, fulfill a request sent to the external API. </p>
    <div class="packt_tip">
      <p class="normal">We will investigate how to use this in <em class="chapterRef">Chapter 19</em><em class="italic">, Centralized Logging with the EFK Stack</em>. </p>
    </div>
    <p class="normal">We can include the trace and span IDs in the log output by specifying the following log format:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">logging.pattern.level:</span> <span class="hljs-string">"%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}]"</span>
</code></pre>
    <p class="normal">With the above log format, the log output will look like:</p>
    <pre class="programlisting con"><code class="hljs-con">2023-04-22T14:02:07.417Z  INFO [product-composite,01234,56789]
</code></pre>
    <p class="normal">Where <code class="inlineCode">product-composite</code> is the name of the microservice, <code class="inlineCode">01234</code> is the trace ID, and <code class="inlineCode">56789</code> is the span ID.</p>
    <p class="normal">To reduce the log output, we also change the log level from <code class="inlineCode">DEBUG</code> to <code class="inlineCode">INFO</code> for each microservice’s configuration file in the <code class="inlineCode">config-repo</code>. This makes it easier to verify that trace and span IDs are added as expected. This change is applied by the line:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-attr">se.magnus:</span> <span class="hljs-string">INFO</span>
</code></pre>
    <p class="normal">For the <code class="inlineCode">product-composite</code> microservice, the log level<a id="_idIndexMarker965"/> for the <code class="inlineCode">HttpWebHandlerAdapter</code> class has been<a id="_idIndexMarker966"/> changed<a id="_idIndexMarker967"/> from <code class="inlineCode">TRACE</code> to <code class="inlineCode">INFO</code> for the same<a id="_idIndexMarker968"/> reason:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">org.springframework.web.server.adapter.HttpWebHandlerAdapter:</span> <span class="hljs-string">INFO</span>
</code></pre>
    <h2 id="_idParaDest-364" class="heading-2">Adding Zipkin to the Docker Compose files</h2>
    <p class="normal">To run the Zipkin server<a id="_idIndexMarker969"/> as a Docker<a id="_idIndexMarker970"/> container, we will use a Docker image, <code class="inlineCode">openzipkin/zipkin</code>, published by the Zipkin<a id="_idIndexMarker971"/> project. Refer to <a href="https://hub.docker.com/r/openzipkin/zipkin"><span class="url">https://hub.docker.com/r/openzipkin/zipkin</span></a> for details. The definition of the Zipkin server appears as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-attr">zipkin:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">openzipkin/zipkin:2.24.0</span>
    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>
    <span class="hljs-attr">mem_limit:</span> <span class="hljs-string">1024m</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">STORAGE_TYPE=mem</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-number">9411</span><span class="hljs-string">:9411</span>
</code></pre>
    <p class="normal">Let’s explain the preceding source code:</p>
    <ul>
      <li class="bulletList">The version of the Docker image, <code class="inlineCode">openzipkin/zipkin</code>, is specified to be version 2.24.0.</li>
      <li class="bulletList">The <code class="inlineCode">STORAGE_TYPE=mem</code> environment variable is used to specify that Zipkin will keep all trace information in memory.</li>
      <li class="bulletList">The memory limit for Zipkin is increased to 1,024 MB, compared to 512 MB for all other containers. The reason for this is that since Zipkin is configured to keep all trace information in memory, it will consume more memory than the other containers after a while.</li>
      <li class="bulletList">If Zipkin happens to run out of memory and stops, we have applied a restart policy that requests the Docker engine to always restart the container. This will apply both if the container itself crashes or if the Docker engine is restarted.</li>
      <li class="bulletList">Zipkin exposes the HTTP port <code class="inlineCode">9411</code> for web browsers<a id="_idIndexMarker972"/> to access its web user<a id="_idIndexMarker973"/> interface.</li>
    </ul>
    <div class="packt_tip">
      <p class="normal">While it is OK to store the trace information in Zipkin in memory for development and test activities, Zipkin should be configured to store trace information in a database in a production environment.</p>
    </div>
    <h2 id="_idParaDest-365" class="heading-2">Adding workarounds for lacking support of reactive clients</h2>
    <p class="normal">As mentioned above, the current versions<a id="_idIndexMarker974"/> of Spring Boot, Project Reactor, and Micrometer Tracing do not yet work together perfectly. Therefore, a couple of workarounds have been applied to the source code for reactive clients. That is, the four microservices and the gateway. The problems are mainly related to the complexity of propagating trace contexts (for example, trace and span IDs) between different threads involved in reactive asynchronous processing, specifically if parts of the processing involve imperative synchronous processing. </p>
    <div class="note">
      <p class="normal">If all processing of a request is done with a synchronous implementation, using one and the same thread for all processing, propagating trace context is not an issue. A <code class="inlineCode">ThreadLocal</code> variable can be used to store the trace context. The trace context can be retrieved from the <code class="inlineCode">ThreadLocal</code> variable in any place of the implementation since all code runs in one and the same thread.</p>
    </div>
    <p class="normal">An example of this mix of reactive and imperative processing is the implementation of the <code class="inlineCode">review</code> microservice, where calls to the underlying SQL database are done synchronously.</p>
    <div class="packt_tip">
      <p class="normal">If you are interested in understanding the challenges in more detail, see the three-part blog series “<em class="italic">Unified Bridging between Reactive and Imperative</em>” published by the Spring team. It can be found here: <a href="https://spring.io/blog/2023/03/30/context-propagation-with-project-reactor-3-unified-bridging-between-reactive"><span class="url">https://spring.io/blog/2023/03/30/context-propagation-with-project-reactor-3-unified-bridging-between-reactive</span></a>.</p>
    </div>
    <p class="normal">It is also worth noting that the predecessor of Micrometer Tracing, Spring Cloud Sleuth, has better support for reactive clients than the current versions of Spring Boot, Project Reactor, and Micrometer Tracing. Hopefully, the coming versions will soon address these shortcomings.</p>
    <div class="packt_tip">
      <p class="normal">If you have a code base that already uses Spring Cloud Sleuth, you can find migration guidelines here: <a href="https://github.com/micrometer-metrics/tracing/wiki/Spring-Cloud-Sleuth-3.1-Migration-Guide"><span class="url">https://github.com/micrometer-metrics/tracing/wiki/Spring-Cloud-Sleuth-3.1-Migration-Guide</span></a>.</p>
    </div>
    <p class="normal">To address many of the challenges with context propagation, we can turn on automatic context propagation by calling the method <code class="inlineCode">Hooks.enableAutomaticContextPropagation()</code> in a reactive client’s <code class="inlineCode">main()</code> method. For details, see the blog series “<em class="italic">Unified Bridging between Reactive and Imperative</em>” referred to above. For the <code class="inlineCode">product-composite</code> service, it looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> {
  Hooks.enableAutomaticContextPropagation();
  SpringApplication.run(ProductCompositeServiceApplication.class, args);
}
</code></pre>
    <p class="normal">However, for the <code class="inlineCode">product-composite</code> service, one problem remains. To ensure that a <code class="inlineCode">WebClient</code> instance is correctly instrumented for observation, for example, to be able to propagate the current trace and span IDs as headers in an outgoing request, the <code class="inlineCode">WebClient.Builder</code> instance is expected to be injected using auto-wiring. Unfortunately, when using Eureka for service discovery, the <code class="inlineCode">WebClient.Builder</code> instance is recommended to be created as a bean annotated with <code class="inlineCode">@LoadBalanced</code> as:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-meta">@Bean</span>
  <span class="hljs-meta">@LoadBalanced</span>
  <span class="hljs-keyword">public</span> WebClient.Builder <span class="hljs-title">loadBalancedWebClientBuilder</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> WebClient.builder();
  }
</code></pre>
    <p class="normal">So, there is a conflict in how to create a <code class="inlineCode">WebClient</code> instance when used with both Eureka and Micrometer Tracing. To resolve this conflict, the <code class="inlineCode">@LoadBalanced</code> bean can be replaced by a load-balancer-aware exchange-filter function, <code class="inlineCode">ReactorLoadBalancerExchangeFilterFunction</code>. An exchange-filter function can be set on an auto-wired <code class="inlineCode">WebClient.Builder</code> instance like:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-meta">@Autowired</span>
  <span class="hljs-keyword">private</span> ReactorLoadBalancerExchangeFilterFunction lbFunction;
  <span class="hljs-meta">@Bean</span>
  <span class="hljs-keyword">public</span> WebClient <span class="hljs-title">webClient</span><span class="hljs-params">(WebClient.Builder builder)</span> {
    <span class="hljs-keyword">return</span> builder.filter(lbFunction).build();
  }
</code></pre>
    <p class="normal">This means that the application class, <code class="inlineCode">ProductCompositeServiceApplication</code>, registers a <code class="inlineCode">WebClient</code> bean instead of a <code class="inlineCode">WebClient.Builder</code> bean. This affects the <code class="inlineCode">ProductCompositeIntegration</code> class; it now needs to auto-wire a <code class="inlineCode">WebClient</code> bean instead of a <code class="inlineCode">WebClient.Builder</code> bean.</p>
    <p class="normal">To get access<a id="_idIndexMarker975"/> to the <code class="inlineCode">ReactorLoadBalancerExchangeFilterFunction</code> function, a dependency to <code class="inlineCode">org.springframework.cloud:spring-cloud-starter-loadbalancer</code> has been added to the build file, <code class="inlineCode">build.gradle</code>.</p>
    <h2 id="_idParaDest-366" class="heading-2">Adding custom spans and custom tags to existing spans</h2>
    <p class="normal">Besides relying on the built-in support<a id="_idIndexMarker976"/> for creating traces<a id="_idIndexMarker977"/> and spans for the ongoing processing, we can also use the <code class="inlineCode">Observation</code> API provided by Micrometer Observability to, for example, add our own spans or add custom tags to existing spans created by a microservice. The <code class="inlineCode">Observation</code> API is implemented behind a Java interface with the same name.</p>
    <p class="normal">Let’s first see how to add a custom span, and after that, see how we can add custom tags to all spans created by a microservice.</p>
    <p class="normal">For any observation to take place using the <code class="inlineCode">Observation</code> API, observation objects need to be registered in an <code class="inlineCode">ObservationRegistry</code> bean. An <code class="inlineCode">ObservationRegistry</code> bean can be injected using auto-wiring<a id="_idIndexMarker978"/> like in the following<a id="_idIndexMarker979"/> example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ObservationRegistry registry;
  <span class="hljs-keyword">public</span> <span class="hljs-title">MyComponent</span><span class="hljs-params">(ObservationRegistry registry)</span> {
    <span class="hljs-built_in">this</span>.registry = registry;
  }
</code></pre>
    <h3 id="_idParaDest-367" class="heading-3">Adding a custom span</h3>
    <p class="normal">To add a custom<a id="_idIndexMarker980"/> span, the <code class="inlineCode">Observation</code> interface<a id="_idIndexMarker981"/> provides a static method, <code class="inlineCode">createNotStarted()</code>, that can be used to create a span. To execute the span, an <code class="inlineCode">observe()</code> method can be used to provide the code that the span shall cover. If the code doesn’t return any value, it can be specified as a <code class="inlineCode">Runnable</code> function; otherwise, it needs to be specified as a <code class="inlineCode">Supplier</code> function. </p>
    <p class="normal">An example of the creation of a custom span for the execution of a minimalistic <code class="inlineCode">Supplier</code> function looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> Observation.createNotStarted(<span class="hljs-string">"my observation"</span>, registry)
      .observe(() -&gt; {
        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
        LOG.info(<span class="hljs-string">"Will return {}"</span>, x);
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
      });
    LOG.info(<span class="hljs-string">"Got {}"</span>, y);
</code></pre>
    <p class="normal">The <code class="inlineCode">registry</code> parameter is a bean of type <code class="inlineCode">ObservationRegistry</code> and is auto-wired as described above.</p>
    <p class="normal">The execution of this code will result in log output like:</p>
    <pre class="programlisting con"><code class="hljs-con">2023-04-22T14:02:07.417Z  INFO [product-composite,9761b2b2b2da59c5096e78252c48ab3d,d8bcbd9cde9fe2d7] 1 --- [     parallel-6] s.m.m.c.p.s.ProductCompositeServiceImpl  : Will return 1
2023-04-22T14:02:07.417Z  INFO [product-composite,9761b2b2b2da59c5096e78252c48ab3d,4c8ea2820fb74ec9] 1 --- [     parallel-6] s.m.m.c.p.s.ProductCompositeServiceImpl  : Got 1
</code></pre>
    <p class="normal">From the log output, we can see that both log statements refer to the same trace ID, <code class="inlineCode">9761b2b2b2da59c5096e78252c48ab3d</code>, but specifies different span IDs, <code class="inlineCode">d8bcbd9cde9fe2d7</code> being the span ID of the custom span!</p>
    <p class="normal">If we want to add metadata<a id="_idIndexMarker982"/> regarding the span, we can specify it by adding a contextual<a id="_idIndexMarker983"/> name and a set of tags as key-value pairs. The contextual name will be the name of the span and it can be used to identify the span when a trace tree is visualized in Zipkin. If the possible values for the information are bounded, limited to a finite number of alternatives, the tag should be specified using the <code class="inlineCode">lowCardinalityKeyValue()</code> method. For unbounded values, the <code class="inlineCode">highCardinalityKeyValue()</code> method should be used. Calling these methods will result in tags being added to the current span, while low-cardinality values will also be tagged to metrics created by the observation. </p>
    <div class="packt_tip">
      <p class="normal">We will investigate how to use metrics in <em class="chapterRef">Chapter 20</em><em class="italic">, Monitoring Microservices</em>. </p>
    </div>
    <p class="normal">An example of specifying information as tags looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> Observation.createNotStarted(<span class="hljs-string">"my observation"</span>, registry)
      .contextualName(<span class="hljs-string">"product info"</span>)
      .lowCardinalityKeyValue(<span class="hljs-string">"template-url"</span>, <span class="hljs-string">"/product-composite/{productId}"</span>)
      .highCardinalityKeyValue(<span class="hljs-string">"actual-url"</span>, <span class="hljs-string">"/product-composite/12345678"</span>)
      .observe(() -&gt; {
        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
        LOG.info(<span class="hljs-string">"Will return {}"</span>, x);
        <span class="hljs-keyword">return</span> x;
      });
    LOG.info(<span class="hljs-string">"Got {}"</span>, y);
</code></pre>
    <p class="normal">From the example above, we can see that:</p>
    <ul>
      <li class="bulletList">The contextual name is set to <code class="inlineCode">"product info"</code>.</li>
      <li class="bulletList">A key, <code class="inlineCode">"template-url"</code>, that only has a few possible values, is specified with the <code class="inlineCode">lowCardinalityKeyValue()</code> method. In our case, it has only three possible values for the create, get, and delete methods.</li>
      <li class="bulletList">A key, <code class="inlineCode">"actual-url"</code>, with an unlimited number of values depending on the specified <code class="inlineCode">productId</code>, has been specified with the <code class="inlineCode">highCardinalityKeyValue()</code> method. </li>
    </ul>
    <p class="normal">Let’s apply this to the <code class="inlineCode">product-composite</code> service to create a custom span that provides the <code class="inlineCode">productId</code> as a tag. Since the number of product IDs is unlimited, we will specify it using the <code class="inlineCode">highCardinalityKeyValue()</code> method. We will create a span that specifies the current <code class="inlineCode">productId</code> for each of the three API methods for creating, retrieving, and deleting composite products. The creation of a custom span that contains one high-cardinality tag is handled by a utility class, <code class="inlineCode">ObservationUtil</code>. The utility class is placed in the package <code class="inlineCode">se.magnus.microservices.composite.product.services.tracing</code>. The utility method <code class="inlineCode">observe()</code> in this class looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">public</span> <span class="hljs-string">&lt;T&gt;</span> <span class="hljs-string">T</span> <span class="hljs-string">observe(String</span> <span class="hljs-string">observationName,</span> <span class="hljs-string">String</span> <span class="hljs-string">contextualName,</span> <span class="hljs-string">String</span> <span class="hljs-string">highCardinalityKey,</span> <span class="hljs-string">String</span> <span class="hljs-string">highCardinalityValue,</span> <span class="hljs-string">Supplier&lt;T&gt;</span> <span class="hljs-string">supplier)</span> {
  <span class="hljs-string">return</span> <span class="hljs-string">Observation.createNotStarted(observationName</span>, <span class="hljs-string">registry)</span>
    <span class="hljs-string">.contextualName(contextualName)</span>
    <span class="hljs-string">.highCardinalityKeyValue(highCardinalityKey</span>, <span class="hljs-string">highCardinalityValue)</span>
    <span class="hljs-string">.observe(supplier);</span>
}
</code></pre>
    <p class="normal">The <code class="inlineCode">observe()</code> method wraps the call to the method <code class="inlineCode">Observation.createNotStarted()</code>. The use of this method is explained in the example above, so it needs no further explanation.</p>
    <p class="normal">This utility method is used in the <code class="inlineCode">ProductCompositeServiceImpl</code> class by a helper method <code class="inlineCode">observationWithProductInfo()</code> that applies common values to the <code class="inlineCode">ProductCompositeServiceImpl</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> &lt;T&gt; T observationWithProductInfo(<span class="hljs-keyword">int</span> productInfo, Supplier&lt;T&gt; supplier) {
  <span class="hljs-keyword">return</span> observationUtil.observe(
    <span class="hljs-string">"composite observation"</span>,
    <span class="hljs-string">"product info"</span>,
    <span class="hljs-string">"productId"</span>,
    String.valueOf(productInfo),
    supplier);
}
</code></pre>
    <p class="normal">Finally, the helper method<a id="_idIndexMarker984"/> is used by the three API methods, <code class="inlineCode">createProduct()</code>, <code class="inlineCode">getProduct()</code>, and <code class="inlineCode">deleteProduct()</code>. The custom span is created by wrapping the existing<a id="_idIndexMarker985"/> code in each method. The existing code has been moved to corresponding “internal” methods to simplify the structure of the solution. The “internal” methods are called by the <code class="inlineCode">observationWithProductInfo()</code> method. For the <code class="inlineCode">getProduct()</code>, the implementation now looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-string">public</span> <span class="hljs-string">Mono&lt;ProductAggregate&gt;</span> <span class="hljs-string">getProduct(int</span> <span class="hljs-string">productId,</span> <span class="hljs-string">...)</span> {
    <span class="hljs-string">return</span> <span class="hljs-string">observationWithProductInfo(productId</span>,
      <span class="hljs-string">()</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">getProductInternal(productId</span>, <span class="hljs-string">...));</span>
  }
  <span class="hljs-string">private</span> <span class="hljs-string">Mono&lt;ProductAggregate&gt;</span> <span class="hljs-string">getProductInternal(int</span> <span class="hljs-string">productId,</span> <span class="hljs-string">...)</span> {
    <span class="hljs-string">return</span> <span class="hljs-string">observationWithProductInfo(productId</span>, <span class="hljs-string">()</span> <span class="hljs-string">-&gt;</span> {
      <span class="hljs-string">LOG.info("Will</span> <span class="hljs-string">get</span> <span class="hljs-string">composite</span> <span class="hljs-string">product</span> <span class="hljs-string">info</span> <span class="hljs-string">for</span> <span class="hljs-string">product.id=</span>{}<span class="hljs-string">", productId);</span>
<span class="hljs-string">      return Mono.zip(</span>
<span class="hljs-string">          values -&gt; createProductAggregate(...</span>
<span class="hljs-string">          integration.getProduct(productId, ...),</span>
<span class="hljs-string">          integration.getRecommendations(productId).collectList(),</span>
<span class="hljs-string">          integration.getReviews(productId).collectList())</span>
<span class="hljs-string">          ...);</span>
<span class="hljs-string">  }</span>
</code></pre>
    <p class="normal">If compared with the corresponding implementation in <em class="chapterRef">Chapter 13</em>, we can see that the changes required to create a custom span are limited to adding a new “<em class="italic">inner</em>” method and calling it from the <code class="inlineCode">observationWithProductInfo()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">public</span> Mono&lt;ProductAggregate&gt; <span class="hljs-title">getProduct</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId, ...)</span> {
    LOG.info(<span class="hljs-string">"Will get composite product info for product.id={}"</span>, productId);
    <span class="hljs-keyword">return</span> Mono.zip(
      values -&gt; createProductAggregate(...
      integration.getProduct(productId, ...),
      integration.getRecommendations(productId).collectList(),
      integration.getReviews(productId).collectList())
      ...);
  }
</code></pre>
    <p class="normal">So, adding a custom<a id="_idIndexMarker986"/> span to existing code can be made with a very small change, given<a id="_idIndexMarker987"/> a proper utility method that handles the details of setting up a custom span. When we try out the distributed tracing later in this chapter, we will see this custom span in action. With a custom span in place, let’s see how we can add custom tags to any span created in a microservice!</p>
    <h3 id="_idParaDest-368" class="heading-3">Adding custom tags to existing spans</h3>
    <p class="normal">If we want to add some custom information<a id="_idIndexMarker988"/> to all spans that<a id="_idIndexMarker989"/> are created by a microservice, we can use an <code class="inlineCode">ObservationFilter</code>. It needs to be registered in the <code class="inlineCode">ObservationRegistry</code> bean using an <code class="inlineCode">ObservationRegistryCustomizer</code> bean. </p>
    <p class="normal">Let’s apply a filter that registers the current version of the <code class="inlineCode">product-composite</code> microservice as a tag on every span it creates. We need to do the following:</p>
    <ul>
      <li class="bulletList">Update the build file to make Gradle create build info, including the current version specified by the <code class="inlineCode">version</code> property in the <code class="inlineCode">build.gradle</code> file.</li>
      <li class="bulletList">Create a filter that adds the current version as a low-cardinality tag to all spans.</li>
      <li class="bulletList">Create a registry configuration bean that registers the filter.</li>
    </ul>
    <p class="normal">To make Gradle create build info, the following is added to the build file, <code class="inlineCode">build.gradle</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-variable">springBoot</span> {
    <span class="hljs-title">buildInfo</span><span class="hljs-function">()</span>
}
</code></pre>
    <p class="normal">This addition will result in the file <code class="inlineCode">build/resources/main/META-INF/build-info.properties</code> being created when the <code class="inlineCode">./gradlew build</code> command is executed. This file will specify the current version as:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">build.version=1.0.0-SNAPSHOT</span>
</code></pre>
    <p class="normal">The build info file will be bundled into the microservice’s JAR file, and its information can be accessed using a <code class="inlineCode">BuildProperties</code> bean.</p>
    <p class="normal">The filter looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">BuildInfoObservationFilter</span><span class="hljs-class"> </span><span class="hljs-keyword">implements</span><span class="hljs-class"> </span><span class="hljs-title">ObservationFilter</span><span class="hljs-class"> </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BuildProperties buildProperties;
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-title">BuildInfoObservationFilter</span><span class="hljs-params">(BuildProperties buildProperties)</span><span class="hljs-function"> </span>{
    <span class="hljs-keyword">this</span>.buildProperties = buildProperties;
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> Observation.<span class="hljs-function">Context </span><span class="hljs-title">map</span><span class="hljs-params">(</span><span class="hljs-keyword">final</span><span class="hljs-params"> Observation.Context context)</span><span class="hljs-function"> </span>{
    KeyValue buildVersion = KeyValue.of(<span class="hljs-string">"build.version"</span>, buildProperties.getVersion());
    <span class="hljs-keyword">return</span><span class="hljs-function"> context.</span><span class="hljs-title">addLowCardinalityKeyValue</span><span class="hljs-params">(buildVersion)</span>;
  }
}
</code></pre>
    <p class="normal">From the source code above, we can see that:</p>
    <ul>
      <li class="bulletList">A <code class="inlineCode">BuildProperties</code> bean is injected into the filter’s constructor.</li>
      <li class="bulletList">The filter’s <code class="inlineCode">map()</code> method retrieves the microservice version from using the <code class="inlineCode">BuildProperties</code> bean and sets it as a low-cardinality tag on the provided observation context.</li>
    </ul>
    <p class="normal">The registry configuration bean looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ObservationRegistryConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ObservationRegistryCustomizer</span>&lt;ObservationRegistry&gt; {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BuildProperties buildProperties;
  <span class="hljs-keyword">public</span> <span class="hljs-title">ObservationRegistryConfig</span><span class="hljs-params">(BuildProperties buildProperties)</span> {
    <span class="hljs-built_in">this</span>.buildProperties = buildProperties;
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customize</span><span class="hljs-params">(</span><span class="hljs-keyword">final</span><span class="hljs-params"> ObservationRegistry registry)</span> {
    registry.observationConfig().observationFilter(<span class="hljs-keyword">new</span> <span class="hljs-title">BuildInfoObservationFilter</span>(buildProperties));
  }
}
</code></pre>
    <p class="normal">From the source code above, we can learn that:</p>
    <ul>
      <li class="bulletList">A <code class="inlineCode">BuildProperties</code> bean is also injected into the configuration class’s constructor.</li>
      <li class="bulletList">In the <code class="inlineCode">customize()</code> method, the filter is created and registered. The filter also gets the <code class="inlineCode">BuildProperties</code> bean injected here.</li>
    </ul>
    <p class="normal">The filter and the registry configuration bean can be found in the <code class="inlineCode">se.magnus.microservices.composite.product.services.tracing</code> package. When we try out the distributed tracing later in this chapter, we will see this observation filter in action.</p>
    <p class="normal">For more ways of handling custom spans, for example, setting up predicates for when to apply an observation<a id="_idIndexMarker990"/> filter or using annotations to describe an observation, see <a href="https://micrometer.io/docs/observation"><span class="url">https://micrometer.io/docs/observation</span></a>.</p>
    <p class="normal">That’s what it takes<a id="_idIndexMarker991"/> to add distributed tracing using Micrometer <a id="_idIndexMarker992"/>Tracing and Zipkin, so let’s try it out in the next section!</p>
    <h1 id="_idParaDest-369" class="heading-1">Trying out distributed tracing</h1>
    <p class="normal">With the necessary changes<a id="_idIndexMarker993"/> to the source code in place, we can try out distributed tracing. We will do this by performing the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Build, start, and verify the system landscape.</li>
      <li class="numberedList">Send a successful API request and see what trace information we can find in Zipkin related to this API request.</li>
      <li class="numberedList">Send an unsuccessful API request and see what error information we can find.</li>
      <li class="numberedList">Send a successful API request that triggers asynchronous processing and see how its trace information is represented.</li>
    </ol>
    <p class="normal">We will discuss these steps in detail in the upcoming sections.</p>
    <h2 id="_idParaDest-370" class="heading-2">Starting up the system landscape</h2>
    <p class="normal">Let’s start up<a id="_idIndexMarker994"/> the system landscape. Build the Docker images with the following commands:</p>
    <pre class="programlisting con"><code class="hljs-con">cd $BOOK_HOME/Chapter14
./gradlew build &amp;&amp; docker-compose build
</code></pre>
    <p class="normal">Start the system landscape in Docker and run the usual tests with the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">./test-em-all.bash start
</code></pre>
    <p class="normal">Before we can call the API, we need an access token. Run the following commands to acquire an access token:</p>
    <pre class="programlisting con"><code class="hljs-con">unset ACCESS_TOKEN
ACCESS_TOKEN=$(curl -k https://writer:secret-writer@localhost:8443/oauth2/token -d grant_type=client_credentials -d scope="product:read product:write" -s | jq -r .access_token)
echo $ACCESS_TOKEN
</code></pre>
    <div class="packt_tip">
      <p class="normal">As noticed in previous chapters, an access token issued by the authorization server is valid for one hour. So, if you start to get <code class="inlineCode">401 Unauthorized</code> errors after a while, it is probably time to acquire a new access token.</p>
    </div>
    <h2 id="_idParaDest-371" class="heading-2">Sending a successful API request</h2>
    <p class="normal">Now, we are ready <a id="_idIndexMarker995"/>to send a normal request to the API. Run the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">curl -H "Authorization: Bearer $ACCESS_TOKEN" -k https://localhost:8443/product-composite/1 -w "%{http_code}\n" -o /dev/null -s
</code></pre>
    <p class="normal">Expect the command to return the HTTP status code for success, <code class="inlineCode">200</code>.</p>
    <p class="normal">We can now launch the Zipkin UI to look into what trace information has been sent to Zipkin:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Open the following URL in your web browser: <code class="inlineCode">http://localhost:9411/zipkin/</code>.</li>
      <li class="numberedList">To find the trace information for our request, we can search for traces that have passed through the <code class="inlineCode">gateway</code> service. Perform the following steps:<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">Click on the large plus sign (a white <strong class="keyWord">+</strong> sign on a red background) and select <strong class="screenText">serviceName</strong> and then <strong class="screenText">gateway</strong>.</li>
          <li class="alphabeticList">Click on the <strong class="screenText">RUN</strong><strong class="keyWord"> </strong><strong class="screenText">QUERY</strong> button.</li>
          <li class="alphabeticList">Click on the <strong class="screenText">Start Time</strong> header to see the results ordered by the latest first (a down arrow should be visible to the left of the <strong class="screenText">Start Time</strong> header).</li>
        </ol>
      </li>
    </ol>
    <p class="normal">The response from finding<a id="_idIndexMarker996"/> traces should look like the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B19825_14_02.png" alt="A screenshot of a computer  Description automatically generated" width="812" height="481"/></figure>
    <p class="packt_figref">Figure 14.2: Searching for distributed traces using Zipkin</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">The trace information from our preceding API request is the first one in the list. Click on its <strong class="screenText">SHOW</strong> button to see details pertaining to the trace:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_14_03.png" alt="Graphical user interface, application  Description automatically generated" width="812" height="799"/></figure>
    <p class="packt_figref">Figure 14.3: Sample distributed trace visualized in Zipkin</p>
    <p class="normal">In the detailed trace<a id="_idIndexMarker997"/> information view, we can observe the following:</p>
    <ol class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList" value="1">The request was received by the <code class="inlineCode">gateway</code> service.</li>
      <li class="alphabeticList">The <code class="inlineCode">gateway</code> service delegated the processing of the request to the <code class="inlineCode">product-composite</code> service.</li>
      <li class="alphabeticList">The <code class="inlineCode">product-composite</code> service, in turn, sent three parallel requests to the core services: <code class="inlineCode">product</code>, <code class="inlineCode">recommendation</code>, and <code class="inlineCode">review</code>. See spans named <strong class="screenText">product-composite: http get</strong>.</li>
      <li class="alphabeticList">Once the <code class="inlineCode">product-composite</code> service received the response from all three core services, it created a composite response and sent it back to the caller through the <code class="inlineCode">gateway</code> service.</li>
      <li class="alphabeticList">The custom span created in the previous section is named <strong class="screenText">product-composite: product info</strong>. Click on it to see its tags. In the details view to the right, we can see both the tag created by the custom span, <strong class="screenText">productId = 1</strong>, and the tag created by the observation filter <strong class="screenText">build.version = 1.0.0-SNAPSHOT</strong>. </li>
      <li class="alphabeticList">To verify that the tag created by the observation filter works as expected, click on other spans created by the <code class="inlineCode">product-composite</code> service, and verify that the <strong class="screenText">build.version</strong> is present.</li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Select the span named <strong class="screenText">review: query</strong> to see a span reported by the <code class="inlineCode">review</code> microservice’s database layer:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_14_04.png" alt="Graphical user interface  Description automatically generated" width="812" height="475"/></figure>
    <p class="packt_figref">Figure 14.4: A span that describes the execution of a SQL query</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">In the span’s list of tags, we can see the actual SQL query it has performed. We can also see its execution time of 0.8 ms. Rather valuable information!</li>
    </ol>
    <p class="normal">To better understand how trace <a id="_idIndexMarker998"/>and span IDs are propagated between microservices, we can change the logging configuration of the <code class="inlineCode">product-composite</code> service so that HTTP headers in outgoing requests are written to its log. This can be achieved by taking the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add the following two lines to the configuration file <code class="inlineCode">config-repo/product-composite.yml</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">spring.codec.log-request-details:</span> <span class="hljs-literal">true</span>
<span class="hljs-attr">logging.level.org.springframework.web.reactive.function.client.ExchangeFunctions:</span> <span class="hljs-string">TRACE</span>
</code></pre>
      </li>
      <li class="numberedList">The two lines already exist in the configuration file but are commented out. They are preceded by the following comment:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># To see tracing headers, uncomment the following two lines and restart the product-composite service</span>
</code></pre>
      </li>
      <li class="numberedList">Find the preceding comment in the configuration file and uncomment the two lines below it. </li>
      <li class="numberedList">After that, restart the <code class="inlineCode">product-composite</code> service:
        <pre class="programlisting con"><code class="hljs-con">docker-compose restart product-composite
</code></pre>
      </li>
      <li class="numberedList">Display the log output from the <code class="inlineCode">product-composite</code> service:
        <pre class="programlisting con"><code class="hljs-con">docker-compose log -f --tail 0 product-composite
</code></pre>
      </li>
      <li class="numberedList">Rerun the above <code class="inlineCode">curl</code> request and you will see the log output containing the <code class="inlineCode">traceparent</code> HTTP header mentioned above. For example, a request sent to the <code class="inlineCode">recommendation</code> service:
        <pre class="programlisting con"><code class="hljs-con">chapter14-product-composite-1  | 2023-04-23T09:24:50.849Z TRACE [product-composite,e1420dcc38901378e888b8ce7022510e,06867b65cf84b552] 1 --- [     parallel-2] o.s.w.r.f.client.ExchangeFunctions       : [14606b71] HTTP GET http://d40874197b77:8080/recommendation?productId=1, headers=[traceparent:"00-e1420dcc38901378e888b8ce7022510e-06867b65cf84b552-01"]
</code></pre>
      </li>
      <li class="numberedList">In the sample log output, we can see the value of the <code class="inlineCode">traceparent</code> HTTP header, where the trace ID is set to <code class="inlineCode">e1420dcc38901378e888b8ce7022510e</code>, and the span ID is set to <code class="inlineCode">06867b65cf84b552</code>.</li>
      <li class="numberedList">If you don’t want to keep<a id="_idIndexMarker999"/> the logging of the <code class="inlineCode">traceparent</code> HTTP header, comment out the two lines in <code class="inlineCode">config-repo/product-composite.yml</code> and restart the <code class="inlineCode">product-composite</code> service.</li>
    </ol>
    <h2 id="_idParaDest-372" class="heading-2">Sending an unsuccessful API request</h2>
    <p class="normal">Let’s see what the trace information<a id="_idIndexMarker1000"/> looks like if we make an unsuccessful API request; for example, searching for a product that causes a timeout:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Send an API request for product ID <code class="inlineCode">1</code> and enforce a delay of three seconds, which will trigger the time limiter, and verify that it returns the HTTP status code <code class="inlineCode">500</code>:
        <pre class="programlisting con"><code class="hljs-con">curl -H "Authorization: Bearer $ACCESS_TOKEN" -k https://localhost:8443/product-composite/1?delay=3 -w "%{http_code}\n" -o /dev/null -s
</code></pre>
      </li>
      <li class="numberedList">In the Zipkin UI, go back to the search page (use the back button in the web browser) and click on the <strong class="screenText">RUN QUERY</strong> button again. To see the results ordered by the latest first, click on the <strong class="screenText">Start Time</strong> header. </li>
    </ol>
    <p class="numberedList">Expect a result similar to the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B19825_14_05.png" alt="A screenshot of a computer  Description automatically generated" width="812" height="336"/></figure>
    <p class="packt_figref">Figure 14.5: Finding a failed request using Zipkin</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">You should see the failed request<a id="_idIndexMarker1001"/> at the top of the returned list. Note that its duration bar is red, indicating that an error has occurred. Click on its <strong class="screenText">SHOW</strong> button to see details:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_14_06.png" alt="A screenshot of a computer error  Description automatically generated" width="812" height="236"/> </figure>
    <p class="packt_figref">Figure 14.6: Viewing a trace of a failed request using Zipkin</p>
    <p class="normal">Here, we can see a span, <strong class="screenText">product-composite: secured request</strong>, with an error symbol in front of it (a red circle with an exclamation mark). </p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Click on the span to see its tags. You will find a tag named <strong class="screenText">error</strong> that clearly indicates that the error<a id="_idIndexMarker1002"/> is caused by a timeout that occurred after two seconds.</li>
    </ol>
    <h2 id="_idParaDest-373" class="heading-2">Sending an API request that triggers asynchronous processing</h2>
    <p class="normal">The third type of request<a id="_idIndexMarker1003"/> that is interesting to see represented in the Zipkin UI is a request where parts of its processing are done asynchronously. Let’s try a delete request, where the delete process in the core services is done asynchronously. </p>
    <p class="normal">The <code class="inlineCode">product-composite</code> service sends a delete event to each of the three core services over the message broker and each core service picks up the delete event and processes it asynchronously. Thanks to Micrometer Tracing, trace information is added to the events that are sent to the message broker, resulting in a coherent view of the total processing of the delete request.</p>
    <p class="normal">Perform the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Run the following command to delete the product with a product ID of <code class="inlineCode">12345</code> and verify that it returns the HTTP status code for the request being accepted, <code class="inlineCode">202</code>:
        <pre class="programlisting con"><code class="hljs-con">curl -X DELETE -H "Authorization: Bearer $ACCESS_TOKEN" -k https://localhost:8443/product-composite/12345 -w "%{http_code}\n" -o /dev/null -s
</code></pre>
      </li>
    </ol>
    <div class="packt_tip">
      <p class="normal">Remember that the delete operation is idempotent, that is, it will succeed even if the product doesn’t exist!</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">In the Zipkin UI, go back to the search page (use the back button in the web browser) and click on the <strong class="screenText">RUN QUERY</strong> button again. To see the results ordered by the latest first, click on the <strong class="screenText">Start Time</strong> header. Expect a result like the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_14_07.png" alt="A screenshot of a computer  Description automatically generated" width="812" height="329"/></figure>
    <p class="packt_figref">Figure 14.7: Finding a delete request using Zipkin</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">You should see the delete<a id="_idIndexMarker1004"/> request at the top of the returned list. Note that the root service name, <strong class="screenText">gateway</strong>, is suffixed by the HTTP method used, <strong class="screenText">delete</strong>. Click on its <strong class="screenText">SHOW</strong> button to see details:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_14_08.png" alt="A screenshot of a computer  Description automatically generated" width="812" height="912"/></figure>
    <p class="packt_figref">Figure 14.8: Viewing a delete request using Zipkin</p>
    <p class="normal">Here, we can see the trace information for processing the delete request:</p>
    <ol class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList" value="1">The request was received by the <code class="inlineCode">gateway</code> service.</li>
      <li class="alphabeticList">The <code class="inlineCode">gateway</code> service delegated the processing of the request to the <code class="inlineCode">product-composite</code> service.</li>
      <li class="alphabeticList">The <code class="inlineCode">product-composite</code> service has created a custom span named <strong class="screenText">product-composite: product info</strong>, as expected.</li>
      <li class="alphabeticList">The <code class="inlineCode">product-composite</code> service, in turn, published three events on the message broker (RabbitMQ, in this case). See spans with names suffixed with <strong class="screenText">send</strong>.</li>
      <li class="alphabeticList">The <code class="inlineCode">product-composite</code> service is now done and returns an HTTP <code class="inlineCode">success</code> status code, <code class="inlineCode">200</code>, through the <code class="inlineCode">gateway</code> service back to the caller. Note that this is done before all processing is completed by the core services!</li>
      <li class="alphabeticList">The core services (<code class="inlineCode">product</code>, <code class="inlineCode">recommendation</code>, and <code class="inlineCode">review</code>) receive the <code class="inlineCode">delete</code> events and start to process them asynchronously, that is, independently of one another. See spans with names suffixed with <strong class="screenText">receive</strong>.</li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">To confirm the involvement<a id="_idIndexMarker1005"/> of the message broker, click on the first product span: <figure class="mediaobject"><img src="../Images/B19825_14_09.png" alt="A screenshot of a computer  Description automatically generated" width="812" height="349"/> </figure>
        <p class="packt_figref">Figure 14.9: Viewing information about the asynchronous processing of an event using Zipkin</p>
        <p class="normal">The selected span contains a tag named <strong class="screenText">peer.service</strong> that reveals that RabbitMQ is used, and the tag <strong class="screenText">spring.rabbit.listener.id</strong> points out that the messages are received by the consumer group <strong class="screenText">productsGroup</strong>.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Finally, to see the <code class="inlineCode">traceparent</code> header in a message sent through RabbitMQ, we can inspect the message stored in the audit queue for the products. Open <a href="http://localhost:15672/#/queues/%2F/products.auditGroup"><span class="url">http://localhost:15672/#/queues/%2F/products.auditGroup</span></a> in your web browser.</li>
      <li class="numberedList">Click on the button named <strong class="screenText">Get Messages(s)</strong> to see the oldest message in the queue. The web page should look like the following:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_14_10.png" alt="Graphical user interface, text, application  Description automatically generated" width="812" height="524"/></figure>
    <p class="packt_figref">Figure 14.10: A message with a traceparent header in RabbitMQ</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">In the <strong class="screenText">Properties</strong> section, you will find the <strong class="screenText">traceparent</strong> header for this message. In this case, the trace ID is <strong class="screenText">99a9f2501e4d454643184c6b1cb0a232</strong> and the span ID is <strong class="screenText">7458430fe56d6df1</strong>.</li>
    </ol>
    <p class="normal">This completes the tests of distributed tracing<a id="_idIndexMarker1006"/> for this chapter!</p>
    <div class="packt_tip">
      <p class="normal">The Zipkin UI contains much more functionality for finding traces of interest!</p>
      <p class="normal">To get more accustomed to the Zipkin UI, try out the query functionality by clicking on the plus sign and selecting <strong class="screenText">tagQuery</strong>. For example, to find requests that failed on a <code class="inlineCode">403 - Forbidden</code> error, set its value to <code class="inlineCode">tagQuery=http.status_code=403</code>, searching for traces that failed on a Forbidden (<code class="inlineCode">403</code>) error. Also, try setting limits for the lookback range (start and end time) and the maximum number of hits by clicking on the cogwheel icon to the right of the <strong class="screenText">RUN QUERY</strong> button.</p>
    </div>
    <p class="normal">Wrap up the tests by bringing down the system<a id="_idIndexMarker1007"/> landscape. Run the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">docker-compose down
</code></pre>
    <h1 id="_idParaDest-374" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we learned how to use distributed tracing to understand how our microservices cooperate. We learned how to use Micrometer Tracing to collect trace information, and Zipkin to store and visualize the trace information.</p>
    <p class="normal">We saw how adding Micrometer Tracing to microservices is affected by adding a couple of dependencies to the build files and setting up a few configuration parameters. Reactive microservices are currently not fully supported, but we learned how to work around the most important issues. If required, we can use the <code class="inlineCode">Observation</code> API to create custom spans or add tags to all spans created by a microservice. We also saw how the Zipkin UI makes it very easy to identify which part of a complex workflow caused either an unexpectedly long response time or an error. Both synchronous and asynchronous workflows can be visualized with the Zipkin UI.</p>
    <p class="normal">In the next chapter, we will learn about container orchestrators, specifically Kubernetes. We will learn how to use Kubernetes to deploy and manage microservices, while also improving important runtime characteristics such as scalability, high availability, and resilience.</p>
    <h1 id="_idParaDest-375" class="heading-1">Questions</h1>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">What is the purpose of the <code class="inlineCode">management.tracing.sampling.probability</code> configuration parameter?</li>
      <li class="numberedList">How can you identify the longest-running request after executing the <code class="inlineCode">test-em-all.bash</code> test script?</li>
      <li class="numberedList">How can we find requests that have been interrupted by a timeout introduced in <em class="chapterRef">Chapter 13</em>, <em class="italic">Improving Resilience Using Resilience4j</em>?</li>
      <li class="numberedList">What does the trace look like for an API request when the circuit breaker introduced in <em class="chapterRef">Chapter 13</em>, <em class="italic">Improving Resilience Using Resilience4j</em>, is open?</li>
      <li class="numberedList">How can we locate APIs that failed on the caller not being authorized to perform the request?</li>
      <li class="numberedList">How can we programmatically add trace information?</li>
    </ol>
  </div>
</div>
</div>
</body></html>