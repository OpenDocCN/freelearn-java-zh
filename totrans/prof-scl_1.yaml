- en: Chapter 1. Setting up the Development Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start writing the various programs in this book, let's talk a little
    about the Scala language itself. Why is it necessary, and what has made Scala
    unique? What are the most important aspects of the language?
  prefs: []
  type: TYPE_NORMAL
- en: Scala was created in 2001 in EPFL (École Polytechnique Fédérale de Lausanne),
    by Martin Odersky. This is the same lab where Pascal language (widely used up
    to the end of the 1990s) was created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scala is an abbreviation for ''Scalable Language''—a language which can be
    scaled, that is, it allows you to write complex systems with gigantic amounts
    of functionality. As specified on Scala''s home page: " *Scala combines object-oriented
    and functional programming in one concise, high-level language.*"'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can visit Scala''s official home page here: [https://www.scala-lang.org/](https://www.scala-lang.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Recognize the structure of a Scala project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify the use of Scala's sbt tool (interactive build tool) for building and
    running your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify how to use the IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement interactions with a simple chatbot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala is built on top of the JVM platform (the Scala program is compiled to
    use JVM bytecode).
  prefs: []
  type: TYPE_NORMAL
- en: Now, the language is used as one of the most preferred platforms in many areas,
    such as high-load soft-realtime applications, ad servers for data science toolkits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some characteristics of Scala are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An advanced type system, which makes Scala superior (but at the same time, more
    complex) compared to most other industrial programming languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static typing, which allows you to write code in a safe way when errors are
    checked during compilation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will learn the basics of Scala, such as what the simple
    Scala program looks like and what a typical developer flow is. A significant part
    of development is interaction with tools—build tools, dependency extractors, IDEs,
    and so on, which form the tool ecosystem with the language. We will build a simple
    program using mainstream tools.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be covering the structure of a basic Scala program.
    We will be covering definitions such as packages, imports, and objects. We will
    also be looking into the main method of a Scala program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the simplest possible program in Scala. We will implement a program
    which will print "Hello World" on the screen. The structure of this program is
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Definitions: Packages, Imports, and Objects'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you look at the preceding code, the first line is a package name. In our
    case, this is `com.packt.courseware`.
  prefs: []
  type: TYPE_NORMAL
- en: All compilation units are organized into packages. Packages can be nested, forming
    hierarchical namespaces for code objects.
  prefs: []
  type: TYPE_NORMAL
- en: When a compilation unit has no package declaration, it belongs to a so-called
    ' `default`' package. Modules from a default package can't be imported from another
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the source directory in a Scala project is organized in the same way
    as packages. This is not mandatory, but becomes a rule of thumb. Some tools (such
    as IDEs) use these conventions for default project settings.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will look at `import` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Object Definition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, we define the object `Chatbot1.`
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are familiar with the traditional classes, since they are implemented
    in Java, you can look at the object of a class with one default instance, that
    is, an object is an implementation of the singleton pattern: on the JVM level,
    the object definition creates a class and one predefined instance of this class.'
  prefs: []
  type: TYPE_NORMAL
- en: The main Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, the `main` method is an entry point for our program. It must accept
    an array of strings (command-line arguments) and return a unit.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, the `main` method name is used in Scala. This is because the Java
    language is following the same tradition, which takes the name of an entry method
    from C, which take this from BCPL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Inside main
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `main` method is an essential part of any Scala program. The execution of
    a program first starts from the `main` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look inside the `main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define an immutable value with the name `name`, which keeps the user's
    input from `stdin`. Scala is a statically typed language, and so the value is
    of type `String`.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the type of the value is not explicitly written, but automatically
    inferred from its context.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the next line, the value is printed using the "string interpolation" operator:
    In a string with a prefix of `s`, all occurrences of expressions inside `${}`
    brackets in strings are replaced with values of these expressions, casted to strings.
    For simple identifiers, we can `omit {}` brackets, for example, in a string interpolation
    of `s"x=$y"`, the value of y will be substituted instead with `$y`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`var timeToBye` is a mutable variable with a `Boolean` type. Unlike values,
    mutable variables can be assigned more than once.'
  prefs: []
  type: TYPE_NORMAL
- en: Looking forward at the loop, we can see that the program is trying to be a good
    listener and answer `interesting` to any message, except `bye`.
  prefs: []
  type: TYPE_NORMAL
- en: The result of the case statement is assigned to `timeToBye`, and is checked
    in the `while` loop condition
  prefs: []
  type: TYPE_NORMAL
- en: Scala, as a multiparadigm language, has both mutable and immutable variables.
    For nearly any task, we can choose more than one way of implementing this.
  prefs: []
  type: TYPE_NORMAL
- en: If guidelines exist, where should we use mutable variables and where should
    we use immutable variables?
  prefs: []
  type: TYPE_NORMAL
- en: Generally, reasoning about immutable variables is simpler. The usual heuristic
    is to use immutable values as much as possible, leaving mutable variables for
    performance-critical sections and state-check language constructs (such as while
    loops).
  prefs: []
  type: TYPE_NORMAL
- en: In our small example, we can eliminate the mutable flag by putting an expression
    for the loop exit condition inside `while`. The resulting code is smaller and
    better to read, but adding new functionality becomes harder. Yet there is one
    possibility—use the `recursive` function instead of the loop language construction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add some functionality to our `chatbot`: when the user asks for
    the `time`, the `chatbot` should report the current time.'
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we must retrieve the current time using the Java API and display
    the output of the time using string interpolators.
  prefs: []
  type: TYPE_NORMAL
- en: For example, use the `now` method of `java.time.LocalTime.`
  prefs: []
  type: TYPE_NORMAL
- en: The code used to display this will be `println("time is ${java.time.LocalTime.now()}").`
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for this functionality, but we will actually implement
    this after setting up the working environment we will be playing with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Structure of a Scala Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at our `chatbot` program in a complete runnable project. Let's navigate
    to the `/day1-lesson1/1-project` directory in our code supplement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code is available on Github at the following link: [https://github.com/TrainingByPackt/Professional-Scala](https://github.com/TrainingByPackt/Professional-Scala)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram is the typical directory structure of a Scala project.
    If you are familiar with the Java tools ecosystem, then you will notice the similarities
    between the `maven` project layout.
  prefs: []
  type: TYPE_NORMAL
- en: In `src`, we can see project sources ( `main` and `test`). `target` is a place
    where output artifacts are created, whereas `project` is used as a place to internally
    build the project. We will cover all of these concepts later on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The head of any project is its `build.sbt` file. It consists of the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: The text inside it is a plain Scala snippet.
  prefs: []
  type: TYPE_NORMAL
- en: '`organization`, `name`, and `version` are instances of `sbt.key`. For this
    point of view, `:=` is a binary operator defined on `keys`. In Scala, any method
    with two arguments can be used with the syntax of a binary operator. `:=` is a
    valid method name.'
  prefs: []
  type: TYPE_NORMAL
- en: '`build.sbt` is interpreted by the `sbt` tool.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`sbt` – The original intention for the name, when `sbt` was created by Mark
    Harrah, was '' `Simple Build Tool`''. Later on, the author decided to avoid such
    a decipherment, and kept it as it was. You can read about the details of `sbt`
    here: [https://www.scala-sbt.org/1.x/docs/index.html](https://www.scala-sbt.org/1.x/docs/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Basic sbt Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now talk about the basic `sbt` commands.
  prefs: []
  type: TYPE_NORMAL
- en: '`sbt` compile should compile the project and live somewhere in its target compiled
    Java classes.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sbt run` executes the `main` function of the project. Therefore, we can try
    to interact with our `chatbot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sbt package` prepares an output artifact. After running it, it will create
    file called `target/chatbot1_2.12-0.1-SNAPSHOT.jar`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`chatbot1` is the name of our project; `0.1-SNAPSHOT – version. 2.12` is the
    version of the Scala compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: Scala guarantees binary compatibility only within the scope of a minor version.
    If, for some reason, the project still uses `scala-2.11`, then it must use the
    library, which was created for `scala-2.11`. On the other hand, updating to the
    next compiler version can be a long process for projects with many dependencies.
    To allow the same library to exist in the repository with different `scalaVersions`,
    we need to have an appropriate suffix in the jar file.
  prefs: []
  type: TYPE_NORMAL
- en: '`sbt publish-local` – publishes the artifact on to your local repository.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see our sample project and `sbt` tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Performing Basic Operations with sbt: Build, Run, Package'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Install sbt on your computer, if not installed beforehand.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the `sbt` console by typing `sbt console` in the root directory of the
    `1-project` (where `build.sbt` is situated).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the code by typing the `compile` command into the `sbt` console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the program by typing the `sbt run` command into the `sbt` console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When running this, say `bye` to the bot and return to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Package the program by typing `package` into the `sbt` console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another part of the developer toolbox is an IDE tool (Integrated Development
    Environment). For our book, we will use Intellij IDEA community edition with the
    Scala plugin. This is not the only option: other alternatives are scala-ide, based
    on IBM Eclipse and Ensime ([http://ensime.github.io/](http://ensime.github.io/)),
    which brings IDE features to any programmable text editors, from vi to emacs.'
  prefs: []
  type: TYPE_NORMAL
- en: All tools support importing the project layout from `build.sbt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Loading and Running a Sample Project in the IDE'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to `File` -> `Import` -> navigate to `build.sbt`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open the program in IDE:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start IDEA
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Press `Open`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select `day1-lesson1/1-project/build.sbt`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the dialog window, which asks whether to open it as a file or as a project,
    select `project`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the left part of the project's structure, unfold `src` entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on `main.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that you can see `main`, as specified in the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that project can be compiled and run via the `sbt` console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For running our project from the IDE, we should edit the project''s configuration
    (Menu: `Build`/ `Edit configuration` or `Run`/ `Edit` configuration, depending
    on which version of IDEA you are using).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Running the Project from IDE:**'
  prefs: []
  type: TYPE_NORMAL
- en: Select `Run`/`Edit Configuration.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Application`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the application's name. In our case, use `Chatbot1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the name of the `Main` class. In our case, it must be `com.packt.courseware.Chatbot1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Actually run the application: select Run, then Chatbot1 from the dropdown menu.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another tool that we will frequently use is REPL (Read Eval Print Loop). It
    is often used for quickly evaluating Scala expressions.
  prefs: []
  type: TYPE_NORMAL
- en: From `sbt`, we can enter REPL mode with the help of the `sbt console` command.
    Let's try some simple expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll look at how to evaluate expressions. Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `sbt` tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `REPL` by typing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Type the following expressions and press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2 + 2`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"2" + 2`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2 + "2"`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(1 to 8).sum`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.time.LocalTime.now()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Please note that we can have an interactive Scala `playboard` inside IDE by
    creating a special file type: a Scala Worksheet. It''s useful, but is mainly for
    demonstration purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the Time Request from Our Chatbot Program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For now, let''s return to our task: modifying the `chatbot` program so that
    it replies with the current time, as requested by the use of `time`. Let''s learn
    how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps for C** **ompletion**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check for `time` to match the statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Retrieve the current time using the Java API. Use the `now` method of `java.time.LocalTime`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Display the output of the time using string interpolators, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `main` method will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: After we prepare and package our artifacts, we need to run them as well.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will use the running system from unpackaged sources via `sbt`
    (as in the early days of Ruby applications), assuming that sources and `sbt` tools
    are accessible from the production environment. Using this, we can use build tool
    commands for sources such as `sbt run`. In real life, packaging for production
    is a bit more complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'Popular methods for doing this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Preparing a fat jar (which includes all dependencies). An `sbt` plugin for
    this exists, which can be found at the following link: [https://github.com/sbt/sbt-assembly](https://github.com/sbt/sbt-assembly).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Preparing a native system package (which includes jars, dependencies, custom
    layouts, and so on). There is also an `sbt` plugin to create native system packages,
    which can be found at the following link: [https://github.com/sbt/sbt-native-packager](https://github.com/sbt/sbt-native-packager).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can use REPL, let's understand the base Scala syntax. For now, it's
    not necessary to learn it in detail, but let's get familiar with it by using an
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For a formal, detailed description, refer to the SLS: Scala Language Specification
    here: [http://scala-lang.org/files/archive/spec/2.12/](http://scala-lang.org/files/archive/spec/2.12/).'
  prefs: []
  type: TYPE_NORMAL
- en: Base Syntax for Definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scala compilation unit – This is a set of definitions inside an entity (template-entity),
    which can be an object, a class, or a trait. We will speak about the Object-Oriented
    part of the Scala language in detail later. Now, let''s look at the basic syntax.
    Let''s define some classes in REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Definitions inside the entity can be nested entities, functions, or values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the function `f` is defined, returning `1`. We will talk about this function
    in detail in [Chapter 3](ch03.html "Chapter 3. Functions"), *Functions*. Now,
    let''s stay on the top-level view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the value `x` is defined with value `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, the mutable variable `y` is defined with value `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other high-level entities include objects and traits. We can create objects
    by writing object or trait definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We will talk about classes, objects, and traits in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at defining an object in REPL with the name ZeroPoint.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps for Completion:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open REPL by typing the following command in `sbt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Type in the following commands in REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Base Syntax for Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scala is an expression-based language, which means that everything is an expression
    (in the right-hand side of function and value/variable definitions).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the base expressions are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Primitive expression: Constant or value/variable name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Function calls: These can be:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usual function calls `f(x, y)`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Operator call syntax:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'binary: `x + y`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Any method with an argument can be used as a binary operator. A set of predefined
    binary operators are similar to Java:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'unary: `!x`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Constructors: `new x` creates an instance of class x.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assignments to mutable variables:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y = 3`: Assigns a value of `3` to `y`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x = 3`: This is a compiler error, and a value can''t be assigned.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Block:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The value of a block expression is the last expression. Note that `;` can be
    omitted if `A` and `B` are situated on different lines. The syntax for this is
    shown as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding syntax will have the same output as `{ A; B }`.
  prefs: []
  type: TYPE_NORMAL
- en: Control structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if` statement:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'match/case expressions:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Loops:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while`/`do`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`Do`/`while`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Foreach`, `for`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Shortcuts for height-order functions will be described in detail in, [Chapter
    4](ch04.html "Chapter 4. Scala Collections"), *Scala Collections*.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at defining a main function which prints something onscreen and calls
    the main function.
  prefs: []
  type: TYPE_NORMAL
- en: You should have already opened `project1`. If you haven't, import it into the
    IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the new method inside the object definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert call at the `main` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The full method should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any program which is bigger than arithmetic operations, programmers should
    make themselves comfortable when it is possible to ensure that new changes are
    not breaking old functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: The most common technique for this is unit testing, which is where the programmer
    tests the functionality of the code in parallel with its development by creating
    a test code which will verify that the code really satisfies their requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The theme of this section will be introducing tools for unit testing in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Test to Our Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's add tests to our small program. We'll import `<for-students/lesson1/2-project>`
    in our IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the directory schema of a Scala project. For adding tests, we should
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add test dependencies to `build.sbt`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write tests in the source test directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For adding dependency, let''s add the following line to our `build.sbt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s an expression in Scala DSL (domain-specific language), which means that
    we should add `scalatest` to our set of library dependencies. Operators `%%` and
    `%` are used for forming the name and classifier for published artifacts. You
    can refer to the `sb` `t` documentation for more detail: [http://www.scala-sbt.org/1.x/docs/Library-Dependencies.html](http://www.scala-sbt.org/1.x/docs/Library-Dependencies.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Before compilation, `sbt` will download `scalatest` from a publicly available
    repository (Maven central), and when running tests, it will add `scalatest` to
    the classpath.
  prefs: []
  type: TYPE_NORMAL
- en: We will now run `sbt` tests from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the command-line environment, navigate to the root of the project and select
    the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are using a Unix/Linux machine and your code is situated in `courses/pactscala`
    of your home `directory`, then run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the following command`:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will get the expected output, which will include the following strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will now see how to run `sbt` tests from IDEA IDE.
  prefs: []
  type: TYPE_NORMAL
- en: We'll now run sbt Tests from IDEA IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in the IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Run**/**Edit Configurations:**![Adding a Test to Our Project](img/1_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose s`bt test` as the configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the checkbox **Use sbt:**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Adding a Test to Our Project](img/1_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Select **Run sbt-test**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s look at a simple test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a class which is inherited from scalatest FunSuite.
  prefs: []
  type: TYPE_NORMAL
- en: The test expression is called. When the `FunSuite` class is initialized and
    added to a set of tests, the test with `name example test should pass` and assert
    an expression as an argument. For now, this looks like magic, but we will show
    you how to build such DSLs in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run our test with the help of `sbt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This command will run all tests and evaluate the test expression.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll add another test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add one more test to the same file: `src/test/scala/com/packt/courseware/l1/ExampleSpec.scala
    in 2-project`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We write one `trivial` test, which asserts the `false` expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the test and look at error reporting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Invert the expression in assert so that the test passes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the `sbt` test again to ensure that all of the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running Tests for Chatbot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that, when writing `chatbot`, we want to test one functionality. Our
    original program only has one function ( `main`), which contains all of the logic
    and can't be split into testable parts.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at Version 2.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please import `Lesson 1/2-project` into your IDE.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see some new constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LineProcessingResult` is a case class, where the result of processing one
    of the lines (that is, the `chatbot` answer and quit flag) is stored.'
  prefs: []
  type: TYPE_NORMAL
- en: What is the word `case` before class?
  prefs: []
  type: TYPE_NORMAL
- en: '`case` classes can participate in pattern matching (while we call one `case`)
    and are usually used for data objects. We will look at `case` classes during the
    next chapter. It is important to see that an instance of `case` classes can be
    created with the `LineProcessingResult(x,y)` syntax (that is, without `new`) and
    an argument to case class constructors ( `answers` and `timeToBye`), which automatically
    become instance variables of the `case` class.'
  prefs: []
  type: TYPE_NORMAL
- en: The functionality of processing one line is encapsulated in the `step` method,
    which we can test.
  prefs: []
  type: TYPE_NORMAL
- en: '`Step` receives input from the method argument, not from `System.in`, therefore
    making it easier to test. In the case of directly testing the `main` method, we
    will need to substitute `System.in` before `test` and return one back after the
    test is finished.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, let''s focus on the first test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Writing the second test in the same manner will be an easy task. We will look
    at this in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's add the second test, which checks bye.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a second test to the `StepTestSpec` class in our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Call the step function with `bye` as a parameter:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Check that after this call that `timeToQuit` in the returned class is set to
    `true`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The whole code should be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run `sbt test.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A more complex task would be to write a test for the time query.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that we can't run the test with the concrete time value, but at
    least we can be sure that the bot answer can't be parsed back to the time form.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what can we do to check the line answer and try to transform it back to
    time? The solution is provided in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note that assertion is not necessary. If time does not satisfy the given format,
    then an exception will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good practice to separate functional and effects time for testing. To
    do this, we will need to substitute the provider of the system time via own.
  prefs: []
  type: TYPE_NORMAL
- en: This will be the first practical task in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's add the date command to our chatbot program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the match statement so that it checks for the `date`
    command, which should output the local date in `DD:MM:YYYY` format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a test case for this function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The resulting code will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have reached the end of the chapter. In this chapter, we learned various
    aspects of setting up the development environment. We covered the structure of
    a Scala project, and we identified the use of `sbt` for building and running projects.
    We covered REPL, which is a command-line interface for running Scala code. We
    also covered how to develop and run code over the IDEA IDE. Finally, we implemented
    interactions with our simple `chatbot` application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the structure of a Scala program and dive
    deep into the object-oriented properties in Scala, such as like classes, objects,
    and traits. We will also cover the syntax for calling functions and various parameter-passing
    models.
  prefs: []
  type: TYPE_NORMAL
