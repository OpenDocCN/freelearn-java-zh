- en: Chapter 1. Setting up the Development Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章：设置开发环境
- en: Before we start writing the various programs in this book, let's talk a little
    about the Scala language itself. Why is it necessary, and what has made Scala
    unique? What are the most important aspects of the language?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写本书中的各种程序之前，让我们先简单谈谈 Scala 语言本身。为什么它是必要的，是什么让它变得独特？语言最重要的方面是什么？
- en: Scala was created in 2001 in EPFL (École Polytechnique Fédérale de Lausanne),
    by Martin Odersky. This is the same lab where Pascal language (widely used up
    to the end of the 1990s) was created.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 是由 Martin Odersky 在 2001 年在洛桑联邦理工学院（EPFL）创建的。这是 Pascal 语言（在 1990 年代末广泛使用）被创建的同一个实验室。
- en: 'Scala is an abbreviation for ''Scalable Language''—a language which can be
    scaled, that is, it allows you to write complex systems with gigantic amounts
    of functionality. As specified on Scala''s home page: " *Scala combines object-oriented
    and functional programming in one concise, high-level language.*"'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 是 'Scalable Language' 的缩写——一种可扩展的语言，也就是说，它允许你编写具有巨大功能复杂性的复杂系统。如 Scala
    的主页所述：" *Scala 将面向对象和函数式编程结合在一个简洁、高级的语言中。*"
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can visit Scala''s official home page here: [https://www.scala-lang.org/](https://www.scala-lang.org/)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里访问 Scala 的官方网站：[https://www.scala-lang.org/](https://www.scala-lang.org/)
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Recognize the structure of a Scala project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别 Scala 项目的结构
- en: Identify the use of Scala's sbt tool (interactive build tool) for building and
    running your project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别 Scala 的 sbt 工具（交互式构建工具）的使用，用于构建和运行你的项目
- en: Identify how to use the IDE
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别如何使用 IDE
- en: Implement interactions with a simple chatbot
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现与简单聊天机器人的交互
- en: Scala is built on top of the JVM platform (the Scala program is compiled to
    use JVM bytecode).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 是建立在 JVM 平台之上的（Scala 程序被编译为使用 JVM 字节码）。
- en: Now, the language is used as one of the most preferred platforms in many areas,
    such as high-load soft-realtime applications, ad servers for data science toolkits.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，该语言被用作许多领域中最受欢迎的平台之一，例如高负载软实时应用、数据科学工具包的广告服务器。
- en: 'Some characteristics of Scala are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 的一些特性如下：
- en: An advanced type system, which makes Scala superior (but at the same time, more
    complex) compared to most other industrial programming languages.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个高级类型系统，这使得 Scala 相比于大多数其他工业编程语言更优越（但同时也更复杂）。
- en: Static typing, which allows you to write code in a safe way when errors are
    checked during compilation.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态类型，它允许你在编译时检查错误，以安全的方式编写代码。
- en: In this chapter, we will learn the basics of Scala, such as what the simple
    Scala program looks like and what a typical developer flow is. A significant part
    of development is interaction with tools—build tools, dependency extractors, IDEs,
    and so on, which form the tool ecosystem with the language. We will build a simple
    program using mainstream tools.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 Scala 的基础知识，例如简单的 Scala 程序是什么样的，以及典型的开发者流程是什么。开发的一个重要部分是与工具的交互——构建工具、依赖提取器、IDE
    等，这些工具与语言一起形成了工具生态系统。我们将使用主流工具构建一个简单的程序。
- en: Simple Program
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单程序
- en: In this section, we will be covering the structure of a basic Scala program.
    We will be covering definitions such as packages, imports, and objects. We will
    also be looking into the main method of a Scala program.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍基本 Scala 程序的结构。我们将介绍包、导入和对象等定义。我们还将探讨 Scala 程序的 main 方法。
- en: 'Let''s create the simplest possible program in Scala. We will implement a program
    which will print "Hello World" on the screen. The structure of this program is
    defined as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Scala 中创建最简单的程序。我们将实现一个在屏幕上打印 "Hello World" 的程序。该程序的结构如下定义：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Definitions: Packages, Imports, and Objects'
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义：包、导入和对象
- en: If you look at the preceding code, the first line is a package name. In our
    case, this is `com.packt.courseware`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看前面的代码，第一行是一个包名。在我们的例子中，这是 `com.packt.courseware`。
- en: All compilation units are organized into packages. Packages can be nested, forming
    hierarchical namespaces for code objects.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所有编译单元都组织到包中。包可以嵌套，形成代码对象的分层命名空间。
- en: When a compilation unit has no package declaration, it belongs to a so-called
    ' `default`' package. Modules from a default package can't be imported from another
    package.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个编译单元没有包声明时，它属于所谓的 ' `default`' 包。默认包中的模块不能从另一个包导入。
- en: Usually, the source directory in a Scala project is organized in the same way
    as packages. This is not mandatory, but becomes a rule of thumb. Some tools (such
    as IDEs) use these conventions for default project settings.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Scala 项目的源目录组织方式与包相同。这并非强制要求，但已成为一个经验法则。一些工具（如 IDE）使用这些约定作为默认项目设置。
- en: Now we will look at `import` statements.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看看 `import` 语句。
- en: Object Definition
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象定义
- en: Here, we define the object `Chatbot1.`
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们定义了对象 `Chatbot1.`。
- en: 'If you are familiar with the traditional classes, since they are implemented
    in Java, you can look at the object of a class with one default instance, that
    is, an object is an implementation of the singleton pattern: on the JVM level,
    the object definition creates a class and one predefined instance of this class.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉传统的类，因为它们是用 Java 实现的，你可以查看具有一个默认实例的类对象，即对象是单例模式的实现：在 JVM 层面上，对象定义创建了一个类和一个预定义的该类实例。
- en: The main Method
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主要方法
- en: Finally, the `main` method is an entry point for our program. It must accept
    an array of strings (command-line arguments) and return a unit.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`main` 方法是程序的入口点。它必须接受一个字符串数组（命令行参数）并返回一个单位。
- en: Historically, the `main` method name is used in Scala. This is because the Java
    language is following the same tradition, which takes the name of an entry method
    from C, which take this from BCPL.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，Scala 中使用 `main` 方法名称。这是因为 Java 语言遵循相同的传统，从 C 语言中继承了入口方法的名称，而 C 语言又从 BCPL
    中继承了这一传统。
- en: 'The method is defined as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 方法定义如下：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Inside main
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 `main` 方法内
- en: The `main` method is an essential part of any Scala program. The execution of
    a program first starts from the `main` method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 方法是任何 Scala 程序的一个基本部分。程序的执行首先从 `main` 方法开始。'
- en: 'Let''s look inside the `main` method:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `main` 方法内部：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we define an immutable value with the name `name`, which keeps the user's
    input from `stdin`. Scala is a statically typed language, and so the value is
    of type `String`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用名称 `name` 定义了一个不可变值，它保存了从 `stdin` 的用户输入。Scala 是一种静态类型语言，因此该值是 `String`
    类型。
- en: As we can see, the type of the value is not explicitly written, but automatically
    inferred from its context.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，值的类型没有明确写出，而是从其上下文中自动推断出来的。
- en: 'At the next line, the value is printed using the "string interpolation" operator:
    In a string with a prefix of `s`, all occurrences of expressions inside `${}`
    brackets in strings are replaced with values of these expressions, casted to strings.
    For simple identifiers, we can `omit {}` brackets, for example, in a string interpolation
    of `s"x=$y"`, the value of y will be substituted instead with `$y`.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，使用“字符串插值”运算符打印值：在一个以 `s` 为前缀的字符串中，所有 `${}` 括号内的表达式都会被这些表达式的值替换，并转换为字符串。对于简单的标识符，我们可以省略
    `{}` 括号，例如，在 `s"x=$y"` 的字符串插值中，y 的值将被替换为 `$y`。
- en: '`var timeToBye` is a mutable variable with a `Boolean` type. Unlike values,
    mutable variables can be assigned more than once.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`var timeToBye` 是一个具有 `Boolean` 类型的可变变量。与值不同，可变变量可以被赋值多次。'
- en: Looking forward at the loop, we can see that the program is trying to be a good
    listener and answer `interesting` to any message, except `bye`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 看向前面的循环，我们可以看到程序试图成为一个好的倾听者，对任何消息都回答 `interesting`，除了 `bye`。
- en: The result of the case statement is assigned to `timeToBye`, and is checked
    in the `while` loop condition
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: case 语句的结果被分配给 `timeToBye`，并在 `while` 循环条件中进行检查。
- en: Scala, as a multiparadigm language, has both mutable and immutable variables.
    For nearly any task, we can choose more than one way of implementing this.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 作为一种多范式语言，既有可变变量也有不可变变量。对于几乎任何任务，我们都可以选择多种实现方式。
- en: If guidelines exist, where should we use mutable variables and where should
    we use immutable variables?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在指南，我们应该在哪里使用可变变量，在哪里使用不可变变量？
- en: Generally, reasoning about immutable variables is simpler. The usual heuristic
    is to use immutable values as much as possible, leaving mutable variables for
    performance-critical sections and state-check language constructs (such as while
    loops).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，关于不可变变量的推理更简单。通常的经验法则是尽可能使用不可变值，将可变变量留给性能关键部分和状态检查语言结构（如 while 循环）。
- en: In our small example, we can eliminate the mutable flag by putting an expression
    for the loop exit condition inside `while`. The resulting code is smaller and
    better to read, but adding new functionality becomes harder. Yet there is one
    possibility—use the `recursive` function instead of the loop language construction.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的小型示例中，我们可以通过在 `while` 中放置循环退出条件的表达式来消除可变标志。结果代码更小，更容易阅读，但添加新功能变得更加困难。然而，有一个可能性——使用
    `recursive` 函数而不是循环语言结构。
- en: 'Now let''s add some functionality to our `chatbot`: when the user asks for
    the `time`, the `chatbot` should report the current time.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们给我们的 `chatbot` 添加一些功能：当用户询问 `time` 时，`chatbot` 应该报告当前时间。
- en: To do this, we must retrieve the current time using the Java API and display
    the output of the time using string interpolators.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们必须使用Java API检索当前时间，并使用字符串插值显示时间的输出。
- en: For example, use the `now` method of `java.time.LocalTime.`
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用 `java.time.LocalTime.` 的 `now` 方法。
- en: The code used to display this will be `println("time is ${java.time.LocalTime.now()}").`
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 用于显示此内容的代码将是 `println("time is ${java.time.LocalTime.now()}").`
- en: 'The following is the code for this functionality, but we will actually implement
    this after setting up the working environment we will be playing with:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个功能的代码，但我们将在设置我们将要使用的开发环境之后实际实现它：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Structure of a Scala Project
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala项目的结构
- en: Let's look at our `chatbot` program in a complete runnable project. Let's navigate
    to the `/day1-lesson1/1-project` directory in our code supplement.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的 `chatbot` 程序在一个完整的可运行项目中。让我们导航到我们的代码补充中的 `/day1-lesson1/1-project`
    目录。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code is available on Github at the following link: [https://github.com/TrainingByPackt/Professional-Scala](https://github.com/TrainingByPackt/Professional-Scala)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可在以下链接的Github上找到：[https://github.com/TrainingByPackt/Professional-Scala](https://github.com/TrainingByPackt/Professional-Scala)
- en: '![](img/1_01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1_01.jpg)'
- en: The preceding diagram is the typical directory structure of a Scala project.
    If you are familiar with the Java tools ecosystem, then you will notice the similarities
    between the `maven` project layout.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表是Scala项目的典型目录结构。如果您熟悉Java工具生态系统，您将注意到 `maven` 项目布局之间的相似性。
- en: In `src`, we can see project sources ( `main` and `test`). `target` is a place
    where output artifacts are created, whereas `project` is used as a place to internally
    build the project. We will cover all of these concepts later on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src` 中，我们可以看到项目源代码（`main` 和 `test`）。`target` 是创建输出工件的地方，而 `project` 则用作内部构建项目的地方。我们将在稍后介绍所有这些概念。
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The head of any project is its `build.sbt` file. It consists of the following
    code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 任何项目的头部都是其 `build.sbt` 文件。它由以下代码组成：
- en: The text inside it is a plain Scala snippet.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 其中的文本是一个普通的Scala代码片段。
- en: '`organization`, `name`, and `version` are instances of `sbt.key`. For this
    point of view, `:=` is a binary operator defined on `keys`. In Scala, any method
    with two arguments can be used with the syntax of a binary operator. `:=` is a
    valid method name.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`organization`、`name` 和 `version` 是 `sbt.key` 的实例。从这个角度来看，`:=` 是在 `keys` 上定义的二进制运算符。在Scala中，任何具有两个参数的方法都可以使用二进制运算符的语法使用。`:=`
    是一个有效的方法名。'
- en: '`build.sbt` is interpreted by the `sbt` tool.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`build.sbt` 由 `sbt` 工具解释。'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`sbt` – The original intention for the name, when `sbt` was created by Mark
    Harrah, was '' `Simple Build Tool`''. Later on, the author decided to avoid such
    a decipherment, and kept it as it was. You can read about the details of `sbt`
    here: [https://www.scala-sbt.org/1.x/docs/index.html](https://www.scala-sbt.org/1.x/docs/index.html).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`sbt` – 当 `sbt` 由 Mark Harrah 创建时，其原始名称的意图是 '' `Simple Build Tool`''。后来，作者决定避免这种解释，并保留了原样。您可以在以下链接中了解
    `sbt` 的详细信息：[https://www.scala-sbt.org/1.x/docs/index.html](https://www.scala-sbt.org/1.x/docs/index.html)。'
- en: Basic sbt Commands
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本sbt命令
- en: We will now talk about the basic `sbt` commands.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将讨论基本的 `sbt` 命令。
- en: '`sbt` compile should compile the project and live somewhere in its target compiled
    Java classes.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`sbt compile` 应该编译项目，并位于其目标编译的Java类中。'
- en: '`sbt run` executes the `main` function of the project. Therefore, we can try
    to interact with our `chatbot`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`sbt run` 执行项目的 `main` 函数。因此，我们可以尝试与我们的 `chatbot` 进行交互：'
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output of the code is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下：
- en: '`sbt package` prepares an output artifact. After running it, it will create
    file called `target/chatbot1_2.12-0.1-SNAPSHOT.jar`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`sbt package` 准备输出工件。运行后，它将创建一个名为 `target/chatbot1_2.12-0.1-SNAPSHOT.jar` 的文件。'
- en: '`chatbot1` is the name of our project; `0.1-SNAPSHOT – version. 2.12` is the
    version of the Scala compiler.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`chatbot1` 是我们项目的名称；`0.1-SNAPSHOT – version. 2.12` 是Scala编译器的版本。'
- en: Scala guarantees binary compatibility only within the scope of a minor version.
    If, for some reason, the project still uses `scala-2.11`, then it must use the
    library, which was created for `scala-2.11`. On the other hand, updating to the
    next compiler version can be a long process for projects with many dependencies.
    To allow the same library to exist in the repository with different `scalaVersions`,
    we need to have an appropriate suffix in the jar file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Scala仅在次要版本范围内保证二进制兼容性。如果由于某种原因，项目仍然使用`scala-2.11`，那么它必须使用为`scala-2.11`创建的库。另一方面，对于具有许多依赖项的项目，升级到下一个编译器版本可能是一个漫长的过程。为了允许同一库在不同的`scalaVersions`中存在于仓库中，我们需要在jar文件中有一个适当的后缀。
- en: '`sbt publish-local` – publishes the artifact on to your local repository.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`sbt publish-local` – 将工件发布到本地仓库。'
- en: Now let's see our sample project and `sbt` tool.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下我们的示例项目和`sbt`工具。
- en: 'Activity: Performing Basic Operations with sbt: Build, Run, Package'
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动：使用`sbt`执行基本操作：构建、运行、打包
- en: Install sbt on your computer, if not installed beforehand.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果之前未安装，请在您的计算机上安装sbt。
- en: Start the `sbt` console by typing `sbt console` in the root directory of the
    `1-project` (where `build.sbt` is situated).
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`1-project`（`build.sbt`所在目录）的根目录中输入`sbt console`来启动`sbt`控制台。
- en: Compile the code by typing the `compile` command into the `sbt` console.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`sbt`控制台中输入`compile`命令来编译代码。
- en: Run the program by typing the `sbt run` command into the `sbt` console.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`sbt`控制台中输入`sbt run`命令来运行程序。
- en: When running this, say `bye` to the bot and return to the console.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当运行此操作时，对机器人说“bye”，然后返回控制台。
- en: Package the program by typing `package` into the `sbt` console.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`sbt`控制台中输入`package`来打包程序。
- en: IDE
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDE
- en: 'Another part of the developer toolbox is an IDE tool (Integrated Development
    Environment). For our book, we will use Intellij IDEA community edition with the
    Scala plugin. This is not the only option: other alternatives are scala-ide, based
    on IBM Eclipse and Ensime ([http://ensime.github.io/](http://ensime.github.io/)),
    which brings IDE features to any programmable text editors, from vi to emacs.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者工具箱的另一部分是IDE工具（集成开发环境）。对于我们的书籍，我们将使用带有Scala插件的IntelliJ IDEA社区版。这不是唯一的选择：其他替代方案包括基于IBM
    Eclipse的scala-ide和Ensime ([http://ensime.github.io/](http://ensime.github.io/))，它将IDE功能带到任何可编程文本编辑器，从vi到emacs。
- en: All tools support importing the project layout from `build.sbt`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所有工具都支持从`build.sbt`导入项目布局。
- en: 'Activity: Loading and Running a Sample Project in the IDE'
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动：在IDE中加载和运行示例项目
- en: 'Import our project:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们的项目：
- en: Go to `File` -> `Import` -> navigate to `build.sbt`
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前往`File` -> `Import` -> 导航到`build.sbt`
- en: 'Open the program in IDE:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在IDE中打开程序：
- en: Start IDEA
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动IDEA
- en: Press `Open`
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按`Open`
- en: Select `day1-lesson1/1-project/build.sbt`
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择`day1-lesson1/1-project/build.sbt`
- en: In the dialog window, which asks whether to open it as a file or as a project,
    select `project`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在询问是否将其作为文件或项目打开的对话框窗口中，选择`project`。
- en: On the left part of the project's structure, unfold `src` entry.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目结构的左侧部分，展开`src`条目。
- en: Click on `main.`
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`main.`
- en: Ensure that you can see `main`, as specified in the code.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您可以看到代码中指定的`main`。
- en: Ensure that project can be compiled and run via the `sbt` console.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保项目可以通过`sbt`控制台编译和运行。
- en: 'For running our project from the IDE, we should edit the project''s configuration
    (Menu: `Build`/ `Edit configuration` or `Run`/ `Edit` configuration, depending
    on which version of IDEA you are using).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要从IDE运行我们的项目，我们应该编辑项目的配置（菜单：`Build`/ `Edit configuration`或`Run`/ `Edit` configuration，具体取决于您使用的IDEA版本）。
- en: '**Running the Project from IDE:**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**从IDE运行项目：**'
- en: Select `Run`/`Edit Configuration.`
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Run`/`Edit Configuration.`
- en: Select `Application`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Application`。
- en: Set the application's name. In our case, use `Chatbot1`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置应用程序的名称。在我们的例子中，使用`Chatbot1`。
- en: Set the name of the `Main` class. In our case, it must be `com.packt.courseware.Chatbot1`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`Main`类的名称。在我们的例子中，它必须是`com.packt.courseware.Chatbot1`。
- en: 'Actually run the application: select Run, then Chatbot1 from the dropdown menu.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际运行应用程序：选择Run，然后从下拉菜单中选择Chatbot1。
- en: REPL
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REPL
- en: Another tool that we will frequently use is REPL (Read Eval Print Loop). It
    is often used for quickly evaluating Scala expressions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将经常使用的另一个工具是REPL（读取评估打印循环）。它通常用于快速评估Scala表达式。
- en: From `sbt`, we can enter REPL mode with the help of the `sbt console` command.
    Let's try some simple expressions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从`sbt`，我们可以通过`sbt console`命令进入REPL模式。让我们尝试一些简单的表达式。
- en: 'Now, we''ll look at how to evaluate expressions. Follow these steps to do so:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看如何评估表达式。按照以下步骤进行操作：
- en: Open the `sbt` tool.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`sbt`工具。
- en: 'Open `REPL` by typing the following command:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入以下命令打开`REPL`：
- en: '[PRE7]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Type the following expressions and press *Enter*:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下表达式并按*Enter*：
- en: '`2 + 2`'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2 + 2`'
- en: '`"2" + 2`'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"2" + 2`'
- en: '`2 + "2"`'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2 + "2"`'
- en: '`(1 to 8).sum`'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(1 to 8).sum`'
- en: '`java.time.LocalTime.now()`'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.time.LocalTime.now()`'
- en: 'Please note that we can have an interactive Scala `playboard` inside IDE by
    creating a special file type: a Scala Worksheet. It''s useful, but is mainly for
    demonstration purposes.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以在IDE中通过创建特殊文件类型：Scala工作表来拥有一个交互式的Scala `playboard`。这很有用，但主要是为了演示目的。
- en: Obtaining the Time Request from Our Chatbot Program
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从我们的聊天机器人程序中获取时间请求
- en: 'For now, let''s return to our task: modifying the `chatbot` program so that
    it replies with the current time, as requested by the use of `time`. Let''s learn
    how to do this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的任务：修改`chatbot`程序，使其能够根据`time`的使用回复当前时间。让我们学习如何做到这一点：
- en: '**Steps for C** **ompletion**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: 'Check for `time` to match the statement:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`time`是否与声明匹配：
- en: '[PRE8]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Retrieve the current time using the Java API. Use the `now` method of `java.time.LocalTime`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Java API检索当前时间。使用`java.time.LocalTime`的`now`方法：
- en: '[PRE9]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Display the output of the time using string interpolators, as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用字符串插值器显示时间的输出，如下所示：
- en: '[PRE10]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `main` method will look like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法将如下所示：'
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After we prepare and package our artifacts, we need to run them as well.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们准备和打包我们的工件之后，我们还需要运行它们。
- en: In this book, we will use the running system from unpackaged sources via `sbt`
    (as in the early days of Ruby applications), assuming that sources and `sbt` tools
    are accessible from the production environment. Using this, we can use build tool
    commands for sources such as `sbt run`. In real life, packaging for production
    is a bit more complex.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用从未打包的源代码通过`sbt`（就像Ruby应用程序的早期日子一样）运行的运行系统，假设源代码和`sbt`工具可以从生产环境中访问。使用这种方式，我们可以使用针对源代码的构建工具命令，例如`sbt
    run`。在现实生活中，为生产打包要复杂得多。
- en: 'Popular methods for doing this are as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的流行方法如下：
- en: 'Preparing a fat jar (which includes all dependencies). An `sbt` plugin for
    this exists, which can be found at the following link: [https://github.com/sbt/sbt-assembly](https://github.com/sbt/sbt-assembly).'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备一个包含所有依赖项的胖jar（这有一个`sbt`插件，可以在以下链接找到：[https://github.com/sbt/sbt-assembly](https://github.com/sbt/sbt-assembly)）。
- en: 'Preparing a native system package (which includes jars, dependencies, custom
    layouts, and so on). There is also an `sbt` plugin to create native system packages,
    which can be found at the following link: [https://github.com/sbt/sbt-native-packager](https://github.com/sbt/sbt-native-packager).'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备一个本地系统包（包括jar、依赖项、自定义布局等）。还有一个`sbt`插件可以创建本地系统包，可以在以下链接找到：[https://github.com/sbt/sbt-native-packager](https://github.com/sbt/sbt-native-packager)。
- en: Base Syntax
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本语法
- en: Now that we can use REPL, let's understand the base Scala syntax. For now, it's
    not necessary to learn it in detail, but let's get familiar with it by using an
    example.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用REPL，让我们了解Scala的基本语法。现在，我们不需要详细了解它，但让我们通过使用示例来熟悉它。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For a formal, detailed description, refer to the SLS: Scala Language Specification
    here: [http://scala-lang.org/files/archive/spec/2.12/](http://scala-lang.org/files/archive/spec/2.12/).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于正式的详细描述，请参阅SLS：Scala语言规范，在这里：[http://scala-lang.org/files/archive/spec/2.12/](http://scala-lang.org/files/archive/spec/2.12/)。
- en: Base Syntax for Definitions
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义的基本语法
- en: 'Scala compilation unit – This is a set of definitions inside an entity (template-entity),
    which can be an object, a class, or a trait. We will speak about the Object-Oriented
    part of the Scala language in detail later. Now, let''s look at the basic syntax.
    Let''s define some classes in REPL:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Scala编译单元 – 这是在一个实体（模板实体）内部的一组定义，该实体可以是对象、类或特质。我们将在稍后详细讨论Scala语言的面向对象部分。现在，让我们看看基本语法。让我们在REPL中定义一些类：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Definitions inside the entity can be nested entities, functions, or values:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 实体内部的定义可以是嵌套实体、函数或值：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, the function `f` is defined, returning `1`. We will talk about this function
    in detail in [Chapter 3](ch03.html "Chapter 3. Functions"), *Functions*. Now,
    let''s stay on the top-level view:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，函数`f`被定义为返回`1`。我们将在[第3章](ch03.html "第3章。函数")中详细讨论这个函数。现在，让我们保持顶层视图：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, the value `x` is defined with value `1`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，值`x`被定义为值`1`：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, the mutable variable `y` is defined with value `2`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，可变变量`y`被定义为值`2`。
- en: 'Other high-level entities include objects and traits. We can create objects
    by writing object or trait definitions:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 其他高级实体包括对象和特质。我们可以通过编写对象或特质定义来创建对象：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We will talk about classes, objects, and traits in the next chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章讨论类、对象和特质。
- en: Now, let's look at defining an object in REPL with the name ZeroPoint.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在REPL中定义一个名为ZeroPoint的对象。
- en: '**Steps for Completion:**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤：**'
- en: 'Open REPL by typing the following command in `sbt`:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`sbt`中输入以下命令以打开REPL：
- en: '[PRE17]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Type in the following commands in REPL:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中输入以下命令：
- en: '[PRE18]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Base Syntax for Expressions
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式的基语法
- en: Scala is an expression-based language, which means that everything is an expression
    (in the right-hand side of function and value/variable definitions).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Scala是一种基于表达式的语言，这意味着一切（在函数和值/变量定义的右侧）都是表达式。
- en: 'Some of the base expressions are:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一些基本表达式包括：
- en: 'Primitive expression: Constant or value/variable name.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本表达式：常量或值/变量名。
- en: 'Function calls: These can be:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数调用：这些可以是：
- en: Usual function calls `f(x, y)`.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常规函数调用`f(x, y)`。
- en: 'Operator call syntax:'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符调用语法：
- en: 'binary: `x + y`.'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制：`x + y`.
- en: Note
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Any method with an argument can be used as a binary operator. A set of predefined
    binary operators are similar to Java:'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 任何带有参数的方法都可以用作二元运算符。一组预定义的二元运算符类似于Java：
- en: 'unary: `!x`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一元：`!x`
- en: 'Constructors: `new x` creates an instance of class x.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数：`new x`创建类x的一个实例。
- en: 'Assignments to mutable variables:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变变量的赋值：
- en: '`y = 3`: Assigns a value of `3` to `y`.'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y = 3`：将值`3`赋给`y`。'
- en: '`x = 3`: This is a compiler error, and a value can''t be assigned.'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x = 3`：这是一个编译器错误，无法赋值。'
- en: 'Block:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块：
- en: '[PRE19]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The value of a block expression is the last expression. Note that `;` can be
    omitted if `A` and `B` are situated on different lines. The syntax for this is
    shown as follows:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 块表达式的值是最后一个表达式。注意，如果`A`和`B`位于不同的行上，则可以省略`;`。此语法的语法如下所示：
- en: '[PRE20]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding syntax will have the same output as `{ A; B }`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语法将产生与 `{ A; B }` 相同的输出。
- en: Control structures
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制结构
- en: '`if` statement:'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`语句：'
- en: '[PRE21]'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'match/case expressions:'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: match/case表达式：
- en: '[PRE22]'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Loops:'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环：
- en: '`while`/`do`'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while`/`do`'
- en: '[PRE23]'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`Do`/`while`'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Do`/`while`'
- en: '`Foreach`, `for`'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Foreach`，`for`'
- en: Shortcuts for height-order functions will be described in detail in, [Chapter
    4](ch04.html "Chapter 4. Scala Collections"), *Scala Collections*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数的快捷方式将在[第4章](ch04.html "第4章。Scala集合")*Scala集合*中详细描述。
- en: We'll look at defining a main function which prints something onscreen and calls
    the main function.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看定义一个打印屏幕上内容并调用主函数的主函数。
- en: You should have already opened `project1`. If you haven't, import it into the
    IDE.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该已经打开了`project1`。如果没有，请将其导入IDE。
- en: Insert the new method inside the object definition.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对象定义内插入新方法。
- en: Insert call at the `main` method.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`方法中插入调用。
- en: 'The full method should look something like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的方法可能看起来像这样：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Unit Testing
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: In any program which is bigger than arithmetic operations, programmers should
    make themselves comfortable when it is possible to ensure that new changes are
    not breaking old functionalities.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何大于算术运算的程序中，程序员应该在可能的情况下确保新更改不会破坏旧功能。
- en: The most common technique for this is unit testing, which is where the programmer
    tests the functionality of the code in parallel with its development by creating
    a test code which will verify that the code really satisfies their requirements.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的做法是单元测试，这是程序员在开发过程中并行测试代码功能，通过创建测试代码来验证代码是否真正满足他们的要求。
- en: The theme of this section will be introducing tools for unit testing in Scala.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的主题将介绍Scala中的单元测试工具。
- en: Adding a Test to Our Project
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向我们的项目添加测试
- en: Let's add tests to our small program. We'll import `<for-students/lesson1/2-project>`
    in our IDE.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的小程序中添加测试。我们将在IDE中导入`<for-students/lesson1/2-project>`。
- en: 'This is the directory schema of a Scala project. For adding tests, we should
    do the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Scala项目的目录结构。为了添加测试，我们应该做以下操作：
- en: Add test dependencies to `build.sbt`
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将测试依赖项添加到`build.sbt`
- en: Write tests in the source test directory
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在源测试目录中编写测试
- en: 'For adding dependency, let''s add the following line to our `build.sbt`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加依赖项，让我们在我们的`build.sbt`中添加以下行：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It''s an expression in Scala DSL (domain-specific language), which means that
    we should add `scalatest` to our set of library dependencies. Operators `%%` and
    `%` are used for forming the name and classifier for published artifacts. You
    can refer to the `sb` `t` documentation for more detail: [http://www.scala-sbt.org/1.x/docs/Library-Dependencies.html](http://www.scala-sbt.org/1.x/docs/Library-Dependencies.html).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 Scala DSL（领域特定语言）中的表达式，这意味着我们应该将 `scalatest` 添加到我们的库依赖集合中。运算符 `%%` 和 `%`
    用于形成发布的工件名称和分类器。你可以参考 `sbt` 文档以获取更多详细信息：[http://www.scala-sbt.org/1.x/docs/Library-Dependencies.html](http://www.scala-sbt.org/1.x/docs/Library-Dependencies.html)。
- en: Before compilation, `sbt` will download `scalatest` from a publicly available
    repository (Maven central), and when running tests, it will add `scalatest` to
    the classpath.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译之前，`sbt` 将从公共仓库（Maven central）下载 `scalatest`，在运行测试时，它将 `scalatest` 添加到类路径中。
- en: We will now run `sbt` tests from the command line.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将从命令行运行 `sbt` 测试。
- en: 'In the command-line environment, navigate to the root of the project and select
    the following test:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行环境中，导航到项目的根目录并选择以下测试：
- en: '[PRE26]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you are using a Unix/Linux machine and your code is situated in `courses/pactscala`
    of your home `directory`, then run the following command:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你正在使用 Unix/Linux 机器，并且你的代码位于家目录的 `courses/pactscala` 中，那么运行以下命令：
- en: '[PRE27]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Run the following command`:`
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：`
- en: '[PRE28]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You will get the expected output, which will include the following strings:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将得到预期的输出，其中包括以下字符串：
- en: '[PRE29]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will now see how to run `sbt` tests from IDEA IDE.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将展示如何在 IDEA IDE 中运行 `sbt` 测试。
- en: We'll now run sbt Tests from IDEA IDE.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在 IDEA IDE 中运行 sbt 测试。
- en: Open the project in the IDE.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 IDE 中打开项目。
- en: Navigate to **Run**/**Edit Configurations:**![Adding a Test to Our Project](img/1_02.jpg)
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **运行**/**编辑配置**：![将测试添加到我们的项目中](img/1_02.jpg)
- en: Choose s`bt test` as the configuration.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `sbt test` 作为配置。
- en: Check the checkbox **Use sbt:**
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择复选框 **使用 sbt**：
- en: '![Adding a Test to Our Project](img/1_03.jpg)'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![将测试添加到我们的项目中](img/1_03.jpg)'
- en: Select **Run sbt-test**.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **运行 sbt-test**。
- en: Inside Tests
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在测试内部
- en: 'Now let''s look at a simple test:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个简单的测试：
- en: '[PRE30]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we define a class which is inherited from scalatest FunSuite.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们定义了一个继承自 scalatest FunSuite 的类。
- en: The test expression is called. When the `FunSuite` class is initialized and
    added to a set of tests, the test with `name example test should pass` and assert
    an expression as an argument. For now, this looks like magic, but we will show
    you how to build such DSLs in the next chapter.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `FunSuite` 类初始化并添加到测试集合中时，名为 `example test should pass` 的测试将被调用，并作为参数断言一个表达式。现在这看起来像是魔法，但我们将向你展示如何在下一章中构建这样的
    DSL。
- en: 'Let''s run our test with the help of `sbt`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们借助 `sbt` 运行我们的测试：
- en: '[PRE31]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This command will run all tests and evaluate the test expression.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将运行所有测试并评估测试表达式。
- en: Now, we'll add another test.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加另一个测试。
- en: 'Add one more test to the same file: `src/test/scala/com/packt/courseware/l1/ExampleSpec.scala
    in 2-project`'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中添加一个额外的测试：`src/test/scala/com/packt/courseware/l1/ExampleSpec.scala in
    2-project`
- en: 'We write one `trivial` test, which asserts the `false` expression:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们编写了一个 `trivial` 测试，它断言一个 `false` 表达式：
- en: '[PRE32]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Run the test and look at error reporting.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试并查看错误报告。
- en: 'Invert the expression in assert so that the test passes:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 assert 中的表达式取反，以便测试通过：
- en: '[PRE33]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Run the `sbt` test again to ensure that all of the tests pass.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行 `sbt` 测试以确保所有测试都通过。
- en: Running Tests for Chatbot
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 Chatbot 的测试
- en: Remember that, when writing `chatbot`, we want to test one functionality. Our
    original program only has one function ( `main`), which contains all of the logic
    and can't be split into testable parts.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当我们编写 `chatbot` 时，我们想要测试一个功能。我们的原始程序只有一个函数（`main`），它包含所有逻辑，不能分割成可测试的部分。
- en: Let's look at Version 2.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看版本 2。
- en: Note
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please import `Lesson 1/2-project` into your IDE.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 请将 `Lesson 1/2-project` 导入到你的 IDE 中。
- en: '[PRE34]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, we see some new constructs:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们看到了一些新的结构：
- en: '`LineProcessingResult` is a case class, where the result of processing one
    of the lines (that is, the `chatbot` answer and quit flag) is stored.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`LineProcessingResult` 是一个案例类，其中存储了处理某一行（即，`chatbot` 答案和退出标志）的结果。'
- en: What is the word `case` before class?
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 类名前的单词 `case` 是什么意思？
- en: '`case` classes can participate in pattern matching (while we call one `case`)
    and are usually used for data objects. We will look at `case` classes during the
    next chapter. It is important to see that an instance of `case` classes can be
    created with the `LineProcessingResult(x,y)` syntax (that is, without `new`) and
    an argument to case class constructors ( `answers` and `timeToBye`), which automatically
    become instance variables of the `case` class.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`case`类可以参与模式匹配（虽然我们调用一个`case`），通常用于数据对象。我们将在下一章中查看`case`类。重要的是要注意，可以使用`LineProcessingResult(x,y)`语法（即不使用`new`）以及传递给`case`类构造函数的参数（`answers`和`timeToBye`）来创建`case`类的实例，这些参数自动成为`case`类的实例变量。'
- en: The functionality of processing one line is encapsulated in the `step` method,
    which we can test.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 处理单行功能封装在`step`方法中，我们可以对其进行测试。
- en: '`Step` receives input from the method argument, not from `System.in`, therefore
    making it easier to test. In the case of directly testing the `main` method, we
    will need to substitute `System.in` before `test` and return one back after the
    test is finished.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`Step`从方法参数接收输入，而不是从`System.in`接收，这使得测试更加容易。在直接测试`main`方法的情况下，我们需要在`test`之前替换`System.in`，并在测试完成后返回一个。'
- en: 'Ok, let''s focus on the first test:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们专注于第一个测试：
- en: '[PRE35]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Writing the second test in the same manner will be an easy task. We will look
    at this in the following exercise.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以相同的方式编写第二个测试将是一个简单的任务。我们将在接下来的练习中查看这一点。
- en: Now, let's add the second test, which checks bye.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加第二个测试，它检查bye。
- en: 'Add a second test to the `StepTestSpec` class in our project:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的项目中向`StepTestSpec`类添加第二个测试：
- en: '[PRE36]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this test:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个测试中：
- en: 'Call the step function with `bye` as a parameter:'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`bye`作为参数调用`step`函数：
- en: '[PRE37]'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Check that after this call that `timeToQuit` in the returned class is set to
    `true`:'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查在此调用之后，返回类中的`timeToQuit`是否设置为`true`：
- en: '[PRE38]'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The whole code should be as follows:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个代码应该如下所示：
- en: '[PRE39]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Run `sbt test.`
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`sbt test.`。
- en: A more complex task would be to write a test for the time query.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 编写时间查询的测试将是一个更复杂的任务。
- en: Please note that we can't run the test with the concrete time value, but at
    least we can be sure that the bot answer can't be parsed back to the time form.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们无法使用具体的时间值运行测试，但至少我们可以确保机器人答案不能被解析回时间格式。
- en: 'So, what can we do to check the line answer and try to transform it back to
    time? The solution is provided in the following code:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们怎样才能检查行答案并尝试将其转换回时间？解决方案如下所示：
- en: '[PRE40]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that assertion is not necessary. If time does not satisfy the given format,
    then an exception will be thrown.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，不需要断言。如果时间不满足给定的格式，则将抛出异常。
- en: It is a good practice to separate functional and effects time for testing. To
    do this, we will need to substitute the provider of the system time via own.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 将功能时间和效果时间分开测试是一种好习惯。为此，我们需要通过自己的提供者替换系统时间的提供者。
- en: This will be the first practical task in the next chapter.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是下一章的第一个实际任务。
- en: Now, let's add the date command to our chatbot program.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将日期命令添加到我们的聊天机器人程序中。
- en: 'Add the following code to the match statement so that it checks for the `date`
    command, which should output the local date in `DD:MM:YYYY` format:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到匹配语句中，以便检查`date`命令，该命令应以`DD:MM:YYYY`格式输出本地日期：
- en: '[PRE41]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Add a test case for this function.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此函数添加一个测试用例。
- en: 'The resulting code will be as follows:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成的代码将如下所示：
- en: '[PRE42]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have reached the end of the chapter. In this chapter, we learned various
    aspects of setting up the development environment. We covered the structure of
    a Scala project, and we identified the use of `sbt` for building and running projects.
    We covered REPL, which is a command-line interface for running Scala code. We
    also covered how to develop and run code over the IDEA IDE. Finally, we implemented
    interactions with our simple `chatbot` application.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了本章的结尾。在本章中，我们学习了设置开发环境的各个方面。我们涵盖了Scala项目的结构，并确定了使用`sbt`构建和运行项目的方法。我们还涵盖了REPL，它是运行Scala代码的命令行界面。我们还介绍了如何在IDEA
    IDE中开发和运行代码。最后，我们实现了与我们的简单`chatbot`应用程序的交互。
- en: In the next chapter, we will cover the structure of a Scala program and dive
    deep into the object-oriented properties in Scala, such as like classes, objects,
    and traits. We will also cover the syntax for calling functions and various parameter-passing
    models.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将涵盖Scala程序的结构，并深入探讨Scala中的面向对象特性，例如类、对象和特质。我们还将涵盖调用函数的语法和各种参数传递模型。
