- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: API Specifications and Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we learned about the design aspects of REST APIs and the
    Spring fundamentals required to develop RESTful web services. In this chapter,
    you’ll make use of these two areas to implement REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: We have chosen a design-first approach for implementation to make our development
    process understandable for non-technical stakeholders as well. To make this approach
    possible, we will make use of the **OpenAPI Specification** (**OAS**) to, first,
    design an API and, later, implement it. We will also learn how to handle errors
    that occur while serving the request. In this chapter, we will use the example
    of designing and implementing an API of a sample e-commerce app.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to design the API specifications
    and make use of the OpenAPI codegen to generate the code for models and API Java
    interfaces. You will also know how to write the pseudo-Spring controllers to implement
    the API Java interfaces and Global Exception Handler for the web service.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics as part of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing APIs with OAS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the basic structure of OAS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting OAS to Spring code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the OAS code interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a Global Exception Handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the implementation of the controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need the following to execute the instructions in this and the following
    chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: Any Java IDE, such as NetBeans, IntelliJ, or Eclipse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java Development Kit** (**JDK**) 17'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An internet connection to download the dependencies and Gradle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Designing APIs with OAS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can directly start coding the API; however, this approach leads to many
    issues, such as frequent modifications, difficulty in API management, and difficulty
    in reviews specifically led by non-technical domain teams. Therefore, you should
    use the **design-first approach**.
  prefs: []
  type: TYPE_NORMAL
- en: The first question that comes to mind is, how can we design REST APIs? You learned
    in [*Chapter 1*](B19349_01.xhtml#_idTextAnchor014), *RESTful Web Service Fundamentals*,
    that there is no existing standard to govern REST API implementation. OAS was
    introduced to solve at least the aspects of the REST API’s specification and description.
    It allows you to write REST APIs in the **YAML Ain’t Markup Language** (**YAML**)
    or **JavaScript Object Notation** (**JSON**) markup languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use version 3.0 of OAS ([https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md))
    to implement the e-commerce app REST API. We’ll use YAML (pronounced as *yamel*,
    rhyming with *camel*), which is cleaner and easier to read. YAML is also space-sensitive.
    It uses space for indentation; for example, it represents the `key: value` pair
    (pay attention to the space after the colon – `:`). You can read more about YAML
    at [https://yaml.org/spec/](https://yaml.org/spec/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'OAS was earlier known as the *Swagger Specification*. Today, OAS-supporting
    tools are still known as **Swagger tools**. Swagger tools are open source projects
    that help the overall development life cycle of REST APIs. We’ll make use of the
    following Swagger tools in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Swagger Editor** ([https://editor.swagger.io/](https://editor.swagger.io/)):
    This tool is used to design and describe the e-commerce app REST APIs. It allows
    you to write and preview, at the same time, your REST APIs’ design and description.
    Make sure that you use OAS 3.0\. Its beta version is available at [https://editor-next.swagger.io/](https://editor-next.swagger.io/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Swagger Codegen** ([https://github.com/swagger-api/swagger-codegen](https://github.com/swagger-api/swagger-codegen)):
    This tool is used to generate the Spring-based API models and Java interfaces.
    You’ll use the Gradle plugin ([https://github.com/int128/gradle-swagger-generator-plugin](https://github.com/int128/gradle-swagger-generator-plugin))
    to generate code that works on top of Swagger Codegen. There is also an OpenAPI
    tool Gradle plugin – OpenAPI Generator ([https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator-gradle-plugin](https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator-gradle-plugin)).
    However, we’ll opt for the former one because of the open issues count, which
    is 3.2k (there are multiple for Java/Spring as well) at the time of writing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Swagger UI** ([https://swagger.io/swagger-ui/](https://swagger.io/swagger-ui/)):
    This tool is used to generate the REST API documentation. The same Gradle plugin
    will be used to generate the API documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have some idea of how the design-first approach can be used to
    develop APIs using OAS supporting tools, let’s understand the basic structure
    of OAS.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basic structure of OAS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The OpenAPI definition structure can be divided into the following sections
    (all are keywords and case-sensitive):'
  prefs: []
  type: TYPE_NORMAL
- en: '`openapi (version)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`externalDocs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`servers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tags`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paths`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`components`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the preceding terms are part of `root`. The first three sections (`openapi`,
    `info`, and `externalDocs`) are used to define the metadata of the API.
  prefs: []
  type: TYPE_NORMAL
- en: You can place an API’s definition either in a single file or divided into multiple
    files. OAS supports both. We’ll use a single file to define the sample e-commerce
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of discussing all the sections theoretically and then writing the e-commerce
    API definitions, we’ll do both together. First, we’ll cover each section definition
    of the e-commerce API, and then we’ll discuss why we have used it and what it
    implies.
  prefs: []
  type: TYPE_NORMAL
- en: The metadata sections of OAS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s have a look at the metadata sections of the e-commerce API definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us discuss each code section in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`openapi`: The `openapi` section tells us which OAS is used to write the API’s
    definition. OpenAPI uses semantic versioning ([https://semver.org/](https://semver.org/)),
    which means the version will be in the `major:minor:patch` form. If you look at
    the `openapi` metadata value, we use `3.0.3`. This reveals that we use major version
    `3` with patch `3` (the minor version is `0`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info`: The `info` section contains the metadata about the API. This information
    is used to generate documentation and can be used by the client. It contains the
    following fields, out of which only `title` and `version` are mandatory fields,
    with the others being optional:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: The title of the API.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: This is used to describe the API details. As you can see, we
    can use Markdown ([https://spec.commonmark.org/](https://spec.commonmark.org/))
    here. An `>` (angular bracket) symbol is used to add multi-line values.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`termsOfService`: This is a URL that links to the terms of services. Make sure
    that it follows the proper URL format.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contact`: This is the contact information of the API provider. The `email`
    attribute should be the email address of the contact person/organization. Other
    attributes are `name` and `url`. The `name` attribute represents the name of the
    contact person or organization. The `url` attribute provides the link to the contact
    page. This is an optional field, and all attributes are also optional.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`license`: This is the license information. The `name` attribute is a required
    field that represents the correct license name, such as MIT. `url` is optional
    and provides a link to the license document.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version`: This exposes the API version in the string format.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`externalDocs`: This is an optional field that points to extended documentation
    of the exposed API. It has two attributes – `description` and `url`. The `description`
    attribute is an optional field that defines a summary of the external documentation.
    You can use the Markdown syntax for the description. The `url` attribute is *mandatory*
    and links to external documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s continue building our API definition. We have completed the metadata section,
    so let’s discuss the servers and tags sections.
  prefs: []
  type: TYPE_NORMAL
- en: The servers and tags sections of OAS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the metadata section, we can now describe the `servers` and `tags` sections.
    Let’s have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us discuss each code section in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`servers`: The `servers` section is an optional section that contains a list
    of servers that host the API. If the hosted API document is interactive, then
    it can be used by Swagger UI to directly call the API and show the response. If
    it is not provided, then it points to the root (`/`) of the hosted document server.
    Server URLs are shown using the `url` attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tags`: The `tags` section, defined at the root level, contains the collection
    of tags and their metadata. Tags are used to group the operations performed on
    the resources. The `tags` metadata contains `name`, which is a mandatory field,
    and two additional optional attributes: `description` and `externalDocs`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `name` attribute contains the tag name. We have already discussed the description
    and `externalDocs` fields in the previous section on metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discuss the last two sections of OAS.
  prefs: []
  type: TYPE_NORMAL
- en: The components section of OAS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we were going through the structure sequentially, we would have discussed
    `path` first. However, conceptually, we want to write our models first before
    we use them in the `path` section. Therefore, we’ll discuss the `components` section
    first, which is used to define the models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code snippet from the `components` section of the sample e-commerce
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml)'
  prefs: []
  type: TYPE_NORMAL
- en: If you are working with YAML for the first time, you may find it a bit uncomfortable.
    However, once you go through this section, you’ll feel more comfortable with YAML.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we define a model called `Cart`. The `Cart` model is of the `object` type
    and contains two fields, namely `customerId` (a string) and `items` (an array).
  prefs: []
  type: TYPE_NORMAL
- en: The object data type
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define any model or field as an object. Once you mark a type as `object`,
    the next attribute is `properties`, which consists of all the object’s fields.
    For example, the `Cart` model in the previous code will have the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type: object`'
  prefs: []
  type: TYPE_NORMAL
- en: '`properties:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`<``field name>:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`type: <``data type>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'OAS supports six basic data types, which are as follows (all are in lowercase):'
  prefs: []
  type: TYPE_NORMAL
- en: '`string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`integer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s discuss the `Cart` model, in which we use the `string`, `object`, and
    `array` data types. Other data types are `number`, `integer`, and `boolean`. Now,
    you may be wondering how to define the `date`, `time`, and `float` types, and
    so on. You can do that with the `format` attribute, which you can use along with
    the `object` type. For example, take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, `orderDate` is defined with `type string`, but `format`
    determines what string value it will contain. Since `format` is marked with `date-time`,
    the `orderDate` field will contain the date and time in the format defined in
    *RFC 3339*, *section 5.6* (https://tools.ietf.org/html/rfc3339#section-5.6) –
    for example, `2020-10-22T19:31:58Z`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some other common formats you can use along with types, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type: number` with `format: float`: This will contain the floating-point number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type: number` with `format: double`: This will contain the floating-point
    number with double precision'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type: integer` with `format: int32`: This will contain the `int` type (signed
    32-bit integer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type: integer` with `format: int64`: This will contain the long type (signed
    64-bit integer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type: string` with `format: date`: This will contain the date as per *RFC
    3339* – for example, `2020-10-22`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type: string` with `format: byte`: This will contain the Base64-encoded values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type: string` with `format: binary`: This will contain the binary data (and
    can be used for files)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `Cart` model’s `items` field is an array of the user-defined `Item` type.
    Here, `Item` is another model and referenced using `$ref`. In fact, all user-defined
    types are referenced using `$ref`. The `Item` model is also part of the `components`/`schema`
    section. Therefore, the value of `$ref` contains an anchor for user-defined types
    with `#/``component/ schemas/{type}`.
  prefs: []
  type: TYPE_NORMAL
- en: '`$ref` represents the reference object. It is based on the JSON reference ([https://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03](https://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03))
    and follows the same semantics in YAML. It can refer to an object in the same
    document or external documents. Therefore, it is used when you have API definitions
    divided into multiple files. You have already seen one example of its usage in
    the previous code. Let’s see one more example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There is another caveat to the previous code. If you look closely, you will
    find two *items* – one is a property of the `Cart` object type and another one
    is an attribute of the array type. The former one is simple – a field of the `Cart`
    object. However, the latter belongs to `array` and is a part of the `array` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Array syntax
  prefs: []
  type: TYPE_NORMAL
- en: '`type: array`'
  prefs: []
  type: TYPE_NORMAL
- en: '`items:`'
  prefs: []
  type: TYPE_NORMAL
- en: '`type: <type` `of object>`'
  prefs: []
  type: TYPE_NORMAL
- en: i. You could have a nested array if you placed the type of object as `array`
  prefs: []
  type: TYPE_NORMAL
- en: "ii. You can also refer to the user-defined type using `$ref`, as shown in the\
    \ code\L (then, the `type` attribute is not required for `items`)"
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what the `Item` model looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml)'
  prefs: []
  type: TYPE_NORMAL
- en: The `Item` model is also part of the `components`/`schema` section. We have
    defined several models used by the e-commerce app API. You can find them in the
    GitHub code at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/Chapter03/src/main/resources/api/openapi.yaml).
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have learned how you can define models under the `components`/`schema`
    section. We’ll now discuss how to define an API’s endpoints in the `path` section
    of OAS.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Like `schemas`, you can also define `requestBodies` (the request payload) and
    `responses` in the `components` section. This is useful when you have common request
    bodies and responses.
  prefs: []
  type: TYPE_NORMAL
- en: The path section of OAS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `path` section is the last section of OAS (sequence-wise, it is second-to-last,
    but we already discussed `components` in the previous subsection), where we define
    the endpoints. This is the place where we form the URI and attach the HTTP methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write the definition for `GET /api/v1/carts/{customerId}/items`. This
    API gets the items of the cart associated with a given customer identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml)'
  prefs: []
  type: TYPE_NORMAL
- en: If you just go through the previous code, you can see what the endpoint is,
    what HTTP method and parameter this API uses, and most importantly, what response
    you can expect. Let’s discuss this in more detail. Here, `v1` represents the version
    of the API. Each endpoint path (such as `/api/v1/carts/{customerId}/items`) has
    an HTTP method (such as `POST`) associated with it. The endpoint path always starts
    with `/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each method can then have seven fields – `tags`, `summary`, `description`,
    `operationId`, `parameters`, `responses`, and `requestBody`. Let us learn about
    each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tags`: Tags are used to group APIs, as shown in the following screenshot for
    APIs tagged with `cart`. `cart` endpoints in the following screenshot will be
    in `CartsApi.java`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Cart APIs](img/Figure_03.1_B19349.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Cart APIs
  prefs: []
  type: TYPE_NORMAL
- en: '`summary` and `description`: The `summary` and `description` sections are the
    same as we ones we discussed in the *The metadata sections of OAS* section. They
    contain the given API’s operation summary and detailed description, respectively.
    As usual, you can use Markdown in the description field, as it refers to the same
    schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operationId`: This represents the name of the operation. As you can see in
    the previous code, we have assigned the `getCartByCustomerId` value to it. This
    same operation name will be used by Swagger Codegen as a method name in the generated
    API Java interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Parameters`: If you look closely, you’ll find `-` (a hyphen) in front of the
    name field. This is used to declare it as an array element. The `parameters` field
    can contain multiple parameters – in fact, a combination of the `path` and `query`
    parameters; therefore, it is declared as an array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `path` parameters, you need to make sure that the value of `name`, under
    `parameters`, is the same as given in `path` inside curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: The `parameters` field contains the API `query`, `path`, `header`, and `cookie`
    parameters. In the previous code, we used the `path` parameter (the value of the
    `in` field). You can change the value to `query` if you want to declare it as
    a `query` parameter and so on for other parameter types.
  prefs: []
  type: TYPE_NORMAL
- en: You can mark a field as required or optional using the `required` field inside
    the `parameters` section, which is a Boolean parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you must declare the data type of the parameter, which is where the
    `schema` field is used.
  prefs: []
  type: TYPE_NORMAL
- en: '`responses`: The `responses` field is a required field for all API operations.
    This defines the type of responses that can be sent by the API operation when
    requested. It contains HTTP status codes as the default field. The field must
    have at least one response, which can be a `default` response or any successful
    HTTP status code, such as `200`. As the name suggests, the default response will
    be used when no other response is defined or available in the API operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The response type (such as `200` or `default`) field contains three types of
    fields – `description`, `content`, and `headers`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `description` field is used to describe the response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `headers` field is used to define the header and its value. A `headers`
    example is shown as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `content` field, like we have in previous code, defines the type of content
    that denotes the different media types. We use `application/json`. Similarly,
    you can define other media types, such as `application/xml`. The `content` type
    field contains the actual response object that can be defined using the `schema`
    field, as we have defined an array of the `Item` model inside it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned earlier, you can create a reusable response under the `components`
    section and directly use it with `$ref`.
  prefs: []
  type: TYPE_NORMAL
- en: '`requestBody`: The `requestBody` field is used to define the request payload
    object. Like the `responses` object, `requestBody` also contains the description
    and content fields. Content can be defined in a similar fashion to the way it
    is defined for the `responses` object. You can refer to the previous code of `POST
    /carts/{customerId}/items` for an example. As a response, you can also create
    reusable request bodies under the `components` section and directly use them with
    `$ref`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, you know how to define the API specification using OAS. Great! Here, we
    just described part of a sample e-commerce app’s API. Similarly, you can describe
    other APIs. You can refer to `openapi.yaml` ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/openapi.yaml))
    for the complete code of our e-commerce API definitions.
  prefs: []
  type: TYPE_NORMAL
- en: I suggest that you copy the code from `openapi.yaml` and paste it into the editor
    at [https://editor.swagger.io](https://editor.swagger.io) to view the API in a
    nice user interface and play around with it. Make sure to convert the API to OpenAPI
    version 3 using the **Edit** menu if the default version is not set to 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: We have finished designing our APIs, so now let’s generate code using `openapi.yaml`
    and enjoy the fruits of our hard work.
  prefs: []
  type: TYPE_NORMAL
- en: Converting OAS to Spring code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I am sure you are as excited as I am to start implementing the API. So far,
    we have learned about the RESTful web service theory and concepts and Spring fundamentals,
    and also designed our first API specs for a sample e-commerce application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this section, you can either clone the Git repository ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3))
    or start to create a Spring project from scratch using **Spring Initializr** ([https://start.spring.io/](https://start.spring.io/))
    with the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Gradle -` `Groovy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3.0.8`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or use the 3.X.X available version. Replace the project metadata with your preferred
    values
  prefs: []
  type: TYPE_NORMAL
- en: '`Jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`17`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Spring Web`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you open the project in your favorite IDE (IntelliJ, Eclipse, or NetBeans),
    you can add the following extra dependencies required for OpenAPI support under
    `dependencies` in the `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/build.gradle)'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, we will use the Swagger plugin for code generation from
    the API definitions we just wrote. Follow the next seven steps to generate the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '`plugins {}` in `build.gradle`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '{  "library": "spring-boot",  "dateLibrary": "java8",  "hideGenerationTimestamp":
    true,  "modelPackage": "com.packt.modern.api.model",  "apiPackage": "com.packt.modern.api",  "invokerPackage":
    "com.packt.modern.api",  "serializableModel": true,  "useTags": true,  "useGzipFeature"
    : true,  "hateoas": true,  "unhandledException": true,  "useSpringBoot3": true,  "useSwaggerUI":
    true,   …   …  "importMappings": {    "ResourceSupport":"org.springframework.hateoas.        RepresentationModel",    "Link":
    "org.springframework.hateoas.Link"  }}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/config.json](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/resources/api/config.json)'
  prefs: []
  type: TYPE_NORMAL
- en: This configuration sets `spring-boot` as `library` – that is, Swagger Codegen
    will generate the classes aligned with Spring Boot. You can see that `useSpringBoot3`
    is set to `true` to make sure that generated classes are aligned with Spring Boot
    3.
  prefs: []
  type: TYPE_NORMAL
- en: All other properties are self-explanatory except `importMappings`. It contains
    the mapping of a type from a YAML file to Java or a type existing in the external
    library. Therefore, once code is generated for the `importMappings` object, it
    uses the mapped class in the generated code. If we use `Link` in any of the models,
    then the generated models will use the mapped `org.springframework.hateoas.Link`
    class instead of the model defined in the YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: The `hateoas` configuration property allows us to use the Spring HATEOAS library
    and add HATEOAS links.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the configuration at [https://github.com/swagger-api/swagger-codegen#customizing-the-generator](https://github.com/swagger-api/swagger-codegen#customizing-the-generator).
  prefs: []
  type: TYPE_NORMAL
- en: "`.gitignore` like file \Lto ignore certain code you don’t want to generate.\
    \ Add the following line of code to the file (`/``src/main/resources/api/.openapi-generator-ignore`):"
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We don’t want to generate controllers. After the code’s addition, only API Java
    interfaces and models will be generated. We’ll add controllers manually.
  prefs: []
  type: TYPE_NORMAL
- en: Copy the OAS file from [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter03/src/main/resources/api/openapi.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter03/src/main/resources/api/openapi.yaml)
    in `/src/main/resources/api`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`swaggerSources` task in the `build.gradle` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we defined `eStore` (the user-defined name), which contains `inputFile`,
    pointing to the location of the `openapi.yaml` file. After defining the input,
    the generator needs to produce the output, which is configured in `code`.
  prefs: []
  type: TYPE_NORMAL
- en: For the `code` block, `language` is set to Spring (it supports various languages);
    `configFile` points to `config.json`; `rawOptions` contains an `ignore` file,
    type mapping, and import mappings; and `components` contains the file flags you
    want to generate – models and API Java interfaces. Except for `language`, all
    our other configuration properties are optional in the `code` block.
  prefs: []
  type: TYPE_NORMAL
- en: We only want to generate models and APIs. You can generate other files too,
    such as clients or test files. `ApiUtil.java` is required in the generated API
    Java interface otherwise, it will give a compilation error during build time.
    Therefore, it is added to `components`.
  prefs: []
  type: TYPE_NORMAL
- en: '`swaggerSources` to the `compileJava` task as a dependent task.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This task points to the `code` block defined under `eStore`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: processResources {  dependsOn(generateSwaggerCode)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: sourceSets.main.java.srcDir "${swaggerSources.eStore.code.outputDir}/src/main/java"sourceSets.main.resources.srcDir
    "${swaggerSources.eStore.code  .outputDir}/src/main/resources"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ gradlew clean build
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@RestControllerpublic class CartsController implements CartApi {'
  prefs: []
  type: TYPE_NORMAL
- en: private static final Logger log = LoggerFactory.getLogger(CartsController.class);
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public ResponseEntity<List<Item>> addCartItemsBy
  prefs: []
  type: TYPE_NORMAL
- en: CustomerId(String customerId, @Valid Item item) {
  prefs: []
  type: TYPE_NORMAL
- en: 'log.info("Request for customer ID: {}\nItem: {}",customerId, item);'
  prefs: []
  type: TYPE_NORMAL
- en: return ok(Collections.EMPTY_LIST);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public ResponseEntity<List<Cart>> getCartByCustomerId(String customerId) {
  prefs: []
  type: TYPE_NORMAL
- en: throw new RuntimeException("Manual Exception thrown");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Other method implementations (omitted)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: public class Error {  private static final long serialVersionUID = 1L;
  prefs: []
  type: TYPE_NORMAL
- en: private String errorCode;
  prefs: []
  type: TYPE_NORMAL
- en: private String message;
  prefs: []
  type: TYPE_NORMAL
- en: private Integer status;
  prefs: []
  type: TYPE_NORMAL
- en: private String url = "Not available";
  prefs: []
  type: TYPE_NORMAL
- en: private String reqMethod = "Not available";
  prefs: []
  type: TYPE_NORMAL
- en: // getters and setters (omitted)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: public enum ErrorCode {  GENERIC_ERROR("PACKT-0001", "The system is unable to
  prefs: []
  type: TYPE_NORMAL
- en: complete the request. Contact system support."),
  prefs: []
  type: TYPE_NORMAL
- en: HTTP_MEDIATYPE_NOT_SUPPORTED("PACKT-0002", "Requested
  prefs: []
  type: TYPE_NORMAL
- en: media type is not supported. Please use
  prefs: []
  type: TYPE_NORMAL
- en: application/json or application/xml as 'Content-
  prefs: []
  type: TYPE_NORMAL
- en: Type' header value"),
  prefs: []
  type: TYPE_NORMAL
- en: HTTP_MESSAGE_NOT_WRITABLE("PACKT-0003", "Missing 'Accept'
  prefs: []
  type: TYPE_NORMAL
- en: header. Please add 'Accept' header."),
  prefs: []
  type: TYPE_NORMAL
- en: HTTP_MEDIA_TYPE_NOT_ACCEPTABLE("PACKT-0004", "Requested
  prefs: []
  type: TYPE_NORMAL
- en: '''Accept'' header value is not supported. Please use'
  prefs: []
  type: TYPE_NORMAL
- en: application/json or application/xml as 'Accept'
  prefs: []
  type: TYPE_NORMAL
- en: value"),
  prefs: []
  type: TYPE_NORMAL
- en: JSON_PARSE_ERROR("PACKT-0005", "Make sure request payload
  prefs: []
  type: TYPE_NORMAL
- en: should be a valid JSON object."),
  prefs: []
  type: TYPE_NORMAL
- en: HTTP_MESSAGE_NOT_READABLE("PACKT-0006", "Make sure
  prefs: []
  type: TYPE_NORMAL
- en: request payload should be a valid JSON or XML
  prefs: []
  type: TYPE_NORMAL
- en: object according to 'Content-Type'.");
  prefs: []
  type: TYPE_NORMAL
- en: private String errCode;
  prefs: []
  type: TYPE_NORMAL
- en: private String errMsgKey;
  prefs: []
  type: TYPE_NORMAL
- en: ErrorCode(final String errCode, final String errMsgKey) {
  prefs: []
  type: TYPE_NORMAL
- en: this.errCode = errCode;
  prefs: []
  type: TYPE_NORMAL
- en: this.errMsgKey = errMsgKey;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public String getErrCode() {  return errCode;  }
  prefs: []
  type: TYPE_NORMAL
- en: public String getErrMsgKey() {  return errMsgKey;  }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: public class ErrorUtils {  private ErrorUtils() {}
  prefs: []
  type: TYPE_NORMAL
- en: public static Error createError(final String errMsgKey,
  prefs: []
  type: TYPE_NORMAL
- en: final String errorCode, final Integer httpStatusCode) {
  prefs: []
  type: TYPE_NORMAL
- en: Error error = new Error();
  prefs: []
  type: TYPE_NORMAL
- en: error.setMessage(errMsgKey);
  prefs: []
  type: TYPE_NORMAL
- en: error.setErrorCode(errorCode);
  prefs: []
  type: TYPE_NORMAL
- en: error.setStatus(httpStatusCode);
  prefs: []
  type: TYPE_NORMAL
- en: return error;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '@ControllerAdvicepublic class RestApiErrorHandler {'
  prefs: []
  type: TYPE_NORMAL
- en: private final MessageSource messageSource;
  prefs: []
  type: TYPE_NORMAL
- en: '@Autowired'
  prefs: []
  type: TYPE_NORMAL
- en: public RestApiErrorHandler(MessageSource messageSource) {
  prefs: []
  type: TYPE_NORMAL
- en: this.messageSource = messageSource;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@ExceptionHandler(Exception.class)'
  prefs: []
  type: TYPE_NORMAL
- en: public ResponseEntity<Error> handleException(HttpServletRequest request, Exception
    ex,Locale locale) {
  prefs: []
  type: TYPE_NORMAL
- en: Error error = ErrorUtils
  prefs: []
  type: TYPE_NORMAL
- en: .createError(ErrorCode.GENERIC_ERROR.getErrMsgKey(),  ErrorCode.GENERIC_ERROR.getErrCode(),  HttpStatus.INTERNAL_SERVER_ERROR.value())     .setUrl(request.getRequestURL().toString())  .setReqMethod(request.getMethod());
  prefs: []
  type: TYPE_NORMAL
- en: return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@ExceptionHandler(HttpMediaTypeNotSupportedException.class)'
  prefs: []
  type: TYPE_NORMAL
- en: public ResponseEntity<Error>
  prefs: []
  type: TYPE_NORMAL
- en: handleHttpMediaTypeNotSupportedException(
  prefs: []
  type: TYPE_NORMAL
- en: HttpServletRequest request,
  prefs: []
  type: TYPE_NORMAL
- en: HttpMediaTypeNotSupportedException ex, Locale locale){
  prefs: []
  type: TYPE_NORMAL
- en: Error error = ErrorUtils
  prefs: []
  type: TYPE_NORMAL
- en: .createError(ErrorCode.HTTP_MEDIATYPE_NOT_SUPPORTED
  prefs: []
  type: TYPE_NORMAL
- en: .getErrMsgKey(),
  prefs: []
  type: TYPE_NORMAL
- en: ErrorCode.HTTP_MEDIATYPE_NOT_SUPPORTED.getErrCode(),
  prefs: []
  type: TYPE_NORMAL
- en: HttpStatus.UNSUPPORTED_MEDIA_TYPE.value())
  prefs: []
  type: TYPE_NORMAL
- en: .setUrl(request.getRequestURL().toString())
  prefs: []
  type: TYPE_NORMAL
- en: .setReqMethod(request.getMethod());
  prefs: []
  type: TYPE_NORMAL
- en: return new ResponseEntity<>(
  prefs: []
  type: TYPE_NORMAL
- en: error, HttpStatus.INTERNAL_SERVER_ERROR);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // removed code for brevity
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: $ ./gradlew clean build
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: $ java -jar build/libs/Chapter03-0.0.1-SNAPSHOT.jar
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '$ curl --request GET ''http://localhost:8080/api/v1/carts/1'' --header ''Accept:
    application/xml'''
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: <Error>  <errorCode>PACKT-0001</errorCode>
  prefs: []
  type: TYPE_NORMAL
- en: <message>The system is unable to complete the request.
  prefs: []
  type: TYPE_NORMAL
- en: Contact system support.</message>
  prefs: []
  type: TYPE_NORMAL
- en: <status>500</status>
  prefs: []
  type: TYPE_NORMAL
- en: <url>http://localhost:8080/api/v1/carts/1</url>
  prefs: []
  type: TYPE_NORMAL
- en: <reqMethod>GET</reqMethod>
  prefs: []
  type: TYPE_NORMAL
- en: </Error>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '$ curl --request GET ''http://localhost:8080/api/v1/carts/1'' --header ''Accept:
    application/json''{'
  prefs: []
  type: TYPE_NORMAL
- en: '"errorCode":"PACKT-0001",'
  prefs: []
  type: TYPE_NORMAL
- en: '"message":"The system is unable to complete the request.'
  prefs: []
  type: TYPE_NORMAL
- en: Contact system support.",
  prefs: []
  type: TYPE_NORMAL
- en: '"status":500,'
  prefs: []
  type: TYPE_NORMAL
- en: '"url":"http://localhost:8080/api/v1/carts/1",'
  prefs: []
  type: TYPE_NORMAL
- en: '"reqMethod":"GET"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '$ curl --request POST ''http://localhost:8080/api/v1/carts/1/items'' \ --header
    ''Content-Type: application/json'' \'
  prefs: []
  type: TYPE_NORMAL
- en: '--header ''Accept: application/json'' \'
  prefs: []
  type: TYPE_NORMAL
- en: --data-raw '{
  prefs: []
  type: TYPE_NORMAL
- en: '"id": "1",'
  prefs: []
  type: TYPE_NORMAL
- en: '"quantity": 1,'
  prefs: []
  type: TYPE_NORMAL
- en: '"unitPrice": 2.5'
  prefs: []
  type: TYPE_NORMAL
- en: '}'''
  prefs: []
  type: TYPE_NORMAL
- en: '[]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'type: arrayitems:  type: array  items:    type: string'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
