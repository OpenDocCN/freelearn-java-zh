<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;3.&#xA0;A Pattern-matching Approach to REST Services with Unfiltered"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03" class="calibre1"/>Chapter 3. A Pattern-matching Approach to REST Services with Unfiltered</h1></div></div></div><p class="calibre7">In this chapter, we'll introduce a light-weight REST framework called <span class="strong"><strong class="calibre8">Unfiltered</strong></span>. With Unfiltered, you can use standard Scala pattern matching to take complete control over how to process an HTTP request and create an HTTP response. In this chapter, we'll look at the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Setting up the basic skeleton for an Unfiltered-based REST service</li><li class="listitem">Using matchers and extractors to process incoming HTTP requests</li><li class="listitem">Processing requests in synchronous and asynchronous ways</li><li class="listitem">Converting and validating incoming requests and parameters using extractors and directives</li><li class="listitem">Customizing response codes and response formats</li></ul></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;A Pattern-matching Approach to REST Services with Unfiltered">
<div class="book" title="What is Unfiltered"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch03lvl1sec22" class="calibre1"/>What is Unfiltered</h1></div></div></div><p class="calibre7">Unfiltered is <a id="id146" class="calibre1"/>an easy to use light-weight REST framework, which provides a set of constructs you can use to create your own REST services. For this, Unfiltered uses Scala pattern matching, together with a set of matchers and extractors. One of the interesting parts of Unfiltered is that it gives you complete control over how you handle your request and define your response. The framework itself won't add any headers, or makes assumptions regarding content-types or response codes unless you tell it to.</p><p class="calibre7">Unfiltered has been around for a couple of years and is used by a large number of companies. Some of the best-known ones are the following two:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">Remember the Milk</strong></span>: Remember<a id="id147" class="calibre1"/> the Milk is one of the best-known to-do apps. It uses Unfiltered to handle all its public APIs.</li><li class="listitem"><span class="strong"><strong class="calibre8">Meetup</strong></span>: With <a id="id148" class="calibre1"/>Meetup, groups of people who share interests come together to share knowledge and schedule meetups. Meetup uses Unfiltered to serve its real-time APIs.</li></ul></div><p class="calibre7">For more information and documentation about Unfiltered, you can check out the website at <a class="calibre1" href="http://unfiltered.databinder.net/">http://unfiltered.databinder.net/</a>.</p></div></div>
<div class="book" title="Your first Unfiltered service"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec23" class="calibre1"/>Your first Unfiltered service</h1></div></div></div><p class="calibre7">Just like we did in the<a id="id149" class="calibre1"/> previous chapter, we will start by creating the most basic Unfiltered REST service. The dependencies for the examples and frameworks used in this chapter can be found in the <code class="email">Dependencies.scala</code> file, which is located in the <code class="email">project</code> directory. For the Unfiltered examples explained in this chapter, we use the following SBT dependencies:</p><div class="informalexample"><pre class="programlisting">  lazy val unfilteredVersion = "0.8.4"
  val backendDeps = Seq(
    "net.databinder" %% "unfiltered-filter" % unfilteredVersion,
    "net.databinder" %% "unfiltered-jetty" % unfilteredVersion
  )</pre></div><p class="calibre7">To work with Unfiltered, we at least need the <code class="email">unfiltered-filter</code> module, which contains the core classes we need to create routes and handle requests and responses. We also need to define which type of server we want to use to run Unfiltered on. In this case, we run Unfiltered on an embedded Jetty (<a class="calibre1" href="http://www.eclipse.org/jetty/">http://www.eclipse.org/jetty/</a>) instance.</p><p class="calibre7">With these dependencies in place, we can create a minimal Unfiltered service. You can find the code for this service in the <code class="email">HelloUnfiltered.scala</code> source file, which is located in the sources for this chapter:</p><div class="informalexample"><pre class="programlisting">package org.restwithscala.chapter3.gettingstarted

import unfiltered.request._
import unfiltered.response._

object HelloUnfiltered extends App {

  // explicitly set the thread name. If not, the server can't be 
  // stopped easily when started from an IDE
  Thread.currentThread().setName("swj");

  // Start a minimalistic server
  val echo = unfiltered.filter.Planify {
    case GET(Path("/hello")) =&gt; ResponseString("Hello Unfiltered")
  }
  unfiltered.jetty.Server.http(8080).plan(echo).run()

  println("Press &lt;enter&gt; to exit.")
  Console.in.read.toChar

}</pre></div><p class="calibre7">What we do here<a id="id150" class="calibre1"/> is create a simple route that responds to a <code class="email">GET</code> request on the <code class="email">/hello</code> path. When Unfiltered receives this request, it will respond with the <code class="email">Hello Unfiltered</code> response using the <code class="email">ResponseString</code> object to create a response (we will discuss this more later). This route is bound to a Jetty server, which runs on port <code class="email">8080</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip07" class="calibre1"/>Tip</h3><p class="calibre7">You probably have noticed the strange <code class="email">Thread.currentThread().setName</code> call at the beginning of this example. The reason we do this is to avoid Unfiltered starting in daemon mode. Unfiltered tries to detect whether we have started from SBT or run normally; if run from SBT, it allows us to stop the server by just pressing a key (the behavior we want). If not, it runs in the background and requires a shutdown hook to stop the server. It does this by checking the name of the current thread. If the name is <code class="email">main</code>, it will run Unfiltered in daemon mode, if it is something else, it will run normally, which allows us to easily stop the server. So by setting the name of the main thread to something else, we can also have this nice shutdown behavior when run from the IDE.</p></div><p class="calibre7">Additionally, we also need to set up logging for Jetty, which is the engine used by Unfiltered. Jetty has some prolific logging in its default configuration. To minimize the logging of Jetty to only log useful information, we need to add a <code class="email">logback.xml</code> configuration file:</p><div class="informalexample"><pre class="programlisting">&lt;configuration&gt;

    &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
        &lt;encoder&gt;
            &lt;pattern&gt; %d{HH:mm:ss.SSS}[%thread]%-5level%logger{36}-%msg%n
            &lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;root level="INFO"&gt;
        &lt;appender-ref ref="STDOUT"/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;</pre></div><p class="calibre7">Now let's start the server and use Postman to make a call to the Unfiltered service. To start this example, run <code class="email">sbt runCH03-HelloUnfiltered</code> from the root directory of the sources:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">$ sbt runCH03-HelloUnfiltered</strong></span>
<span class="strong"><strong class="calibre8">[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project</strong></span>
<span class="strong"><strong class="calibre8">[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)</strong></span>
<span class="strong"><strong class="calibre8">[info] Running org.restwithscala.chapter3.gettingstarted.HelloUnfiltered </strong></span>
<span class="strong"><strong class="calibre8">10:04:32.108 [swj] INFO  org.eclipse.jetty.server.Server - jetty-8.1.13.v20130916</strong></span>
<span class="strong"><strong class="calibre8">10:04:32.178 [swj] INFO  o.e.jetty.server.AbstractConnector - Started SocketConnector@0.0.0.0:8080</strong></span>
<span class="strong"><strong class="calibre8">Embedded server listening at</strong></span>
<span class="strong"><strong class="calibre8">  http://0.0.0.0:8080</strong></span>
<span class="strong"><strong class="calibre8">Press any key to stop.</strong></span>
</pre></div><p class="calibre7">Open up <a id="id151" class="calibre1"/>Postman, click on the collection name <span class="strong"><strong class="calibre8">Chapter 03</strong></span>, and open the first request. Once you click on <span class="strong"><strong class="calibre8">Send</strong></span>, you should see the response, <span class="strong"><strong class="calibre8">Hello Unfiltered</strong></span>, being returned by the server:</p><div class="mediaobject"><img src="../images/00023.jpeg" alt="Your first Unfiltered service" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">In the next section, we'll look a bit more closely at how Unfiltered uses pattern matching to map incoming requests to functions.</p></div>
<div class="book" title="HTTP verb and URL matching"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec24" class="calibre1"/>HTTP verb and URL matching</h1></div></div></div><p class="calibre7">Unfiltered uses<a id="id152" class="calibre1"/> standard Scala pattern matching to determine what to do with a specific request. The following code shows how Unfiltered provides matchers for a number of simple REST calls:</p><div class="informalexample"><pre class="programlisting">package org.restwithscala.chapter3.steps

import unfiltered.request._
import unfiltered.response._

object Step1 extends App {

Thread.currentThread().setName("swj");


  object api extends unfiltered.filter.Plan {
    def intent = taskApi.onPass(fallback)

    def taskApi = unfiltered.filter.Intent {
      case GET(Path("/tasks")) 
            =&gt; ResponseString(s"Get all tasks" )
      case GET(Path(Seg("tasks" :: id :: Nil))) 
            =&gt; ResponseString(s"Get a single task with id: $id" )
      case DELETE(Path(Seg("tasks" :: id :: Nil)))   
           =&gt; ResponseString
                     (s"Delete an existing task with id $id")

      case req @ Path("/tasks") =&gt; req match {
        case POST(_) 
          =&gt; ResponseString(s"Create a new" +
                           s" task with body ${Body.string(req)}")
        case PUT(_) 
          =&gt; ResponseString(s"Update a new task with" +
                            s" body ${Body.string(req)}")
        case _ =&gt; Pass
      }
      case _ =&gt; Pass
    }

    def fallback = unfiltered.filter.Intent {
      case _ =&gt; NotImplemented ~&gt; 
                ResponseString("Function is not implemented")
    }
  }


  unfiltered.jetty.Server.http(8080).plan(api).run()

  println("Press &lt;enter&gt; to exit.")
  Console.in.read.toChar

}</pre></div><p class="calibre7">There is a lot to<a id="id153" class="calibre1"/> see in this code fragment, so let's start at the beginning. To create a REST API in Unfiltered, we need to create a <code class="email">Plan</code> object. A <code class="email">Plan</code> describes how to respond to specific requests. There are two different ways to create such a <code class="email">Plan</code>. You can directly pass in a partial function to <code class="email">unfiltered.filter.Planify</code>, like we did in the getting started example earlier in this chapter or explicitly extend from <code class="email">unfiltered.filter.Plan</code> and set the <code class="email">intent val</code> to your route configuration. In the rest of this chapter, we'll use the latter approach since it allows us to combine API parts in an easy manner. Let's start with the first set of matchers from the <code class="email">taskApi</code> instance:</p><div class="informalexample"><pre class="programlisting">      case GET(Path("/tasks")) 
            =&gt; ResponseString(s"Get all tasks" )
      case GET(Path(Seg("tasks" :: id :: Nil))) 
            =&gt; ResponseString(s"Get a single task with id: $id" )
      case DELETE(Path(Seg("tasks" :: id :: Nil))) 
            =&gt; ResponseString(s"Delete an existing task with id $id")</pre></div><p class="calibre7">As you can see, we use standard pattern matching from Scala. These patterns will be checked against the current <code class="email">HttpRequest</code> instance and will make use of a number of matchers provided by Unfiltered:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Matcher</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">GET</code> and the other HTTP verbs.</p>
</td><td valign="top" class="calibre23">
<p class="calibre21">With this matcher, we match the HTTP verb of the request. Unfiltered provides the following number of standard matchers for this: <code class="literal">GET</code>, <code class="literal">POST</code>, <code class="literal">PUT</code>, <code class="literal">DELETE</code>, <code class="literal">HEAD</code>, <code class="literal">CONNECT</code>, <code class="literal">OPTIONS</code>, <code class="literal">TRACE</code>, <code class="literal">PATCH</code>, <code class="literal">LINK</code>, and <code class="literal">UNLINK</code>.</p>
<p class="calibre21">Should you have edge cases where you need to match other verbs, you can easily create your own matcher like this: <code class="literal">object WOW extends Method("WOW")</code></p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">Path</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">The next matcher we see is the <code class="literal">Path</code> matcher. With this matcher, you check whether you match the complete URL path. So in the preceding example, the first pattern only matches when the exact <code class="literal">/tasks</code> path is called.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">Seq</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">If you want to extract path segments or match more flexibly on multiple path segments, you can use the <code class="literal">Seq</code> matcher. This matcher will check the URL on which the request was made, splits it into path segments, and check whether individual path segments match or extract path segments for further processing.</p>
</td></tr></tbody></table></div><p class="calibre7">So, in our API:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The first case matches a <code class="email">GET</code> request on the <code class="email">/tasks</code> path.</li><li class="listitem">The second case matches a <code class="email">GET</code> request on the <code class="email">/tasks/:id</code> path. The ID is passed into the function handling this case.</li><li class="listitem">The third case does the same as the second, but this time for a <code class="email">DELETE</code> request.</li></ul></div><p class="calibre7">Besides these <a id="id154" class="calibre1"/>matchers shown in this example, Unfiltered also provides the following:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Matcher</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">HTTP</code> and <code class="literal">HTTPS</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">These two matchers allow you to check whether the request was received over an HTTP or HTTPS connection.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">Json</code>/<code class="literal">JavaScript</code>/<code class="literal">XML</code> and more</p>
</td><td valign="top" class="calibre23">
<p class="calibre21">Unfiltered also allows you to check the Accepts header of a request. For instance, the JSON matcher will match when the <code class="literal">Accepts</code> header is <code class="literal">application/json</code> or a request is made on a URL with the extension <code class="literal">.js</code>, without an <code class="literal">Accepts</code> header. Unfiltered provides the following set of standard matchers of this type: <code class="literal">Json</code>, <code class="literal">JavaScript</code>, <code class="literal">AppJavaScript</code>, <code class="literal">Jsonp</code>, <code class="literal">Xml</code>, <code class="literal">Html</code>, and <code class="literal">Csv</code>. If you want to specify a new content-type matcher, you can do it like this:</p>
<div class="informalexample1"><pre class="programlisting1">
<span><strong class="calibre25">object Custom extends Accepting {</strong></span>
<span><strong class="calibre25">     val contentType = "application/vnd+company.category"</strong></span>
<span><strong class="calibre25">  val ext = "json"</strong></span>
<span><strong class="calibre25">}</strong></span>
</pre></div>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">HTTP_1_0</code>/<code class="literal">HTTP_1_1</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">Check whether the protocol was made using HTTP version 1.0 or HTTP version 1.1.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">Mime</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matcher allows you to check whether the request conforms to a specific mime-type.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21">Any header</p>
</td><td valign="top" class="calibre23">
<p class="calibre21">Unfiltered also provides matchers and extractors for a large set of other HTTP headers. There are too many to list here; for a complete overview look at the objects in the <code class="literal">headers.scala</code> file from the Unfiltered sources.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">Params</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">With this matcher-extractor, you can match a specific request parameter. We will show an example of this extractor in the next section.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">RemoteAddr</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">Specific matcher that checks whether the <code class="literal">XForwaredFor</code> header contains a trusted address.</p>
</td></tr></tbody></table></div><p class="calibre7">Let's look back at the example, especially the <code class="email">PUT</code> and <code class="email">POST</code> calls on the <code class="email">/tasks</code> URL. For these two routes, we used an alternative approach:</p><div class="informalexample"><pre class="programlisting">   case req @ Path("/tasks") =&gt; req match {
        case POST(_) 
          =&gt; ResponseString(s"Create a new" +
                            s" task with body ${Body.string(req)}")
        case PUT(_) 
          =&gt; ResponseString(s"Update a new task with" +
                            s" body ${Body.string(req)}")
        case _ =&gt; Pass
      }</pre></div><p class="calibre7">Here, we first match on the <code class="email">Path("/tasks")</code> route and then use the matching request to determine what to do for the different verbs. This is a convenient way to handle multiple verbs that can be used to make a call to the same URL.</p><p class="calibre7">In this case, we can <a id="id155" class="calibre1"/>handle a <code class="email">POST</code> and a <code class="email">PUT</code> call, and just ignore any other call by returning <code class="email">Pass</code>. When we return <code class="email">Pass</code>, we just tell Unfiltered that this intent can't handle the request. When Unfiltered can't match a request with the current intent, it will just try the next. We've used this approach in our example:</p><div class="informalexample"><pre class="programlisting">  object api extends unfiltered.filter.Plan {
    def intent = taskApi.onPass(fallback)

    def taskApi = unfiltered.filter.Intent { ... }
    def fallback = unfiltered.filter.Intent {
      case _ =&gt; NotImplemented ~&gt; 
                ResponseString("Function is not implemented")
    }</pre></div><p class="calibre7">In our <code class="email">Plan</code>, we defined two intents: one that handled our API, the <code class="email">taskAPI</code> intent, and one that could serve as fallback when the <code class="email">taskAPI</code> intent didn't match, aptly named <code class="email">fallback</code> (we'll explain more about this later in this chapter). The <code class="email">fallback</code> intent returns the HTTP code, <code class="email">NotImplemented</code>, with a message. By calling <code class="email">taskApi.onPass(fallback)</code>, we tell Unfiltered that when the <code class="email">taskAPI</code> intent returns a <code class="email">Pass</code> result, it should try the <code class="email">fallback</code> intent. The <code class="email">fallback</code> intent can also configure an <code class="email">onPass</code> result, and this way, you can easily chain and combine APIs.</p><p class="calibre7">To test this service, start it with the <code class="email">sbt runCH03-runCH03Step1</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">$ sbt runCH03-runCH03Step1</strong></span>
<span class="strong"><strong class="calibre8">[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project</strong></span>
<span class="strong"><strong class="calibre8">[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)</strong></span>
<span class="strong"><strong class="calibre8">[info] Running org.restwithscala.chapter3.steps.Step1 </strong></span>
<span class="strong"><strong class="calibre8">15:06:36.085 [swj] INFO  org.eclipse.jetty.server.Server - jetty-8.1.13.v20130916</strong></span>
<span class="strong"><strong class="calibre8">15:06:36.160 [swj] INFO  o.e.jetty.server.AbstractConnector - Started SocketConnector@0.0.0.0:8080</strong></span>
<span class="strong"><strong class="calibre8">Embedded server listening at</strong></span>
<span class="strong"><strong class="calibre8">  http://0.0.0.0:8080</strong></span>
<span class="strong"><strong class="calibre8">Press any key to stop.</strong></span>
</pre></div><p class="calibre7">The collection for <span class="strong"><strong class="calibre8">Chapter 03</strong></span> in Postman provides you with a number of requests you can use to test this server. For instance, the call to create a new task looks similar to this:</p><div class="mediaobject"><img src="../images/00024.jpeg" alt="HTTP verb and URL matching" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">And when we hit the <code class="email">fallback</code> route, we see the following screenshot:</p><div class="mediaobject"><img src="../images/00025.jpeg" alt="HTTP verb and URL matching" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">So far, we've only focused on routing and matching requests. In the next section, we'll look at how we can access the request parameters and use the Scala <code class="email">Future</code> object to create asynchronous responses.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Extracting request parameters and using futures for asynchronous responses"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec25" class="calibre1"/>Extracting request parameters and using futures for asynchronous responses</h1></div></div></div><p class="calibre7">Now that we've got the <a id="id156" class="calibre1"/>basics covered, let's see what we need to do to convert the incoming request parameters and body into our domain model (our case classes). In this section, we'll take the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Convert the incoming request to a <code class="email">Task</code> case class.</li><li class="listitem" value="2">Store the converted <code class="email">Task</code> in our dummy <code class="email">TaskService</code>.</li><li class="listitem" value="3">The <code class="email">TaskService</code> object returns a <code class="email">Future[Task]</code>; we will change the Unfiltered configuration to start handling requests asynchronously.</li></ol><div class="calibre13"/></div><p class="calibre7">Let's start with the first part and look at the route configuration and how to convert the incoming request to a <code class="email">Task</code> case class. The complete source for this example can be found in the <code class="email">Step2.scala</code> file in the <code class="email">rest-with-scala/chapter-03/src/main/scala/org/restwithscala/chapter3/steps/</code> directory.</p><p class="calibre7">Let's first show you the complete code and then we'll look at the individual parts in more detail. Note <a id="id157" class="calibre1"/>that we've only implemented a part of the complete task API here:</p><div class="informalexample"><pre class="programlisting">object Step2 extends App {

  implicit def ec = ExecutionContext.Implicits.global

  @io.netty.channel.ChannelHandler.Sharable
  object api extends future.Plan with ServerErrorResponse {

    implicit def executionContext = ec

    def intent =  {
      case GET(Path("/tasks")) =&gt; Future 
       {ResponseString(s"Get all tasks" )}
      case GET(Path(Seg("tasks" :: id :: Nil))) =&gt; Future 
       {ResponseString(s"Get a single task with id: $id" )}
      case DELETE(Path(Seg("tasks" :: id :: Nil))) =&gt; Future
       {ResponseString(s"Delete an existing task with id $id")}

      case req @ Path("/tasks")) =&gt; req match {
        case POST(_) =&gt; 
         handleCreateTask(req).map(ResponseString(_))
        case PUT(_) =&gt; 
           handleCreateTask(req).map(ResponseString(_))
        case _ =&gt; Future {Pass}
      }

      case _ =&gt; Future{Pass}
    }
  }
  @io.netty.channel.ChannelHandler.Sharable
  object fallback extends future.Plan with ServerErrorResponse {
    implicit def executionContext = ec
    def intent =  {
      case _ =&gt; Future {NotImplemented ~&gt; 
               ResponseString("Function is not implemented")}
    }
  }
  
  def handleCreateTask(req: HttpRequest[Any]): Future[String] = {
    val task = requestToTask(TaskService.nextTaskId(), req)
    val inserted = task map(TaskService.insert(_).map(_.toString))

    inserted.getOrElse(Future{"Error inserting"})
  }

  def paramExtractor(param: String): Extract[String] = {
     new Extract[String]( param, 
               Params.first ~&gt; Params.nonempty ~&gt; Params.trimmed)
  }

  def requestToTask(id: Long, req: HttpRequest[Any])
                                         : Option[Task] = {
    val title = paramExtractor("title")

    req match {
      case Params(title(param)) =&gt; Some(Task(
        id, param, Body.string(req),
        None, List.empty[Note], Status("")))

      case _ =&gt; None
    }
  }

  unfiltered.netty.Server.http(8080)
         .handler(api)
         .handler(fallback).run
  dispatch.Http.shutdown()
}</pre></div><p class="calibre7">The first part <a id="id158" class="calibre1"/>we'll look at more closely is how to convert an incoming request to a <code class="email">Task</code> case class.</p></div>

<div class="book" title="Extracting request parameters and using futures for asynchronous responses">
<div class="book" title="Converting a request to a Task class"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec20" class="calibre1"/>Converting a request to a Task class</h2></div></div></div><p class="calibre7">The following <a id="id159" class="calibre1"/>code fragment shows how we can convert a request to a <code class="email">Task</code> case class with Unfiltered:</p><div class="informalexample"><pre class="programlisting">def paramExtractor(param: String): Extract[String] = {
   new Extract[String]( param, Params.first ~&gt; Params.nonempty)
}

def requestToTask(id: Long, req: HttpRequest[Any]): Option[Task] = {
  val title = paramExtractor("title")

  req match {
    case Params(title(param)) =&gt; Some(Task(
      id,
      param,
      Body.string(req),
      None,
      List.empty[Note],
    Status("")))

    case _ =&gt; None
  }
}</pre></div><p class="calibre7">We defined <a id="id160" class="calibre1"/>a function named <code class="email">requestToTask</code> which converts an incoming <code class="email">HttpRequest</code> and an ID to a <code class="email">Task</code>. The first step we take in this function is to create a custom extractor, based on a number of standard Unfiltered constructs:</p><div class="informalexample"><pre class="programlisting">def paramExtractor(param: String): Extract[String] = {
   new Extract[String]( param, Params.first ~&gt; Params.nonempty)
}</pre></div><p class="calibre7">In this function, we create a custom extractor by extending the <code class="email">Extract</code> class provided by Unfiltered. This class has a constructor with two arguments. The first one is the name of the parameter we want to extract and the second is a function with the <code class="email">Seq[String] =&gt; Option[T]</code> signature. The second parameter can be used to provide a set of predicates, which Unfiltered uses to check whether the value is available, and has the correct format. In this scenario, we used two predicates provided by Unfiltered. <code class="email">Params.first</code> returns the first parameter value with the provided name or <code class="email">None</code>, and the <code class="email">Params.nonempty</code> returns <code class="email">None</code> if the result from <code class="email">Params.first</code> is empty, and returns <code class="email">Some[String]</code> if it isn't. As you can see, we can use the <code class="email">~&gt;</code> operator to chain predicates together (this operator is just syntactic sugar for the <code class="email">andThen</code> function).</p><p class="calibre7">We now can use this extractor in our pattern matching logic:</p><div class="informalexample"><pre class="programlisting">  req match {
    case Params(title(param)) =&gt; ...</pre></div><p class="calibre7">This means that this pattern will only match if one of the provided parameters has the name <code class="email">title</code> and isn't empty. Out of the box Unfiltered provides the following constructs you can use when creating new matchers and extractors:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Predicate</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">even</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns the parameter value if it can be converted to an integer and the result is even.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">odd</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns the parameter value if it can be converted to an integer and the result is odd.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">nonempty</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns the parameter value if it isn't empty.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">first</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns the first value of a parameter. For example, in the case of <code class="literal">?id=10&amp;id=20</code>, it will return <code class="literal">10</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">int</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">If the parameter value can be converted to an integer, it will return the integer value.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">long</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">If the parameter value can be converted to a long, it will return the long value.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">float</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">If the parameter value can be converted to a float, it will return the float value.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">double</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">If the parameter value can be converted to a double, it will return the double value.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">trimmed</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This will use <code class="literal">String.trim</code> to trim the parameter value.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">~&gt;</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This creates a sequence of predicates, for example, <code class="literal">first ~&gt; nonempty ~&gt; trimmed</code>.</p>
</td></tr></tbody></table></div><p class="calibre7">At this point, we <a id="id161" class="calibre1"/>check whether we've got a non-empty title parameter, and if we do, we convert the incoming request to a <code class="email">Task</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip08" class="calibre1"/>Tip</h3><p class="calibre7">Unfiltered also provides a way you can use multiple extractors at the same time. With the <code class="email">&amp;</code> matcher, you can combine two extractors. The pattern will only match if both sides of the <code class="email">&amp;</code> matched succeed. For instance, we could check whether the parameters contain a non-empty title and an integer amount like this:</p><div class="informalexample"><pre class="programlisting">val title = new Extract[String]( "title", Params.first ~&gt; Params.nonempty)
val amount  = new Extract[String]( "amount", Params.first ~&gt; Params.nonempty ~&gt; int)</pre></div><p class="calibre7">And use it in a pattern, like this:</p><div class="informalexample"><pre class="programlisting">case Params(title(titleValue) &amp; amount(amountValue))</pre></div><p class="calibre7">We'll see more of this in the section on validation later in this chapter.</p></div><p class="calibre7">To finally convert the request into a <code class="email">Task</code>, we just call the constructor directly, like this:</p><div class="informalexample"><pre class="programlisting">    case Params(title(param)) =&gt; Some(Task(
      id,
      param,
      Body.string(req),
      None,
      List.empty[Note],
    Status("")))</pre></div><p class="calibre7">Now that we can convert a request to a <code class="email">Task</code>, let's look at how we call this from our route and store it.</p></div></div>

<div class="book" title="Extracting request parameters and using futures for asynchronous responses">
<div class="book" title="Storing a request in the TaskService"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec21" class="calibre1"/>Storing a request in the TaskService</h2></div></div></div><p class="calibre7">To store the <a id="id162" class="calibre1"/>request in the <code class="email">TaskService</code>, we have to call the <code class="email">TaskService.insert</code> function. We use the following code to do that:</p><div class="informalexample"><pre class="programlisting">  case req @ Path("/tasks") =&gt; req match {
    case POST(_) =&gt; handleCreateTask(req).map(ResponseString(_))
    case PUT(_) =&gt; handleCreateTask(req).map(ResponseString(_))
    case _ =&gt; Future {Pass}
  }

  ...

  def handleCreateTask(req: HttpRequest[Any]): Future[String] = {
    val task = requestToTask(TaskService.nextTaskId(), req)
    val insertedTask = task 
           map(TaskService.insert(_).map(_.toString))

    insertedTask.getOrElse(Future{"Error inserting"})
  }</pre></div><p class="calibre7">When we receive a <code class="email">POST</code> or <code class="email">PUT</code> request on <code class="email">/tasks</code>, we pass the request on to the <code class="email">handleCreateTask</code> function. In this function, we convert the request to a <code class="email">Task</code> using the code we discussed previously, and store it with the <code class="email">TaskService.insert</code> function. For now, we'll just return the <code class="email">toString</code> of the created <code class="email">Task</code> if we converted and stored the <code class="email">Task</code> successfully. If something went wrong, we return a simple error message, also a string. We then return the created <code class="email">Task</code> or the error message using the <code class="email">ResponseString</code> function.</p><p class="calibre7">The <code class="email">handleCreateTask</code> function returns a <code class="email">Future[String]</code> object, so what we have to do is make sure that our Unfiltered configuration can handle futures.</p></div></div>

<div class="book" title="Extracting request parameters and using futures for asynchronous responses">
<div class="book" title="Configuring Unfiltered to work with futures"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec22" class="calibre1"/>Configuring Unfiltered to work with futures</h2></div></div></div><p class="calibre7">Changing the<a id="id163" class="calibre1"/> configuration from a synchronous to an asynchronous model is very easy. The first thing we need to do is change the underlying server from Jetty to Netty. We need to do this because the asynchronous functionality is built on top of Netty, and thus, won't work with Jetty. To use Netty, we need to add the following two dependencies to our SBT configuration:</p><div class="informalexample"><pre class="programlisting">    "net.databinder" %% "unfiltered-netty" % "0.8.4"
    "net.databinder" %% "unfiltered-netty-server" % "0.8.4"</pre></div><p class="calibre7">Next, we need to change the way we create our API:</p><div class="informalexample"><pre class="programlisting">  implicit def ec = ExecutionContext.Implicits.global

  @io.netty.channel.ChannelHandler.Sharable
  object api extends future.Plan with ServerErrorResponse {

    def executionContext = ec

    def intent =  ..
      
  }</pre></div><p class="calibre7">Instead of <a id="id164" class="calibre1"/>extending from <code class="email">unfiltered.filter.Plan</code>, we extend from <code class="email">future.Plan</code> (with <code class="email">ServerErrorResponse</code>, which you can use to handle exception in a generic way). If we work with futures, we also need to define the execution context we want to use. This is used by Unfiltered to run futures asynchronously. In this case, we just use the default global execution context. Note that we need to add the <code class="email">io.netty.channel.ChannelHandler.Sharable</code> annotation to our API. If we don't do this, Netty will block any incoming requests, and only one thread can access the API at the same time. Since we move our service to Netty, we also need to start the server in a slightly different way:</p><div class="informalexample"><pre class="programlisting">  unfiltered.netty.Server.http(8080)
      .handler(api)
      .handler(fallback).run
  dispatch.Http.shutdown()</pre></div><p class="calibre7">The last step we need to take to work with futures is to make sure that all our pattern match cases also return a <code class="email">Future</code> object. We do this simply by wrapping the responses in a <code class="email">Future</code>:</p><div class="informalexample"><pre class="programlisting">      case GET(Path("/tasks")) =&gt; Future 
       {ResponseString(s"Get all tasks" )}
      case GET(Path(Seg("tasks" :: id :: Nil))) =&gt; Future 
       {ResponseString(s"Get a single task with id: $id" )}
      case DELETE(Path(Seg("tasks" :: id :: Nil))) =&gt; Future
       {ResponseString(s"Delete an existing task with id $id")}

      case req @ Path("/tasks")) =&gt; req match {
        case POST(_) =&gt; 
         handleCreateTask(req).map(ResponseString(_))
        case PUT(_) =&gt; handleCreateTask(req).map(ResponseString(_))
        case _ =&gt; Future {Pass}
      }

      case _ =&gt; Future{Pass}</pre></div><p class="calibre7">Most of the responses are explicitly wrapped in a <code class="email">Future</code> object. For the <code class="email">handleCreateTask</code> function, we already receive a <code class="email">Future[String]</code> object, so just use <code class="email">map</code> to convert it to the correct type using a <code class="email">ResponseString</code> instance.</p><p class="calibre7">As for all the <a id="id165" class="calibre1"/>examples, we've also provided a set of sample requests you can use to test this REST API. You can find the requests in the <span class="strong"><strong class="calibre8">Chapter 03</strong></span> collection in Postman. The most interesting requests to play around with are <span class="strong"><strong class="calibre8">Step 02 – CreateTask</strong></span>, <span class="strong"><strong class="calibre8">Step 02 – Create Task – Invalid</strong></span>, and <span class="strong"><strong class="calibre8">Step 02 – Trigger Fallback</strong></span>.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Adding validation to parameter processing"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec26" class="calibre1"/>Adding validation to parameter processing</h1></div></div></div><p class="calibre7">So far, we <a id="id166" class="calibre1"/>haven't really validated the incoming request. We just checked whether a parameter was provided, and if not, completely failed the request. This works, but is a rather cumbersome way of validating input parameters. Luckily, Unfiltered provides an alternative way of validation by using something called directives. With a directive, you tell Unfiltered what you expect, for example, a parameter that can be converted to an int, and Unfiltered will either get the value or respond with an appropriate response message. In other words, with a directive, you define a set of criteria the request must fulfill.</p></div>

<div class="book" title="Adding validation to parameter processing">
<div class="book" title="Introducing directives"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec23" class="calibre1"/>Introducing directives</h2></div></div></div><p class="calibre7">Before <a id="id167" class="calibre1"/>we look at how we can use a directive in our scenario, let's look at how you can use a directive in your code:</p><div class="informalexample"><pre class="programlisting">import unfiltered.directives._, Directives._

val intent = { Directive.Intent {
  case Path("/") =&gt;
    for {
      _ &lt;- Accepts.Json
      _ &lt;- GET
      amount &lt;- data.as.Option[Int].named("amount") } yield JsonContent ~&gt; ResponseString(
          """{ "response": "Ok" }""")
}</pre></div><p class="calibre7">In this intent, we use <code class="email">Directive.Intent</code> to indicate that we want to create an intent that uses directives to process the request. In this sample, <code class="email">Accepts.Json</code>, <code class="email">GET</code>, and <code class="email">data.as.Option[Int].named("amount")</code> are all directives. When one of the directives fails, an appropriate error response is returned automatically. With directives, you can pretty much move your matcher and extractor logic to a set of directives.</p><p class="calibre7">Out of the box, Unfiltered comes with a number of directives, which automatically return a response when they don't match:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Directive</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">GET</code>, <code class="literal">POST</code>, and the other HTTP verbs</p>
</td><td valign="top" class="calibre23">
<p class="calibre21">You can match on all the methods. If a method doesn't match, a <code class="literal">MethodNotAllowed</code> response is returned.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">Accepts.Json</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">All the <code class="literal">Accepts.Accepting</code> definitions are supported. If one of these should fail, you get a <code class="literal">NotAcceptable</code> response.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">QueryParams</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">Get all the query parameters from the request.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">Params</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">You can check whether a single parameter is available. If not, a <code class="literal">BadRequest</code> response is returned.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">data.as</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">The <code class="literal">data.as</code> directive allows you to get a parameter and convert it to a specific value. It provides standard directives to convert a parameter to: BigDecimal, BigInt, Double, Float, Int, Long, and String. Besides that, it also allows you to specify whether a value is an option or required.</p>
</td></tr></tbody></table></div><p class="calibre7">Let's look a bit closer <a id="id168" class="calibre1"/>at the <code class="email">data.as</code> directive since that is the most interesting one when trying to validate input. To use this directive, we first define an implicit function like this:</p><div class="informalexample"><pre class="programlisting">implicit val intValue =
  data.as.String ~&gt; data.as.Int.fail { (k,v) =&gt;
    BadRequest ~&gt; ResponseString(
      s"'$v' is not a valid int for $k"
    )
}</pre></div><p class="calibre7">And use it from the <code class="email">for</code> comprehension like this:</p><div class="informalexample"><pre class="programlisting"> ...
 for {
  value &lt;- data.as.Int.named("amount")
 } yield {...}</pre></div><p class="calibre7">If the request parameter with the name <code class="email">amount</code> is present and can be converted to an int, we'll retrieve that value. If it isn't present, nothing will happen, and if it can't be converted to an int, the specified <code class="email">BadRequest</code> message will be returned. We can also make it <code class="email">Optional</code> by just requesting <code class="email">data.as.Option[Int]</code> instead. Having a value as an option is nice, but sometimes you want to make sure that a specific query parameter is always present. For that, we can use <code class="email">Required</code>. To use <code class="email">Required</code>, we first have to add another <code class="email">implicit</code> function to define what happens when a required field isn't present:</p><div class="informalexample"><pre class="programlisting">implicit def required[T] = data.Requiring[T].fail(name =&gt;
  BadRequest ~&gt; ResponseString(name + " is missing\n")
)</pre></div><p class="calibre7">This means that we return a <code class="email">BadRequest</code> message with the specified response when a <code class="email">Required</code> field is missing. To use the <code class="email">Required</code> field, we simply change <code class="email">data.as.Int</code> to <code class="email">data.as.Required[Int]</code>:</p><div class="informalexample"><pre class="programlisting">...
 for {
  value &lt;- data.as.Required[Int].named("amount")
 } yield {...}</pre></div><p class="calibre7">Now, Unfiltered <a id="id169" class="calibre1"/>will first check if the field is present, and if it is, will check whether it can be converted to an int. When one of the checks fails, the correct response message will be returned.</p></div></div>

<div class="book" title="Adding validation to parameter processing">
<div class="book" title="Adding search functionality to our API"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec24" class="calibre1"/>Adding search functionality to our API</h2></div></div></div><p class="calibre7">Now let's <a id="id170" class="calibre1"/>move on to our example. For this scenario, we'll add a <code class="email">search</code> function to our API. This <code class="email">search</code> function will allow you to search on the status and the text of a task, and return a list of tasks that match. Let's first look at the complete code before we dive into the individual parts:</p><div class="informalexample"><pre class="programlisting">package org.restwithscala.chapter3.steps

import org.restwithscala.common.model._
import org.restwithscala.common.service.TaskService
import unfiltered.directives.{Directive =&gt; UDirective, ResponseJoiner, data}
import unfiltered.request._
import unfiltered.response._
import unfiltered.netty._
import scala.concurrent.{ExecutionContext}
import scala.concurrent.Future
import scalaz._
import scalaz.std.scalaFuture._

object Step3 extends App {


  /**
   * Object holds all the implicit conversions used by Unfiltered to
   * process the incoming requests.
   */
  object Conversions {

  case class BadParam(msg: String) extends ResponseJoiner(msg)(
    msgs =&gt;
      BadRequest ~&gt; ResponseString(msgs.mkString("","\n","\n"))
  )


    implicit def requiredJoin[T] = data.Requiring[T].fail(name =&gt;
      BadParam(name + " is missing")
    )

    implicit val toStringInterpreter = data.as.String

    val allowedStatus = Seq("new", "done", "progress")
    val inStatus = data.Conditional[String](
                        allowedStatus contains (_)).fail(
      (k, v) =&gt; BadParam(s" value not allowed: $v, should be one of ${allowedStatus.mkString(",")} ")
    )
  }


  Thread.currentThread().setName("swj");
  implicit def ec = ExecutionContext.Implicits.global

  // This plan contains the complete API. Works asynchronously
  // directives by default don't work with futures. Using the d2
  // directives, we can wrap the existing directives and use the
  // async plan.
  @io.netty.channel.ChannelHandler.Sharable
  object api extends async.Plan with ServerErrorResponse {

    // Import the required d2 directives so we can work
    // with futures and directives together. We also bring
    // the implicit directive conversions into scope.
    val D = d2.Directives[Future]
    import D._
    import D.ops._
    import Conversions._

    // maps the requests so that we can use directives with the
    // async intent. In this case we pass on the complete request
    // to the partial function
    val MappedAsyncIntent = d2.Async.Mapping[Any, HttpRequest[Any]] {
      case req: HttpRequest[Any] =&gt; req
    }

    // d2 provides a function to convert standard Unfiltered
    // directives to d2 directives. This implicit conversion
    // makes using this easier by adding a toD2 function to
    // the standard directives.
    implicit class toD2[T, L, R](s: UDirective[T, L, R]) {
      def toD2 = fromUnfilteredDirective(s)
    }

    // our plan requires an execution context,
    def executionContext = ec
    def intent = MappedAsyncIntent {
      case Path("/search") =&gt; handleSearchSingleError
    }

    def handleSearchSingleError = for {
      status &lt;- inStatus.named("status").toD2
      text1 &lt;- data.as.Required[String].named("text").toD2
      tasks &lt;- TaskService
               .search(status.get,Some(text1)).successValue
    } yield {Ok ~&gt; ResponseString(tasks.toString()) }
  }
  unfiltered.netty.Server.http(8080).handler(api).run
  dispatch.Http.shutdown()
}</pre></div><p class="calibre7">Lots of code <a id="id171" class="calibre1"/>and some of it might look a bit strange. In the following sections, we'll see why we did it this way.</p></div></div>

<div class="book" title="Adding validation to parameter processing">
<div class="book" title="Directives and working with futures"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec25" class="calibre1"/>Directives and working with futures</h2></div></div></div><p class="calibre7">Before we <a id="id172" class="calibre1"/>dive into the directives, you might notice some additional code regarding d2. For this example, we needed to use the <code class="email">Directives2</code> library from <a class="calibre1" href="https://github.com/shiplog/directives2/">https://github.com/shiplog/directives2/</a> so that we can correctly work combining futures and directives. The standard directives, as provided by Unfiltered, don't support asynchronous plans and only allow you to use the synchronous Jetty approach. With the <code class="email">Directives2</code> directives, we can work with futures and use one of the available asynchronous plans provided by Unfiltered.</p><p class="calibre7">There is, however, some glue code required for this to get it to work. The following changes needed to be made to the previous step to make directives work nicely together with futures:</p><p class="calibre7">Move from <code class="email">future.Plan</code> to <code class="email">async.Plan</code>:</p><div class="informalexample"><pre class="programlisting">@io.netty.channel.ChannelHandler.Sharable
  object api extends async.Plan with ServerErrorResponse {</pre></div><p class="calibre7">The d2 directives support the <code class="email">async.Plan</code> class, but don't support the <code class="email">future.Plan</code>. Luckily, this doesn't change the rest of the code for us. The next step is to import the d2 classes and objects:</p><div class="informalexample"><pre class="programlisting">    val D = d2.Directives[Future]
    import D._
    import D.ops._
    import Conversions._</pre></div><p class="calibre7">With these <a id="id173" class="calibre1"/>imports, we get the ability to work with futures as directives, and it allows us to convert standard Unfiltered directives to d2 directives. The next step to do is to use the <code class="email">d2.Async.Mapping</code> object to glue our new asynchronous directives to our <code class="email">async.Plan</code>:</p><div class="informalexample"><pre class="programlisting">    val MappedAsyncIntent = d2.Async.Mapping[Any, HttpRequest[Any]] {
      case req: HttpRequest[Any] =&gt; req
    }</pre></div><p class="calibre7">In this setup, we'll just pass any request we receive to a partial function, which we define like this:</p><div class="informalexample"><pre class="programlisting">    def intent = MappedAsyncIntent {
      case Path("/search") =&gt; handleSearchSingleError
    }</pre></div><p class="calibre7">Now whenever we receive a request on the <code class="email">/search</code> path, we pass it on to the <code class="email">handleSearchSingleError</code> function. The final step we do is that we create a simple helper method to make converting our standard directives to d2 directives:</p><div class="informalexample"><pre class="programlisting">    implicit class toD2[T, L, R](s: UDirective[T, L, R]) {
      def toD2 = fromUnfilteredDirective(s)
    }</pre></div><p class="calibre7">When this <code class="email">implicit</code> is in scope, we can just call <code class="email">toD2</code> on our normal directives so that they can work correctly with the ones from the d2 library.</p></div></div>

<div class="book" title="Adding validation to parameter processing">
<div class="book" title="Adding validation to the request parameters"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch03lvl2sec26" class="calibre1"/>Adding validation to the request parameters</h2></div></div></div><p class="calibre7">Now <a id="id174" class="calibre1"/>that we've got the d2 stuff out of the way, let's look at the definition of our validations. We've defined all our directives implicitly in a <code class="email">Conversions</code> object:</p><div class="informalexample"><pre class="programlisting">  object Conversions {

    case class BadParam(msg: String) extends ResponseJoiner(msg)(
      msgs =&gt;
        BadRequest ~&gt; ResponseString(msgs.mkString("","\n","\n"))
    )

    implicit def required[T] = data.Requiring[T].fail(name =&gt;
      BadParam(name + " is missing")
    )

    implicit val toStringInterpreter = data.as.String

    val allowedStatus = Seq("new", "done", "progress")
    val inStatus = data.Conditional[String](
                        allowedStatus contains (_)).fail(
      (k, v) =&gt; BadParam(s" value not allowed: $v, should
                be one of ${allowedStatus.mkString(",")} ")
    )
  }</pre></div><p class="calibre7">Here, we<a id="id175" class="calibre1"/> define three implicit values—<code class="email">required</code> checks whether a value is present, <code class="email">toStringInterpreter</code> tries to convert a parameter to a string, and <code class="email">inStatus</code> checks whether a string is one of the specific set of values. If one of them fails, the <code class="email">fail</code> function is called and an error is returned. Here, however, we don't directly return the error as an <code class="email">HttpResponse</code>, but return it as a <code class="email">BadParam</code> class. This <code class="email">BadParam</code> case class serves as a collector of errors and allows a standard way to report one or more errors. In the next section, we'll come back to this. For now, we'll just report the first error we see. We do this by setting up a <code class="email">for</code> comprehension like this:</p><div class="informalexample"><pre class="programlisting">    def handleSearchSingleError = for {
      status &lt;- inStatus.named("status").toD2
      text1 &lt;- data.as.Required[String].named("text").toD2
      tasks &lt;- TaskService
               .search(status.get,Some(text1)).successValue
    } yield {Ok ~&gt; ResponseString(tasks.toString()) }</pre></div><p class="calibre7">This <code class="email">for</code> comprehension works just like any normal one. First, we check whether the status query parameter is valid. If it is, we get the text value and then we use both these values to search through the <code class="email">TaskService</code>, and finally return the result from the <code class="email">TaskService</code> as a string. One remark here is the <code class="email">successValue</code> function we call on the <code class="email">Future</code> returned from the <code class="email">TaskService</code>. This is a d2 specific call, which transforms the <code class="email">Future</code> into a directive.</p><p class="calibre7">Let's open Postman and first make a request with an invalid status:</p><div class="mediaobject"><img src="../images/00026.jpeg" alt="Adding validation to the request parameters" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">As you can see, the <a id="id176" class="calibre1"/>error message shows what we expect. However, as you might have noticed, we also didn't enter a text value, but the error message didn't show that. The reason is that our <code class="email">for</code> comprehension stops at the first error.</p><p class="calibre7">Luckily, Unfiltered provides a way to combine errors. All we have to do is change our <code class="email">for</code> loop to the following:</p><div class="informalexample"><pre class="programlisting">    def handleSearchCombinedError = for {
      (status, text) &lt;- (
             (data.as.Required[String].named("status")) &amp;
             (data.as.Required[String].named("text"))
            ).toD2
      tasks &lt;- TaskService.search(status,Some(text)).successValue
    } yield {
        Ok ~&gt; ResponseString(tasks.toString())</pre></div><p class="calibre7">By using the <code class="email">&amp;</code> operator we can combine directives together. Now each part of the combined directives will log its errors using the <code class="email">BadParam</code> case class, which will respond with all the errors it has collected. You can see how this works in the following screenshot:</p><div class="mediaobject"><img src="../images/00027.jpeg" alt="Adding validation to the request parameters" class="calibre10"/></div><p class="calibre11"> </p></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec27" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we saw some of the most important aspects of Unfiltered. You learned how to handle requests, use matchers and extractors to route requests, and access parameters and path segments. You also learned that Unfiltered provides different processing models, synchronous and asynchronous, and how to run your service either on top of Jetty or on Netty. In the last section, we explored how directives in Unfiltered can be used to extract parameters in a more powerful way and the additional steps you need to take to use those in an asynchronous manner.</p><p class="calibre7">All in all, as you saw, Unfiltered is a very flexible framework, which is easily extensible, and gives you full control over the response-request cycle.</p></div></body></html>