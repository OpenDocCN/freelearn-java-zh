- en: Appendix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This appendix will walk you through lambda expressions, functional types, mixing
    object-oriented and reactive programming, and how schedulers work.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java officially supported lambda expressions when Java 8 was released in 2014\.
    *Lambda expressions* are shorthand implementations for **single abstract method**
    (**SAM**) classes. In other words, they are quick ways to pass functional arguments
    instead of anonymous classes.
  prefs: []
  type: TYPE_NORMAL
- en: Making a Runnable a lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prior to Java 8, you might have leveraged anonymous classes to implement interfaces,
    such as `Runnable`, on the fly as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement `Runnable` without declaring an explicit class, you had to implement
    its `run()` abstract method in a block immediately after the constructor. This
    created a lot of boilerplate and became a major pain point with Java development,
    and was a barrier to using Java for functional programming. Thankfully, Java 8
    officially brought lambdas to the Java language. With lambda expressions, you
    can express this in a much more concise way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Awesome, right? That is a lot less code and boilerplate noise, and we will dive
    into how this works. Lambda expressions can target any interface or abstract class
    with one abstract method, which is called *single abstract method* types. In the
    preceding code, the `Runnable` interface has a single abstract method called `run()`.
    If you pass a lambda that matches the arguments and return type for that abstract
    method, the compiler will use that lambda for the implementation of that method.
  prefs: []
  type: TYPE_NORMAL
- en: Everything to the left of the `->` arrow is an argument. The `run()` method
    of `Runnable` does not take any arguments, so the lambda provides no arguments
    with the empty parenthesis `()`. The right side of the arrow `->` is the action
    to be executed. In this example, we are calling a single statement and printing
    a simple message with `System.out.println("run() was called!");`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java 8 lambdas can support multiple statements in the body. Say we have this
    `Runnable` anonymous inner class with multiple statements in its `run()` implementation,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can move both `System.out.println()` statements to a lambda by wrapping
    them in a multiline `{ }` block to the right of the arrow `->`. Note that you
    need to use semicolons to terminate each line within the lambda, shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Making a Supplier a lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lambdas can also implement methods that return items. For instance, the `Supplier`
    class introduced in Java 8 (and originally introduced in Google Guava) has an
    abstract `get()` method that returns a `T` item for a given `Supplier<T>`. If
    we have a `Supplier<List<String>>` whose `get()` returns `List<String>`, we can
    implement it using an old-fashioned anonymous class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'But we can also use a lambda, which can implement `get()` much more succinctly
    and yield `List<String>`, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When your lambda is simplify invoking a constructor on a type using the `new`
    keyword, you can use a double colon `::` lambda syntax to invoke the constructor
    on that class. This way, you can leave out the symbols `()` and `->`, shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: RxJava does not have Java 8's Supplier but rather a Callable, which accomplishes
    the same purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Making a Consumer a lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Consumer<T>` accepts a `T` argument and performs an action with it but does
    not return any value. Using an anonymous class, we can create a `Consumer<String>`
    that simply prints the string as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can implement this as a lambda. We can choose to call the `String` parameter
    `s` on the left-hand side of the lambda arrow `->` and print it on the right-hand
    side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler can actually infer that `s` is a `String` type based on the `Consumer<String>`
    you are targeting. So you can leave that explicit type declaration out, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For a simple single method invocation, you can actually use another syntax
    to declare the lambda using a double colon `::`. Declare the type you are targeting
    on the left-hand side of the double-colon and invoke its method on the right-hand
    side of the double colon. The compiler will be smart enough to figure out you
    are trying to pass the `String` argument to `System.out::println`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Making a Function a lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lambdas can also implement single abstract methods that accept arguments and
    return an item. For instance, RxJava 2.0 (as well as Java 8) has a `Function<T,R>`
    type that accepts a `T` type and returns an `R` type. For instance, you can declare
    a `Function<String,Integer>`, whose `apply()` method will accept a `String`  and
    return an `Integer`. Here, we implement `apply()` by returning the string''s length
    in an anonymous class, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can make this even more concise by implementing `Function<String,Integer>`
    with a lambda, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We have a couple of syntaxes we can alternatively use to implement `Function<String,Integer>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java 8''s compiler is smart enough to see that our parameter `s` is a `String`
    based on the `Function<String,Integer>` type we are assigning it to. Therefore,
    we do not need to explicitly declare `s` as a `String` because it can infer it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We do not need to wrap our `s` in parentheses `(s)` either, as those are not
    needed for a single argument (but are needed for multiple arguments, as we will
    see later):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are simply calling a method or property on the incoming item, we can
    use the double colon `::` syntax to call the method on that type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`Function<T,R>` is heavily used in RxJava as `Observable` operators often to
    transform emissions. The most common example is the `map()` operator, which turns
    each `T` emission into an `R` emission and derives an `Observable<R>` from an `Observable<T>`.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there are other flavors of `Function`, such as `Predicate` and `BiFunction`,  which
     accept two arguments, not one. The `reduce()` operator accepts a `BiFunction<T,T,T>`
    where the first `T` argument is the rolling aggregation, the second `T` is the
    next item to put into the aggregation, and the third `T` is the result of merging
    the two. In this case, we use `reduce()` to add all the items using a rolling
    total:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Functional types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are all the functional types available in RxJava 2.0 at the time of writing
    this, and you can find them in the `io.reactivex.functions` package. You may recognize
    many of these functional types as being almost identical to those in Java 8 (in `java.util.function`)
    or Google Guava. However, they were somewhat copied in RxJava 2.0 to make them
    available for use in Java 6 and 7\. A subtle difference is that RxJava's implementations
    throw checked exceptions. This eliminates a pain point from RxJava 1.0 where checked
    exceptions had to be handled in lambdas that yielded them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The RxJava 1.0 equivalents are listed as well, but note that the single abstract
    method (SAM) column corresponds to the RxJava 2.0 type. RxJava 1.0 functions implement
    `call()` and do not support primitives. RxJava 2.0 implemented a few functional
    types with primitives to reduce boxing overhead where reasonably possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **RxJava 2.0** | **RxJava 1.0** | **SAM** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Action` | `Action0` | `run()` | Executes an action, much like `Runnable`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Callable<T>` | `Func0<T>` | `get()` | Returns a single item of type `T`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Consumer<T>` | `Action1<T>` | `accept()` | Performs an action on a given
    `T` item but returns nothing |'
  prefs: []
  type: TYPE_TB
- en: '| `Function<T,R>` | `Func1<T,R>` | `apply()` | Accepts a type `T` and returns
    a type `R` |'
  prefs: []
  type: TYPE_TB
- en: '| `Predicate<T>` | `Func1<T,Boolean>` | `test()` | Accepts a `T` item and returns
    a primitive `boolean` |'
  prefs: []
  type: TYPE_TB
- en: '| `BiConsumer<T1,T2>` | `Action2<T1,T2>` | `accept()` | Performs an action
    on a `T1` and `T2` item but returns nothing |'
  prefs: []
  type: TYPE_TB
- en: '| `BiFunction<T1,T2,R>` | `Func2<T1,T2,R>` | `apply()` | Accepts a `T1` and
    `T2` and returns a type `R` |'
  prefs: []
  type: TYPE_TB
- en: '| `BiPredicate<T1,T2>` | `Func2<T1,T2,Boolean>` | `test()` | Accepts a `T1`
    and `T2` and returns a primitive `boolean` |'
  prefs: []
  type: TYPE_TB
- en: '| `Function3<T1,T2,T3,R>` | `Func3<T1,T2,T3,R>` | `apply()` | Accepts three
    arguments and returns an `R` |'
  prefs: []
  type: TYPE_TB
- en: '| `BooleanSupplier` | `Func0<Boolean>` | `getAsBoolean()` | Returns a single
    primitive `boolean` value |'
  prefs: []
  type: TYPE_TB
- en: '| `LongConsumer` | `Action1<Long>` | `accept()` | Performs an action on a given
    `Long` but returns nothing |'
  prefs: []
  type: TYPE_TB
- en: '| `IntFunction` | `Func1<T>` | `apply()` | Accepts a primitive `int` and returns
    an item of type `T` |'
  prefs: []
  type: TYPE_TB
- en: Not every primitive equivalent for a functional type has been implemented in
    RxJava 2.0\. For example, currently, there is no `IntSupplier` like there is in
    Java 8's standard library. This is because RxJava 2.0 does not need it to implement
    any of its operators.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing object-oriented and reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you start applying your RxJava knowledge to real-world problems, something
    that may not immediately be clear is how to mix it with object-oriented programming.
    Leveraging multiple paradigms such as object-oriented and functional programming
    is becoming increasingly common. Reactive programming and object-oriented programming,
    especially in a Java environment, can definitely work together for the greater
    good.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, you can emit any type `T` from an `Observable` or any of the other
    reactive types. Emitting objects built off your own classes is one way object-oriented
    and reactive programming work together. We have seen a number of examples in this
    book. For instance, Java 8''s `LocalDate` is a complex object-oriented type, but
    you can push it through an `Observable<LocalDate>`, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have seen in several examples throughout the book, a number of RxJava
    operators provide adapters to take a stateful, object-oriented item and turn it
    into a reactive stream. For instance, there is the `generate()` factory for `Flowable`
    and `Observable` to build a series of emissions off a mutable object that is updated
    incrementally. In the following code, we emit an infinite, consecutive sequence
    of Java 8 LocalDates but take only the first 60 emissions. Since `LocalDate` is
    immutable, we wrap the seed `LocalDate` of `2017-1-1` in an `AtomicReference`
    so it can be mutably replaced with each increment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So again, RxJava has many factories and tools to adapt your object-oriented,
    imperative operations and make them reactive. Many of them are covered throughout
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: But are there cases for a class to return an `Observable`, `Flowable`, `Single`,
    or `Maybe` from a property or method? Certainly! When your object has properties
    or methods whose results are dynamic and change over time and represent an event(s)
    or a sizable sequence of data, they are candidates to be returned as a reactive
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an abstract example: say, you have a `DroneBot` type that represents
    a flying drone. You could have a property called `getLocation()` that returns
    an `Observable<Point>` instead of `Point`. This way, you can get a live feed that
    pushes a new `Point` emission every time the drone''s location changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This `DroneBot` example shows another way in which you can mix object-oriented
    and reactive programming effectively. You can easily get a live feed of that drone''s
    movements by returning an `Observable`. There are many use cases for this pattern:
    stock feeds, vehicle locations, weather station feeds, social networks, and so
    on. However, be careful if the properties are infinite. If you wanted to manage
    the location feeds of 100 drones, flat mapping all their infinite location feeds
    together into a single stream is likely not going to produce anything meaningful,
    apart from a noisy sequence of locations with no context. You will likely subscribe
    to each one separately, in a UI that populates a `Location` field in a table displaying
    all the drones, or you will use `Observable.combineLatest()` to emit a snapshot
    of the latest locations for all drones. The latter can be helpful in displaying
    points on a geographic map live.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having reactive class properties is useful when they are finite as well. Say
    you have a list of warehouses, and you want to count the total inventory across
    all of them. Each `Warehouse` contains an `Observable<ProductStock>`, which returns
    a finite sequence of the product stocks currently available. The `getQuantity()`
    operator of `ProductStock` returns the quantity of that product available. We
    can use `reduce()` on the `getQuantity()` values to get a sum of all the available
    inventory, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: So, finite Observables like the ones returned from `getProducts()` on `Warehouse`
    can be helpful too and are especially helpful for analytical tasks. But note that
    this particular business case decided that `getProducts()` would return the products
    available at that moment, not an infinite feed that broadcasts the inventory every
    time it changes. This was a design decision, and sometimes, representing snapshot
    data in a cold manner is better than a hot infinite feed. An infinite feed would
    have required `Observable<List<ProductStock>>` (or `Observable<Observable<ProductStock>>`)
    to be returned so logical snapshots are emitted. You can always add a separate
    `Observable` that emits notifications of changes and then uses `flatMap()` on
    your `getProducts()` to create a hot feed of inventory changes. This way, you
    create basic building blocks in your code model and then compose them together
    reactively to accomplish more complex tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you can have methods that return reactive types accept arguments.
    This is a powerful way to create an `Observable` or `Flowable` catered to a specific
    task. For instance, we could add a `getProductsOnDate()` method to our `warehouse`
    that returns an `Observable` emitting product stock from a given date, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In summary, mixing reactive and object-oriented programming is not only beneficial,
    but also necessary. When you design your domain classes, think carefully what
    properties and methods should be made reactive and whether they should be cold,
    hot, and/or infinite. Imagine how you will be using your class and whether your
    candidate design will be easy or difficult to work with. Be sure to not make every
    property and method reactive for the sake of being reactive either. Only make
    it reactive when there is usability or performance benefit. For example, you should
    not make a `getId()` property for your domain type reactive. This ID on that class
    instance is unlikely to change, and it is just a single value, not a sequence
    of values.
  prefs: []
  type: TYPE_NORMAL
- en: Materializing and Dematerializing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two interesting operators we did not cover are `materialize()` and `dematerialize()`.
    We did not cover them in [Chapter 3](de58a40c-f55f-442f-b12e-7c022e08644e.xhtml), *Basic
    Operators*, with all the other operators because it might have been confusing
    at that point in your learning curve. But hopefully, the point at which you are
    reading this, you understand the `onNext()`, `onComplete()`, and `onError()` events
    well enough to use an operator that abstractly packages them in a different way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `materialize()` operator will take these three events, `onNext()`, `onComplete()`,
    and `onError()`, and turn all of them into emissions wrapped in a `Notification<T>`.
    So if your source emits five emissions, you will get six emissions where the last
    one will be `onComplete()` or `onError()`. In the following code, we materialize
    an `Observable` emitting five strings, which are turned into six `Notification`
    emissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Each `Notification` has three methods, `isOnNext()`, `isOnComplete()`, and
    `isOnError()`, to determine what type of event `Notification` is. There is also
    `getValue()`, which will return the emission value for `onNext()` but will be
    null for `onComplete()` or `onError()`. We leverage these methods on `Notification`,
    as shown in the following code, to filter out the three events to three separate
    Observers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `dematerialize()` to turn an `Observable` or `Flowable` emitting
    notifications back into a normal `Observable` or `Flowable`. It will produce an
    error if any emissions are not `Notification`. Unfortunately, at compile time,
    Java cannot enforce operators being applied to Observables/Flowables emitting
    specific types such as Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: So what exactly would you use `materialize()` and `dematerialize()` for? You
    may not use them often, which is another reason why they are covered here in the
    appendix. But they can be handy in composing more complex operators with transformers and
    stretching transformers to do more without creating low-level operators from scratch.
    For instance, RxJava2-Extras uses `materialize()` for a number of its operators,
    including `collectWhile()`. By treating `onComplete()` an emission itself, `collectWhile()`
    can map it to push the collection buffer downstream and start the next buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, you will likely not use it often. But it is good to be aware that
    it exists if you need it to build more complex transformers.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Schedulers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will likely not use schedulers like this in isolation as we are about to
    do in this section. You are more likely to use them with `observeOn()` and `subscribeOn()`.
    But here is how they work in isolation outside of an Rx context.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Scheduler is RxJava''s abstraction for pooling threads and scheduling tasks
    to be executed by them. These tasks may be executed immediately, delayed, or repeated
    periodically depending on which of its execution methods are called. These execution
    methods are `scheduleDirect()` and `schedulePeriodicallyDirect()`, which have
    a few overloads. Below, we use the computation Scheduler to execute an immediate
    task, a delayed task, and a repeated task as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output will likely be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `scheduleDirect()` will only execute a one-time task, and accepts optional
    overloads to specify a time delay. `schedulePeriodicallyDirect()` will repeat
    infinitely. Interestingly, all of these methods return a `Disposable` to allow
    cancellation of the task it is executing or waiting to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'These three methods will automatically pass tasks to a `Worker`, which is an
    abstraction that wraps around a single thread that sequentially does work given
    to it. You can actually call the Scheduler''s `createWorker()` method to explicitly
    get a Worker and delegate tasks to it directly. Its `schedule()` and `schedulePeriodically()`
    methods operate just like Scheduler''s `scheduleDirect()` and `schedulePeriodicallyDirect()`
    respectively (and also return disposables), but they are executed by the specified
    worker. When you are done with a worker, you should dispose it so it can be discarded
    or returned to the `Scheduler`. Here is an equivalent of our earlier example using
    a `Worker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output you may get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Of course, every Scheduler is implemented differently . A Scheduler may use
    one thread or several threads. It may cache and reuse threads, or not reuse them
    at all. It may use an Android thread or a JavaFX thread (as we have seen with
    RxAndroid and RxJavaFX in this book). But that is essentially how schedulers work,
    and you can perhaps see why they are useful in implemeting RxJava operators.
  prefs: []
  type: TYPE_NORMAL
