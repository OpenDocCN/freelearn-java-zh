<html><head></head><body>
		<div id="_idContainer077">
			<h1 id="_idParaDest-191"><em class="italic"><a id="_idTextAnchor202"/>Chapter 11</em><strong class="bold">: MicroProfile GraphQL</strong></h1>
			<p><strong class="bold">GraphQL</strong> is a distributed query language that addresses some of the shortcomings of <strong class="bold">REpresentational State Transfer</strong> (<strong class="bold">REST</strong>). In particular, GraphQL addresses the notions of <strong class="bold">over-fetching</strong> (receiving more data than the client intended) and <strong class="bold">under-fetching</strong> (requiring the client to make multiple requests to get the data it requires). GraphQL applications make use of a schema file that presents clients with the queries and mutations at its disposal, as well as the entities it can access and manipulate.</p>
			<p>The ease of use and robustness of GraphQL explains why its popularity is growing, especially in cloud-native applications. <strong class="bold">MicroProfile GraphQL</strong> (<strong class="bold">MP GraphQL</strong>) makes it easy to create GraphQL-based applications. </p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Understanding GraphQL basics and when to use it</li>
				<li>Building services with MP GraphQL</li>
				<li>Consuming GraphQL services with client <strong class="bold">application programming interfaces</strong> (<strong class="bold">APIs</strong>)</li>
			</ul>
			<p>By the end of this chapter, you will have learned what GraphQL is and when it is appropriate to use it, and you will be able to build your own GraphQL application ready to deploy in open source, cloud-ready servers such as Open Liberty.</p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor203"/>Technical requirements</h1>
			<p>To build and run the samples mentioned in this chapter, you will need a Mac or PC (Windows or Linux) with the following software:</p>
			<ul>
				<li><strong class="bold">Java Development Kit</strong> (<strong class="bold">JDK</strong>) version 8 or higher (<a href="http://ibm.biz/GetSemeru">http://ibm.biz/GetSemeru</a>)</li>
				<li>Apache Maven (<a href="https://maven.apache.org/">https://maven.apache.org/</a>)</li>
				<li>A Git client (<a href="https://git-scm.com/">https://git-scm.com/</a>)</li>
			</ul>
			<p>All of the source code used in this chapter is available on GitHub at <a href="https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter11">https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter11</a>.</p>
			<p>Once you have cloned the GitHub repository, you can start the Open Liberty server where these code samples will execute by entering the <strong class="source-inline">Chapter11</strong> directory and executing the following command from the command line:</p>
			<p class="source-code"> mvn clean package liberty:run</p>
			<p>You can then stop the server in the same command window by pressing <em class="italic">Ctrl + C</em>.</p>
			<p>Now we've got the prerequisites taken care of, let's start by learning the basics of GraphQL.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor204"/>Understanding GraphQL basics and when to use it</h1>
			<p>As with REST, GraphQL is a <a id="_idIndexMarker1111"/>means<a id="_idIndexMarker1112"/> of accessing and modifying remote data over web-based transports. It uses a publicly visible schema, allowing clients to know exactly which entities it can query, which fields can be modified, and so on. This is similar to how OpenAPI describes RESTful APIs. The schema acts as a contract between the client and the service. GraphQL strictly enforces the schema, preventing clients from accessing or modifying entities or fields that are not defined within it. This strictness provides a lot of freedom for developers of both clients and services, which we'll cover later in this section.</p>
			<p>GraphQL supports the following operations:</p>
			<ul>
				<li><strong class="bold">Queries</strong>: Queries are <a id="_idIndexMarker1113"/>read operations and are analogous to <strong class="source-inline">GET</strong> requests in REST.</li>
				<li><strong class="bold">Mutations</strong>: Mutations are used for modifying data—that is, creating, updating, and/or deleting it.</li>
				<li><strong class="bold">Subscriptions</strong>: Subscriptions are used so that clients can receive notifications of specific events, such as when a particular entity has been created or a field has dropped below a certain threshold, or even unrelated events.</li>
			</ul>
			<p>Unlike REST, where different parts of the API are spread out across <a id="_idIndexMarker1114"/>multiple <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) endpoints, GraphQL applications typically use a single HTTP endpoint, and the operations are embedded in the HTTP request's body. </p>
			<p>GraphQL operations and schemas use their <a id="_idIndexMarker1115"/>own syntax, but<a id="_idIndexMarker1116"/> the response is in <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) format. This <a id="_idIndexMarker1117"/>allows GraphQL services and clients to be written in any language. While we plan to cover creating services in Java, it is also currently possible to write service and client applications in JavaScript, Python, Go, Haskell, Perl, Ruby, Scala, and many others.</p>
			<p>The schema defines the types of entities accessible for the service, as well as the operations that can be performed. Built-in or primitive <a id="_idIndexMarker1118"/>GraphQL types are called <strong class="bold">scalars</strong>. Any service is free to define its own scalar types, but the GraphQL specification states that all services must use at least these five standard scalars:</p>
			<ul>
				<li><strong class="source-inline">int</strong>—A 32-bit signed integer</li>
				<li><strong class="source-inline">float</strong>—Signed double-precision floating-point number</li>
				<li><strong class="source-inline">string</strong>—A sequence of <a id="_idIndexMarker1119"/>characters using <strong class="bold">Unicode Transformation Format-8</strong> (<strong class="bold">UTF-8</strong>) encoding</li>
				<li><strong class="source-inline">boolean</strong>—<strong class="source-inline">true</strong> or <strong class="source-inline">false</strong></li>
				<li><strong class="source-inline">ID</strong>—A string that is intended to be a unique <strong class="bold">identifier </strong>(<strong class="bold">ID</strong>) for an entity; it is not intended to be human-readable</li>
			</ul>
			<p>GraphQL objects can be made up of scalars or other objects. Each operation must explicitly specify all fields that it wishes to view in the response. For complex types (types that include other types or scalars), this might mean specifying fields several layers deep.</p>
			<p>Requiring clients to specify all fields in a query ensures backward compatibility when you add new fields to existing objects. A client cannot be caught off guard if a new field appears on an object since their existing query didn't specify it!</p>
			<p>Another advantage of requiring clients to specify all fields that they are interested in is that it avoids <strong class="bold">over-fetching</strong>. Over-fetching <a id="_idIndexMarker1120"/>occurs when more data is sent over the network than is necessary. One common example of over-fetching in REST is weather data. If you issue a RESTful request to check the current conditions for a particular location from various weather sites, you will see an enormous amount of information, but most of that data is unused when you just wanted to know what the outside temperature is and whether or not it's raining.</p>
			<p>By sending queries as the payload of an HTTP request, GraphQL also avoids<a id="_idIndexMarker1121"/> <strong class="bold">under-fetching</strong>. As you've probably guessed, under-fetching occurs when the data returned is insufficient. Using the weather example, suppose you also wanted to know the temperature at your friends' homes in other cities. You'd have to issue similar RESTful requests to the weather site for each location. But in GraphQL, you can issue multiple queries in <a id="_idIndexMarker1122"/>a single HTTP request, enabling you to get exactly the data you <a id="_idIndexMarker1123"/>need with a single round trip to the server and making it fast and efficient!</p>
			<p>Queries and mutations have their own syntax, though it is similar to JSON and other query languages. Generally, these operations start with <strong class="source-inline">query</strong> or <strong class="source-inline">mutation</strong> and then a label for the operation, then, inside curly braces, you would specify the query or mutation to invoke with any parameters inside parentheses. You would then add the fields you are interested in inside curly braces. We'll see some example queries and mutations later in this chapter.</p>
			<p>GraphQL also allows <strong class="bold">partial results</strong> to be <a id="_idIndexMarker1124"/>sent when an exception occurs. Suppose the weather data for precipitation is unavailable due to some unforeseen system failure. A GraphQL service could still send temperature data to the clients, along with some error data for the missing precipitation fields, whereas a RESTful service would likely return a <strong class="source-inline">503</strong> (service unavailable) error. Some data is still better than none, right?</p>
			<p>Since the schema is exposed to clients, various tools can introspect the schema, allowing users to construct queries and mutations and test them in real time. One such tool, which we'll <a id="_idIndexMarker1125"/>discuss later, is called <strong class="bold">GraphiQL</strong> (<a href="https://github.com/graphql/graphiql">https://github.com/graphql/graphiql</a>). </p>
			<p>While REST is still the more widely used communication architecture in the cloud, GraphQL is quickly gaining in popularity as it addresses many of the gaps in REST. So, which approach is right for you? The answer, as with most things, is <em class="italic">it depends</em>. GraphQL primarily only works with JSON as the response type; if you want to use other data types, you might want to consider REST or an alternative approach. If your data is hierarchical in nature, it might lend itself better to REST.</p>
			<p>Another consideration is <a id="_idIndexMarker1126"/>security-based in relation to <strong class="bold">Uniform Resource Indicator</strong> (<strong class="bold">URI</strong>) paths: GraphQL uses a single URI for all operations, while REST uses different paths for different entities. With REST, it would be possible to use a firewall to grant access to certain entities for all clients (for example, <strong class="source-inline">/public/*</strong>) while restricting access to other entities (for example, <strong class="source-inline">/private/*</strong>). This isn't possible in GraphQL without splitting the service into separate public and private services, which might not be ideal.</p>
			<p>Similarly, HTTP caching is more complicated with GraphQL. Since REST uses URI paths, both clients and servers can cache entity results based on the path used. It is possible to<a id="_idIndexMarker1127"/> cache based on paths in GraphQL, but this would require <a id="_idIndexMarker1128"/>clients to pass their queries as HTTP <strong class="source-inline">GET</strong> query parameters. This could be cumbersome for the client, as well as being a potential security risk as proxy servers would be able to see query parameters, and you may still have issues with caching, depending on the spacing and formatting of the query. Fortunately, most implementations of GraphQL use query caching on the server side to reduce unnecessary duplication of work.</p>
			<p>So, when would you use GraphQL? GraphQL tends to cost a little more on the server (in order to filter results to get the client exactly what it wants), but that trade-off means that client-side processing is significantly reduced. So, if you have a lot of clients or want to optimize your client performance, GraphQL is a good approach.</p>
			<p>GraphQL tends to reduce network traffic since it avoids under-fetching and over-fetching. In environments where network bandwidth is expensive, GraphQL is ideal.</p>
			<p>It should also be noted that nothing prevents you from writing both GraphQL and RESTful APIs for the same service. This might add more maintenance, but it allows your clients to choose. </p>
			<p>Now we understand what GraphQL is and when we should use it, let's explore how we can build GraphQL applications using MicroProfile. </p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor205"/>Building services with MP GraphQL</h1>
			<p>In this section, we <a id="_idIndexMarker1129"/>will learn how to develop a <a id="_idIndexMarker1130"/>GraphQL application using the MP GraphQL APIs and runtime framework. We'll cover building queries and mutations, and how to invoke them using an interactive web tool called <strong class="bold">GraphiQL</strong>. We'll also cover entities and enumerated types. Finally, we'll cover a technique to reduce unnecessary server-side computations and deliver partial results. </p>
			<p>Most GraphQL APIs for <a id="_idIndexMarker1131"/>Java require you to write a <a id="_idIndexMarker1132"/>schema first and then build the Java code around it. This approach tends to cause some level of dual maintenance, and it can slow down development as you evolve your application. MP GraphQL uses a <strong class="bold">code-first</strong> approach, meaning that you write the code using patterns <a id="_idIndexMarker1133"/>similar to <strong class="bold">Jakarta RESTful Web Services</strong> (<strong class="bold">JAX-RS</strong>), and the framework generates the schema at runtime. This makes development and maintenance faster and easier. Let's start by building a basic <strong class="source-inline">Hello World</strong> query service.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor206"/>Developing queries</h2>
			<p>As with JAX-RS, MP GraphQL is <a id="_idIndexMarker1134"/>based on annotations. The <a id="_idIndexMarker1135"/>first annotation to consider is <strong class="source-inline">@GraphQLApi</strong>. This <a id="_idIndexMarker1136"/>annotation is a <strong class="bold">Contexts and Dependency Injection</strong> (<strong class="bold">CDI</strong>) bean-defining annotation, which means that when you apply this annotation to a class, it becomes a CDI bean. This enables the CDI framework to manage its life cycle and inject dependencies. This annotation is required on classes that contain query or mutation methods.</p>
			<p>The next annotation we'll consider is <strong class="source-inline">@Query</strong>. When this annotation is applied to methods, it tells the MP GraphQL runtime to create a top-level query in the schema. Let's see a simple example, as follows:</p>
			<p class="source-code">@GraphQLApi</p>
			<p class="source-code">public class SimpleApi {</p>
			<p class="source-code">    @Query</p>
			<p class="source-code">    public String hello() {</p>
			<p class="source-code">        return "Hello World";</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">@GraphQLApi</strong> annotation tells the runtime to manage the life cycle of this bean, and the <strong class="source-inline">@Query</strong> annotation tells the runtime to generate a query in the schema with no parameters that returns a <strong class="source-inline">String</strong> scalar. If we run this example in an MP GraphQL server such as Open Liberty, we can then see the schema file by browsing to <strong class="source-inline">http://localhost:9080/ch11/graphql/schema.graphql</strong>. Then, we'll see something like this:</p>
			<p class="source-code">"Query root"</p>
			<p class="source-code">type Query {</p>
			<p class="source-code">  hello: String</p>
			<p class="source-code">}</p>
			<p>Using <strong class="bold">GraphiQL</strong>, which <a id="_idIndexMarker1137"/>comes built in to Open Liberty, we can <a id="_idIndexMarker1138"/>execute this query from a web-based client. Simply browse to <strong class="source-inline">http://localhost:9080/ch11/graphql-ui</strong> and then enter this query string:</p>
			<p class="source-code">query hello {</p>
			<p class="source-code">  hello</p>
			<p class="source-code">}</p>
			<p>Then, click the triangular <em class="italic">play</em> button to see the results. You should see something like this: </p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/B17377_11_01.jpg" alt="Figure 11.1 – Simple query in GraphiQL&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – Simple query in GraphiQL</p>
			<p>Notice that the result is a JSON object with a field labeled <strong class="source-inline">data</strong>. The results of the query are always under the <strong class="source-inline">data</strong> field. If an error were to occur, there would be a separate <strong class="source-inline">errors</strong> field instead of, or in addition to, the <strong class="source-inline">data</strong> field. This field would include details of the error(s).</p>
			<p>This is a nice start, and you can probably guess that you could have multiple query methods in this class that could return different data, but queries are much more powerful when they have parameters. In previous chapters, we've been working with the <strong class="bold">Stock Trader</strong> application. Let's GraphQL-ize that application in our following examples.</p>
			<p>If we want the client <a id="_idIndexMarker1139"/>to be able to specify parameters <a id="_idIndexMarker1140"/>to a query, we simply add Java method parameters to the <strong class="source-inline">@Query</strong>-annotated methods. Let's take a look at what we might do for the <strong class="source-inline">Portfolio</strong> service, as follows:</p>
			<p class="source-code"><strong class="bold">@GraphQLApi</strong></p>
			<p class="source-code">public class PortfolioGraphQLApi {</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    private PortfolioDatabase portfolioDB;</p>
			<p class="source-code">    <strong class="bold">@Query</strong></p>
			<p class="source-code">    @Description("Returns the portfolio of the given       owner.")</p>
			<p class="source-code">    public <strong class="bold">Portfolio</strong> portfolio(<strong class="bold">@Name</strong>("owner") String owner)</p>
			<p class="source-code">        throws UnknownPortfolioException {</p>
			<p class="source-code">        return Optional.ofNullable(portfolioDB.getPortfolio           (owner)).orElseThrow(() -&gt; new                UnknownPortfolioException(owner));</p>
			<p class="source-code">    }</p>
			<p class="source-code">    //...</p>
			<p class="source-code">}</p>
			<p>There are a few new things to consider here. First, we inject <strong class="source-inline">PortfolioDatabase </strong>instance. This is nothing more than a wrapper around a <strong class="source-inline">HashMap</strong>, but it could just as well access a real relational or NoSQL database to retrieve stock portfolio data. CDI injects this for us. <em class="italic">Muchas gracias!</em></p>
			<p>Next, the <strong class="source-inline">portfolio</strong> query method also has a <strong class="source-inline">@Description</strong> annotation applied to it. This allows us to specify a human-readable description that will appear in the generated schema, which is useful for describing the intent of the query and its parameters.</p>
			<p>Speaking of parameters, the <a id="_idIndexMarker1141"/>method takes a <strong class="source-inline">String</strong> parameter <a id="_idIndexMarker1142"/>called <strong class="source-inline">owner</strong>. The <strong class="source-inline">@Name</strong> annotation tells the runtime which name to use when generating the schema.</p>
			<p class="callout-heading">Best practice</p>
			<p class="callout">Use <strong class="source-inline">@Name</strong> annotations on parameters for portability. Some MP GraphQL implementations may not be able to determine the parameter name from the code and will end up writing the schema with parameter names such as <strong class="source-inline">arg0</strong>, <strong class="source-inline">arg1</strong>, and so on. The <strong class="source-inline">@Name</strong> annotation guarantees that the runtime will generate the specified parameter name in the schema.</p>
			<p>Another thing worth noting in the aforementioned code is that instead of returning a <strong class="source-inline">string</strong> or other primitive, we are returning a <strong class="source-inline">Portfolio</strong> object. This is a custom object in our application. By doing so, the runtime will introspect the <strong class="source-inline">Portfolio</strong> Java object and will generate it as an entity in the schema. It will also generate any other object that it references. Let's take a look at the schema generated from this code, as follows:</p>
			<p class="source-code">type Portfolio {</p>
			<p class="source-code">  accountID: ID</p>
			<p class="source-code">  loyalty: Loyalty</p>
			<p class="source-code">  owner: String</p>
			<p class="source-code">  stocks: [Stock]</p>
			<p class="source-code">  total: Float!</p>
			<p class="source-code">}</p>
			<p class="source-code">"Query root"</p>
			<p class="source-code">type Query {</p>
			<p class="source-code">  "Returns the portfolio of the given owner."</p>
			<p class="source-code">  portfolio(owner: String): Portfolio</p>
			<p class="source-code">}</p>
			<p class="source-code">type Stock {</p>
			<p class="source-code">type Stock {</p>
			<p class="source-code">  commission: Float!</p>
			<p class="source-code">  dateOfLastUpdate: String</p>
			<p class="source-code">  pricePerShare: Float!</p>
			<p class="source-code">  shares: Int!</p>
			<p class="source-code">  symbol: String!</p>
			<p class="source-code">  total: Float!</p>
			<p class="source-code">}</p>
			<p class="source-code">}</p>
			<p class="source-code">enum Loyalty {</p>
			<p class="source-code">  BRONZE</p>
			<p class="source-code">  GOLD</p>
			<p class="source-code">  SILVER</p>
			<p class="source-code">}</p>
			<p>First, we see the <strong class="source-inline">Portfolio</strong> type (entity) and its various fields and their types. So, the <strong class="source-inline">accountID</strong> field is a <strong class="source-inline">string</strong>; the <strong class="source-inline">total</strong> field is a <strong class="source-inline">float</strong>, with the exclamation mark indicating that the <a id="_idIndexMarker1143"/>value for this field must be <a id="_idIndexMarker1144"/>non-null; the <strong class="source-inline">stocks</strong> field is an array of <strong class="source-inline">Stock</strong> objects, with the square brackets indicating an <strong class="bold">array</strong>.</p>
			<p>We also see the text description for our query. The query section indicates that the <strong class="source-inline">portfolio</strong> query takes a single <strong class="source-inline">String</strong> parameter called <strong class="source-inline">owner</strong> and returns a <strong class="source-inline">Portfolio</strong> object.</p>
			<p>The <strong class="source-inline">Stock</strong> type is<a id="_idIndexMarker1145"/> pulled in because it is referenced by the <strong class="source-inline">Portfolio</strong> type. Likewise, the <strong class="source-inline">Loyalty</strong> <strong class="bold">enumerated type</strong> (<strong class="bold">enum</strong>) is referenced by the <strong class="source-inline">Portfolio</strong> type. Enums in GraphQL are generated from Java <strong class="source-inline">enums</strong> and behave similarly.</p>
			<p>Let's take one last look at the code that generated this schema, and we'll see that the <strong class="source-inline">portfolio</strong> method throws an <strong class="source-inline">UnknownPortfolioException</strong> exception. This exception is handled by the framework. When the exception is thrown, the framework will return an error <a id="_idIndexMarker1146"/>response to the client. Let's see what <a id="_idIndexMarker1147"/>happens when we query for two portfolios—one that exists and one that doesn't, as follows:</p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/B17377_11_02.jpg" alt="Figure 11.2 – Multiple queries: one successful, one failing with an expected exception&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – Multiple queries: one successful, one failing with an expected exception</p>
			<p><em class="italic">Figure 11.2</em> shows us <a id="_idIndexMarker1148"/>that we can send multiple queries in the same request. It also shows us that we can <a id="_idIndexMarker1149"/>receive partial results. In this case, the query to find portfolio details for <strong class="source-inline">Emily J</strong> was successful, but the query to find portfolio details for <strong class="source-inline">Andy M</strong> failed because his portfolio is not yet in the database.</p>
			<p>Now we have a basic understanding of how to create query methods, let's take a look at how we can create mutations.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor207"/>Developing mutations</h2>
			<p>When we <a id="_idIndexMarker1150"/>think of <strong class="bold">create, read, update, and delete</strong> (<strong class="bold">CRUD</strong>) operations, queries are the <em class="italic">read</em> part, while <a id="_idIndexMarker1151"/>mutations are everything else. That said, queries and mutations are <a id="_idIndexMarker1152"/>just labels—a GraphQL query could certainly create, update, or delete entities, and a mutation could simply return a view of an entity, but that is not the intended practice.</p>
			<p class="callout-heading">Best practice</p>
			<p class="callout">Query methods should never manipulate entity data. Use queries for returning the current state of entities and mutations for changing that data.</p>
			<p>To create a mutation method, you would just apply the <strong class="source-inline">@Mutation</strong> annotation to your Java method. In most cases, mutation methods will take parameters to indicate what sort of change to make and/or to specify which entities to update or delete. Let's take a look at how we might use a mutation method to create a <strong class="source-inline">Portfolio</strong> object, as follows:</p>
			<p class="source-code">@GraphQLApi</p>
			<p class="source-code">public class PortfolioGraphQLApi {</p>
			<p class="source-code">    //...</p>
			<p class="source-code">    @Mutation</p>
			<p class="source-code">    public Portfolio createNewPortfolio(@Name("portfolio") </p>
			<p class="source-code">      Portfolio portfolio)</p>
			<p class="source-code">        throws DuplicatePortfolioOwnerException,             UnknownPortfolioException {</p>
			<p class="source-code">        portfolioDB.addPortfolio(portfolio);</p>
			<p class="source-code">        return portfolio(portfolio.getOwner());</p>
			<p class="source-code">    }</p>
			<p>There are a few <a id="_idIndexMarker1153"/>things to notice here. First, the <strong class="source-inline">createNewPortfolio</strong> method returns the <strong class="source-inline">Portfolio</strong> object it just created—it actually calls the <strong class="source-inline">portfolio</strong> method we wrote in the last section to ensure that the new <strong class="source-inline">Portfolio</strong> object <a id="_idIndexMarker1154"/>was created successfully in the database. Mutations, as with queries, must always return something. Void mutation or query methods are not allowed.</p>
			<p class="callout-heading">Suggestion</p>
			<p class="callout">If you really don't want to return anything, consider returning a <strong class="source-inline">boolean</strong> value to indicate whether the mutation was completed successfully, or consider returning an <strong class="source-inline">int</strong> value, indicating how many entities were created/updated/deleted.</p>
			<p>The second thing to notice about this code is that it accepts a complex object as a parameter. This will cause some new entries to be generated in the schema. Let's take a look, as follows:</p>
			<p class="source-code">input PortfolioInput {</p>
			<p class="source-code">  accountID: ID</p>
			<p class="source-code">  loyalty: Loyalty</p>
			<p class="source-code">  owner: String</p>
			<p class="source-code">  stocks: [StockInput]</p>
			<p class="source-code">  total: Float!</p>
			<p class="source-code">}</p>
			<p class="source-code">input StockInput {</p>
			<p class="source-code">  commission: Float!</p>
			<p class="source-code">  shares: Int!</p>
			<p class="source-code">  symbol: String</p>
			<p class="source-code">}</p>
			<p>These input types <a id="_idIndexMarker1155"/>look very similar to the types we saw when we generated the schema for our query method. The difference is that these <a id="_idIndexMarker1156"/>types are appended with <strong class="source-inline">input</strong>. GraphQL differentiates between types used for input and types used for output. One advantage of this is that it means it might be possible for clients to view things that they cannot modify or vice versa. So, what might the mutation look like in <strong class="bold">GraphiQL</strong>? Let's take a look, as follows:</p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/B17377_11_03.jpg" alt="Figure 11.3 – Mutation creating a new portfolio&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3 – Mutation creating a new portfolio</p>
			<p><em class="italic">Figure 11.3</em> shows how to specify a complex parameter, <strong class="source-inline">portfolio</strong>. The syntax is very similar to JSON, but not exactly—notice that the field names are not in quotes. Notice also that the mutation specifies a return value, <strong class="source-inline">owner</strong>—a valid query or mutation must contain at least one return value.</p>
			<p class="callout-heading">A note about parameters and pagination</p>
			<p class="callout">Parameters in a query or mutation do not need to be related to the underlying business entity. You could also <a id="_idIndexMarker1157"/>use parameters for <strong class="bold">pagination</strong>, allowing a client to control the number and range of the entries it wants to receive. For example, suppose a client wants to iterate over all the stock portfolios in the database, but it has a limited capacity for processing. In this case, it might be advantageous to add parameters for <strong class="source-inline">pageNumber</strong> and <strong class="source-inline">entriesPerPage</strong> so that the client can process the portfolios at its own pace.</p>
			<p>Now we've <a id="_idIndexMarker1158"/>covered queries and mutations, let's take a <a id="_idIndexMarker1159"/>closer look at entities and how we can shape them into what we want in the GraphQL world!</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor208"/>Writing entities</h2>
			<p>Entities are <a id="_idIndexMarker1160"/>all complex types (not <strong class="bold">scalars</strong>) used for input or output. The <a id="_idIndexMarker1161"/>MP GraphQL runtime will compute all entities that are referenced by root-level queries and mutations, and it will automatically add them to the schema. It will differentiate between entities that are used as parameters (input) and entities used as return values (output). And, as we discovered in the last section, the framework will also add entities referenced by other entities that may not necessarily be directly referenced by root-level queries and mutations. This includes classes, enums, and <strong class="bold">interfaces</strong>.</p>
			<h3>Using GraphQL interfaces</h3>
			<p>We've already <a id="_idIndexMarker1162"/>covered basic classes and enums as entities, so let's <a id="_idIndexMarker1163"/>now take a look at interfaces. Just as with interfaces in Java, GraphQL interfaces can be implemented by concrete GraphQL types. One difference is that input types cannot implement interfaces, which can make things tricky. Let's take a look at an example to get a better understanding. Suppose we want to have a portfolio owner <em class="italic">profile</em> that contains the contact information of the account owner. Since some portfolio accounts might be managed by somebody other than the owner, we might want two different types of profiles—one for single-person owners and one for accounts with a designated manager. To meet this requirement, we might code up something like this:</p>
			<p class="source-code">@Interface</p>
			<p class="source-code">public interface OwnerProfile {</p>
			<p class="source-code">    String getOwnerId();</p>
			<p class="source-code">    String getEmailAddress();</p>
			<p class="source-code">    void setEmailAddress(String emailAddress);</p>
			<p class="source-code">}</p>
			<p class="source-code">public class OwnerProfileImpl implements OwnerProfile {</p>
			<p class="source-code">    private String ownerId;</p>
			<p class="source-code">    private String emailAddress;</p>
			<p class="source-code">    // ... public getters / setters</p>
			<p class="source-code">}</p>
			<p class="source-code">public class ManagedOwnerProfileImpl extends </p>
			<p class="source-code">  OwnerProfileImpl implements OwnerProfile {</p>
			<p class="source-code">    private String managerName;</p>
			<p class="source-code">    private String managerEmailAddress;</p>
			<p class="source-code">    // ... public getters / setters</p>
			<p class="source-code">}</p>
			<p>In the preceding <a id="_idIndexMarker1164"/>code snippet, we see the <strong class="source-inline">@Interface</strong> annotation applied to the <strong class="source-inline">OwnerProfile</strong> interface. This <a id="_idIndexMarker1165"/>tells the MP GraphQL framework to treat this interface as a GraphQL interface in the schema. The framework will then search for implementations of this interface and add them to the schema as well. </p>
			<p>Next, let's take a look at what the API class might look like, as follows:</p>
			<p class="source-code">@GraphQLApi</p>
			<p class="source-code">public class ProfileGraphQLApi {</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    OwnerProfileDatabase db;</p>
			<p class="source-code">    @Query</p>
			<p class="source-code">    public OwnerProfile profile(String ownerId) {</p>
			<p class="source-code">        return db.getProfile(ownerId);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Mutation</p>
			<p class="source-code">    public boolean addProfile(OwnerProfileImpl profile)           throws DuplicatePortfolioOwnerException {</p>
			<p class="source-code">        db.addProfile(profile);</p>
			<p class="source-code">        return true;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Mutation</p>
			<p class="source-code">    public boolean addManagedProfile</p>
			<p class="source-code">      (ManagedOwnerProfileImpl profile)           throws DuplicatePortfolioOwnerException {</p>
			<p class="source-code">        db.addProfile(profile);</p>
			<p class="source-code">        return true;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Notice that the API class has separate mutation methods for creating each type of profile. This is an unfortunate side effect of GraphQL not allowing input types to implement interfaces—even though the Java code implements the interface, the GraphQL code does not. This <a id="_idIndexMarker1166"/>means that the <a id="_idIndexMarker1167"/>parameters must not be interfaces. On the other hand, output types don't have this limitation, so we can use a single-query method that will handle both profile types. The combination of this API class and the entity interface and classes will generate a schema that looks like this (abbreviated):</p>
			<p class="source-code">interface OwnerProfile {</p>
			<p class="source-code">  emailAddress: String</p>
			<p class="source-code">  ownerId: String</p>
			<p class="source-code">}</p>
			<p class="source-code">type ManagedOwnerProfileImpl implements OwnerProfile {</p>
			<p class="source-code">  emailAddress: String</p>
			<p class="source-code">  managerEmailAddress: String</p>
			<p class="source-code">  managerName: String</p>
			<p class="source-code">  ownerId: String</p>
			<p class="source-code">}</p>
			<p class="source-code">type OwnerProfileImpl implements OwnerProfile {</p>
			<p class="source-code">  emailAddress: String</p>
			<p class="source-code">  ownerId: String</p>
			<p class="source-code">}</p>
			<p class="source-code">input ManagedOwnerProfileImplInput {</p>
			<p class="source-code">  emailAddress: String</p>
			<p class="source-code">  managerEmailAddress: String</p>
			<p class="source-code">  managerName: String</p>
			<p class="source-code">  ownerId: String</p>
			<p class="source-code">}</p>
			<p class="source-code">input OwnerProfileImplInput {</p>
			<p class="source-code">  emailAddress: String</p>
			<p class="source-code">  ownerId: String</p>
			<p class="source-code">}</p>
			<p>As we'd expect, the <strong class="source-inline">ManagedOwnerProfileImpl</strong> type implements the <strong class="source-inline">OwnerProfile</strong> interface. It <a id="_idIndexMarker1168"/>has the same fields <a id="_idIndexMarker1169"/>as the interface, and it also has a couple of extra fields. So, how do we access these extra fields in a query? The magic happens on <em class="italic">lines 6</em> and <em class="italic">14</em> of the query, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/B17377_11_04.jpg" alt="Figure 11.4 – Query using interfaces&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.4 – Query using interfaces</p>
			<p>As seen in <em class="italic">Figure 11.4</em>, the <strong class="source-inline">… on ManagedOwnerProfileImpl</strong> code is similar to casting the interface to the implementation class and then invoking getter methods that only exist on the implementation class in Java. Notice in the output that the profile type returned for <strong class="source-inline">Emily J</strong> is not a <strong class="source-inline">ManagedOwnerProfileImpl</strong> type, so it does not contain the additional fields.</p>
			<p>Just as with Java, interfaces <a id="_idIndexMarker1170"/>can be quite useful <a id="_idIndexMarker1171"/>for organizing and reusing entities. Now, let's look at how we can further refine entities.</p>
			<h3>Using entity annotations</h3>
			<p>It's not uncommon to <a id="_idIndexMarker1172"/>have an entity class that <a id="_idIndexMarker1173"/>you want to expose as part of the GraphQL schema, but maybe rename a field (or exclude one) or make a field read-only, or make some other modification. This is possible using annotations on entity fields and/or getter/setter methods. Since MP GraphQL integrates with <strong class="bold">JSON Binding</strong> (<strong class="bold">JSON-B</strong>), many of <a id="_idIndexMarker1174"/>the MP GraphQL-specific annotations can be replaced by JSON-B annotations to avoid annotation overload.</p>
			<p>We've already seen the <strong class="source-inline">@Name</strong> annotation used on parameters in query/mutation methods, but we can also use this annotation on entity fields and getters/setters to <em class="italic">rename</em> the field in the generated GraphQL schema. As with all of the annotations described in this section, if you put the annotation on the getter method it will only apply to the output type. If you put the annotation on the setter method, it will only apply to the input type. If you put it on the field, it will apply to both. </p>
			<p>The following table lists the annotations that can be quite useful when adding entities to your GraphQL applications: </p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/Table_11.1.jpg" alt="Table 11.1 – MP GraphQL entity annotations and their JSON-B equivalents&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 11.1 – MP GraphQL entity annotations and their JSON-B equivalents</p>
			<p>Applying these annotations <a id="_idIndexMarker1175"/>to your entity types allows <a id="_idIndexMarker1176"/>you to better control the external view of your model classes and better reuse existing classes.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor209"/>Outsourcing</h2>
			<p>Suppose you have an <a id="_idIndexMarker1177"/>entity with a field that is expensive to compute—maybe it requires intensive mathematical computation, or perhaps it requires querying a remote database, and so on. It seems wasteful to compute that field when the client isn't interested in it. Fortunately, it's possible to avoid expensive computation by <strong class="bold">outsourcing</strong> the <a id="_idIndexMarker1178"/>field from the entity class and using the <strong class="source-inline">@Source</strong> annotation.</p>
			<p>For example, let's suppose that the profile service wants to be able to check the loyalty level of a given portfolio owner, but that information is in the portfolio database, not the profile database. So, in this example, a client wanting to see profile data would end up asking the server to connect to two different databases to get the results. We can optimize this situation by only checking the portfolio database if the client requests the loyalty field. We do this by putting a <strong class="source-inline">getLoyalty(@Source OwnerProfileImpl profile)</strong> method in the <strong class="source-inline">ProfileGraphQLApi</strong> class, like so:</p>
			<p class="source-code">@GraphQLApi</p>
			<p class="source-code">public class ProfileGraphQLApi {</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    PortfolioDatabase portfolioDB;</p>
			<p class="source-code">    public Loyalty getLoyalty(@Source OwnerProfileImpl       profile) throws UnknownPortfolioException {</p>
			<p class="source-code">        String ownerId = profile.getOwnerId();</p>
			<p class="source-code">        Portfolio p = portfolioDB.getPortfolio(ownerId);</p>
			<p class="source-code">        return p.getLoyalty();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // ... </p>
			<p class="source-code">}</p>
			<p>What this does is <em class="italic">adds</em> a new field, <strong class="source-inline">loyalty</strong>, to the <strong class="source-inline">OwnerProfileImpl</strong> entity in the schema. From the client's view, this new field is just like any other field, but the <strong class="source-inline">getLoyalty</strong> method is only invoked if the client specifically requests that field. This is a useful way to avoid paying for expensive operations when the client has no use for the resulting data.</p>
			<p class="callout-heading">Best practice</p>
			<p class="callout">Use the <strong class="source-inline">@Source</strong> annotation for expensive data fetching in order to optimize server-side performance. This also enables you to reduce memory consumption on the server for large queries.</p>
			<p>If the <strong class="source-inline">@Source</strong> method <a id="_idIndexMarker1179"/>throws an exception, the MP GraphQL framework will return a <a id="_idIndexMarker1180"/>null result for that field and will send error data but will continue to send the data from other fields as partial results.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor210"/>Sending partial results using GraphQLException</h2>
			<p>We've now <a id="_idIndexMarker1181"/>seen two <a id="_idIndexMarker1182"/>ways that we can send <strong class="bold">partial results</strong> with <a id="_idIndexMarker1183"/>error data—firstly when the client sends multiple queries in the same request and one or more goes bad, and secondly, when using the <strong class="source-inline">@Source</strong> annotation to outsource a field's data fetcher.</p>
			<p>A third way to send partial results is by using a <strong class="source-inline">GraphQLException</strong> exception. This exception allows you to include partial results before throwing the exception back to the MP GraphQL framework. The framework will then attempt to send the partial results with the error data back to the client. Here is an example of this:</p>
			<p class="source-code">@Mutation</p>
			<p class="source-code">public Collection&lt;Portfolio&gt; createNewPortfolios(</p>
			<p class="source-code">        @Name("portfolios") List&lt;Portfolio&gt; newPortfolios)</p>
			<p class="source-code">        throws GraphQLException, UnknownPortfolioException {</p>
			<p class="source-code">    Tuple&lt;Collection&lt;Portfolio&gt;, Collection&lt;String&gt;&gt;      tuple = portfolioDB.addPortfolios(newPortfolios);</p>
			<p class="source-code">    if (!tuple.second.isEmpty()) {</p>
			<p class="source-code">       // some of the portfolios to be added already exist;</p>
			<p class="source-code">        // throw an exception with partial results</p>
			<p class="source-code">        throw new GraphQLException(</p>
			<p class="source-code">            "The following portfolios already exist and "             + "cannot be re-added: " + tuple.second,              tuple.first); // here are the partial results</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return tuple.first;</p>
			<p class="source-code">}</p>
			<p>This mutation allows clients <a id="_idIndexMarker1184"/>to create multiple <a id="_idIndexMarker1185"/>new <a id="_idIndexMarker1186"/>portfolios in one request. If the client attempts to create a portfolio for an owner that already exists, this will cause an exception, but all of the other portfolios will still be created and their results will be sent back to the client, along with a list of portfolios that could not be created in the error data.</p>
			<p>In this section, we've learned how to construct a server-side GraphQL application in Java using MP GraphQL. While not specifically covered in this section, it should be noted that MP GraphQL integrates nicely with other MicroProfile features, such as Fault Tolerance and Metrics. The MP GraphQL 1.0 specification is officially released and supported in open source Java servers such as Open Liberty, Quarkus, and WildFly. Future versions of the specification will add new features such as support for subscriptions, the ability to define custom scalars, union types, built-in pagination support, and client APIs.</p>
			<p>In this section, we learned how to write simple and advanced GraphQL services using MicroProfile APIs. So far, we've only invoked these services using the <strong class="bold">GraphiQL</strong> tool. In the next section, we'll <a id="_idIndexMarker1187"/>learn how we can invoke these services using Java APIs.</p>
			<h1 id="_idParaDest-200"><a id="_idTextAnchor211"/>Consuming GraphQL services with client APIs</h1>
			<p>The <a id="_idIndexMarker1188"/>client APIs are not officially part of the MP GraphQL specification yet. At the time of writing, these APIs are still under development <a id="_idIndexMarker1189"/>in the <strong class="bold">SmallRye GraphQL</strong> project, with the intention of formalizing them into the specification. </p>
			<p class="callout-heading">Disclaimer</p>
			<p class="callout">Since these APIs are not official yet, they are subject to change. The information in this section pertains to the SmallRye GraphQL version 1.2.3 client APIs. These APIs may change when added to the official MP GraphQL specification, so please check with the official documentation at <a href="https://github.com/eclipse/microprofile-graphql">https://github.com/eclipse/microprofile-graphql</a> for any changes.</p>
			<p>The MP GraphQL project intends to support two flavors of client APIs. Similar to the JAX-RS client and the MicroProfile REST client (see <a href="B17377_04_Final_SB_epub.xhtml#_idTextAnchor068"><em class="italic">Chapter 4</em></a>, <em class="italic">Developing Cloud-Native Applications</em>), there is a <strong class="bold">dynamic client</strong> API and a <strong class="bold">type-safe client</strong> API. As with the JAX-RS client, the dynamic client allows users to specify the nitty-gritty details of the request, while the type-safe client allows users to construct an interface to model the remote service and simply invokes it when it wants to make a new request.</p>
			<p>Both of these client APIs are demonstrated as integration tests in the GitHub repository at <a href="https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter11/src/test/java/com/packt/microprofile/ch11/client">https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter11/src/test/java/com/packt/microprofile/ch11/client</a>. They test an <strong class="source-inline">allProfiles</strong> query that returns all of the profiles known to the server. In our example, we've created two profiles for testing purposes. Let's take a look at the dynamic client first.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor212"/>Dynamic client</h2>
			<p>The <a id="_idIndexMarker1190"/>dynamic client works <a id="_idIndexMarker1191"/>by building a <strong class="source-inline">DynamicGraphQLClient</strong> instance and then passing it as either a <strong class="source-inline">Request</strong> or a <strong class="source-inline">Document</strong> object. The <strong class="source-inline">Request</strong> object usually contains a plain text string with the query or mutation you wish to execute, while a <strong class="source-inline">Document</strong> object must be constructed programmatically. Let's take a <a id="_idIndexMarker1192"/>look at <a id="_idIndexMarker1193"/>the <strong class="source-inline">Request</strong> approach first, as follows:</p>
			<p class="source-code">@Test</p>
			<p class="source-code">public void testAllProfilesWithStringDocument()</p>
			<p class="source-code">  throws Exception {</p>
			<p class="source-code">    verify(() -&gt; executeSync(</p>
			<p class="source-code">        new RequestImpl("query allProfiles {"</p>
			<p class="source-code">                       +"  allProfiles {"</p>
			<p class="source-code">                       +"     ownerId, emailAddress"</p>
			<p class="source-code">                       +"  }"</p>
			<p class="source-code">                       +"}")));</p>
			<p class="source-code">}</p>
			<p class="source-code">private Response executeSync(Request req) {</p>
			<p class="source-code">    try (DynamicGraphQLClient client = newClient()) {</p>
			<p class="source-code">        return client.executeSync(req);</p>
			<p class="source-code">    } catch (Exception ex) {</p>
			<p class="source-code">        throw new IllegalStateException(ex);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">private DynamicGraphQLClient newClient() {</p>
			<p class="source-code">    return DynamicGraphQLClientBuilder.newBuilder()</p>
			<p class="source-code">        .url(URL)</p>
			<p class="source-code">        .build();</p>
			<p class="source-code">}</p>
			<p class="source-code">private void verify(Supplier&lt;Response&gt; responseSupplier)        throws Exception {</p>
			<p class="source-code">    Response resp = responseSupplier.get();</p>
			<p class="source-code">    JsonObject data = resp.getData();</p>
			<p class="source-code">    assertNotNull(data);</p>
			<p class="source-code">    JsonArray allProfiles =         data.getJsonArray("allProfiles");</p>
			<p class="source-code">    assertNotNull(allProfiles);</p>
			<p class="source-code">    JsonObject emily = allProfiles.getJsonObject(0);</p>
			<p class="source-code">    assertNotNull(emily);</p>
			<p class="source-code">    assertEquals("Emily J", emily.getString("ownerId"));</p>
			<p class="source-code">    assertEquals("emilyj@notmyrealaddress.com",        emily.getString("emailAddress"));</p>
			<p class="source-code">    JsonObject andy = allProfiles.getJsonObject(1);</p>
			<p class="source-code">    assertNotNull(andy);</p>
			<p class="source-code">    assertEquals("Andy M", andy.getString("ownerId"));</p>
			<p class="source-code">    assertEquals("andym@notmyrealaddress.com",        andy.getString("emailAddress"));</p>
			<p class="source-code">}</p>
			<p>In this code snippet, we <a id="_idIndexMarker1194"/>create a <a id="_idIndexMarker1195"/>new <strong class="source-inline">DynamicGraphQLClient</strong> instance using the builder <a id="_idIndexMarker1196"/>pattern and specifying the <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>)—for our example, the URL is <strong class="source-inline">http://localhost:9080/ch11/graphql</strong>. We then call the <strong class="source-inline">executeSync</strong> method on that client instance, passing it as <strong class="source-inline">RequestImpl</strong> with our query in a plain text string. This returns a <strong class="source-inline">Response</strong> object that we can extract a JSON-P <strong class="source-inline">JsonObject</strong> instance from that contains the data from the GraphQL result.</p>
			<p>Another way that we <a id="_idIndexMarker1197"/>could write this is more <a id="_idIndexMarker1198"/>like a builder pattern, where we build each part of the query into a <strong class="source-inline">Document</strong> object using Java code. Here is an example of this:</p>
			<p class="source-code">@Test</p>
			<p class="source-code">public void testAllProfilesWithConstructedDocument() throws   Exception {</p>
			<p class="source-code">    Field query = field("allProfiles");</p>
			<p class="source-code">    query.setFields(Arrays.asList(field("ownerId"),         field("emailAddress")));</p>
			<p class="source-code">    verify(() -&gt; executeSync(document(operation</p>
			<p class="source-code">        (OperationType.QUERY, "allProfiles",query))));</p>
			<p class="source-code">}</p>
			<p>In this code, we create an <strong class="source-inline">allProfiles</strong> field for the query itself, and then create the sub-fields we are interested in: <strong class="source-inline">ownerId</strong> and <strong class="source-inline">emailAddress</strong>. We then construct an <strong class="source-inline">Operation</strong> from the query field and a <strong class="source-inline">Document</strong> object from the <strong class="source-inline">Operation</strong>. We then pass the <strong class="source-inline">Document</strong> object to the <strong class="source-inline">executeSync</strong> method in order to invoke the query, and our <strong class="source-inline">Response</strong> object is the same as in the previous code snippet. This may seem more complicated than simply writing up the query in plain text, but the advantage is that you could use this approach to build more complicated queries depending on the situation—for example, you could programmatically request additional fields in your query for certain situations.</p>
			<p>The dynamic client is a nice way to write GraphQL queries and mutations that might require changes, depending on when they are invoked. For situations where you expect the query to be somewhat static, the type-safe client is more appropriate. Let's see what that looks like next.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor213"/>Type-safe client</h2>
			<p>The type-safe client borrows a <a id="_idIndexMarker1199"/>lot of its design <a id="_idIndexMarker1200"/>from the MicroProfile REST client. It uses annotations and interfaces to represent the remote service and then either a builder pattern or CDI injection to create a client instance. Let's take a look at how we might code this up in an integration test case. First, we'll need to represent the actual response object, the <strong class="source-inline">OwnerProfile</strong> object, as follows:</p>
			<p class="source-code">class OwnerProfile {</p>
			<p class="source-code">    String ownerId;</p>
			<p class="source-code">    String emailAddress;</p>
			<p class="source-code">    // public getters/setters</p>
			<p class="source-code">}</p>
			<p>This is very similar to the same class on the server side. Let's now see what the client interface looks like, as follows:</p>
			<p class="source-code">@GraphQLClientApi</p>
			<p class="source-code">interface ProfileApi {</p>
			<p class="source-code">    List&lt;OwnerProfile&gt; allProfiles();</p>
			<p class="source-code">}</p>
			<p>This interface is annotated with <strong class="source-inline">@GraphQLClientApi</strong> to indicate that it represents the remote service. Because we are only interested in the <strong class="source-inline">allProfiles</strong> query, we only have one method: <strong class="source-inline">allProfiles</strong>. We could add other methods to match other queries or mutations. Since this is a single-query method, we don't need to annotate it with <strong class="source-inline">@Query</strong>, but if we wanted to include mutations, then we would need to specify which methods are which, with the <strong class="source-inline">@Query</strong> and <strong class="source-inline">@Mutation</strong> annotations.</p>
			<p>Let's now tie this all together with the builder code and the execution, as follows:</p>
			<p class="source-code">@Test</p>
			<p class="source-code">public void testAllProfiles() throws Exception {</p>
			<p class="source-code">    ProfileApi api = TypesafeGraphQLClientBuilder         .newBuilder()</p>
			<p class="source-code">        .endpoint(URL)</p>
			<p class="source-code">        .build(ProfileApi.class);</p>
			<p class="source-code">    List&lt;OwnerProfile&gt; allProfiles = api.allProfiles();</p>
			<p class="source-code">    assertNotNull(allProfiles);</p>
			<p class="source-code">    assertEquals(2, allProfiles.size());</p>
			<p class="source-code">    assertEquals("Emily J",         allProfiles.get(0).getOwnerId());</p>
			<p class="source-code">    assertEquals("emilyj@notmyrealaddress.com",        allProfiles.get(0).getEmailAddress());</p>
			<p class="source-code">    assertEquals("Andy M",allProfiles.get(1).getOwnerId());</p>
			<p class="source-code">    assertEquals("andym@notmyrealaddress.com",        allProfiles.get(1).getEmailAddress());</p>
			<p class="source-code">}</p>
			<p>We build an <a id="_idIndexMarker1201"/>instance of the <strong class="source-inline">ProfileApi</strong> client interface using <strong class="source-inline">TypesafeGraphQLClientBuilder</strong>. Then, once we invoke a method on this interface, the query is <a id="_idIndexMarker1202"/>sent to the server and returns with a list of owner profiles identical to the data returned using the dynamic client in the previous section.</p>
			<p>Both of these client options provide a lot of power and flexibility for invoking remote GraphQL services, even those not built with MicroProfile—or even Java.</p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor214"/>Summary</h1>
			<p>In this chapter, we've learned about GraphQL and how it addresses some of the gaps in REST. We've also learned how to create and consume GraphQL services using MP GraphQL, without the overhead of maintaining a schema in addition to Java code. We've learned that we can build queries and mutations by applying annotations to our API classes and that we can enrich them by adding descriptions, parameters, formatting, and more. By outsourcing, we've learned that we can avoid executing expensive operations when they are not necessary. We've also learned how to send partial results when exceptions occur. We've learned that there are some useful tools such as <strong class="bold">GraphiQL</strong> that can simplify testing. And while the client APIs aren't fully supported from the specification, we've been able to view two different clients, and we've seen how we could use them for integration testing or to consume GraphQL services.</p>
			<p>With what we've learned in this chapter, combined with the tools available at our disposal, we are now able to develop and test cloud-native GraphQL applications or apply a GraphQL frontend to our existing applications. Our microservices can now avoid over-fetching and under-fetching, reducing network traffic and giving clients exactly what they want. </p>
			<p>In the next chapter, we will take a look at the future of MicroProfile and see what changes we can expect to see in the years to come.</p>
		</div>
	</body></html>