- en: Chapter 5. Interactive Application Design and Theory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。交互式应用程序设计与理论
- en: '|   | *"If you never did, you should. These things are fun and fun is good."*
    |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"如果你从未做过，你应该。这些事情很有趣，有趣是好的。" |   |'
- en: '|   | --*Dr. Suess* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*苏斯博士* |'
- en: 'Creating engaging and immersive experiences in Greenfoot is far more involving
    than compiling a collection of programming effects into one application. In this
    chapter, you will learn how to engage your user by understanding the relationship
    between user choice and outcome, conditioning the user, and including the right
    level of complexity into your work. You will be shown a proven iterative development
    process that will help you put theory into practice. The topics that will be covered
    in the chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Greenfoot 中创建引人入胜和沉浸式的体验，远比将编程效果集合到一个应用程序中更具吸引力。在本章中，你将学习如何通过理解用户选择与结果之间的关系、对用户进行条件化以及将适当复杂度融入你的工作中来吸引用户。你将看到一个经过验证的迭代开发过程，这将帮助你将理论付诸实践。本章将涵盖以下主题：
- en: Meaningful play
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有意义的游戏
- en: Choice, action, and outcomes
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择、行动和结果
- en: Complexity
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂度
- en: Goals
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标
- en: User conditioning
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户条件化
- en: Storytelling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讲故事
- en: Fictional worlds
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟世界
- en: Narrative descriptors
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 叙事描述
- en: Interactive entertainment iterative development process
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互娱乐迭代开发过程
- en: As we discuss the topics of this chapter, we will refer to the Avoider game
    we created in [Chapter 1](part0014.xhtml "Chapter 1. Let's Dive Right in…"), *Let's
    Dive Right in…* and [Chapter 2](part0017.xhtml "Chapter 2. Animation"), *Animation*.
    We will discuss items already implemented in the game to illustrate interactive
    design concepts and demonstrate other concepts by adding new features. In this
    chapter, we are discussing methods to engineer fun. That might sound strange,
    but creating fun is the main goal of the designers of games and other forms of
    interactive entertainment. And, as Dr. Suess so elegantly puts it, "These things
    are fun and fun is good."
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论本章的主题时，我们将参考我们在[第 1 章](part0014.xhtml "第 1 章。让我们直接跳进去…")，“让我们直接跳进去…”，以及[第
    2 章](part0017.xhtml "第 2 章。动画")，“动画”中创建的 Avoider 游戏。我们将讨论游戏中已经实现的项目，以说明交互设计概念，并通过添加新功能来展示其他概念。在本章中，我们正在讨论创造乐趣的方法。这听起来可能有些奇怪，但创造乐趣是游戏和其他形式交互娱乐的设计师的主要目标。而且，正如苏斯博士如此优雅地所说，“这些事情很有趣，有趣是好的。”
- en: Meaningful play
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有意义的游戏
- en: Learning to create experiences that are meaningful to users is the most important
    skill needed by developers of interactive applications. It is the meaning of the
    interaction that drives players to invest time and energy in playing your application.
    We want to invoke feelings of happiness, anger, pride, relief, caring, astonishment,
    surprise, elation, or satisfaction in our users. To do this, *we need to provide
    immediate and long-term feedback to difficult choices and actions taken by the
    user*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 学习创造对用户有意义的体验是交互应用程序开发者最需要的技能。正是这种交互的意义驱使玩家投入时间和精力来玩你的应用程序。我们希望唤起用户快乐、愤怒、自豪、放松、关心、惊讶、惊喜、兴奋或满足的感觉。为了做到这一点，*我们需要为用户做出的困难和行动提供即时和长期反馈*。
- en: Let's look at a few clarifying examples that might take place in a role-playing
    game (RPG). Imagine that you are a wizard wondering through a forest-covered mountain
    when you come upon a cave. Peeking into the cave, you see in the dim light a sleeping
    dragon surrounded by treasure. The following are some possible interactions that
    could take place. We will discuss each, and determine if it created meaningful
    play.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些可能发生在角色扮演游戏（RPG）中的澄清示例。想象一下，你是一位在森林覆盖的山脉中漫步的巫师，当你来到一个洞穴前。向洞穴里窥视，你在昏暗的光线中看到一条被宝藏包围的沉睡的龙。以下是一些可能发生的互动。我们将讨论每一个，并确定它是否创造了有意义的游戏。
- en: '**Scenario 1**:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景 1**:'
- en: '**User choice**: You look through your spell book and decide to cast the spell
    *Fireball*.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户选择**：你翻阅你的咒语书，决定施展*火球*咒语。'
- en: '**User action**: You cast the spell on the dragon.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户行动**：你对龙施展了咒语。'
- en: '**System feedback/outcome**: The fireball hits the dragon. Nothing happens
    afterwards.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统反馈/结果**：火球击中了龙。之后没有发生任何事情。'
- en: What!?!?? Did your spell fail? Is the game broken? Does the dragon have an aura
    of anti-magic? Did you actually miss? We get absolutely no meaning from this interaction.
    The player is left confused and disengaged. Let's look at another scenario.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 啊？！？你的拼写失败了吗？游戏出故障了吗？龙有反魔法光环吗？你真的错过了吗？我们从这次交互中得不到任何意义。玩家感到困惑和脱节。让我们看看另一个场景。
- en: '**Scenario 2**:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景 2**:'
- en: '**User choice**: You look through your spell book and decide to cast the spell
    *Fireball*.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户选择**：你翻阅你的咒语书，决定施放*火球*魔法。'
- en: '**User action**: You cast the spell on the dragon.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户行为**：你对龙施放了魔法。'
- en: '**System feedback/outcome**: The fireball hits the dragon. The dragon laughs
    and says, "Puny mortal. Go immediately, and I will let you live."'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统反馈/结果**：火球击中了龙。龙痛苦地尖叫着，然后分解。'
- en: The meaning is perfectly clear here. You have little power and you have no chance
    against a creature as strong as a dragon. You could choose to talk to the dragon,
    but he has indicated extreme annoyance at your presence. Are you going to press
    your luck or flee? Maybe one day, you'll grow strong enough to come back and take
    that treasure from this dragon. For now, you might be feeling lucky, inspired
    to be better, frightened, or frustrated at your lack of progress. However, you
    are feeling something and the interaction definitely had meaning.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的意义非常明确。你对一个像龙这样强大的生物几乎无能为力，也没有机会。你可以选择和龙交谈，但他已经对你的存在表示极度的不满。你是要冒险还是逃跑？也许有一天，你会变得足够强大，回来从这条龙那里夺走宝藏。现在，你可能觉得自己很幸运，受到鼓舞想要变得更好，或者因为缺乏进展而感到害怕或沮丧。然而，你确实有所感受，这种互动确实是有意义的。
- en: '**Scenario 3**:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**情景3**：'
- en: '**User choice**: You look through your spell book and decide to cast the spell
    *Fireball*.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户选择**：你翻阅你的咒语书，决定施放*火球*魔法。'
- en: '**User action**: You cast the spell on the dragon.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户行为**：你对龙施放了魔法。'
- en: '**System feedback/outcome**: The fireball hits the dragon. The dragon screams
    in agony before disintegrating.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统反馈/结果**：火球击中了龙。龙在痛苦中尖叫，然后分解。'
- en: Ah, it is time to collect your loot. You marvel at your supreme power. Perhaps
    you should have allowed the dragon one chance to flee? Nah, it probably would
    not have done that for you. This interaction re-affirms your greatness.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，是时候收集你的战利品了。你对自己的至高无上力量感到惊叹。也许你应该给龙一次逃跑的机会？不，它可能不会为你这么做。这次互动再次证实了你的伟大。
- en: The key to creating engaging applications is producing meaningful interactions
    on a moment-to-moment basis with the user. If a choice and action do not have
    a meaningful outcome, then why bother your users with it? *Every interaction in
    your interactive applications needs to be meaningful.* This is what Salen and
    Zimmerman refer to as *descriptive meaningful play* in their book, *Rules of Play*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建引人入胜的应用程序的关键是时刻与用户产生有意义的互动。如果选择和行动没有有意义的后果，那么为什么还要让用户烦恼呢？*您交互式应用程序中的每一次互动都需要有意义*。这正是Salen和Zimmerman在他们所著的《游戏规则》一书中提到的*描述性有意义的游戏*。
- en: Another very important aspect to your application is the long-term outcome of
    a user's action. For example, in Scenario 3, the player could be referred to as
    Dragon Slayer, later in the game. The fine items purchased with the loot should
    be useful later in the game. *The outcomes of actions need to persist in the game*.
    Salen and Zimmerman refer to this as *evaluative meaningful play*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序中另一个非常重要的方面是用户行为的长期结果。例如，在情景3中，玩家可能会被称为游戏中的龙战士，之后在游戏中。用战利品购买的精美物品应该对游戏后期有用。*行为的结果需要在游戏中持续存在*。Salen和Zimmerman将此称为*评估性有意义的游戏*。
- en: Meaningful play is not only for games. The same thought process should be used
    to design any application. For example, if a user clicks on an item on an e-commerce
    site that they are interested in purchasing, there should be immediate visual
    feedback, such as the shopping cart icon displaying a 1 instead of a 0 or, going
    even further, the sound of a cheering crowd playing for a couple of seconds. If
    a user types in a word processing document, the word processing application should
    highlight the Save icon or put an asterisk by the filename to indicate that there
    are unsaved changes. If a person is taking a survey, there should a progress meter
    to let them know how many questions they have left to answer. Perhaps you could
    offer words of encouragement every time the user completes five survey questions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有意义的游戏不仅适用于游戏。在设计任何应用程序时，都应该使用相同的思考过程。例如，如果用户点击了一个他们感兴趣想要购买的电子商务网站上的商品，应该立即有视觉反馈，比如购物车图标显示1而不是0，或者更进一步，播放几秒钟欢呼的人群的声音。如果用户在文字处理文档中输入文字，文字处理应用程序应该突出显示保存图标，或者在文件名旁边放置星号，以表明有未保存的更改。如果一个人正在填写调查问卷，应该有一个进度条让他们知道他们还有多少问题需要回答。也许你可以在用户完成五个调查问题后提供一些鼓励的话语。
- en: Complexity
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂性
- en: There is a really funny game that demonstrates what a game plays like when the
    player's choices are overly simplistic. It is called *Super PSTW Action RPG*.
    In this RPG, you only have one control—the spacebar. For every given situation,
    you simply hit the spacebar. If you haven't guessed, the PSTW in the title stands
    for **Press Space To Win**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常有趣的演示游戏，展示了当玩家的选择过于简单时，游戏会是什么样子。它被称为*超级PSTW动作RPG*。在这个RPG中，你只有一个控制键——空格键。对于任何给定的情况，你只需简单地按空格键。如果你还没有猜到，标题中的PSTW代表**按空格键获胜**。
- en: 'Obviously, this game is a joke, but it is also an interesting experiment in
    game design. There is no meaningful play in the game, because the choice and action
    a player has to take is trivial. The actions and outcomes are well designed, but
    that is insufficient. Without complexity of choice, there is no meaningful play.
    We don''t have to go to such an extreme example to demonstrate this point. Have
    you ever played the card game War? If not, you can quickly review the rules here:
    [http://en.wikipedia.org/wiki/War_(card_game)](http://en.wikipedia.org/wiki/War_(card_game)).
    This game also has no meaningful play. Throughout the game, the player either
    flips a card over or places three cards face down and then flips a card over.
    The current game state completely informs the player of which action they should
    take. There are no tradeoffs to consider and no risk analysis to be done. It is
    all mechanical play. For most players older than 10 years, Tic-Tac-Toe suffers
    from the same lack of meaningful play.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这款游戏只是一个玩笑，但它也是游戏设计中的一个有趣实验。游戏中没有有意义的玩法，因为玩家必须做出的选择和行动都是微不足道的。动作和结果设计得很好，但这还不够。没有选择复杂性的话，就没有有意义的玩法。我们不必用这样一个极端的例子来证明这一点。你玩过“战争”牌戏吗？如果没有，你可以快速在这里回顾规则：[http://en.wikipedia.org/wiki/War_(card_game)](http://en.wikipedia.org/wiki/War_(card_game))。这款游戏也没有有意义的玩法。在整个游戏中，玩家要么翻一张牌，要么将三张牌面朝下放置，然后翻一张牌。当前的游戏状态完全告知玩家他们应该采取什么行动。没有需要考虑的权衡和风险分析。这完全是机械式的玩法。对于大多数10岁以上的玩家来说，井字棋也遭受了同样缺乏有意义的玩法的困扰。
- en: 'For meaningful play to exist, the decisions a player makes should require sufficient
    mental effort. A player must have several options available to them and each option
    should involve different tradeoffs, risks, and rewards. For example, in our RPG
    scenarios above, the player might have the following choices available to them:
    cast Fireball, cast Lightning Strike, cast Charm Monster, talk, or flee. Perhaps
    the player has learned previously in the game, that charm spells rarely work on
    dragons and that certain dragons are immune to either fire or lightning. The player
    could choose to flee. This is a low-reward, low-risk option.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存在有意义的玩法，玩家所做的决定应该需要足够的脑力劳动。玩家必须有几个选项可供选择，并且每个选项都应该涉及不同的权衡、风险和回报。例如，在我们的RPG场景中，玩家可能有以下选择：施放火球、施放闪电打击、施放魅惑怪物、交谈或逃跑。也许玩家在游戏中之前已经了解到，魅惑法术很少对龙有效，而且某些龙对火或闪电具有免疫力。玩家可以选择逃跑。这是一个低回报、低风险的选项。
- en: When a player is making non-trivial decisions, taking action, and is provided
    with clear feedback, then the game becomes meaningful. When making decisions in
    an interactive application or game, the player needs to know what the goals of
    the interaction are. Is it to create custom pieces of music, become the most powerful
    wizard, or get the best deals on an e-commerce site? Setting up user goals is
    the next most important aspect of creating engaging applications.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家做出非平凡的决定、采取行动并获得清晰的反馈时，游戏就变得有意义。在交互式应用程序或游戏中做出决策时，玩家需要知道互动的目标是什么。是要创建定制的音乐作品、成为最强大的巫师，还是在电子商务网站上获得最佳交易？设置用户目标是创建引人入胜的应用程序下一个最重要的方面。
- en: Goals
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: Goals provide the players the means to assess their decisions in their moment-to-moment
    and long-term interactions with your application. After each interaction, the
    user can ask, "Did my last choice and action bring me closer to completing my
    goal?" With this type of ongoing assessment, users can augment and optimize their
    decision processes, in order to more quickly achieve their goals. In essence,
    the players use goals as guides to learning optimal ways to interact with your
    application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 目标为玩家提供了评估他们在与你的应用程序的即时和长期互动中做出的决策的手段。每次互动后，用户可以问自己，“我的最后一个选择和行动是否让我更接近完成我的目标？”通过这种持续的评估，用户可以增强和优化他们的决策过程，以便更快地实现他们的目标。本质上，玩家使用目标作为指导，学习与你的应用程序互动的最佳方式。
- en: In writing an interactive application, you must set up clear goals and subgoals
    for your users. This is why high-score lists are so popular in many games. The
    simple fact of having one provides the goal of the game—score as many points as
    possible. As people play your game, they will constantly judge if their last course
    of action or long-term actions have led to the maximum amount of points. This
    enhances the meaningful play of the game.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写一个交互式应用程序时，你必须为你的用户设定清晰的目标和子目标。这就是为什么高分榜在许多游戏中如此受欢迎。仅仅拥有一个高分榜就为游戏提供了目标——尽可能多地得分。当人们玩你的游戏时，他们会不断判断他们上一次的行动或长期行动是否导致了最大数量的得分。这增强了游戏的趣味性。
- en: In industry, companies will often try and gamify their applications or services.
    For example, the airline industry sets up programs to earn free flying miles.
    So, the customer is now engaged in making decisions that optimize their ability
    to gain free miles to earn a free airline flight. It often makes sense to establish
    subgoals to keep the customer invested along the way. If it takes a year or two
    to earn enough free flying miles, then the consumer could get discouraged. An
    airline might decide to offer intermediate goals, such as earning a free travel
    mug after achieving a certain, smaller amount of miles. Subgoals are very important
    to drive short-term behavior, as are rewards. We will talk further about methods
    of conditioning users next.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在工业界，公司通常会尝试将他们的应用程序或服务游戏化。例如，航空业设立了赚取免费飞行里程的程序。因此，客户现在参与做出决策，以优化他们获得免费飞行里程的能力，以换取免费航班。在旅途中建立子目标以保持客户的投入往往是有意义的。如果需要一两年才能积累足够的免费飞行里程，那么消费者可能会感到沮丧。航空公司可能会决定提供中间目标，例如在达到一定数量的里程后，可以获得一个免费的旅行杯。子目标对于驱动短期行为非常重要，正如奖励一样。我们将在下一节进一步讨论用户条件化的方法。
- en: User conditioning
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户条件化
- en: In creating an interactive application or game, we want the user experience
    to be the best it can be. In creating meaningful play, we have given the user
    a rich set of options to choose from, and their path through the game has many
    possible states and outcomes. As the possible states and transitions in the game
    increase, it becomes harder as a game designer, to ensure that each path through
    the game states results in a positive interaction. We need to use user conditioning
    to help guide a user's behavior to interact with our application in predictable
    ways.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建一个交互式应用程序或游戏时，我们希望用户体验尽可能好。在创造有意义的游戏时，我们为用户提供了一个丰富的选项集供他们选择，他们的游戏路径有许多可能的状态和结果。随着游戏状态的可能状态和转换增加，作为游戏设计师，确保每个游戏状态路径都导致积极的交互变得更加困难。我们需要使用用户条件化来帮助引导用户的行为，以可预测的方式与我们的应用程序互动。
- en: The effect of conditioning was clearly demonstrated by Ivan Pavlov in an experiment
    involving a dog and food. In this experiment, Pavlov would ring a bell every time
    he fed his dog. Eventually, he could get the dog to drool by just ringing a bell.
    The dog learned to associate a neutral stimulus, like the bell, with food. While
    it seems weird to say we want to manipulate our users like this, it will help
    us to guide the user into the most favorable interactions with our application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 条件化的效果在伊凡·巴甫洛夫的一个涉及狗和食物的实验中得到了清晰的展示。在这个实验中，巴甫洛夫每次喂狗时都会响铃。最终，他只需响铃就能让狗流口水。狗学会了将一个中性刺激，如铃声，与食物联系起来。虽然这样说我们想要像这样操纵我们的用户似乎很奇怪，但这将帮助我们引导用户进入与我们的应用程序最有利的交互。
- en: 'There are three methods we will use to condition our users:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用三种方法来条件化我们的用户：
- en: '**Positive reinforcement**: Give the user a reward for doing the behavior we
    want.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正强化**：当用户做出我们希望的行为时，给予用户奖励。'
- en: '**Negative reinforcement**: Take away something negative when the user does
    the desired behavior.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负强化**：当用户做出期望的行为时，移除一些负面因素。'
- en: '**Punishment**: Take away something positive or add something negative when
    the users exhibit the wrong behavior.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**惩罚**：当用户表现出错误行为时，移除一些正面因素或添加一些负面因素。'
- en: We want to treat our users with respect, and we want them to have a good time;
    therefore, positive reinforcement should be the way we condition our users the
    most. We want to give them rewards for doing the correct behavior. In a game,
    we might give them points, an extra life, an extra ability, or access to a new
    part of the game. Whether you are creating a game or an interactive application,
    you should have a set reward schedule for your users. Some rewards could be given
    frequently, such as earning points for disposing of an enemy, while other rewards
    could be more rare, such as giving the character the ability to fly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望尊重我们的用户，并希望他们玩得开心；因此，积极的强化应该是我们最常用来训练用户的方式。我们希望奖励他们正确的表现。在游戏中，我们可能会给他们加分、额外生命、额外能力，或者进入游戏新区域的权限。无论是创建游戏还是交互式应用程序，你都应该为你的用户提供一套奖励计划。一些奖励可能会频繁发放，例如，通过消灭敌人获得积分，而其他奖励可能会更罕见，例如，给予角色飞行的能力。
- en: Giving rewards allows us to tell the player which behaviors are favored in the
    game. If we wanted the user to get through an area as fast as possible, we could
    give a reward for doing it under 30 seconds. If we wanted the user to explore
    the controls and find fighting move combinations, we could give extra points whenever
    three fighting combinations are done in a row. If we wanted our users to pick
    flowers, we could provide a 0.001 percent chance to receive the most powerful
    item in the game every time a flower is picked. If we wanted a customer to buy
    coffee at a store more often, we could give them every twelfth drink free. Rewards
    are a powerful mechanism to condition users.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 给予奖励允许我们告诉玩家哪些行为在游戏中是被偏好的。如果我们希望用户尽可能快地通过一个区域，我们可以在30秒内完成时给予奖励。如果我们希望用户探索控制并找到战斗动作组合，我们可以在连续完成三次战斗组合时给予额外积分。如果我们希望用户采摘花朵，我们可以在每次采摘花朵时提供0.001%的机会获得游戏中最强大的物品。如果我们希望顾客在商店更频繁地购买咖啡，我们可以每第十二杯饮料免费。奖励是一种强大的用户训练机制。
- en: Negative reinforcement is less used but still a powerful tool to condition users.
    In the last paragraph, I mentioned that you could encourage your player to move
    fast through an area by giving them a reward for making it through in under 30
    seconds. Using negative reinforcement, we could drive the same behavior. Imagine
    that you are in very large room and the ceiling starts slowly moving down. You
    become aware that if you do not get out quickly, you will get squashed. By moving
    quickly to the other side of the room and leaving, you no longer have this pressure
    to move quick. This is negative reinforcement. Other examples of negative reinforcement
    include making the lighting dark in an area and playing creepy music, in order
    to encourage the player to get out of this area quickly (the game Bioshock is
    great at this), sounding a siren when the player is in a place they shouldn't
    be in, or blinking the screen until your health gets back to an acceptable level.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 负面强化虽然使用较少，但仍然是一种强大的用户训练工具。在上一个段落中，我提到你可以通过给予玩家在30秒内通过某个区域的奖励来鼓励他们快速通过该区域。使用负面强化，我们可以驱动相同的行为。想象一下，你在一个非常大的房间里，天花板开始慢慢下降。你意识到如果你不快速离开，你将被压扁。通过快速移动到房间的另一边并离开，你就不再有这种快速移动的压力。这就是负面强化。负面强化的其他例子包括在一个区域中使灯光变暗并播放令人毛骨悚然的音乐，以鼓励玩家快速离开该区域（游戏《生化奇兵》在这方面做得很好），当玩家在不应出现的地方时发出警报，或者闪烁屏幕直到你的健康值回到可接受的水平。
- en: Ultimately, punishment is a necessary component of game play, although not usually
    included in the gamification of a non-game application. There eventually have
    to be hard consequences for not meeting game objects. This could include subtracting
    points, subtracting money, losing a life, and eventually losing the game. Punishment
    is necessary because there has to be some risk associated with the choices a player
    makes, in order to achieve meaningful play. Just try not to be too hard on your
    users. The whole point of making a game is to provide an engaging, recreational
    activity.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，惩罚是游戏玩法的一个必要组成部分，尽管通常不包括在非游戏应用的游戏化中。最终必须对未能达到游戏目标的行为有硬性后果。这可能包括扣分、扣钱、失去生命，最终输掉游戏。惩罚是必要的，因为必须有一些风险与玩家所做的选择相关联，以便实现有意义的游戏体验。只是尽量不要对你的用户太苛刻。制作游戏的全部目的就是提供一个引人入胜、休闲的活动。
- en: Storytelling
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讲故事
- en: Telling and appreciating stories has been engrained into our culture since the
    earliest times. We present stories in many different formats and mediums. They
    appear in oral traditions, the written word, theatre, cinema, and games. Games
    are one of the newest forms of storytelling but perhaps the most compelling for
    one simple reason—YOU are the main character of the story. In traditional methods
    of storytelling, the author must spend sufficient time building up a relatable
    character that the audience cares about. In games, you get this for free. You
    are the character.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从最早的时代起，讲述和欣赏故事就已经深深植根于我们的文化中。我们以许多不同的格式和媒介呈现故事。它们出现在口头传统、书面文字、戏剧、电影和游戏中。游戏是讲故事的新形式之一，但也许是因为一个简单的原因——你才是故事的主角。在传统的讲故事方法中，作者必须花费足够的时间构建一个受众关心的、可联系的角色。在游戏中，你无需付出任何代价就能得到这个角色。
- en: Fictional worlds
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚构世界
- en: In games, stories have an additional role other than just pure entertainment.
    The story creates a fictional world for the player of the game that helps guide
    their experience. It provides context for the actions and the motivation to achieve
    goals. Why are we killing these aliens in this game? Well, given that they just
    wiped out all of South America and are heading north, we know we need to stop
    their advance soon if the world is to stand a chance of surviving this invasion.
    If a game takes place in outer space, you expect to have spaceships, lasers, and
    aliens. There is a whole wealth of information given to your player by just telling
    them that the story takes place in the Old West, under water, or on a soccer field.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，故事除了纯粹的娱乐作用外，还有其他作用。故事为游戏玩家创造了一个虚构世界，有助于引导他们的体验。它为行动和实现目标提供背景和动机。为什么我们在游戏中要杀死这些外星人？好吧，鉴于他们刚刚摧毁了整个南美洲，正朝北方进发，我们知道如果世界要在这场入侵中生存下来，我们必须尽快阻止他们的前进。如果一个游戏发生在外太空，你期望看到宇宙飞船、激光和外星人。只要告诉玩家故事发生在老西部、水下或足球场上，就能向玩家提供大量信息。
- en: For any game, you should have a rich and complete story that covers what happens
    in your game's fictional world before the game is played, what happens to it during
    the game, and what happens afterwards—even if the user will never experience the
    before and after. Your fictional world and story not only provide context and
    motivation for the player, but they also serve as a guide to the game designer.
    As you add and subtract features from the game, as you go through the interactive
    entertainment development process (described in the section by the same name),
    you need to make sure you stay true to both.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '对于任何游戏，你应该有一个丰富而完整的故事，涵盖游戏在玩家开始游戏之前、游戏过程中以及游戏之后发生的事情——即使用户永远不会体验到游戏之前和之后的事情。你的虚构世界和故事不仅为玩家提供背景和动机，还作为游戏设计师的指南。当你从游戏中添加或删除功能时，当你通过互动娱乐开发过程（在本节中描述）时，你需要确保你忠于这两者。 '
- en: Narrative descriptors
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 叙述描述符
- en: Everything in your game contributes to the story and your fictional world—the
    graphics on the box your game is shipped in, the manual, and the sounds and images
    in your game. You want your player to imagine a rich and vibrant world by providing
    appropriate and consistent narrative descriptors. Luckily, it does not take many
    prompts to get your user to imagine a complex world due to the principle of minimal
    departure. This principle states that people will use their knowledge of the world
    to fill in any missing gaps they see in an incomplete image. Take a few moments
    to look at *Figure 1*. What do you imagine lives in those mountains? Does this
    world have gravity? What else can you say about the world depicted in this figure?
    Whatever you come up with, you did so using the principle of minimal departure.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的游戏中，一切元素都为故事和你的虚构世界做出贡献——无论是游戏包装盒上的图形、说明书，还是游戏中的声音和图像。你希望通过提供适当且一致的叙述描述，让你的玩家想象出一个丰富而充满活力的世界。幸运的是，由于最小偏离原则，不需要太多提示就能让你的用户想象出一个复杂的世界。这个原则指出，人们会利用他们对世界的知识来填补他们在一个不完整的图像中看到的任何缺失。花几分钟时间看看*图1*。你想象那些山里住着什么？这个世界有重力吗？你能对这个图中描绘的世界说些什么？无论你想到什么，你都是利用最小偏离原则做到的。
- en: '![Narrative descriptors](img/image00292.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![叙述描述符](img/image00292.jpeg)'
- en: 'Figure 1: This is an example of the principle of minimal departure.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：这是最小偏离原则的一个例子。
- en: Now, take a look at *Figure 2*. What has been added to the picture? How does
    this change your perception of the world? What if I would have added a caveman
    instead of a robot?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请看看*图2*。图片中添加了什么？这如何改变你对世界的看法？如果我在图片中添加一个穴居人而不是机器人会怎样？
- en: '![Narrative descriptors](img/image00293.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![叙事描述符](img/image00293.jpeg)'
- en: 'Figure 2: This shows the power of one narrative descriptor to completely change
    the fictional world'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：这展示了单个叙事描述符如何完全改变虚构世界
- en: Just as in a movie, everything that appears in your game or interactive application
    should perpetuate the story. For example, if you create an interactive history
    simulation of medieval times, then you should use a font that matches the time
    period and not use Courier New. If you have a game that takes place during World
    War I, then perhaps instead of showing a vanilla health bar for your player, you
    could show the picture of a soldier that looks more injured as you take more damage.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在电影中一样，你游戏中或互动应用程序中出现的每一件事都应该延续故事。例如，如果你创建了一个中世纪时期的互动历史模拟，那么你应该使用符合该时期的字体，而不是使用Courier
    New。如果你有一个发生在第一次世界大战的游戏，那么也许你可以在玩家受到更多伤害时，展示一个看起来更受伤的士兵图片，而不是展示一个普通的健康条。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Disney**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**迪士尼**'
- en: Disney provides great stories and is a master of using narrative descriptors.
    Have you ever been to Disneyland? I once had the privilege to be given a tour
    of Disneyland by Disney Imagineers and artists. The first thing that struck me,
    is how every employee of Disney recites the same mantra, "Story, story, story".
    I was surprised to find that on the tour my guides continually pointed out their
    use of narrative descriptors. In the different lands, they would show me how the
    concrete, plants, trash cans, and lighting all contributed to the story of the
    area. They knew that one item out of place could confuse or destroy the fictional
    worlds that their customers were imagining.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 迪士尼提供了精彩的故事，并且是运用叙事描述符的大师。你有没有去过迪士尼乐园？我曾经有幸被迪士尼的想象工程师和艺术家带领参观迪士尼乐园。给我留下深刻印象的第一件事是，迪士尼的每位员工都背诵着同样的咒语，“故事，故事，故事”。我惊讶地发现，在参观过程中，我的导游不断地指出他们使用叙事描述符的方式。在不同的区域，他们会向我展示如何通过混凝土、植物、垃圾桶和照明等元素共同构建该区域的叙事。他们知道，任何一个位置不恰当的物品都可能会使顾客所想象的虚构世界变得混乱或被破坏。
- en: The interactive entertainment iterative development process
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互动娱乐迭代开发过程
- en: All of the design principles we have discussed thus far in this chapter will
    help you to create meaningful, engaging interactive applications. However, they
    are not enough. As you proceed with designing and building your game, you get
    to know the game deeply and lose your ability to be an unbiased judge of it. In
    addition, what you find fun and meaningful, could be confusing to others. You
    have to realize that if you have created a game with sufficient complexity, you
    will not be able to predict game play.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 本章迄今为止所讨论的所有设计原则都将帮助你创建有意义的、引人入胜的互动应用程序。然而，这些还不够。随着你继续设计和构建你的游戏，你会对游戏有更深入的了解，并失去作为无偏见评判者的能力。此外，你认为有趣和有意义的东西，可能对其他人来说会感到困惑。你必须意识到，如果你创建了一个具有足够复杂性的游戏，你将无法预测游戏玩法。
- en: The only way to give your application the best chance of success, is to develop
    it using the interactive entertainment iterative development method shown in *Figure
    3*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 给你的应用程序提供最佳成功机会的唯一方法，就是使用*图3*中所示的互动娱乐迭代开发方法进行开发。
- en: '![The interactive entertainment iterative development process](img/image00294.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![互动娱乐迭代开发过程](img/image00294.jpeg)'
- en: 'Figure 3: This is the interactive entertainment iterative development process'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：这是互动娱乐迭代开发过程
- en: Next, we will talk about having an initial idea for a game and some upfront
    work you need to do to make an effective game pitch. In the gaming industry, game
    developers have to pitch their game and convince peers and management that this
    game is worth investing in. If you are working with a small team, you will still
    need to pitch the game to developers and artists that you want to recruit to work
    on your project. After talking about the upfront work, we will discuss each stage
    of the iterative design process in turn.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论为游戏构思一个初步想法以及你需要做的前期工作，以便制作一个有效的游戏提案。在游戏产业中，游戏开发者必须提出他们的游戏，并说服同行和管理层，这个游戏值得投资。如果你在一个小团队中工作，你仍然需要向希望招募加入你项目的开发者和艺术家提出游戏提案。在讨论前期工作之后，我们将依次讨论迭代设计过程的每个阶段。
- en: Game pitch and initial design
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏提案和初步设计
- en: 'So, you have an idea and a desire to build a game. What should you do next?
    You need to create a clear and concise way to describe your game to others. You
    need to be able to describe the world you are creating, the story behind this
    world, the major goal of the game, and a rough draft of the game rules. Here is
    a detailed process for creating this information:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你有一个想法，并且有建造游戏的愿望。接下来你应该做什么？你需要创建一个清晰简洁的方式来向他人描述你的游戏。你需要能够描述你正在创造的世界，这个世界的背景故事，游戏的主要目标，以及游戏规则的草稿。以下是创建这些信息的详细过程：
- en: In one paragraph, write a description of your game. Try to keep it to five sentences
    or less. Be clear, specific, and concise. As your game evolves over time, be sure
    to update this paragraph.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用一段话描述你的游戏。尽量保持五句话或更少。要清晰、具体、简洁。随着你的游戏随着时间的推移而发展，确保更新这一段落。
- en: Write the story of your game, including what happened before your game, what
    happens during your game, and what happens after your game. This will end up being
    a guide that all developers, designers, and artists will consult as they consider
    new features and assets for the game. Again, keep this document up-to-date.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写你游戏的剧情，包括游戏开始之前发生了什么，游戏过程中发生了什么，以及游戏结束后发生了什么。这将最终成为所有开发者、设计师和艺术家在考虑为游戏添加新功能和资产时参考的指南。同样，确保这份文档保持更新。
- en: In one sentence, state the game's goal. What is the player trying to achieve?
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用一句话说明游戏的目标。玩家试图实现什么？
- en: In one sentence, state how one player will know if he/she is better than another.
    Is the best player the one with the most points? Furthest progress? Best time?
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用一句话说明玩家如何知道他/她比另一个玩家更好。最好的玩家是得分最高的人吗？进度最远的人？用时最短的人？
- en: Write a draft of the rules of the game. Try to come up with at least five major
    rules. Rules provide a formal description of your game. Every game has a concise
    set of rules.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 撰写游戏规则的草案。尽量提出至少五条主要规则。规则为你的游戏提供正式描述。每个游戏都有简洁的规则集。
- en: Create a storyboard of your game. A storyboard reads like a comic book and depicts
    the main storyline and concept art for the game. Storyboards are a major design
    tool, used in both the gaming and movie industries.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建你游戏的分镜脚本。分镜脚本读起来像漫画书，描述了游戏的主要故事线和概念艺术。分镜是主要的设计工具，在游戏和电影行业中都得到广泛应用。
- en: After creating this information, make sure to keep it located in a central location
    that is shared among all team members and updated as the game evolves. When you
    are unsure what feature would be best to add to the game, or whether you should
    add a twist to the story, consult these documents and make sure everything stays
    consistent.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建这些信息后，确保将其保存在所有团队成员共享的中心位置，并在游戏发展过程中进行更新。当你不确定应该添加什么功能到游戏中，或者是否应该给故事增加一个转折时，查阅这些文档并确保一切保持一致。
- en: Prototype
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原型
- en: In this step, you implement a few features to your game that you have already
    decided upon in the last iteration's Refinement step. If this is your first iteration,
    pick a few simple things to implement, such as a main character, movement controls,
    and maybe one enemy. This step only contains coding and no design work. That was
    done through the last iteration.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，你将实施在上一个迭代细化步骤中已经决定的一些游戏功能。如果你是第一次迭代，选择一些简单的事情来实现，比如主要角色、移动控制，也许还有一个敌人。这一步只包含编码，没有设计工作。那是在上一个迭代中完成的。
- en: Playtest
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏测试
- en: This iterative development process encourages play-based design. In play-based
    design, you have volunteers playtest your game. They evaluate it, not based on
    a description you give them, but on how the game actually plays. Early stages
    will be simplistic and evaluators might only be able to comment on whether the
    controls feel natural or how the navigation feels. As the game evolves, so will
    their ability to provide feedback.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这种迭代开发过程鼓励基于游戏的设计。在基于游戏的设计中，你让志愿者测试你的游戏。他们评估它，不是基于你给出的描述，而是基于游戏的实际玩法。早期阶段将很简单，评估者可能只能评论控制是否自然或导航是否顺畅。随着游戏的发展，他们提供反馈的能力也会提高。
- en: 'Your playtesting session should be well defined and repeatable. You want to
    make sure every playtester has the same experience, so that you can reliably compile
    and compare their feedback. To conduct a playtest, you should:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你的游戏测试会话应该定义明确且可重复。你想要确保每个测试者都有相同体验，以便你可以可靠地收集和比较他们的反馈。进行游戏测试时，你应该：
- en: Have a computer available that has the prototype of your game ready to play.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一台可以玩到你游戏原型的电脑。
- en: Provide your tester with a short explanation of the playtesting procedure and
    then give them a short description of your game and what features are available
    for testing.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向你的测试者简要解释游戏测试程序，然后简要描述你的游戏以及可供测试的功能。
- en: Allow your player 5–20 minutes of play time, depending on how many features
    you want tested during this iteration. Try not to interrupt your playtester (even
    if you notice them doing something very wrong) and only speak to them if they
    ask you a question. Provide short answers, but do not elaborate.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据你想要在这一迭代中测试多少功能，让你的玩家玩5-20分钟。尽量不要打断你的测试者（即使你注意到他们做得非常不对），除非他们问你问题。提供简短的答案，但不要详细阐述。
- en: Observe the body language of your tester. Do they seem bored? Frustrated? Engaged?
    Are they looking at their watch or surprised when you tell them that their 10
    minutes of playing are up?
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察测试者的身体语言。他们看起来是否无聊？沮丧？投入？当他们告诉你他们的10分钟游戏时间结束时，他们是否在看着手表或感到惊讶？
- en: When your playtester is done with the game, give them a short survey. Ask them
    questions about the game's controls, rules, goals, and story. Ask them whether
    they felt the challenge of the game was balanced. Did they think they had sufficient
    options to consider on a moment-to-moment basis? Was the look and feel of the
    game consistent? Did your choice of narrative descriptors work well? Were they
    ever confused on what to do next? Collect some demographics on your testers. How
    old are they? Are they casual or hardcore gamers?
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你的测试者完成游戏后，给他们一份简短的调查问卷。询问他们关于游戏控制、规则、目标和故事的问题。询问他们是否觉得游戏的挑战性平衡。他们认为他们在每一刻都有足够的选项去考虑吗？游戏的外观和感觉是否一致？你选择的叙事描述符是否有效？他们是否曾经对下一步该做什么感到困惑？收集一些关于测试者的统计数据。他们多大年纪？他们是休闲玩家还是核心玩家？
- en: Have an open question-and-answer period. Do they have any suggestions on how
    to improve the game? Were there aspects they did not enjoy?
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设定一个开放式的问答环节。他们是否有关于如何改进游戏的建议？有没有他们不喜欢的地方？
- en: Make sure to thank your playtester and go over the information you collected.
    This is your last chance to get clarification from the tester. After doing all
    of this, you are ready to move to the next stage.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 确保感谢你的测试者，并回顾你收集到的信息。这是你从测试者那里获取澄清的最后机会。完成所有这些后，你就可以进入下一阶段。
- en: Evaluation
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估
- en: The evaluation stage is very mechanical. In this stage, you only compile the
    results you received from all of your playtesters. Compile all of the results
    from the survey. Is there a consensus on certain answers? For example, 80 percent
    of the playtesters felt the controls were awkward, or 100 percent of the players
    did not know what to do after killing the first enemy. For the open question-and-answer
    session, are there any suggestions that multiple testers made? From the body language
    observations, did a majority of the players ask if they were done playtesting
    before the time expired?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 评估阶段非常机械。在这个阶段，你只整理从所有测试者那里收到的结果。整理所有调查问卷的结果。是否对某些答案有共识？例如，80%的测试者觉得控制不灵活，或者100%的玩家在杀死第一个敌人后不知道该做什么。在开放式的问答环节中，是否有多个测试者提出的建议？从身体语言观察中，是否大多数玩家在时间结束前就询问他们是否完成了测试？
- en: Refinement
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 精炼
- en: The real design work happens in this stage. Pick the top two or four issues
    with the game identified during playtesting and write them down. Now, brainstorm
    the changes, additions, or subtractions you could make to the game to address
    these issues. Your ideas could include suggestions playtesters gave you or not.
    You are not obligated at all to directly use the suggestions given to you by your
    playtesters; however, you should give them special consideration. While brainstorming,
    do not filter your, or your teammates' ideas. On a piece of paper, record at least
    twenty changes you could make to your game.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的设计工作发生在这一阶段。挑选出在游戏测试过程中识别出的前两个或四个问题，并将它们记录下来。现在，头脑风暴一下你可以对游戏做出的改变、添加或删除，以解决这些问题。你的想法可能包括测试者给出的建议，也可能不包括。你并不一定要直接使用测试者给出的建议；然而，你应该给予它们特别的考虑。在头脑风暴的过程中，不要过滤你或你的队友的想法。在一张纸上，至少记录下你可以对游戏做出的二十种改变。
- en: After brainstorming twenty ideas, prioritize them based on how effectively they
    address the top issues raised by your playtesters and also based on the scope
    of work needed to implement the idea. Choose your top two to five ideas and implement
    them in the upcoming prototype stage. The process begins again.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在头脑风暴了二十个想法之后，根据它们如何有效地解决你的测试玩家提出的前几个问题以及实现该想法所需的工作范围来优先排序。选择你前两个到五个想法，并在即将到来的原型阶段实现它们。这个过程再次开始。
- en: Benefits
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优点
- en: The interactive entertainment iterative development process allows you to incrementally
    grow your game in a way that is pleasing to users. By doing quick iterations,
    you quickly find development paths that should be abandoned and others that should
    be started. While it might seem initially to be time consuming, the process will
    actually save you a lot of development time in the long run and greatly increase
    the chances that you converge on a game that is truly fun to play.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式娱乐迭代开发过程允许你以用户满意的方式逐步扩展你的游戏。通过快速迭代，你很快就能找到应该放弃的开发路径和应该开始的其他路径。虽然一开始可能看起来很耗时，但这个过程实际上会在长期内为你节省大量的开发时间，并大大增加你最终得到一个真正有趣的游戏的机会。
- en: Avoider Game
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免者游戏
- en: 'In the first couple of chapters in this book, we worked on Avoider Game, then
    switched to a zombie invasion simulation, and then a platform game. We will go
    back to Avoider Game and use it to demonstrate the concepts discussed earlier
    in this chapter. You can either start with your version of Avoider Game or download
    this version: [http://www.packtpub.com/support](http://www.packtpub.com/support)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前几章中，我们研究了避免者游戏，然后转向僵尸入侵模拟，接着是平台游戏。我们将回到避免者游戏，并使用它来展示本章前面讨论的概念。你可以从你自己的避免者游戏版本开始，或者下载这个版本：[http://www.packtpub.com/support](http://www.packtpub.com/support)
- en: Avoider Game recap
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免者游戏回顾
- en: Our version of Avoider Game which we created in [Chapter 1](part0014.xhtml "Chapter 1. Let's
    Dive Right in…"), *Let's Dive Right in…* and [Chapter 2](part0017.xhtml "Chapter 2. Animation"),
    *Animation* is fairly functional. It has an introduction screen, a game-over screen,
    a moving star field, interesting actor animations, a score, power-ups, and power-downs.
    *Figure 4* shows a screenshot from the game.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](part0014.xhtml "第1章。让我们直接进入…")、“让我们直接进入…”和[第2章](part0017.xhtml "第2章。动画")、“动画”中创建的避免者游戏版本相当功能齐全。它有一个介绍屏幕、一个游戏结束屏幕、一个移动的星系背景、有趣的演员动画、得分、升级和降级。*图4*显示了游戏的一个截图。
- en: '![Avoider Game recap](img/image00295.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![避免者游戏回顾](img/image00295.jpeg)'
- en: 'Figure 4: This is a snapshot of our version of Avoider Game'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：这是我们版本避免者游戏的一个快照
- en: In the next several sections, we will augment this version of Avoider Game.
    Our changes will be based on the game design principles we just finished studying.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个部分中，我们将增强这个版本的避免者游戏。我们的改变将基于我们刚刚研究过的游戏设计原则。
- en: High-score list
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高分排行榜
- en: 'The first change we are going to make is to add a simple mechanism to record
    the highest score. We will then display this score on the game-over screen, so
    that players can see where they stand compared with each other. By adding a high
    score, we are clearly identifying the main goal of the game—score the most points.
    To add a high score, make the following changes to the `AvoiderGameOverWorld`
    class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第一个改变是添加一个简单的机制来记录最高分。然后我们将把这个分数显示在游戏结束屏幕上，这样玩家就可以看到他们与其他玩家的相对位置。通过添加高分，我们清楚地确定了游戏的主要目标——得分最高。要添加高分，需要对`AvoiderGameOverWorld`类进行以下更改：
- en: '[PRE0]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The constructor and the `act()` method did not change. We added two new methods:
    `setPlayerHighScore()` and `recordAndReturnHighScore()`. The `setPlayerHighScore()`
    method is public and will be called by `AvoiderWorld` to pass the current player''s
    score, in the form of `String`, to the game-over screen. Due to functional decomposition,
    this method is fairly simple. It creates two `Label` objects to display the player''s
    score and the high score and then adds these objects to the current world, which
    is `AvoiderGameOverWorld`. The `Label` class is new and provides a way to easily
    create text-based images. We will look at the code for it shortly. First, we will
    look more closely at the `recordAndReturnHighScore()` method, which contains the
    functionality to retrieve and set the high score.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数和 `act()` 方法没有改变。我们添加了两个新的方法：`setPlayerHighScore()` 和 `recordAndReturnHighScore()`。`setPlayerHighScore()`
    方法是公开的，将由 `AvoiderWorld` 调用，以 `String` 的形式传递当前玩家的分数到游戏结束屏幕。由于功能分解，这个方法相当简单。它创建了两个
    `Label` 对象来显示玩家的分数和最高分，然后将这些对象添加到当前世界，即 `AvoiderGameOverWorld`。`Label` 类是新的，提供了一种轻松创建基于文本的图像的方法。我们很快就会查看它的代码。首先，我们将更仔细地查看
    `recordAndReturnHighScore()` 方法，它包含检索和设置最高分的功能。
- en: Tip
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `java.nio.file` package requires that you have Java 1.7 or later installed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.nio.file` 包要求您安装 Java 1.7 或更高版本。'
- en: The `recordAndReturnHighScore()` method introduces file I/O. To make the high
    score persist whether you have Avoider Game open or not, we need to store the
    high score in a file. Files provide persistent storage. We can use some very simple
    file I/O operations because we are only storing or retrieving a single `String`.
    First, we make a call to the `Paths.get()` static function. This provides the
    location of the file. Next, we check to see whether the file already exists using
    the `Files.exists()` static function. If the file does not exist, we create and
    write to it the current player's score using `Files.write()`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`recordAndReturnHighScore()` 方法引入了文件 I/O。为了使最高分在您打开或关闭 Avoider Game 时都能持久保存，我们需要将最高分存储在文件中。文件提供持久存储。由于我们只存储或检索单个
    `String`，我们可以使用一些非常简单的文件 I/O 操作。首先，我们调用 `Paths.get()` 静态函数。这提供了文件的位置。接下来，我们使用
    `Files.exists()` 静态函数检查文件是否已存在。如果文件不存在，我们使用 `Files.write()` 创建并写入当前玩家的分数。'
- en: This function will create the file and write to it and then close the file before
    returning. If the file does exist, then we read its contents using `Files.readAllBytes()`
    which will open the file, read the contents of the file, close the file, and then
    return the data it read. The last thing we need to do in this method, is to see
    if the current player's score is larger than the current high score. If it is,
    we update the file. `recordAndReturnHighScore()` then returns the highest score,
    which will either be the value read from the file or the current player's score.
    Please note the additional `import` statements we added to access these new file
    I/O classes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将创建文件并写入它，然后在返回之前关闭文件。如果文件确实存在，我们将使用 `Files.readAllBytes()` 读取其内容，这将打开文件，读取文件内容，关闭文件，然后返回它读取的数据。在这个方法中，我们需要做的最后一件事是查看当前玩家的分数是否高于当前最高分。如果是，我们将更新文件。`recordAndReturnHighScore()`
    然后返回最高分，这将是读取自文件或当前玩家的分数。请注意我们添加的额外 `import` 语句，以便访问这些新的文件 I/O 类。
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Greenfoot provides another mechanism to store and maintain high-score lists
    that only work after you have shared your game/application on the Greenfoot site.
    To learn more about this, read the Greenfoot online documentation on the `UserInfo`
    class provided by Greenfoot. You can access that documentation at [http://www.greenfoot.org/files/javadoc/](http://www.greenfoot.org/files/javadoc/).
    To learn more about the Java file I/O, look at the tutorial at [http://docs.oracle.com/javase/tutorial/essential/io/index.html](http://docs.oracle.com/javase/tutorial/essential/io/index.html).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Greenfoot 提供了另一种机制来存储和维护仅在您在 Greenfoot 网站上共享了您的游戏/应用程序后才能工作的最高分列表。要了解更多信息，请阅读
    Greenfoot 在线文档中提供的 `UserInfo` 类。您可以在 [http://www.greenfoot.org/files/javadoc/](http://www.greenfoot.org/files/javadoc/)
    访问该文档。要了解更多关于 Java 文件 I/O 的信息，请查看 [http://docs.oracle.com/javase/tutorial/essential/io/index.html](http://docs.oracle.com/javase/tutorial/essential/io/index.html)
    上的教程。
- en: 'Now, we can look at the code for the `Label` class. The `Label` class is a
    new class we are going to create to help us add text to our game. Create a new
    subclass of `Actor` and call it `Label`. Do not associate an image with this class.
    We will also use this class later in this chapter. Here is the code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看`Label`类的代码。`Label`类是我们将要创建的一个新类，用来帮助我们向游戏中添加文本。创建一个新的`Actor`子类，命名为`Label`。不要将图像与这个类关联。我们也会在本章的后面使用这个类。以下是代码：
- en: '[PRE1]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This class is simple and only contains two constructors; the first one calls
    the second one with the default color, white. In the second constructor, `String`,
    which is supplied, is converted into an image using `GreenfootImage`, and then
    this image is set to be the default image for this instance of `Label`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类很简单，只包含两个构造函数；第一个构造函数使用默认颜色白色调用第二个构造函数。在第二个构造函数中，提供的`String`被`GreenfootImage`转换成图像，然后这个图像被设置为`Label`实例的默认图像。
- en: 'The last change that we need to make to get all this working, is add the code
    to `AvoiderWorld` to pass the player''s current score to `AvoiderGameOverWorld`.
    We only need to add one line to the `endGame()` method in `AvoiderWorld`. Here
    is the complete implementation of `endGame()`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让所有这些功能正常工作，我们需要做的最后一个更改是在`AvoiderWorld`中添加代码，将玩家的当前分数传递给`AvoiderGameOverWorld`。我们只需要在`AvoiderWorld`中的`endGame()`方法中添加一行代码。以下是`endGame()`的完整实现：
- en: '[PRE2]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After making this change, compile the game to find and fix any typos that happened
    along the way. Play it. What's your top score? *Figure 5* demonstrates what your
    game-over screen should now look like.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这些更改后，编译游戏以查找和修复在过程中发生的任何错误。玩玩看。你的最高分是多少？*图5*展示了你的游戏结束屏幕现在应该看起来是什么样子。
- en: '![High-score list](img/image00296.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![高分列表](img/image00296.jpeg)'
- en: 'Figure 5: The game-over screen with the current and high score added.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：添加了当前和最高分的游戏结束屏幕。
- en: Achievement badges
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成就徽章
- en: Many games and gamification strategies use the notion of an achievement badge.
    This is a badge you earn for accomplishing something difficult or something out
    of the ordinary. In games and interactive applications, they are a convenient
    and popular technique of giving players subgoals to complete, conditioning their
    behavior, and adding complexity of choice. We will add achievement badges to accomplish
    all of those things in our version of Avoider Game.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 许多游戏和游戏化策略都使用了成就徽章的概念。这是你完成困难或非同寻常的事情后获得的徽章。在游戏和交互式应用程序中，它们是给玩家设定子目标以完成、调节他们的行为和增加选择复杂性的便捷且受欢迎的技术。我们将在我们的Avoider游戏版本中添加成就徽章来实现所有这些功能。
- en: 'First, we need to come up with a list of achievements. In practice, coming
    up with the right mix of achievements will take some careful thought, time, and
    playtesting. Here is the list of achievements I came up with:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要想出一串成就列表。在实践中，想出正确的成就组合需要一些仔细的思考、时间和测试。以下是我想出的成就列表：
- en: '**Magically Delicious**: The player has to hit 20 clovers.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**神奇美味**：玩家必须击中20片三叶草。'
- en: This achievement adds complexity to the choices available to the player on a
    moment-to-moment basis. Do they dare risk collecting another clover and suffer
    the slow-down penalty?
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个成就增加了玩家在每一刻可用的选择复杂性。他们敢冒险收集另一片三叶草并承受减速惩罚吗？
- en: '**Turkey**: The player must collect three rocks in a row. The user cannot touch
    any other object during this time.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**火鸡**：玩家必须连续收集三个岩石。在这段时间内，用户不能触碰任何其他对象。'
- en: This achievement conditions the player to go after rocks even when they are
    at full health.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个成就条件使玩家即使在满血状态下也会去追击岩石。
- en: '**Unbreakable**: The player has to touch an enemy 10 times.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可破坏**：玩家必须触摸敌人10次。'
- en: This achievement adds to the complexity of choices available to the user and
    serves as a means to increase the challenge during certain slow parts of the game.
    In the game, you come across small periods of time where you are at full health
    and there is no immediate danger of being hit by an enemy. During these periods,
    the player could now choose to take a few hits to increase the number of **Unbreakable**
    badges they get.
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个成就增加了用户可用的选择复杂性，并在游戏的某些缓慢部分作为增加挑战的手段。在游戏中，你会遇到一些小段时间，你处于满血状态，没有立即被敌人击中的危险。在这些时期，玩家现在可以选择承受几次打击，以增加他们获得的**不可破坏**徽章数量。
- en: '**Master Avoider**: The player finishes a game before hitting three cupcakes
    in total.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大师躲避者**：玩家在总共击中三个纸杯蛋糕之前完成游戏。'
- en: This achievement reinforces the behavior that we want. We want the player to
    avoid cupcakes at all costs.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个成就强化了我们希望的行为。我们希望玩家不惜一切代价避免纸杯蛋糕。
- en: These achievements also serve as potential subgoals for the user. We will display
    the badges the player has earned on the game-over screen right next to the main
    goal—their score.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些成就也作为用户的潜在子目标。我们将在游戏结束屏幕上显示玩家获得的徽章，紧挨着主要目标——他们的分数。
- en: The first issue to consider when implementing achievement badges is that, the
    data needed to determine whether a badge was earned. In our case, this data is
    distributed between the `PowerItems` subclasses and `Avatar`. Also, the `AvoiderGameOverWorld`
    class will have to know which badges were earned, so that they can be displayed
    on the game-over screen. We would like to have a central location to collect this
    information. Because we need distributed access to a single class, we are going
    to use the **Singleton** design pattern.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现成就徽章时需要考虑的第一个问题是，确定是否获得徽章所需的数据。在我们的案例中，这些数据分布在`PowerItems`子类和`Avatar`之间。此外，`AvoiderGameOverWorld`类将需要知道哪些徽章被获得，以便它们可以在游戏结束屏幕上显示。我们希望有一个中心位置来收集这些信息。因为我们需要分布式访问单个类，我们将使用**单例**设计模式。
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Design patterns**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计模式**'
- en: As you become more experienced in programming, you are going to recognize common
    patterns of coding that emerge in your work. Perhaps in the next game you create,
    you will also want achievements and think to yourself, "I can just reuse my design
    of achievements from my version of Avoider Game." In essence, you have a very
    small, personal design pattern that you can use to create achievements that you
    can improve upon over time.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对编程的熟练程度提高，你将在工作中认识到常见的编码模式。也许在你创建的下一个游戏中，你也会想要成就，并想，“我可以直接重用我在Avoider游戏版本中的成就设计。”本质上，你有一个非常小、个人的设计模式，你可以用它来创建可以随着时间的推移不断改进的成就。
- en: Developers have created very useful design patterns since the inception of programming,
    that apply to many different types of applications. Design patterns provide a
    proven, tested method for coding certain functionality that you can easily adapt
    for your own uses.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 自编程诞生以来，开发者们就创造了许多非常有用的设计模式，这些模式适用于许多不同类型的应用程序。设计模式提供了一种经过验证、测试的方法来编码某些功能，你可以轻松地将其适应自己的用途。
- en: Design patterns are also very useful to study. By examining them, you can see
    how some of the best programmers use abstraction to solve complex, recurring issues.
    They also serve as a concise language that developers can use to effectively communicate
    with each other. It is far more convenient to say that the `BadgeCenter` class
    in Avoider Game implements the Singleton design pattern rather than trying to
    describe it from scratch.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式也非常有用去研究。通过研究它们，你可以看到一些最好的程序员如何使用抽象来解决复杂、重复的问题。它们还作为开发者之间有效沟通的简洁语言。说Avoider游戏中的`BadgeCenter`类实现了单例设计模式，比从头描述它要方便得多。
- en: 'There are a lot of books published on design patterns, but the most famous
    and popular one is Design Patterns: Elements of Reusable Object-Oriented Software
    by *Gamma et al*. At some point in your development career, you should read it.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设计模式的书籍出版了很多，但最著名和最受欢迎的是由*Gamma等人*撰写的《设计模式：可复用面向对象软件元素》。在你的开发生涯的某个阶段，你应该阅读这本书。
- en: To keep track of player achievements, we are going to create a class called
    `BadgeCenter` that follows the Singleton design pattern. This new class will not
    be a subclass of `World` or `Actor`. To create it, click on **Edit** in the menu
    bar and then choose **New Class**. You should see the pop-up window shown in *Figure
    6*. Type in `BadgeCenter` and press *Enter*. We are now ready to add the code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪玩家的成就，我们将创建一个名为`BadgeCenter`的类，该类遵循单例设计模式。这个新类将不是`World`或`Actor`的子类。要创建它，请点击菜单栏中的**编辑**，然后选择**新建类**。你应该会看到*图6*中显示的弹出窗口。输入`BadgeCenter`并按*Enter*键。我们现在准备好添加代码。
- en: '![Achievement badges](img/image00297.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![成就徽章](img/image00297.jpeg)'
- en: 'Figure 6: This is the popup window used to create a class that is not a subclass
    of Actor or World'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：这是用于创建不是Actor或World子类的类的弹出窗口
- en: 'Here is the code for this class:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个类的代码：
- en: '[PRE3]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Following the Singleton design pattern, we create a constructor that is `private`
    and provide a `static` method called `getInstance()` to manage access to the single
    instance of this class. Since `getInstance()` is `static`, all of our classes
    in our version of Avoider Game will have access to it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 按照单例设计模式，我们创建了一个`private`的构造函数，并提供了一个名为`getInstance()`的`static`方法来管理对这个类单例实例的访问。由于`getInstance()`是`static`的，所以我们的Avoider
    Game版本中的所有类都可以访问它。
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In practice, you should try and minimize your use of the keyword `static`. While
    it is very useful in several cases, abusing it can lead to poor design and hard-to-maintain
    code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，您应该尽量减少使用关键字`static`。虽然它在许多情况下非常有用，但过度使用它可能导致设计不佳和难以维护的代码。
- en: 'To collect all the data we need, we have four methods: `hitClover()`, `hitRock()`,
    `hitEnemy()`, and `hitCupcake()`. These methods will be called by the `Clover`,
    `Rock`, `Avatar`, and `Cupcake` classes, respectively, to report collisions. Each
    method tracks the number of hits, sets the `previous` variable, and then determines
    if a badge should be awarded. For example, `hitClover()` first increments the
    variable `clovers` and then sets `previous` to `Clover`. The method then checks
    to see if we have just hit another 20 clovers. If so, we award a badge using the
    `awardBadge()` method. If we hit over 80 clovers, we issue the grand prize—a *Magically
    Delicious* badge.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了收集我们所需的所有数据，我们有四个方法：`hitClover()`、`hitRock()`、`hitEnemy()`和`hitCupcake()`。这些方法将由`Clover`、`Rock`、`Avatar`和`Cupcake`类分别调用，以报告碰撞。每个方法跟踪击中次数，设置`previous`变量，然后确定是否应该颁发徽章。例如，`hitClover()`首先增加变量`clovers`，然后将`previous`设置为`Clover`。该方法然后检查我们是否刚刚击中了另一个20个三叶草。如果是这样，我们使用`awardBadge()`方法颁发徽章。如果我们击中了80多个三叶草，我们将颁发大奖——一个*神奇美味*徽章。
- en: The `awardBadge()` method is used to record badges. It takes `String` that will
    be used as the title of the achievement, creates `Badge` anew, and then stores
    that badge in an array. The array will later be accessed using `getBadges()` by
    `AvoiderGameOverWorld`. The `getBadges()` method has a few duties other than returning
    the array of badges achieved until now. It looks at values maintained by `hitCupcakes()`
    and `hitRock()` and determines whether additional badges should be awarded. If
    you did not know, the term, *turkey*, comes from bowling and means you just got
    three strikes in a row.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`awardBadge()`方法用于记录徽章。它接受一个`String`，该字符串将用作成就的标题，创建一个新的`Badge`，然后将该徽章存储在数组中。稍后，`AvoiderGameOverWorld`将通过`getBadges()`方法访问这个数组。`getBadges()`方法除了返回到目前为止获得的徽章数组外，还有其他一些职责。它查看`hitCupcakes()`和`hitRock()`维护的值，并确定是否应该颁发额外的徽章。如果您不知道，术语*turkey*来自保龄球，意味着您连续击中了三次。'
- en: 'Here is the code we need to add to the constructor of `AvoiderGameOverWorld`,
    in order to display the badges on the game-over screen:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们需要添加到`AvoiderGameOverWorld`构造函数中的代码，以便在游戏结束屏幕上显示徽章：
- en: '[PRE4]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the constructor, we use `BadgeCenter.getInstance()` to get access to the
    single instance of `BadgeCenter` and then immediately invoke `getBadges()`. We
    then iterate over `badgeList` (we discussed the `List` interface in [Chapter 3](part0024.xhtml
    "Chapter 3. Collision Detection"), *Collision Detection*) and add each `Badge`
    to the world. We use the variable `yPos` to appropriately space out the badges.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们使用`BadgeCenter.getInstance()`来获取对`BadgeCenter`单例实例的访问，然后立即调用`getBadges()`。然后我们遍历`badgeList`（我们在[第3章](part0024.xhtml
    "第3章。碰撞检测")中讨论了`List`接口，*碰撞检测*）并将每个`Badge`添加到世界中。我们使用变量`yPos`来适当地分隔徽章。
- en: 'Because we use the `List` interface, we need to add the following `import`
    statement to `AvoiderGameOverWorld`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了`List`接口，我们需要将以下`import`语句添加到`AvoiderGameOverWorld`中：
- en: '[PRE5]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Last, we need to define the `Badge` class. It is a simple class that adds a
    text string onto an image for a badge. *Figure 7* shows the image I created for
    badges. I tried to make it look like a tombstone.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要定义`Badge`类。这是一个简单的类，它将文本字符串添加到徽章的图像上。*图7*显示了我为徽章创建的图像。我尽量让它看起来像一块墓碑。
- en: '![Achievement badges](img/image00298.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![成就徽章](img/image00298.jpeg)'
- en: 'Figure 7: This is the image associated with the Badge class.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：这是与`Badge`类相关的图像。
- en: 'Create a new subclass of `Actor` and call it `Badge`. Assign the new image
    you created for badges or use mine. Add this code to it:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`Actor`子类，命名为`Badge`。分配您为徽章创建的新图像或使用我的。将以下代码添加到其中：
- en: '[PRE6]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have already discussed the `Color` and `GreenfootImage` classes in the earlier
    chapters. The constructor uses the `drawImage()` method of `GreenfootImage` to
    draw one image on top of another. By doing this, we effectively add the text.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在前面章节中讨论了`Color`和`GreenfootImage`类。构造函数使用`GreenfootImage`的`drawImage()`方法在另一个图像上绘制一个图像。通过这样做，我们有效地添加了文本。
- en: Compile the code, debug any mistakes, and try it out. What badges did you earn?
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 编译代码，调试任何错误，并尝试运行。你获得了哪些徽章？
- en: Player conditioning
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家条件
- en: I would like to provide you with an example where some user conditioning I added
    to the game had to be removed as I determined, after playtesting, that it drove
    the wrong behavior. Initially, I thought of changing the game to provide 10 points
    for each clover you hit. This would help to increase the complexity of the game,
    as players would have to balance getting more points against the slowdown penalty
    of clovers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我想给你提供一个例子，其中我添加到游戏中的某些用户条件在游戏测试后必须被移除，因为我确定它导致了错误的行为。最初，我想将游戏改为每次击中三叶草得10分。这将有助于增加游戏的复杂性，因为玩家必须平衡获得更多分数与三叶草的减速惩罚。
- en: However, this change really had an effect on the player. Because clovers are
    so plentiful and worth 10 points, it really became worthwhile to collect clovers
    as a means of getting high scores. This changed the whole feel of the game from
    one that encourages avoiding to one that encourages collecting. Therefore, the
    change was removed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个改变确实对玩家产生了影响。因为三叶草非常多，价值10分，所以收集三叶草作为一种获得高分的方式变得非常有价值。这改变了游戏的整体感觉，从鼓励避免转变为鼓励收集。因此，这个改变被移除了。
- en: In addition, adding points to clovers broke some of the story elements of the
    game. In the game, things that look good are bad. But, by having a good item provide
    a direct benefit to the player, we broke our game's theme. Next, we will discuss
    theming and storytelling in Avoider Game.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，给三叶草加分破坏了游戏的一些故事元素。在游戏中，看起来好的东西是坏的。但是，通过让一个好的物品为玩家提供直接的好处，我们破坏了游戏的主题。接下来，我们将讨论避免者游戏的主题和讲故事。
- en: Storytelling
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讲故事
- en: It is hard to build a deep, meaningful story for a game like ours. However,
    the player will still try to make sense of the world we threw them in, and we
    need to do as much as we can to help the player construct a meaningful world.
    Our story should motivate why we flee from smiley faces and cupcakes and welcome
    rocks.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为像我们这样的游戏构建一个深刻、有意义的故事是困难的。然而，玩家仍然会试图理解我们扔给他们的世界，我们需要尽我们所能帮助玩家构建一个有意义的世界。我们的故事应该激励我们为什么逃离笑脸和纸杯蛋糕，而欢迎岩石。
- en: Adding a story screen
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加故事屏幕
- en: To help tell the story of our game, we are going to create a story screen the
    player can choose to view before playing the game. This screen will provide the
    background and context for our game, as well as set up its theme. While we are
    at it, we are going to add a credits screen. Adding comments to your code to credit
    artists and developers is a good start, but eventually you will need to formally
    recognize these people. Plus, you can give the person who worked hardest on this
    game credit—you!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助讲述我们游戏的故事，我们将创建一个玩家可以选择在玩游戏之前查看的故事屏幕。这个屏幕将提供我们游戏的背景和上下文，以及设定其主题。在此期间，我们还将添加一个信用屏幕。在代码中添加注释以感谢艺术家和开发者是一个好的开始，但最终您需要正式认可这些人。此外，您可以给在这款游戏上工作最努力的人以认可——那就是你！
- en: 'First, we are going to add some buttons to our introduction screen that, when
    clicked, will either take you to the story screen, take you to the credits screen,
    or start the game. Here are the changes we need to make to `AvoiderGameIntroScreen`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在介绍屏幕上添加一些按钮，点击这些按钮将带您进入故事屏幕、信用屏幕或开始游戏。以下是我们需要对`AvoiderGameIntroScreen`进行的更改：
- en: '[PRE7]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The constructor function creates three buttons using the `addButton()` method.
    In the `act()` method, we simply listen for mouse clicks on those buttons and
    switch worlds appropriately if we get one. We covered all of this in [Chapter
    1](part0014.xhtml "Chapter 1. Let's Dive Right in…"), *Let's Dive Right in…*,
    except for the implementation of `addButton()`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数使用`addButton()`方法创建三个按钮。在`act()`方法中，我们只是监听鼠标点击这些按钮，并在收到点击时相应地切换世界。我们已经在[第1章](part0014.xhtml
    "第1章。让我们直接进入…")中涵盖了所有这些内容，*让我们直接进入…*，除了`addButton()`的实现。
- en: The method `addButton()` creates a new `Label` and adds it to the screen. We
    discussed the `Label` class earlier in the chapter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`addButton()`方法创建一个新的`Label`并将其添加到屏幕上。我们在本章前面讨论了`Label`类。'
- en: After running this code, your introduction screen will look like the one shown
    in *Figure 8*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码后，你的介绍屏幕将看起来像*图8*中所示的那样。
- en: '![Adding a story screen](img/image00299.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![添加故事屏幕](img/image00299.jpeg)'
- en: 'Figure 8: This is the revised introduction screen to our version of Avoider
    Game'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：这是我们版本Avoider游戏的修订版介绍屏幕
- en: Now, we just need to make the story screen (`AvoiderGameStoryScreen`) and the
    credits screen (`AvoiderGameCreditScreen`). You already learned how to do this
    (refer to [Chapter 1](part0014.xhtml "Chapter 1. Let's Dive Right in…"), *Let's
    Dive Right in…*), and I will just show you what my screens look like in *Figure
    9* and *Figure 10*. Feel free to use mine or make your own.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要制作故事屏幕（`AvoiderGameStoryScreen`）和信用屏幕（`AvoiderGameCreditScreen`）。你已经学到了如何做这件事（参考[第1章](part0014.xhtml
    "第1章。让我们直接进入…")，*让我们直接进入…*），我只会向你展示我的屏幕在*图9*和*图10*中的样子。你可以自由使用我的或者自己制作。
- en: '![Adding a story screen](img/image00300.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![添加故事屏幕](img/image00300.jpeg)'
- en: 'Figure 9: This is how our story screen will look'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图9：这是我们故事屏幕的显示效果
- en: This is how the credits screen looks.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是信用屏幕的显示效果。
- en: '![Adding a story screen](img/image00301.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![添加故事屏幕](img/image00301.jpeg)'
- en: 'Figure 10: This is how the credits screen looks'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图10：这是信用屏幕的显示效果
- en: Changing the score
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改变分数
- en: Getting points in the game is a good thing; therefore, our score indicator should
    look like a bad thing. Right now, it is neutral and does not contribute to the
    story or theme of the game. Let's change this narrative descriptor.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中获得分数是好事；因此，我们的分数指示器应该看起来像坏事。目前，它是中性的，并不有助于游戏的故事或主题。让我们改变这个叙述描述符。
- en: Presently, we are using the imported `Counter` class. To get a customized look
    for our score, we are going to need to create our own class and not rely on the
    `Counter` class. Create a new subclass of `Actor` and name it `Score`. Because
    points and badges are types of awards, I thought making them both tombstones made
    sense. *Figure 11* shows the image I used for the new `Score` actor. It is a smaller
    version of the tombstone used for achievement badges with the **Achievement Badge**
    text replaced with **R.I.P.**.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在使用导入的`Counter`类。为了使我们的分数看起来更定制化，我们需要创建自己的类，而不是依赖于`Counter`类。创建一个新的`Actor`子类，命名为`Score`。因为分数和徽章都是奖励的类型，我觉得将它们都做成墓碑是有意义的。*图11*显示了用于新`Score`演员的图像。它是用于成就徽章的墓碑的小版本，将**成就徽章**文本替换为**R.I.P**。
- en: '![Changing the score](img/image00302.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![改变分数](img/image00302.jpeg)'
- en: 'Figure 11: This is the image for our new Score class.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图11：这是我们新`Score`类的图像。
- en: 'Here is the code for the `Score` class:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Score`类的代码：
- en: '[PRE8]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This class stores the current score in the `counter` integer variable. You can
    increase the score by calling `addScore()` and retrieve the current score by calling
    `getScore()`. The `Score` class works by adding an image that contains the current
    score over the default image, which is a tombstone. Whenever the score changes,
    the `counter` variable is incremented and then `updateImage()` is called. The
    `updateImage()` method removes the old object containing the image of the score
    and then creates a new image based on the current value of `counter` using the
    `Label` class (as discussed previously). The `addedToWorld()` method is needed
    to display the initial score of 0.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将当前分数存储在`counter`整型变量中。你可以通过调用`addScore()`来增加分数，通过调用`getScore()`来获取当前分数。`Score`类通过在默认图像（墓碑）上添加包含当前分数的图像来工作。每当分数改变时，`counter`变量会增加，然后调用`updateImage()`。`updateImage()`方法会移除包含分数图像的旧对象，然后根据`counter`的当前值使用`Label`类（如前所述）创建一个新的图像。`addedToWorld()`方法用于显示初始分数0。
- en: We have made several changes. Make sure to compile and run your game to ensure
    that everything works properly.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做了几项更改。请确保编译并运行你的游戏，以确保一切正常工作。
- en: Adding sound effects
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加音效
- en: Sound effects can provide important and valuable feedback to players. Also,
    they can be important narrative descriptors. In this section, we are going to
    add some sound effects to both enhance meaningful play and the story of the game.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 音效可以为玩家提供重要且有价值的反馈。它们还可以作为重要的叙述描述符。在本节中，我们将添加一些音效，以增强有意义的游戏玩法和游戏故事。
- en: Because cupcakes, clovers, and rocks have a random, limited lifespan, it can
    be confusing to know whether you hit one or it just expired right before touching
    you. If you were at full health already, you have no idea whether you hit a rock
    or not. If you do not move, you cannot tell whether you really hit a cupcake or
    clover. We are going to solve this ambiguity by playing a sound whenever you collide
    with any `PowerItems`. This will also help players who are actively trying to
    gain achievement badges.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: We will choose sounds appropriate for our game's story. If the player collides
    with a cupcake or clover, then we will play the sound of you saying, *Woot!*.
    If you, the player, collide with a rock, then we will play the sound of you saying,
    *Ahhh!*. This fits with the theme of the game.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: You could play any sound effect you find on the Internet (assuming it is free
    for such use) or create your own using various audio editing programs. Fortunately,
    Greenfoot comes with a built-in audio recording and editing tool. To access it,
    click on **Controls** in the main menu and then choose **Show Sound Recorder**.
    You should see the window shown in *Figure 12*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding sound effects](img/image00303.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12: This is the sound recorder tool in Greenfoot'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Using Greenfoot's sound recorder, record yourself saying *ahhh* and save it
    as `ahhh.wav`. Then, record yourself saying *woot* and save it as `woot.wav`.
    To make your recordings as concise as possible, you can use the **Trim to selection**
    button to eliminate any beginning or ending silence or unnecessary noises.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to add two methods to the `Avatar` class to play these sounds.
    Here is the first method:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is the second method:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We create two instance variables, `woot` and `ahhh`, at the top of the `Avatar`
    class:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Initialize them in the `AddedToWorld()` method. Here is this initialization
    code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have now set up `Avatar` to say *ahhh* or *woot!*. We just need to change
    `PowerItems` to call either of the two methods we just added to the `Avatar` class.
    In the `Cupcake` class, change `checkHitAvatar()` to this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the `Clover` class, we need to change `checkHitAvatar()` to this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `Health` class, we need to change `checkHitAvatar()` to this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Compile your game and play. Enjoy all of the *wooting* and *ahhhing*!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Playtesting
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Playtest your game and see if you think the game needs any changes. After playing
    for a while, I decided to change the `increaseLevel()` method in `AvoiderWorld`
    to this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: I felt that there were not enough enemies on screen and that the `Health` power-ups
    were too frequent after the player had increased several levels. To help with
    this, I increased the rate of change to the `enemySpawnRate` variable to `4` and
    reduced the rate of increase to the `healthFrequency` variable to `1`. With these
    changes, the game play felt better. Do you agree with my changes? What changes
    do you feel improve the game? Of course, the way to best determine the appropriate
    values for these variables is to recruit more playtesters.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to [http://en.wikipedia.org/wiki/Balance_(game_design)](http://en.wikipedia.org/wiki/Balance_(game_design))
    for more information on game balance.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We added some nice features to our version of Avoider Game. Of course, it seems
    there are endless cool things we could try to implement in order to improve our
    game. As a programming challenge, let's try one more. Change the game, so that
    players are awarded bonus points for each achievement badge they get. This change
    will further encourage the users to attempt the achievements. This also potentially
    enhances long-term meaningful play. How many points are you going to assign for
    each badge? Will each badge be worth the same amount of points? How does this
    affect game play? Is this a change you would keep?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Let's spruce up our introduction screen. Add background music and play a *click*
    sound when the player clicks on a menu choice. Providing auditory feedback to
    player actions enhances those interactions.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Additional readings
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good portion of my philosophy of game design came from many years of teaching
    game development and two key textbooks. The first textbook is *Rules of Play*
    by Eric Zimmerman and Katie Salen, published in 2003\. This book provides an in-depth
    and thorough coverage of games, game history, and game design. The other book
    that heavily influenced me was *Half-real* by Jesper Juul, published in 2005\.
    This book offers a more concise study of game design. If you have a passion for
    game design, I highly recommend that you read these two books.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating meaningful play is the main goal for game designers. In this chapter,
    we defined meaningful play and learned many game design techniques for enhancing
    meaningful play. We also learned a process for creating interactive applications
    that will guide you in creating engaging applications. As you read the rest of
    this book, and eventually create your own applications, you should reflect on
    this chapter and apply the techniques provided.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn to create worlds for our games that expand
    far beyond the edges of the screen.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
