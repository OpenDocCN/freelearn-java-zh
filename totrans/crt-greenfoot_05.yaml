- en: Chapter 5. Interactive Application Design and Theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"If you never did, you should. These things are fun and fun is good."*
    |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Dr. Suess* |'
  prefs: []
  type: TYPE_TB
- en: 'Creating engaging and immersive experiences in Greenfoot is far more involving
    than compiling a collection of programming effects into one application. In this
    chapter, you will learn how to engage your user by understanding the relationship
    between user choice and outcome, conditioning the user, and including the right
    level of complexity into your work. You will be shown a proven iterative development
    process that will help you put theory into practice. The topics that will be covered
    in the chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Meaningful play
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choice, action, and outcomes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Complexity
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Goals
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: User conditioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storytelling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fictional worlds
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Narrative descriptors
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive entertainment iterative development process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we discuss the topics of this chapter, we will refer to the Avoider game
    we created in [Chapter 1](part0014.xhtml "Chapter 1. Let's Dive Right in…"), *Let's
    Dive Right in…* and [Chapter 2](part0017.xhtml "Chapter 2. Animation"), *Animation*.
    We will discuss items already implemented in the game to illustrate interactive
    design concepts and demonstrate other concepts by adding new features. In this
    chapter, we are discussing methods to engineer fun. That might sound strange,
    but creating fun is the main goal of the designers of games and other forms of
    interactive entertainment. And, as Dr. Suess so elegantly puts it, "These things
    are fun and fun is good."
  prefs: []
  type: TYPE_NORMAL
- en: Meaningful play
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning to create experiences that are meaningful to users is the most important
    skill needed by developers of interactive applications. It is the meaning of the
    interaction that drives players to invest time and energy in playing your application.
    We want to invoke feelings of happiness, anger, pride, relief, caring, astonishment,
    surprise, elation, or satisfaction in our users. To do this, *we need to provide
    immediate and long-term feedback to difficult choices and actions taken by the
    user*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a few clarifying examples that might take place in a role-playing
    game (RPG). Imagine that you are a wizard wondering through a forest-covered mountain
    when you come upon a cave. Peeking into the cave, you see in the dim light a sleeping
    dragon surrounded by treasure. The following are some possible interactions that
    could take place. We will discuss each, and determine if it created meaningful
    play.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario 1**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User choice**: You look through your spell book and decide to cast the spell
    *Fireball*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User action**: You cast the spell on the dragon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System feedback/outcome**: The fireball hits the dragon. Nothing happens
    afterwards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What!?!?? Did your spell fail? Is the game broken? Does the dragon have an aura
    of anti-magic? Did you actually miss? We get absolutely no meaning from this interaction.
    The player is left confused and disengaged. Let's look at another scenario.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario 2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User choice**: You look through your spell book and decide to cast the spell
    *Fireball*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User action**: You cast the spell on the dragon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System feedback/outcome**: The fireball hits the dragon. The dragon laughs
    and says, "Puny mortal. Go immediately, and I will let you live."'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The meaning is perfectly clear here. You have little power and you have no chance
    against a creature as strong as a dragon. You could choose to talk to the dragon,
    but he has indicated extreme annoyance at your presence. Are you going to press
    your luck or flee? Maybe one day, you'll grow strong enough to come back and take
    that treasure from this dragon. For now, you might be feeling lucky, inspired
    to be better, frightened, or frustrated at your lack of progress. However, you
    are feeling something and the interaction definitely had meaning.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario 3**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User choice**: You look through your spell book and decide to cast the spell
    *Fireball*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User action**: You cast the spell on the dragon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System feedback/outcome**: The fireball hits the dragon. The dragon screams
    in agony before disintegrating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ah, it is time to collect your loot. You marvel at your supreme power. Perhaps
    you should have allowed the dragon one chance to flee? Nah, it probably would
    not have done that for you. This interaction re-affirms your greatness.
  prefs: []
  type: TYPE_NORMAL
- en: The key to creating engaging applications is producing meaningful interactions
    on a moment-to-moment basis with the user. If a choice and action do not have
    a meaningful outcome, then why bother your users with it? *Every interaction in
    your interactive applications needs to be meaningful.* This is what Salen and
    Zimmerman refer to as *descriptive meaningful play* in their book, *Rules of Play*.
  prefs: []
  type: TYPE_NORMAL
- en: Another very important aspect to your application is the long-term outcome of
    a user's action. For example, in Scenario 3, the player could be referred to as
    Dragon Slayer, later in the game. The fine items purchased with the loot should
    be useful later in the game. *The outcomes of actions need to persist in the game*.
    Salen and Zimmerman refer to this as *evaluative meaningful play*.
  prefs: []
  type: TYPE_NORMAL
- en: Meaningful play is not only for games. The same thought process should be used
    to design any application. For example, if a user clicks on an item on an e-commerce
    site that they are interested in purchasing, there should be immediate visual
    feedback, such as the shopping cart icon displaying a 1 instead of a 0 or, going
    even further, the sound of a cheering crowd playing for a couple of seconds. If
    a user types in a word processing document, the word processing application should
    highlight the Save icon or put an asterisk by the filename to indicate that there
    are unsaved changes. If a person is taking a survey, there should a progress meter
    to let them know how many questions they have left to answer. Perhaps you could
    offer words of encouragement every time the user completes five survey questions.
  prefs: []
  type: TYPE_NORMAL
- en: Complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a really funny game that demonstrates what a game plays like when the
    player's choices are overly simplistic. It is called *Super PSTW Action RPG*.
    In this RPG, you only have one control—the spacebar. For every given situation,
    you simply hit the spacebar. If you haven't guessed, the PSTW in the title stands
    for **Press Space To Win**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, this game is a joke, but it is also an interesting experiment in
    game design. There is no meaningful play in the game, because the choice and action
    a player has to take is trivial. The actions and outcomes are well designed, but
    that is insufficient. Without complexity of choice, there is no meaningful play.
    We don''t have to go to such an extreme example to demonstrate this point. Have
    you ever played the card game War? If not, you can quickly review the rules here:
    [http://en.wikipedia.org/wiki/War_(card_game)](http://en.wikipedia.org/wiki/War_(card_game)).
    This game also has no meaningful play. Throughout the game, the player either
    flips a card over or places three cards face down and then flips a card over.
    The current game state completely informs the player of which action they should
    take. There are no tradeoffs to consider and no risk analysis to be done. It is
    all mechanical play. For most players older than 10 years, Tic-Tac-Toe suffers
    from the same lack of meaningful play.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For meaningful play to exist, the decisions a player makes should require sufficient
    mental effort. A player must have several options available to them and each option
    should involve different tradeoffs, risks, and rewards. For example, in our RPG
    scenarios above, the player might have the following choices available to them:
    cast Fireball, cast Lightning Strike, cast Charm Monster, talk, or flee. Perhaps
    the player has learned previously in the game, that charm spells rarely work on
    dragons and that certain dragons are immune to either fire or lightning. The player
    could choose to flee. This is a low-reward, low-risk option.'
  prefs: []
  type: TYPE_NORMAL
- en: When a player is making non-trivial decisions, taking action, and is provided
    with clear feedback, then the game becomes meaningful. When making decisions in
    an interactive application or game, the player needs to know what the goals of
    the interaction are. Is it to create custom pieces of music, become the most powerful
    wizard, or get the best deals on an e-commerce site? Setting up user goals is
    the next most important aspect of creating engaging applications.
  prefs: []
  type: TYPE_NORMAL
- en: Goals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Goals provide the players the means to assess their decisions in their moment-to-moment
    and long-term interactions with your application. After each interaction, the
    user can ask, "Did my last choice and action bring me closer to completing my
    goal?" With this type of ongoing assessment, users can augment and optimize their
    decision processes, in order to more quickly achieve their goals. In essence,
    the players use goals as guides to learning optimal ways to interact with your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: In writing an interactive application, you must set up clear goals and subgoals
    for your users. This is why high-score lists are so popular in many games. The
    simple fact of having one provides the goal of the game—score as many points as
    possible. As people play your game, they will constantly judge if their last course
    of action or long-term actions have led to the maximum amount of points. This
    enhances the meaningful play of the game.
  prefs: []
  type: TYPE_NORMAL
- en: In industry, companies will often try and gamify their applications or services.
    For example, the airline industry sets up programs to earn free flying miles.
    So, the customer is now engaged in making decisions that optimize their ability
    to gain free miles to earn a free airline flight. It often makes sense to establish
    subgoals to keep the customer invested along the way. If it takes a year or two
    to earn enough free flying miles, then the consumer could get discouraged. An
    airline might decide to offer intermediate goals, such as earning a free travel
    mug after achieving a certain, smaller amount of miles. Subgoals are very important
    to drive short-term behavior, as are rewards. We will talk further about methods
    of conditioning users next.
  prefs: []
  type: TYPE_NORMAL
- en: User conditioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In creating an interactive application or game, we want the user experience
    to be the best it can be. In creating meaningful play, we have given the user
    a rich set of options to choose from, and their path through the game has many
    possible states and outcomes. As the possible states and transitions in the game
    increase, it becomes harder as a game designer, to ensure that each path through
    the game states results in a positive interaction. We need to use user conditioning
    to help guide a user's behavior to interact with our application in predictable
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: The effect of conditioning was clearly demonstrated by Ivan Pavlov in an experiment
    involving a dog and food. In this experiment, Pavlov would ring a bell every time
    he fed his dog. Eventually, he could get the dog to drool by just ringing a bell.
    The dog learned to associate a neutral stimulus, like the bell, with food. While
    it seems weird to say we want to manipulate our users like this, it will help
    us to guide the user into the most favorable interactions with our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three methods we will use to condition our users:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Positive reinforcement**: Give the user a reward for doing the behavior we
    want.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Negative reinforcement**: Take away something negative when the user does
    the desired behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Punishment**: Take away something positive or add something negative when
    the users exhibit the wrong behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to treat our users with respect, and we want them to have a good time;
    therefore, positive reinforcement should be the way we condition our users the
    most. We want to give them rewards for doing the correct behavior. In a game,
    we might give them points, an extra life, an extra ability, or access to a new
    part of the game. Whether you are creating a game or an interactive application,
    you should have a set reward schedule for your users. Some rewards could be given
    frequently, such as earning points for disposing of an enemy, while other rewards
    could be more rare, such as giving the character the ability to fly.
  prefs: []
  type: TYPE_NORMAL
- en: Giving rewards allows us to tell the player which behaviors are favored in the
    game. If we wanted the user to get through an area as fast as possible, we could
    give a reward for doing it under 30 seconds. If we wanted the user to explore
    the controls and find fighting move combinations, we could give extra points whenever
    three fighting combinations are done in a row. If we wanted our users to pick
    flowers, we could provide a 0.001 percent chance to receive the most powerful
    item in the game every time a flower is picked. If we wanted a customer to buy
    coffee at a store more often, we could give them every twelfth drink free. Rewards
    are a powerful mechanism to condition users.
  prefs: []
  type: TYPE_NORMAL
- en: Negative reinforcement is less used but still a powerful tool to condition users.
    In the last paragraph, I mentioned that you could encourage your player to move
    fast through an area by giving them a reward for making it through in under 30
    seconds. Using negative reinforcement, we could drive the same behavior. Imagine
    that you are in very large room and the ceiling starts slowly moving down. You
    become aware that if you do not get out quickly, you will get squashed. By moving
    quickly to the other side of the room and leaving, you no longer have this pressure
    to move quick. This is negative reinforcement. Other examples of negative reinforcement
    include making the lighting dark in an area and playing creepy music, in order
    to encourage the player to get out of this area quickly (the game Bioshock is
    great at this), sounding a siren when the player is in a place they shouldn't
    be in, or blinking the screen until your health gets back to an acceptable level.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, punishment is a necessary component of game play, although not usually
    included in the gamification of a non-game application. There eventually have
    to be hard consequences for not meeting game objects. This could include subtracting
    points, subtracting money, losing a life, and eventually losing the game. Punishment
    is necessary because there has to be some risk associated with the choices a player
    makes, in order to achieve meaningful play. Just try not to be too hard on your
    users. The whole point of making a game is to provide an engaging, recreational
    activity.
  prefs: []
  type: TYPE_NORMAL
- en: Storytelling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Telling and appreciating stories has been engrained into our culture since the
    earliest times. We present stories in many different formats and mediums. They
    appear in oral traditions, the written word, theatre, cinema, and games. Games
    are one of the newest forms of storytelling but perhaps the most compelling for
    one simple reason—YOU are the main character of the story. In traditional methods
    of storytelling, the author must spend sufficient time building up a relatable
    character that the audience cares about. In games, you get this for free. You
    are the character.
  prefs: []
  type: TYPE_NORMAL
- en: Fictional worlds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In games, stories have an additional role other than just pure entertainment.
    The story creates a fictional world for the player of the game that helps guide
    their experience. It provides context for the actions and the motivation to achieve
    goals. Why are we killing these aliens in this game? Well, given that they just
    wiped out all of South America and are heading north, we know we need to stop
    their advance soon if the world is to stand a chance of surviving this invasion.
    If a game takes place in outer space, you expect to have spaceships, lasers, and
    aliens. There is a whole wealth of information given to your player by just telling
    them that the story takes place in the Old West, under water, or on a soccer field.
  prefs: []
  type: TYPE_NORMAL
- en: For any game, you should have a rich and complete story that covers what happens
    in your game's fictional world before the game is played, what happens to it during
    the game, and what happens afterwards—even if the user will never experience the
    before and after. Your fictional world and story not only provide context and
    motivation for the player, but they also serve as a guide to the game designer.
    As you add and subtract features from the game, as you go through the interactive
    entertainment development process (described in the section by the same name),
    you need to make sure you stay true to both.
  prefs: []
  type: TYPE_NORMAL
- en: Narrative descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everything in your game contributes to the story and your fictional world—the
    graphics on the box your game is shipped in, the manual, and the sounds and images
    in your game. You want your player to imagine a rich and vibrant world by providing
    appropriate and consistent narrative descriptors. Luckily, it does not take many
    prompts to get your user to imagine a complex world due to the principle of minimal
    departure. This principle states that people will use their knowledge of the world
    to fill in any missing gaps they see in an incomplete image. Take a few moments
    to look at *Figure 1*. What do you imagine lives in those mountains? Does this
    world have gravity? What else can you say about the world depicted in this figure?
    Whatever you come up with, you did so using the principle of minimal departure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Narrative descriptors](img/image00292.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: This is an example of the principle of minimal departure.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, take a look at *Figure 2*. What has been added to the picture? How does
    this change your perception of the world? What if I would have added a caveman
    instead of a robot?
  prefs: []
  type: TYPE_NORMAL
- en: '![Narrative descriptors](img/image00293.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: This shows the power of one narrative descriptor to completely change
    the fictional world'
  prefs: []
  type: TYPE_NORMAL
- en: Just as in a movie, everything that appears in your game or interactive application
    should perpetuate the story. For example, if you create an interactive history
    simulation of medieval times, then you should use a font that matches the time
    period and not use Courier New. If you have a game that takes place during World
    War I, then perhaps instead of showing a vanilla health bar for your player, you
    could show the picture of a soldier that looks more injured as you take more damage.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Disney**'
  prefs: []
  type: TYPE_NORMAL
- en: Disney provides great stories and is a master of using narrative descriptors.
    Have you ever been to Disneyland? I once had the privilege to be given a tour
    of Disneyland by Disney Imagineers and artists. The first thing that struck me,
    is how every employee of Disney recites the same mantra, "Story, story, story".
    I was surprised to find that on the tour my guides continually pointed out their
    use of narrative descriptors. In the different lands, they would show me how the
    concrete, plants, trash cans, and lighting all contributed to the story of the
    area. They knew that one item out of place could confuse or destroy the fictional
    worlds that their customers were imagining.
  prefs: []
  type: TYPE_NORMAL
- en: The interactive entertainment iterative development process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the design principles we have discussed thus far in this chapter will
    help you to create meaningful, engaging interactive applications. However, they
    are not enough. As you proceed with designing and building your game, you get
    to know the game deeply and lose your ability to be an unbiased judge of it. In
    addition, what you find fun and meaningful, could be confusing to others. You
    have to realize that if you have created a game with sufficient complexity, you
    will not be able to predict game play.
  prefs: []
  type: TYPE_NORMAL
- en: The only way to give your application the best chance of success, is to develop
    it using the interactive entertainment iterative development method shown in *Figure
    3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![The interactive entertainment iterative development process](img/image00294.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: This is the interactive entertainment iterative development process'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will talk about having an initial idea for a game and some upfront
    work you need to do to make an effective game pitch. In the gaming industry, game
    developers have to pitch their game and convince peers and management that this
    game is worth investing in. If you are working with a small team, you will still
    need to pitch the game to developers and artists that you want to recruit to work
    on your project. After talking about the upfront work, we will discuss each stage
    of the iterative design process in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Game pitch and initial design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, you have an idea and a desire to build a game. What should you do next?
    You need to create a clear and concise way to describe your game to others. You
    need to be able to describe the world you are creating, the story behind this
    world, the major goal of the game, and a rough draft of the game rules. Here is
    a detailed process for creating this information:'
  prefs: []
  type: TYPE_NORMAL
- en: In one paragraph, write a description of your game. Try to keep it to five sentences
    or less. Be clear, specific, and concise. As your game evolves over time, be sure
    to update this paragraph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the story of your game, including what happened before your game, what
    happens during your game, and what happens after your game. This will end up being
    a guide that all developers, designers, and artists will consult as they consider
    new features and assets for the game. Again, keep this document up-to-date.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In one sentence, state the game's goal. What is the player trying to achieve?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In one sentence, state how one player will know if he/she is better than another.
    Is the best player the one with the most points? Furthest progress? Best time?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a draft of the rules of the game. Try to come up with at least five major
    rules. Rules provide a formal description of your game. Every game has a concise
    set of rules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a storyboard of your game. A storyboard reads like a comic book and depicts
    the main storyline and concept art for the game. Storyboards are a major design
    tool, used in both the gaming and movie industries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After creating this information, make sure to keep it located in a central location
    that is shared among all team members and updated as the game evolves. When you
    are unsure what feature would be best to add to the game, or whether you should
    add a twist to the story, consult these documents and make sure everything stays
    consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this step, you implement a few features to your game that you have already
    decided upon in the last iteration's Refinement step. If this is your first iteration,
    pick a few simple things to implement, such as a main character, movement controls,
    and maybe one enemy. This step only contains coding and no design work. That was
    done through the last iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Playtest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This iterative development process encourages play-based design. In play-based
    design, you have volunteers playtest your game. They evaluate it, not based on
    a description you give them, but on how the game actually plays. Early stages
    will be simplistic and evaluators might only be able to comment on whether the
    controls feel natural or how the navigation feels. As the game evolves, so will
    their ability to provide feedback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your playtesting session should be well defined and repeatable. You want to
    make sure every playtester has the same experience, so that you can reliably compile
    and compare their feedback. To conduct a playtest, you should:'
  prefs: []
  type: TYPE_NORMAL
- en: Have a computer available that has the prototype of your game ready to play.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide your tester with a short explanation of the playtesting procedure and
    then give them a short description of your game and what features are available
    for testing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allow your player 5–20 minutes of play time, depending on how many features
    you want tested during this iteration. Try not to interrupt your playtester (even
    if you notice them doing something very wrong) and only speak to them if they
    ask you a question. Provide short answers, but do not elaborate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Observe the body language of your tester. Do they seem bored? Frustrated? Engaged?
    Are they looking at their watch or surprised when you tell them that their 10
    minutes of playing are up?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When your playtester is done with the game, give them a short survey. Ask them
    questions about the game's controls, rules, goals, and story. Ask them whether
    they felt the challenge of the game was balanced. Did they think they had sufficient
    options to consider on a moment-to-moment basis? Was the look and feel of the
    game consistent? Did your choice of narrative descriptors work well? Were they
    ever confused on what to do next? Collect some demographics on your testers. How
    old are they? Are they casual or hardcore gamers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have an open question-and-answer period. Do they have any suggestions on how
    to improve the game? Were there aspects they did not enjoy?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure to thank your playtester and go over the information you collected.
    This is your last chance to get clarification from the tester. After doing all
    of this, you are ready to move to the next stage.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The evaluation stage is very mechanical. In this stage, you only compile the
    results you received from all of your playtesters. Compile all of the results
    from the survey. Is there a consensus on certain answers? For example, 80 percent
    of the playtesters felt the controls were awkward, or 100 percent of the players
    did not know what to do after killing the first enemy. For the open question-and-answer
    session, are there any suggestions that multiple testers made? From the body language
    observations, did a majority of the players ask if they were done playtesting
    before the time expired?
  prefs: []
  type: TYPE_NORMAL
- en: Refinement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The real design work happens in this stage. Pick the top two or four issues
    with the game identified during playtesting and write them down. Now, brainstorm
    the changes, additions, or subtractions you could make to the game to address
    these issues. Your ideas could include suggestions playtesters gave you or not.
    You are not obligated at all to directly use the suggestions given to you by your
    playtesters; however, you should give them special consideration. While brainstorming,
    do not filter your, or your teammates' ideas. On a piece of paper, record at least
    twenty changes you could make to your game.
  prefs: []
  type: TYPE_NORMAL
- en: After brainstorming twenty ideas, prioritize them based on how effectively they
    address the top issues raised by your playtesters and also based on the scope
    of work needed to implement the idea. Choose your top two to five ideas and implement
    them in the upcoming prototype stage. The process begins again.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The interactive entertainment iterative development process allows you to incrementally
    grow your game in a way that is pleasing to users. By doing quick iterations,
    you quickly find development paths that should be abandoned and others that should
    be started. While it might seem initially to be time consuming, the process will
    actually save you a lot of development time in the long run and greatly increase
    the chances that you converge on a game that is truly fun to play.
  prefs: []
  type: TYPE_NORMAL
- en: Avoider Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first couple of chapters in this book, we worked on Avoider Game, then
    switched to a zombie invasion simulation, and then a platform game. We will go
    back to Avoider Game and use it to demonstrate the concepts discussed earlier
    in this chapter. You can either start with your version of Avoider Game or download
    this version: [http://www.packtpub.com/support](http://www.packtpub.com/support)'
  prefs: []
  type: TYPE_NORMAL
- en: Avoider Game recap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our version of Avoider Game which we created in [Chapter 1](part0014.xhtml "Chapter 1. Let's
    Dive Right in…"), *Let's Dive Right in…* and [Chapter 2](part0017.xhtml "Chapter 2. Animation"),
    *Animation* is fairly functional. It has an introduction screen, a game-over screen,
    a moving star field, interesting actor animations, a score, power-ups, and power-downs.
    *Figure 4* shows a screenshot from the game.
  prefs: []
  type: TYPE_NORMAL
- en: '![Avoider Game recap](img/image00295.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: This is a snapshot of our version of Avoider Game'
  prefs: []
  type: TYPE_NORMAL
- en: In the next several sections, we will augment this version of Avoider Game.
    Our changes will be based on the game design principles we just finished studying.
  prefs: []
  type: TYPE_NORMAL
- en: High-score list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first change we are going to make is to add a simple mechanism to record
    the highest score. We will then display this score on the game-over screen, so
    that players can see where they stand compared with each other. By adding a high
    score, we are clearly identifying the main goal of the game—score the most points.
    To add a high score, make the following changes to the `AvoiderGameOverWorld`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor and the `act()` method did not change. We added two new methods:
    `setPlayerHighScore()` and `recordAndReturnHighScore()`. The `setPlayerHighScore()`
    method is public and will be called by `AvoiderWorld` to pass the current player''s
    score, in the form of `String`, to the game-over screen. Due to functional decomposition,
    this method is fairly simple. It creates two `Label` objects to display the player''s
    score and the high score and then adds these objects to the current world, which
    is `AvoiderGameOverWorld`. The `Label` class is new and provides a way to easily
    create text-based images. We will look at the code for it shortly. First, we will
    look more closely at the `recordAndReturnHighScore()` method, which contains the
    functionality to retrieve and set the high score.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `java.nio.file` package requires that you have Java 1.7 or later installed.
  prefs: []
  type: TYPE_NORMAL
- en: The `recordAndReturnHighScore()` method introduces file I/O. To make the high
    score persist whether you have Avoider Game open or not, we need to store the
    high score in a file. Files provide persistent storage. We can use some very simple
    file I/O operations because we are only storing or retrieving a single `String`.
    First, we make a call to the `Paths.get()` static function. This provides the
    location of the file. Next, we check to see whether the file already exists using
    the `Files.exists()` static function. If the file does not exist, we create and
    write to it the current player's score using `Files.write()`.
  prefs: []
  type: TYPE_NORMAL
- en: This function will create the file and write to it and then close the file before
    returning. If the file does exist, then we read its contents using `Files.readAllBytes()`
    which will open the file, read the contents of the file, close the file, and then
    return the data it read. The last thing we need to do in this method, is to see
    if the current player's score is larger than the current high score. If it is,
    we update the file. `recordAndReturnHighScore()` then returns the highest score,
    which will either be the value read from the file or the current player's score.
    Please note the additional `import` statements we added to access these new file
    I/O classes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Greenfoot provides another mechanism to store and maintain high-score lists
    that only work after you have shared your game/application on the Greenfoot site.
    To learn more about this, read the Greenfoot online documentation on the `UserInfo`
    class provided by Greenfoot. You can access that documentation at [http://www.greenfoot.org/files/javadoc/](http://www.greenfoot.org/files/javadoc/).
    To learn more about the Java file I/O, look at the tutorial at [http://docs.oracle.com/javase/tutorial/essential/io/index.html](http://docs.oracle.com/javase/tutorial/essential/io/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can look at the code for the `Label` class. The `Label` class is a
    new class we are going to create to help us add text to our game. Create a new
    subclass of `Actor` and call it `Label`. Do not associate an image with this class.
    We will also use this class later in this chapter. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This class is simple and only contains two constructors; the first one calls
    the second one with the default color, white. In the second constructor, `String`,
    which is supplied, is converted into an image using `GreenfootImage`, and then
    this image is set to be the default image for this instance of `Label`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last change that we need to make to get all this working, is add the code
    to `AvoiderWorld` to pass the player''s current score to `AvoiderGameOverWorld`.
    We only need to add one line to the `endGame()` method in `AvoiderWorld`. Here
    is the complete implementation of `endGame()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After making this change, compile the game to find and fix any typos that happened
    along the way. Play it. What's your top score? *Figure 5* demonstrates what your
    game-over screen should now look like.
  prefs: []
  type: TYPE_NORMAL
- en: '![High-score list](img/image00296.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: The game-over screen with the current and high score added.'
  prefs: []
  type: TYPE_NORMAL
- en: Achievement badges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many games and gamification strategies use the notion of an achievement badge.
    This is a badge you earn for accomplishing something difficult or something out
    of the ordinary. In games and interactive applications, they are a convenient
    and popular technique of giving players subgoals to complete, conditioning their
    behavior, and adding complexity of choice. We will add achievement badges to accomplish
    all of those things in our version of Avoider Game.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to come up with a list of achievements. In practice, coming
    up with the right mix of achievements will take some careful thought, time, and
    playtesting. Here is the list of achievements I came up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Magically Delicious**: The player has to hit 20 clovers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This achievement adds complexity to the choices available to the player on a
    moment-to-moment basis. Do they dare risk collecting another clover and suffer
    the slow-down penalty?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Turkey**: The player must collect three rocks in a row. The user cannot touch
    any other object during this time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This achievement conditions the player to go after rocks even when they are
    at full health.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unbreakable**: The player has to touch an enemy 10 times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This achievement adds to the complexity of choices available to the user and
    serves as a means to increase the challenge during certain slow parts of the game.
    In the game, you come across small periods of time where you are at full health
    and there is no immediate danger of being hit by an enemy. During these periods,
    the player could now choose to take a few hits to increase the number of **Unbreakable**
    badges they get.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Master Avoider**: The player finishes a game before hitting three cupcakes
    in total.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This achievement reinforces the behavior that we want. We want the player to
    avoid cupcakes at all costs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These achievements also serve as potential subgoals for the user. We will display
    the badges the player has earned on the game-over screen right next to the main
    goal—their score.
  prefs: []
  type: TYPE_NORMAL
- en: The first issue to consider when implementing achievement badges is that, the
    data needed to determine whether a badge was earned. In our case, this data is
    distributed between the `PowerItems` subclasses and `Avatar`. Also, the `AvoiderGameOverWorld`
    class will have to know which badges were earned, so that they can be displayed
    on the game-over screen. We would like to have a central location to collect this
    information. Because we need distributed access to a single class, we are going
    to use the **Singleton** design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Design patterns**'
  prefs: []
  type: TYPE_NORMAL
- en: As you become more experienced in programming, you are going to recognize common
    patterns of coding that emerge in your work. Perhaps in the next game you create,
    you will also want achievements and think to yourself, "I can just reuse my design
    of achievements from my version of Avoider Game." In essence, you have a very
    small, personal design pattern that you can use to create achievements that you
    can improve upon over time.
  prefs: []
  type: TYPE_NORMAL
- en: Developers have created very useful design patterns since the inception of programming,
    that apply to many different types of applications. Design patterns provide a
    proven, tested method for coding certain functionality that you can easily adapt
    for your own uses.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns are also very useful to study. By examining them, you can see
    how some of the best programmers use abstraction to solve complex, recurring issues.
    They also serve as a concise language that developers can use to effectively communicate
    with each other. It is far more convenient to say that the `BadgeCenter` class
    in Avoider Game implements the Singleton design pattern rather than trying to
    describe it from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of books published on design patterns, but the most famous
    and popular one is Design Patterns: Elements of Reusable Object-Oriented Software
    by *Gamma et al*. At some point in your development career, you should read it.'
  prefs: []
  type: TYPE_NORMAL
- en: To keep track of player achievements, we are going to create a class called
    `BadgeCenter` that follows the Singleton design pattern. This new class will not
    be a subclass of `World` or `Actor`. To create it, click on **Edit** in the menu
    bar and then choose **New Class**. You should see the pop-up window shown in *Figure
    6*. Type in `BadgeCenter` and press *Enter*. We are now ready to add the code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Achievement badges](img/image00297.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: This is the popup window used to create a class that is not a subclass
    of Actor or World'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Following the Singleton design pattern, we create a constructor that is `private`
    and provide a `static` method called `getInstance()` to manage access to the single
    instance of this class. Since `getInstance()` is `static`, all of our classes
    in our version of Avoider Game will have access to it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In practice, you should try and minimize your use of the keyword `static`. While
    it is very useful in several cases, abusing it can lead to poor design and hard-to-maintain
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To collect all the data we need, we have four methods: `hitClover()`, `hitRock()`,
    `hitEnemy()`, and `hitCupcake()`. These methods will be called by the `Clover`,
    `Rock`, `Avatar`, and `Cupcake` classes, respectively, to report collisions. Each
    method tracks the number of hits, sets the `previous` variable, and then determines
    if a badge should be awarded. For example, `hitClover()` first increments the
    variable `clovers` and then sets `previous` to `Clover`. The method then checks
    to see if we have just hit another 20 clovers. If so, we award a badge using the
    `awardBadge()` method. If we hit over 80 clovers, we issue the grand prize—a *Magically
    Delicious* badge.'
  prefs: []
  type: TYPE_NORMAL
- en: The `awardBadge()` method is used to record badges. It takes `String` that will
    be used as the title of the achievement, creates `Badge` anew, and then stores
    that badge in an array. The array will later be accessed using `getBadges()` by
    `AvoiderGameOverWorld`. The `getBadges()` method has a few duties other than returning
    the array of badges achieved until now. It looks at values maintained by `hitCupcakes()`
    and `hitRock()` and determines whether additional badges should be awarded. If
    you did not know, the term, *turkey*, comes from bowling and means you just got
    three strikes in a row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code we need to add to the constructor of `AvoiderGameOverWorld`,
    in order to display the badges on the game-over screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, we use `BadgeCenter.getInstance()` to get access to the
    single instance of `BadgeCenter` and then immediately invoke `getBadges()`. We
    then iterate over `badgeList` (we discussed the `List` interface in [Chapter 3](part0024.xhtml
    "Chapter 3. Collision Detection"), *Collision Detection*) and add each `Badge`
    to the world. We use the variable `yPos` to appropriately space out the badges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we use the `List` interface, we need to add the following `import`
    statement to `AvoiderGameOverWorld`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Last, we need to define the `Badge` class. It is a simple class that adds a
    text string onto an image for a badge. *Figure 7* shows the image I created for
    badges. I tried to make it look like a tombstone.
  prefs: []
  type: TYPE_NORMAL
- en: '![Achievement badges](img/image00298.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: This is the image associated with the Badge class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new subclass of `Actor` and call it `Badge`. Assign the new image
    you created for badges or use mine. Add this code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have already discussed the `Color` and `GreenfootImage` classes in the earlier
    chapters. The constructor uses the `drawImage()` method of `GreenfootImage` to
    draw one image on top of another. By doing this, we effectively add the text.
  prefs: []
  type: TYPE_NORMAL
- en: Compile the code, debug any mistakes, and try it out. What badges did you earn?
  prefs: []
  type: TYPE_NORMAL
- en: Player conditioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I would like to provide you with an example where some user conditioning I added
    to the game had to be removed as I determined, after playtesting, that it drove
    the wrong behavior. Initially, I thought of changing the game to provide 10 points
    for each clover you hit. This would help to increase the complexity of the game,
    as players would have to balance getting more points against the slowdown penalty
    of clovers.
  prefs: []
  type: TYPE_NORMAL
- en: However, this change really had an effect on the player. Because clovers are
    so plentiful and worth 10 points, it really became worthwhile to collect clovers
    as a means of getting high scores. This changed the whole feel of the game from
    one that encourages avoiding to one that encourages collecting. Therefore, the
    change was removed.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, adding points to clovers broke some of the story elements of the
    game. In the game, things that look good are bad. But, by having a good item provide
    a direct benefit to the player, we broke our game's theme. Next, we will discuss
    theming and storytelling in Avoider Game.
  prefs: []
  type: TYPE_NORMAL
- en: Storytelling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is hard to build a deep, meaningful story for a game like ours. However,
    the player will still try to make sense of the world we threw them in, and we
    need to do as much as we can to help the player construct a meaningful world.
    Our story should motivate why we flee from smiley faces and cupcakes and welcome
    rocks.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a story screen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To help tell the story of our game, we are going to create a story screen the
    player can choose to view before playing the game. This screen will provide the
    background and context for our game, as well as set up its theme. While we are
    at it, we are going to add a credits screen. Adding comments to your code to credit
    artists and developers is a good start, but eventually you will need to formally
    recognize these people. Plus, you can give the person who worked hardest on this
    game credit—you!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to add some buttons to our introduction screen that, when
    clicked, will either take you to the story screen, take you to the credits screen,
    or start the game. Here are the changes we need to make to `AvoiderGameIntroScreen`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The constructor function creates three buttons using the `addButton()` method.
    In the `act()` method, we simply listen for mouse clicks on those buttons and
    switch worlds appropriately if we get one. We covered all of this in [Chapter
    1](part0014.xhtml "Chapter 1. Let's Dive Right in…"), *Let's Dive Right in…*,
    except for the implementation of `addButton()`.
  prefs: []
  type: TYPE_NORMAL
- en: The method `addButton()` creates a new `Label` and adds it to the screen. We
    discussed the `Label` class earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: After running this code, your introduction screen will look like the one shown
    in *Figure 8*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a story screen](img/image00299.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8: This is the revised introduction screen to our version of Avoider
    Game'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we just need to make the story screen (`AvoiderGameStoryScreen`) and the
    credits screen (`AvoiderGameCreditScreen`). You already learned how to do this
    (refer to [Chapter 1](part0014.xhtml "Chapter 1. Let's Dive Right in…"), *Let's
    Dive Right in…*), and I will just show you what my screens look like in *Figure
    9* and *Figure 10*. Feel free to use mine or make your own.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a story screen](img/image00300.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9: This is how our story screen will look'
  prefs: []
  type: TYPE_NORMAL
- en: This is how the credits screen looks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a story screen](img/image00301.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10: This is how the credits screen looks'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the score
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Getting points in the game is a good thing; therefore, our score indicator should
    look like a bad thing. Right now, it is neutral and does not contribute to the
    story or theme of the game. Let's change this narrative descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: Presently, we are using the imported `Counter` class. To get a customized look
    for our score, we are going to need to create our own class and not rely on the
    `Counter` class. Create a new subclass of `Actor` and name it `Score`. Because
    points and badges are types of awards, I thought making them both tombstones made
    sense. *Figure 11* shows the image I used for the new `Score` actor. It is a smaller
    version of the tombstone used for achievement badges with the **Achievement Badge**
    text replaced with **R.I.P.**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the score](img/image00302.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11: This is the image for our new Score class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the `Score` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This class stores the current score in the `counter` integer variable. You can
    increase the score by calling `addScore()` and retrieve the current score by calling
    `getScore()`. The `Score` class works by adding an image that contains the current
    score over the default image, which is a tombstone. Whenever the score changes,
    the `counter` variable is incremented and then `updateImage()` is called. The
    `updateImage()` method removes the old object containing the image of the score
    and then creates a new image based on the current value of `counter` using the
    `Label` class (as discussed previously). The `addedToWorld()` method is needed
    to display the initial score of 0.
  prefs: []
  type: TYPE_NORMAL
- en: We have made several changes. Make sure to compile and run your game to ensure
    that everything works properly.
  prefs: []
  type: TYPE_NORMAL
- en: Adding sound effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sound effects can provide important and valuable feedback to players. Also,
    they can be important narrative descriptors. In this section, we are going to
    add some sound effects to both enhance meaningful play and the story of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Because cupcakes, clovers, and rocks have a random, limited lifespan, it can
    be confusing to know whether you hit one or it just expired right before touching
    you. If you were at full health already, you have no idea whether you hit a rock
    or not. If you do not move, you cannot tell whether you really hit a cupcake or
    clover. We are going to solve this ambiguity by playing a sound whenever you collide
    with any `PowerItems`. This will also help players who are actively trying to
    gain achievement badges.
  prefs: []
  type: TYPE_NORMAL
- en: We will choose sounds appropriate for our game's story. If the player collides
    with a cupcake or clover, then we will play the sound of you saying, *Woot!*.
    If you, the player, collide with a rock, then we will play the sound of you saying,
    *Ahhh!*. This fits with the theme of the game.
  prefs: []
  type: TYPE_NORMAL
- en: You could play any sound effect you find on the Internet (assuming it is free
    for such use) or create your own using various audio editing programs. Fortunately,
    Greenfoot comes with a built-in audio recording and editing tool. To access it,
    click on **Controls** in the main menu and then choose **Show Sound Recorder**.
    You should see the window shown in *Figure 12*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding sound effects](img/image00303.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12: This is the sound recorder tool in Greenfoot'
  prefs: []
  type: TYPE_NORMAL
- en: Using Greenfoot's sound recorder, record yourself saying *ahhh* and save it
    as `ahhh.wav`. Then, record yourself saying *woot* and save it as `woot.wav`.
    To make your recordings as concise as possible, you can use the **Trim to selection**
    button to eliminate any beginning or ending silence or unnecessary noises.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to add two methods to the `Avatar` class to play these sounds.
    Here is the first method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the second method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We create two instance variables, `woot` and `ahhh`, at the top of the `Avatar`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize them in the `AddedToWorld()` method. Here is this initialization
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now set up `Avatar` to say *ahhh* or *woot!*. We just need to change
    `PowerItems` to call either of the two methods we just added to the `Avatar` class.
    In the `Cupcake` class, change `checkHitAvatar()` to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Clover` class, we need to change `checkHitAvatar()` to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Health` class, we need to change `checkHitAvatar()` to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Compile your game and play. Enjoy all of the *wooting* and *ahhhing*!
  prefs: []
  type: TYPE_NORMAL
- en: Playtesting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Playtest your game and see if you think the game needs any changes. After playing
    for a while, I decided to change the `increaseLevel()` method in `AvoiderWorld`
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: I felt that there were not enough enemies on screen and that the `Health` power-ups
    were too frequent after the player had increased several levels. To help with
    this, I increased the rate of change to the `enemySpawnRate` variable to `4` and
    reduced the rate of increase to the `healthFrequency` variable to `1`. With these
    changes, the game play felt better. Do you agree with my changes? What changes
    do you feel improve the game? Of course, the way to best determine the appropriate
    values for these variables is to recruit more playtesters.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to [http://en.wikipedia.org/wiki/Balance_(game_design)](http://en.wikipedia.org/wiki/Balance_(game_design))
    for more information on game balance.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We added some nice features to our version of Avoider Game. Of course, it seems
    there are endless cool things we could try to implement in order to improve our
    game. As a programming challenge, let's try one more. Change the game, so that
    players are awarded bonus points for each achievement badge they get. This change
    will further encourage the users to attempt the achievements. This also potentially
    enhances long-term meaningful play. How many points are you going to assign for
    each badge? Will each badge be worth the same amount of points? How does this
    affect game play? Is this a change you would keep?
  prefs: []
  type: TYPE_NORMAL
- en: Let's spruce up our introduction screen. Add background music and play a *click*
    sound when the player clicks on a menu choice. Providing auditory feedback to
    player actions enhances those interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Additional readings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good portion of my philosophy of game design came from many years of teaching
    game development and two key textbooks. The first textbook is *Rules of Play*
    by Eric Zimmerman and Katie Salen, published in 2003\. This book provides an in-depth
    and thorough coverage of games, game history, and game design. The other book
    that heavily influenced me was *Half-real* by Jesper Juul, published in 2005\.
    This book offers a more concise study of game design. If you have a passion for
    game design, I highly recommend that you read these two books.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating meaningful play is the main goal for game designers. In this chapter,
    we defined meaningful play and learned many game design techniques for enhancing
    meaningful play. We also learned a process for creating interactive applications
    that will guide you in creating engaging applications. As you read the rest of
    this book, and eventually create your own applications, you should reflect on
    this chapter and apply the techniques provided.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn to create worlds for our games that expand
    far beyond the edges of the screen.
  prefs: []
  type: TYPE_NORMAL
