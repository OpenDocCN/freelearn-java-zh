<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Making Our Game Professional - Do it as a Webapp</h1>
            

            <article>
                
<p class="calibre2">In this chapter, we will program a web application. We will build on what we have achieved already and create a web version of the Mastermind game. This time, it will not only run alone, guessing and answering the number of positions and matched colors, but also communicate with the user asking for the answers to the guesses. This will be a real game. Web programming is extremely important for Java programmers. Most of the programs are web applications. The universal client available on the Internet is the web browser. The thin-client, web browser-based architecture is widely accepted in enterprises as well. There are only some exceptions when the architecture has something else but the web client. If you want to become a professional Java developer, you must be familiar with web programming. And it is also fun!</p>
<p class="calibre2">There are a lot of technical topics that we will visit during the development. First of all, we will discuss networking and web architecture. This is the concrete base of the whole building. It is not too sexy, just like when you construct the building. You spend a lot of money and effort digging trenches, and then you bury the concrete and end up at the end of the phase with what you seemingly had before: flat ground. Except that there is the base. Building without this base, the house would either collapse soon after or during the process of building. Networking is just as important for web programming. There are a lot of topics that seemingly have nothing to do with programming. Still, it is the base of the building and when you program web applications, you will also find the fun part in it.</p>
<p class="calibre2">We will also talk a bit about HTML, CSS, and JavaScript, but not too much. We cannot avoid them because they are also important for web programming, but they are topics that you can learn from somewhere else as well. In case you are not an expert in some of these areas, there are usually other experts in enterprise project teams who can extend your knowledge. (In the case of networking, there is no mercy.) In addition to that, JavaScript is a topic so complex and huge that it deserves a whole book to start with it. There are only very few experts who deeply understand both Java and JavaScript. I understand the general structure of the language and the environment it runs in, but I cannot keep up with the new frameworks that are released every week these days, having my focus on other areas.</p>
<p class="calibre2">You will learn how to create Java applications that run in an application server, this time in Jetty, and we will see what a servlet is. We will create a web <em class="calibre12">hello world</em> application to start up fast, and then we will create the servlet version of Mastermind. Note that we hardly ever program servlets directly without the aid of some framework that implements the code to handle parameters, authentication, and many other things that are not application-specific. We will still stick to a naked servlet in this chapter because it is not possible to effectively use frameworks, such as Spring, without first understanding what a servlet is. Spring will come in the next chapter.</p>
<p class="calibre2">We will mention <strong class="calibre1">Java Server Pages</strong> (<strong class="calibre1">JSP</strong>) only because you may meet some legacy application, which was developed using that technology, but modern web applications do not use JSP. Still, JSP is a part of the servlet standard and is available for use. There are other technologies that were developed in the recent past but do not seem to be future-proof these days. They are still usable but appear only in legacy applications, and choosing them for a new project is fairly questionable. We will talk about these technologies shortly in a separate section.</p>
<p class="calibre2">By the end of this chapter, you will understand how the basic web technology works and what the major architectural elements are, and you will be able to create simple web applications. This is not enough to be a professional Java web developer but will be a good grounding for the next chapter, where we will have a look at the professional frameworks used in today's enterprises for real application developments.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Web and network</h1>
            

            <article>
                
<p class="calibre2">Programs run on computers, and computers are connected to the Internet. This network was developed in the last 60 years, first to provide military data communication that is resilient to rocket attack, then it was extended to be an academic network, and later it became a commercial network used by anyone and available almost ubiquitously all over the Earth.</p>
<div class="packtinfobox">The design of the network, and the research, started as a response to the flight of Gagarin over the Earth in the fifties. Sending Gagarin to space and travelling over the Earth was a demonstration that Russia could send a rocket anywhere on the globe, possibly with atomic explosives. It meant that any data network that needed some central control was not resilient to such an attack. It was not feasible to have a network with a central location as a single point of failure. Therefore, research was started to create a network that goes on working even if any part of it is brought down.</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">IP</h1>
            

            <article>
                
<p class="calibre2">The network delivers data packets between any two computers connected to it. The protocol used on the network is IP, which is simply an abbreviation of Internet Protocol. Using IP, a computer can send a data packet to another. The package contains a header and the data content. The header contains the Internet addresses of the sender and the target machine, other flags, and information about the package. Since the machines are not connected to each other directly, routers forward the packets. It is like post offices sending mails to each other till it gets into the hands of the postman you know, who can directly deliver it to your mailbox. To do that, the routers use the information in the header. The algorithm and organization of how the routers interact are complex and something we need not know to be Java professionals.</p>
<p class="calibre2">If you ever need to program in order to send IP packets directly, you should look at <kbd class="calibre11">java.net.DatagramPacket</kbd>, and the rest is implemented in the JDK, the operating system, and on the firmware of the network card. You can create a data packet; sending it and changing the modulated voltage on the network card or emitting photons to the fiber is not your headache. However, you will all know whether you really need to program datagrams directly.</p>
<div class="packtinfobox">IP has two versions. The old version still in use is IPv4. The new version that coexists with the old one is IPv6 or IPng (<em class="calibre27">ng</em> stands for <em class="calibre27">new generation</em>). The major difference that may concern a Java developer is that version 4 uses 32-bit addresses and version 6 uses 128-bit addresses. When you see a version-4 address, you will see something like <kbd class="calibre22">192.168.1.110</kbd>, which contains the four bytes in a decimal format separated by dots. IPv6 addresses are expressed as <kbd class="calibre22">2001:db8:0:0:0:0:2:1</kbd>, as eight 16-bit numbers expressed in hexadecimal separated by colons.</div>
<p class="calibre2">The Web is a bit more complex than sending data packets. If sending a data packet is like sending a one-page letter, then a web page download is like discussing a contract in paper mail. There should be an agreement in the initial paper mail as to what to send, what to answer, and so on, until the contract is signed. On the Internet, that protocol is called <strong class="calibre1">Transmission Control Protocol</strong> (<strong class="calibre1">TCP</strong>). While it is highly unlikely (but possible) that you will meet IP routing issues, being a Java developer, you certainly may meet TCP programming. Therefore, we will cover shortly how the TCP works. Be aware that this is very brief. Really. You will not become a TCP expert reading the next section, but you will get a glimpse of the most important issues that affect web programming.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">TCP/IP</h1>
            

            <article>
                
<p class="calibre2">The TCP protocol is implemented in the operating system and provides a higher level of interface than IP. When you program TCP, you do not deal with datagrams. Instead, you have a channel of byte streams where you can put bytes to be delivered to the other computer, and you can read bytes from the channel that were sent by the other computer, exactly in the order as they were sent. This is a kind of connection between two computers and, what's more, between two programs.</p>
<div class="packtinfobox">There are other protocols that are implemented over IP and which are not connection-oriented. One of them is <strong class="calibre24">User Datagram Protocol</strong> (<strong class="calibre24">UDP</strong>), used for services when there is no need for connections, when the data may be lost and it is more important that the data gets to the destination in a timely manner than losing some of the packets (video streaming, telephony). When the data amount is small and in case it is not delivered, it can be requested again; the cost of losing it is cheap (DNS request, see the next section).</div>
<p class="calibre2">When a packet is lost on the network, or when it is sent twice, or when it is delivered sooner than a later package, it is handled by the TCP software layer implemented by the operating system. This layer is also popularly called the <strong class="calibre1">TCP stack</strong>.</p>
<p class="calibre2">Since the TCP is a connected protocol, there is a need for something that tells the TCP stack which stream a datagram belongs to when it arrives. The stream is identified by two ports. A port is a 16-bit integer. One identifies the program that initiates the connection, called the source port. The other one identifies the target program: the destination port. These are contained in each and every TCP packet delivered. When a machine runs a <strong class="calibre1">Secure Shell</strong> (<strong class="calibre1">SSH</strong>) server and a web server, they use different ports, usually port 22 and 80. When a package comes that contains the destination port <span>number</span> 22 in the TCP header, the TCP stack knows that the data in the packet belongs to the stream handled by the SSH server. Likewise, if the destination port is 80, then the data goes to the web server.</p>
<p class="calibre2">When we program a server, we usually have to define the port number; otherwise, there is no way the clients will find the server program. Web servers are usually listen on port 80, and clients try to connect to that port. The client port is usually not important and not specified; it is allocated by the TCP stack automatically.</p>
<p class="calibre2">To connect from a client code to a server is easy: only a few lines of code. Sometimes, it is only one line of code. However, under the hood, there is a lot of work that the TCP stack does that we should care about—it takes time to build up a TCP connection.</p>
<p class="calibre2">To have a connection, the TCP stack has to send a datagram to the destination to know that it exists. If there is no server listening on the port, sending the data over the network has no result, except for wasting the network bandwidth. For this reason, the client first sends an empty data packet called SYN. When the other side receives it, it sends back a similar package called SYN-ACK. Finally, the client sends a package called ACK. If the packets go through the Atlantic, this is approximately 45ms for each package, which is equivalent to 45 million seconds in bureaucrat time. This is almost one and a half years. We need three of those to set up the connection, and there is more.</p>
<p class="calibre2">When a TCP connection starts, the client does not start to send the data without control. It sends some data packets and then it waits for the server to acknowledge their receipt. It would not only be useless, but also network wasting, to send data that the server is not prepared to accept and has to throw away. The TCP is designed to optimize the network usage. Therefore, the client sends some data, and then it waits for the acknowledgement. The TCP stack automatically manages this. If the acknowledgement arrives, it sends more packets, and if a carefully designed optimization algorithm, implemented in the TCP stack, believes that it is good to send more, it will send a bit more data than in the first step. If there are negative acknowledgements telling the client that the server could not accept some of the data and had to throw it away, then the client will lower the number of packets it sends without acknowledgement. But first it starts slow and cautious. This is called TCP slow start and we have to be aware of it. Although it is a low level networking feature it has consequences that we have to consider in our Java code: we use database connection pools instead of creating a new connection to the database each time there is a need for some data; we try to manage to have as few connections to web servers as possible using techniques such as <em class="calibre12">keep-alive</em>, <em class="calibre12">SPDY</em> protocol, or <em class="calibre12">http/2.0</em> (also replacing SPDY).</p>
<p class="calibre2">For a start, it is enough that TCP is connection-oriented where you build up a connection to a server, send and receive bytes, and finally close the connection. When you have a network performance problem, you have to look at the issues I listed.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">DNS</h1>
            

            <article>
                
<p class="calibre2">The TCP protocol creates a channel using the IP addresses of machines. When you type a URL in the browser, it usually does not contain IP numbers. It contains machine names. The name is converted to IP numbers using a distributed database called <strong class="calibre1">Domain Name System</strong> (<strong class="calibre1">DNS</strong>). This database is distributed, and when a program needs to convert a name to an address, it sends DNS request to one of the DNS servers it knows. These servers query each other or tell the client whom to ask, until the client knows the IP address assigned to the name. The servers and the client also cache the recently requested names, so answering is fast. On the other hand, when the IP address of a server changes this name, not all clients will immediately see the address assignment over the globe. The DNS lookup can be easily programmed, and there are classes and methods in JDK that support this, but usually we need not care about that; when we program, it is done automatically in web programming.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The HTTP protocol</h1>
            

            <article>
                
<p class="calibre2">The <strong class="calibre1">Hypertext Transport Protocol</strong> (<strong class="calibre1">HTTP</strong>) is built on top of the TCP. When you type a URL in a browser, the browser opens a TCP channel to the server (after DNS lookup, of course) and sends a HTTP request to the web server. The server, after receiving the request, produces a response and sends it to the client. After that, the TCP channel may be closed or kept alive for further HTTP request-response pairs.</p>
<p class="calibre2">Both the request and the response contain a header and an optional (possibly zero-length) body. The header is in the text format, and it is separated from the body by an empty line.</p>
<div class="packtinfobox">More precisely the header and the body are separated by four bytes: <kbd class="calibre22">0x0D</kbd>, <kbd class="calibre22">0x0A</kbd>, <kbd class="calibre22">0x0D</kbd>, and <kbd class="calibre22">0x0A</kbd>, which are two <kbd class="calibre22">CR</kbd>, <kbd class="calibre22">LF</kbd> line separators. The HTTP protocol uses carriage return and line feed to terminate lines in the header, and thus, an empty line is two <kbd class="calibre22">CRLF</kbd> following each other.</div>
<p class="calibre2">The start of the header is a status line plus header fields. The following is a sample HTTP request:</p>
<pre class="calibre20">
GET /html/rfc7230 HTTP/1.1 <br class="title-page-name"/>Host: tools.ietf.org <br class="title-page-name"/>Connection: keep-alive <br class="title-page-name"/>Pragma: no-cache <br class="title-page-name"/>Cache-Control: no-cache <br class="title-page-name"/>Upgrade-Insecure-Requests: 1 <br class="title-page-name"/>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36 <br class="title-page-name"/>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 <br class="title-page-name"/>DNT: 1 <br class="title-page-name"/>Referer: https://en.wikipedia.org/ <br class="title-page-name"/>Accept-Encoding: gzip, deflate, sdch, br <br class="title-page-name"/>Accept-Language: en,hu;q=0.8,en-US;q=0.6,de;q=0.4,en-GB;q=0.2
</pre>
<p class="calibre2">The following is the response:</p>
<pre class="calibre20">
HTTP/1.1 200 OK <br class="title-page-name"/>Date: Tue, 04 Oct 2016 13:06:51 GMT <br class="title-page-name"/>Server: Apache/2.2.22 (Debian) <br class="title-page-name"/>Content-Location: rfc7230.html <br class="title-page-name"/>Vary: negotiate,Accept-Encoding <br class="title-page-name"/>TCN: choice <br class="title-page-name"/>Last-Modified: Sun, 02 Oct 2016 07:11:54 GMT <br class="title-page-name"/>ETag: "225d69b-418c0-53ddc8ad0a7b4;53e09bba89b1f" <br class="title-page-name"/>Accept-Ranges: bytes <br class="title-page-name"/>Cache-Control: max-age=604800 <br class="title-page-name"/>Expires: Tue, 11 Oct 2016 13:06:51 GMT <br class="title-page-name"/>Content-Encoding: gzip <br class="title-page-name"/>Strict-Transport-Security: max-age=3600 <br class="title-page-name"/>X-Frame-Options: SAMEORIGIN <br class="title-page-name"/>X-Xss-Protection: 1; mode=block <br class="title-page-name"/>X-Content-Type-Options: nosniff <br class="title-page-name"/>Keep-Alive: timeout=5, max=100 <br class="title-page-name"/>Connection: Keep-Alive <br class="title-page-name"/>Transfer-Encoding: chunked <br class="title-page-name"/>Content-Type: text/html; charset=UTF-8 <br class="title-page-name"/><br class="title-page-name"/>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" <br class="title-page-name"/>  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; <br class="title-page-name"/>&lt;html  xml:lang="en" lang="en"&gt; <br class="title-page-name"/>&lt;head profile="http://dublincore.org/documents/2008/08/04/dc-html/"&gt; <br class="title-page-name"/>    &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; <br class="title-page-name"/>    &lt;meta name="robots" content="index,follow" /&gt;
</pre>
<p class="calibre2">The request does not contain a body. The status line is as follows:</p>
<pre class="calibre20">
GET /html/rfc7230 HTTP/1.1
</pre>
<p class="calibre2">It contains the so-called method of the request, the object that is requested, and the protocol version used by the request. The rest of the request of the header contains header fields that have the format, <kbd class="calibre11">label : value</kbd>. Some of the lines are wrapped in the printed version, but there is no line break in a header line.</p>
<p class="calibre2">The response specifies the protocol it uses (usually the same as the request), the status code, and the message format of the status:</p>
<pre class="calibre20">
HTTP/1.1 200 OK
</pre>
<p class="calibre2">After this, the response fields come with the same syntax as in the request. One important header is the content type:</p>
<pre class="calibre20">
Content-Type: text/html; charset=UTF-8
</pre>
<p class="calibre2">It specifies that the response body (truncated in the printout) is HTML text.</p>
<p class="calibre2">The actual request was sent to the URL, <a href="https://tools.ietf.org/html/rfc7230" class="calibre6"><span>https://tools.ietf.org/html/rfc7230</span></a>, which is the standard that defines the 1.1 version of HTTP. You can easily look into the communication yourself, starting up the browser and opening the developer tools. Such a tool is built into every browser these days. You can use it to debug the program behavior on the network application level looking at the actual HTTP requests and responses on the byte level. The following screenshot shows how the developer tool shows this communication:</p>
<div class="packtfigure"><img class="image-border" src="../images/00045.jpeg"/></div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">HTTP methods</h1>
            

            <article>
                
<p class="calibre2">The method that is the first word in the status line of the request tells the server what to do with the request. The standard defines different methods, such as <kbd class="calibre11">GET</kbd>, <kbd class="calibre11">HEAD</kbd>, <kbd class="calibre11">POST</kbd>, <kbd class="calibre11">PUT</kbd>, <kbd class="calibre11">DELETE</kbd>, and some others.</p>
<p class="calibre2">The client uses the <kbd class="calibre11">GET</kbd> method when it wants to get the content of a resource. In the case of a <kbd class="calibre11">GET</kbd> request, the body of the request is empty. This is the method used by the browser when we download a web page. It is also, many times, the method used when some program implemented in JavaScript and running in the browser asks for some information from a web application, but it does not want to send much information to the server.</p>
<p class="calibre2">When the client uses <kbd class="calibre11">POST</kbd>, the intention is usually to send some data to the server. The server does reply and, many times, there is also a body in the reply, but the main purpose of the request/reply communication is to send some information from the client to the server. This is the opposite of the <kbd class="calibre11">GET</kbd> method in some sense.</p>
<p class="calibre2">The <kbd class="calibre11">GET</kbd> and <kbd class="calibre11">POST</kbd> methods are the most frequently used methods. Although there is a general guideline to use <kbd class="calibre11">GET</kbd> to retrieve data and <kbd class="calibre11">POST</kbd> to send data to the server, it is only a recommendation, and there is no clean separation of the two cases. Many times, <kbd class="calibre11">GET</kbd> is used to send some data to the server. After all, it is an HTTP request with a status line and header fields, and although there is no body in the request, the object (part of the URL) that follows the method in the status line is still able to deliver parameters. Many times, it is also easy to test a service that responds to a <kbd class="calibre11">GET</kbd> request because you only need a browser and to type in the URL with the parameters, and look at the response in the browser developer tools. You should not be surprised if you see an application that uses <kbd class="calibre11">GET</kbd> requests to execute operations that modify the state on a web server. However, not being surprised does not mean approval. You should be aware that in most cases, these are not good practices. When we send sensitive information using the <kbd class="calibre11">GET</kbd> request, the parameters in the URL are available to the client in the address line of the browser. When we send using <kbd class="calibre11">POST</kbd>, the parameters are still reachable by the client (after all, the information the client sends is generated by the client and, as such, cannot be unavailable), but not that easy for a simple security-unaware user to copy-paste the information and send, perhaps, to a malevolent third party. The decision between using <kbd class="calibre11">GET</kbd> and <kbd class="calibre11">POST</kbd> should always consider practicalities and security issues.</p>
<p class="calibre2">The <kbd class="calibre11">HEAD</kbd> method is identical to a <kbd class="calibre11">GET</kbd> request, but the response will not contain a body. This is used when the client is not interested in the actual response. It may happen that the client already has the object and wants to see if it was changed. The <kbd class="calibre11">Last-Modified</kbd> header will contain the time when the resource was last changed, and the client can decide if it has a newer one or needs to ask for the resource in a new request.</p>
<p class="calibre2">The <kbd class="calibre11">PUT</kbd> method is used when the client wants to store something on the server and <kbd class="calibre11">DELETE</kbd> when the client wants to erase some resource. These methods are used only by applications usually written in JavaScript and not directly by the browser.</p>
<p class="calibre2">There are other methods defined in the standard, but these are the most important and frequently used ones.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Status codes</h1>
            

            <article>
                
<p class="calibre2">The response starts with the status code. These codes are also defined and there are a limited number of codes usable in a response. The most important is <kbd class="calibre11">200</kbd>, which says all is OK; the response contains what the request wanted. The codes are always in the range of <kbd class="calibre11">100</kbd> to <kbd class="calibre11">599</kbd>, contain three digits, and are grouped by the first digit.</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre11">1xx</kbd>: These codes are information codes. They are rarely used but can be very important in some cases. For example, <kbd class="calibre11">100</kbd> means continue. A server can send this code when it gets a <kbd class="calibre11">POST</kbd> request and the server wants to signal the client to send the body of the request because it can process it. Using this code, and the client waiting for this code, may save a lot of bandwidth if properly implemented on the server and also on the client.</li>
<li class="calibre15"><kbd class="calibre11">2xx</kbd>: These codes mean success. The request is answered properly, or the requested service was done. There are codes, such as <kbd class="calibre11">200</kbd>, <kbd class="calibre11">201</kbd>, <kbd class="calibre11">202</kbd>, and so on, defined in the standard and there is a description about when to use one or the other.</li>
<li class="calibre15"><kbd class="calibre11">3xx</kbd>: These codes mean redirection. One of these codes is sent when the server cannot directly service the request but knows the URL that can. The actual codes can distinguish between a permanent redirect (when it is known that all future requests should be sent to the new URL) and temporary redirect (when any later request should be sent here and possibly served or redirected), but the decision is kept on the server side.</li>
<li class="calibre15"><kbd class="calibre11">4xx</kbd>: These are error codes. The most famous code is <kbd class="calibre11">404</kbd>, which means Not Found, that is, the server is not able to respond to the request because the resource is not found. <kbd class="calibre11">401</kbd> means that the resource to serve the request may be available but it requires authentication. <kbd class="calibre11">403</kbd> is a code that signals that the request was valid but is still refused to be served by the server.</li>
<li class="calibre15"><kbd class="calibre11">5xx</kbd>: These codes are server error codes. When a response holds one of these error codes, the meaning is that there is some error on the server. This error can be temporary, for example, when the server is processing too many requests and cannot respond to a new request with a calculation-intensive response (this is usually signaled by error code <kbd class="calibre11">503</kbd>) or when the feature is not implemented (code <kbd class="calibre11">501</kbd>). The general error code <kbd class="calibre11">500</kbd> is interpreted as Internal Error, which means that no information, whatsoever, is available about what was going wrong on the server, but it was not going well and hence, no meaningful response.</li>
</ul>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">HTTP/2.0</h1>
            

            <article>
                
<p class="calibre2">After almost 20 years since the last release of HTTP, the new version of HTTP was released in 2015. This new version of the protocol has several enhancements over the previous versions. Some of these enhancements will also affect the way server applications will be developed.</p>
<p class="calibre2">The first and most important enhancement is that the new protocol will make it possible to send several resources parallelly in a single TCP connection. The keep-alive flag is available to avoid the recreation of the TCP channel, but it does not help when a response is created slowly. In the new protocol, other resources can also be delivered in the same TCP channel even before one request is fully served. This requires complex package handling in the protocol, but this is hidden from the server application programmer as well as the browser programmer. The application server, servlet container, and browser implement this transparently.</p>
<p class="calibre2">HTTP/2.0 will always be encrypted, therefore it will not be possible to use <kbd class="calibre11">http</kbd> as a protocol in the browser URL. It will always be <kbd class="calibre11">https</kbd>.</p>
<p class="calibre2">The feature that will need changes in servlet programming to leverage the advantages of the new version of the protocol is server push. Version 4.0 of the servlet specification includes support for HTTP/2.0, and this version is still in draft.</p>
<p class="calibre2">Server push is an HTTP response to a request that will come in the future. How can a server answer a request that is not even issued? Well, the server anticipates. For example, the application sends an HTML page that has references to many small pictures and icons. The client downloads the HTML page, builds the DOM structure, analyzes it, and realizes that the pictures are needed, and sends the request for the pictures. The application programmer knows what pictures are there and may code the server to send the pictures even before the browser requests for it. Every such response includes a URL that this response is for. When the browser wants the resource, it realizes that it is already there and does not issue a new request. In <kbd class="calibre11">HttpServlet</kbd>, the program should access <kbd class="calibre11">PushBuilder</kbd> via the request's new <kbd class="calibre11">getPushBuilder</kbd> method and use that to push down resources to the client.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Cookies</h1>
            

            <article>
                
<p class="calibre2">Cookies are maintained by the browser and are sent in the HTTP request header using the <kbd class="calibre11">Cookie</kbd> header field. Each cookie has a name, value, domain, path, expiration time, and some other parameters. When a request is sent to a URL that matches the domain, the path of a non-expired cookie, the client sends the cookie to the server. Cookies are usually stored in small files on the client by the browser or in a local database. The actual implementation is the business of the browser, and we need not worry about it. It is just the text information that is not executed by the client. It is only sent back to the server when some rules (mainly domain and path) match. Cookies are created by servers and are sent to the client in HTTP responses using the <kbd class="calibre11">Set-Cookie</kbd> header field. Thus, essentially the server tells the client, Hey, here is this cookie, whenever you come to me next time, show me this piece of information, so I will know it is you.</p>
<p class="calibre2">Cookies are usually to remember clients. Advertisers and online shops that need to remember who they are talking to heavily use it. But this is not the only use. These days, any application that maintains user sessions uses cookies to chain up the HTTP requests that come from the same user. When you log in to an application, the username and password you use to identify yourself are sent to the server only once, and in subsequent requests, only a special cookie is sent to the server used to identify the already logged in user. This use of cookies emphasizes why it is important to use cookie values that cannot be easily guessed. If the cookie used to identify a user is easily guessable, then an attacker could just create a cookie and send it to the server mimicking the other user. Cookie values, for the purpose, are usually long random strings.</p>
<p class="calibre2">Cookies are not always sent back to the server where they originate. When the cookie is set, the server specifies the domain of the URL where the cookie should be sent back. This is used when a different server from the one providing the services needing authentication does the user authentication.</p>
<p class="calibre2">Applications sometimes encode values into cookies. This is not necessarily bad, though in most actual cases, it is. When encoding something into a cookie, we should always consider the fact that the cookie travels through the network and can go huge as more and more data is encoded in it and can create unnecessary burden on the network. Usually, it is better to send only some unique, otherwise meaningless, random key, and store the values in some database, be it on disk or in the memory.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Client server and web architecture</h1>
            

            <article>
                
<p class="calibre2">The applications we developed so far were running on a single JVM. We already have some experience with concurrent programming and this is something that will come handy now. When we program a web application, a part of the code will run on the server and a part of the application logic will execute in the browser. The server part will be written in Java, the browser part will be implemented in HTML, CSS, and JavaScript. Since this is a Java book we will focus mainly on the server part, but we should still be aware of the fact that many of the functionalities can be and should be implemented to run in the browser. The two programs communicate with each other over the IP network, that is, the Internet, or in the case of an enterprise internal application, the network of the company.</p>
<p class="calibre2">Today, a browser is capable of running very powerful applications, all implemented in JavaScript. A few years ago, such applications needed client application implemented in Delphi, C++, or Java, using the windowing capabilities of the client operating system.</p>
<p class="calibre2">Originally, the client-server architecture meant that the functionality of the application was implemented on the client, and the program was using general services only from the server. The server provided database access and file storage but nothing more. Later, the three-tier architecture put the business functionality on the servers that used other servers for database and other general services, and the client application implemented the user interface and limited business functionality.</p>
<p class="calibre2">When the web technology started to penetrate enterprise computing, the web browser started to replace the client applications in many use cases. Previously, the browser could not run complex JavaScript applications. The application was executed on the web server and the client displayed the HTML that the server created as a part of the application logic. Every time something was changed on the user interface, the browser started a communication with the server, and in a HTTP request-response pair, the browser content was replaced. A web application was essentially a series of form filling and form data sending to the server, and the server responded with HTML-formatted pages, presumably containing new forms.</p>
<p class="calibre2">JavaScript interpreters were developed and became more and more effective and standardized. Today, modern web applications contain HTML (which is a part of the client code and is not generated by the server on the fly), CSS, and JavaScript. When the code is downloaded from the web server, the JavaScript starts to execute and communicate with the server. It is still HTTP requests and responses, but the responses do not contain HTML code. It contains pure data, usually in the JSON format. This data is used by the JavaScript code and some of the data, if needed, is displayed on the web browser display also controlled by JavaScript. This is functionally equivalent to a three-tier architecture with some slight but very important differences.</p>
<p class="calibre2">The first difference is that the code is not installed on the client. The client downloads the application from a web server, and the only thing that is installed is the modern browser. This removes a lot of enterprise maintenance burden and cost.</p>
<p class="calibre2">The second difference is that the client is not able, or is limited, to access the resources of the client machine. Thick client applications could save anything in a local file or access a local database. This is very limited, for security reasons, compared to a program running on the browser. At the same time this is a handy limitation because clients aren't and shouldn't be a trusted part of the architecture. The disk in the client computer is hard and expensive to back up. It can be stolen with a notebook, and encrypting it is costly. There are tools to protect client storage, but most of the time, storing the data on the server only is a more viable solution.</p>
<p class="calibre2">It is also a common program design error to trust the client application. The client physically controls the client computer and although it can be made technically very difficult, the client can still overcome the security limitations of the client device and client code. If it is only the client application that checks the validity of some functionality or data, then the physical security provided by the physical control of the server is not used. Whenever data is sent from the client to the server, the data has to be checked in regards of validity, no matter what the client application is. Actually, since the client application can be changed, we just don't really know what the client application really is.</p>
<p class="calibre2">In this chapter and, as a matter of fact, in the entire book, we focus on Java technologies; therefore the sample application will not contain almost any client technology. I could not help but create some CSS. On the other hand, I definitely avoided JavaScript. Therefore, I have to emphasize again that the example is to demonstrate the programming of the server side and still providing something that really works. A modern application would use REST and JSON communications and would not play around creating HTML on the fly on the server side. Originally, I wanted to create a JavaScript client and REST server application, but the focus was moved so much from server-side Java programming that I dropped this idea. On the other hand, you can extend the application to be one like that.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Writing servlets</h1>
            

            <article>
                
<p class="calibre2">Servlets are Java classes that are executed in a web server that implements the servlet container environment. The first web servers could only deliver static HTML files to the browsers. For each URL, there was an HTML page on the web server and the server delivered the content of this file, in response to a request sent by the browser. Very soon, there was a need to extend the web servers to be able to start some program that calculates the content of the response, on the fly, when the request is processed.</p>
<p class="calibre2">The first standard to do that defined CGI. It started a new process to respond to a request. The new process got the request on its standard input, and the standard output was sent back to the client. This approach wastes a lot of resources. Starting a new process, as you learned in the previous chapter, is way too costly just to respond to an HTTP request. Even starting a new thread seems to be unnecessary, but with that, we ran a bit ahead.</p>
<p class="calibre2">The next approach was FastCGI, executing the external process continually and reusing it, and then came different other approaches. The approaches after</p>
<p class="calibre2">FastCGIall use in-process extensions. In these cases, the code calculating the response runs inside the same process as the web server. Such standards or extension interfaces were ISAPI for the Microsoft IIS server, NSASPI for the Netscape server, and the Apache module interface. Each of these made it possible to create a <strong class="calibre1">dynamically loaded library</strong> (<strong class="calibre1">DLL</strong> on Windows or SO files on Unix systems) to be loaded by the web server during</p>
<p class="calibre2">startupand to map certain requests to be handled by the code implemented in these libraries.</p>
<p class="calibre2">When somebody programs PHP, for example, the Apache module extension is the PHP interpreter that reads the PHP code and acts upon it. When somebody programs ASP pages for the Microsoft IIS, the ISAPI extension implementing the ASP page interpreter is executed (well, this is a bit sloppy and oversimplified to say but works as an example).</p>
<p class="calibre2">To Java, the interface definition is a servlet defined in JSR340 as of version 3.1.</p>
<div class="packtinfobox">JSR stands for Java Specification Request. These are requests for modification of the Java language, library interfaces, and other components. The requests go through an evaluation process, and when they are accepted, they become a standard. The process is defined by the Java Community Process (JCP). JCP is also documented and has versions. The current version is 2.10 and can be found at <a href="https://jcp.org/en/procedures/overview" class="calibre25"><span class="URLPACKT">https://jcp.org/en/procedures/overview</span></a>. The JSR340 standard can be found at <a href="https://jcp.org/en/jsr/detail?id=340" class="calibre25"><span class="URLPACKT">https://jcp.org/en/jsr/detail?id=340</span></a>.</div>
<p class="calibre2">A servlet program implements the servlet interface. Usually this is done via extending <kbd class="calibre11">HttpServlet</kbd>, the abstract implementation of the <kbd class="calibre11">Servlet</kbd> interface. This abstract class implements methods, such as <kbd class="calibre11">doGet</kbd>, <kbd class="calibre11">doPost</kbd>, <kbd class="calibre11">doPut</kbd>, <kbd class="calibre11">doDelete</kbd>, <kbd class="calibre11">doHead</kbd>, <kbd class="calibre11">doOption</kbd>, and <kbd class="calibre11">doTrace</kbd>, free to be overridden by the actual class extending it. If a servlet class does not override one of the these methods, sending the corresponding HTTP method, <kbd class="calibre11">GET</kbd>, <kbd class="calibre11">POST</kbd>, and so on, will return the <kbd class="calibre11">405</kbd><kbd class="calibre11">Not Allowed</kbd> status code.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Hello world servlet</h1>
            

            <article>
                
<p class="calibre2">Before getting into the technical details, let's create an extremely simple <em class="calibre12">hello world</em> servlet. To do it, we setup a Gradle project with the build file, <kbd class="calibre11">build.gradle</kbd>, the servlet class in the file, <kbd class="calibre11">src/main/java/packt/java9/by/example/mastermind/servlet/HelloWorld.java</kbd>, and last but not least, we have to create the file <kbd class="calibre11">src/main/webapp/WEB-INF/web.xml</kbd>. The <kbd class="calibre11">gradle.build</kbd> file will look the following:</p>
<div class="title-page-name">
<pre class="calibre20">
apply plugin: 'java' <br class="title-page-name"/> apply plugin: 'jetty' <br class="title-page-name"/>  <br class="title-page-name"/> repositories { <br class="title-page-name"/>     jcenter() <br class="title-page-name"/> } <br class="title-page-name"/>  <br class="title-page-name"/> dependencies { <br class="title-page-name"/>     providedCompile "javax.servlet:javax.servlet-api:3.1.0" <br class="title-page-name"/> } <br class="title-page-name"/>  <br class="title-page-name"/> jettyRun { <br class="title-page-name"/>     contextPath '/hello' <br class="title-page-name"/> }
</pre></div>
<p class="calibre2">The Gradle build file uses two plugins, <kbd class="calibre11">java</kbd> and <kbd class="calibre11">jetty</kbd>. We have already used the <kbd class="calibre11">java</kbd> plugin in the previous chapter. The <kbd class="calibre11">jetty</kbd> plugin adds tasks such as <kbd class="calibre11">jettyRun</kbd> that load the Jetty servlet container and start up the application. The <kbd class="calibre11">jetty</kbd> plugin is also an extension of the <kbd class="calibre11">war</kbd> plugin that compiles web applications into a <strong class="calibre1">Web Archive</strong> (<strong class="calibre1">WAR</strong><kbd class="calibre11">)</kbd> packaging format.</p>
<p class="calibre2">The WAR packaging format is practically the same as JAR; it is a zip file and it contains a <kbd class="calibre11">lib</kbd> directory that contains all the JAR files that the web application depends on. The classes of the application are in the directory, <kbd class="calibre11">WEB-INF/classes</kbd>, and there is a <kbd class="calibre11">WEB-INF/web.xml</kbd> file that describes servlet URL mapping, which we will explore in detail soon.</p>
<p class="calibre2">Since we want to develop an extremely simple servlet, we add the servlet API as a dependency to the project. This is, however, not a compile dependency. The API is available when the servlet runs in the container. Still, it has to be available when the compiler compiles our code; therefore, a <em class="calibre12">dummy</em> implementation is provided by the artifact specified as <kbd class="calibre11">providedCompile</kbd>. Because it is specified that way, the build process will not package the library into the generated WAR file. The generated file will contain nothing that is specific to Jetty or any other servlet container.</p>
<p class="calibre2">The servlet container will provide the actual implementation of the servlet library. When the application is deployed and started in a Jetty, the Jetty-specific implementation of the servlet library will be available on the classpath. When the application is deployed to a Tomcat, the Tomcat specific implementation will be available.</p>
<p class="calibre2">We create a class in our project, as follows:</p>
<pre class="calibre20">
package packt.java9.by.example.mastermind.servlet; <br class="title-page-name"/>  <br class="title-page-name"/> import javax.servlet.ServletException; <br class="title-page-name"/> import javax.servlet.http.HttpServlet; <br class="title-page-name"/> import javax.servlet.http.HttpServletRequest; <br class="title-page-name"/> import javax.servlet.http.HttpServletResponse; <br class="title-page-name"/> import java.io.IOException; <br class="title-page-name"/> import java.io.PrintWriter; <br class="title-page-name"/>  <br class="title-page-name"/> public class HelloWorld extends HttpServlet { <br class="title-page-name"/>  <br class="title-page-name"/>     private String message; <br class="title-page-name"/>  <br class="title-page-name"/>     @Override <br class="title-page-name"/>     public void init() throws ServletException { <br class="title-page-name"/>         message = "Hello, World"; <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     @Override <br class="title-page-name"/>     public void doGet(HttpServletRequest request, <br class="title-page-name"/>                       HttpServletResponse response) <br class="title-page-name"/>             throws ServletException, IOException { <br class="title-page-name"/>         response.setContentType("text/html"); <br class="title-page-name"/>         PrintWriter out = response.getWriter(); <br class="title-page-name"/>         out.println("&lt;h1&gt;" + message + "&lt;/h1&gt;"); <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     @Override <br class="title-page-name"/>     public void destroy() { <br class="title-page-name"/>     } <br class="title-page-name"/> }
</pre>
<p class="calibre2">When the servlet is started, the <kbd class="calibre11">init</kbd> method is invoked. When it is put out of service, the <kbd class="calibre11">destroy</kbd> method is called. These methods can be overridden and provide a more fine-grained control than the constructor and other finalization possibilities. A servlet object may be put into service more than once, and after calling <kbd class="calibre11">destroy</kbd>, the servlet container may invoke <kbd class="calibre11">init</kbd> again; thus, this cycle is not strictly tied to the life cycle of the object. Usually, there is not much that we do in these methods, but sometimes, you may need some code in them.</p>
<p class="calibre2">Also, note that a single servlet object may be used to serve many requests, even at the same time; thus, the servlet classes and methods in it should be fairly thread-safe. The specification demands that a servlet container uses only one servlet instance in case the container runs in a non-distributed environment. In case the container runs on the same machine in several processes, each executing a JVM, or even on different machines, there can be many servlet instances that handle the requests. Generally, the servlet classes should be designed such that they do not assume that only one thread is executing them, but at the same time, they should also not assume that the instance is the same for different requests. We just cannot know.</p>
<p class="calibre2">What does it mean in practice? You should not use instance fields that are specific to a certain request. In the example, the field initialized to hold the message holds the same value for each and every request; essentially, the variable is almost a final constant. It is used only to demonstrate some functionality for the <kbd class="calibre11">init</kbd> method.</p>
<p class="calibre2">The <kbd class="calibre11">doGet</kbd> method is invoked when the servlet container gets an HTTP request with the <kbd class="calibre11">GET</kbd> method. The method has two arguments. The first one represents the request, and the second one represents the response. The <kbd class="calibre11">request</kbd> can be used to collect all information that comes in the request. In the preceding example, there is nothing like that. We do not use any of the inputs. If a request comes to our servlet, then we answer the <kbd class="calibre11">Hello, World</kbd> string, no matter what. Later, we will see examples when we read the parameters from the request. The <kbd class="calibre11">response</kbd> gives methods that can be used to handle the output. In the example, we fetch <kbd class="calibre11">PrintWriter</kbd>, which is to be used to send characters to the body of the HTTP response. This is the content that appears in the browser. The mime type we send is <kbd class="calibre11">text/html</kbd>, and this is set by calling the <kbd class="calibre11">setContentType</kbd> method. This will get into the HTTP header field, <kbd class="calibre11">Content-Type</kbd>. The standard and the JavaDoc documentation of the classes define all the methods that can be used, and also how these should be used.</p>
<p class="calibre2">Finally, we have a <kbd class="calibre11">web.xml</kbd> file that declares the servlets that are implemented in our code. This is, just as the name of the file indicates, an XML file. It declaratively defines all the servlets that are included in the archive and also other parameters. In the example, the parameters are not defined, only the servlet and the mapping to the URL. Since we have only one single servlet in this example, the WAR file, it is mapped to the root context. All and every <kbd class="calibre11">GET</kbd> request that arrives to the servlet container and to this archive will be served by this servlet:</p>
<pre class="calibre20">
&lt;?xml version="1.0" encoding="UTF-8"?&gt; <br class="title-page-name"/>&lt;web-app version="2.5" <br class="title-page-name"/>          <br class="title-page-name"/>          <br class="title-page-name"/>         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt; <br class="title-page-name"/><br class="title-page-name"/>    &lt;servlet&gt; <br class="title-page-name"/>        &lt;display-name&gt;HelloWorldServlet&lt;/display-name&gt; <br class="title-page-name"/>        &lt;servlet-name&gt;HelloWorldServlet&lt;/servlet-name&gt; <br class="title-page-name"/>        &lt;servlet-class&gt;packt.java9.by.example.mastermind.servlet.HelloWorld&lt;/servlet-class&gt; <br class="title-page-name"/>    &lt;/servlet&gt; <br class="title-page-name"/><br class="title-page-name"/>    &lt;servlet-mapping&gt; <br class="title-page-name"/>        &lt;servlet-name&gt;HelloWorldServlet&lt;/servlet-name&gt; <br class="title-page-name"/>        &lt;url-pattern&gt;/&lt;/url-pattern&gt; <br class="title-page-name"/>    &lt;/servlet-mapping&gt; <br class="title-page-name"/><br class="title-page-name"/>&lt;/web-app&gt;
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Java Server Pages</h1>
            

            <article>
                
<p class="calibre2">I promised you that I would not bore you with Java Server Pages because that is a technology of the past. Even though it is the past, it is still not history as there are many programs running that still use JSP and contain JSP code.</p>
<p class="calibre2">JSP pages are web pages that contain HTML and Java code mixed. When an HTTP request is served by a JSP page, the servlet container reads the JSP page, executes the Java parts, takes the HTML parts as they are, and in this way, mixing the two together, creates an HTML page that is sent to the browser.</p>
<pre class="calibre20">
&lt;%@ page language="java" <br class="title-page-name"/>         contentType="text/html; charset=UTF-8" <br class="title-page-name"/>         pageEncoding="UTF-8"%&gt; <br class="title-page-name"/>&lt;html&gt; <br class="title-page-name"/>&lt;body&gt; <br class="title-page-name"/>&lt;% for( int i = 0 ; i &lt; 5 ; i ++ ){ %&gt; <br class="title-page-name"/>  hallo&lt;br/&gt; <br class="title-page-name"/>&lt;% } %&gt; <br class="title-page-name"/>&lt;/body&gt; <br class="title-page-name"/>&lt;/html&gt;
</pre>
<p class="calibre2">The preceding page will create an HTML page that contains the text <kbd class="calibre11">hallo</kbd> five times, each in a new line separated by the tag <kbd class="calibre11">br</kbd>. Behind the scenes, the servlet container converts the JSP page to a Java servlet, then compiles the servlet using the Java compiler, and then runs the servlet. It does it every time there is some change in the source JSP file; therefore, it is very easy to incrementally craft some simple code using JSP. The code that is generated from the preceding JSP file is 138 lines long (on the Tomcat 8.5.5 version), which is simply long and boring to list here, but the part that may help to understand how the Java file generation works is only a few lines.</p>
<div class="packttip">If you want to see all the lines of the generated servlet class, you can deploy the application into a Tomcat server and look at the directory <kbd class="calibre22">work/Catalina/localhost/hello/org/apache/jsp/</kbd>. It is a rarely known fact among developers that this code is actually saved to disk and is available. Sometimes it helps when you need to debug some JSP pages.</div>
<p class="calibre2">Here are the few interesting lines generated from the preceding code:</p>
<pre class="calibre20">
      out.write("\n"); <br class="title-page-name"/>      out.write("&lt;html&gt;\n"); <br class="title-page-name"/>      out.write("&lt;body&gt;\n"); <br class="title-page-name"/> for( int i = 0 ; i &lt; 5 ; i ++ ){  <br class="title-page-name"/>      out.write("\n"); <br class="title-page-name"/>      out.write("  hallo&lt;br/&gt;\n"); <br class="title-page-name"/> }  <br class="title-page-name"/>      out.write("\n"); <br class="title-page-name"/>      out.write("&lt;/body&gt;\n"); <br class="title-page-name"/>      out.write("&lt;/html&gt;\n");
</pre>
<p class="calibre2">The JSP compiler moves the inside of the JSP code out and the outside in. In the JSP code, Java is surrounded by HTML, and in the generated servlet Java source, the HTML is surrounded by Java. It is like when you want to mend clothes: the first thing is to turn the dress inside out.</p>
<p class="calibre2">It is not only the Java code that you can mix into HTML in the JSP pages but also the so-called tags. Tags are collected into tag libraries, implemented in Java, and packaged into JAR files, and they should be available on the classpath to be used. The JSP page using the tags from some library should declare the use:</p>
<pre class="calibre20">
&lt;%@ taglib prefix="c" <br class="title-page-name"/>           uri="http://java.sun.com/jsp/jstl/core" %&gt;
</pre>
<p class="calibre2">The tags look like HTML tags, but they are processed by the JSP compiler and executed by the code implemented in the <kbd class="calibre11">taglib</kbd> library. JSP may also refer to the value of the Java objects that are available in the scope of the JSP. To do this inside the HTML page, the JSP expression language could be used.</p>
<p class="calibre2">JSP was originally created to ease the development of a web application. The main advantage is the fast startup of development. There is no lengthy time for configuration, setup, and so on in the development, and when there is any change in the JSP page, there is no need to compile the whole application again: the servlet container generates the Java code, compiles it to class file, loads the code into memory, and executes. JSP was a competitor of Microsoft ASP pages, which mixed HTML with VisualBasic code.</p>
<p class="calibre2">When the application starts to grow big, using the JSP technology causes more problems than are good. The code that mixes the business logic and the view of the application, how it is rendered in the browser, becomes messy. Developing JSP requires frontend technology knowledge. A Java developer is expected to know some frontend technology but is rarely a design expert and CSS guru. Modern code also contains JavaScript, many times embedded in the HTML page. After all, the big advantage of JSP is that it contains code that runs on the server as well as on the client-side code. The developers follow the paradigm many times, so do not be surprised to see some legacy code that contains Java, HTML, CSS, and JavaScript all mixed in a JSP file. Since Java and JavaScript are syntactically similar sometimes, it is not obvious to see what is executed on the server and what is executed on the client. I have even seen code that created JavaScript code from Java code in a JSP file. That is a total mix of different responsibilities and a mess that is nearly impossible to maintain. This led to the total deprecation of JSP as of today.</p>
<div class="packtinfobox">The deprecation of JSP is not official. It is my expert opinion. You may meet some experienced developers who are still in love with JSP, and you may find yourself in projects where you are required to develop programs in JSP. It is not shameful doing that. Some people do worse for money.</div>
<p class="calibre2">To mend the messy situation, there were technologies that advocated the separation of the server code and the client functionality more and more. These technologies include Wicket, Vaadin, JSF, and different Java templating engines, such as Freemarker, Apache Velocity, and Thymeleaf. These latter technologies can also be interesting when you generate textual output from Java even when the code is not web-related at all.</p>
<p class="calibre2">These technologies, with discipline, helped control the development and maintenance costs of moderate and large web projects, but the basic problem of the architecture was still there: no clear separation of concerns.</p>
<p class="calibre2">Today, modern applications implement the code of a web application in separate projects: one for the client, using HTML, CSS and JavaScript, and a separate one to implement server functionality in Java (or in something else, but we focus here on Java). The communication between the two is the REST protocol, which we will cover in the subsequent chapters.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">HTML, CSS, and JavaScript</h1>
            

            <article>
                
<p class="calibre2">HTML, CSS, and JavaScript are client-side technologies. These are extremely important for web applications, and a professional Java developer should have some knowledge about them. Nobody expects you to be an expert in Java and in web-client technologies at the same time, though this is not impossible. A certain understanding is desirable.</p>
<p class="calibre2">HTML is the textual representation of a structured text. The text is given as characters, as in any text file. Tags represent the structure. A start tag starts with a <kbd class="calibre11">&lt;</kbd> character, then the name of the tag, then, optionally, <kbd class="calibre11">name="value"</kbd> attributes, and finally a closing <kbd class="calibre11">&gt;</kbd> character. An end tag starts with <kbd class="calibre11">&lt;/</kbd>, then the name of the tag, and then <kbd class="calibre11">&gt;</kbd>. Tags are enclosed into hierarchies; thus, you should not close a tag sooner than the one that was opened later. First, the tag that was opened last has to be closed, then the next, and so on. This way, any actual tag in the HTML has a level, and all tags that are between the start and end tags are <em class="calibre12">below</em> this tag. Some tags that cannot enclose other tags or text do not have end tags and stand on their own. Consider the following sample:</p>
<pre class="calibre20">
&lt;html&gt; <br class="title-page-name"/>  &lt;head&gt; <br class="title-page-name"/>    &lt;title&gt;this is the title&lt;/title&gt; <br class="title-page-name"/>  &lt;/head&gt; <br class="title-page-name"/>&lt;/html&gt;
</pre>
<p class="calibre2">The tag <kbd class="calibre11">head</kbd> is under <kbd class="calibre11">html</kbd>, and <kbd class="calibre11">title</kbd> is under <kbd class="calibre11">head</kbd>. This can be structured into a tree, as follows:</p>
<pre class="calibre20">
html <br class="title-page-name"/>+ head <br class="title-page-name"/>  + title <br class="title-page-name"/>    + "this is the title"
</pre>
<p class="calibre2">The browser stores the HTML text in a tree structure, and this tree is the object model of the web page document, thus the name, <strong class="calibre1">Document Object Model</strong> (<strong class="calibre1">DOM</strong>) tree.</p>
<p class="calibre2">The original HTML concept mixed formatting and structure, and even with the current version of HTML5, we still have tags such as <kbd class="calibre11">b</kbd>, <kbd class="calibre11">i</kbd>, <kbd class="calibre11">tt</kbd> that suggest the browser to display the text between the start and end tags in bold, italics, and teletype, respectively.</p>
<p class="calibre2">As the name HTML, standing for Hypertext Markup Language, suggests, the text can contain references to other web pages in the form of hyperlinks. These links are assigned to texts using the <kbd class="calibre11">a</kbd> tag (standing for anchor) or to some form that may consist of different fields, and when the submit button of the form is pressed, the content of the fields is sent to the server in a <kbd class="calibre11">POST</kbd> request. When the form is sent, the content of the fields is encoded in the so-called <kbd class="calibre11">application/x-www-form-urlencoded</kbd> form.</p>
<p class="calibre2">The HTML structure always tried to promote the separation of structure and formatting. To do so, formatting was moved to styles. Styles defined in <strong class="calibre1">Cascading Style Sheets</strong> (<strong class="calibre1">CSS</strong>) provide much more flexibility for formatting than HTML; the format of a CSS is more effective for formatting. The aim to create CSS was that the design can be decoupled from the structure of the text. If I had to choose one of the three, I would opt for CSS as the one that is least important for Java server-side web developers and, at the same time, the most important for the users (things should look nice).</p>
<p class="calibre2">JavaScript is the third pillar of client-side technologies. JavaScript is a fully functional, interpreted programming language executed by the browser. It can access the DOM tree, and read and modify it. When the DOM tree is modified, the browser automatically displays the modified page. JavaScript functions can be scheduled and registered to be invoked when some event occurs. For example, you can register a function to be invoked when the document is fully loaded, when the user presses a button, clicks on a link, or just hovers the mouse over some section. Although JavaScript was first only used to create funny animations on the browser, today it is possible, and is a usual practice, to program fully functional clients using the capabilities of the browser. There are really powerful programs written in JavaScript, even such power-hungry applications as PC emulators.</p>
<p class="calibre2">In this book, we focus on Java and use the client-side technologies as much as is needed for demonstration technologies. However, being a Java web developer professional, you have to learn these technologies as well, to some extent at least, to understand what a client can do and to be able to cooperate with the professionals responsible for frontend technologies.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Mastermind servlet</h1>
            

            <article>
                
<p class="calibre2">Playing the Mastermind game via the Web is a bit different from what it used to be. Till now, we did not have any user interaction and our classes were designed accordingly. For example, we could add a new guess to the table, along with the partial and full matches calculated by the program. Now we have to separate the creation of a new guess, add it to the game, and set the full and partial matches. This time, we have to display the table first, and the user has to calculate and provide the number of matches.</p>
<p class="calibre2">We have to modify some of the classes to be able to do that. We need to add a new method to <kbd class="calibre11">Game.java</kbd>:</p>
<pre class="calibre20">
public Row addGuess(Guess guess, int full, int partial) { <br class="title-page-name"/>    assertNotFinished(); <br class="title-page-name"/>    final Row row = new Row(guess, full, partial); <br class="title-page-name"/>    table.addRow(row); <br class="title-page-name"/>    if (itWasAWinningGuess(full)) { <br class="title-page-name"/>        finished = true; <br class="title-page-name"/>    } <br class="title-page-name"/>    return row; <br class="title-page-name"/>}
</pre>
<p class="calibre2">Till now, we had only one method that was adding a new guess, and since the program knew the secret, it was immediately calculating the value of <kbd class="calibre11">full</kbd> and <kbd class="calibre11">partial</kbd>. The name of the method could be <kbd class="calibre11">addNewGuess</kbd>, overloading the original method, but this time, the method is used not only to add a new guess but also to add old guesses to rebuild the table.</p>
<p class="calibre2">When the program starts, there are no guesses. The program creates one, the first one. Later on, when the user tells the program the full and partial matches, the program needs the <kbd class="calibre11">Game</kbd> structure with <kbd class="calibre11">Table</kbd> and <kbd class="calibre11">Row</kbd> objects containing <kbd class="calibre11">Guess</kbd> objects and the <kbd class="calibre11">full</kbd> and <kbd class="calibre11">partial</kbd> match values. These were already available, but when the new HTTP hit comes in, we have to pull it from somewhere. Programming a servlet, we have to store the state of the game somewhere and restore it when a new HTTP request hits the server.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Storing state</h1>
            

            <article>
                
<p class="calibre2">Storing the state can be done in two places. One place, which we will first do in our code, is the client. When the program creates a new guess, it adds it to the table and sends an HTML page that contains not only the new guess but also all the previous guesses and the <kbd class="calibre11">full</kbd> and <kbd class="calibre11">partial</kbd> match values that the user gave for each of the rows. To send the data to the server, the values are stored in the fields of a form. When the form is submitted, the browser gathers the information in the fields, creates an encoded string from the content of the fields, and puts the content into the body of a <kbd class="calibre11">POST</kbd> request.</p>
<p class="calibre2">The other possibility for storing the actual state is in the server. The server can store the state of the game, and it can reconstruct the structure when it creates a new guess. The problem in this case is knowing which game to use. The server can and should store many games, one for each user, and users may use the application concurrently. It does not necessarily mean strong concurrency in the same meaning as we examined in the previous chapter.</p>
<p class="calibre2">Even if the users are not served at the same time in multiple threads, there can be games that are active. Imagine <kbd class="calibre11">cnn.com</kbd> telling you that you cannot read the news at the moment because somebody else is reading it. There can be multiple users playing multiple games, and while serving an HTTP request, we should know which user we are serving.</p>
<p class="calibre2">Servlets maintain sessions that can be used for this purpose as we will see in the next section.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">HTTP session</h1>
            

            <article>
                
<p class="calibre2">When a client sends requests from the same browser to the same servlet, the series of requests belong to one session. To know that the requests belong to the same session, the servlet container automatically sends a cookie named <kbd class="calibre11">JSESSIONID</kbd> to the client, and this cookie has a long, random, hard-to-guess value (<kbd class="calibre11">tkojxpz9qk9xo7124pvanc1z</kbd> as I run the application in Jetty). The servlet maintains a session store that contains the <kbd class="calibre11">HttpSession</kbd> instances. The key string that travels in the value of the <kbd class="calibre11">JSESSIONID</kbd> cookie identifies the instances. When an HTTP request arrives at the servlet, the container attaches the session to the request object from the store. If there is no session for the key, then one is created, and the code can access the session object by calling the <kbd class="calibre11">request.getSession()</kbd> method.</p>
<p class="calibre2">A <kbd class="calibre11">HttpSession</kbd> object can store attributes. The program can call the <kbd class="calibre11">setAttribute(String,Object)</kbd>, <kbd class="calibre11">getAttribute(String)</kbd>, and <kbd class="calibre11">removeAttribute(String)</kbd> methods to store, retrieve, or delete an attribute object. Each attribute is assigned to a <kbd class="calibre11">String</kbd> and can be any <kbd class="calibre11">Object</kbd>.</p>
<p class="calibre2">Although the session attribute store essentially looks as simple as a <kbd class="calibre11">Map&lt;String,?&gt;</kbd> object, it is not. The values stored in the session can be moved from one node to another when the servlet container runs in a clustered or other distributed environment. To do that, the values are serialized; therefore, the values stored in the session should be <kbd class="calibre11">Serializable</kbd>. Failing to do so is a very common novice error. During development, executing the code in a simple development Tomcat or Jetty container practically never serializes the session to disk and never loads it from the serialized form. This means that the values set using <kbd class="calibre11">setAttribute</kbd> will be available by calling <kbd class="calibre11">getAttribute</kbd>. We run into trouble the first time the application gets installed in a clustered environment. As soon as a HTTP request arrives on different nodes <kbd class="calibre11">getAttribute</kbd> may return <kbd class="calibre11">null</kbd>. The method <kbd class="calibre11">setAttribute</kbd> is called on one node and during the processing of the next request <kbd class="calibre11">getAttribute</kbd> on a different node cannot deserialize the attribute value from the disk shared among the nodes. This is usually, and sadly, the production environment.</p>
<p class="calibre2">You, as a developer, should also be aware that serializing and de-serializing an object is a heavy operation that costs several CPU cycles. If the structure of the application uses only a part of the client state serving most of the HTTP requests, then this is a waste of CPU to create the whole state in memory from a serialized form and then serializing it again. In such cases, it is more advisable to store only a key in the session and use some database (SQL or NoSQL) or some other service to store the actual data referenced by the key. Enterprise applications almost exclusively use this structure.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Storing state on the client</h1>
            

            <article>
                
<p class="calibre2">First, we will develop our code storing the state on the client. The form needed to send the user input and the number of new full and partial matches, also contains all the previous colors for all the guesses and answers given at that time by the user. To do so, we create a new helper class to format the HTML code. This is something that is done in a modern enterprise environment using templates, JSP files, or just totally avoided using pure REST and a one-page application in the enterprise environment. Nevertheless, here we will use the old technology in order to demonstrate the gears that rotate under the hood of modern engines:</p>
<pre class="calibre20">
package packt.java9.by.example.mastermind.servlet; <br class="title-page-name"/><br class="title-page-name"/>import packt.java9.by.example.mastermind.Color; <br class="title-page-name"/>import packt.java9.by.example.mastermind.Table; <br class="title-page-name"/><br class="title-page-name"/>import javax.inject.Inject; <br class="title-page-name"/>import javax.inject.Named; <br class="title-page-name"/><br class="title-page-name"/>public class HtmlTools { <br class="title-page-name"/>    @Inject <br class="title-page-name"/>    Table table; <br class="title-page-name"/><br class="title-page-name"/>    @Inject <br class="title-page-name"/>    @Named("nrColumns") <br class="title-page-name"/>    private int NR_COLUMNS; <br class="title-page-name"/><br class="title-page-name"/>    public String tag(String tagName, String... attributes) { <br class="title-page-name"/>        StringBuilder sb = new StringBuilder(); <br class="title-page-name"/>        sb.append("&lt;").append((tagName)); <br class="title-page-name"/>        for (int i = 0; i &lt; attributes.length; i += 2) { <br class="title-page-name"/>            sb.append(" "). <br class="title-page-name"/>                    append(attributes[i]). <br class="title-page-name"/>                    append("=\""). <br class="title-page-name"/>                    append(attributes[i + 1]). <br class="title-page-name"/>                    append("\""); <br class="title-page-name"/>        } <br class="title-page-name"/>        sb.append("&gt;"); <br class="title-page-name"/>        return sb.toString(); <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    public String inputBox(String name, String value) { <br class="title-page-name"/>        return tag("input", "type", "text", "name", name, "value", value, "size", "1"); <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    public String colorToHtml(Color color, int row, int column) { <br class="title-page-name"/>        return tag("input", "type", "hidden", "name", paramNameGuess(row, column), <br class="title-page-name"/>                "value", color.toString()) + <br class="title-page-name"/>                tag("div", "class", "color" + color) + <br class="title-page-name"/>                tag("/div") + <br class="title-page-name"/>                tag("div", "class", "spacer") + <br class="title-page-name"/>                tag("/div"); <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>    public String paramNameFull(int row) { <br class="title-page-name"/>        return "full" + row; <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    public String paramNamePartial(int row) { <br class="title-page-name"/>        return "partial" + row; <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    public String paramNameGuess(int row, int column) { <br class="title-page-name"/>        return "guess" + row + column; <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    public String tableToHtml() { <br class="title-page-name"/>        StringBuilder sb = new StringBuilder(); <br class="title-page-name"/>        sb.append("&lt;html&gt;&lt;head&gt;"); <br class="title-page-name"/>        sb.append("&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"colors.css\"&gt;"); <br class="title-page-name"/>        sb.append("&lt;title&gt;Mastermind guessing&lt;/title&gt;"); <br class="title-page-name"/>        sb.append("&lt;body&gt;"); <br class="title-page-name"/>        sb.append(tag("form", "method", "POST", "action", "master")); <br class="title-page-name"/><br class="title-page-name"/>        for (int row = 0; row &lt; table.nrOfRows(); row++) { <br class="title-page-name"/>            for (int column = 0; column &lt; NR_COLUMNS; column++) { <br class="title-page-name"/>                sb.append(colorToHtml(table.getColor(row, column), row, column)); <br class="title-page-name"/>            } <br class="title-page-name"/><br class="title-page-name"/>            sb.append(inputBox(paramNameFull(row), "" + table.getFull(row))); <br class="title-page-name"/>            sb.append(inputBox(paramNamePartial(row), "" + table.getPartial(row))); <br class="title-page-name"/>            sb.append("&lt;p&gt;"); <br class="title-page-name"/>        } <br class="title-page-name"/>        return sb.toString(); <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">Except the <kbd class="calibre11">@Inject</kbd> annotation, the rest of the code is simple and straightforward. We will focus on <kbd class="calibre11">@Inject</kbd> later but very soon. What we have to focus on is the HTML structure the code generates. The generated page will look something like this:</p>
<pre class="calibre20">
&lt;html&gt; <br class="title-page-name"/>    &lt;head&gt; <br class="title-page-name"/>        &lt;link rel="stylesheet" type="text/css" href="colors.css"&gt; <br class="title-page-name"/>        &lt;title&gt;Mastermind guessing&lt;/title&gt; <br class="title-page-name"/>        &lt;body&gt; <br class="title-page-name"/>            &lt;form method="POST" action="master"&gt; <br class="title-page-name"/>                &lt;input type="hidden" name="guess00" value="3"&gt; <br class="title-page-name"/>                &lt;div class="color3"&gt;&lt;/div&gt; <br class="title-page-name"/>                &lt;div class="spacer"&gt;&lt;/div&gt; <br class="title-page-name"/>                &lt;input type="hidden" name="guess01" value="2"&gt; <br class="title-page-name"/>                &lt;div class="color2"&gt;&lt;/div&gt; <br class="title-page-name"/>                &lt;div class="spacer"&gt;&lt;/div&gt; <br class="title-page-name"/>                &lt;input type="hidden" name="guess02" value="1"&gt; <br class="title-page-name"/>                &lt;div class="color1"&gt;&lt;/div&gt; <br class="title-page-name"/>                &lt;div class="spacer"&gt;&lt;/div&gt; <br class="title-page-name"/>                &lt;input type="hidden" name="guess03" value="0"&gt; <br class="title-page-name"/>                &lt;div class="color0"&gt;&lt;/div&gt; <br class="title-page-name"/>                &lt;div class="spacer"&gt;&lt;/div&gt; <br class="title-page-name"/>                &lt;input type="text" <br class="title-page-name"/>                       name="full0" value="0" size="1"&gt; <br class="title-page-name"/>                &lt;input type="text" <br class="title-page-name"/>                       name="partial0" value="2" size="1"&gt; <br class="title-page-name"/>                &lt;p&gt; <br class="title-page-name"/>                &lt;input type="hidden" name="guess10" value="5"&gt; <br class="title-page-name"/>                &lt;div class="color5"&gt;&lt;/div&gt; <br class="title-page-name"/><br class="title-page-name"/>...deleted content that just looks almost the same... <br class="title-page-name"/><br class="title-page-name"/>                &lt;p&gt; <br class="title-page-name"/>                &lt;input type="submit" value="submit"&gt; <br class="title-page-name"/>            &lt;/form&gt; <br class="title-page-name"/>        &lt;/body&gt; <br class="title-page-name"/>    &lt;/head&gt; <br class="title-page-name"/>&lt;/html&gt;
</pre>
<p class="calibre2">The form contains the colors in the form of DIV tags, and it also contains the "letter" of the color in hidden fields. These input fields are sent to the server when the form is submitted, just like any other field, but they do not appear on the screen and the user cannot edit them. The full and partial matches are displayed in the text input fields. Since it is not possible to display the <kbd class="calibre11">Color</kbd> objects in an HTML text, we use <kbd class="calibre11">LetteredColor</kbd> and <kbd class="calibre11">LetteredColorFactory</kbd>, which assign single letters to colors. The first 6 colors are simply numbered as <kbd class="calibre11">0</kbd>, <kbd class="calibre11">1</kbd>, <kbd class="calibre11">2</kbd>, <kbd class="calibre11">3</kbd>, <kbd class="calibre11">4</kbd> and <kbd class="calibre11">5</kbd>. A CSS file can control how the colors will look on the browser window. You may remember that we covered how and where to implement the display of individual colors. First, we created a special printing class that was assigning letters to already existing colors, but that was usable only in a very limited environment (unit tests mainly). Now, we have the issue again. We have the lettered color, but now we need real colors as this time we have a client display that is capable of displaying colors. The real power of modern web technology shines here. The content and the format can be separated from each other. The pegs of different colors are listed in HTML as <kbd class="calibre11">div</kbd> tags. They have a formatting class but the actual look is defined in a CSS file that is responsible for nothing else but the look:</p>
<pre class="calibre20">
.color0 { <br class="title-page-name"/>    background: red; <br class="title-page-name"/>    width : 20px; <br class="title-page-name"/>    height: 20px; <br class="title-page-name"/>    float:left <br class="title-page-name"/>} <br class="title-page-name"/>.color1 { <br class="title-page-name"/>    background-color: green; <br class="title-page-name"/>    width : 20px; <br class="title-page-name"/>    height: 20px; <br class="title-page-name"/>    float:left <br class="title-page-name"/>} <br class="title-page-name"/>... .color2 to .color5 is deleted, content is the same except different colors ... <br class="title-page-name"/><br class="title-page-name"/>.spacer { <br class="title-page-name"/>    background-color: white; <br class="title-page-name"/>    width : 10px; <br class="title-page-name"/>    height: 20px; <br class="title-page-name"/>    float:left <br class="title-page-name"/>}
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Dependency injection with Guice</h1>
            

            <article>
                
<p class="calibre2">The servlet class is very simple as shown in the following:</p>
<pre class="calibre20">
package packt.java9.by.example.mastermind.servlet; <br class="title-page-name"/><br class="title-page-name"/>import com.google.inject.Guice; <br class="title-page-name"/>import com.google.inject.Injector; <br class="title-page-name"/>import org.slf4j.Logger; <br class="title-page-name"/>import org.slf4j.LoggerFactory; <br class="title-page-name"/><br class="title-page-name"/>import javax.servlet.ServletException; <br class="title-page-name"/>import javax.servlet.http.HttpServlet; <br class="title-page-name"/>import javax.servlet.http.HttpServletRequest; <br class="title-page-name"/>import javax.servlet.http.HttpServletResponse; <br class="title-page-name"/>import java.io.IOException; <br class="title-page-name"/><br class="title-page-name"/>public class Mastermind extends HttpServlet { <br class="title-page-name"/>    private static final Logger log = LoggerFactory.getLogger(Mastermind.class); <br class="title-page-name"/><br class="title-page-name"/>    public void doGet(HttpServletRequest request, <br class="title-page-name"/>                      HttpServletResponse response) <br class="title-page-name"/>            throws ServletException, IOException { <br class="title-page-name"/>        doPost(request, response); <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    public void doPost(HttpServletRequest request, <br class="title-page-name"/>                       HttpServletResponse response) <br class="title-page-name"/>            throws ServletException, IOException { <br class="title-page-name"/><br class="title-page-name"/>        Injector injector =  <br class="title-page-name"/>            Guice.createInjector(new MastermindModule()); <br class="title-page-name"/>        MastermindHandler handler =  <br class="title-page-name"/>            injector.getInstance(MastermindHandler.class); <br class="title-page-name"/>        handler.handle(request, response); <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">Because many threads use servlets concurrently, and thus we cannot use instance fields holding data for a single hit, the servlet class does nothing else but create a new instance of a <kbd class="calibre11">MastermindHandler</kbd> class and invoke its <kbd class="calibre11">handle</kbd> method. Since there is a new instance of <kbd class="calibre11">MastermindHandler</kbd> for each request, it can store objects in fields specific to the request. To create a handler, we use the Guice library created by Google.</p>
<p class="calibre2">We have already talked about dependency injection. The handler needs a <kbd class="calibre11">Table</kbd> object to play, a <kbd class="calibre11">ColorManager</kbd> object to manage the colors, and a <kbd class="calibre11">Guesser</kbd> object to create a new guess, but creating these or fetching some prefabricated instances from somewhere is not the core functionality of the handler. The handler has to do one thing: handle the request; the instances needed to do this should be injected from outside. This is done by a <kbd class="calibre11">Guice</kbd> injector.</p>
<p class="calibre2">To use Guice, we have to list the library among the dependencies in <kbd class="calibre11">build.gradle</kbd>:</p>
<pre class="calibre20">
apply plugin: 'java' <br class="title-page-name"/>apply plugin: 'jetty' <br class="title-page-name"/><br class="title-page-name"/>repositories { <br class="title-page-name"/>    jcenter() <br class="title-page-name"/>} <br class="title-page-name"/><br class="title-page-name"/>dependencies { <br class="title-page-name"/>    providedCompile "javax.servlet:javax.servlet-api:3.1.0" <br class="title-page-name"/>    testCompile 'junit:junit:4.12' <br class="title-page-name"/>    compile 'org.slf4j:slf4j-api:1.7.7' <br class="title-page-name"/>    compile 'ch.qos.logback:logback-classic:1.0.11' <br class="title-page-name"/>    compile 'com.google.inject:guice:4.1.0' <br class="title-page-name"/>} <br class="title-page-name"/><br class="title-page-name"/>jettyRun { <br class="title-page-name"/>    contextPath '/hello' <br class="title-page-name"/>}
</pre>
<p class="calibre2">Then we have to create an <kbd class="calibre11">injector</kbd> instance that will do the injection. The injector is created with the following line in the servlet:</p>
<pre class="calibre20">
Injector injector = Guice.createInjector(new MastermindModule());
</pre>
<p class="calibre2">The instance of <kbd class="calibre11">MastermindModule</kbd> specifies what to inject where. This is essentially a configuration file in the Java format. Other dependency injector frameworks used, and use, XML and annotations to describe the injection binding and what to inject where, but Guice solely uses Java code. The following is the DI configuration code:</p>
<pre class="calibre20">
public class MastermindModule extends AbstractModule { <br class="title-page-name"/>    @Override <br class="title-page-name"/>    protected void configure() { <br class="title-page-name"/>        bind(int.class) <br class="title-page-name"/>          .annotatedWith(Names.named("nrColors")).toInstance(6); <br class="title-page-name"/>        bind(int.class) <br class="title-page-name"/>          .annotatedWith(Names.named("nrColumns")).toInstance(4); <br class="title-page-name"/>        bind(ColorFactory.class).to(LetteredColorFactory.class); <br class="title-page-name"/>        bind(Guesser.class).to(UniqueGuesser.class); <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">The methods used in the <kbd class="calibre11">configure</kbd> method are created in a fluent API manner so that the methods can be chained one after the other and that the code can be read almost like English sentences. A good introduction to fluent API can be found at <a href="https://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-course/" class="calibre6"><span>https://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-course/</span></a>. For example, the first configuration line could be read in English as</p>
<p class="calibre2"><em class="calibre12">Bind to the class</em> <kbd class="calibre11">int</kbd> <em class="calibre12">wherever it is annotated with the</em> <kbd class="calibre11">@Name</kbd> <em class="calibre12">annotation having value</em> <kbd class="calibre11">"nrColor"</kbd> <em class="calibre12">to the instance</em> <kbd class="calibre11">6</kbd>.</p>
<p class="calibre2">(Note that the <kbd class="calibre11">int</kbd> value <kbd class="calibre11">6</kbd> is autoboxed to an <kbd class="calibre11">Integer</kbd> instance.)</p>
<p class="calibre2">The <kbd class="calibre11">MastermindHandler</kbd> class contains fields annotated with <kbd class="calibre11">@Inject</kbd> annotation:</p>
<pre class="calibre20">
@Inject <br class="title-page-name"/>@Named("nrColors") <br class="title-page-name"/>private int NR_COLORS; <br class="title-page-name"/>@Inject <br class="title-page-name"/>@Named("nrColumns") <br class="title-page-name"/>private int NR_COLUMNS; <br class="title-page-name"/>@Inject <br class="title-page-name"/>private HtmlTools html; <br class="title-page-name"/>@Inject <br class="title-page-name"/>Table table; <br class="title-page-name"/>@Inject <br class="title-page-name"/>ColorManager manager; <br class="title-page-name"/>@Inject <br class="title-page-name"/>Guesser guesser;
</pre>
<p class="calibre2">This annotation is not Guice-specific. <kbd class="calibre11">@Inject</kbd> is a part of the <kbd class="calibre11">javax.inject</kbd> package and is a standard part of JDK. JDK does not provide the <strong class="calibre1">dependency injector</strong> (<strong class="calibre1">DI</strong>) framework but supports the different frameworks so that they can use standard JDK annotations, and in case the DI framework is replaced, the annotations may remain the same and not framework-specific.</p>
<p class="calibre2">When the injector is called to create an instance of <kbd class="calibre11">MastermindHandler</kbd>, it looks at the class and sees that it has an <kbd class="calibre11">int</kbd> field annotated with <kbd class="calibre11">@Inject</kbd> and <kbd class="calibre11">@Named("nrColors")</kbd>, and finds in the configuration that such a field should have the value 6. It injects the value to the field before returning the <kbd class="calibre11">MastermindHandler</kbd> object. Similarly, it also injects the values into the other fields, and if it should create any of the objects to be injected, it does. If there are fields in these objects, then they are also created by injecting other objects and so on.</p>
<p class="calibre2">This way the DI framework removes the burden from the programmers' shoulder to create the instances. This is something fairly boring and is not the core feature of the classes anyway. Instead, it creates all the objects needed to have a functional <kbd class="calibre11">MastermindHandler</kbd> and links them together via the Java object references. This way, the dependencies of the different objects (<kbd class="calibre11">MastermindHandler</kbd> needs <kbd class="calibre11">Guesser</kbd>, <kbd class="calibre11">ColorManager</kbd>, and <kbd class="calibre11">Table</kbd>; <kbd class="calibre11">ColorManager</kbd> needs <kbd class="calibre11">ColorFactory</kbd>; and <kbd class="calibre11">Table</kbd> also needs <kbd class="calibre11">ColorManager</kbd>, and so on) become a declaration, specified using annotations on the fields. These declarations are inside the code of the classes, and it is the right place for them. Where else could we specify what the class needs to properly function than in the class itself?</p>
<p class="calibre2">The configuration in our example specifies that wherever there is a need for <kbd class="calibre11">ColorFactory</kbd>, we will use <kbd class="calibre11">LetteredColorFactory</kbd>, and that wherever we need <kbd class="calibre11">Guesser</kbd>, we will use <kbd class="calibre11">UniqueGuesser</kbd>. This is separated from the code and it has to be like that. If we want to change the guessing strategy, we replace the configuration and the code should work without modifying the classes that use the guesser.</p>
<p class="calibre2">Guice is clever enough and you need not specify that <span>wherever</span> there is a need for <kbd class="calibre11">Table</kbd>, we will use <kbd class="calibre11">Table</kbd>: there is no <kbd class="calibre11">bind(Table.class).to(Table.class)</kbd>. First I created a line like that in the configuration, but Guice rewarded me with an error message, and now, writing it again in plain English, I feel really stupid. If I need a table I need a table. Really?</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The MastermindHandler class</h1>
            

            <article>
                
<p class="calibre2">We have already started the listing of the <kbd class="calibre11">MastermindHandler</kbd> class, and since this class is more than a hundred lines, I will not include it here as a whole. The most important method of this class is <kbd class="calibre11">handle</kbd>:</p>
<pre class="calibre20">
public void handle(HttpServletRequest request, <br class="title-page-name"/>                   HttpServletResponse response) <br class="title-page-name"/>        throws ServletException, IOException { <br class="title-page-name"/><br class="title-page-name"/>    Game game = buildGameFromRequest(request); <br class="title-page-name"/>    Guess newGuess = guesser.guess(); <br class="title-page-name"/>    response.setContentType("text/html"); <br class="title-page-name"/>    PrintWriter out = response.getWriter(); <br class="title-page-name"/>    if (game.isFinished() || newGuess == Guess.none) { <br class="title-page-name"/>        displayGameOver(out); <br class="title-page-name"/>    } else { <br class="title-page-name"/>        log.debug("Adding new guess {} to the game", newGuess); <br class="title-page-name"/>        game.addGuess(newGuess, 0, 0); <br class="title-page-name"/>        displayGame(out); <br class="title-page-name"/>    } <br class="title-page-name"/>    bodyEnd(out); <br class="title-page-name"/>}
</pre>
<p class="calibre2">We perform three steps. Step 1 is creating the table and we do it from the request. If this is not the start of the game, there is already a table and the HTML form contains all previous guess colors and the answers to those. Then, as the second step, we create a new guess based on that. Step 3 is to send the new HTML page to the client.</p>
<div class="packtinfobox">Again, this is not a modern approach, creating HTML on the servlet code, but demonstrating pure servlet functionality with REST, JSON, and JavaScript with some framework would make this chapter alone a few hundred pages long, and it would definitely distract our focus from Java.</div>
<p class="calibre2">Printing HTML text to a <kbd class="calibre11">PrintWriter</kbd> is not something that should be new to you at this point in this book; therefore, we will not list that code here. You can download the working example on GitHub. The branch for this version of the code is <kbd class="calibre11">nosession</kbd>. Instead of printing, we will focus on the servlet parameter handling.</p>
<p class="calibre2">The request parameters are available via the <kbd class="calibre11">getParameter</kbd> method, which returns the string value of a parameter. This method assumes that any parameter, be it <kbd class="calibre11">GET</kbd> or <kbd class="calibre11">POST</kbd>, appears only once in the request. In case there are parameters that appear multiple times, the value should have been a string array. In such a case, we should use <kbd class="calibre11">getParameterMap</kbd>, which returns the whole map with the <kbd class="calibre11">String</kbd> keys and <kbd class="calibre11">String[]</kbd> values. Even though we do not have multiple values for any key this time, and we also know the values of the keys coming as <kbd class="calibre11">POST</kbd> parameters, we will still use the latter method. The reason for this is that we will later use the session to store these values, and we want to have a method that is reusable in that case.</p>
<div class="packttip">If you look at the earlier commits in the Git repository, you will see that the first version used <kbd class="calibre22">getParameter</kbd> and I refactored it only later when I created the second version of the program, which stores the state in a session. Never believe if anyone tells you that programs are created perfectly upfront without any refactoring during development. Do not feel ashamed to create foolish code and refactor it later. It is only shameful if you do not refactor it.</div>
<p class="calibre2">To get to that we convert the request's <kbd class="calibre11">Map&lt;String,String[]&gt;</kbd> to <kbd class="calibre11">Map&lt;String,String&gt;</kbd>:</p>
<pre class="calibre20">
private Game buildGameFromRequest(HttpServletRequest request) { <br class="title-page-name"/>    return buildGameFromMap(toMap(request)); <br class="title-page-name"/>} <br class="title-page-name"/>private Map&lt;String, String&gt; toMap(HttpServletRequest request) { <br class="title-page-name"/>    log.debug("converting request to map"); <br class="title-page-name"/>    return request.getParameterMap().entrySet(). <br class="title-page-name"/>            stream().collect( <br class="title-page-name"/>                    Collectors.toMap( <br class="title-page-name"/>                            Map.Entry::getKey, <br class="title-page-name"/>                            e -&gt; e.getValue()[0])); <br class="title-page-name"/>}
</pre>
<p class="calibre2">Then, we use that map to re-create the game:</p>
<pre class="calibre20">
private Game buildGameFromMap(Map&lt;String, String&gt; params) { <br class="title-page-name"/>    final Guess secret = new Guess(new Color[NR_COLUMNS]); <br class="title-page-name"/>    final Game game = new Game(table, secret); <br class="title-page-name"/>    for (int row = 0; <br class="title-page-name"/>         params.containsKey(html.paramNameGuess(row, 0)); <br class="title-page-name"/>         row++) { <br class="title-page-name"/>        Color[] colors = getRowColors(params, row); <br class="title-page-name"/>        Guess guess = new Guess(colors); <br class="title-page-name"/>        final int full = Integer.parseInt(params.get(html.paramNameFull(row))); <br class="title-page-name"/>        final int partial = Integer.parseInt(params.get(html.paramNamePartial(row))); <br class="title-page-name"/>        log.debug("Adding guess to game"); <br class="title-page-name"/>        game.addGuess(guess, full, partial); <br class="title-page-name"/>    } <br class="title-page-name"/>    return game; <br class="title-page-name"/>}
</pre>
<div class="packttip">The conversion from <kbd class="calibre22">String</kbd> to <kbd class="calibre22">int</kbd> is done via the method <kbd class="calibre22">parseInt</kbd>. This method throws <kbd class="calibre22">NumberFormatException</kbd> when the input is not a number. Try to run the game, use the browser, and see how Jetty handles the case when the servlet throws an exception. How much valuable information do you see in the browser that can be used by a potential hacker? Fix the code so that it asks the user again if any of the numbers are not well formatted!</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Storing state on the server</h1>
            

            <article>
                
<p class="calibre2">The application state should <span>usually</span> not be saved on the client. There may be some special case in addition to the one where you write educational code and want to demonstrate how to do it. Generally, the state of the application related to the actual use is stored in the session object or on some database. This is especially important when the application requests the user to enter a lot of data and does not want the user to lose the work if there is some hiccup in the client computer.</p>
<p class="calibre2">You spend a lot of time selecting the appropriate items in an online shop, choosing the appropriate items that work together, creating a configuration of your new model airplane, and all of a sudden, there is a blackout in your home. If the state were stored on the client you'd have had to start from scratch. If the state is stored on the server, the state is saved to disk; the servers are duplicated, fed by battery-backed power supplies, and when you reboot your client machine when the power comes back in your home, you log in, and miraculously, the items are all there in your shopping basket. Well, it is not a miracle; it is web programming.</p>
<p class="calibre2">In our case, the second version will store the state of the game in the session. This will let the user have the game restore so long as the session is there. If the user quits and restarts the browser, the session gets lost and a new game can start.</p>
<p class="calibre2">Since there is no need to send the actual colors and matching in hidden fields this time, the HTML generation is modified a bit, and the generated HTML will also be simpler:</p>
<pre class="calibre20">
&lt;html&gt; <br class="title-page-name"/>&lt;head&gt; <br class="title-page-name"/>    &lt;link rel="stylesheet" type="text/css" href="colors.css"&gt; <br class="title-page-name"/>    &lt;title&gt;Mastermind guessing&lt;/title&gt; <br class="title-page-name"/>&lt;body&gt; <br class="title-page-name"/>&lt;form method="POST" action="master"&gt; <br class="title-page-name"/>    &lt;div class="color3"&gt;&lt;/div&gt; <br class="title-page-name"/>    &lt;div class="spacer"&gt;&lt;/div&gt; <br class="title-page-name"/>    &lt;div class="color2"&gt;&lt;/div&gt; <br class="title-page-name"/>    &lt;div class="spacer"&gt;&lt;/div&gt; <br class="title-page-name"/>    &lt;div class="color1"&gt;&lt;/div&gt; <br class="title-page-name"/>    &lt;div class="spacer"&gt;&lt;/div&gt; <br class="title-page-name"/>    &lt;div class="color0"&gt;&lt;/div&gt; <br class="title-page-name"/>    &lt;div class="spacer"&gt;&lt;/div&gt;0 <br class="title-page-name"/>    &lt;div class="spacer"&gt;&lt;/div&gt;2&lt;p&gt; <br class="title-page-name"/>    &lt;div class="color5"&gt;&lt;/div&gt; <br class="title-page-name"/>... <br class="title-page-name"/>    &lt;div class="spacer"&gt;&lt;/div&gt; <br class="title-page-name"/>    &lt;div class="color1"&gt;&lt;/div&gt; <br class="title-page-name"/>    &lt;div class="spacer"&gt;&lt;/div&gt; <br class="title-page-name"/>    &lt;input type="text" name="full2" value="0" size="1"&gt;&lt;input type="text" name="partial2" value="0" size="1"&gt; <br class="title-page-name"/>    &lt;p&gt; <br class="title-page-name"/>        &lt;input type="submit" value="submit"&gt; <br class="title-page-name"/>&lt;/form&gt; <br class="title-page-name"/>&lt;/body&gt; <br class="title-page-name"/>&lt;/head&gt;&lt;/html&gt;
</pre>
<p class="calibre2">The number of full and partially matching colors is displayed as a simple number, so this version does not allow <em class="calibre12">cheating</em> or changing previous results. (These are the numbers <kbd class="calibre11">0</kbd> and <kbd class="calibre11">2</kbd> after the <kbd class="calibre11">div</kbd> tags that have the CSS class <kbd class="calibre11">spacer</kbd>.)</p>
<p class="calibre2">The <kbd class="calibre11">handle</kbd> method in <kbd class="calibre11">MastermindHandler</kbd> also changes, as shown in the following:</p>
<pre class="calibre20">
public void handle(HttpServletRequest request, <br class="title-page-name"/>                   HttpServletResponse response) <br class="title-page-name"/>        throws ServletException, IOException { <br class="title-page-name"/><br class="title-page-name"/>    Game game = buildGameFromSessionAndRequest(request); <br class="title-page-name"/>    Guess newGuess = guesser.guess(); <br class="title-page-name"/>    response.setContentType("text/html"); <br class="title-page-name"/>    PrintWriter out = response.getWriter(); <br class="title-page-name"/>    if (game.isFinished() || newGuess == Guess.none) { <br class="title-page-name"/>        displayGameOver(out); <br class="title-page-name"/>    } else { <br class="title-page-name"/>        log.debug("Adding new guess {} to the game", newGuess); <br class="title-page-name"/>        game.addGuess(newGuess, 0, 0); <br class="title-page-name"/>        sessionSaver.save(request.getSession()); <br class="title-page-name"/>        displayGame(out); <br class="title-page-name"/>    } <br class="title-page-name"/>    bodyEnd(out); <br class="title-page-name"/>}
</pre>
<p class="calibre2">This version of the class gets a <kbd class="calibre11">SessionSaver</kbd> object injected by the Guice injector. This is a class that we create. This class will convert the current Table into something that is stored in the session, and it also recreates the table from the data stored in the session. The <kbd class="calibre11">handle</kbd> method uses the <kbd class="calibre11">buildGameFromSessionAndRequest</kbd> method to restore the table and to add the full and partial match answers that the user just gave in the request. When the method creates a new guess and fills it in the table, and also sends it to the client in the response, it saves the state in the session by calling the <kbd class="calibre11">save</kbd> method via the <kbd class="calibre11">sessionSaver</kbd> object.</p>
<p class="calibre2">The <kbd class="calibre11">buildGameFromSessionAndRequest</kbd> method replaces the other version, which we named <kbd class="calibre11">buildGameFromRequest</kbd>:</p>
<pre class="calibre20">
private Game buildGameFromSessionAndRequest(HttpServletRequest request) { <br class="title-page-name"/>    Game game = buildGameFromMap(sessionSaver.restore(request.getSession())); <br class="title-page-name"/>    Map&lt;String, String&gt; params = toMap(request); <br class="title-page-name"/>    int row = getLastRowIndex(params); <br class="title-page-name"/>    log.debug("last row is {}", row); <br class="title-page-name"/>    if (row &gt;= 0) { <br class="title-page-name"/>        final int full = Integer.parseInt(params.get(html.paramNameFull(row))); <br class="title-page-name"/>        final int partial = Integer.parseInt(params.get(html.paramNamePartial(row))); <br class="title-page-name"/>        log.debug("setting full {} and partial {} for row {}", full, partial, row); <br class="title-page-name"/>        table.setPartial(row, partial); <br class="title-page-name"/>        table.setFull(row, full); <br class="title-page-name"/>        if (full == table.nrOfColumns()) { <br class="title-page-name"/>            game.setFinished(); <br class="title-page-name"/>        } <br class="title-page-name"/>    } <br class="title-page-name"/>    return game; <br class="title-page-name"/>}
</pre>
<p class="calibre2">Note that this version has the same illness of using the <kbd class="calibre11">parseInt</kbd> method from the <kbd class="calibre11">Integer</kbd> class in JDK, which throws an exception.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The GameSessionSaver class</h1>
            

            <article>
                
<p class="calibre2">This class has three public methods:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre11">save</kbd>: This saves a table to the user session</li>
<li class="calibre15"><kbd class="calibre11">restore</kbd>: This gets a table from the user session</li>
<li class="calibre15"><kbd class="calibre11">reset</kbd>: This deletes any table that may be in the session</li>
</ul>
<p class="calibre2">The code of the class is the following:</p>
<pre class="calibre20">
public class GameSessionSaver { <br class="title-page-name"/>    private static final String STATE_NAME = "GAME_STATE"; <br class="title-page-name"/>    @Inject <br class="title-page-name"/>    private HtmlTools html; <br class="title-page-name"/>    @Inject <br class="title-page-name"/>    Table table; <br class="title-page-name"/>    @Inject <br class="title-page-name"/>    ColorManager manager; <br class="title-page-name"/><br class="title-page-name"/>    public void save(HttpSession session) { <br class="title-page-name"/>        Map&lt;String,String&gt; params = convertTableToMap(); <br class="title-page-name"/>        session.setAttribute(STATE_NAME,params); <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    public void reset(HttpSession session) { <br class="title-page-name"/>        session.removeAttribute(STATE_NAME); <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    public Map&lt;String,String&gt; restore(HttpSession session){ <br class="title-page-name"/>        Map&lt;String,String&gt; map= <br class="title-page-name"/>                    (Map&lt;String,String&gt;) <br class="title-page-name"/>                            session.getAttribute(STATE_NAME); <br class="title-page-name"/>        if( map == null ){ map = new HashMap&lt;&gt;(); } <br class="title-page-name"/>        return map; <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    private Map&lt;String,String&gt; convertTableToMap() { <br class="title-page-name"/>        Map&lt;String, String&gt; params = new HashMap&lt;&gt;(); <br class="title-page-name"/>        for (int row = 0; row &lt; table.nrOfRows(); row++) { <br class="title-page-name"/>            for (int column = 0; <br class="title-page-name"/>                 column &lt; table.nrOfColumns(); column++) { <br class="title-page-name"/>                params.put(html.paramNameGuess(row,column), <br class="title-page-name"/>                           table.getColor(row,column).toString()); <br class="title-page-name"/>            } <br class="title-page-name"/>            params.put(html.paramNameFull(row), <br class="title-page-name"/>                           ""+table.getFull(row)); <br class="title-page-name"/>            params.put(html.paramNamePartial(row), <br class="title-page-name"/>                           ""+table.getPartial(row)); <br class="title-page-name"/>        } <br class="title-page-name"/>        return params; <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">When we save the session and convert the table to a map, we use a <kbd class="calibre11">HashMap</kbd>. The implementation in this case is important. The <kbd class="calibre11">HashMap</kbd> class implements the <kbd class="calibre11">Serializable</kbd> interface; therefore, we can be safe putting it to the session. This alone does not guarantee that everything in <kbd class="calibre11">HashMap</kbd> is <kbd class="calibre11">Serializable</kbd>. The keys and the values in our case are Strings, and fortunately, the <kbd class="calibre11">String</kbd> class also implements the <kbd class="calibre11">Serializable</kbd> interface. This way, the converted <kbd class="calibre11">HashMap</kbd> object can be safely stored in the session.</p>
<p class="calibre2">Also note that, although serialization can be slow, storing <kbd class="calibre11">HashMap</kbd> in a session is so frequent that it implements its own serialization mechanism. This implementation is optimized and avoids serialization being dependent on the internal structure of the map.</p>
<div class="packtinfobox">It is time to think about why we have the <kbd class="calibre22">convertTableToMap</kbd> method in this class and <kbd class="calibre22">buildGameFromMap</kbd> in <kbd class="calibre22">MastermindHandler</kbd>. Converting the game and the table in it to a <kbd class="calibre22">Map</kbd> and the other way round should be implemented together. They are just two directions of the same conversion. On the other hand, the implementation of the <kbd class="calibre22">Table</kbd> to <kbd class="calibre22">Map</kbd> direction should use a <kbd class="calibre22">Map</kbd> version that is <kbd class="calibre22">Serializable</kbd>. This is very much related to session handling. Converting a <kbd class="calibre22">Map</kbd> object, in general, to a <kbd class="calibre22">Table</kbd> object is one level higher, restoring the table from wherever it was stored: client, session, database, or in the moisture of the cloud. Session storage is only one possible implementation, and methods should be implemented in the class that meets the abstraction level.<br class="calibre23"/>
The best solution could be to implement these in a separate class. You have homework!</div>
<p class="calibre2">The <kbd class="calibre11">reset</kbd> method is not used from the handler. This is invoked from the <kbd class="calibre11">Mastermind</kbd> class, that is, the servlet class to reset the game when we start it:</p>
<pre class="calibre20">
public void doGet(HttpServletRequest request, <br class="title-page-name"/>                  HttpServletResponse response) <br class="title-page-name"/>        throws ServletException, IOException { <br class="title-page-name"/>    GameSessionSaver sessionSaver = new GameSessionSaver(); <br class="title-page-name"/>    sessionSaver.reset(request.getSession()); <br class="title-page-name"/>    doPost(request, response); <br class="title-page-name"/>}
</pre>
<p class="calibre2">Without this, playing the game against the machine once would just display the finished game every time we want to start it again, until we exit the browser and restart it or explicitly delete the <kbd class="calibre11">JSESSIONID</kbd> cookie somewhere in the advanced menu of the browser. Calling <kbd class="calibre11">reset</kbd> does not delete the session. The session remains the same, and thus the value of <kbd class="calibre11">JSESSIONID</kbd> too, but the game is deleted from the session object that the servlet container maintains.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Running the Jetty web servlet</h1>
            

            <article>
                
<p class="calibre2">Since we have included the Jetty plugin into our Gradle build, the targets of the plugin are available. To start Jetty is as easy as typing the following:</p>
<pre class="calibre20">
    <strong class="calibre1">gradle jettyRun</strong>
</pre>
<p class="calibre2">This will compile the code, build the WAR file, and start the Jetty servlet container. To help us remember, it also prints the following on the command line:</p>
<pre class="calibre20">
    <strong class="calibre1">Running at http://localhost:8080//hello</strong>
</pre>
<p class="calibre2">We can open this URL and see the opening screen of the game with the colors that the program created as a first guess:</p>
<div class="packtfigure"><img class="image-border33" src="../images/00046.jpeg"/></div>
<p class="calibre2">Now it is time to have some fun and play with our game, giving answers to the program. Do not make it easy for the code! Refer to the following screenshot:</p>
<div class="packtfigure"><img class="image-border34" src="../images/00047.jpeg"/></div>
<p class="calibre2">At the same time, if you look at the console where you have typed <kbd class="calibre11">gradle jettyRun</kbd>, you will see that the code is printing out log messages, as shown in the following screenshot:</p>
<div class="packtfigure"><img class="image-border" src="../images/00048.gif"/></div>
<p class="calibre2">These printouts come through the logger that we have in our code. In the previous chapters, we used the <kbd class="calibre11">System.out.println</kbd> method calls to send informational messages to the console. This is a practice that should not be followed in any program that is more complex than a <em class="calibre12">hello world</em></p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Logging</h1>
            

            <article>
                
<p class="calibre2">There are several logging frameworks available for Java and each has advantages and disadvantages. There is one built into JDK in the <kbd class="calibre11">java.util.logging</kbd> package and accessing the logger is supported by the <kbd class="calibre11">System.getLogger</kbd> method: the <kbd class="calibre11">System.Logger</kbd> and <kbd class="calibre11">System.LoggerFinder</kbd> classes. Even though <kbd class="calibre11">java.util.logging</kbd> has been available in Java since JDK 1.4, a lot of programs use other logging solutions. In addition to the built-in logging, we have to mention <kbd class="calibre11">log4j</kbd>, <kbd class="calibre11">slf4j</kbd> and Apache Commons Logging. Before getting into the details of the different frameworks, let's discuss why it is important to use logging instead of just printing to the standard output.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Configurability</h1>
            

            <article>
                
<p class="calibre2">The most important reason is configurability and ease of use. We use logging to record information about the operation of code. This is not the core functionality of the application but is inevitable to have a program that can be operated. There are messages we print out to the log, which can be used by the operating personnel to identify environmental issues. For example, when an <kbd class="calibre11">IOException</kbd> is thrown and it gets logged, the operation may look at the logs and identify that the disk got full. They may delete files, or add a new disk and extend the partition. Without the logs, the only information would be that the program does not work.</p>
<p class="calibre2">The logs are also used many times to hunt down bugs. Some of the bugs do not manifest in the test environment and are very difficult to reproduce. In such a case, the logs that print out detailed information about the execution of the code are the only source of finding the root cause of some error.</p>
<p class="calibre2">Since logging needs CPU, IO bandwidth, and other resources, it should be carefully examined what and when to log. This examination and the decisions could be done during programming, and as a matter of fact, that is the only possibility if we used <kbd class="calibre11">System.out.println</kbd> for logging. If we need to find a bug, we should log a lot. If we log a lot, the performance of the system will go down. The conclusion is that we have to log only if it is needed. If there is a bug in the system that cannot be reproduced, the developers ask the operation to switch on debug logging for a short period. Switching on and off different parts of logging is not possible when <kbd class="calibre11">System.out.println</kbd> is used. When the debug level log is switched on, the performance may go down for a while, but at the same time, the logs become available for analysis. At the same time, the analysis is simpler when we have to find the log lines that are relevant (and you do not know beforehand which are relevant) if there is a small (a few hundred megabytes log file) rather than a lot of 2-GB compressed log files to find the lines in.</p>
<p class="calibre2">Using a log framework, you can define loggers that identify the source of the log messages and log levels. A string usually identifies the logger, and it is a common practice to use the name of the class from which the log message is created. This is such a common practice that the different log frameworks provide factory classes that get the class itself, instead of its name, to get a logger.</p>
<p class="calibre2">The possible logging levels may be slightly different in different logging frameworks, but the most important levels are as follows:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre11">FATAL</kbd>: This is used when the log message is about some error that prevents the program from continuing its execution.</li>
<li class="calibre15"><kbd class="calibre11">ERROR</kbd>: This is used when there is some severe error, but the program can still go on functioning although, probably, in some limited manner.</li>
<li class="calibre15"><kbd class="calibre11">WARNING</kbd>: This is used when there is some condition that is not a direct problem but may later lead to an error if not attended. For example, the program recognizes that a disk is near full, some database connections answer within limits but close to the timeout value, and similar situations.</li>
<li class="calibre15"><kbd class="calibre11">INFO</kbd>: This is used to create messages about normal operations that may be interesting to operate and are not an error or warning. These messages may help the operation to debug the operational environment settings.</li>
<li class="calibre15"><kbd class="calibre11">DEBUG</kbd>: This is used to log information about the program that is detailed enough (hopefully) to find a bug in the code. The trick is that when we put the log statement into the code, we do not know what bug it could be. If we knew, we better fixed it.</li>
<li class="calibre15"><kbd class="calibre11">TRACE</kbd>: This is even more detailed information about the execution of the code.</li>
</ul>
<p class="calibre2">The log frameworks are usually configured using some configuration file. The configuration may limit the logging, switching off certain levels. In a normal operational environment, the first three levels are usually switched on, and <kbd class="calibre11">INFO</kbd>, <kbd class="calibre11">DEBUG</kbd>, and <kbd class="calibre11">TRACE</kbd> are switched on when really needed. It is also possible to switch on and off certain levels only for certain loggers. If we know that the error is certainly in the <kbd class="calibre11">GameSessionSaver</kbd> class, then we can switch on the <kbd class="calibre11">DEBUG</kbd> level only for that class.</p>
<p class="calibre2">Log files may also contain other information that we did not directly code and would be very cumbersome to print to the standard output. Usually, each log message contains the precise time when the message was created, the name of the logger, and, many times, the identifier of the thread. Imagine if you were forced to put all this to each and every <kbd class="calibre11">println</kbd> argument; you would probably soon write some extra class to do that. Don't! It has already been done professionally: it is the logger framework.</p>
<p class="calibre2">Loggers can also be configured to send the message to different locations. Logging to the console is only one possibility. Logging frameworks are prepared to send messages to files, database, Windows Event Recorder, syslog service, or to any other target. This flexibility, which message to print, what extra information to print, and where to print is reached by separating the different tasks that the logger framework does into several classes following the single responsibility principle.</p>
<p class="calibre2">The logger frameworks usually contain loggers that create the logs, formatters that format the message from the original log information, many times, adding information such as thread ID and time stamp, and appenders that append the formatted message to some destination. These classes implement interfaces defined in the logging framework and nothing but the size of the book stops us from creating our own formatters and appenders.</p>
<p class="calibre2">When a log is configured, the appenders and formatters are configured, given the class that implements them. Therefore, when you want to send some logs to some special destination, you are not limited to the appenders that are provided by the authors of the framework. There are a lot of independent open-source projects for different logging frameworks providing appenders for different targets.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Performance</h1>
            

            <article>
                
<p class="calibre2">The second reason to use a logging framework is performance. Although it is not good to optimize for performance before we profile the code (premature optimization), using some methodology known to be slow and inserting several lines into our performance-critical code, invoking slow methods is not really professional either. Using a well-established, highly optimized framework in a way that is industry best practice should not be questionable.</p>
<p class="calibre2">Using <kbd class="calibre11">System.out.println</kbd> sends the message to a stream and returns only when the IO operation is done. Using real logging handles the information to the logger and lets the logger do the logging asynchronously, and it does not wait for completion. It is really a drawback that log information may be lost if there is some system failure, but this is usually not a serious issue considering how rarely that happens and what is on the other side of the wage: performance. What do we lose if there is a missing debug log line when the disk got full, anyway rendering the system unusable?</p>
<div class="packttip">There is one exception to this: audit logging—when some log information about the transactions of the system has to be saved for legal reasons so that the operation and the actual transactions can be audited. In such a case, the log information is saved in a transactional manner, making the log part of the transaction. Because that is a totally different type of requirement, audit logging is not usually done with any of these frameworks.</div>
<p class="calibre2">Also, <kbd class="calibre11">System.out.println</kbd> is not synchronized and that way different threads may just garble the output. Log frameworks pay attention to this issue.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Log frameworks</h1>
            

            <article>
                
<p class="calibre2">The most widely used logging framework is <strong class="calibre1">Apache</strong><strong class="calibre1">log4j</strong>. It currently has a second version that is a total rewrite of the first version. It is very versatile and has many appenders and formatters. The configuration of log4j can be in XML or properties file format, and it can also be configured through API.</p>
<p class="calibre2">The author of log4j version 1 created a new logging framework: <strong class="calibre1">slf4j</strong>. This logging library is essentially a façade that can be used together with any other logging framework. Thus, when you use slf4j in a library you develop, and your code is added to a program as a dependency that uses a different logging framework, it is easy to configure slf4j to send the logs to the loggers of the other framework. Thus, the logs will be handled together and not in separate file, which is desirable to decrease the cost of operation. When developing your library code or an application that uses slf4j, there is no need to select another log framework to slf4j. It has its own simple implementation called backlog.</p>
<p class="calibre2">Apache Commons Logging is also a façade with its own logging implementation if nothing else fails. The major difference from slf4j is that it is more flexible in configuration and what underlying logging to use, and it implements a run-time algorithm to discover which logging framework is available and is to be used. The industry best practice shows that this flexibility, which also comes with higher complexity and cost, is not needed.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Java 9 logging</h1>
            

            <article>
                
<p class="calibre2">Java 9 includes a facade implementation for logging. The use is very simple and we can expect that logging frameworks will very soon start to support this façade. The fact that this façade is built into the JDK has two major advantage:</p>
<ul class="calibre14">
<li class="calibre15">The libraries that want to log do not need to have any dependency on any logging framework or logging façade any more. The only dependency is the JDK log façade that is there anyway.</li>
<li class="calibre15">The JDK libraries that log themselves use this façade and thus they will log into the same log file as the application.</li>
</ul>
<p class="calibre2">If we use the JDK-provided logging façade the start of the <kbd class="calibre11">ColorManager</kbd> class will be changed to the following:</p>
<pre class="calibre20">
package packt.java9.by.example.mastermind; <br class="title-page-name"/><br class="title-page-name"/>import javax.inject.Inject; <br class="title-page-name"/>import javax.inject.Named; <br class="title-page-name"/>import javax.inject.Singleton; <br class="title-page-name"/>import java.util.HashMap; <br class="title-page-name"/>import java.util.Map; <br class="title-page-name"/>import java.lang.System.Logger; <br class="title-page-name"/><br class="title-page-name"/>import static java.lang.System.Logger.Level.DEBUG; <br class="title-page-name"/><br class="title-page-name"/>@Singleton <br class="title-page-name"/>public class ColorManager { <br class="title-page-name"/>    protected final int nrColors; <br class="title-page-name"/>    protected final Map&lt;Color, Color&gt; successor = new HashMap&lt;&gt;(); <br class="title-page-name"/>    private Color first; <br class="title-page-name"/>    private final ColorFactory factory; <br class="title-page-name"/>    private static final Logger log = System.getLogger(ColorManager.class.getName()); <br class="title-page-name"/><br class="title-page-name"/>    @Inject <br class="title-page-name"/>    public ColorManager(@Named("nrColors") int nrColors, <br class="title-page-name"/>                                           ColorFactory factory) { <br class="title-page-name"/>        log.log(DEBUG,"creating colorManager for {0} colors", <br class="title-page-name"/>                                           nrColors);
</pre>
<p class="calibre2">In this version we do not import the slf4j classes. Instead we import the <kbd class="calibre11">java.lang.System.Logger</kbd> class.</p>
<div class="packtinfobox">Note that we do not need to import the System class, because the classes from the <kbd class="calibre22">java.lang</kbd> package are automatically imported. This is not true for the classes that are nested classes in the <kbd class="calibre22">System</kbd> class.</div>
<p class="calibre2">To get access to the logger the <kbd class="calibre11">System.getLogger</kbd> static method is called. This method finds the actual logger that is available and returns one for the name that we pass as argument. There is no version of the method <kbd class="calibre11">getLogger</kbd> that accepts the class as the argument. If we want to stick to the convention then we have to write <kbd class="calibre11">ColorManager.class.getName()</kbd> to get the name of the class or we can write there the name of the class as a string. The second approach has the drawback that it does not follow the change of the name of the class. Intelligent IDEs like IntelliJ, Eclipse, or Netbeans rename the references to classes automatically but they have a hard time when the name of the class is used in a string.</p>
<p class="calibre2">The interface <kbd class="calibre11">System.Logger</kbd> does not declare the convenience methods <kbd class="calibre11">error</kbd>, <kbd class="calibre11">debug</kbd>, <kbd class="calibre11">warning</kbd>, and so on, that are familiar from other logging frameworks and façade. There is only one method named <kbd class="calibre11">log</kbd> and the first argument of this method is the level of the actual log we issue. There are eight levels defined: <kbd class="calibre11">ALL</kbd>, <kbd class="calibre11">TRACE</kbd>, <kbd class="calibre11">DEBUG</kbd>, <kbd class="calibre11">INFO</kbd>, <kbd class="calibre11">WARNING</kbd>, <kbd class="calibre11">ERROR,</kbd> and <kbd class="calibre11">OFF</kbd>. When creating a log message we are supposed to use one of the middle six levels. <kbd class="calibre11">ALL</kbd> and <kbd class="calibre11">OFF</kbd> are meant to be passed to the <kbd class="calibre11">isLoggable</kbd> method. This method can be used to check if the actual logging level gets logged or not. For example, if the level is set to <kbd class="calibre11">INFO</kbd> then messages sent with <kbd class="calibre11">DEBUG</kbd> or <kbd class="calibre11">TRACE</kbd> will not be printed.</p>
<p class="calibre2">The actual implementation is located by the JDK using the service loader functionality. The log implementation has to be in a module that provides the interface <kbd class="calibre11">java.lang.System.LoggerFinder</kbd> via some implementation. In other words the module should have a class that implements the <kbd class="calibre11">LoggerFinder</kbd> interface and the <kbd class="calibre11">module-info.java</kbd> should declare which class it is using the code:</p>
<pre class="calibre20">
provides java.lang.System.LoggerFinder with <br class="title-page-name"/>                            packt.java9.by.example.MyLoggerFinder;
</pre>
<p class="calibre2">The <kbd class="calibre11">MyLoggerFinder</kbd> class has to extend the <kbd class="calibre11">LoggerFinder</kbd> abstract class with the method <kbd class="calibre11">getLogger</kbd>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Logging practice</h1>
            

            <article>
                
<p class="calibre2">The practice of logging is very simple. If you do not want to spend too much time experimenting with different logging solutions and you do not have some special requirement, then simply go with slf4j, add the JAR to the dependency list as a compile dependency, and start using logging in the source code.</p>
<p class="calibre2">Since logging is not instance-specific, and loggers implement thread safety, the log objects that we usually use are stored in a <kbd class="calibre11">static</kbd> field, and since they are used as long as the class is used, the program running the field is also <kbd class="calibre11">final</kbd>. For example using the slf4j façade we can get a logger with the following command:</p>
<pre class="calibre20">
private static final Logger log = <br class="title-page-name"/>           LoggerFactory.getLogger(MastermindHandler.class);
</pre>
<p class="calibre2">To get the logger, the logger factory is used, which just creates the logger or returns the one that is already available.</p>
<div class="packttip">The name of the variable is usually <kbd class="calibre22">log</kbd> or <kbd class="calibre22">logger,</kbd> but do not be surprised if you see <kbd class="calibre22">LOG</kbd> or <kbd class="calibre22">LOGGER</kbd>. The reason for uppercasing the name of the variable is that some static code analysis checkers treat <kbd class="calibre22">static final</kbd> variables as constants, as they really are, and the convention in the Java community is to use uppercase names for such variables. It is a matter of taste; many times <kbd class="calibre22">log</kbd> and <kbd class="calibre22">logger</kbd> are used in lowercase.</div>
<p class="calibre2">To create a log item the methods <kbd class="calibre11">trace</kbd>, <kbd class="calibre11">debug</kbd>, <kbd class="calibre11">info</kbd>, <kbd class="calibre11">warn</kbd>, and <kbd class="calibre11">error</kbd> create a message with the respective level as the name implies. For example, consider the following line:</p>
<pre class="calibre20">
log.debug("Adding new guess {} to the game", newGuess);
</pre>
<p class="calibre2">It creates a debug message. Slf4j has support for formatting using the <kbd class="calibre11">{}</kbd> literal inside strings. This way, there is no need to append the string from small parts, and in case the actual log item is not sent to the log destination, the formatting will not perform. If we use <kbd class="calibre11">String</kbd> concatenation in any form to pass a string as an argument, then the formatting will happen even if debug logging is not desired as per the example.</p>
<p class="calibre2">The logging methods also have a version that gets only two arguments: a <kbd class="calibre11">String</kbd> message and <kbd class="calibre11">Throwable</kbd>. In this case, the logging framework will take care of the output of the exception and the stack trace along with it. If you log something in exception handling code, log the exception and let the logger format it.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Other technologies</h1>
            

            <article>
                
<p class="calibre2">We discussed the servlet technology, a bit of JavaScript, HTML, and CSS. When programming in a real professional environment, these technologies are generally used. The creation of the user interface of applications, however, was not always based on these technologies. Older operating system-native GUI applications as well as Swing, AWT, and SWT use a different approach to create UI. They build up the UI facing the user from program code, and the UI is built as a hierarchical structure of components. When web programming started, Java developers had experience with technologies like these and projects created frameworks that tried to hide the web technology layer.</p>
<p class="calibre2">One technology worth mentioning is Google Web Toolkit, which implements the server as well as the browser code in Java, but since there is no Java environment implemented in the browsers, it transpiles (converts) the client part of the code from Java to JavaScript. The last release of the toolkit was created two years ago in 2014 and since then Google has released other types of web programming toolkits that support native JavaScript, HTML, and CSS client development.</p>
<p class="calibre2"><strong class="calibre1">Vaadin</strong> is also a toolkit that you may come across. It lets you write GUI code on the server in Java. It is built on top of GWT and is commercially supported. It may be a good choice in case there are developers available who have experience with GUI development in Java but not in web native technologies, and the application does not require special usability tuning on the client side. A typical intranet corporate application can select it as a technology.</p>
<p class="calibre2"><strong class="calibre1">Java Server Faces</strong> (<strong class="calibre1">JSF</strong>) is a technology that tries to offload the client-side development of the application from the developers providing widgets ready to be used and the server side. It is a collection of several <strong class="calibre1">Java Specification Requests</strong> (<strong class="calibre1">JSR</strong>) and there are several implementations. The components and their relations are configured in XML files and the server creates the client native code. In this technology, there is no transpilation from Java to JavaScript. It is more like using a limited but huge set of widgets, limiting the use to those only, and giving up direct programming of the web browser. If one has the experience and knowledge, however, they can create new widgets in HTML, CSS, and JavaScript.</p>
<p class="calibre2">There are many other technologies that were developed to support web applications in Java. The modern approach advocated by most of the big players is to develop the server side and the client side using separate toolsets and methodologies, and connect the two using REST communication.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            <article>
                
<p class="calibre2">In this chapter, you learnt the structure of web programming. This was not possible without understanding the basics of TCP/IP networking, which is the protocol of the Internet. The application level protocol that is used over that is HTTP, currently in a very new version 2.0, which is still not supported by the servlet standard. We created a version of the Mastermind game that, this time, can really be played using the browser and we started it in a development environment using Jetty. We examined how to store the game state and implemented two versions. Finally, we learned the basics of logging and we looked at other technologies. At the same time, we also looked at the dependency injection implementation Guice from Google, and we studied how it works under the hood, and why and how to use it.</p>
<p class="calibre2">After this chapter, you will be able to start the development of a web application in Java and will understand the architecture of such a program. You will understand what is under the hood when you start learning how to program web applications using the Spring framework, which hides many of the complexities of web programming.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    </body></html>