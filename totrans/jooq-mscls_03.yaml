- en: '*Chapter 2*: Customizing the jOOQ Level of Involvement'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced jOOQ in a Spring Boot application and
    used it for generating and executing a valid non-type-safe SQL statement. In this
    chapter, we will continue this journey and increase the jOOQ level of involvement
    via an astonishing feature – the so-called jOOQ *Code Generator*. In other words,
    jOOQ will be in control of the persistence layer via a straightforward flow that
    begins with type-safe queries, continues by generating **Plain Old Java Objects**
    (**POJOs**) used to map the query results as objects, and ends with generating
    DAOs used to shortcut the most common queries in object-oriented style.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll know how to write type-safe queries, and
    how to instruct jOOQ to generate POJOs and DAOs that have custom names in Java
    and Kotlin applications, using Maven and Gradle. We will cover these topics declaratively
    (for instance, in XML files) and programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what type-safe queries are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a jOOQ Java-based schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing queries using a Java-based schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring jOOQ to generate POJOs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring jOOQ to generate DAOs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring jOOQ to generate interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tackling programmatic configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing jOOQ settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with a brief discussion about type-safe queries.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files used in this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter02](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter02)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what type-safe queries are
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally speaking, what actually is a type-safe API? In short, an API is type-safe
    if it relies on the type system of a programming language aiming to prevent and
    report type errors. Specifically, jOOQ enables the compiler to do that via the
    Code Generator features.
  prefs: []
  type: TYPE_NORMAL
- en: Working with type-safe SQL is preferable because there is no need to validate
    every SQL statement via dedicated tests, and it is faster to fix things during
    coding than while running the application. For example, you can significantly
    reduce the number of unit tests dedicated to SQL validation and focus on integration
    tests, which is always a good thing. So, SQL type safety really matters!
  prefs: []
  type: TYPE_NORMAL
- en: Declaring SQL statements as Java `String` statements (for example, in JPQL style,
    which is verified at execution time) doesn't take advantage of type safety. In
    other words, the compiler cannot guarantee that a SQL statement is valid. This
    happens in each of the following examples that use different choices for the persistence
    layer. All these examples compile but fail at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a `JdbcTemplate` non-type-safe SQL example (with the wrong order
    of binding values):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a Spring Data example (`name` should be `String`, not `int`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a Spring Data derived query method example (`name` should be `String`,
    not `int`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a jOOQ query builder without the Code Generator example (instead
    of `v`, it should be `v.getOwnerName()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s another jOOQ query builder without the Code Generator example (in our
    schema, there is no `OFFICES` table and no `CAPACITY` column):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: These are just some simple cases that are easy to spot and fix. Imagine a non-type-safe
    complex query with a significant number of bindings.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, if the jOOQ Code Generator is enabled, then jOOQ will compile the SQL
    statements against an actual Java-based schema that mirrors a database. This way,
    jOOQ ensures *at least* the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The classes and fields that occur in SQL exist, have the expected type, and
    are mapped to a database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no type mismatches between the operators and operands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The generated query is syntactically valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'I said *at least* because, besides type safety, jOOQ takes care of many other
    aspects, such as quotations, qualification, and case sensitivity of identifiers.
    These aspects are not easy to handle across SQL dialects, and thanks to the Code
    Generator feature, jOOQ makes the right choices for us upfront almost everywhere.
    As Lukas Eder said: *"Using jOOQ with the Code Generator is just a little additional
    setup, but it will help jOOQ to make the right, carefully chosen default choices
    for so many silly edge cases that are so annoying to handle later on. I can''t
    recommend it enough! :)"*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Back to type safety, let''s assume that the jOOQ Code Generator has produced
    the needed artifacts (a suite of classes that mirrors the database tables, columns,
    routines, views, and so on). In this context, the previous jOOQ examples can be
    rewritten in a type-safe manner, as follows. Note that none of the following snippets
    will compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Besides being less verbose than the original example, this query is type-safe
    as well. This time, `CUSTOMER` (which replaced `table("CUSTOMER")`) is a `static`
    instance (shortcut) of the `Customer` class, representing the `customer` table.
    Moreover, `CUSTOMER_NAME` (which replaced `field("CUSTOMER.CUSTOMER_NAME")`) is
    also a `static` field in the `Customer` class, representing the `customer_name`
    column of the `customer` table. These Java objects have been generated by the
    jOOQ Code Generator as part of the Java-based schema. Note how this `static` instance
    was nominally imported here – if you find the technique of importing each `static`
    artifact cumbersome, then you can simply rely on the neat trick of importing the
    entire schema as `import static jooq.generated.Tables.*`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second jOOQ example can be rewritten in a type-safe manner, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure is a screenshot from the IDE, showing that the compiler
    complains about the type safety of this SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The compiler reports a type safety error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_2.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – The compiler reports a type safety error
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Lukas Eder said this: *"As you probably know, the IDEs help writing SQL and
    JPQL strings, which is nice. But IDEs doesn''t fail the build when a column name
    changes."* Well, having type-safe queries covers this aspect, and the IDE can
    fail the build. So, thanks to jOOQ''s fluency and expressiveness, the IDE can
    provide code completion and refactoring support. Moreover, with jOOQ, the bind
    variables are part of a non-dynamic **Abstract Syntax Tree** (**AST**); therefore,
    it is not possible to expose SQL injection vulnerabilities this way.'
  prefs: []
  type: TYPE_NORMAL
- en: OK, but how do we obtain this Java-based schema?
  prefs: []
  type: TYPE_NORMAL
- en: Generating a jOOQ Java-based schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the previous queries were referencing the database schema explicitly by
    placing the table or column name between quotes and passing them as arguments
    to the jOOQ built-in `table()` and `field()` methods respectively.
  prefs: []
  type: TYPE_NORMAL
- en: But, using the jOOQ Code Generator allows the SQL statements expressed via jOOQ's
    query DSL API to take advantage of a Java-based schema that mirrors the one from
    the database. The code generation part is the job of the jOOQ generation tool
    (its starting point is the `org.jooq.codegen.GenerationTool` class).
  prefs: []
  type: TYPE_NORMAL
- en: Having a Java-based schema is quite useful. The SQL statements can be expressed
    via the Java data access layer and executed against the underlying database schema.
    Besides being type-safe, these SQL statements are not prone to typos, are easy
    to refactor (for example, to rename a column), and are less verbose than referencing
    the database schema explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ comes with several solutions for generating the Java-based schema via the
    jOOQ Code Generator. Mainly, jOOQ can generate the Java-based schema by applying
    the technique of reverse engineering to the database directly, the DDL files,
    JPA entities, or XML files containing the schema. Next, we will tackle the first
    three approaches, starting with the first approach, which generates the Java-based
    schema directly from the database. Mainly, we will use Flyway to migrate the database
    (Liquibase is supported as well), which is subsequently reverse engineered by
    jOOQ to obtain the Java-based schema.
  prefs: []
  type: TYPE_NORMAL
- en: Code generation from a database directly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following figure represents the jOOQ Java-based schema generation flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Java-based schema generation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_2.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Java-based schema generation
  prefs: []
  type: TYPE_NORMAL
- en: So far, jOOQ will regenerate the Java-based schema every time the application
    starts (runs).
  prefs: []
  type: TYPE_NORMAL
- en: In other words, even if the database schema has not changed, jOOQ will regenerate
    the Java-based schema at each run. Obviously, this is preferable to regenerating
    the Java-based schema only when the underlying database schema is missing or has
    changed (for instance, a new column has been added to a table); otherwise, this
    is just a waste of time.
  prefs: []
  type: TYPE_NORMAL
- en: Conscious schema change management is a good thing, and having a tool for this
    is great! Most probably, you'll choose between Flyway and Liquibase. While we
    will only cover the Flyway approach in the next section, Liquibase is very well
    represented in the jOOQ manual ([https://www.jooq.org/doc/latest/manual/code-generation/codegen-liquibase/)](https://www.jooq.org/doc/latest/manual/code-generation/codegen-liquibase/)).
  prefs: []
  type: TYPE_NORMAL
- en: Adding Flyway with Maven
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flyway is a great tool for database migration ([https://flywaydb.org/](https://flywaydb.org/)).
    Mainly, Flyway keeps track of database schema modifications via a table named
    `flyway_schema_history` (or `schema_version` in Flyway prior to version 5). This
    table is automatically added to the database and is maintained by Flyway itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, in Spring Boot, Flyway reads and executes all the database migration
    scripts located in the indicated path (the default path is `src/main/resources/db/migration`).
    For instance, in this book, we use an explicit path that points to a location
    outside the applications in the root folder (`${root}/db/migration`). We do this
    because we want to avoid multiplying the migrations scripts in every single application.
    To quickly start with Flyway, simply add to `pom.xml` the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The Flyway default Maven phase for a `migrate` operation is `pre-integration-test`
    (right after `package`). On the other hand, jOOQ needs the migrations to take
    place in the `generate-sources` phase (right after `validate`), therefore much
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mainly, jOOQ triggers a `SELECT` query against the `flyway_schema_history`
    table to check the schema version. This means that jOOQ needs to wait for migrations
    to take place and the schema version to be updated. If the version is updated,
    then jOOQ regenerates the Java-based schema; otherwise, you''ll see a message
    like this: `Existing version 1.1 is up to date with 1.1 for schema classicmodels.
    Ignoring schema`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scheduling migrations in the `generate-sources` phase can be done via the Flyway
    Maven plugin, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Let's try using Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Flyway with Gradle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you prefer to use Gradle, then you''ll need `build.gradle` in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's add the SQL scripts following the Flyway naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Adding SQL scripts for Flyway
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the applications developed in this book, the scripts read and executed by
    Flyway are named `V1.1__Create.sql` (this file contains the DDLs of the database
    schema) and `afterMigrate.sql` (this file contains the DMLs to populate the database)
    and are placed externally to the applications in the `${root}/db/migration` folder.
    Adding a new file that respects the Flyway naming convention (for example, `V1.2__AddColumn.sql`)
    will instruct Flyway to update the database schema and jOOQ to regenerate the
    Java-based schema. As long as no migrations happen and the jOOQ-generated classes
    exist, jOOQ doesn't regenerate the Java-based schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure represents the flow, which is particularly interesting
    for most use cases that contain DDL changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Flyway migrations and the jOOQ Java-based schema generation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_2.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Flyway migrations and the jOOQ Java-based schema generation
  prefs: []
  type: TYPE_NORMAL
- en: Note how Flyway migrations take place before jOOQ code generation. Finally,
    it's time to enable the jOOQ Code Generator.
  prefs: []
  type: TYPE_NORMAL
- en: From a developer perspective, enabling the jOOQ Code Generator is a setup task
    that gets materialized in a snippet of code, written in standalone migration scripts
    or `pom.xml` if there is a Maven-based project, or `build.gradle` if there is
    a Gradle-based project. jOOQ reads this information and uses it to configure and
    automatically execute the `org.jooq.codegen.GenerationTool` generator accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code Generator with Maven
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mainly, the jOOQ Code Generator can run in standalone mode or with Maven/Gradle.
    While there are no big differences between these two approaches, we prefer to
    go further with the Maven plugin, `jooq-codegen-maven`. Nevertheless, for a quick
    example of running the Code Generator from the command line in standalone mode,
    you have everything you need (including a `README` file) packed in a ZIP archive
    named `standalone-codegen-jooq.zip`. This is available for MySQL, PostgreSQL,
    SQL Server, and Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, configuring jOOQ''s Code Generator requires some information that can
    be packed in an XML file. The climax of this file is the `<configuration>` tag
    used to shape an `org.jooq.meta.jaxb.Configuration` instance. Consider reading
    carefully each comment of the following jOOQ Code Generator configuration stub,
    since each comment provides important details about the tag that precedes it (in
    the bundled code, you''ll see an expanded version of these comments, containing
    extra details):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `<generator/>` tag contains all the information needed for customizing
    the jOOQ generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on this stub and the comments, let''s try to fill up the missing parts
    for configuring the jOOQ Code Generator against the `classicmodels` database in
    MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: For brevity, the alternatives for PostgreSQL, SQL Server, and Oracle are not
    listed here, but you can find them in the code bundled with this book in the application
    named *WriteTypesafeSQL*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the Maven plugin supports the following flags in `<configuration>`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Disabling the plugin via a Boolean property/constant:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Specifying an external XML configuration instead of an inline configuration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, specifying several external configuration files, merged by using
    Maven''s `combine.children="append"` policy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's run the jOOQ generator via Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code Generator with Gradle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Running the Code Generator via Gradle can be accomplished via `gradle-jooq-plugin`
    ([https://github.com/etiennestuder/gradle-jooq-plugin/](https://github.com/etiennestuder/gradle-jooq-plugin/)).
    The next snippet of code represents the climax of configuration for Oracle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we have to bind the jOOQ generator to the Flyway migration tool
    to execute it only when it is really needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, you can find the complete application (*WriteTypesafeSQL*)
    for MySQL, PostgreSQL, SQL Server, and Oracle, written for Java/Kotlin and Maven/Gradle
    combos.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, if you prefer `Ant`, then read this: [https://www.jooq.org/doc/latest/manual/code-generation/codegen-ant/](https://www.jooq.org/doc/latest/manual/code-generation/codegen-ant/).
    Next, let''s tackle another approach to generating the Java-based schema.'
  prefs: []
  type: TYPE_NORMAL
- en: Code generation from SQL files (DDL)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another jOOQ approach for obtaining the Java-based schema relies on the DDL
    Database API, which is capable of accomplishing this task from SQL scripts (a
    single file or incremental files) containing the database schema. Mainly, the
    jOOQ SQL parser materializes our SQL scripts into an in-memory H2 database (available
    out of the box in Spring Boot), and the generation tool will reverse-engineer
    it to output the Java-based schema. The following figure depicts this flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – The jOOQ Java-based schema generation via the DDL Database API'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_2.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – The jOOQ Java-based schema generation via the DDL Database API
  prefs: []
  type: TYPE_NORMAL
- en: The climax of the DDL Database API configuration relies on the jOOQ Meta Extensions,
    represented by `org.jooq.meta.extensions.ddl.DDLDatabase`.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code Generator with Maven
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this context, running the Code Generator via Maven relies on the following
    XML stub. Read each comment, since they contain valuable information (in the bundled
    code, you''ll see an expanded version of these comments):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: In this context, jOOQ generates the Java-based schema without connecting to
    the real database. It uses the DDL files to produce an in-memory H2 database that
    is subsequently reverse-engineered into Java classes. The `<schemaVersionProvider>`
    tag can be bound to a Maven constant that you have to maintain in order to avoid
    running the Code Generator when nothing has changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides this stub, we need the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on this stub and the explanations from the comments, let''s try to fill
    up the missing parts to configure the jOOQ Code Generator against the `classicmodels`
    database in PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: The Gradle alternative is available in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the SQL files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Currently, it is impossible to use some vendor-specific stuff; therefore, our
    SQL files may contain parts that the jOOQ SQL parser may not understand. In such
    cases, we have to prepare our SQL files by delimiting these parts with the jOOQ
    default conventions from the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: The code between `-- [jooq ignore start]` and `-- [jooq ignore stop]` is ignored
    by the jOOQ SQL parser. Turning on/off ignoring content between such tokens can
    be done via the `parseIgnoreComments` Boolean property, while customizing these
    tokens can be done via the `parseIgnoreCommentStart` and `parseIgnoreCommentStop`
    properties. For more details, refer to [https://www.jooq.org/doc/latest/manual/code-generation/codegen-ddl/](https://www.jooq.org/doc/latest/manual/code-generation/codegen-ddl/).
  prefs: []
  type: TYPE_NORMAL
- en: In the bundled code, you can see an implementation of this stub for MySQL, PostgreSQL,
    SQL Server, and Oracle via the Java/Kotlin and Maven/Gradle combos, under the
    name *DeclarativeDDLDatabase*.
  prefs: []
  type: TYPE_NORMAL
- en: Going forward, while the jOOQ SQL parser will become more powerful, this will
    be the recommended approach for using the jOOQ Code Generator. The goal is to
    delegate jOOQ to do more migration work out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Code generation from entities (JPA)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's assume that you have a JPA application that relies on a schema shaped
    as an entity model (JPA-annotated entities) and you want to obtain the jOOQ Java-based
    schema. If you cannot isolate the JPA entity model in a separate module of the
    application, then you can configure jOOQ to generate the Java-based schema directly
    from the real database (supposing that you have access to the real database schema
    during the development stage) or from the DDL files (assuming that you have such
    files). But, if you can easily place the entities in a separate module of the
    application, then you can rely on jOOQ's JPA Database API (`org.jooq.meta.extensions.jpa.JPADatabase`),
    which is capable of generating the Java-based schema from the JPA model. The JPA
    Database API requires entities in a separate module because it has to look them
    up from the classpath via Spring.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure depicts the flow of the JPA Database API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – The jOOQ Java-based schema generation via the JPA Database API'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_2.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – The jOOQ Java-based schema generation via the JPA Database API
  prefs: []
  type: TYPE_NORMAL
- en: The flow of the JPA Database API uses Hibernate internally for generating an
    in-memory H2 database from the JPA model (entities). Subsequently, jOOQ reverse-engineers
    this H2 database into jOOQ classes (the Java-based schema).
  prefs: []
  type: TYPE_NORMAL
- en: Running the Code Generator with Maven
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this context, running the Code Generator via Maven relies on the following
    XML stub. Read each comment, since they contain valuable information (in the bundled
    code, you can find an expanded version of these comments):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on this stub and the comments, here is an example containing the popular
    settings (this snippet was extracted from a JPA application that uses MySQL as
    the real database):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides this stub, we need the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: This approach and the Gradle alternative are available in the bundled code for
    Java and Kotlin under the name `DeclarativeJPADatabase`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach that you''ll find interesting is generating the Java-based
    schema from XML files: [https://www.jooq.org/doc/latest/manual/code-generation/codegen-xml/](https://www.jooq.org/doc/latest/manual/code-generation/codegen-xml/).
    This is exemplified in `DeclarativeXMLDatabase` and `ProgrammaticXMLGenerator`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally speaking, it is highly recommended to read the *Code generation*
    section of the jOOQ manual: [https://www.jooq.org/doc/latest/manual/code-generation/](https://www.jooq.org/doc/latest/manual/code-generation/).
    This section contains tons of settings and configurations that influence the generated
    artifacts.'
  prefs: []
  type: TYPE_NORMAL
- en: If you need to manage multiple databases, schemas, catalogs, a shared-schema
    multitenancy, and so on, then refer to [*Chapter 17*](B16833_17.xhtml#_idTextAnchor330),
    *Multitenancy in jOOQ*.
  prefs: []
  type: TYPE_NORMAL
- en: Writing queries using a Java-based schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once jOOQ's Code Generator has done its job, we have access to the generated
    artifacts. Among these artifacts, we have the `jooq.generated.tables` folder,
    which contains the database tables mirrored as Java code. The generated artifacts
    are placed in the specified `/target` folder (in our case, `target/generated-sources`)
    under the specified package name (in our case, `jooq.generated`).
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, you''ll instruct the jOOQ Code Generator to store generated code
    under the `/target` folder (Maven), `/build` folder (Gradle), or `/src` folder.
    Basically, if you choose the `/target` or `/build` folder, then jOOQ regenerates
    the code at each build; therefore, you are sure that sources are always up to
    date. Nevertheless, to decide which path fits best to your strategic case, consider
    reading Lukas Eder''s answer from Stack Overflow: [https://stackoverflow.com/questions/25576538/why-does-jooq-suggest-to-put-generated-code-under-target-and-not-under-src](https://stackoverflow.com/questions/25576538/why-does-jooq-suggest-to-put-generated-code-under-target-and-not-under-src).
    It is also recommended to check out the *Code generation and version control*
    section from the jOOQ manual, available at [https://www.jooq.org/doc/latest/manual/code-generation/codegen-version-control/](https://www.jooq.org/doc/latest/manual/code-generation/codegen-version-control/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that, in the previous chapter ([*Chapter 1*](B16833_01.xhtml#_idTextAnchor015),
    *Starting jOOQ and Spring Boot*), we already used the jOOQ DSL API to write the
    following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: 'This query references the database schema (table and columns). Rewriting this
    query referencing the Java-based schema produces the following code (jOOQ `Record`
    such as `OfficeRecord` are introduced in the next chapter; for now, think of it
    as the result set wrapped in a Java object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, generating and executing the query immediately can be done as
    follows (`Office` is a POJO):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on the database vendor, the generated SQL looks as follows with MySQL
    (note that jOOQ has correctly generated backticks specific to MySQL queries):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated SQL looks as follows with PostgreSQL (note that jOOQ has used
    the qualification containing the PostgreSQL schema):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated SQL looks as follows with Oracle (note that jOOQ has made the
    identifiers uppercase, exactly as Oracle prefers):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated SQL looks as follows with SQL Server (note that jOOQ has used
    `[]`, specific to SQL Server):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: So, depending on the dialect, jOOQ has produced the expected query.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `selectFrom(table("OFFICE"))` has been rendered as `*`, while `selectFrom(OFFICE)`
    has been rendered as a list of column names. In the first case, jOOQ cannot infer
    the columns from the argument table; therefore, it projects `*`. In the second
    case, thanks to the Java-based schema, jOOQ projects the known columns from the
    table, which avoids the usage of the controversial `*`. Of course, `*` per se
    isn''t controversial – just the fact that the columns aren''t listed explicitly,
    as this article explains: [https://tanelpoder.com/posts/reasons-why-select-star-is-bad-for-sql-performance/](https://tanelpoder.com/posts/reasons-why-select-star-is-bad-for-sql-performance/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try another example that queries the `ORDER` table. Since `ORDER` is
    a reserved word in most dialects, let''s see how jOOQ will handle it. Note that
    our query doesn''t do anything special to instruct jOOQ about this aspect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, generating and executing it immediately (`Order` is a POJO):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the valid SQL generated for MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: For brevity, we'll skip the generated SQL for PostgreSQL, Oracle, and SQL Server.
    Mainly, since jOOQ quotes everything by default, we can use reserved and unreserved
    names exactly in the same way and get back valid SQL statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s tackle one more example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, generating and executing it immediately (`CustomerAndOrder` is a POJO):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: 'This query uses the `JOIN`...`USING` syntax. Basically, instead of a condition
    via the `ON` clause, you supply a set of fields that have an important particularity
    – their names are common to both tables to the left and right of the join operator.
    However, some dialects (for example, Oracle) don''t allow us to use qualified
    names in `USING`. Having qualified names leads to an error such as `ORA-25154:
    column part of USING clause cannot have qualifier`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'jOOQ is aware of this aspect and takes action. Following the Oracle dialect,
    jOOQ renders `CUSTOMER.CUSTOMER_NUMBER` as `"CUSTOMER_NUMBER"`, not qualified
    as `"CLASSICMODELS"."CUSTOMER"."CUSTOMER_NUMBER"`. Check this here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: This was just an example of how jOOQ takes care of the generated SQL by emulating
    the correct syntax, depending on the dialect used! Thanks to jOOQ code generation,
    we benefit from default choices for so many silly edge cases that are so annoying
    to handle later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s summarize a handful of advantages brought by jOOQ code generation:'
  prefs: []
  type: TYPE_NORMAL
- en: Type-safe SQL queries. Did I mention type-safe SQL queries?!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No need to worry about the identifier's case sensitivity, quotation, and qualification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using generated code makes for much leaner expressions. There's less wrapping
    noise such as `field("X", "Y")`, `field(name("X", "Y"))`, or `field(name("X",
    "Y"), DATA_TYPE)`. Via jOOQ code generation, this would just be `X.Y`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The IDE can provide code completion and refactoring support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the IDE to find uses of tables and columns because they're Java objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code will no longer compile when the columns are renamed, rather than having
    to run the query for it to fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoidance of issues caused by edge cases with vendor-specific data types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since jOOQ quotes everything by default, users don't have to think of quoting
    reserved names such as `table(name("ORDER"))`. It's just `ORDER`, and jOOQ will
    produce `` `ORDER` ``, `"ORDER"`, `[ORDER]`, or whatever is specific to the used
    dialect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As a rule of thumb, always consider jOOQ code generation as the default way
    to exploit jOOQ. Of course, there are edge cases when code generation cannot be
    fully exploited (for instance, in the case of schemas that are created/modified
    dynamically at runtime), but this is a different story.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The application developed in this section is named *WriteTypesafeSQL*.
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ versus JPA Criteria versus QueryDSL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All these three, jOOQ, JPA Criteria (or the Spring Data JPA Specifications API
    built on top of the Criteria API), and QueryDSL, can provide type-safe SQL.
  prefs: []
  type: TYPE_NORMAL
- en: If you come from a JPA background, then you know that JPA defines a Metamodel
    API for Criteria queries. So, the Criteria API and the Metamodel API can provide
    type safety for SQL as well. But, the Criteria API is quite complicated compared
    to QueryDSL. You don't have to take my word for it – try it! However, the Criteria
    API is something that you need to learn in addition to JPQL and all the JPA stuff.
    Also, it is not intuitive, it is poorly documented, and developers describe it
    as quite slow. Moreover, having 100% type safety means having to write all SQL
    statements that are prone to type errors via the Criteria API.
  prefs: []
  type: TYPE_NORMAL
- en: QueryDSL supports SQL type safety as well. Having support in Spring Boot, QueryDSL
    is well covered in this article at [https://dzone.com/articles/querydsl-vs-jooq-feature](https://dzone.com/articles/querydsl-vs-jooq-feature),
    which contains a non-exhaustive list of jOOQ support beyond QueryDSL's "feature
    completeness." Nevertheless, that article is quite old and may be out of date.
    Meanwhile, jOOQ has even more advantages that you can find yourself by a quick
    search on `reddit.com`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's go one step further and give more control to jOOQ.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring jOOQ to generate POJOs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have used our own **POJOs** as our primary **Data** **Transfer Objects**
    (**DTOs**). This is a common approach in layered applications such as Spring Boot
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: The `Office` and `Order` POJOs are Java mirrors of the `OFFICE` and `ORDER`
    tables, since our queries fetch all the columns from these tables. On the other
    hand, the `CustomerAndOrder` POJO maps columns from two different tables, `CUSTOMER`
    and `ORDER`. More precisely, it maps `CUSTOMER_NAME` from `CUSTOMER` and `ORDER_DATE`
    from `ORDER`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, jOOQ can generate POJOs on our behalf via the jOOQ Code Generator.
    In Maven, this feature can be enabled via the following configuration into the
    `<generator>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, jOOQ can add to the generated POJOs a set of Bean Validation
    API annotations to convey type information. More precisely, they include two well-known
    validation annotations – `@NotNull` (`javax/jakarta.validation.constraints.NotNull`)
    and `@Size` (`javax/jakarta``.validation.constraints.Size`). To enable these annotations,
    the configuration should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: Also, you should add the dependency for `validation-api` as in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the names of the generated POJOs are the same as the names of the
    tables in *Pascal* case (for instance, the table named `office_has_manager` becomes
    `OfficeHasManager`). Altering the default behavior can be achieved via so-called
    *generator strategies* – basically, in Maven, a piece of XML delimited by the
    `<strategy>` tag that relies on regular expressions for producing custom (user-defined)
    output. For example, if the POJOs are prefixed with the `Jooq` text, then the
    generator strategy will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: This time, the table named `office_has_manager` results in a POJO source named
    `JooqOfficeHasManager`. More details about the generator strategies (including
    the programmatic approach) are available in [*Chapter 18*](B16833_18.xhtml#_idTextAnchor338),
    *jOOQ SPI (Providers and Listeners)*. Also, it is recommended to read [https://www.jooq.org/doc/latest/manual/code-generation/codegen-matcherstrategy/](https://www.jooq.org/doc/latest/manual/code-generation/codegen-matcherstrategy/).
  prefs: []
  type: TYPE_NORMAL
- en: The Gradle alternative is available in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, jOOQ generates a POJO for each table in the database. Therefore,
    by default, jOOQ can generate a POJO as `Office` and `Order` (or `JooqOffice`
    and `JooqOrder`, conforming to the preceding strategy), but its purpose is not
    to generate more complex POJOs, such as composite POJOs or ones containing arbitrary
    objects (such as `CustomerAndOrder`). The following is the source code of `JooqOffice`,
    generated by jOOQ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar POJOs are generated for each table of the `classicmodels` database.
    This means that we can still use our `CustomerAndOrder` POJO, but there is no
    need to write our own POJOs for `Office` and `Order` because we can use those
    generated by jOOQ. The following code was cut out from `ClassicModelsRepository`
    and uses the generated `JooqOffice` and `JooqOrder` (note the imports – jOOQ placed
    the POJOs in the `jooq.generated.tables.pojos` package):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: Done! So, jOOQ-generated POJOs can be used as any regular POJOs. For instance,
    they can be returned from a `REST` controller, and Spring Boot will serialize
    them as JSON. We'll detail more types of supported POJOs later on when we tackle
    the mapping result set to POJOs.
  prefs: []
  type: TYPE_NORMAL
- en: The application developed in this section is available as *GeneratePojos*. Next,
    let's see how jOOQ can generate DAOs.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring jOOQ to generate DAOs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are familiar with Spring Data JPA/JDBC, then you're already used to relying
    on a DAO layer that wraps the queries. Both Spring Data JDBC and JPA provide a
    built-in DAO that exposes a set of CRUD operations and can be extended via user-defined
    repositories.
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ code generation can produce similar DAOs. Basically, for each table of
    the database, jOOQ can generate an `org.jooq.DAO` implementation that exposes
    methods such as `findById()`, `delete()`, `findAll()`, `insert()`, and `update()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Maven, this feature can be enabled via the following configuration in the
    `<generator>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: 'jOOQ DAOs make use of POJOs; therefore, jOOQ will implicitly generate POJOs
    as well. Since we are in Spring Boot, it will be nice to have the generated DAOs
    annotated with `@Repository` as the built-in `SimpleJpaRepository`. To achieve
    this, we use the `<springAnnotations/>` flag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the names of the generated DAOs are the same as the names of the
    tables in *Pascal* case and suffixed with the word `Dao` (for instance, the table
    named `office_has_manager` becomes `OfficeHasManagerDao`). Altering the default
    behavior can be achieved via so-called *generator strategies*. For instance, following
    the Spring style, we prefer `OfficeHasManagerRepository` instead of `OfficeHasManagerDao`.
    This can be achieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: 'The Gradle alternative is available in the bundled code. For instance, the
    generated `OfficeRepository` looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: Each generated DAO extends the common base implementation named `DAOImpl`. This
    implementation supplies common methods such as `insert()`, `update()`, `delete()`,
    and `findById()`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, our `ClassicModelsRepository` contains three query methods, represented
    by `findOfficesInTerritory()`, `findOrdersByRequiredDate()`, and `findCustomersAndOrders()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, let''s check the query from `findOfficesInTerritory()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we notice that the generated `OfficeRepository` already covers this query
    via the `fetchByTerritory(String territory)` method; therefore, we can use this
    built-in DAO method directly in our service, `ClassicModelsService`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: 'Going further, check out the query from `findOrdersByRequiredDate()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the previous query is covered in `OrderRepository` by the built-in
    DAO method, `fetchRangeOfRequiredDate(LocalDate li, LocalDate ui)`. So, we can
    drop the previous query and rely on `ClassicModelsService` on the built-in one,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the only query method left in `ClassicModelsRepository` is `findCustomersAndOrders()`.
    This query method doesn't have an alternative in the default generated DAOs; therefore,
    we still need it.
  prefs: []
  type: TYPE_NORMAL
- en: For now, you can check the application named *GenerateDaos*. Later on, we'll
    discuss extending and customizing the jOOQ-generated DAO.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring jOOQ to generate interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides POJOs and DAOs, jOOQ can generate an interface for each table. Each
    column is associated with a getter and a setter. In Maven, this can be done as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: Basically, jOOQ generates interfaces that look like Spring Data's so-called
    *interfaces-based closed projections*. We can use these interfaces for mapping
    results sets exactly as we do with *closed projections*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, note that at the time of writing, this feature has been proposed
    to be removed. You can track the deprecation here: [https://github.com/jOOQ/jOOQ/issues/10509](https://github.com/jOOQ/jOOQ/issues/10509).'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's continue with the programmatic configuration of the jOOQ Code Generator.
  prefs: []
  type: TYPE_NORMAL
- en: Tackling programmatic configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you prefer programmatic configurations, then jOOQ exposes a fluent API (`org.jooq.meta.jaxb.*`)
    that can be used for configuring code generation in programmatic fashion. First,
    for Maven, add the following dependency in `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, in Gradle, add `implementation 'org.jooq{.trial-java-8}:jooq-codegen'`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `Configuration` refers to `org.jooq.meta.jaxb.Configuration`, not
    `org.jooq.Configuration`, which is used for creating `DSLContext` and other jOOQ
    contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'This programmatic API mirrors the declarative approach and, therefore, is very
    intuitive. For instance, here it is the programmatic alternative of the declarative
    approach presented in the *Configuring jOOQ to generate DAOs* section for the
    MySQL `classicmodels` schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: The jOOQ Code Generator must generate the classes before the application's classes
    are compiled; therefore, the programmatic Code Generator should be placed in a
    separate module of your application and invoked at the proper moment before the
    compilation phase. As you'll see in the bundled code (*ProgrammaticGenerator*),
    this can be achieved via `exec-maven-plugin` for Maven or `JavaExec` for Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer the DDL Database API, then you'll love the programmatic approach
    from `ProgrammaticDDLDatabase`. If you prefer the JPA Database API, then check
    out the programmatic approach as well, *ProgrammaticJPADatabase*.
  prefs: []
  type: TYPE_NORMAL
- en: All the applications from this chapter are available for Java/Kotlin and Maven/Gradle
    combos.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing jOOQ settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: jOOQ supports a bunch of optional settings (`org.jooq.conf.Settings`) that are
    mostly used to customize rendered SQL. While all these settings rely on defaults
    that have been carefully chosen for a wide range of cases, there are still situations
    when we have to alter them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer the declarative approach, then you can alter these settings via
    an XML file, named `jooq-settings.xml`, placed in the application classpath. For
    instance, if the rendered SQL doesn''t contain the name of the catalog/schema,
    then `jooq-settings.xml` will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: 'Without these settings, jOOQ renders the name of the catalog/schema for each
    generated SQL. Here is an example in SQL Server:'
  prefs: []
  type: TYPE_NORMAL
- en: Without these settings, jOOQ renders `[classicmodels].[dbo].[customer].[customer_name]`
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these settings, jOOQ doesn't render the schema and catalog names – `[customer].[customer_name]`
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see in the corresponding XSD (`https://www.jooq.org/xsd/jooq-runtime-3.x.x.xsd`),
    jOOQ supports a lot of settings, and most of them are for advanced users and serve
    only certain scenarios. Nevertheless, some of them are more popular than others,
    and you'll see them mentioned in the proper context throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, jOOQ `Settings` can be programmatically shaped via `@Bean`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: 'Via `@Bean`, we customize jOOQ settings globally (at the application level),
    but we can override them locally at the `DSLContext` level via the `DSLContext`
    constructor (`DSL.using()`), as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can locally define `DSLContext`, derived from the current
    `DSLContext` (denoted as `ctx`) and having altered `Settings`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: During this book, you'll have plenty of occasions to see `Settings` at work,
    so there is no need to bother too much for the moment.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to summarize this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have reached several targets, but the most important was
    the introduction of the jOOQ Code Generator using configurative and programmatic
    approaches. More specifically, you saw how to write type-safe queries and how
    to generate and use POJOs and DAOs. These are fundamental skills in jOOQ that
    we'll develop during the entire book.
  prefs: []
  type: TYPE_NORMAL
- en: From this point forward, we'll focus on other topics that will help you to become
    a jOOQ power user.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start diving into the jOOQ core concepts.
  prefs: []
  type: TYPE_NORMAL
