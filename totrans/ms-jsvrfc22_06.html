<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Working with Tabular Data"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Working with Tabular Data</h1></div></div></div><p>Data that makes sense when displayed in a spreadsheet (or a tabular structure) is known as <span class="strong"><strong>tabular data</strong></span>. In web<a id="id776" class="indexterm"/> applications, tabular data is commonly obtained from databases, where the data is natively represented in relational tables. The main JSF component for displaying tabular data is represented by the <code class="literal">&lt;h:dataTable&gt;</code> tag, which is capable of producing HTML classical tables. This chapter is a tribute to this tag, since tabular data is very commonly used and can be manipulated in many ways. Therefore, in this chapter, you will learn about the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a simple JSF table</li><li class="listitem" style="list-style-type: disc">The <code class="literal">CollectionDataModel</code> class of JSF 2.2</li><li class="listitem" style="list-style-type: disc">Sorting tables</li><li class="listitem" style="list-style-type: disc">Deleting a table row</li><li class="listitem" style="list-style-type: disc">Editing/updating a table row</li><li class="listitem" style="list-style-type: disc">Adding a new row</li><li class="listitem" style="list-style-type: disc">Displaying a row number</li><li class="listitem" style="list-style-type: disc">Selecting a single row</li><li class="listitem" style="list-style-type: disc">Selecting multiple rows</li><li class="listitem" style="list-style-type: disc">Nesting tables</li><li class="listitem" style="list-style-type: disc">Paginating tables</li><li class="listitem" style="list-style-type: disc">Generating tables with the JSF API</li><li class="listitem" style="list-style-type: disc">Filtering tables</li><li class="listitem" style="list-style-type: disc">Styling tables</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note125"/>Note</h3><p>This chapter focuses more on the tables that are populated with data that comes from collections (databases). But, you can include in and manipulate the content in the table with almost any JSF UI component.</p></div></div><div class="section" title="Creating a simple JSF table"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Creating a simple JSF table</h1></div></div></div><p>Most commonly, everything <a id="id777" class="indexterm"/>starts from a<a id="id778" class="indexterm"/> POJO class (or a EJB entity class), as shown in the following code—note that tables with hardcoded information were skipped:</p><div class="informalexample"><pre class="programlisting">public class Players {
    
  private String player;
  private byte age;
  private String birthplace;
  private String residence;
  private short height;
  private byte weight;
  private String coach;
  private Date born;
  private int ranking;

  public Players() {}

  public Players(int ranking, String player, byte age, String birthplace, String residence, short height, byte weight, String coach, Date born) {
 
    this.ranking = ranking;
    this.player = player;
    this.age = age;
    this.birthplace = birthplace;
    this.residence = residence;
    this.height = height;
    this.weight = weight;
    this.coach = coach;
    this.born = born;
  }  
 ...
  //getters and setters

}</pre></div><p>Each instance of this POJO class is actually a row in the table displayed to the user (it's  not mandatory, but usually this is how things work). Next, a JSF bean (or CDI bean) will provide a collection of POJO's instances. (The <code class="literal">List</code>, <code class="literal">Map</code>, and <code class="literal">Set</code> instances are the ones that are most commonly used.) In the following code, the <code class="literal">List</code> instance is shown:</p><div class="informalexample"><pre class="programlisting">@Named
@ViewScoped
public class PlayersBean implements Serializable{

  List&lt;Players&gt; data = new ArrayList&lt;&gt;();
  final SimpleDateFormat sdf = new SimpleDateFormat("dd.MM.yyyy");

  public PlayersBean() {
    try {
      data.add(new Players(2, "NOVAK DJOKOVIC", (byte) 26, "Belgrade, Serbia", "Monte Carlo, Monaco", (short) 188, (byte) 80, "Boris Becker, Marian Vajda", sdf.parse("22.05.1987")));
      data.add(new Players(1, "RAFAEL NADAL", (byte) 27, "Manacor, Mallorca, Spain", "Manacor, Mallorca, Spain", (short) 185, (byte) 85, "Toni Nadal", sdf.parse("03.06.1986")));
      data.add(new Players(7, "TOMAS BERDYCH", (byte) 28, "Valasske Mezirici, Czech", "Monte Carlo, Monaco", (short) 196, (byte) 91, "Tomas Krupa", sdf.parse("17.09.1985")));
      ...
 
    } catch (ParseException ex) {             
      Logger.getLogger(PlayersBean.class.getName()).log(Level.SEVERE, null, ex);
    }
  }

  public List&lt;Players&gt; getData() {
    return data;
  }

  public void setData(List&lt;Players&gt; data) {
    this.data = data;
  }
}</pre></div><p>Note that, usually, data is<a id="id779" class="indexterm"/> queried from a database, but this is not quite relevant here.</p><p>This common scenario ends with a piece of code that displays the data on the screen. The code is shown as follows:</p><div class="informalexample"><pre class="programlisting">...
&lt;h:dataTable value="#{playersBean.data}" var="t"&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Ranking&lt;/f:facet&gt;
    #{t.ranking}
  &lt;/h:column&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Name&lt;/f:facet&gt;
    #{t.player}
  &lt;/h:column&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Age&lt;/f:facet&gt;
    #{t.age}
  &lt;/h:column&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Birthplace&lt;/f:facet&gt;
    #{t.birthplace}
  &lt;/h:column&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Residence&lt;/f:facet&gt;
    #{t.residence}
  &lt;/h:column&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Height (cm)&lt;/f:facet&gt;
    #{t.height}
  &lt;/h:column&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Weight (kg)&lt;/f:facet&gt;
    #{t.weight}
  &lt;/h:column&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Coach&lt;/f:facet&gt;
    #{t.coach}
  &lt;/h:column&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Born&lt;/f:facet&gt;
    &lt;h:outputText value="#{t.born}"&gt;                
      &lt;f:convertDateTime pattern="dd.MM.yyyy" /&gt;
    &lt;/h:outputText&gt;
  &lt;/h:column&gt;
&lt;/h:dataTable&gt;
...</pre></div><p>The output is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_06_01.jpg" alt="Creating a simple JSF table"/></div><p>The complete example is available<a id="id780" class="indexterm"/> in the code bundle of this chapter, and is named <code class="literal">ch6_1</code>.</p></div></div>
<div class="section" title="The CollectionDataModel class of JSF 2.2"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec52"/>The CollectionDataModel class of JSF 2.2</h1></div></div></div><p>Until JSF 2.2, the<a id="id781" class="indexterm"/> supported<a id="id782" class="indexterm"/> types for the <code class="literal">&lt;h:dataTable&gt;</code> tag contains <code class="literal">java.util.List</code>, arrays, <code class="literal">java.sql.ResultSet</code>, <code class="literal">javax.servlet.jsp.jstl.sql.Result</code>, <code class="literal">javax.faces.model.DataModel</code>, null (or empty list), and types used as scalar values.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note126"/>Note</h3><p>Starting with JSF 2.2, we can also use <code class="literal">java.util.Collection</code>. This is especially useful to Hibernate/JPA users, who are usually using the <code class="literal">Set</code> collections for entity relationships. Therefore, nothing can stop us from using a <code class="literal">HashSet</code>, <code class="literal">TreeSet</code>, or <code class="literal">LinkedHashSet</code> set for feeding our JSF tables.</p></div></div><p>The next example is like a test case for the most-used Java collections. First, let's declare some collections of <code class="literal">Players</code> as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.ArrayList</code>: This<a id="id783" class="indexterm"/> library implements <code class="literal">java.util.Collection</code>. The <code class="literal">java.util.ArrayList</code> collection is declared as follows:<div class="informalexample"><pre class="programlisting">ArrayList&lt;Players&gt; dataArrayList = new ArrayList&lt;&gt;();</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.LinkedList</code>: This library<a id="id784" class="indexterm"/> implements <code class="literal">java.util.Collection</code>. The <code class="literal">java.util.LinkedList</code> collection is declared as follows:<div class="informalexample"><pre class="programlisting">LinkedList&lt;Players&gt; dataLinkedList = new LinkedList&lt;&gt;();</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.HashSet</code>: This library<a id="id785" class="indexterm"/> implements <code class="literal">java.util.Collection</code>. The <code class="literal">java.util.HashSet</code> collection is declared as follows:<div class="informalexample"><pre class="programlisting">HashSet&lt;Players&gt; dataHashSet = new HashSet&lt;&gt;(); </pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.TreeSet</code>: This library<a id="id786" class="indexterm"/> implements <code class="literal">java.util.Collection</code>. The <code class="literal">java.util.TreeSet</code> collection is declared as follows:<div class="informalexample"><pre class="programlisting">TreeSet&lt;Players&gt; dataTreeSet = new TreeSet&lt;&gt;();</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note127"/>Note</h3><p>For the <code class="literal">TreeSet</code> collection, you<a id="id787" class="indexterm"/> have to use <code class="literal">Comparable</code> elements, or provide <code class="literal">Comparator</code>. Otherwise, the <code class="literal">TreeSet</code> collection can't do its job since it wouldn't know how to order the elements. This means that the <code class="literal">Players</code> class should implement <code class="literal">Comparable&lt;Players&gt;</code>.</p></div></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.LinkedHashSet</code>: This library implements <code class="literal">java.util.Collection</code>. The <code class="literal">java.util.LinkedHashSet</code> collection is declared<a id="id788" class="indexterm"/> as follows:<div class="informalexample"><pre class="programlisting">LinkedHashSet&lt;Players&gt; dataLinkedHashSet = new LinkedHashSet&lt;&gt;();</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.HashMap</code>: This library doesn't implement <code class="literal">java.util.Collection</code>. The <code class="literal">java.util.HashMap</code> collection<a id="id789" class="indexterm"/> is declared as follows:<div class="informalexample"><pre class="programlisting">HashMap&lt;String, Players&gt; dataHashMap = new HashMap&lt;&gt;();</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.TreeMap</code>: This library doesn't implement <code class="literal">java.util.Collection</code>. The <code class="literal">java.util.TreeMap</code> collection<a id="id790" class="indexterm"/> is declared as follows:<div class="informalexample"><pre class="programlisting">TreeMap&lt;String, Players&gt; dataTreeMap = new TreeMap&lt;&gt;();</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.LinkedHashMap</code>: This library<a id="id791" class="indexterm"/> doesn't implement <code class="literal">java.util.Collection</code>. The <code class="literal">java.util.LinkedHashMap</code> collection is declared as follows:<div class="informalexample"><pre class="programlisting">LinkedHashMap&lt;String, Players&gt; dataLinkedHashMap = new LinkedHashMap&lt;&gt;();</pre></div></li></ul></div><p>Supposing that these <a id="id792" class="indexterm"/>collections are populated and<a id="id793" class="indexterm"/> the getters are available; they are used to display their content in a table in the following ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.ArrayList</code>: This library<a id="id794" class="indexterm"/> implements <code class="literal">java.util.Collection</code>.. The following is the code of the <code class="literal">java.util.ArrayList</code> collection:<div class="informalexample"><pre class="programlisting">&lt;h:dataTable value="#{playersBean.dataArrayList}" var="t"&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Ranking&lt;/f:facet&gt;
    #{t.ranking}
  &lt;/h:column&gt;
...
&lt;/h:dataTable&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note128"/>Note</h3><p>In the same manner, we can display in a table the <code class="literal">LinkedList</code>, <code class="literal">HashSet</code>, <code class="literal">TreeSet</code>, and <code class="literal">LinkedHashSet</code> collection classes.</p></div></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.LinkedList</code>: This library implements <code class="literal">java.util.Collection</code>. The following<a id="id795" class="indexterm"/> is the code of the <code class="literal">java.util.LinkedList</code> collection:<div class="informalexample"><pre class="programlisting">&lt;h:dataTable value="#{playersBean.dataLinkedList}" var="t"&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Ranking&lt;/f:facet&gt;
    #{t.ranking}
  &lt;/h:column&gt;
...
&lt;/h:dataTable&gt;</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.HashSet</code>: This library<a id="id796" class="indexterm"/> implements <code class="literal">java.util.Collection</code>. The following is the code<a id="id797" class="indexterm"/> of the <code class="literal">java.util.HashSet</code> collection:<div class="informalexample"><pre class="programlisting">&lt;h:dataTable value="#{playersBean.dataHashSet}" var="t"&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Ranking&lt;/f:facet&gt;
    #{t.ranking}
  &lt;/h:column&gt;
...
&lt;/h:dataTable&gt;</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.TreeSet</code>: This library implements <code class="literal">java.util.Collection</code>. The following <a id="id798" class="indexterm"/>is the<a id="id799" class="indexterm"/> code of the <code class="literal">java.util.TreeSet</code> collection:<div class="informalexample"><pre class="programlisting">&lt;h:dataTable value="#{playersBean.dataTreeSet}" var="t"&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Ranking&lt;/f:facet&gt;
    #{t.ranking}
  &lt;/h:column&gt;
...
&lt;/h:dataTable&gt;</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.LinkedHashSet</code>: This library implements <code class="literal">java.util.Collection</code>. The following<a id="id800" class="indexterm"/> is the code of the <code class="literal">java.util.LinkedHashSet</code> collection:<div class="informalexample"><pre class="programlisting">&lt;h:dataTable value="#{playersBean.dataLinkedHashSet}" var="t"&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Ranking&lt;/f:facet&gt;
    #{t.ranking}
  &lt;/h:column&gt;
...
&lt;/h:dataTable&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note129"/>Note</h3><p>Use the following examples to display a <code class="literal">Map</code> collection in a table. (<code class="literal">HashMap</code>, <code class="literal">TreeMap</code>, and <code class="literal">LinkedHashMap</code> are displayed in the same way.)</p></div></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.HashMap</code>: This library<a id="id801" class="indexterm"/> doesn't implement <code class="literal">java.util.Collection</code>. The following<a id="id802" class="indexterm"/> is the code<a id="id803" class="indexterm"/> of the <code class="literal">java.util.HashMap</code> collection:<div class="informalexample"><pre class="programlisting">&lt;h:dataTable value="#{playersBean.dataHashMap.entrySet()}" var="t"&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Ranking&lt;/f:facet&gt;
    #{t.key}             
  &lt;/h:column&gt; 
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Name&lt;/f:facet&gt;
    #{t.value.player}
  &lt;/h:column&gt;
...
&lt;/h:dataTable&gt;</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.TreeMap</code>: This library<a id="id804" class="indexterm"/> doesn't implement <code class="literal">java.util.Collection</code>. The following is the code of the <code class="literal">java.util.TreeMap</code> collection:<div class="informalexample"><pre class="programlisting">&lt;h:dataTable value="#{playersBean.dataTreeMap.entrySet()}" var="t"&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Ranking&lt;/f:facet&gt;  
    #{t.key}             
  &lt;/h:column&gt; 
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Name&lt;/f:facet&gt;
    #{t.value.player}
  &lt;/h:column&gt;
...
&lt;/h:dataTable&gt;</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.LinkedHashMap</code>: This library doesn't implement <code class="literal">java.util.Collection</code>. The following<a id="id805" class="indexterm"/> is the code of the <code class="literal">java.util.LinkedHashMap</code> collection:<div class="informalexample"><pre class="programlisting">&lt;h:dataTable value="#{playersBean.dataLinkedHashMap.entrySet()}" var="t"&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Ranking&lt;/f:facet&gt;
    #{t.key}             
  &lt;/h:column&gt; 
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Name&lt;/f:facet&gt;
    #{t.value.player}
  &lt;/h:column&gt;
...
&lt;/h:dataTable&gt;</pre></div></li></ul></div><p>For a <code class="literal">Map</code> collection, you <a id="id806" class="indexterm"/>can have a getter<a id="id807" class="indexterm"/> method, as<a id="id808" class="indexterm"/> follows:</p><div class="informalexample"><pre class="programlisting">HashMap&lt;String, Players&gt; dataHashMap = new HashMap&lt;&gt;(); 

public Collection&lt;Players&gt; getDataHashMap() {
  return dataHashMap.values();
}</pre></div><p>In this case, the code<a id="id809" class="indexterm"/> of the table will be as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:dataTable value="#{playersBean.dataHashMap}" var="t"&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Ranking&lt;/f:facet&gt;
    #{t.ranking}             
  &lt;/h:column&gt;
...
&lt;/h:dataTable&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note130"/>Note</h3><p>The <code class="literal">CollectionDataModel</code> class is an extension of the <code class="literal">DataModel</code> class that wraps a <code class="literal">Collection</code> class of Java objects. Furthermore, in this chapter, you will see some examples that will alter this new class.</p></div></div><p>The complete example is<a id="id810" class="indexterm"/> available in the code bundle<a id="id811" class="indexterm"/> of this chapter, and is named <code class="literal">ch6_2</code>.</p></div>
<div class="section" title="Sorting tables"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Sorting tables</h1></div></div></div><p>In the previous examples, the data is<a id="id812" class="indexterm"/> arbitrarily displayed. Sorting the data provides more clarity and accuracy in reading and using the information; for example, see the screenshot of the <span class="emphasis"><em>Creating a simple JSF table</em></span> section. You can try to visually localize the number 1 in the ATP ranking, and number 2 and number 3, and so on, but it is much more useful to have the option of sorting the table by the <span class="strong"><strong>Ranking</strong></span> column. This is a pretty simple task to implement, especially if you are familiar with Java's <code class="literal">List</code>, <code class="literal">Comparator</code>, and <code class="literal">Comparable</code> features. It is beyond the scope of this book to present these features, but you can accomplish most of the sorting tasks by overriding the <code class="literal">compare</code> method, which has a straightforward flow: it compares both of its arguments for order and returns a negative integer, zero, or a positive integer, as the first argument is less than, equal to, or greater than the second. For example, let's see some common sortings:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sort the list of strings, such<a id="id813" class="indexterm"/> as player's names. To do this sorting, the code of the <code class="literal">compare</code> method is as follows:<div class="informalexample"><pre class="programlisting">...
String dir="asc"; //or "dsc" for descending sort

Collections.sort(data, new Comparator&lt;Players&gt;() {
  @Override
  public int compare(Players key_1, Players key_2) {
    if (dir.equals("asc")) {
      return key_1.getPlayer().compareTo(key_2.getPlayer());
    } else {
      return key_2.getPlayer().compareTo(key_1.getPlayer());
    }
  }
});
...</pre></div></li><li class="listitem" style="list-style-type: disc">Sort the list of numbers, such<a id="id814" class="indexterm"/> as the player's rankings. To do<a id="id815" class="indexterm"/> this sorting, the code of the <code class="literal">compare</code> method is as follows:<div class="informalexample"><pre class="programlisting">...
int dir = 1; //1 for ascending, -1 for descending

Collections.sort(data, new Comparator&lt;Players&gt;() {
  @Override
  public int compare(Players key_1, Players key_2) {
    return dir * (key_1.getRanking() - key_2.getRanking());
  }
});
...</pre></div></li><li class="listitem" style="list-style-type: disc">Sort the list of dates, such<a id="id816" class="indexterm"/> as player's birthdays (this works as in the case of strings). To<a id="id817" class="indexterm"/> do this sorting, the code of the <code class="literal">compare</code> method is as follows:<div class="informalexample"><pre class="programlisting">...
String dir="asc"; //or "dsc" for descending sort

Collections.sort(data, new Comparator&lt;Players&gt;() {
  @Override
  public int compare(Players key_1, Players key_2) {
    if (dir.equals("asc")) {
      return key_1.getBorn().compareTo(key_2.getBorn());
    } else {
      return key_2.getBorn().compareTo(key_1.getBorn());
    }
  }
});
...</pre></div></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note131"/>Note</h3><p>The <code class="literal">data</code> argument stands for a <code class="literal">List</code> collection type because not all types of collections can take the place of this one. For example, <code class="literal">List</code> will work perfectly, while <code class="literal">HashSet</code> won't. There are different workarounds to sort collections that are not <code class="literal">List</code> collections. You have to ensure that you choose the right collection for your case.</p></div></div><p>If you know how to write comparators for the selected collection, then everything else is simple. You can<a id="id818" class="indexterm"/> encapsulate the comparators in managed beans methods and attach buttons, links, or anything else that calls those methods. For example, you can add these comparators to the <code class="literal">PlayersBean</code> backing bean, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@Named
@ViewScoped
public class PlayersBean implements Serializable{

  List&lt;Players&gt; data = new ArrayList&lt;&gt;();
  final SimpleDateFormat sdf = new SimpleDateFormat("dd.MM.yyyy");

  public PlayersBean() {
    try {
      data.add(new Players(2, "NOVAK DJOKOVIC", (byte) 26, "Belgrade, Serbia", "Monte Carlo, Monaco", (short) 188, (byte) 80, "Boris Becker, Marian Vajda", sdf.parse("22.05.1987")));
...
    } catch (ParseException ex) {
      Logger.getLogger(PlayersBean.class.getName()).log(Level.SEVERE, null, ex);
    }
  }

  public List&lt;Players&gt; getData() {
    return data;
  }

  public void setData(List&lt;Players&gt; data) {
    this.data = data;
  }

<span class="strong"><strong>  public String sortDataByRanking(final int dir) {</strong></span>

<span class="strong"><strong>    Collections.sort(data, new Comparator&lt;Players&gt;() {</strong></span>
<span class="strong"><strong>      @Override</strong></span>
<span class="strong"><strong>      public int compare(Players key_1, Players key_2) {</strong></span>
<span class="strong"><strong>        return dir * (key_1.getRanking() - key_2.getRanking());</strong></span>
<span class="strong"><strong>      }</strong></span>
<span class="strong"><strong>    });</strong></span>
<span class="strong"><strong>    return null;</strong></span>
<span class="strong"><strong>  }</strong></span>

<span class="strong"><strong>  public String sortDataByName(final String dir) {</strong></span>

<span class="strong"><strong>    Collections.sort(data, new Comparator&lt;Players&gt;() {</strong></span>
<span class="strong"><strong>      @Override</strong></span>
<span class="strong"><strong>      public int compare(Players key_1, Players key_2) {</strong></span>
<span class="strong"><strong>        if (dir.equals("asc")) {</strong></span>
<span class="strong"><strong>          return key_1.getPlayer().compareTo(key_2.getPlayer());</strong></span>
<span class="strong"><strong>        } else {</strong></span>
<span class="strong"><strong>          return key_2.getPlayer().compareTo(key_1.getPlayer());</strong></span>
<span class="strong"><strong>        }</strong></span>
<span class="strong"><strong>      }</strong></span>
<span class="strong"><strong>    });</strong></span>
<span class="strong"><strong>    return null;</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>    </strong></span>
<span class="strong"><strong>  public String sortDataByDate(final String dir) {</strong></span>

<span class="strong"><strong>    Collections.sort(data, new Comparator&lt;Players&gt;() {</strong></span>
<span class="strong"><strong>      @Override</strong></span>
<span class="strong"><strong>      public int compare(Players key_1, Players key_2) {</strong></span>
<span class="strong"><strong>        if (dir.equals("asc")) {</strong></span>
<span class="strong"><strong>          return key_1.getBorn().compareTo(key_2.getBorn());</strong></span>
<span class="strong"><strong>        } else {</strong></span>
<span class="strong"><strong>          return key_2.getBorn().compareTo(key_1.getBorn());</strong></span>
<span class="strong"><strong>        }</strong></span>
<span class="strong"><strong>      }</strong></span>
<span class="strong"><strong>    });</strong></span>
<span class="strong"><strong>    return null;</strong></span>
<span class="strong"><strong>  }</strong></span>
...</pre></div><p>Next, you can easily<a id="id819" class="indexterm"/> modify the code of the <code class="literal">index.xhtml</code> page to provide access to the sorting feature as follows:</p><div class="informalexample"><pre class="programlisting">...
&lt;h:dataTable value="#{playersBean.data}" var="t" border="1"&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;
      &lt;h:commandLink action="#{playersBean.sortDataByRanking(1)}"&gt;
        Ranking ASC
      &lt;/h:commandLink&gt;
   |
      &lt;h:commandLink action="#{playersBean.sortDataByRanking(-1)}"&gt;
        Ranking DSC
      &lt;/h:commandLink&gt;
    &lt;/f:facet&gt;
    #{t.ranking}
  &lt;/h:column&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;
      &lt;h:commandLink action="#{playersBean.sortDataByName('asc')}"&gt;
        Name ASC
      &lt;/h:commandLink&gt;
      |
      &lt;h:commandLink action="#{playersBean.sortDataByName('dsc')}"&gt;
        Name DSC
      &lt;/h:commandLink&gt;
    &lt;/f:facet&gt;
    #{t.player}
  &lt;/h:column&gt;
 ...
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;
      &lt;h:commandLink action="#{playersBean.sortDataByDate('asc')}"&gt;
        Born ASC
      &lt;/h:commandLink&gt;
      |
      &lt;h:commandLink action="#{playersBean.sortDataByDate('dcs')}"&gt;
        Born DSC
      &lt;/h:commandLink&gt;
    &lt;/f:facet&gt;
    &lt;h:outputText value="#{t.born}"&gt;                
      &lt;f:convertDateTime pattern="dd.MM.yyyy" /&gt;
    &lt;/h:outputText&gt;
  &lt;/h:column&gt;
&lt;/h:dataTable&gt;
...</pre></div><p>The output is<a id="id820" class="indexterm"/> shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_06_02.jpg" alt="Sorting tables"/></div><p>The complete example is available in the code bundle of this chapter, and is named <code class="literal">ch6_3_1</code>.</p><p>As you can see, each sorting provides two links: one for ascending and one for descending. We can easily <a id="id821" class="indexterm"/>glue these links in a switch-link, by using an extra property in our view scoped bean. For example, we can declare a property named <code class="literal">sortType</code>, as follows:</p><div class="informalexample"><pre class="programlisting">...
private String sortType = "asc";
...</pre></div><p>Add a simple condition to make it act as a switch between ascending and descending sort as shown in the following code:</p><div class="informalexample"><pre class="programlisting">...
public String sortDataByRanking() {

  Collections.sort(data, new Comparator&lt;Players&gt;() {
    @Override
    public int compare(Players key_1, Players key_2) {
      if(sortType.equals("asc")){                    
        return key_1.getRanking() - key_2.getRanking();
      } else {                    
        return (-1) * (key_1.getRanking() - key_2.getRanking());
      }
    }
  });
  
  sortType = (sortType.equals("asc")) ? "dsc" : "asc";       
  return null;
}
...</pre></div><p>Now, the <code class="literal">index.xhtml</code> page contains a single link per sort, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">...
&lt;h:dataTable value="#{playersBean.data}" var="t" border="1"&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;
      &lt;h:commandLink action="#{playersBean.sortDataByRanking()}"&gt;
        Ranking
      &lt;/h:commandLink&gt; 
    &lt;/f:facet&gt;
    #{t.ranking}
  &lt;/h:column&gt;
...</pre></div><p>The output of this trick can be seen in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_06_03.jpg" alt="Sorting tables"/></div><p>The complete example is<a id="id822" class="indexterm"/> available in the code bundle of this chapter, and is named <code class="literal">ch6_3_2</code>.</p><div class="section" title="Sorting and DataModel – CollectionDataModel"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec70"/>Sorting and DataModel – CollectionDataModel</h2></div></div></div><p>A more complex sorting example involves a decorator class that extends the <code class="literal">javax.faces.model.DataModel</code> class. JSF uses a <code class="literal">DataModel</code> class even if we are not<a id="id823" class="indexterm"/> aware of it, because <a id="id824" class="indexterm"/>each collection (<code class="literal">List</code>, array, <code class="literal">HashMap</code> and so on) is wrapped by JSF in a <code class="literal">DataModel</code> class (or, in a subclass, as <code class="literal">ArrayDataModel</code>, <code class="literal">CollectionDataModel</code>, <code class="literal">ListDataModel</code>, <code class="literal">ResultDataModel</code>, <code class="literal">ResultSetDataModel</code>, or <code class="literal">ScalarDataModel</code>). JSF will call the table <code class="literal">DataModel</code> class's methods when it renders/decodes table data. In the following screenshot, you can see all directly known subclasses of the <code class="literal">DataModel</code> class:</p><div class="mediaobject"><img src="graphics/6466EN_06_04.jpg" alt="Sorting and DataModel – CollectionDataModel"/></div><p>As you will see in this chapter, sometimes you need to be aware of the <code class="literal">DataModel</code> class because you need to alter its default behavior. (It is recommended that you take a quick look at the official documentation of this class's section at <a class="ulink" href="https://javaserverfaces.java.net/nonav/docs/2.2/javadocs/">https://javaserverfaces.java.net/nonav/docs/2.2/javadocs/</a> to obtain a better understanding.) The most common cases involve the rendering row numbers, sorting, and altering the row count<a id="id825" class="indexterm"/> of a table. When you do this, you will expose the <code class="literal">DataModel</code> class instead of the underlying collection.</p><p>For example, let's <a id="id826" class="indexterm"/>suppose that we need to use a collection, such as <code class="literal">HashSet</code>. This collection doesn't guarantee that the iteration order will remain constant over time, which can be a problem if we want to sort it. Of course, there are a few workarounds, such as converting it to <code class="literal">List</code> or using <code class="literal">TreeSet</code> instead, but we can alter the <code class="literal">DataModel</code> class that wraps the <code class="literal">HashSet</code> collection, which is the new JSF 2.2 class, <code class="literal">CollectionDataModel</code>.</p><p>We can accomplish this in a few steps, which are listed as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Extend the <code class="literal">CollectionDataModel</code> class for overriding the default behavior of its methods, as shown in the following code:<div class="informalexample"><pre class="programlisting">public class SortDataModel&lt;T&gt; extends CollectionDataModel&lt;T&gt; {
...</pre></div></li><li class="listitem">Provide a constructor and use it for passing the original model (in this case, <code class="literal">CollectionDataModel</code>). Besides the original model, we need an array of integers representing the indexes of rows (For example, <code class="literal">rows[0]=0</code>, <code class="literal">rows[1]=1</code>, ... <code class="literal">rows[n]= model.getRowCount()</code>). Sorting the row indexes will actually sort the <code class="literal">HashSet</code> collection, as shown in the following code:<div class="informalexample"><pre class="programlisting">...
CollectionDataModel&lt;T&gt; model;
private Integer[] rows;

public SortDataModel(CollectionDataModel&lt;T&gt; model) {
  this.model = model;    
  initRows();
}

private void initRows() {
  int rowCount = model.getRowCount();
  if (rowCount != -1) {
    this.rows = new Integer[rowCount];
    for (int i = 0; i &lt; rowCount; ++i) {
      rows[i] = i;
    }
  }
}
...</pre></div></li><li class="listitem">Next, we need to override the <code class="literal">setRowIndex</code> method to<a id="id827" class="indexterm"/> replace the default row index, as shown<a id="id828" class="indexterm"/> in the following code:<div class="informalexample"><pre class="programlisting">@Override
public void setRowIndex(int rowIndex) {

  if ((0 &lt;= rowIndex) &amp;&amp; (rowIndex &lt; rows.length)) {
    model.setRowIndex(rows[rowIndex]);
  } else {
    model.setRowIndex(rowIndex);
  }
}</pre></div></li><li class="listitem">Finally, provide a comparator <a id="id829" class="indexterm"/>as follows:<div class="informalexample"><pre class="programlisting">public void sortThis(final Comparator&lt;T&gt; comparator) {
  Comparator&lt;Integer&gt; rowc = new Comparator&lt;Integer&gt;() {
    @Override
    public int compare(Integer key_1, Integer key_2) {
      T key_1_data = getData(key_1);
      T key_2_data = getData(key_2);
      return comparator.compare(key_1_data, key_2_data);
    }
  };
  Arrays.sort(rows, rowc);
}

private T getData(int row) {
  int baseRowIndex = model.getRowIndex();
  model.setRowIndex(row);
  T newRowData = model.getRowData();
  model.setRowIndex(baseRowIndex);

  return newRowData;
}</pre></div></li><li class="listitem">Now, our custom <code class="literal">CollectionDataModel</code> class with sorting capabilities is ready. We can test it by declaring and<a id="id830" class="indexterm"/> populating <code class="literal">HashSet</code>, wrapping it in the original <code class="literal">CollectionDataModel</code> class, and passing it to the custom <code class="literal">SortDataModel</code> class, as shown in the following code:<div class="informalexample"><pre class="programlisting">private HashSet&lt;Players&gt; dataHashSet = new HashSet&lt;&gt;();
private SortDataModel&lt;Players&gt; sortDataModel;  
...
public PlayersBean() {
  dataHashSet.add(new Players(2, "NOVAK DJOKOVIC", (byte) 26, "Belgrade, Serbia", "Monte Carlo, Monaco", (short) 188, (byte) 80, "Boris Becker, Marian Vajda", sdf.parse("22.05.1987")));
...

  sortDataModel = new SortDataModel&lt;&gt;(new CollectionDataModel&lt;&gt;(dataHashSet));
}
...</pre></div></li><li class="listitem">Since we are the caller, we need<a id="id831" class="indexterm"/> to provide a comparator. The complete example is available in the code bundle of this chapter, and is named <code class="literal">ch6_3_3</code>.</li></ol></div></div></div>
<div class="section" title="Deleting a table row"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec54"/>Deleting a table row</h1></div></div></div><p>Deleting a table row can<a id="id832" class="indexterm"/> be easily implemented by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define a method in the managed bean that receives information about the row that should be deleted, and remove it from the collection that feeds the table.<p>For example, for a <code class="literal">Set</code> collection, the code will be as follows (<code class="literal">HashSet&lt;Players&gt;</code>):</p><div class="informalexample"><pre class="programlisting">public void deleteRowHashSet(Players player) {
  dataHashSet.remove(player);       
}</pre></div><p>For <code class="literal">Map&lt;String, Players&gt;</code>, the code will be as follows:</p><div class="informalexample"><pre class="programlisting">public void deleteRowHashMap(Object key) {
  dataHashMap.remove(String.valueOf(key));       
}</pre></div></li><li class="listitem">Besides columns containing data, add a new column in the table named <span class="strong"><strong>Delete</strong></span>. Each row can be a link to the <code class="literal">delete</code><span class="emphasis"><em>XXX</em></span> method.<p>For example, we can delete a value from <code class="literal">Set</code> (<code class="literal">HashSet&lt;Players&gt;</code>), as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:dataTable value="#{playersBean.dataHashSet}" var="t"&gt;
...
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Delete&lt;/f:facet&gt;
    &lt;h:commandLink value="Delete" action="#{playersBean.deleteRowHashSet(t)}" /&gt; 
  &lt;/h:column&gt;
...
&lt;/h:dataTable&gt;</pre></div><p>And from <code class="literal">Map&lt;String, Players&gt;</code>, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:dataTable value="#{playersBean.dataHashMap.entrySet()}" var="t"&gt;
...
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Delete&lt;/f:facet&gt;
    &lt;h:commandLink value="Delete" action="#{playersBean.deleteRowHashMap(t.key)}" /&gt; 
  &lt;/h:column&gt;
...
&lt;/h:dataTable&gt;</pre></div></li></ol></div><p>In the following <a id="id833" class="indexterm"/>screenshot, you can see a possible output:</p><div class="mediaobject"><img src="graphics/6466EN_06_05.jpg" alt="Deleting a table row"/></div><p>The complete example is <a id="id834" class="indexterm"/>available in the code bundle of this chapter, and is named <code class="literal">ch6_4</code>.</p></div>
<div class="section" title="Editing/updating a table row"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec55"/>Editing/updating a table row</h1></div></div></div><p>One of the most convenient approaches for editing/updating<a id="id835" class="indexterm"/> a table row consists of using a special property to track the row edit status. This property can be named <code class="literal">edited</code> and it should be of the type <code class="literal">boolean</code> (default <code class="literal">false</code>). Define it in the POJO class, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public class Players {
  ...
  private boolean edited;
  ...
  public boolean isEdited() {
    return edited;
  }

  public void setEdited(boolean edited) {
    this.edited = edited;
  }        
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note132"/>Note</h3><p>If your POJO class is an entity class, then define this new property as transient, using the <code class="literal">@Transient</code> annotation or transient modifier. This annotation will tell JPA that this property doesn't participate in persistence and that its values are never stored in the database.</p></div></div><p>Next, assign an <span class="strong"><strong>Edit</strong></span> link to <a id="id836" class="indexterm"/>each row. Using the <code class="literal">rendered</code> attribute, you can easily show/hide the link using a simple EL condition; initially, the link is visible for each row. For example, take a look at the following use cases:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For a <code class="literal">Set</code> collection, the code is as follows:<div class="informalexample"><pre class="programlisting">...
&lt;h:column&gt;
  &lt;f:facet name="header"&gt;Edit&lt;/f:facet&gt;
  &lt;h:commandLink value="Edit" action="#{playersBean.editRowHashSet(t)}" rendered="#{not t.edited}" /&gt; 
&lt;/h:column&gt;
...</pre></div></li><li class="listitem" style="list-style-type: disc">For a <code class="literal">Map</code> collection, the code is as follows:<div class="informalexample"><pre class="programlisting">...
&lt;h:column&gt;
  &lt;f:facet name="header"&gt;Edit&lt;/f:facet&gt;
  &lt;h:commandLink value="Edit" action="#{playersBean.editRowHashMap(t.value)}" rendered="#{not t.value.edited}"/&gt; 
&lt;/h:column&gt;
...</pre></div></li></ul></div><p>When the link is clicked, the <code class="literal">edited</code> property will be switched from <code class="literal">false</code> to <code class="literal">true</code> and the table will be re-rendered as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For a <code class="literal">Set</code> collection, the code of <a id="id837" class="indexterm"/>the <code class="literal">editRowHashSet</code> method is as follows:<div class="informalexample"><pre class="programlisting">public void editRowHashSet(Players player) {
  player.setEdited(true);
}</pre></div></li><li class="listitem" style="list-style-type: disc">For a <code class="literal">Map</code> collection, the<a id="id838" class="indexterm"/> code of the <code class="literal">editRowHashSet</code> method is as follows:<div class="informalexample"><pre class="programlisting">public void editRowHashMap(Players player) {
  player.setEdited(true);
}</pre></div></li></ul></div><p>This means that the link is<a id="id839" class="indexterm"/> not rendered anymore and the user should be able to edit that table row. You need to switch between the <code class="literal">&lt;h:outputText&gt;</code> tag, used to display data (visible when the <code class="literal">edited</code> property is <code class="literal">false</code>), and the <code class="literal">&lt;h:inputText&gt;</code> tag, which is used to collect data (visible when the <code class="literal">edited</code> property is <code class="literal">true</code>). Using the <code class="literal">rendered</code> attribute again will do the trick, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For a <code class="literal">Set</code> collection, the code is modified as follows:<div class="informalexample"><pre class="programlisting">...
&lt;h:column&gt;
  &lt;f:facet name="header"&gt;Name&lt;/f:facet&gt;
  &lt;h:inputText value="#{t.player}" rendered="#{t.edited}" /&gt;
  &lt;h:outputText value="#{t.player}" rendered="#{not t.edited}" /&gt;
&lt;/h:column&gt;
...</pre></div></li><li class="listitem" style="list-style-type: disc">For a <code class="literal">Map</code> collection, the code is modified as follows:<div class="informalexample"><pre class="programlisting">...
&lt;h:column&gt;
  &lt;f:facet name="header"&gt;Name&lt;/f:facet&gt;
  &lt;h:inputText value="#{t.value.player}" rendered="#{t.value.edited}" /&gt;
  &lt;h:outputText value="#{t.value.player}" rendered="#{not t.value.edited}" /&gt;
&lt;/h:column&gt;
...</pre></div></li></ul></div><p>Finally, you need a button to save changes; this button will set the <code class="literal">edited</code> property back to <code class="literal">false</code>, preparing the table for more edits, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For a <code class="literal">Set</code> collection, the code for the button is as follows:<div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Save Hash Set Changes" action="#{playersBean.saveHashSet()}" /&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">For a <code class="literal">Map</code> collection, the code for the button is as follows:<div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Save Hash Map Changes" action="#{playersBean.saveHashMap()}" /&gt;</pre></div></li></ul></div><p>This is a straightforward <a id="id840" class="indexterm"/>action, as you can see in the following points—values inserted in the input textbox are automatically saved in the collection:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For a <code class="literal">Set</code> collection, the code is as follows:<div class="informalexample"><pre class="programlisting">public void saveHashSet() {
  for (Players player : dataHashSet) {
    player.setEdited(false);
  }
}</pre></div></li><li class="listitem" style="list-style-type: disc">For a <code class="literal">Map</code> collection, the code is as follows:<div class="informalexample"><pre class="programlisting">public void saveHashMap() {
  for (Map.Entry pairs : dataHashMap.entrySet()) {
    ((Players) pairs.getValue()).setEdited(false);
  }
}</pre></div></li></ul></div><p>Done! In the following screenshot, you can see a possible output:</p><div class="mediaobject"><img src="graphics/6466EN_06_06.jpg" alt="Editing/updating a table row"/></div><p>The complete example is available in the code bundle of this chapter, and is named <code class="literal">ch6_5</code>.</p></div>
<div class="section" title="Adding a new row"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec56"/>Adding a new row</h1></div></div></div><p>Adding a new row is<a id="id841" class="indexterm"/> also a simple task. First, you need to provide a form that reflects a table row content, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_06_07.jpg" alt="Adding a new row"/></div><p>This form can be easily implemented using the following code:</p><div class="informalexample"><pre class="programlisting">...
&lt;h:inputText value="#{playersBean.player}"/&gt;
&lt;h:inputText value="#{playersBean.age}"/&gt;
&lt;h:inputText value="#{playersBean.birthplace}"/&gt;
&lt;h:inputText value="#{playersBean.residence}"/&gt;
&lt;h:inputText value="#{playersBean.height}"/&gt;
&lt;h:inputText value="#{playersBean.weight}"/&gt;
&lt;h:inputText value="#{playersBean.coach}"/&gt;
&lt;h:inputText value="#{playersBean.born}"&gt;
  &lt;f:convertDateTime pattern="dd.MM.yyyy" /&gt;
&lt;/h:inputText&gt;
&lt;h:inputText value="#{playersBean.ranking}"/&gt;
&lt;h:commandButton value="Add Player" action="#{playersBean.addNewPlayer()}"/&gt;
...</pre></div><p>The button labeled <span class="strong"><strong>Add Player</strong></span> will call a managed bean method that creates a new <code class="literal">Players</code> instance and adds it in the collection that feeds the table, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public void addNewPlayer() {
  Players new_player = new Players(ranking, player, age, birthplace, residence, height, weight, coach, born);
  //adding in a Set
  dataHashSet.add(new_player); 
  //adding in a Map
  dataHashMap.put(String.valueOf(ranking), new_player);
}</pre></div><p>In the following screenshot, you can see the newly added row from the data shown in  the preceding screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_06_08.jpg" alt="Adding a new row"/></div><p>The complete example is available in the code bundle of this chapter, and is named <code class="literal">ch6_6_1</code>.</p><p>A more elegant approach is<a id="id842" class="indexterm"/> to add a row directly in the table and eliminate this user form. This can be easily accomplished by following these simple steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Use linked collections (for example, use <code class="literal">LinkedHashSet</code> instead of <code class="literal">HashSet</code> or <code class="literal">LinkedHashMap</code> instead of <code class="literal">HashMap</code>). A table is populated by iterating the corresponding collection, but some collections, such as <code class="literal">HashSet</code> or <code class="literal">HashMap</code>, do not provide an iteration order, which means that the iteration order is unpredictable. This is important because we want to add a row at the end of the table, but this is hard to achieve with an unpredictable iteration order. But a linked collection would fix this issue, which is shown in the following code:<div class="informalexample"><pre class="programlisting">LinkedHashSet&lt;Players&gt; dataHashSet = new LinkedHashSet&lt;&gt;();
LinkedHashMap&lt;String, Players&gt; dataHashMap = new LinkedHashMap&lt;&gt;();</pre></div></li><li class="listitem">Add a new row by creating a new item in the corresponding collection and activate the editable mode using the <code class="literal">Set</code> and <code class="literal">Map</code> collections as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The following is the code for a linked <code class="literal">Set</code> collection:<div class="informalexample"><pre class="programlisting">...
&lt;h:commandButton value="Add New Row"  action="#{playersBean.addNewRowInSet()}" /&gt;
...
public void addNewRowInSet() {
  Players new_player = new Players();
  new_player.setEdited(true);
  dataHashSet.add(new_player);
}</pre></div></li><li class="listitem" style="list-style-type: disc">The following is the code for a linked <code class="literal">Map</code> collection:<div class="informalexample"><pre class="programlisting">...
&lt;h:commandButton value="Add New Row" action="#{playersBean.addNewRowInMap()}" /&gt;
...

public void addNewRowInMap() {
  Players new_player = new Players();
  new_player.setEdited(true);
  dataHashMap.put(String.valueOf(dataHashMap.size() + 1), new_player);
}</pre></div></li></ul></div></li></ol></div><p>Check out the following screenshot for a possible output:</p><div class="mediaobject"><img src="graphics/6466EN_06_09.jpg" alt="Adding a new row"/></div><p>The complete example is <a id="id843" class="indexterm"/>available in the code bundle of this chapter, and is named <code class="literal">ch6_6_2</code>.</p></div>
<div class="section" title="Displaying row numbers"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec57"/>Displaying row numbers</h1></div></div></div><p>By default, JSF doesn't provide a method for displaying row numbers. But as you can see in the screenshot depicting<a id="id844" class="indexterm"/> the output in the <span class="emphasis"><em>Editing/updating a table row</em></span> section, there is a column named <span class="strong"><strong>No</strong></span> that displays row numbers. You can obtain this column in at least two ways. The simplest workaround consists of binding the table to the current view, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:dataTable value="..." binding="#{table}" var="t"&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;No&lt;/f:facet&gt; 
    #{table.rowIndex+1}.
  &lt;/h:column&gt;
...</pre></div><p>Another approach is to obtain it using the <code class="literal">DataModel</code> class, which has the <code class="literal">getRowIndex</code> method to return the currently selected row number. In order to do that, you need to wrap the collection in a <code class="literal">DataModel</code> class.</p><p>The example named <code class="literal">ch6_7</code> contains the first approach of this task.</p></div>
<div class="section" title="Selecting a single row"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec58"/>Selecting a single row</h1></div></div></div><p>The easiest implementation<a id="id845" class="indexterm"/> of such a task is to provide a button for each row in the table. When a button is clicked, it can pass the selected row, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:dataTable value="#{playersBean.dataHashSet}" var="t" border="1"&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Select&lt;/f:facet&gt;
    &lt;h:commandButton value="#" action="#{playersBean.showSelectedPlayer(t)}"/&gt; 
    &lt;/h:column&gt;
...</pre></div><p>Since the <code class="literal">showSelectedPlayer</code> method<a id="id846" class="indexterm"/> receives the selected row, it can process it further with no other<a id="id847" class="indexterm"/> requirements. The complete example is available in the code bundle of this chapter, and is named <code class="literal">ch6_8_1</code>.</p><p>Generally speaking, selecting one item from a bunch of items is a job for a group of radio buttons. In a JSF table, items are rows, and adding a radio button per row will result in a column as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_06_10.jpg" alt="Selecting a single row"/></div><p>However, adding radio buttons in the <code class="literal">&lt;h:column&gt;</code> tag using the <code class="literal">&lt;h:selectOneRadio&gt;</code> tag doesn't behave as expected. The main functionality of radio buttons doesn't work; selecting one radio will not deselect the rest of radios in the group. It is now acting more like a group of checkboxes. You can fix this issue by implementing a deselection mechanism through JavaScript. Moreover, at this point, you can set a JSF hidden field with the value of the selected row. For example, if the table is populated by <code class="literal">Map</code>, you use the following code:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
//&lt;![CDATA[
    function deselectRadios(id, val) {
    
      var f = document.getElementById("hashMapFormId");
      for (var i = 0; i &lt; f.length; i++)
      {
        var e = f.elements[i];
        var eid = e.id;
        if (eid.indexOf("radiosId") !== -1) {
          if (eid.indexOf(id) === -1) {
            e.checked = false;
          } else {
            e.checked = true;
            document.getElementById("hashMapFormId:selectedRowId").value = val;
          }
        }
      }
    }
  //]]&gt;
&lt;/script&gt;  </pre></div><p>First, you need to find the form<a id="id848" class="indexterm"/> containing the radios by the ID. Afterwards, iterate through the form's children, and identify each radio by a fixed part of its ID. Check only the radio that was selected by the user, and uncheck the rest of them. Next, populate a hidden<a id="id849" class="indexterm"/> field with the value of the selected row. The ID of the selected radio and the row value are provided as arguments, as follows (in this case, the table is populated from <code class="literal">Map</code>):</p><div class="informalexample"><pre class="programlisting">&lt;h:dataTable value="#{playersBean.dataHashMap.entrySet()}" var="t"&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Select&lt;/f:facet&gt;
    &lt;h:selectOneRadio id="radiosId" 
      onclick="deselectRadios(this.id, '#{t.key}');"&gt;
      &lt;f:selectItem itemValue="null"/&gt;
    &lt;/h:selectOneRadio&gt;
  &lt;/h:column&gt;
...</pre></div><p>Besides the hidden field for storing the selected row information, you need a button labeled <span class="strong"><strong>Show Hash Map Selection</strong></span>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:inputHidden id="selectedRowId" value="#{playersBean.selectedPlayerKey}"/&gt;
&lt;h:commandButton value="Show Hash Map Selection" action="#{playersBean.showSelectedPlayer()}" /&gt;</pre></div><p>The following <code class="literal">showSelectedPlayer</code> method is ready to process the selected row:</p><div class="informalexample"><pre class="programlisting">public void showSelectedPlayer() {
  Players player = dataHashMap.get(selectedPlayerKey);

  if (player != null) {
    logger.log(Level.INFO, "Selected player:{0}", player.getPlayer());
  } else {
    logger.log(Level.INFO, "No player selected!");
  }        
}</pre></div><p>Done! The complete example is available in the code bundle of this chapter and is named <code class="literal">ch6_8_2</code>.</p><p>If you feel that using<a id="id850" class="indexterm"/> a hidden field is not a very elegant approach, then you can<a id="id851" class="indexterm"/> replace its role by using the <code class="literal">valueChangeListener</code> attribute of the <code class="literal">&lt;h:selectOneRadio&gt;</code> tag.</p><p>In the code bundle of this chapter, you can find an example that uses the <code class="literal">valueChangeListener</code> attribute named <code class="literal">ch6_8_3</code>.</p></div>
<div class="section" title="Selecting multiple rows"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec59"/>Selecting multiple rows</h1></div></div></div><p>Multiple selection is commonly<a id="id852" class="indexterm"/> achieved using groups of checkboxes. One of the most convenient approaches for multiple selections consists of using a special property for tracking the row selection status. This property can be named <code class="literal">selected</code> and it should be of type <code class="literal">boolean</code> (default <code class="literal">false</code>). You can define it in the POJO class as follows:</p><div class="informalexample"><pre class="programlisting">public class Players {
...
  private boolean selected;
  ...
  public boolean isSelected() {
    return selected;
  }

  public void setSelected(boolean selected) {
    this.selected = selected;
}
...</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note133"/>Note</h3><p>If your POJO class is an entity class, then define this new property as transient, using the <code class="literal">@Transient</code> annotation or transient modifier. This annotation will tell JPA that this property doesn't participate in persistence and his values are never stored in the database.</p></div></div><p>Next, assign a checkbox to each row (<code class="literal">&lt;h:selectBooleanCheckbox&gt;</code>). Using the <code class="literal">value</code> attribute and the <code class="literal">selected</code> property, you can easily track the selection status, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:dataTable value="#{playersBean.dataHashSet}" var="t"&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Select&lt;/f:facet&gt;
    &lt;h:selectBooleanCheckbox value="#{t.selected}" /&gt; 
  &lt;/h:column&gt;
...</pre></div><p>So the <code class="literal">&lt;h:selectBooleanCheckbox&gt;</code> tag<a id="id853" class="indexterm"/> will do the hard work for us (we just exploit its natural behavior), therefore, all you need is a button labeled <span class="strong"><strong>Show Selected Players</strong></span>, as shown in the following line:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Show Selected Players" action="#{playersBean.showSelectedPlayers()}" /&gt;</pre></div><p>The <code class="literal">showSelectedPlayers</code> method<a id="id854" class="indexterm"/> has an easy task. It can iterate the collection and check the status of the <code class="literal">selected</code> property for each item; this is a good chance to reset the selected items as well. For example, you<a id="id855" class="indexterm"/> can extract the selected items in a separate list, as follows:</p><div class="informalexample"><pre class="programlisting">...
HashSet&lt;Players&gt; dataHashSet = new HashSet&lt;&gt;();
List&lt;Players&gt; selectedPlayers  = new ArrayList&lt;&gt;();
...
public void showSelectedPlayers() {
  selectedPlayers.clear();
  for (Players player : dataHashSet) {
    if(player.isSelected()){
      logger.log(Level.INFO, "Selected player: {0}", layer.getPlayer());
      selectedPlayers.add(player);
      player.setSelected(false);
    }
  }   
       
  //the selected players were extracted in a List ...
}</pre></div><p>The complete example is available in the code bundle of this chapter, and is named <code class="literal">ch6_8_4</code>.</p><p>If you don't want to use an extra property, such as <code class="literal">selected</code>, you can use a <code class="literal">Map &lt;String, Boolean&gt;</code> map. The code is pretty straightforward; therefore, a quick look over the complete code, <code class="literal">ch6_8_5</code>, will clarify things instantly.</p></div>
<div class="section" title="Nesting tables"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec60"/>Nesting tables</h1></div></div></div><p>It's most likely that you won't need to display a table inside another table, but there are cases when this workaround can be<a id="id856" class="indexterm"/> useful in obtaining a clear presentation of the data. For example, nested collections can be presented as nested tables as follows:</p><div class="informalexample"><pre class="programlisting">HashMap&lt;Players, HashSet&lt;Trophies&gt;&gt; dataHashMap = new HashMap&lt;&gt;();</pre></div><p>Here, players are <a id="id857" class="indexterm"/>stored in <code class="literal">HashMap</code> as keys, and each player has a collection (<code class="literal">HashSet</code>) of trophies. Each <code class="literal">HashSet</code> value is a value in <code class="literal">HashMap</code>. Therefore, you need to display the table of players; however, you need to display each player's trophies. This can be achieved as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:dataTable value="#{playersBean.dataHashMap.entrySet()}" var="t"&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Ranking&lt;/f:facet&gt;
    #{t.key.ranking}
  &lt;/h:column&gt;
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Name&lt;/f:facet&gt;
    #{t.key.player}
  &lt;/h:column&gt;
    ...
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;Trophies 2013&lt;/f:facet&gt;
    &lt;h:dataTable value="#{t.value}" var="q" border="1"&gt;
    &lt;h:column&gt; 
      #{q.trophy}
    &lt;/h:column&gt;
    &lt;/h:dataTable&gt;
  &lt;/h:column&gt;
&lt;/h:dataTable&gt;</pre></div><p>A possible output for the preceding code can be seen in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_06_11.jpg" alt="Nesting tables"/></div><p>The complete application<a id="id858" class="indexterm"/> is named <code class="literal">ch6_9</code>, and is available in the <a id="id859" class="indexterm"/>code bundle of this chapter.</p></div>
<div class="section" title="Paginating tables"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec61"/>Paginating tables</h1></div></div></div><p>When you need to display<a id="id860" class="indexterm"/> large tables (with many rows), it can be useful to implement a pagination mechanism. There are many advantages, such as its fancy look, the clear presentation of data, saving space in web pages, and lazy loading.</p><p>In a standard version of such a table, we should be able to navigate to the first page, last page, next page, previous page, and in some tables, to select the number of rows displayed on one page.</p><p>When you bind a table to its backing bean, you have access to three handy properties, which are listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">first</code>: This property<a id="id861" class="indexterm"/> represents the first row number that is displayed in the current table page (it starts from the default value <code class="literal">0</code>). The value for this property can be specified using the <code class="literal">first</code> attribute of the <code class="literal">&lt;h:dataTable&gt;</code> tag. In the JSF API, this is accessible through the <code class="literal">HtmlDataTable.getFirst</code> and <code class="literal">HtmlDataTable.setFirst</code> methods.</li><li class="listitem" style="list-style-type: disc"><code class="literal">rows</code>: This property<a id="id862" class="indexterm"/> represents the number of rows displayed in a single page, starting from <code class="literal">first</code>. The value for this property can be specified using the <code class="literal">rows</code> attribute of the <code class="literal">&lt;h:dataTable&gt;</code> tag. In the JSF API, this is accessible through the <code class="literal">HtmlDataTable.getRows</code> and <code class="literal">HtmlDataTable.setRows</code> methods.</li><li class="listitem" style="list-style-type: disc"><code class="literal">rowCount</code>: This property<a id="id863" class="indexterm"/> represents the total number of rows, from all pages, starting from row 0. There is no attribute for this property. In the JSF API, this is accessible through the <code class="literal">HtmlDataTable.getRowCount</code> method. Setting the row count can be accomplished through the data model, as you will see later. By default, is determined by JSF.</li></ul></div><p>In the following screenshot, these properties can be seen in detail:</p><div class="mediaobject"><img src="graphics/6466EN_06_12.jpg" alt="Paginating tables"/></div><p>The preceding information<a id="id864" class="indexterm"/> is very useful for to implementing the pagination mechanism. First, we bind the table, and set the first row number and the number of rows per page, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:dataTable value="#{playersBean.dataHashSet}" binding="#{playersBean.table}" rows="#{playersBean.rowsOnPage}" first="0" var="t"&gt;
...</pre></div><p>Based on some arithmetic and EL condition's support, we can conclude the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first row number, the row number per page, and the total row count are accessible via the following code:<div class="informalexample"><pre class="programlisting">&lt;b&gt;FIRST:&lt;/b&gt; #{playersBean.table.first}
&lt;b&gt;ROWS:&lt;/b&gt; #{playersBean.table.rows}
&lt;b&gt;ROW COUNT:&lt;/b&gt; #{playersBean.table.rowCount}                    </pre></div></li><li class="listitem" style="list-style-type: disc">Navigate to the first page by using the following code:<div class="informalexample"><pre class="programlisting">public void goToFirstPage() {
  table.setFirst(0);
}</pre></div><p>A button that accomplishes this navigation can be disabled by an EL condition, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="First Page" action="#{playersBean.goToFirstPage()}" disabled="#{playersBean.table.first eq 0}" /&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">Navigate to the next page by using the following code:<div class="informalexample"><pre class="programlisting">public void goToNextPage() {
  table.setFirst(table.getFirst() + table.getRows());
}</pre></div><p>A button that accomplishes this navigation can be disabled by an EL condition, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Next Page" action="#{playersBean.goToNextPage()}" disabled="#{playersBean.table.first + playersBean.table.rows ge playersBean.table.rowCount}" /&gt; </pre></div></li><li class="listitem" style="list-style-type: disc">Navigate to the<a id="id865" class="indexterm"/> previous page by using the following code:<div class="informalexample"><pre class="programlisting">public void goToPreviousPage() {
  table.setFirst(table.getFirst() - table.getRows());
}     </pre></div><p>A button that accomplishes this navigation can be disabled by an EL condition, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Previous Page" action="#{playersBean.goToPreviousPage()}" disabled="#{playersBean.table.first eq 0}" /&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">Navigate to the last page by using the following code:<div class="informalexample"><pre class="programlisting">public void goToLastPage() {
  int totalRows = table.getRowCount();
  int displayRows = table.getRows();
  int full = totalRows / displayRows;
  int modulo = totalRows % displayRows;

  if (modulo &gt; 0) {
    table.setFirst(full * displayRows);
  } else {
    table.setFirst((full - 1) * displayRows);
  }
}</pre></div><p>A button that accomplishes this navigation can be disabled by an EL condition, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Last Page" action="#{playersBean.goToLastPage()}" disabled="#{playersBean.table.first + playersBean.table.rows ge playersBean.table.rowCount}" /&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">Display the <span class="strong"><strong>current page</strong></span> of the <span class="strong"><strong>total pages</strong></span> message by using the following code:<div class="informalexample"><pre class="programlisting">&lt;h:outputText value="#{(playersBean.table.first div playersBean.table.rows) + 1}"&gt;
    &lt;f:converter converterId="javax.faces.Integer"/&gt;
&lt;/h:outputText&gt;
of   
&lt;h:outputText value="#{playersBean.table.rowCount mod playersBean.table.rows eq 0 ? (playersBean.table.rowCount div playersBean.table.rows) : ((playersBean.table.rowCount div playersBean.table.rows) + 1)-(((playersBean.table.rowCount div playersBean.table.rows) + 1) mod 1)}"&gt;
    &lt;f:converter converterId="javax.faces.Integer"/&gt;
&lt;/h:outputText&gt;</pre></div></li></ul></div><p>Merging all these chunks<a id="id866" class="indexterm"/> of code in a sample application (see the application <code class="literal">ch6_10_1</code>), will result in something like the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_06_13.jpg" alt="Paginating tables"/></div><p>The biggest issue here is that even if the data is displayed in pages, they are still loaded in the memory as a bulk. In this case, pagination is just a <span class="emphasis"><em>slicer</em></span> of the collection, which has only visual effect. In reality, the pagination is the effect of <span class="strong"><strong>lazy loading</strong></span>, which represents a technique for querying only a portion of data from a database (instead of slicing the data in memory, you slice it from the database directly). There are many kinds of querying in a database, but in Java web/enterprise applications, EJB/JPA is the most used. EJB and JPA are large technologies that can't be covered here, but with some assumptions it will be very easy to understand the upcoming example.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note134"/>Note</h3><p>If you feel that EJB/JPA are not good choices, you should can take into account the fact that the <code class="literal">&lt;h:dataTable&gt;</code> tag also supports <code class="literal">java.sql.ResultSet</code>, <code class="literal">javax.servlet.jsp.jstl.Result</code>, and <code class="literal">javax.sql.CachedRowSet</code>. So, for tests, you can use plain JDBC as well.</p></div></div><p>Instead of the <code class="literal">Players</code> POJO class, this time you will use a <code class="literal">Players</code> JPA entity that is bounded to a table named <code class="literal">PLAYERS</code>. This table contains the data that should be displayed in the JSF table and it was created in Apache Derby RDBMS, in the <code class="literal">APP</code> database (if you have NetBeans 8.0 with GlassFish 4.0, then this RDBMS and the <code class="literal">APP</code> database are out of the box). The idea is to query this table to obtain only the rows from <code class="literal">first</code> to <code class="literal">first</code> + <code class="literal">rows</code>, which is exactly the amount of rows displayed per page. This can be easily accomplished by JPA using the <code class="literal">setFirstResult</code> and <code class="literal">setMaxResults</code> methods of a query (the <code class="literal">loadPlayersAction</code> method was defined in a EJB component, named <code class="literal">PlayersSessionBean</code>), as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public HashSet&lt;Players&gt; loadPlayersAction(int first, int max) {

  Query query = em.createNamedQuery("Players.findAll");
  query.setFirstResult(first);
  query.setMaxResults(max);

  return new HashSet(query.getResultList());
}</pre></div><p>So, passing the right <code class="literal">first</code> and <code class="literal">max</code> arguments will return the needed rows!</p><p>But pagination works <a id="id867" class="indexterm"/>if we know the total number of rows, since without this we can't calculate the number of pages, or the last page, and so on. In JPA, we can do this easily (the <code class="literal">countPlayersAction</code> method was defined in a EJB component, named <code class="literal">PlayersSessionBean</code>) by using the following code:</p><div class="informalexample"><pre class="programlisting">public int countPlayersAction() {
  Query query = em.createNamedQuery("Players.countAll");
  return ((Long)query.getSingleResult()).intValue();
}</pre></div><p>Knowing the total number of rows (without actually extracting the data from the database) is great, but we need to tell JSF that number! Since <code class="literal">HtmlDataTable</code> doesn't provide a <code class="literal">setRowCount</code> method, we have to take another approach into account. One solution is to extend the <code class="literal">DataModel</code> class (or one of its subclasses) and provide the row count explicitly; since we are using <code class="literal">HashSet</code>, we can extend the <code class="literal">CollectionDataModel</code> class of JSF 2.2 as follows:</p><div class="informalexample"><pre class="programlisting">public class PlayersDataModel extends CollectionDataModel {
  
  private int rowIndex = -1;
  private int allRowsCount;
  private int pageSize;
  private HashSet hashSet;   

  public PlayersDataModel() {}

  public PlayersDataModel(HashSet hashSet, int allRowsCount, int pageSize)     
  {            
    this.hashSet = hashSet;
    this.allRowsCount = allRowsCount;
    this.pageSize = pageSize;        
  }   

  @Override
  public boolean isRowAvailable() {     
    if (hashSet == null) {
      return false;
    }

    int c_rowIndex = getRowIndex();
    if (c_rowIndex &gt;= 0 &amp;&amp; c_rowIndex &lt; hashSet.size()) {
      return true;
    } else {
      return false;
    }
  }

  @Override
  public int getRowCount() {       
    return allRowsCount;
  }

  @Override
  public Object getRowData() {       
    if (hashSet == null) {
      return null;
    } else if (!isRowAvailable()) {
      throw new IllegalArgumentException();
    } else {
      int dataIndex = getRowIndex();
      Object[] arrayView = hashSet.toArray();
      return arrayView[dataIndex];
    }
  }

  @Override
  public int getRowIndex() {      
    return (rowIndex % pageSize);
  }

  @Override
  public void setRowIndex(int rowIndex) {     
    this.rowIndex = rowIndex;
  }

  @Override
  public Object getWrappedData() {       
    return hashSet;
  }

  @Override
  public void setWrappedData(Object hashSet) {      
    this.hashSet = (HashSet) hashSet;
  }
}</pre></div><p>So, creating a <code class="literal">PlayersDataModel</code> class can<a id="id868" class="indexterm"/> be accomplished in the following manner:</p><div class="informalexample"><pre class="programlisting">...
@Inject
private PlayersSessionBean playersSessionBean;
private int rowsOnPage;
private int allRowsCount = 0;
...
@PostConstruct
public void initHashSet() {
  rowsOnPage = 4; //any constant in [1, rowCount]
  allRowsCount = playersSessionBean.countPlayersAction();
  lazyDataLoading(0);
}
...
private void lazyDataLoading(int first) {
  HashSet&lt;Players&gt; dataHashSet = playersSessionBean.loadPlayersAction(first, rowsOnPage);
  playersDataModel = new PlayersDataModel(dataHashSet, allRowsCount, rowsOnPage);
}</pre></div><p>Finally, each time a page navigation is detected in the table, we just need to call the following method:</p><div class="informalexample"><pre class="programlisting">lazyDataLoading(table.getFirst());</pre></div><p>The complete example is available in the code bundle of this chapter, and is named <code class="literal">ch6_10_2</code>.</p></div>
<div class="section" title="Generating tables with the JSF API"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec62"/>Generating tables with the JSF API</h1></div></div></div><p>JSF tables can be<a id="id869" class="indexterm"/> programmatically generated as well. The JSF API<a id="id870" class="indexterm"/> provides comprehensive support to accomplish such tasks. First, you <span class="emphasis"><em>prepare</em></span> the place where the generated table will be added, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:body&gt;
  &lt;h:form id="tableForm"&gt;     
    &lt;h:panelGrid id="myTable"&gt;                
    &lt;/h:panelGrid&gt;
    &lt;h:commandButton value="Add Table" action="#{playersBean.addTable()}"/&gt;
  &lt;/h:form&gt;        
&lt;/h:body&gt; </pre></div><p>The idea is simple: when the button labeled <span class="strong"><strong>Add Table</strong></span> is clicked, the generated table should be attached in the <code class="literal">&lt;h:panelGrid&gt;</code> tag identified by the <code class="literal">myTable</code> ID.</p><p>Before creating a JSF table in a programmatic fashion, you need to know how to create a table, a header/footer, a column, and so on. Let's have a short overview as follows—the code is self-explanatory and straightforward, since JSF provides very intuitive methods:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's create the simplest table, <code class="literal">&lt;h:dataTable value="..." var="t" border="1"&gt;</code> using the following code:<div class="informalexample"><pre class="programlisting">public HtmlDataTable createTable(String exp, Class&lt;?&gt; cls) {
  HtmlDataTable table = new HtmlDataTable();
  table.setValueExpression("value", createValueExpression(exp, cls));
  table.setVar("t");
  table.setBorder(1);

  return table;
}</pre></div></li><li class="listitem">Now, we will create a column with a header, a footer, and a possible converter, as follows:<div class="informalexample"><pre class="programlisting">public HtmlColumn createColumn(HtmlDataTable table, String header_name, String footer_name, String exp, Class&lt;?&gt; cls, Class&lt;?&gt; converter) {

  HtmlColumn column = new HtmlColumn();
  table.getChildren().add(column);

  if (header_name != null) {
    HtmlOutputText header = new HtmlOutputText();
    header.setValue(header_name);
    column.setHeader(header);
  }

  if (footer_name != null) {
    HtmlOutputText footer = new HtmlOutputText();
    footer.setValue(footer_name);
    column.setFooter(footer);
  }

  HtmlOutputText output = new HtmlOutputText();
  output.setValueExpression("value", createValueExpression(exp, cls));
  column.getChildren().add(output);

  if (converter != null) {
    if (converter.getGenericInterfaces()[0].equals(Converter.class)) {
      if (converter.equals(DateTimeConverter.class)) {
        DateTimeConverter dateTimeConverter = new DateTimeConverter();
        dateTimeConverter.setPattern("dd.MM.yyyy");
        output.setConverter(dateTimeConverter);
      }
      //more converters ...
    } else {
      //the passed class is not a converter!
    }
  }

  return column;
}</pre></div></li><li class="listitem">Now, attach the<a id="id871" class="indexterm"/> table in DOM (in order to do that, you<a id="id872" class="indexterm"/> need to find the desired parent component) using the following code:<div class="informalexample"><pre class="programlisting">public void attachTable(HtmlDataTable table, String parent_id) throws NullPointerException {
  UIComponent component = findComponent(parent_id);
  if (component != null) {
    component.getChildren().clear();
    component.getChildren().add(table);
  } else {
    throw new NullPointerException();
  }
}</pre></div><p>The <code class="literal">findComponent</code> method uses the JSF <code class="literal">visit</code> method, which is very useful for traversing a tree of components, which is shown in the following code:</p><div class="informalexample"><pre class="programlisting">private UIComponent findComponent(final String id) {
  FacesContext context = FacesContext.getCurrentInstance();
  UIViewRoot root = context.getViewRoot();
  final UIComponent[] found = new UIComponent[1];
  root.visitTree(new FullVisitContext(context), new VisitCallback() {
 
    @Override
    public VisitResult visit(VisitContext context, UIComponent component) {
      if (component.getId().equals(id)) {
        found[0] = component;
        return VisitResult.COMPLETE;
      }
      return VisitResult.ACCEPT;
    }
  });
  return found[0];
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note135"/>Note</h3><p>In Mojarra, the <code class="literal">FullVisitContext</code> method<a id="id873" class="indexterm"/> comes from the <code class="literal">com.sun.faces.component.visit</code> package. In MyFaces, this class comes from the <code class="literal">org.apache.myfaces.test.mock.visit</code> package. Both the implementations extend <code class="literal">javax.faces.component.visit.VisitContext</code>.</p></div></div></li><li class="listitem">The necessary <a id="id874" class="indexterm"/>expressions are then added as shown<a id="id875" class="indexterm"/> in the following code (you saw another example of this in <a class="link" href="ch02.html" title="Chapter 2. Communication in JSF">Chapter 2</a>, <span class="emphasis"><em>Communication in JSF</em></span>):<div class="informalexample"><pre class="programlisting">private ValueExpression createValueExpression(String exp, Class&lt;?&gt; cls) {
  FacesContext facesContext = FacesContext.getCurrentInstance();
  ELContext elContext = facesContext.getELContext();
  return facesContext.getApplication().getExpressionFactory().createValueExpression(elContext, exp, cls);
}</pre></div></li><li class="listitem">Finally, merge these methods in a helper class, <code class="literal">TableHelper</code>.<p>Remember the button labeled <span class="strong"><strong>Add Table</strong></span>? Well, when that button is clicked, the  <code class="literal">addTable</code> method<a id="id876" class="indexterm"/> is called. This method exploits the <code class="literal">TableHelper</code> class for programmatically creating a table, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public void addTable() {

  TableHelper tableHelper = new TableHelper();
  HtmlDataTable tableHashSet = tableHelper.createTable("#{playersBean.dataHashSet}", HashSet.class);
  tableHelper.createColumn(tableHashSet, "Ranking", null, "#{t.ranking}", Integer.class, null);
  tableHelper.createColumn(tableHashSet, "Name", null, "#{t.player}", String.class, null);
  tableHelper.createColumn(tableHashSet, "Age", null, "#{t.age}", Byte.class, null);
  tableHelper.createColumn(tableHashSet, "Birthplace", null, "#{t.birthplace}", String.class, null);
  tableHelper.createColumn(tableHashSet, "Residence", null, "#{t.residence}", String.class, null);
  tableHelper.createColumn(tableHashSet, "Height (cm)", null, "#{t.height}", Short.class, null);
  tableHelper.createColumn(tableHashSet, "Weight (kg)", null, "#{t.weight}", Byte.class, null);
  tableHelper.createColumn(tableHashSet, "Coach", null, "#{t.coach}", String.class, null);
  tableHelper.createColumn(tableHashSet, "Born", null, "#{t.born}", java.util.Date.class, DateTimeConverter.class);
  tableHelper.attachTable(tableHashSet, "myTable");
}</pre></div></li></ol></div><p>Done! The complete<a id="id877" class="indexterm"/> application is available in the code bundle<a id="id878" class="indexterm"/> of this chapter, and is named <code class="literal">ch6_11</code>.</p><p>A programmatically generated table would be an apt approach for generating tables with variable number of columns, or dynamic columns. Let's suppose that we have two JPA entities, <code class="literal">Players</code> and <code class="literal">Trophies</code>. The first entity should produce a table with nine columns, while <code class="literal">Trophies</code> should produce a table with three columns. Moreover, the column names (headers) differ. It may sound complicated, but actually is more simple than you would have expected.</p><p>Think that each table is mapped by a JPA entity, which means that we can write specific queries by indicating the entity name. Moreover, each entity can be passed through Java's reflection mechanism to extract the field's names (we are focusing on the <code class="literal">private</code> fields), which gave us the column headers. (If you alter the column names using <code class="literal">@Column(name="alias_name")</code>, then the process will be a little tricky to reflect the alias names.) So, we can use the following code (the package name is fixed):</p><div class="informalexample"><pre class="programlisting">@Inject
//this is the EJB component that queries the database  
private QueryBean queryBean;
HashSet&lt;Object&gt; dataHashSet = new HashSet&lt;&gt;();
...
public void addTable(String selectedTable) {

  try {
    dataHashSet.clear();
            
    dataHashSet = queryBean.populateData(selectedTable);
            
    String tableToQuery = "book.ejbs." + selectedTable;
            
    Class tableClass = Class.forName(tableToQuery);
    Field[] privateFields = tableClass.getDeclaredFields();

    TableHelper tableHelper = new TableHelper();
    HtmlDataTable tableHashSet = tableHelper.createTable("#{playersBean.dataHashSet}", HashSet.class);
            
    for (int i = 0; i &lt; privateFields.length; i++) {                
      String privateField = privateFields[i].getName();                
      if ((!privateField.startsWith("_")) &amp;&amp; (!privateField.equals("serialVersionUID"))) {
        tableHelper.createColumn(tableHashSet, privateField, null, "#{t."+privateField+"}", 
          privateFields[i].getType(), null);
      }
    }

    tableHelper.attachTable(tableHashSet, "myTable");

  } catch (ClassNotFoundException ex) {
    Logger.getLogger(PlayersBean.class.getName()).log(Level.SEVERE, null, ex);
}</pre></div><p>So, as long as we pass<a id="id879" class="indexterm"/> the table name (entity name) to this<a id="id880" class="indexterm"/> method, it will return the corresponding data. For the complete example, check the application named <code class="literal">ch6_12</code> in the code bundle of this chapter.</p></div>
<div class="section" title="Filtering tables"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec63"/>Filtering tables</h1></div></div></div><p>Filtering data is a very useful facility in a table. It allows the user to <span class="emphasis"><em>see</em></span> only the set of data that matches a certain set of rules (criteria); most commonly, filter by column(s). For example, the user may<a id="id881" class="indexterm"/> need to see all players younger than 26 years, which is a filter applied in the column labeled <span class="strong"><strong>Age</strong></span>.</p><p>Basically, a filter can have only visual effect, without modifying the filtered data (using some CSS, JS code, or duplicating the filter results in a separate collection and displaying that collection), or by removing the unnecessary items for the initial collection (which requires restoring its content when the filter is removed).</p><p>In JSF, we can write a nice filter by playing with some CSS code, which can be used to hide/show rows of a table; this is not a recommended approach in production, since all the data is still available in the source page, but it might be useful when you don't need anything fancy. The idea is to hide all of the table's rows that do not match the filter criteria, and for this, we can exploit the <code class="literal">rowClasses</code> attribute of the <code class="literal">&lt;h:dataTable&gt;</code> tag. This attribute's value is represented by a string of CSS classes separated by a comma; JSF iterates the CSS classes and applies them sequentially and repeatedly over rows.</p><p>Consider the following two CSS classes:</p><div class="informalexample"><pre class="programlisting">.rowshow
{
  display:visible;
}

.rowhide 
{
  display:none;
}</pre></div><p>Now, a filter can use the <code class="literal">rowshow</code> CSS class to display a row containing valid data, and the <code class="literal">rowhide</code> CSS class to hide the rest of the rows. For example, iterating over a collection of five elements can reveal the following string of CSS classes:</p><div class="informalexample"><pre class="programlisting">rowshow, rowhide, rowshow, rowhide, rowhide</pre></div><p>So, only the first and the third row will be visible.</p><p>Let's have a look at the steps involved in the writing of such a filter:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">A convenient way to add a filter selection per column consists of using the <code class="literal">&lt;h:selectOneMenu&gt;</code> tag. For example, we add a filter selection in the <span class="strong"><strong>Age</strong></span> column, as follows:<div class="informalexample"><pre class="programlisting">...
&lt;h:column&gt;
  &lt;f:facet name="header"&gt;
    Age&lt;br/&gt;
    &lt;h:selectOneMenu value="#{playersBean.criteria}"&gt;
      &lt;f:selectItem itemValue="all" itemLabel="all" /&gt;
      &lt;f:selectItem itemValue="&amp;lt;26" itemLabel="&amp;lt;26" /&gt;
      &lt;f:selectItem itemValue="&amp;gt;=26" itemLabel="&amp;gt;=26" /&gt;                            
    &lt;/h:selectOneMenu&gt;
    &lt;h:commandButton value="Go!" action="#{playersBean.addTableFilter()}"/&gt;
  &lt;/f:facet&gt;                                      
  &lt;h:outputText value="#{t.age}"/&gt;
&lt;/h:column&gt;
...</pre></div></li><li class="listitem">The <code class="literal">addTableFilter</code> method<a id="id882" class="indexterm"/> is called when the button labeled <span class="strong"><strong>Go!</strong></span> is clicked. It checks the value of the <code class="literal">criteria</code> property, and if the value equals <code class="literal">&lt;26</code> or <code class="literal">&gt;=26</code>, then it<a id="id883" class="indexterm"/> iterates over the table rows and builds the corresponding string of CSS classes. Otherwise, if the <code class="literal">criteria</code> property is equal to <code class="literal">all</code>, the filter is removed, as shown in the following code:<div class="informalexample"><pre class="programlisting">public void addTableFilter() {

  if (!criteria.equals("all")) {
    String c = "";
    for (int i = 0; i &lt; table.getRowCount(); i++) {
      table.setRowIndex(i);
      Players player = (Players) table.getRowData();
      if (criteria.equals("&lt;26")) {
        if (player.getAge() &gt;= 26) {
          c = c + "rowhide,";
        } else {
          c = c + "rowshow,";
        }
      }
      if (criteria.equals("&gt;=26")) {
        if (player.getAge() &lt; 26) {
          c = c + "rowhide,";
        } else {
          c = c + "rowshow,";
        }
      }
    }

    String css = "rowshow";
    if (!c.isEmpty()) {
      css = c.substring(0, c.length() - 1);
    }

    rowsOnPage = table.getRowCount();
    table.setRowClasses(css);
    table.setFirst(0);
  } else {
    removeTableFilter();
  }
}</pre></div></li><li class="listitem">The following <code class="literal">removeTableFilter</code> method<a id="id884" class="indexterm"/> will restore the CSS class; therefore, all data will be visible again:<div class="informalexample"><pre class="programlisting">public void removeTableFilter() {
  String css = "rowshow";
  rowsOnPage = 4;  //any constant in [1, rowCount]
  table.setRowClasses(css);
  table.setFirst(0);
}</pre></div></li></ol></div><p>For the complete example, check the application named <code class="literal">ch6_13_1</code> in the code bundle of this chapter.</p><p>It's important to notice that the number of rows per page is modified when the filter is applied. Actually, when the filter results are displayed, the rows per page become equal to table row count, and<a id="id885" class="indexterm"/> when the filter is removed, they take a value anything from 1 to row count. The conclusion is that the filtered data is displayed in a table without pagination.</p><p>In some cases, like filtering by age, you can apply a sort before generating the string of CSS classes. This will help you to display the filter results, without affecting data, and with pagination available. A complete example can be found in the code bundle of this chapter, named <code class="literal">ch6_13_2</code>.</p><p>You can obtain the same results by removing from the initial collection the items that do not match the filter criteria. For example, notice that before applying a filter, you need to restore the initial data of the collection—the <code class="literal">initHashSet</code> method<a id="id886" class="indexterm"/> can do that:</p><div class="informalexample"><pre class="programlisting">public void addTableFilter() {

  initHashSet();

  Iterator&lt;Players&gt; i = dataHashSet.iterator();
  while (i.hasNext()) {
    Players player = i.next();
    if (criteria.equals("&lt;26")) {
      if (player.getAge() &gt;= 26) {
        i.remove();
      }
    }
    if (criteria.equals("&gt;=26")) {
      if (player.getAge() &lt; 26) {
        i.remove();
      }
    }
  }

  table.setFirst(0);
}</pre></div><p>If you want to apply a<a id="id887" class="indexterm"/> chain of filters, then restore the data before entering in the chain. A complete example can be found in the code bundle of this chapter named <code class="literal">ch6_13_3</code>.</p><p>Since collections that feed tables are usually populated from databases, you can apply filters directly on databases. A <a id="id888" class="indexterm"/>common case is represented by tables with a lazy loading mechanism; since you have only a slice of data in memory, you need to apply the filter on the database instead of filtering the collection that populates the table. This means that the filtration process is accomplished through SQL queries. For example, our filter can be modeled through SQL queries, by performing the following steps (this example is based on the lazy loading application presented earlier in this chapter):</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">You pass the filter criteria to the EJB component (<code class="literal">copy_criteria</code> acts as a flag—you don't want to count the number of rows each time the user navigates through table pages using the same filter), as shown in the following code:<div class="informalexample"><pre class="programlisting">@Inject
private PlayersSessionBean playersSessionBean; 
private PlayersDataModel playersDataModel;         
private String criteria = "all";
private String copy_criteria = "none";
private int allRowsCount = 0;
...
private void lazyDataLoading(int first) {
  if (!copy_criteria.equals(criteria)) {           
    allRowsCount = playersSessionBean.countPlayersAction(criteria);
    copy_criteria = criteria;
  }

  HashSet&lt;Players&gt; dataHashSet = playersSessionBean.loadPlayersAction(first, rowsOnPage, criteria);
  playersDataModel = new PlayersDataModel(dataHashSet, allRowsCount, rowsOnPage);
}</pre></div></li><li class="listitem">Count the number of rows returned by the filter as follows:<div class="informalexample"><pre class="programlisting">public int countPlayersAction(String criteria) {

  if (criteria.equals("all")) {
    Query query = em.createNamedQuery("Players.countAll");
    return ((Long) query.getSingleResult()).intValue();
  }

  if (criteria.equals("&lt;26")) {
    Query query = em.createQuery("SELECT COUNT(p) FROM Players p WHERE p.age &lt; 26");
    return ((Long) query.getSingleResult()).intValue();
  }

  if (criteria.equals("&gt;=26")) {
    Query query = em.createQuery("SELECT COUNT(p) FROM Players p WHERE p.age &gt;= 26");
    return ((Long) query.getSingleResult()).intValue();
  }

  return 0;
}</pre></div></li><li class="listitem">Finally, round off by<a id="id889" class="indexterm"/> applying the filter criteria using SQL queries as follows:<div class="informalexample"><pre class="programlisting">public HashSet&lt;Players&gt; loadPlayersAction(int first, int max, String criteria) {

  if (criteria.equals("all")) {
    Query query = em.createNamedQuery("Players.findAll");
    query.setFirstResult(first);
    query.setMaxResults(max);
    return new HashSet(query.getResultList());
  }

  if (criteria.equals("&lt;26")) {
    Query query = em.createQuery("SELECT p FROM Players p WHERE p.age &lt; 26");
    query.setFirstResult(first);
    query.setMaxResults(max);
    return new HashSet(query.getResultList());
  }

  if (criteria.equals("&gt;=26")) {
    Query query = em.createQuery("SELECT p FROM Players p WHERE p.age &gt;= 26");
    query.setFirstResult(first);
    query.setMaxResults(max);
    return new HashSet(query.getResultList());
  }

  return null;
}</pre></div></li></ol></div><p>Done! The complete example<a id="id890" class="indexterm"/> is available in the code bundle of this chapter and it is named <code class="literal">ch6_13_4</code>.</p></div>
<div class="section" title="Styling tables"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec64"/>Styling tables</h1></div></div></div><p>Almost all JSF UI components <a id="id891" class="indexterm"/>support the <code class="literal">style</code> and <code class="literal">styleClass</code> attributes for creating custom designs using CSS. But the <code class="literal">&lt;h:dataTable&gt;</code> tag supports attributes, such as <code class="literal">captionClass</code>, <code class="literal">captionStyle</code>, <code class="literal">columnClasses</code>, <code class="literal">rowClasses</code>, <code class="literal">headerClass</code>, and <code class="literal">footerClass</code>. Therefore, we should have no problem in adding a CSS style to every single part of a table (header, footer, caption, and so on). Obviously, there are plenty of examples that can be built, but let's see three of the most impressive and used ones.</p><div class="section" title="Alternate row colors with the rowclasses attribute"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec71"/>Alternate row colors with the rowclasses attribute</h2></div></div></div><p>The <code class="literal">rowClasses</code> attribute is used to indicate a string of CSS classes separated by a comma. The string is<a id="id892" class="indexterm"/> parsed by JSF, and the styles are applied sequentially and <a id="id893" class="indexterm"/>repeatedly to rows. For example, you can color the even rows with one color, and the odd rows with some other color, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:dataTable value="#{playersBean.data}" rowClasses="even, odd" var="t"&gt;
...</pre></div><p>Here, <code class="literal">even</code> and <code class="literal">odd</code> are the following CSS classes:</p><div class="informalexample"><pre class="programlisting">.odd {
  background-color: gray;
}

.even{
  background-color: darkgray;
}</pre></div><p>A possible output can be seen in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_06_14.jpg" alt="Alternate row colors with the rowclasses attribute"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note136"/>Note</h3><p>You can obtain the same effect for columns, by using the <code class="literal">columnClasses</code> attribute instead of the <code class="literal">rowClasses</code> attribute.</p></div></div><p>The complete<a id="id894" class="indexterm"/> example<a id="id895" class="indexterm"/> is named <code class="literal">ch6_14_1</code>.</p></div><div class="section" title="Highlighting rows on mouse hover"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec72"/>Highlighting rows on mouse hover</h2></div></div></div><p>Highlighting rows on<a id="id896" class="indexterm"/> mouse hover is a nice effect that can be accomplished with a<a id="id897" class="indexterm"/> piece of JavaScript. The idea<a id="id898" class="indexterm"/> is to set the <code class="literal">onmouseover</code> and <code class="literal">onmouseout</code> attributes, as shown in the following self-explanatory code:</p><div class="informalexample"><pre class="programlisting">...
&lt;script type="text/javascript"&gt;
  //&lt;![CDATA[           
    function onmouseOverOutRows() {
      var rows = document.getElementById('playersTable').getElementsByTagName('tr');
      for (var i = 1; i &lt; rows.length; i++) {
        rows[i].setAttribute("onmouseover", "this.bgColor='#00cc00'");
        rows[i].setAttribute("onmouseout", "this.bgColor='#ffffff'");
      }
    }
  //]]&gt;
&lt;/script&gt;
...

&lt;h:body onload="onmouseOverOutRows();"&gt;
  &lt;h:dataTable id="playersTable" value="#{playersBean.data}" var="t"&gt;
...</pre></div><p>The complete example is named <code class="literal">ch6_14_2</code>.</p><p>Another approach does not involve using the JavaScript code. In this case, you can try CSS pseudo-classes, as follows:</p><div class="informalexample"><pre class="programlisting">tbody tr:hover {
  background-color: red;
}</pre></div><p>Done! The <a id="id899" class="indexterm"/>complete application<a id="id900" class="indexterm"/> is named <code class="literal">ch6_14_3</code>.</p></div><div class="section" title="Highlighting rows on mouse click"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec73"/>Highlighting rows on mouse click</h2></div></div></div><p>Highlighting rows with a<a id="id901" class="indexterm"/> mouse click can be done with another piece of JavaScript<a id="id902" class="indexterm"/> code. You have to add the <code class="literal">onclick</code> attribute to each row and control the color alternation when the<a id="id903" class="indexterm"/> user clicks repeatedly on the same row, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
  //&lt;![CDATA[           
    function onClickRows() {
      var rows = document.getElementById('playersTable').getElementsByTagName('tr');
      for (var i = 1; i &lt; rows.length; i++) {
        rows[i].setAttribute("onclick", "changeColor(this);");
      }
    }

    function changeColor(row) {
      var bgcolor = row.bgColor;
      if (bgcolor === "") {
        row.bgColor = "#00cc00";
      } else if (bgcolor === "#00cc00") {
        row.bgColor = "#ffffff";
      } else if (bgcolor === "#ffffff") {
        row.bgColor = "#00cc00";
      }
    }
   //]]&gt;
&lt;/script&gt;
...
&lt;h:body onload="onClickRows();"&gt;
  &lt;h:dataTable id="playersTable" value="#{playersBean.data}" var="t"&gt;
...</pre></div><p>The complete <a id="id904" class="indexterm"/>example<a id="id905" class="indexterm"/> is named <code class="literal">ch6_14_4</code> in the <a id="id906" class="indexterm"/>code bundle of this chapter.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec65"/>Summary</h1></div></div></div><p>Tabular data is very commonly used in web applications, and this chapter is a tribute to the powerful JSF DataTable component (<code class="literal">&lt;h:dataTable&gt;</code>). JSF 2.2 brought even more power by allowing developers to render more collections than before, by adding the new <code class="literal">CollectionDataModel</code> class. This chapter covers the most common tasks that a table should accomplish, such as sorting, filtering, lazy loading, and CSS support. Notice that a cool and comprehensive extension of the <code class="literal">&lt;h:dataTable&gt;</code> tag is provided by PrimeFaces (<a class="ulink" href="http://primefaces.org/">http://primefaces.org/</a>) under the tag named <code class="literal">&lt;p:dataTable&gt;</code> (<a class="ulink" href="http://www.primefaces.org/showcase/ui/datatableHome.jsf">http://www.primefaces.org/showcase/ui/datatableHome.jsf</a>).</p><p>In the next chapter, we will be covering the AJAX technique for JSF applications.</p></div></body></html>