<html><head></head><body>
		<div id="_idContainer036">
			<h1 id="_idParaDest-65"><a id="_idTextAnchor065"/>Chapter 3: Common Architecture Design Techniques</h1>
			<p>In the previous chapter, <a href="B16354_02_Final_JM_ePUB.xhtml#_idTextAnchor034"><em class="italic">Chapter 2</em></a>, <em class="italic">Software Requirements – Collecting, Documenting, Managing</em>, we highlighted techniques to retrieve and analyze the features an application should have. This is done by interacting with the business and other stakeholders and describing what the desired behavior should be. We now have all the ingredients needed to start baking our application. The first—very important—step is to define the architecture. </p>
			<p>It is debated as to how much, in terms of resources, you should invest in this phase. Some experts argue that architecture design is the most important phase, while others claim that it's crucial to keep a flexible approach, being able to adapt the architecture while the solution is evolving according to new ideas coming in or shifting external conditions.</p>
			<p>For sure, both ideas are interesting and have some strong points. Whatever your point of view on that is, it is really useful to have a clear understanding of what the most common ways of documenting the architectures you will design are.</p>
			<p>This is a topic we started to touch on in <a href="B16354_01_Final_JM_ePUB.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Designing Software Architectures in Java – Methods and Styles</em>. But while in the first chapter the idea was to start sketching some ideas and brainstorm potential solutions, in this chapter, we will cover a detailed design. This means exploring different modeling techniques, walking through notation and diagram types, and creating artifacts that are shareable and clear to understand for other team members. In this chapter, you will learn about the following topics:</p>
			<ul>
				<li>Introducing marchitectures—impactful and purely demonstrative schemas</li>
				<li>Familiarizing ourselves with <strong class="bold">Unified Modeling Language</strong> (<strong class="bold">UML</strong>) notation</li>
				<li>Exploring <strong class="bold">ArchiMate</strong></li>
				<li>Introducing the <strong class="bold">C4 model</strong></li>
				<li>Other modeling techniques – <strong class="bold">Business Process Model and Notation</strong> (<strong class="bold">BPMN</strong>), <strong class="bold">Decision Model and Notation</strong> (<strong class="bold">DMN</strong>), and <strong class="bold">arc42</strong></li>
				<li>Case studies and examples</li>
			</ul>
			<p>But first of all, let's start by having a look at a less structured but widely used architectural style, with a funny and a bit of an ugly name: <strong class="bold">marchitectures</strong>.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor066"/>Introducing marchitectures – impactful and purely demonstrative schemas</h1>
			<p>With its name being a <a id="_idIndexMarker251"/>portmanteau of marketing and architecture, as you can imagine, <strong class="bold">marchitectures</strong> are a very common tool to pitch your solution and get sponsorship (and often the budget) for your project. You don't need to get into technical details, nor to cover every aspect of the solution; the idea here is to give an idea of what the finished product will look like.</p>
			<p>From a content point of view, marchitectures are no more and no less than a polished version of the first whiteboard sketches of a software architecture. This includes the same vague meaning, incomplete vision, and mixed point of view that we discussed in <a href="B16354_01_Final_JM_ePUB.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Designing Software Architectures in Java – Methods and Styles</em>. </p>
			<p>Marchitectures often complement mockups<a id="_idIndexMarker252"/> of the <strong class="bold">User Interface</strong> (<strong class="bold">UI</strong>), marketing research, and industry trends. You want to convince the stakeholders (budget owners, investors, and so on) that your idea is a good one and that the underlying architecture (and implementation) will be rock-solid, yet flexible enough to follow the evolutions that the business will drive.</p>
			<p>It is definitely an ambitious goal and is sometimes—inevitably—not fully met. Indeed, the real architecture will often only partially look like what you defined in your marchitecture.</p>
			<p>Marchitectures are often used by software vendors and for good reason. If you are pitching a product (or a framework, or a service), you don't want to be too specific on what the finished solution will look like. You just need to give a high-level idea of how your product works. Maybe authentication will be different, and maybe you will need to integrate third-party systems into the final picture, but the important thing is to have a shiny picture of how good your architecture (marchitecture) looks. There is time to get into the nitty-gritty details later. UML notation, which we will look at in the next section, is a very good way to document those details. </p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor067"/>Familiarizing ourselves with UML notation</h1>
			<p>There are things <a id="_idIndexMarker253"/>in this book that we need to treat with reverential respect; <strong class="bold">UML</strong> is one of them. This modeling language is simply a piece of IT history. You should take into account that UML is a very comprehensive and articulate standard, aimed at modeling and representing a wide number of concepts. For this reason, going through the whole specification is out of the scope of this book.</p>
			<p>But by the end of this section, you will have a grasp of the UML philosophy, and we will have covered practical examples of the most widespread UML diagrams.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">It's worthwhile deepening your knowledge of the UML language. To do this, you will find plenty of resources on the web. I would also suggest you have a look at the official UML website, and at <em class="italic">The Unified Modeling Language User Guide</em> by Booch, Rumbaugh, and Jacobson (more information is available in the <em class="italic">Further reading</em> section of this chapter), which is probably the most important UML book, written by the original authors of the language. </p>
			<p>Now, let's look at the fascinating UML genesis in the next section, where we will see how UML started as a joint effort by different working groups that were all working to solve a common problem: defining a language to break the barrier between designing and implementing a software solution.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor068"/>Understanding the background to UML</h2>
			<p>UML's history began in the 1990s and is strictly<a id="_idIndexMarker254"/> related to <strong class="bold">object-oriented programming</strong>.</p>
			<p>UML was<a id="_idIndexMarker255"/> born from an effort to standardize object modeling and the conceptual representation of object-oriented software. A further objective was to create an object that is both human- and machine-readable, supporting the life cycle starting from analysis, and moving toward implementation and testing.</p>
			<p>The history of the UML standard starts with a cross-company, meritocratic effort to find a solution to common problems. This looks a lot like the open source development model. Everybody is free to contribute and share ideas with the community, regardless of their role or the company they are working for.</p>
			<p>Let's look at an<a id="_idIndexMarker256"/> overview of what's contained in the UML framework.</p>
			<p>Walking through the UML basics, as we discussed, UML was created to model object-oriented systems, and in theory, diagrams created with UML can be automatically translated into source code.</p>
			<p>There are a number of interesting <a id="_idIndexMarker257"/>principles in the UML language, making it just as useful and relevant today, more than 20 years after its inception, as when it was created. Let's have a look at some of them here:</p>
			<ul>
				<li>UML is independent of the development methodology, meaning that it can be used even in modern Agile<a id="_idIndexMarker258"/> and <strong class="bold">DevOps</strong> teams. Some of the diagrams introduced by UML are commonly used in those contexts too. The goal of the language is to visualize, specify, construct, and document OO systems.</li>
				<li>UML is usually associated with diagrams and graphical artifacts. While they are, indeed, a core concept of the language, UML also defines the related semantics. This means that the reasoning for everything is well defined and formalized so that both a trained person and a machine can understand what a UML diagram represents in all its details.</li>
				<li>UML concepts are built upon three different kinds of building blocks—namely, <strong class="bold">things</strong>, <strong class="bold">relationships</strong>, and <strong class="bold">diagrams</strong>. These <a id="_idIndexMarker259"/>are further organized into subcategories. For each of<a id="_idIndexMarker260"/> those concepts, a graphical representation (symbol) is provided.</li>
			</ul>
			<p>These building blocks<a id="_idIndexMarker261"/> are covered in detail in the following subsections.</p>
			<h3>Things</h3>
			<p><strong class="bold">Things</strong> are<a id="_idIndexMarker262"/> core entities that have the goal of abstracting <a id="_idIndexMarker263"/>concepts represented by the system. Things are further grouped into other subtypes, as outlined here:</p>
			<ul>
				<li><strong class="bold">Structural things</strong>: These<a id="_idIndexMarker264"/> are the most essential elements in object-oriented programming (such as classes and interfaces) </li>
				<li><strong class="bold">Behavioral things</strong>: These <a id="_idIndexMarker265"/>represent interactions (such as messages and actions) </li>
				<li><strong class="bold">Grouping things</strong>: These <a id="_idIndexMarker266"/>are used to organize other things (packages are an example)</li>
				<li><strong class="bold">Annotational things</strong>: These<a id="_idIndexMarker267"/> support elements to document the models (such as notes)</li>
			</ul>
			<h3>Relationships</h3>
			<p><strong class="bold">Relationships</strong> model <a id="_idIndexMarker268"/>the links between things. These are <a id="_idIndexMarker269"/>further organized into four main categories, as follows: </p>
			<ul>
				<li><strong class="bold">Dependencies</strong>: Defining <a id="_idIndexMarker270"/>a relationship in which the changes made to a thing will influence a dependent thing. Also referred to as<a id="_idIndexMarker271"/> a <strong class="bold">client-supplier link</strong>, where a change to the supplier requires a change to the client. As an example, think about a <strong class="source-inline">BusinessLogic</strong> component, providing validations, checks, and so on, and a <strong class="source-inline">PaymentService</strong> component, called from the <strong class="source-inline">BusinessLogic</strong> component in order to provide payment functionalities. A change in the methods of the <strong class="source-inline">PaymentService</strong> component will require a change in the BackendAPI that uses it.</li>
				<li><strong class="bold">Associations</strong>: An <a id="_idIndexMarker272"/>association, such as a link between classes, is usually modeled as one object holding a reference to one or more instances of the other objects. An example of this is a <strong class="source-inline">PaymentTransaction</strong> component with a user. Each payment must reference at least one user of the platform (that is, the one making the payment).</li>
				<li><strong class="bold">Generalizations</strong>: This<a id="_idIndexMarker273"/> represents the parent-child relationship. That's pretty straightforward: a <strong class="source-inline">MobilePayment</strong> interface is a specific type of <strong class="source-inline">PaymentTransaction</strong> component, inheriting from it.</li>
				<li><strong class="bold">Realization</strong>: This<a id="_idIndexMarker274"/> helps in modeling the interface-implementation link, representing a contract in terms of methods and signatures, and the realization of it. You can take as an example an <strong class="source-inline">IPaymentService</strong> interface, and its practical implementation—such as <strong class="source-inline">MobilePayment</strong>—implementing one particular way of making a payment (and abstracting the caller from the implementation details).</li>
			</ul>
			<h3>Diagrams</h3>
			<p><strong class="bold">Diagrams</strong> are <a id="_idIndexMarker275"/>schemas representing meaningful sets of things. They <a id="_idIndexMarker276"/>are technically graphs, which helps them to be easily read and written by machines. Diagrams can be classified as follows:</p>
			<ul>
				<li><strong class="bold">Structural</strong>: Describing<a id="_idIndexMarker277"/> the static aspects of a system, such as the structure, grouping, and hierarchy of objects </li>
				<li><strong class="bold">Behavioral</strong>: Describing <a id="_idIndexMarker278"/>the interactions between objects</li>
			</ul>
			<p>Diagrams are the most widely known concept of UML. It is very likely that you have already seen a class diagram or a sequence one. In my opinion, diagrams are one of the most useful UML concepts. For this reason, we will walk through the main types of diagrams in the following upcoming sections.</p>
			<p>In the following diagram, you <a id="_idIndexMarker279"/>can see a graphical representation of the UML things we've just seen:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/Figure_3.01_B16354.jpg" alt="Figure 3.1 – Graphical representation of some UML things&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Graphical representation of some UML things</p>
			<p>In the next <a id="_idIndexMarker280"/>diagram, we represent the graphical symbols of the UML relationships we've described:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/Figure_3.02_B16354.jpg" alt="Figure 3.2 – Graphical representation of some UML relationships&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Graphical representation of some UML relationships</p>
			<p>With regard to UML diagrams, due to their relevance, we will walk through some of the most common ones in the next sections.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor069"/>Class diagrams</h2>
			<p>Since the <a id="_idIndexMarker281"/>beginning of this section, we've made it clear that UML is all about <strong class="bold">object-oriented</strong> modeling, which is expected since <strong class="bold">Java</strong> (probably the most widespread object-oriented language) is one of the pillars of this book, and—of course—modeling classes are one of the most important aspects of object-oriented modeling. I'm pretty sure you've already seen (or used) class diagrams. They're a very common and natural way to represent classes and how they are made, and indeed are used in countless documentation on the internet.</p>
			<p>A class diagram<a id="_idIndexMarker282"/> is made up of a set of classes (including their fields and methods) and the relationships between them. Interfaces are represented where present, and so is inheritance between classes. As per the other diagrams, a class diagram is conceptually a graph, made up of arcs and vertices.</p>
			<p>A class diagram is intended to highlight a specific subset of the whole architecture, so the class represented is part of a given use case or belongs to a specific subdomain.</p>
			<p>It's worth noticing that the relationships will represent both the kind of cooperation/responsibility between the classes and the multiplicity of the relationship itself (for example, one-to-many, one-to-one, and similar cardinalities). This is what a basic class diagram looks like:</p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/Figure_3.03_B16354.jpg" alt="Figure 3.3 – Basic class diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Basic class diagram</p>
			<p>As you can see, a class diagram is a great way to model the structure of a logical subdomain<a id="_idIndexMarker283"/> of the application (objects and their links). In the next section, we <a id="_idIndexMarker284"/>will look at sequence diagrams, which are another very widespread representation, focusing more on the end-to-end interactions needed to implement the functionality.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor070"/>Sequence diagram</h2>
			<p>A <strong class="bold">sequence diagram</strong> is <a id="_idIndexMarker285"/>probably one of the most famous UML diagrams. This <a id="_idIndexMarker286"/>diagram is a particular instance of so-called interaction diagrams, which are a representation of a set of objects (such as software components and actors) and how they interact (for example, exchanging messages). In the case of sequence diagrams, the interaction is pictured in a linear way, representing interactions ordered by the temporal dimension.</p>
			<p>From a graphical viewpoint, a sequence diagram pictures objects in a row, each one with a line going down vertically (also known as a <strong class="bold">lifeline</strong>). Crossing those lifelines, interactions are<a id="_idIndexMarker287"/> laid out as horizontal lines, intersecting the involved objects.</p>
			<p>A sequence diagram also offers a way to represent conditions and iterations. <strong class="bold">Conditions</strong>, <strong class="bold">parallelization</strong>, <strong class="bold">loops</strong>, and <strong class="bold">optional</strong> are represented by drawing a box around the<a id="_idIndexMarker288"/> interactions<a id="_idIndexMarker289"/> and<a id="_idIndexMarker290"/> tagging the box with the right keyword.</p>
			<p>Given <a id="_idIndexMarker291"/>the nice level of detail that can be expressed by the message flow (including the time ordering) and the expressiveness provided by the structured controls (conditions and such), sequence diagrams are a very nice way to analyze and document functionalities, by breaking them up into smaller operations.</p>
			<p>This is what a sequence diagram looks like:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/Figure_3.04_B16354.jpg" alt="Figure 3.4 – Sequence diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Sequence diagram</p>
			<p>As you can see in the first row of the diagram, we have in this case a user and two components, whereby<a id="_idIndexMarker292"/> the following applies:</p>
			<ul>
				<li>Each one of them has a lifeline, which is highlighted to represent activation when an interaction is made (for example, a method is called, or a message is sent). </li>
				<li>A self-message is pictured as a curved line, representing the call of a method on the same component.</li>
				<li>A loop is represented as a frame with a tag. In the tag, other than loops, <strong class="source-inline">opt </strong>(<strong class="bold">optional</strong>), <strong class="source-inline">par</strong> (<strong class="bold">parallel</strong>), and <strong class="source-inline">alt</strong> (<strong class="bold">conditional</strong>) are admitted values. <strong class="source-inline">opt</strong> identifies an optional interaction that will happen only if a specified condition is met (such as an <strong class="source-inline">if</strong> block), <strong class="source-inline">par</strong> represents a parallel interaction (such as two methods called in parallel in a multithread fashion), and <strong class="source-inline">alt</strong> matches alternative conditions, such as an <strong class="source-inline">if</strong>/<strong class="source-inline">else</strong> block.</li>
				<li>The same kind of notation (box with a tag) can be used to represent sub diagrams. In this case, the tag has a <strong class="source-inline">ref</strong> value, while the name of the diagram representing that part is reported in the box. This provides a simple way of breaking down big and complex sequence diagrams into smaller ones.</li>
			</ul>
			<p>With this<a id="_idIndexMarker293"/> look at sequence diagrams, we have completed our very brief overview of the most common UML ideas.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor071"/>Wrapping up on UML</h2>
			<p>As we<a id="_idIndexMarker294"/> said at the very beginning of this section, UML is a big and complete framework that is too complex to summarize in just a few pages. However, the essential concepts we have seen so far (including class diagrams and sequence diagrams) are a good way to start getting used to this language and add some useful tools to your toolbox. Of course, my advice is to go deeper and get to know more diagrams and techniques from this awesome language. </p>
			<p>In the next section, we are going to explore a technique that shares many similarities with UML: ArchiMate.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor072"/>Exploring ArchiMate</h1>
			<p><strong class="bold">ArchiMate</strong> is an <a id="_idIndexMarker295"/>architectural modeling technique aimed at analyzing and documenting enterprise architectures. This means that, while still having roots in technology and software, it's usually adopted in projects with a broader scope, such as documenting the whole enterprise technology landscape (also known as <strong class="bold">enterprise architecture</strong>) and modeling the business processes implemented by the underlying technology implementation.</p>
			<p>ArchiMate's name is a merging of <em class="italic">architecture</em> and <em class="italic">animate</em>, implying that one goal of this framework is to display the enterprise architecture in an intuitive way. ArchiMate was created in the early 2000s in the Netherlands, the result of a concerted effort from players in the government, industry, and academic sectors. Soon after the first drafts of this standard, the governance was transferred<a id="_idIndexMarker296"/> to <strong class="bold">The Open Group</strong>, an industry <a id="_idIndexMarker297"/>consortium regulating many other IT standards, such as <strong class="bold">The Open Group Architectural Framework</strong> (<strong class="bold">TOGAF</strong>, which is an enterprise architecture standard) and <a id="_idIndexMarker298"/>the <strong class="bold">Single Unix Specification</strong> (<strong class="bold">SUS</strong>, which <a id="_idIndexMarker299"/>is a <strong class="bold">Portable Operating System Interface</strong> (<strong class="bold">POSIX</strong>)-standard superset). The Open Group is also<a id="_idIndexMarker300"/> behind other famous standards in the<a id="_idIndexMarker301"/> Java world, such as <strong class="bold">Service Oriented Architecture</strong> (<strong class="bold">SOA</strong>) and <strong class="bold">eXtended Architecture</strong> (<strong class="bold">XA</strong>).</p>
			<p>Let's start with the ArchiMate Core Framework.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor073"/>The ArchiMate Core and Full Frameworks</h2>
			<p>The first <a id="_idIndexMarker302"/>concept to approach in ArchiMate is the <strong class="bold">Core Framework</strong>. The ArchiMate Core Framework is a 3x3 matrix, created by crossing three layers (<strong class="bold">Business</strong>, <strong class="bold">Application</strong>, and <strong class="bold">Technology</strong>) stacked with three aspects (represented vertically: <strong class="bold">Passive Structure</strong>, <strong class="bold">Behavior</strong>, and <strong class="bold">Active Structure</strong>).</p>
			<p>This is what the Core Framework matrix looks like:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/Figure_3.05_B16354.jpg" alt="Figure 3.5 – ArchiMate Core Framework&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – ArchiMate Core Framework</p>
			<p>The layers <a id="_idIndexMarker303"/>are a way to look at the same concept (or closely related concepts) from three different perspectives. In a way, a concept in one <a id="_idIndexMarker304"/>layer makes use of or is linked to concepts in nearby layers. You can see the three layers as a specification from the more abstract (business) to the more concrete (technology), as outlined here:</p>
			<ul>
				<li>The <strong class="bold">Business</strong> layer revolves around business capabilities, usually offered to the external world (for example, final customers). This includes business processes, events, and functions related to high-level capabilities.</li>
				<li>The <strong class="bold">Application</strong> layer includes<a id="_idIndexMarker305"/> the software components offering capabilities to the <strong class="bold">Business</strong> layer.</li>
				<li>The <strong class="bold">Technology</strong> layer is <a id="_idIndexMarker306"/>the technical infrastructure supporting the software components, including hardware and communication.</li>
			</ul>
			<p>The aspects<a id="_idIndexMarker307"/> are a way to classify objects by their role in an activity, as outlined here:</p>
			<ul>
				<li><strong class="bold">Active Structure</strong> includes <a id="_idIndexMarker308"/>the elements starting an action (including actors, devices, and software components).</li>
				<li><strong class="bold">Behavior</strong> includes<a id="_idIndexMarker309"/> the action itself being made by something in the <strong class="bold">Active Structure</strong> aspect (such as an actor).</li>
				<li><strong class="bold">Passive Structure</strong> includes <a id="_idIndexMarker310"/>the objects on which the activity is made (for instance, the recipient of the action itself, such as a data object).</li>
			</ul>
			<p>You should take into account the fact that some objects can be part of more than one aspect.</p>
			<p>As you will see, the Core Framework provides a simple way to place and categorize objects, and it enables multiple viewpoints. Also, take into account that ArchiMate diagrams do not necessarily follow this matrix layout: this is merely a conceptual way to demonstrate layers and aspects and how they are related.</p>
			<p>The ArchiMate standard also provides an extended version of the framework. In this framework, three more layers are added, as outlined here:</p>
			<ul>
				<li><strong class="bold">Strategy</strong>, on <a id="_idIndexMarker311"/>top of the <strong class="bold">Business</strong> layer, aims to link business functionalities and use cases to the pursuit of strategic objectives. </li>
				<li><strong class="bold">Physical</strong>, technically<a id="_idIndexMarker312"/> a subset of the <strong class="bold">Technology</strong> layer, is used to represent materials, physical objects, facilities, and so on.</li>
				<li><strong class="bold">Implementation and Migration</strong> is <a id="_idIndexMarker313"/>used to model all the temporary components supporting transitory phases during implementation and migration.</li>
			</ul>
			<p>A fourth aspect, called <strong class="bold">Motivation</strong>, is also<a id="_idIndexMarker314"/> included in the extended framework. The goal of this aspect is to map and represent the strategic reasons behind the other architectural choices. In particular, you will see components such as value, goal, and stakeholders used to model the reason behind specific domains or use cases.</p>
			<p>This is what the Full Framework looks like: </p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/Figure_3.06_B16354.jpg" alt="Figure 3.6 – ArchiMate Full Framework&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – ArchiMate Full Framework</p>
			<p>As per the Core Framework, this is just a logical model aimed to highlight areas of overlap between the layers and aspects. ArchiMate-compliant schemas will not necessarily come in a matrix format.</p>
			<p>In the next section, we will see the components of ArchiMate, which are the objects categorized according to the matrices we've just seen.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor074"/>Navigating the ArchiMate language tree</h2>
			<p>The ArchiMate language<a id="_idIndexMarker315"/> is conceptually structured as a tree, as follows:</p>
			<ul>
				<li>The top concept<a id="_idIndexMarker316"/> is the <strong class="bold">model</strong>, defined as a collection of concepts.</li>
				<li>A <strong class="bold">concept</strong> is a<a id="_idIndexMarker317"/> generic term that can be characterized as an element or a relationship.</li>
				<li>An <strong class="bold">element</strong> is a<a id="_idIndexMarker318"/> generic item that maps to a definition of the layers—that is, <strong class="bold">Behavior</strong>, <strong class="bold">Active Structure</strong>, or <strong class="bold">Passive Structure</strong>. An element is also allowed as part of the <strong class="bold">Motivation</strong> aspect (as per the Full Framework). Composite elements are intended as aggregations of other concepts. <strong class="bold">Active Structure</strong> and <strong class="bold">Behavior</strong> elements can further be classified as <strong class="bold">Internal</strong> or <strong class="bold">External</strong>. An event is a further specialization of a <strong class="bold">Behavior</strong> element.</li>
				<li>A <strong class="bold">relationship</strong> represents<a id="_idIndexMarker319"/> the connection between two or more concepts. Relationships are further classified as <strong class="bold">Structural</strong> (elements are statically associated to create another element), <strong class="bold">Dependency</strong> (elements may be affected by changes in other elements), <strong class="bold">Dynamic</strong> (elements have temporal dependencies to other elements), or <strong class="bold">Other</strong>.</li>
				<li><strong class="bold">Relationship connectors</strong> are<a id="_idIndexMarker320"/> logical junctions (<strong class="bold">And</strong>, <strong class="bold">Or</strong>), associating relationships of the same type.</li>
			</ul>
			<p>This is what the tree will look like:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/Figure_3.07_B16354.jpg" alt="Figure 3.7 – ArchiMate language tree&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – ArchiMate language tree</p>
			<p>In this classification, elements <a id="_idIndexMarker321"/>are just defined in an abstract way, not dependent on layers. In ArchiMate modeling, concrete implementations of those elements are then instantiated and classified in the relevant layer. As an example, a service is a generic internal <strong class="bold">Behavior</strong> element. It will then be used in the form of a business service, application service, or technology service, depending on which layer we are modeling.</p>
			<p>Other elements only make sense in a specific layer. For example, a communication network is an element property of the <strong class="bold">Technology</strong> layer, classified as an <strong class="bold">Active Structure</strong> element that doesn't have a one-to-one correspondence to elements present in other layers.</p>
			<p>The combination of elements and relationships can then be organized into custom views, effectively building architectural diagrams, optimized by stakeholders and viewpoints.</p>
			<p>In the next section, we are going to compare ArchiMate with UML.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor075"/>Comparing ArchiMate to UML</h2>
			<p>As you may <a id="_idIndexMarker322"/>have seen, the ArchiMate language shows some similarities to UML. That is not by accident: ArchiMate is indeed inspired by UML, and some concepts of the two frameworks are almost the same.</p>
			<p>However, other <a id="_idIndexMarker323"/>than specific differences (for instance, concepts present in one framework and not in the other), there are some high-level considerations to take into account when comparing those two frameworks, as outlined here:</p>
			<ul>
				<li>UML is strictly centered around object-oriented modeling, while ArchiMate is not linked to a specific paradigm.</li>
				<li>ArchiMate explicitly defines the <strong class="bold">Business</strong> layer and other higher-level concepts (including <strong class="bold">Motivation</strong> and <strong class="bold">Strategy</strong>) that are usually not contemplated in UML diagrams.</li>
				<li>UML provides a fixed set of diagrams, while ArchiMate is more of a palette of different components and aspects, aimed at building views and viewpoints, explicitly providing ways of customizing the architecture definition.</li>
			</ul>
			<p>As we saw when we covered the ArchiMate genesis at the beginning of this section, The Open Group is the organization behind many other standards, including TOGAF. Let's see what the relationship between ArchiMate and TOGAF is.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor076"/>Comparing ArchiMate to TOGAF</h2>
			<p><strong class="bold">TOGAF</strong> is a <a id="_idIndexMarker324"/>complete framework, aimed at providing a standardized <a id="_idIndexMarker325"/>way of defining, modeling, and implementing architecture projects (for example, classifying the enterprise architecture of an organization). TOGAF is, in a way, complementary to ArchiMate. While TOGAF does not provide a specific architectural notation (as ArchiMate does), ArchiMate does not prescribe a specific process for architecture definition (as TOGAF does).</p>
			<p>The core<a id="_idIndexMarker326"/> of TOGAF is the <strong class="bold">Architecture Development Method</strong> (<strong class="bold">ADM</strong>) process. The process is made up of eight steps (plus two special phases: the preliminary phase and requirements collection). A detailed explanation of each step is beyond the scope of this book, but <a id="_idIndexMarker327"/>the important takeaway is that each phase of the TOGAF ADM can be mapped as a layer into the ArchiMate framework (for instance, Phase B, which is <a id="_idIndexMarker328"/>about the definition of business architecture, of course maps to the <strong class="bold">Business</strong> layer, while Phase F, Migration Planning, can be mapped to the <strong class="bold">Implementation and</strong> <strong class="bold">Migration</strong> layer).</p>
			<p>This concludes the section dedicated to ArchiMate. In the next section, we will go through another very smart architectural modeling technique: the C4 model.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor077"/>Introducing the C4 model</h1>
			<p>The <strong class="bold">C4 model</strong> is a <a id="_idIndexMarker329"/>lightweight methodology for modeling and representing software architecture. It was created in 2006 by Simon Brown, and the official <a id="_idIndexMarker330"/>website (under a <strong class="bold">Creative Commons (CC) License</strong>) was launched in 2018.</p>
			<p>The model is somewhat inspired by UML, but it takes an alternative, leaner approach and, for this reason, is very popular among Agile teams who are looking for a more dynamic and less prescriptive way of designing and documenting software architectures. </p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor078"/>Exploring the C4 model</h2>
			<p>The keyword for <a id="_idIndexMarker331"/>understanding the C4 model is <em class="italic">zoom</em>. This concept means exactly what it does for pictures: the core idea of the C4 model, indeed, is about navigating the architectural representation by widening or narrowing the point of view. The C4 model is built around four main levels, detailed as follows:</p>
			<ul>
				<li><strong class="bold">Context</strong> is a <a id="_idIndexMarker332"/>diagram giving the big picture of an application. It shows the whole system represented as a box and depicts interactions with users and other systems.</li>
				<li><strong class="bold">Container</strong> is the<a id="_idIndexMarker333"/> view obtained when zooming in one level down. It represents what's inside the system box by modeling the subsystems comprising it. In terms of granularity, a container is something that can be deployed and executed—so, it can represent a backend application, a database, a filesystem, and so on.</li>
				<li><strong class="bold">Component</strong> is another <a id="_idIndexMarker334"/>zoom level, looking inside one container. In essence, a component is an abstraction grouping of a set of code instances (for example, a bunch of classes) that implement a functionality.</li>
				<li><strong class="bold">Code</strong> is the maximum<a id="_idIndexMarker335"/> level of zoom in this hierarchy and can be omitted. It's used to directly represent source code and configurations. The C4 model does not provide a specific suggestion on how to draw this kind of schema, which is usually represented using UML class diagrams. The reason why it's considered optional is that it is not very easy to keep this view up to date with code changes. A suggestion here is to try to stick to the automatic generation of this diagram if possible (by using plugins for the integrated development environments or other automated procedures).</li>
			</ul>
			<p>So, the C4 model, in essence, is made up of three different diagrams (plus an optional one). Each diagram is linked to the others by a different level of zoom, as shown in the following diagram:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/Figure_3.8_B16354_new.jpg" alt="Figure 3.8 – C4 zoom levels&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – C4 zoom levels</p>
			<p>The idea behind <a id="_idIndexMarker336"/>this technique is to focus on a different ecosystem based on the level of zoom. Moreover, different views can be aimed at different stakeholders. In the next section, we will see what's inside each level.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor079"/>Filling in the different levels</h2>
			<p>The C4 model <a id="_idIndexMarker337"/>does not provide any particular notation or symbology. Unlike UML, the kind of shapes, color coding, and so on are not part of the standard. The model simply encourages you to have a consistent representation (for example, once you choose a shape to represent an element, keep that shape in all the diagrams), to add an explicit legend to each diagram, and to comment as much as possible, for better clarity.</p>
			<p>C4 is made up of the following elements:</p>
			<ul>
				<li><strong class="bold">Software system</strong>: The <a id="_idIndexMarker338"/>top-level element, the center of the <em class="italic">context</em> representation. This is basically the whole system that we are going to design and implement.</li>
				<li><strong class="bold">Container</strong>: As <a id="_idIndexMarker339"/>we mentioned when discussing the level with the same name, a container is roughly something that can be deployed and started/stopped individually. This includes applications, databases, and so on. It's usually completed with a description of the technology and framework used.</li>
				<li><strong class="bold">Component</strong>: As <a id="_idIndexMarker340"/>before, this is a concept already introduced when discussing levels. A component is an abstraction aggregated over a subdomain or functionality. It's basically a grouping of code. It may or may not map one-to-one to a Java package.</li>
				<li><strong class="bold">Relationship</strong>: A <a id="_idIndexMarker341"/>line (or, more often, an arrow) representing a link between one of the aforementioned elements. It's usually completed with a textual explanation of the kind/scope/goal of the relationship, and technical details where relevant (for instance, the protocol used).</li>
				<li><strong class="bold">Person</strong>: A<a id="_idIndexMarker342"/> human interacting with the system.</li>
			</ul>
			<p>As you will see, there is no explicit advice for representing the code. It's a common practice to represent it with UML classes but, as we said before, this is something that is only done if strictly necessary.</p>
			<p>For the sake of completeness, C4 also includes some additional diagrams, as outlined here:</p>
			<ul>
				<li><strong class="bold">System landscape</strong>: A <a id="_idIndexMarker343"/>context diagram showing the whole enterprise, in order to represent the full <em class="italic">neighborhood</em> of our application.</li>
				<li><strong class="bold">Dynamic</strong>: A <a id="_idIndexMarker344"/>diagram representing a use case by numbering the interactions between elements in order to show the temporal progression. It looks quite similar to the UML sequence diagram but is less prescriptive in terms of syntax.</li>
				<li><strong class="bold">Deployment</strong>: This <a id="_idIndexMarker345"/>shows the mapping between containers and the <a id="_idIndexMarker346"/>underlying infrastructure, which may be a physical server, a virtual machine, a <strong class="bold">Linux</strong> container, and so on.</li>
			</ul>
			<p>With these diagrams, we have completed our excursus on the C4 model. As you will see, this model is simpler than UML and ArchiMate but still quite complete and expressive, meaning that you can model a lot of architecture types with it.</p>
			<p>In the next section, we are going to explore other modeling techniques that are less common and aimed at specific use cases.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor080"/>Other modeling techniques</h1>
			<p>The<a id="_idIndexMarker347"/> three modeling systems we have seen so far—UML, ArchiMate, and C4—are complete systems with different approaches, aimed at analyzing and representing software architecture end to end. </p>
			<p>In this section, we are going to quickly touch on some other techniques that have a more vertical approach, meaning that they are less general-purpose and more detailed when it <a id="_idIndexMarker348"/>comes to<a id="_idIndexMarker349"/> targeting specific use cases. Those<a id="_idIndexMarker350"/> techniques are <strong class="bold">Business Process Model and Notation</strong> (<strong class="bold">BPMN</strong>), <strong class="bold">Decision Model and Notation</strong> (<strong class="bold">DMN</strong>), and <strong class="bold">arc42</strong>.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor081"/>BPMN</h2>
			<p><strong class="bold">BPMN</strong> is a<a id="_idIndexMarker351"/> standard that was developed and is currently <a id="_idIndexMarker352"/>maintained by the <strong class="bold">Object Management Group</strong> (<strong class="bold">OMG</strong>), the same organization behind UML. BPMN is also a standard that has been<a id="_idIndexMarker353"/> recognized by the <strong class="bold">International Organization for Standardization</strong> (<strong class="bold">ISO</strong>).</p>
			<p>As may be obvious by its name, this language specializes in representing business processes.</p>
			<p>BPMN is <a id="_idIndexMarker354"/>usually associated with the activity diagram of UML, as both are flow chart-like diagrams (with a slightly different notation and symbology), aimed at describing a use case in terms of elementary steps and the connections between them (for instance, optional conditions), including a temporal dimension (from-to). But the similarities end there. </p>
			<p>UML is wider and aimed at modeling a lot of other things, rather than being fundamentally an object-oriented framework. On the other hand, BPMN focuses just on the modeling of business processes, and its primary goal is to define common ground between technical and business stakeholders. Indeed, the idea behind BPMN is that a businessperson (or better, someone with no technical skills but a good knowledge of processes) can model a diagram that can then be directly imported and executed into a BPMN engine, with little-to-no help from technical staff. This is not something that happens <a id="_idIndexMarker355"/>in the real world, as often, BPMN design is still an abstraction, and a number of technical steps are still needed to configure, deploy, and execute a BPMN process.</p>
			<p>However, it's true <a id="_idIndexMarker356"/>that BPMN is usually at least understandable (if not definable from scratch) by non-technical stakeholders. This is good enough for supporting collaboration between teams and reducing friction when translating business processes into code implementation.</p>
			<p>The <a id="_idIndexMarker357"/>building blocks of BPMN are categorized as four basic families: <strong class="bold">flow objects</strong>, <strong class="bold">connecting objects</strong>, <strong class="bold">swimlanes</strong>, and <strong class="bold">artifacts</strong>. For each of them, a graphical notation is formalized.</p>
			<p>Roughly speaking, <strong class="bold">flow objects</strong> represent the steps in the diagram and are described in more detail here:</p>
			<ul>
				<li>The <a id="_idIndexMarker358"/>most important one is probably the <strong class="bold">task</strong>, which is the abstraction of generic activity. This means both non-automatic activities (manually performed outside of the BPMN platform) and automatic activities (such as sending an email or triggering a web service call). </li>
				<li>Other basic flow objects are <strong class="bold">start</strong> and <strong class="bold">end</strong> events, delimiting the beginning and end of a workflow. </li>
				<li><strong class="bold">Gateways</strong> are another important kind of object, used to model things such as conditional execution or the parallelization of paths.</li>
			</ul>
			<p><strong class="bold">Connecting objects</strong> are <a id="_idIndexMarker359"/>used to link flow objects with one another. They can mimic different behaviors, such as sequences, messages, or associations. </p>
			<p><strong class="bold">Swimlanes</strong> are <a id="_idIndexMarker360"/>a way to graphically group and organize a business process. With swimlanes, you partition the business process according to the actor (or group of actors) in charge of a specific set of steps. </p>
			<p>Finally, <strong class="bold">artifacts</strong> are <a id="_idIndexMarker361"/>supporting concepts (for example, annotations), aimed at enriching the BPMN flow expressiveness. </p>
			<p>This is what all these objects look like graphically:</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/Figure_3.09_B16354.jpg" alt="Figure 3.9 – Graphical representation of some BPMN entities&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – Graphical representation of some BPMN entities</p>
			<p>We will talk <a id="_idIndexMarker362"/>again about BPMN in <a href="B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164"><em class="italic">Chapter 7</em></a>, <em class="italic">Exploring Middleware and Frameworks</em>.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor082"/>DMN</h2>
			<p><strong class="bold">DMN</strong> is a <a id="_idIndexMarker363"/>standard published and maintained by OMG, and it's younger than BPMN. DMN is somewhat complementary to BPMN. Instead of being aimed at <a id="_idIndexMarker364"/>modeling business processes, the scope of DMN is to model business rules, which are commonly used as one of the tasks in BPMN processes, rather than standalone, outside of BPMN processes.</p>
			<p>The goal is exactly the same as BPMN: defining a common language between business and IT personas, allowing for better collaboration.</p>
			<p>DMN encompasses elements such as decision tables (tables representing rule outcome based on<a id="_idIndexMarker365"/> the combination of a set of inputs) and <strong class="bold">Friendly Enough Expression Language</strong> (<strong class="bold">FEEL</strong>), an expression language <a id="_idIndexMarker366"/>used to formalize the logic behind decisions.</p>
			<p>We will talk about DMN again in <a href="B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164"><em class="italic">Chapter 7</em></a>, <em class="italic">Exploring Middleware and Frameworks</em>.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor083"/>arc42</h2>
			<p><strong class="bold">arc42</strong> is <a id="_idIndexMarker367"/>not a modeling technique but, instead, a templating model <a id="_idIndexMarker368"/>that helps with identifying, in software architecture, what the important concepts to document are and how to document them, by providing a kind of <em class="italic">scaffold</em>. </p>
			<p>arc42 was originally created by Dr. Peter Hruschka and Dr. Gernot Starke and has a completely open source approach (including being free to use in commercial projects). It's an exceptional way to start documenting your system from scratch, from an architectural point of view. From a practical viewpoint, it provides a scaffold (including sections to be fulfilled) on what the documentation should look like.</p>
			<p>It is not a substitute for other modeling languages and does not mandate a specific working model or development techniques. Instead, it is expected that you will use concepts and diagrams from other techniques (such as UML or C4) to fill out the sections of arc42-compliant documentation.</p>
			<p>Sections include elements such as the introduction, runtime view, cross-cutting concepts, architectural decisions, and more. It is really just a suggestion on the structure of the documentation; it's up to you to choose how deep to dive into each section. If you want to give it a try, you can go to the official website (see the <em class="italic">Further reading</em> section), download a template, and start to fill out the sections. It really is that easy.</p>
			<p>BPMN, DMN, and arc42 cover specific niches and target specific needs. For this reason, they can be a useful complement to the more generic and comprehensive frameworks that we have seen before. With this section, we've completed our overview of architectural modeling techniques. Let's now complete this chapter by looking at some examples.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor084"/>Case studies and examples</h1>
			<p>In this<a id="_idIndexMarker369"/> chapter, as in previous ones, we will continue our study of the mobile payments application. We will keep exploring this context to see some examples of the diagrams we have discussed so far.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor085"/>UML class diagrams for mobile payments</h2>
			<p>As a<a id="_idIndexMarker370"/> first example, we will look at UML<a id="_idIndexMarker371"/> class modeling. This is a very common diagram in Java projects. It is debated whether it's useful to build and maintain documentation that is so close to code (see also the considerations we discussed in the section on C4), since it may be seen as not adding that much value and being hard to maintain. Moreover, in modern development models (such as cloud-native and microservices), you are supposed to communicate between parts of<a id="_idIndexMarker372"/> the application by using established interfaces (such as <strong class="bold">REpresentational State Transfer</strong> (<strong class="bold">REST</strong>) or <strong class="bold">Google Remote Procedure Call</strong> (<strong class="bold">gRPC</strong>) and avoid exposing the internal model of your<a id="_idIndexMarker373"/> applications for others to tap into.</p>
			<p>My personal view is that the truth is in the middle. Unless you are developing something very peculiar (such as a framework, a library, or a plugin extension system), you may not need to document your entire code base as class diagrams. However, in order to analyze impacts and collaborate with other team members on the same code base, it may be worthwhile to at least sketch the critical aspects of your application (this being the core classes and interfaces). </p>
			<p>Another useful technique is to rely on the automatic generation of class diagrams. You may find plugins for most commonly used IDEs and also for Maven that can do that for you. Class diagrams can be particularly useful for giving an idea of what the model behind your code looks like (think about a new team member joining the project) and can ease things such as refactoring by giving an idea of what impact a change could have on related classes.</p>
			<p>This is what a class diagram for mobile payments will look like (picking just a handful of significant classes):</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/Figure_3.10_B16354.jpg" alt="Figure 3.10 – UML class diagram for payment and user objects&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – UML class diagram for payment and user objects</p>
			<p>As you<a id="_idIndexMarker374"/> can see in the preceding <a id="_idIndexMarker375"/>diagram, we are representing the <strong class="source-inline">Payment</strong> and <strong class="source-inline">User</strong> classes (some methods and fields are omitted for the sake of space). </p>
			<p>Some of the notations we used in this diagram are listed as follows:</p>
			<ul>
				<li><strong class="source-inline">MobilePayment</strong> is a subclass of <strong class="source-inline">Payment</strong> (generalization).</li>
				<li><strong class="source-inline">Payment</strong> implements the <strong class="source-inline">Auditable</strong> interface.</li>
				<li>Payment is associated with <strong class="source-inline">User</strong>. </li>
				<li>You can also see the multiplicity (each user can have <strong class="bold">n</strong> payments). As we discussed before, this kind of association is very similar to what you can find in an<a id="_idIndexMarker376"/> entity relationship <a id="_idIndexMarker377"/>diagram representing database tables.</li>
			</ul>
			<p>In the next section, we will see some C4 diagrams for mobile payments.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor086"/>C4 diagrams for mobile payments</h2>
			<p>In the <a id="_idIndexMarker378"/>section<a id="_idIndexMarker379"/> dedicated to C4 diagrams, we saw that the C4 technique involves diagramming the system <a id="_idIndexMarker380"/>according to four main levels of zoom. As discussed, the last level of zoom (code) is optional, and there are no strict guidelines given on how to represent it. It is common to use class diagrams, as we did in the previous section. Supposing we take that as one of the four representations for our use case, let's see what the path is that takes us to that schematization. Let's start with the context diagram of a module of the mobile payments solution, as follows:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/Figure_3.11_B16354.jpg" alt="Figure 3.11 – C4 context diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – C4 context diagram</p>
			<p>As we<a id="_idIndexMarker381"/> can see, this is very high-level, aimed at showing the ecosystem of interactions around our system. The mobile payment <a id="_idIndexMarker382"/>application is just a big block, and in the diagram, we summarize the external system and the actors interacting with it. There is also a synthetic description of the interactions (including the format/protocol) and <a id="_idIndexMarker383"/>the type of each element (software system, person). </p>
			<p>Let's now<a id="_idIndexMarker384"/> zoom into the container view, as follows:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/Figure_3.12_B16354.jpg" alt="Figure 3.12 – C4 component diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – C4 component diagram</p>
			<p>Here, we can see a closer representation of the technical pieces comprising our application. Our application is no longer just a box: we can see all the processes (things that can <a id="_idIndexMarker385"/>be deployed and started independently from one another) that comprise our system included in the dashed box. External context is still present (for example, the transactional backend). Every <a id="_idIndexMarker386"/>interaction has some explanation and protocol. Every container has a generic description of the kind of technology that is implementing it. If you think this diagram is pretty similar to what we saw in <a href="B16354_01_Final_JM_ePUB.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Designing Software Architectures in Java – Methods and Styles</em>, you are right.</p>
			<p>We are still a bit far from the code/class diagram. The component diagram is the missing link. We can view this here:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/Figure_3.13_B16354.jpg" alt="Figure 3.13 – C4 container diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.13 – C4 container diagram</p>
			<p>As expected, we zoomed in one level deeper, highlighting three components that comprise the business logic container (<strong class="bold">Mobile Application Backend</strong>, <strong class="bold">Data Mapper</strong>, and <strong class="bold">Integration</strong>).</p>
			<p>With this container diagram, we are one step above the direct representation of the implementation code (code diagram). </p>
			<p>For the sake of space, we are not providing the full code diagram here. However, the classes modeled as UML in the section before can be seen as a partial code diagram of the <strong class="bold">Data Mapper</strong> component, somewhat closing the loop.</p>
			<p>Those <a id="_idIndexMarker387"/>were very basic examples to show <a id="_idIndexMarker388"/>some bits of the modeling techniques in practice. Of course, giving detailed examples on every methodology shown in this chapter would have taken a whole book (or more than one) on its own, but I hope to have given you some basics to start from and deep dive into, in case you need to start practicing one of these diagrams for your projects. Let's now recap the main points of this chapter.</p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor087"/>Summary</h1>
			<p>In this chapter, we saw a wide range of techniques for modeling and representing the internal architecture of a software system. We started with UML, which is a consolidated standard that is very widespread and actively used, especially in some of its aspects, such as class diagrams and sequence diagrams.</p>
			<p>We then moved on to ArchiMate, which gives an enterprise architecture point of view on the subject and is commonly used in a context that follows the TOGAF approach. We then moved on to the C4 approach, which is a younger standard that is very lightweight and particularly suitable for projects adopting lean methodologies.</p>
			<p>We've also seen a handful of specialized languages (BPMN and DMN), which are perfect for modeling specific aspects of our application. Last but not least, we quickly touched on arc42, which is a wonderful template system to start your architecture documentation and ensure that nothing important is missing. </p>
			<p>In the next chapter, we will discuss <strong class="bold">Domain Driven Design</strong> (<strong class="bold">DDD</strong>) and other techniques to flesh out your application, which you can use once you have defined the architecture for it.</p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor088"/>Further reading</h1>
			<ul>
				<li>The UML official website: <a href="http://uml.org/">http://uml.org/</a></li>
				<li><em class="italic">The Unified Modeling Language User Guide</em>, by Grady Booch, James Rumbaugh, and Ivar Jacobson, published by Addison-Wesley, 1999.</li>
				<li>The Open Group, <em class="italic">ArchiMate® 3.1 Specification</em>: <a href="https://pubs.opengroup.org/architecture/archimate3-doc/">https://pubs.opengroup.org/architecture/archimate3-doc/</a></li>
				<li>InfoQ, <em class="italic">The C4 Model for Software Architecture</em>: <a href="https://www.infoq.com/articles/C4-architecture-model/">https://www.infoq.com/articles/C4-architecture-model/</a></li>
				<li>The C4 official website: <a href="https://c4model.com/">https://c4model.com/</a></li>
				<li>The arc42 official website: <a href="https://arc42.org/">https://arc42.org/</a></li>
			</ul>
		</div>
	</body></html>