- en: Chapter 5. Making Use of New APIs to Improve Your Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous lessons, we talked about possible ways to improve the performance
    of your Java application--from using the new command and monitoring tools to adding
    multithreading and introducing reactive programming and even to radically re-architecting
    your current solution into an unruly and flexible bunch of small independent deployment
    units and microservices. Without knowing your particular situation, there is no
    way for us to guess which of the provided recommendations can be helpful to you.
    That's why, in this lesson, we will describe a few recent additions to the JDK
    that can be helpful to you too. As we mentioned in the previous lesson, the gain
    in performance and overall code improvement does not always require us to radically
    redesign it. Small incremental changes can sometimes bring more significant improvements
    than we could have expected.
  prefs: []
  type: TYPE_NORMAL
- en: To bring back our analogy of a pyramid building, instead of trying to change
    the logistics of the delivery of the stones to the final destination--in order
    to shorten the construction time--it is often prudent to look closer at the tools
    the builders are using first. If each operation can be completed in half the time,
    the overall time of the project's delivery can be shortened accordingly, even
    if each of the stone blocks travels the same, if not a larger, distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the improvements of the programming tools we will discuss in this
    lesson:'
  prefs: []
  type: TYPE_NORMAL
- en: Using filters on streams as a way to find what you need and to decrease workload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new stack-walking API as the way analyze the stack trace programmatically
    in order to apply an automatic correction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New convenient static factory methods that create compact, unmodifiable collection
    instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new `CompletableFuture` class as a way to access the results of asynchronous
    processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JDK 9 stream API improvements that can speed up processing while making
    your code more readable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `java.util.streams.Stream` interface was introduced in Java 8\. It emits
    elements and supports a variety of operations that perform computations based
    on these elements. A stream can be finite or infinite, slow or fast emitting.
    Naturally, there is always a concern that the rate of the newly emitted elements
    may be higher than the rate of the processing. Besides, the ability to keep up
    with the input reflects the application's performance. The `Stream` implementations
    address the backpressure (when the rate of the element processing is lower than
    their emitting rate) by adjusting the emitting and processing rates using a buffer
    and various other techniques. In addition, it is always helpful if an application
    developer makes sure that the decision about processing or skipping each particular
    element is made as early as possible so that the processing resources are not
    wasted. Depending on the situation, different operations can be used for filtering
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first and the most straightforward way to do filtering is using the `filter()`
    operation. To demonstrate all the following capabilities, we will use the `Senator`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this class captures a senator's name, party, and how they voted
    for each of the issues (`0` means `No` and `1` means `Yes`). If for a particular
    issue `i`, `voteYes[i]=0` , and `voteNo[i]=0`, it means that the senator was not
    present. It is not possible to have `voteYes[i]=1` and `voteNo[i]=1` for the same
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that there are 100 senators, each belonging to one of the two
    parties: `Party1` or `Party2`. We can use these objects to collect statistics
    of how senators voted for the last 10 issues using the `Senate` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We hardcoded statistics for the first five senators so we can get predictable
    results while testing our filters and verify that the filters work. We also hardcoded
    voting statistics for the last two senators so we can have a predictable count
    while looking for senators who voted only `Yes` or only `No` for each of the ten
    issues. And we added the `timesVotedYes()` method, which provides the count of
    how many times the given `senator` voted `Yes`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can collect some data from the `Senate` class. For example, let''s see
    how many members of each party comprise the `Senate` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding code differs from run to run because of the random
    value generator we used in the `Senate` class, so do not expect to see exactly
    the same numbers if you try to run the examples. What is important is that the
    total of the two party members should be equal 100--the total number of the senators
    in the `Senate` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic Filtering](img/05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The expression `s -> s.getParty()=="Party1"` is the predicate that filters out
    only those senators who are members of `Party1`. So, the elements (`Senator` objects)
    of `Party2` do not get through and are not included in the count. That was pretty
    straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at a more complex example of filtering. Let''s count how many
    senators of each party voted on `issue 3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For `Party1`, we used two filters. For `Party2`, we combined them just to show
    another possible solution. The important point here is to use the filter by a
    party (`s -> s.getParty() == "Party1"`) first before the filter that selects only
    those who voted. This way, the second filter is used only for approximately half
    of the elements. Otherwise, if the filter that selects only those who voted were
    placed first, it would be applied to all 100 of `Senate` members.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic Filtering](img/05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, we can calculate how many members of each party voted `Yes` on `issue
    3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic Filtering](img/05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can refactor the preceding examples by taking advantage of the Java functional
    programming capability (using lambda expressions) and creating the `countAndPrint()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all the earlier code can be expressed in a more compact way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We created four predicates, `party1`, `party2`, `voted3`, and `yes3`, and we
    used each of them several times as parameters of the `countAndPrint()` method.
    The output of this code is the same as that of the earlier examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic Filtering](img/05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the `filter()` method of the `Stream` interface is the most popular way
    of filtering. But it is possible to use other `Stream` methods to accomplish the
    same effect.
  prefs: []
  type: TYPE_NORMAL
- en: Using Other Stream Operations for Filtering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alternatively, or in addition to the basic filtering described in the previous
    section, other operations (methods of the `Stream` interface) can be used for
    selection and filtering emitted stream elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s use the `flatMap()` method to filter out the members of
    the Senate by their party membership:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes advantage of the `Stream.of()` (produces a stream of one
    element) and `Stream.empty()`factory methods (it produces a stream without elements,
    so nothing is emitted further downstream). Alternatively, the same effect can
    be achieved using a new factory method (introduced in Java 9) called `Stream.ofNullable()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Stream.ofNullable()` method creates a stream of one element if not `null`;
    otherwise, it creates an empty stream, as in the previous example. Both the preceding
    code snippets--produce the same output if we run them for the same senate composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Other Stream Operations for Filtering](img/05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, the same result can be achieved using a `java.uti.Optional` class
    that may or may not contain a value. If a value is present (and not `null`), its
    `isPresent()` method returns `true` and the `get()` method returns the value.
    Here is how we can use it to filter out the members of one party:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we map (transform) an element (the `Senator` object) to an `Optional`
    object with or without the value. Next, we use the `flatMap()` method to either
    generate a stream of a single element or else an empty stream, and then we count
    the elements that made it through. In Java 9, the `Optional` class acquired a
    new factory `stream()` method that produces a stream of one element if the `Optional`
    object carries a non-null value; otherwise, it produces an empty stream. Using
    this new method, we can rewrite the previous code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the previous examples produce the same output if we run them for the same
    senate composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Other Stream Operations for Filtering](img/05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can apply another kind of filtering when we need to capture the first element
    emitted by the stream. This means that we terminate the stream after the first
    element is emitted. For example, let''s find the first senator of `Party1`who
    voted `Yes` on `issue 3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![Using Other Stream Operations for Filtering](img/05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This was exactly what we expected when we seeded data in the `Senate` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can use the `findAny()` method to find any `senator` who voted
    `Yes` on `issue 3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is also as we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Other Stream Operations for Filtering](img/05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is typically (but not necessarily) the first element of the stream. But one
    should not rely on this assumption, especially in the case of parallel processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Stream` interface also has three `match` methods that, although they return
    a Boolean value, can be used for filtering too if the specific object is not required
    and we only need to establish the fact that such an object exists or not. The
    names of these methods are `anyMatch()`, `allMatch()`, and `noneMatch()`. Each
    of them takes a predicate and returns a Boolean. Let''s start by demonstrating
    the `anyMatch()` method. We will use it to find out if there is at least one `senator`
    of `Party1` who voted `Yes` on `issue 3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of running the previous code should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Other Stream Operations for Filtering](img/05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To demonstrate the `allMatch()` method, we will use it to find out if all the
    members of `Party1` in the `Senate` class have voted `Yes` on `issue 3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the previous code may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Other Stream Operations for Filtering](img/05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And the last of the three `match` methods--the `noneMatch()` method--will be
    used to figure out if some senators of `Party1` have voted `Yes` on `issue 3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the earlier example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Other Stream Operations for Filtering](img/05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: However, in real life, it could be very different because quite a few issues
    in the `Senate` class are voted for along party lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet another type of filtering is required when we need to skip all the duplicate
    elements in a stream and select only unique ones. The `distinct()` method is designed
    for the purpose. We will use it to find the names of the parties that have their
    members in the `Senate` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The result, as expected, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Other Stream Operations for Filtering](img/05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Well, no surprise there?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also filter out all the elements of the `stream` except the certain
    count of the first ones, using the `limit()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you remember how we have set up the first five senators in the list, you
    could predict that the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Other Stream Operations for Filtering](img/05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s find only one element in a stream--the biggest one. To do this,
    we can use the `max()` method of the `Stream` interface and the `Senate.timeVotedYes()`
    method (we will apply it on each senator):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![Using Other Stream Operations for Filtering](img/05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Yes, we got `Senator100` filtered as the one who voted `Yes` on all 10 issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can find the senator who voted `No` on all 10 issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We expect it to be `Senator99`, and here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Other Stream Operations for Filtering](img/05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's why we hardcoded several stats in the `Senate` class, so we can verify
    that our queries work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the last two methods can help us with filtering, we will demonstrate the
    `takeWhile()` and `dropWhile()`methods introduced in JDK 9\. We will first print
    the data of all the first five senators and then use the `takeWhile()`method to
    print the first senators until we encounter the one who voted `Yes` more than
    four times, and then stop printing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The result for the previous code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Other Stream Operations for Filtering](img/05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `dropWhile()` method can be used for the opposite effect, that is, to filter
    away, to skip the first senators until we encounter the one who voted `Yes` more
    than four times, then continue printing all the rest of the senators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Other Stream Operations for Filtering](img/05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This concludes our demonstration of the ways in which a stream of elements can
    be filtered. We hope you have learned enough to be able to find a solution for
    any of your filtering needs. Nevertheless, we encourage you to study and experiment
    with the Stream API on your own, so you can retain what you have learned so far
    and acquire your own view on the rich APIs of Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: Stack-Walking APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exceptions do happen, especially during development or the period of software
    stabilization. But in a big complex system, the chance of getting an exception
    is possible even in production, especially when several third-party systems are
    brought together and the need arises to analyze the stack trace programmatically
    in order to apply an automatic correction. In this section, we will discuss how
    it can be done.
  prefs: []
  type: TYPE_NORMAL
- en: Stack Analysis before Java 9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The traditional reading of the stack trace, using objects of the `java.lang.Thread`
    and `java.lang.Throwable`classes, was accomplished by capturing it from the standard
    output. For example, we can include this line in any section of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous line will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack Analysis before Java 9](img/05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, we can include this line in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack Analysis before Java 9](img/05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This output can be captured, read, and analyzed programmatically, but requires
    quite a bit of custom code writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'JDK 8 made this easier via the usage of streams. Here is the code that allows
    reading the stack trace from the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous line produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack Analysis before Java 9](img/05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, we could use this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the previous code shows the stack trace in a similar way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack Analysis before Java 9](img/05_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If, for example, you would like to find the fully qualified name of the caller
    class, you can use one of these approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Such coding is possible because the `getStackTrace()` method returns an array
    of objects of the `java.lang.StackTraceElement` class, each representing a stack
    frame in a stack trace. Each object carries stack trace information accessible
    by the `getFileName()`, `getClassName()`, `getMethodName()`, and `getLineNumber()`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how it works, we have created three classes, `Clazz01`, `Clazz02`,
    and `Clazz03`, that call each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s call the `method()` method of `Clazz01`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are two (the second and the third) of the six stack trace frames printed
    out by the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack Analysis before Java 9](img/05_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In principle, every called class has access to this information. But to find
    out which class called the current class may not be so easy because you need to
    figure out which frame represents the caller. Also, in order to provide this info,
    JVM captures the entire stack (except for the hidden stack frames), and it may
    affect performance.
  prefs: []
  type: TYPE_NORMAL
- en: That was the motivation for introducing the `java.lang.StackWalker` class, its
    nested `Option` class, and the `StackWalker.StackFrame` interface in JDK 9.
  prefs: []
  type: TYPE_NORMAL
- en: New Better Way to Walk the Stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `StackWalker` class has four `getInstance()` static factory methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getInstance()`: This returns a `StackWalker` class instance configured to
    skip all hidden frames and the caller class reference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getInstance(StackWalker.Option option)`: This creates a `StackWalker` class
    instance with the given option specifying the stack frame information it can access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getInstance(Set<StackWalker.Option> options)`: This creates a `StackWalker`
    class instance with the given set of options'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getInstance(Set<StackWalker.Option> options, int estimatedDepth)`: This allows
    you to pass in the `estimatedDepth` parameter that specifies the estimated number
    of stack frames this instance will traverse so that the Java machine can allocate
    the appropriate buffer size it might need'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The value passed as an option can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StackWalker.Option.RETAIN_CLASS_REFERENCE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StackWalker.Option.SHOW_HIDDEN_FRAMES`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StackWalker.Option.SHOW_REFLECT_FRAMES`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The other three methods of the `StackWalker` class are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`T walk(Function<Stream<StackWalker.StackFrame>, T> function)`: This applies
    the passed in function to the stream of stack frames, the first frame representing
    the method that called this `walk()` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void forEach(Consumer<StackWalker.StackFrame> action)`: This performs the
    passed in action on each element (of the `StalkWalker.StackFrame` interface type)
    of the stream of the current thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Class<?> getCallerClass()`: This gets objects of the `Class` class of the
    caller class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, it allows much more straightforward stack trace analysis. Let''s
    modify our demo classes using the following code and access the caller name in
    one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code will produce this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![New Better Way to Walk the Stack](img/05_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can appreciate the simplicity of the solution. If we need to see the entire
    stack trace, we can add the following line to the code in `Clazz03`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![New Better Way to Walk the Stack](img/05_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, with only one line of code, we have achieved much more readable output.
    We could achieve the same result by using the `walk()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of just printing `StackWalker.StackFrame`, we also could run a deeper
    analysis on it, if need be, using its API, which is more extensive than the API
    of `java.lang.StackTraceElement`. Let''s run the code example that prints every
    stack frame and its information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the previous code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![New Better Way to Walk the Stack](img/05_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note the `StackFrameInfo` class that implements the `StackWalker.StackFrame`
    interface and actually does the job. The API also allows converting back to the
    familiar `StackTraceElement` object for backward compatibility and for the enjoyment
    of those who are used to it and do not want to change their code and habits.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, with the full stack trace generated and stored in the array in
    the memory (like in the case of the traditional stack trace implementation), the
    `StackWalker` class brings only the requested elements. This is another motivation
    for its introduction in addition to the demonstrated simplicity of use. More details
    about the `StackWalker` class API and its usage can be found at [https://docs.oracle.com/javase/9/docs/api/java/lang/StackWalker.html](https://docs.oracle.com/javase/9/docs/api/java/lang/StackWalker.html).
  prefs: []
  type: TYPE_NORMAL
- en: Convenience Factory Methods for Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the introduction of functional programming in Java, the interest in and
    need for immutable objects increased. The functions passed into the methods may
    be executed in substantially different contexts than the one they were created
    in, so the need to decrease the chances of unexpected side effects made the case
    for immutability stronger. Besides, the Java way of creating an unmodifiable collection
    was quite verbose anyway, so the issue was addressed in Java 9\. Here is an example
    of the code that creates an immutable collection of the `Set` interface in Java
    8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'After one does it several times, the need for a convenience method comes up
    naturally as the basic refactoring consideration that always lingers in the background
    thinking of any software professional. In Java 8, the previous code could be changed
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if streams are your friends, you could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Another version of the previous code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it has more boilerplate code than the values you are trying to encapsulate.
    So, in Java 9, a shorter version of the previous code became possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar factories were introduced to generate immutable collections of `List`
    interfaces and `Map` interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Why New Factory Methods?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ability to express the same functionality in more compact manner is very
    helpful, but it would probably not be enough motivation to introduce these new
    factories. It was much more important to address the weakness of the existing
    implementation of `Collections.unmodifiableList()`, `Collections.unmodifiableSet()`,
    and `Collections.unmodifiableMap()`. Although the collections created using these
    methods throw an `UnsupportedOperationException` class when you try to modify
    or add/remove their elements, they are just wrappers around the traditional modifiable
    collections and can thus be susceptible to modifications, depending on the way
    you construct them. Let''s walk through examples to illustrate the point. By the
    way, another weakness of the existing unmodifiable implementation is that it does
    not change how the source collection is constructed, so the difference between
    `List`, `Set`, and `Map`--the ways in which they can be constructed--remains in
    place, which may be a source of bugs or even frustration when a programmer uses
    them. The new factory methods address this issue too, providing a more unified
    approach using the `of()` factory method (and the additional `ofEntries()` method
    for `Map`) only. Having said that, let''s get back to the examples. Look at the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Attempts of direct modification of the elements of `unmodifiableList1` lead
    to `UnsupportedOperationException`. Nevertheless, we can modify them via the underlying
    `list` object. If we run the previous example, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Why New Factory Methods?](img/05_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Even if we use `Arrays.asList()` for the source list creation, it will only
    protect the created collection from adding a new element, but not from modifying
    the existing one. Here is a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the previous code, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Why New Factory Methods?](img/05_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We also included a `null` element to demonstrate how the existing implementation
    treats them, because, by contrast, the new factories of immutable collections
    do not allow `null` to be included. By the way, they do not allow duplicate elements
    in `Set` either (while the existing implementation just ignores them), but we
    will demonstrate this aspect later while using the new factory methods in code
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be fair, there is a way to create a truly immutable collection of `List`
    interfaces with the existing implementation too. Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to create an immutable list is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a variation of the earlier code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the previous three examples, we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Why New Factory Methods?](img/05_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that although we cannot modify the content of these lists, we can put `null`
    in them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The situation with `Set` is quite similar to what we have seen with the lists
    earlier. Here is the code that shows how an unmodifiable collection of `Set` interfaces
    can be modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting collection of `Set` interfaces can be modified even if we convert
    the original collection from an array to a list and then to a set, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of running the previous two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Why New Factory Methods?](img/05_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you have not worked with sets in Java 9, you may be surprised to see the
    unusually messed up order of the set elements in the output. In fact, it is another
    new feature of set and maps introduced in JDK 9\. In the past, `Set` and `Map`
    implementations did not guarantee to preserve the elements' order. But more often
    than not, the order was preserved and some programmers wrote code that relied
    on it, thus introducing an annoyingly inconsistent and not easily reproducible
    defect into an application. The new `Set` and `Map` implementations change the
    order more often, if not at every new run of the code. This way, it exposes potential
    defects early in development and decreases the chance of its propagation into
    production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the lists, we can create immutable sets even without using Java
    9''s new immutable set factory. One way to do it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, as in the case with lists, here is another way to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Another variant of the previous code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run all three examples of creating an immutable collection of `iSet`
    interfaces that we have just introduced, the result would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Why New Factory Methods?](img/05_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With `Map` interfaces, we were able to come up with only one way to modify
    the `unmodifiableMap` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the previous code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Why New Factory Methods?](img/05_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We found four ways to create an immutable collection of `Map` interfaces without
    using Java 9 enhancements. Here is the first example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The second example has a bit of a complication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'A variant of the previous code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'After we run all the four last examples, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Why New Factory Methods?](img/05_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With that revision of the existing collections implementations, we can now discuss
    and appreciate the new factory methods of collections in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: The New Factory Methods in Action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After revisiting the existing methods of collection creation, we can now review
    and enjoy the related API introduced in Java 9\. As in a previous section, we
    start with the `List` interface. Here is how simple and consistent the immutable
    list creation can be using the new `List.of()` factory method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the previous code comments, the new factory method does
    not allow including `null` as the list value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `immutableSet` creation looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the previous code comments, the `Set.of()` factory method
    does not allow adding `null` or a duplicate element when creating an immutable
    collection of `Set` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The immutable collection of `Map` interfaces has similar format too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `Map.of()` method does not allow `null` as a value either. Another feature
    of the `Map.of()` method is that it allows a compile-time check of the element
    type, which decreases the chances of a runtime problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'For those who prefer more compact code, here is another way to express the
    same functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the output if we run all the previous examples of the usage of
    the new factory methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The New Factory Methods in Action](img/05_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we mentioned already, the ability to have immutable collections, including
    empty ones, is very helpful for functional programming as this feature makes sure
    that such a collection cannot be modified as a side effect and cannot introduce
    unexpected and difficult to trace defects. The full variety of the new factories
    methods includes up to 10 explicit entries plus one with an arbitrary number of
    elements. Here''s how it looks for `List` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Set` factory methods look similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the `Map` factory methods follow suit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The decision not to add new interfaces for immutable collections left them susceptible
    to causing occasional confusion when programmers assumed they could call `add()`
    or `put()` on them. Such an assumption, if not tested, will cause a runtime error
    that throws an `UnsupportedOperationException`. Despite this potential pitfall,
    the new factory methods for immutable collection creation are very useful additions
    to Java.
  prefs: []
  type: TYPE_NORMAL
- en: CompletableFuture in Support of Asynchronous Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `java.util.concurrent.CompletableFuture<T>` class was first introduced in
    Java 8\. It is the next level of asynchronous call control over `java.util.concurrent.Future<T>`
    interface. It actually implements `Future`, as well as `java.util.concurrent.CompletionStage<T>`.
    In Java 9, `CompletableFuture` was enhanced by adding new factory methods, support
    for delays and timeouts, and improved subclassing--we will discuss these features
    in more details in the sections to follow. But first, let's have an overview of
    the `CompletableFuture` API.
  prefs: []
  type: TYPE_NORMAL
- en: The CompletableFuture API Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `CompletableFuture` API consists of more than 70 methods, 38 of which are
    implementations of the `CompletionStage` interface, and five are the implementations
    of `Future`. Because the `CompletableFuture`class implements the `Future` interface,
    it can be treated as `Future` and will not break the existing functionality based
    on the `Future` API.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the bulk of the API comes from `CompletionStage`. Most of the methods return
    `CompletableFuture` (in the `CompletionStage` interface, they return `CompletionStage`,
    but they are converted to `CompletableFuture`when implemented in `CompletableFuture`
    class), which means that they allow chaining the operations similar to how the
    `Stream` methods do when only one element goes through a pipe. Each method has
    a signature that accepts a function. Some methods accept `Function<T,U>`, which
    is going to be applied to the passed-in value `T` and return the result `U`. Other
    methods accept `Consumer<T>`, which takes the passed-in value and returns `void`.
    Yet other methods accept `Runnable`, which does not take any input and returns
    `void`. Here is one group of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'They all return `CompletableFuture`, which carries the result of the function
    or void (in the case of `Runnable`and `Consumer`). Each of them has two companion
    methods that perform the same function asynchronously. For example, let''s take
    the `thenRun(Runnable action)` method. The following are its companions:'
  prefs: []
  type: TYPE_NORMAL
- en: The `thenRunAsync(Runnable action)` method, which runs the action in another
    thread from the default `ForkJoinPool.commonPool()` pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `thenRun(Runnable action, Executor executor)` method, which runs the action
    in another thread from the pool passed in as the parameter executor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that, we have covered nine methods of the `CompletionStage` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another group of methods consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: These methods execute the passed in action after one or both the `CompletableFuture`
    (or `CompletionStage`) objects produce a result that is used as an input to the
    action. By both, we mean the `CompletableFuture` that provides the method and
    the one that is passed in as a parameter of the method. From the name of these
    methods, you can quite reliably guess what their intent is. We will demonstrate
    some of them in the following examples. Each of these seven methods has two companions
    for asynchronous processing, too. This means that we have already described 30
    (out of 38) methods of the `CompletionStage` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a group of two methods that are typically used as terminal operations
    because they can handle either the result of the previous method (passed in as
    `T`) or an exception (passed in as `Throwable`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We will see an example of the use of these methods later. When an exception
    is thrown by a method in the chain, all the rest of the chained methods are skipped
    until the first `handle()` method or `whenComplete()` is encountered. If neither
    of these two methods are present in the chain, then the exception will bubble
    up as any other Java exception. These two also have asynchronous companions, which
    means that we talked about 36 (out of 38) methods of `CompletionStage` interface
    already.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a method that handles exceptions only (similar to a catch block
    in the traditional programming):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This method does not have asynchronous companions, just like the last remaining
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: It just returns a `CompletableFuture` object with the same properties as this
    stage. With that, we have described all 38 methods of the `CompletionStage` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also some 30 methods in the `CompletableFuture` class that do not
    belong to any of the implemented interfaces. Some of them return the `CompletableFuture`
    object after asynchronously executing the provided function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Others execute several objects of `CompletableFuture` in parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a group of the methods that generate completed futures, so the
    `get()` method on the returned `CompletableFuture` object will not block any more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the methods perform various other functions that can be helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the official Oracle documentation, which describes these and other
    methods of the `CompletableFuture` API at [http://download.java.net/java/jdk9/docs/api/index.html?java/util/concurrent/CompletableFuture.html](http://download.java.net/java/jdk9/docs/api/index.html?java/util/concurrent/CompletableFuture.html).
  prefs: []
  type: TYPE_NORMAL
- en: The CompletableFuture API Enhancements in Java 9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java 9 introduces several enhancements to `CompletableFuture`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `CompletionStage<U> failedStage(Throwable ex)` factory method returns the
    `CompletionStage` object completed with the given exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CompletableFuture<U> failedFuture(Throwable ex)` factory method returns
    the `CompletableFuture`object completed with the given exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new `CompletionStage<U> completedStage(U value)` factory method returns
    the `CompletionStage` object completed with the given `U` value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompletableFuture<T> completeOnTimeout(T value, long timeout, TimeUnit unit)`
    completes `CompletableFuture` task with the given `T` value if not otherwise completed
    before the given timeout'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompletableFuture<T> orTimeout(long timeout, TimeUnit unit)` completes `CompletableFuture`
    with `java.util.concurrent.TimeoutException` if not completed before the given
    timeout'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible now to override the `defaultExecutor()` method to support another
    default executor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new method, `newIncompleteFuture()`, makes it easier to subclass the `CompletableFuture`
    class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Problem and the Solution using Future
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate and appreciate the power of `CompletableFuture`, let''s start
    with a problem implemented using just `Future` and then see how much more effectively
    it can be solved with `CompletableFuture`. Let''s imagine that we are tasked with
    modeling a building that consists of four stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Collecting materials for the foundation, walls, and roof
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the foundation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raising up the walls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing and finishing the roof
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the traditional sequential programming for the single thread, the model
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `Stage` is an enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The `doStage()` method has two overloaded versions. Here is the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The second version is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sleepSec()`, `isSuccess()`, and `getResult()` methods look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The successful house construction (if we run the previous code without assigning
    any value to the `failedStage` variable) looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Problem and the Solution using Future](img/05_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we set `failedStage=Stage.Walls`, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Problem and the Solution using Future](img/05_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using `Future`, we can shorten the time it takes to build the house:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `getSuccessOrFirstFailure()` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The successful building of the house now is faster because material collection
    happens in parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Problem and the Solution using Future](img/05_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'By taking advantage of Java functional programming, we can change the second
    half of our implementation to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The chain of the previous nested functions is triggered by `supplier5.get()`
    in the last line. It blocks until all the functions are completed sequentially,
    so there is no performance improvement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Problem and the Solution using Future](img/05_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And that is as far as we can go with `Future`. Now let's see if we can improve
    the previous code using `CompletableFuture`.
  prefs: []
  type: TYPE_NORMAL
- en: The Solution with CompletableFuture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s how we can chain the same operations using the `CompletableFuture`
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it work, we had to change the implementation of one of the `doStage()`
    to `doStageEx()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see how the system behaves if one of the first stages of collecting
    materials fails (`failedStage = Stage.WallsMaterials`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Solution with CompletableFuture](img/05_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The exception was thrown by the `WallsMaterials` stage and caught by the `handleAsync()`
    method, as expected. And, again, the processing was done asynchronously after
    the `Out!!!!!` message was printed.
  prefs: []
  type: TYPE_NORMAL
- en: Other Useful Features of CompletableFuture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the great advantages of `CompletableFuture` is that it can be passed
    around as an object and used several times to start different chains of operations.
    To demonstrate this capability, let''s create several new operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of these operations are going to be handled by the `myHandler()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Note all the different types returned by the operations. Now we can build a
    chain that forks in two at some point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Other Useful Features of CompletableFuture](img/05_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `CompletableFuture` API provides a very rich and well-thought-through API
    that supports, among other things, the latest trends in reactive microservices
    because it allows processing data fully asynchronously as it comes in, splitting
    the flow if needed, and scaling to accommodate the increase of the input. We encourage
    you to study the examples (many more are provided in the code that accompanies
    this book) and look at the API at [http://download.java.net/java/jdk9/docs/api/index.html?java/util/concurrent/CompletableFuture.html](http://download.java.net/java/jdk9/docs/api/index.html?java/util/concurrent/CompletableFuture.html).
  prefs: []
  type: TYPE_NORMAL
- en: Stream API Improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the new `Stream` API features in Java 9 have already been demonstrated
    in the section that describes `Stream` filtering. To remind you, here are the
    examples we have demonstrated based on the `Stream` API improvements in JDK 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The only one we have not mentioned yet is the new overloaded `iterate()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of its usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'We had to add `limit(5)` because this version of the `iterate()` method creates
    an unlimited stream of integer numbers. The result of the previous code is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stream API Improvements](img/05_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In Java 9, an overloaded `iterate()` method was added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, it has now a `Predicate` functional interface as a parameter that
    allows limiting the stream as needed. For example, the following code produces
    exactly the same result as the previous example with `limit(5)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Note that the type of the stream element does not need to be an integer. It
    can be any type produced by the source. So, the new `iterate()` method can be
    used to provide criteria for the termination of the stream of any type of data.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this lesson, we covered a lot of ground in the area of the new features introduced
    with Java 9\. First, we looked at many ways to stream filtering, starting with
    the basic `filter()` method and ending up using the `Stream` API additions of
    JDK 9\. Then, you learned a better way to analyze the stack trace using the new
    `StackWalker` class. The discussion was illustrated by specific examples that
    help you to see the real working code.
  prefs: []
  type: TYPE_NORMAL
- en: We used the same approach while presenting new convenient factory methods for
    creating immutable collections and new capabilities for asynchronous processing
    that came with the `CompletableFuture` class and its enhancements in JDK 9.
  prefs: []
  type: TYPE_NORMAL
- en: We ended this lesson by enumerating the improvements to the `Stream` API--those
    we have demonstrated in the filtering code examples and the new `iterate()` method.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we come to the end of this book. You can now try and apply the tips
    and techniques you have learned to your project or, if it is not suitable for
    that, to build your own Java project for high performance. While doing that, try
    to solve real problems. That will force you to learn new skills and frameworks
    instead of just applying the knowledge you have already, although the latter is
    helpful too--it keeps your knowledge fresh and practical.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to learn is to do it yourself. As Java continues to improve and
    expand, watch out for new editions of this and similar books by Packt.
  prefs: []
  type: TYPE_NORMAL
- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The _______ interface was introduced in Java 8 to emit elements and supports
    a variety of operations that perform computations based on stream elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following factory methods of the `StackWalker` class creates a
    `StackWalker` class instance with the given option of specifying the stack frame
    information that it can access?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`getInstance()`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`getInstance(StackWalker.Option option)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`getInstance(Set<StackWalker.Option> options)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`getInstance(Set<StackWalker.Option> options, int estimatedDepth)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'State whether True or False: The `CompletableFuture` API consists of many methods
    which are implementations of the `CompletionStage` interface, and are the implementations
    of `Future`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which among the following methods is used when a type of filtering is required
    to skip all the duplicate elements in a stream and select only unique element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`distinct()`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`unique()`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`selectall()`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`filtertype()`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'State whether True or False: One of the great advantages of `CompletableFuture`
    is that it can be passed around as an object and used several times to start different
    chains of operations.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
