- en: Chapter 5. Making Use of New APIs to Improve Your Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：利用新API改进您的代码
- en: In the previous lessons, we talked about possible ways to improve the performance
    of your Java application--from using the new command and monitoring tools to adding
    multithreading and introducing reactive programming and even to radically re-architecting
    your current solution into an unruly and flexible bunch of small independent deployment
    units and microservices. Without knowing your particular situation, there is no
    way for us to guess which of the provided recommendations can be helpful to you.
    That's why, in this lesson, we will describe a few recent additions to the JDK
    that can be helpful to you too. As we mentioned in the previous lesson, the gain
    in performance and overall code improvement does not always require us to radically
    redesign it. Small incremental changes can sometimes bring more significant improvements
    than we could have expected.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的课程中，我们讨论了提高Java应用程序性能的可能方法——从使用新的命令和监控工具到添加多线程，引入响应式编程，甚至将当前解决方案彻底重构为混乱而灵活的一组小型独立部署单元和微服务。由于不了解您的具体情况，我们无法猜测提供的建议中哪些建议对您有帮助。这就是为什么在本课中，我们将描述一些对您也有帮助的JDK的最新补充。正如我们在之前的课程中提到的，性能和整体代码改进的收益并不总是需要我们彻底重新设计。有时，小的增量变化可以带来比我们预期的更显著的改进。
- en: To bring back our analogy of a pyramid building, instead of trying to change
    the logistics of the delivery of the stones to the final destination--in order
    to shorten the construction time--it is often prudent to look closer at the tools
    the builders are using first. If each operation can be completed in half the time,
    the overall time of the project's delivery can be shortened accordingly, even
    if each of the stone blocks travels the same, if not a larger, distance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们构建金字塔的类比为例，与其试图改变将石头运送到最终目的地的物流——为了缩短建设时间——通常更明智的做法是首先仔细看看建造者使用的工具。如果每个操作都可以在半数时间内完成，那么整个项目的交付时间可以相应缩短，即使每个石块移动的距离相同，甚至更长。
- en: 'These are the improvements of the programming tools we will discuss in this
    lesson:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将在本课中讨论的编程工具的改进：
- en: Using filters on streams as a way to find what you need and to decrease workload
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流上的过滤器作为找到所需内容并减少工作负载的方法
- en: A new stack-walking API as the way analyze the stack trace programmatically
    in order to apply an automatic correction
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种新的堆栈跟踪API，作为以编程方式分析堆栈跟踪以应用自动纠正的方法
- en: New convenient static factory methods that create compact, unmodifiable collection
    instances
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的方便的静态工厂方法，用于创建紧凑、不可修改的集合实例
- en: The new `CompletableFuture` class as a way to access the results of asynchronous
    processing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的`CompletableFuture`类作为访问异步处理结果的方法
- en: The JDK 9 stream API improvements that can speed up processing while making
    your code more readable
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 9流API的改进，可以在加快处理速度的同时使您的代码更易于阅读
- en: Filtering Streams
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤流
- en: The `java.util.streams.Stream` interface was introduced in Java 8\. It emits
    elements and supports a variety of operations that perform computations based
    on these elements. A stream can be finite or infinite, slow or fast emitting.
    Naturally, there is always a concern that the rate of the newly emitted elements
    may be higher than the rate of the processing. Besides, the ability to keep up
    with the input reflects the application's performance. The `Stream` implementations
    address the backpressure (when the rate of the element processing is lower than
    their emitting rate) by adjusting the emitting and processing rates using a buffer
    and various other techniques. In addition, it is always helpful if an application
    developer makes sure that the decision about processing or skipping each particular
    element is made as early as possible so that the processing resources are not
    wasted. Depending on the situation, different operations can be used for filtering
    the data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.streams.Stream`接口是在Java 8中引入的。它发出元素并支持基于这些元素执行计算的各种操作。流可以是有限的或无限的，缓慢或快速发出。自然地，总是存在一个担忧，即新发出的元素的速率可能高于处理速率。此外，跟上输入的能力反映了应用程序的性能。《Stream》实现通过使用缓冲区和各种其他技术调整发出和处理速率来解决背压（当元素处理的速率低于它们的发出速率时）。此外，如果应用程序开发者确保尽可能早地做出处理或跳过每个特定元素的决定，那么这总是有帮助的，这样就不会浪费处理资源。根据情况，可以使用不同的操作来过滤数据。'
- en: Basic Filtering
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本过滤
- en: 'The first and the most straightforward way to do filtering is using the `filter()`
    operation. To demonstrate all the following capabilities, we will use the `Senator`
    class:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 执行过滤的第一个且最直接的方法是使用`filter()`操作。为了展示所有以下功能，我们将使用`Senator`类：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, this class captures a senator's name, party, and how they voted
    for each of the issues (`0` means `No` and `1` means `Yes`). If for a particular
    issue `i`, `voteYes[i]=0` , and `voteNo[i]=0`, it means that the senator was not
    present. It is not possible to have `voteYes[i]=1` and `voteNo[i]=1` for the same
    issue.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个类捕捉了参议员的姓名、所属党派以及他们如何对每个问题进行投票（`0`表示`否`，`1`表示`是`）。如果对于特定问题`i`，`voteYes[i]=0`且`voteNo[i]=0`，这意味着参议员缺席。对于同一问题，不可能同时有`voteYes[i]=1`和`voteNo[i]=1`。
- en: 'Let''s assume that there are 100 senators, each belonging to one of the two
    parties: `Party1` or `Party2`. We can use these objects to collect statistics
    of how senators voted for the last 10 issues using the `Senate` class:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有100位参议员，每位参议员属于两个党派之一：`Party1`或`Party2`。我们可以使用这些对象收集参议员在过去10个问题上的投票统计信息，使用`Senate`类：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We hardcoded statistics for the first five senators so we can get predictable
    results while testing our filters and verify that the filters work. We also hardcoded
    voting statistics for the last two senators so we can have a predictable count
    while looking for senators who voted only `Yes` or only `No` for each of the ten
    issues. And we added the `timesVotedYes()` method, which provides the count of
    how many times the given `senator` voted `Yes`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为前五位参议员硬编码了统计数据，以便在测试过滤器时获得可预测的结果，并验证过滤器是否工作。我们还为最后两位参议员硬编码了投票统计数据，以便在寻找只对十个问题中的每一个投了`是`或只投了`否`的参议员时，有一个可预测的计数。我们还添加了`timesVotedYes()`方法，它提供了给定`senator`投`是`的次数。
- en: 'Now we can collect some data from the `Senate` class. For example, let''s see
    how many members of each party comprise the `Senate` class:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从`Senate`类中收集一些数据。例如，让我们看看每个党派的成员在`Senate`类中占多少比例：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The result of the preceding code differs from run to run because of the random
    value generator we used in the `Senate` class, so do not expect to see exactly
    the same numbers if you try to run the examples. What is important is that the
    total of the two party members should be equal 100--the total number of the senators
    in the `Senate` class:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的结果因我们在`Senate`类中使用的随机值生成器而有所不同，因此不要期望在尝试运行示例时看到完全相同的数字。重要的是两个党派成员的总数应该等于100--`Senate`类中参议员的总数：
- en: '![Basic Filtering](img/05_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![基本过滤](img/05_01.jpg)'
- en: The expression `s -> s.getParty()=="Party1"` is the predicate that filters out
    only those senators who are members of `Party1`. So, the elements (`Senator` objects)
    of `Party2` do not get through and are not included in the count. That was pretty
    straightforward.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`s -> s.getParty()=="Party1"`是过滤条件，只过滤出属于`Party1`的参议员。因此，`Party2`的元素（`Senator`对象）无法通过，并且不计入总数。这相当直接。
- en: 'Now let''s look at a more complex example of filtering. Let''s count how many
    senators of each party voted on `issue 3`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个更复杂的过滤示例。让我们计算每个党派的参议员在`issue 3`上投票的人数：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For `Party1`, we used two filters. For `Party2`, we combined them just to show
    another possible solution. The important point here is to use the filter by a
    party (`s -> s.getParty() == "Party1"`) first before the filter that selects only
    those who voted. This way, the second filter is used only for approximately half
    of the elements. Otherwise, if the filter that selects only those who voted were
    placed first, it would be applied to all 100 of `Senate` members.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Party1`，我们使用了两个过滤器。对于`Party2`，我们将它们结合起来，只是为了展示另一种可能的解决方案。这里的重要点是首先使用按党派过滤（`s
    -> s.getParty() == "Party1"`），然后再使用只选择那些投票的人的过滤器。这样，第二个过滤器只应用于大约一半的元素。否则，如果将只选择那些投票的人的过滤器放在第一位，它将应用于所有的100个`Senate`成员。
- en: 'The result looks like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来像这样：
- en: '![Basic Filtering](img/05_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![基本过滤](img/05_02.jpg)'
- en: 'Similarly, we can calculate how many members of each party voted `Yes` on `issue
    3`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以计算每个党派有多少成员在`issue 3`上投了`是`：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The result of the preceding code is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的结果如下：
- en: '![Basic Filtering](img/05_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![基本过滤](img/05_03.jpg)'
- en: 'We can refactor the preceding examples by taking advantage of the Java functional
    programming capability (using lambda expressions) and creating the `countAndPrint()`
    method:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过利用Java函数式编程能力（使用lambda表达式）对前述示例进行重构，并创建`countAndPrint()`方法：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now all the earlier code can be expressed in a more compact way:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有之前的代码都可以用更紧凑的方式表达：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We created four predicates, `party1`, `party2`, `voted3`, and `yes3`, and we
    used each of them several times as parameters of the `countAndPrint()` method.
    The output of this code is the same as that of the earlier examples:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了四个谓词，`party1`、`party2`、`voted3`和`yes3`，并将它们中的每一个作为`countAndPrint()`方法的参数使用了几次。此代码的输出与先前的示例相同：
- en: '![Basic Filtering](img/05_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![基本过滤](img/05_04.jpg)'
- en: Using the `filter()` method of the `Stream` interface is the most popular way
    of filtering. But it is possible to use other `Stream` methods to accomplish the
    same effect.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Stream`接口的`filter()`方法是过滤的最流行方式。但也可以使用其他`Stream`方法来达到相同的效果。
- en: Using Other Stream Operations for Filtering
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用其他流操作进行过滤
- en: Alternatively, or in addition to the basic filtering described in the previous
    section, other operations (methods of the `Stream` interface) can be used for
    selection and filtering emitted stream elements.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，除了上一节中描述的基本过滤之外，还可以使用其他操作（`Stream`接口的方法）来进行选择和过滤发出的流元素。
- en: 'For example, let''s use the `flatMap()` method to filter out the members of
    the Senate by their party membership:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们使用`flatMap()`方法过滤掉参议院的成员，根据他们的党派成员资格：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This method takes advantage of the `Stream.of()` (produces a stream of one
    element) and `Stream.empty()`factory methods (it produces a stream without elements,
    so nothing is emitted further downstream). Alternatively, the same effect can
    be achieved using a new factory method (introduced in Java 9) called `Stream.ofNullable()`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法利用了`Stream.of()`（产生一个元素的流）和`Stream.empty()`工厂方法（它产生一个没有元素的流，因此不会进一步发出任何内容）。或者，可以使用在Java
    9中引入的新工厂方法`Stream.ofNullable()`达到相同的效果。
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `Stream.ofNullable()` method creates a stream of one element if not `null`;
    otherwise, it creates an empty stream, as in the previous example. Both the preceding
    code snippets--produce the same output if we run them for the same senate composition:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream.ofNullable()`方法在非`null`的情况下创建一个包含一个元素的流；否则，它创建一个空流，就像之前的例子一样。如果我们以相同的参议院组成运行这两个先前的代码片段，它们会产生相同的输出：'
- en: '![Using Other Stream Operations for Filtering](img/05_05.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_05.jpg)'
- en: 'However, the same result can be achieved using a `java.uti.Optional` class
    that may or may not contain a value. If a value is present (and not `null`), its
    `isPresent()` method returns `true` and the `get()` method returns the value.
    Here is how we can use it to filter out the members of one party:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可以使用可能包含或不包含值的`java.util.Optional`类来达到相同的结果。如果存在值（且不是`null`），则其`isPresent()`方法返回`true`，而`get()`方法返回该值。以下是如何使用它来过滤掉一个党派的成员：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'First, we map (transform) an element (the `Senator` object) to an `Optional`
    object with or without the value. Next, we use the `flatMap()` method to either
    generate a stream of a single element or else an empty stream, and then we count
    the elements that made it through. In Java 9, the `Optional` class acquired a
    new factory `stream()` method that produces a stream of one element if the `Optional`
    object carries a non-null value; otherwise, it produces an empty stream. Using
    this new method, we can rewrite the previous code as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将一个元素（`Senator`对象）映射（转换）为一个带有或不带有值的`Optional`对象。然后，我们使用`flatMap()`方法生成一个包含单个元素的流或空流，然后计算通过这些元素的个数。在Java
    9中，`Optional`类获得了一个新的工厂方法`stream()`，如果`Optional`对象包含非空值，则它产生一个包含一个元素的流；否则，它产生一个空流。使用这个新方法，我们可以将之前的代码重写如下：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Both the previous examples produce the same output if we run them for the same
    senate composition:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以相同的参议院组成运行这两个先前的示例，它们会产生相同的输出：
- en: '![Using Other Stream Operations for Filtering](img/05_06.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_06.jpg)'
- en: 'We can apply another kind of filtering when we need to capture the first element
    emitted by the stream. This means that we terminate the stream after the first
    element is emitted. For example, let''s find the first senator of `Party1`who
    voted `Yes` on `issue 3`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要捕获流中发出的第一个元素时，我们可以应用另一种类型的过滤。这意味着我们在第一个元素发出后终止流。例如，让我们找到在`issue 3`上投票`Yes`的`Party1`的第一个参议员：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![Using Other Stream Operations for Filtering](img/05_07.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_07.jpg)'
- en: This was exactly what we expected when we seeded data in the `Senate` class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们在`Senate`类中播种数据时预期的结果。
- en: 'Similarly, we can use the `findAny()` method to find any `senator` who voted
    `Yes` on `issue 3`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用`findAny()`方法来找出在`issue 3`上投了`Yes`票的任何参议员：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result is also as we expected:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 结果也正如预期的那样：
- en: '![Using Other Stream Operations for Filtering](img/05_08.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_08.jpg)'
- en: It is typically (but not necessarily) the first element of the stream. But one
    should not rely on this assumption, especially in the case of parallel processing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是（但不一定是）流中的第一个元素。但不应依赖于这个假设，尤其是在并行处理的情况下。
- en: 'The `Stream` interface also has three `match` methods that, although they return
    a Boolean value, can be used for filtering too if the specific object is not required
    and we only need to establish the fact that such an object exists or not. The
    names of these methods are `anyMatch()`, `allMatch()`, and `noneMatch()`. Each
    of them takes a predicate and returns a Boolean. Let''s start by demonstrating
    the `anyMatch()` method. We will use it to find out if there is at least one `senator`
    of `Party1` who voted `Yes` on `issue 3`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream`接口也有三个`match`方法，尽管它们返回一个布尔值，但如果不需要特定的对象，我们只需要确定这样的对象是否存在，也可以用于过滤。这些方法的名称是`anyMatch()`、`allMatch()`和`noneMatch()`。每个方法都接受一个谓词并返回一个布尔值。让我们首先演示`anyMatch()`方法。我们将使用它来找出是否有至少一位`Party1`的参议员在`issue
    3`上投了`Yes`票：'
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The result of running the previous code should look like the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前一段代码的结果应该如下所示：
- en: '![Using Other Stream Operations for Filtering](img/05_09.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_09.jpg)'
- en: 'To demonstrate the `allMatch()` method, we will use it to find out if all the
    members of `Party1` in the `Senate` class have voted `Yes` on `issue 3`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`allMatch()`方法，我们将使用它来找出`Senate`类中`Party1`的所有成员是否都在`issue 3`上投了`Yes`票：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The result of the previous code may look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前一段代码的结果可能如下所示：
- en: '![Using Other Stream Operations for Filtering](img/05_10.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_10.jpg)'
- en: 'And the last of the three `match` methods--the `noneMatch()` method--will be
    used to figure out if some senators of `Party1` have voted `Yes` on `issue 3`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 三种`match`方法中的最后一种——`noneMatch()`方法——将用于确定`Party1`中的某些参议员是否在`issue 3`上投了`Yes`票：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The result of the earlier example is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 早期示例的结果如下所示：
- en: '![Using Other Stream Operations for Filtering](img/05_11.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_11.jpg)'
- en: However, in real life, it could be very different because quite a few issues
    in the `Senate` class are voted for along party lines.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在现实生活中，情况可能非常不同，因为`Senate`类中的许多问题都是按党派投票的。
- en: 'Yet another type of filtering is required when we need to skip all the duplicate
    elements in a stream and select only unique ones. The `distinct()` method is designed
    for the purpose. We will use it to find the names of the parties that have their
    members in the `Senate` class:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要跳过流中的所有重复元素并仅选择唯一元素时，就需要另一种类型的过滤。`distinct()`方法就是为了这个目的设计的。我们将使用它来找出在`Senate`类中有成员的党派的名称：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The result, as expected, is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，正如预期的那样，如下所示：
- en: '![Using Other Stream Operations for Filtering](img/05_12.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_12.jpg)'
- en: Well, no surprise there?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这并不令人惊讶？
- en: 'We can also filter out all the elements of the `stream` except the certain
    count of the first ones, using the `limit()` method:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`limit()`方法过滤掉`stream`中的所有元素，除了前几个特定的数量：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you remember how we have set up the first five senators in the list, you
    could predict that the result will be as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得我们是如何设置列表中的前五位参议员的，你可以预测结果如下所示：
- en: '![Using Other Stream Operations for Filtering](img/05_13.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_13.jpg)'
- en: 'Now let''s find only one element in a stream--the biggest one. To do this,
    we can use the `max()` method of the `Stream` interface and the `Senate.timeVotedYes()`
    method (we will apply it on each senator):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在流中找到唯一的一个元素——最大的一个。为此，我们可以使用`Stream`接口的`max()`方法和`Senate.timeVotedYes()`方法（我们将对每位参议员应用它）：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![Using Other Stream Operations for Filtering](img/05_14.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_14.jpg)'
- en: Yes, we got `Senator100` filtered as the one who voted `Yes` on all 10 issues.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们已经将`Senator100`过滤为在所有10个问题上都投了`Yes`票的人。
- en: 'Similarly, we can find the senator who voted `No` on all 10 issues:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以找到在所有10个问题上都投了`No`票的参议员：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We expect it to be `Senator99`, and here is the result:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预计结果将是`Senator99`，以下是结果：
- en: '![Using Other Stream Operations for Filtering](img/05_15.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_15.jpg)'
- en: That's why we hardcoded several stats in the `Senate` class, so we can verify
    that our queries work correctly.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在`Senate`类中硬编码了几个统计信息，以便我们可以验证我们的查询是否正确工作。
- en: 'As the last two methods can help us with filtering, we will demonstrate the
    `takeWhile()` and `dropWhile()`methods introduced in JDK 9\. We will first print
    the data of all the first five senators and then use the `takeWhile()`method to
    print the first senators until we encounter the one who voted `Yes` more than
    four times, and then stop printing:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前两种方法可以帮助我们进行过滤，我们将演示JDK 9中引入的`takeWhile()`和`dropWhile()`方法。我们首先将打印前五位参议员的数据，然后使用`takeWhile()`方法打印直到我们遇到投票`Yes`超过四次的第一位参议员，然后停止打印：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The result for the previous code is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的结果如下：
- en: '![Using Other Stream Operations for Filtering](img/05_16.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_16.jpg)'
- en: 'The `dropWhile()` method can be used for the opposite effect, that is, to filter
    away, to skip the first senators until we encounter the one who voted `Yes` more
    than four times, then continue printing all the rest of the senators:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`dropWhile()`方法可以用于相反的效果，即过滤掉，跳过直到我们遇到投票`Yes`超过四次的第一位参议员，然后继续打印所有其他参议员：'
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The result will be as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![Using Other Stream Operations for Filtering](img/05_17.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_17.jpg)'
- en: This concludes our demonstration of the ways in which a stream of elements can
    be filtered. We hope you have learned enough to be able to find a solution for
    any of your filtering needs. Nevertheless, we encourage you to study and experiment
    with the Stream API on your own, so you can retain what you have learned so far
    and acquire your own view on the rich APIs of Java 9.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对元素流过滤方式的演示。我们希望你已经学到了足够的知识，能够为你的任何过滤需求找到解决方案。尽管如此，我们鼓励你自己学习和实验Stream
    API，这样你可以保留到目前为止所学到的知识，并形成自己对Java 9丰富API的个人看法。
- en: Stack-Walking APIs
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈跟踪API
- en: Exceptions do happen, especially during development or the period of software
    stabilization. But in a big complex system, the chance of getting an exception
    is possible even in production, especially when several third-party systems are
    brought together and the need arises to analyze the stack trace programmatically
    in order to apply an automatic correction. In this section, we will discuss how
    it can be done.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 异常确实会发生，尤其是在开发期间或软件稳定期。但在一个大型复杂系统中，即使在生产环境中，出现异常的可能性也是可能的，尤其是在将多个第三方系统组合在一起并需要程序化分析堆栈跟踪以应用自动纠正时。在本节中，我们将讨论如何实现这一点。
- en: Stack Analysis before Java 9
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 9之前的堆栈分析
- en: 'The traditional reading of the stack trace, using objects of the `java.lang.Thread`
    and `java.lang.Throwable`classes, was accomplished by capturing it from the standard
    output. For example, we can include this line in any section of the code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`java.lang.Thread`和`java.lang.Throwable`类的对象的传统读取堆栈跟踪是通过从标准输出捕获来完成的。例如，我们可以在代码的任何部分包含以下行：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The previous line will produce the following output:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行将产生以下输出：
- en: '![Stack Analysis before Java 9](img/05_18.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Java 9之前的堆栈分析](img/05_18.jpg)'
- en: 'Similarly, we can include this line in the code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以在代码中包含以下行：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output will then look like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Stack Analysis before Java 9](img/05_19.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![Java 9之前的堆栈分析](img/05_19.jpg)'
- en: This output can be captured, read, and analyzed programmatically, but requires
    quite a bit of custom code writing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种输出可以被捕获、读取和分析，但需要编写相当多的自定义代码。
- en: 'JDK 8 made this easier via the usage of streams. Here is the code that allows
    reading the stack trace from the stream:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 8通过使用流使这一过程变得简单。以下是从流中读取堆栈跟踪的代码：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The previous line produces the following output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行将产生以下输出：
- en: '![Stack Analysis before Java 9](img/05_20.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![Java 9之前的堆栈分析](img/05_20.jpg)'
- en: 'Alternatively, we could use this code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用以下代码：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output of the previous code shows the stack trace in a similar way:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的输出以类似的方式显示了堆栈跟踪：
- en: '![Stack Analysis before Java 9](img/05_21.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Java 9之前的堆栈分析](img/05_21.jpg)'
- en: 'If, for example, you would like to find the fully qualified name of the caller
    class, you can use one of these approaches:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想找到调用者的完全限定名称，你可以使用以下方法之一：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Such coding is possible because the `getStackTrace()` method returns an array
    of objects of the `java.lang.StackTraceElement` class, each representing a stack
    frame in a stack trace. Each object carries stack trace information accessible
    by the `getFileName()`, `getClassName()`, `getMethodName()`, and `getLineNumber()`
    methods.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的编码是可能的，因为`getStackTrace()`方法返回一个`java.lang.StackTraceElement`类的对象数组，每个对象代表堆栈跟踪中的一个堆栈帧。每个对象都携带可通过`getFileName()`、`getClassName()`、`getMethodName()`和`getLineNumber()`方法访问的堆栈跟踪信息。
- en: 'To demonstrate how it works, we have created three classes, `Clazz01`, `Clazz02`,
    and `Clazz03`, that call each other:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示它是如何工作的，我们创建了三个类，`Clazz01`、`Clazz02`和`Clazz03`，它们相互调用：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let''s call the `method()` method of `Clazz01`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们调用`Clazz01`的`method()`方法：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here are two (the second and the third) of the six stack trace frames printed
    out by the preceding code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是前述代码打印出的六个堆栈跟踪帧中的两个（第二个和第三个）：
- en: '![Stack Analysis before Java 9](img/05_22.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![Java 9之前的堆栈分析](img/05_22.jpg)'
- en: In principle, every called class has access to this information. But to find
    out which class called the current class may not be so easy because you need to
    figure out which frame represents the caller. Also, in order to provide this info,
    JVM captures the entire stack (except for the hidden stack frames), and it may
    affect performance.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在原则上，每个被调用类都可以访问这些信息。但要找出哪个类调用了当前类可能并不容易，因为你需要确定哪个帧代表调用者。此外，为了提供这些信息，JVM捕获整个堆栈（除了隐藏的堆栈帧），这可能会影响性能。
- en: That was the motivation for introducing the `java.lang.StackWalker` class, its
    nested `Option` class, and the `StackWalker.StackFrame` interface in JDK 9.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是引入`java.lang.StackWalker`类、其嵌套的`Option`类和`StackWalker.StackFrame`接口在JDK 9中的动机。
- en: New Better Way to Walk the Stack
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的更好的堆栈遍历方式
- en: 'The `StackWalker` class has four `getInstance()` static factory methods:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackWalker`类有四个`getInstance()`静态工厂方法：'
- en: '`getInstance()`: This returns a `StackWalker` class instance configured to
    skip all hidden frames and the caller class reference'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getInstance()`: 这返回一个配置为跳过所有隐藏帧和调用者类引用的`StackWalker`类实例'
- en: '`getInstance(StackWalker.Option option)`: This creates a `StackWalker` class
    instance with the given option specifying the stack frame information it can access'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getInstance(StackWalker.Option option)`: 这创建一个具有给定选项的`StackWalker`类实例，指定它可以访问的堆栈帧信息'
- en: '`getInstance(Set<StackWalker.Option> options)`: This creates a `StackWalker`
    class instance with the given set of options'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getInstance(Set<StackWalker.Option> options)`: 这创建一个具有给定选项集的`StackWalker`类实例'
- en: '`getInstance(Set<StackWalker.Option> options, int estimatedDepth)`: This allows
    you to pass in the `estimatedDepth` parameter that specifies the estimated number
    of stack frames this instance will traverse so that the Java machine can allocate
    the appropriate buffer size it might need'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getInstance(Set<StackWalker.Option> options, int estimatedDepth)`: 这允许你传入`estimatedDepth`参数，该参数指定此实例将要遍历的堆栈帧的估计数量，以便Java机器可以分配它可能需要的适当缓冲区大小'
- en: 'The value passed as an option can be one of the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 作为选项传入的值可以是以下之一：
- en: '`StackWalker.Option.RETAIN_CLASS_REFERENCE`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackWalker.Option.RETAIN_CLASS_REFERENCE`'
- en: '`StackWalker.Option.SHOW_HIDDEN_FRAMES`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackWalker.Option.SHOW_HIDDEN_FRAMES`'
- en: '`StackWalker.Option.SHOW_REFLECT_FRAMES`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackWalker.Option.SHOW_REFLECT_FRAMES`'
- en: 'The other three methods of the `StackWalker` class are as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackWalker`类的其他三个方法如下：'
- en: '`T walk(Function<Stream<StackWalker.StackFrame>, T> function)`: This applies
    the passed in function to the stream of stack frames, the first frame representing
    the method that called this `walk()` method'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T walk(Function<Stream<StackWalker.StackFrame>, T> function)`: 这将传入的函数应用于堆栈帧流，第一个帧表示调用此`walk()`方法的调用方法'
- en: '`void forEach(Consumer<StackWalker.StackFrame> action)`: This performs the
    passed in action on each element (of the `StalkWalker.StackFrame` interface type)
    of the stream of the current thread'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void forEach(Consumer<StackWalker.StackFrame> action)`: 这对当前线程流中的每个元素（`StalkWalker.StackFrame`接口类型）执行传入的操作'
- en: '`Class<?> getCallerClass()`: This gets objects of the `Class` class of the
    caller class'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Class<?> getCallerClass()`: 这获取调用者类的`Class`类对象'
- en: 'As you can see, it allows much more straightforward stack trace analysis. Let''s
    modify our demo classes using the following code and access the caller name in
    one line:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它允许更直接的堆栈跟踪分析。让我们使用以下代码修改我们的演示类，并在一行中访问调用者名称：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The previous code will produce this output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将产生以下输出：
- en: '![New Better Way to Walk the Stack](img/05_23.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![新的更好的堆栈遍历方式](img/05_23.jpg)'
- en: 'You can appreciate the simplicity of the solution. If we need to see the entire
    stack trace, we can add the following line to the code in `Clazz03`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以欣赏这个解决方案的简单性。如果我们需要查看整个堆栈跟踪，我们可以在`Clazz03`中的代码中添加以下行：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The resulting output will be as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的输出将如下所示：
- en: '![New Better Way to Walk the Stack](img/05_24.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![新的更好的栈遍历方法](img/05_24.jpg)'
- en: 'Again, with only one line of code, we have achieved much more readable output.
    We could achieve the same result by using the `walk()` method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，仅用一行代码，我们就得到了更易读的输出。我们可以通过使用`walk()`方法达到相同的结果：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Instead of just printing `StackWalker.StackFrame`, we also could run a deeper
    analysis on it, if need be, using its API, which is more extensive than the API
    of `java.lang.StackTraceElement`. Let''s run the code example that prints every
    stack frame and its information:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅打印`StackWalker.StackFrame`，如果需要的话，还可以使用其API进行更深入的分析，该API比`java.lang.StackTraceElement`的API更广泛。让我们运行打印每个堆栈帧及其信息的代码示例：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output of the previous code is as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的输出如下：
- en: '![New Better Way to Walk the Stack](img/05_25.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![新的更好的栈遍历方法](img/05_25.jpg)'
- en: Note the `StackFrameInfo` class that implements the `StackWalker.StackFrame`
    interface and actually does the job. The API also allows converting back to the
    familiar `StackTraceElement` object for backward compatibility and for the enjoyment
    of those who are used to it and do not want to change their code and habits.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意实现`StackWalker.StackFrame`接口并实际执行工作的`StackFrameInfo`类。API还允许将它们转换回熟悉的`StackTraceElement`对象，以实现向后兼容性，以及让那些习惯于它且不想改变他们的代码和习惯的人感到愉快。
- en: In contrast, with the full stack trace generated and stored in the array in
    the memory (like in the case of the traditional stack trace implementation), the
    `StackWalker` class brings only the requested elements. This is another motivation
    for its introduction in addition to the demonstrated simplicity of use. More details
    about the `StackWalker` class API and its usage can be found at [https://docs.oracle.com/javase/9/docs/api/java/lang/StackWalker.html](https://docs.oracle.com/javase/9/docs/api/java/lang/StackWalker.html).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在内存中生成并存储完整的堆栈跟踪（如传统堆栈跟踪实现的情况），`StackWalker`类只带来了请求的元素。这是其引入的另一个动机，除了演示的使用简单性之外。有关`StackWalker`类API及其使用的更多详细信息，请参阅[https://docs.oracle.com/javase/9/docs/api/java/lang/StackWalker.html](https://docs.oracle.com/javase/9/docs/api/java/lang/StackWalker.html)。
- en: Convenience Factory Methods for Collections
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合的便利工厂方法
- en: 'With the introduction of functional programming in Java, the interest in and
    need for immutable objects increased. The functions passed into the methods may
    be executed in substantially different contexts than the one they were created
    in, so the need to decrease the chances of unexpected side effects made the case
    for immutability stronger. Besides, the Java way of creating an unmodifiable collection
    was quite verbose anyway, so the issue was addressed in Java 9\. Here is an example
    of the code that creates an immutable collection of the `Set` interface in Java
    8:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Java中函数式编程的引入，对不可变对象的需求增加。传递给方法的功能可能在与它们创建时显著不同的上下文中执行，因此减少意外副作用的可能性使得不可变性更有说服力。此外，Java创建不可修改集合的方式本身就相当冗长，因此这个问题在Java
    9中得到了解决。以下是一个在Java 8中创建不可变`Set`接口集合的代码示例：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After one does it several times, the need for a convenience method comes up
    naturally as the basic refactoring consideration that always lingers in the background
    thinking of any software professional. In Java 8, the previous code could be changed
    to the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在多次执行之后，方便方法的必要性自然地作为任何软件专业人士背景思维中始终存在的重构考虑因素而出现。在Java 8中，之前的代码可以修改为以下形式：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Alternatively, if streams are your friends, you could write the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你是流的朋友，你可以写如下代码：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Another version of the previous code is as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的另一个版本如下：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'However, it has more boilerplate code than the values you are trying to encapsulate.
    So, in Java 9, a shorter version of the previous code became possible:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它比你要封装的值有更多的样板代码。因此，在Java 9中，之前代码的简短版本成为可能：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Similar factories were introduced to generate immutable collections of `List`
    interfaces and `Map` interfaces:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的生产厂被引入来生成不可变的`List`接口和`Map`接口的集合：
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Why New Factory Methods?
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么需要新的工厂方法？
- en: 'The ability to express the same functionality in more compact manner is very
    helpful, but it would probably not be enough motivation to introduce these new
    factories. It was much more important to address the weakness of the existing
    implementation of `Collections.unmodifiableList()`, `Collections.unmodifiableSet()`,
    and `Collections.unmodifiableMap()`. Although the collections created using these
    methods throw an `UnsupportedOperationException` class when you try to modify
    or add/remove their elements, they are just wrappers around the traditional modifiable
    collections and can thus be susceptible to modifications, depending on the way
    you construct them. Let''s walk through examples to illustrate the point. By the
    way, another weakness of the existing unmodifiable implementation is that it does
    not change how the source collection is constructed, so the difference between
    `List`, `Set`, and `Map`--the ways in which they can be constructed--remains in
    place, which may be a source of bugs or even frustration when a programmer uses
    them. The new factory methods address this issue too, providing a more unified
    approach using the `of()` factory method (and the additional `ofEntries()` method
    for `Map`) only. Having said that, let''s get back to the examples. Look at the
    following code snippet:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 能够以更紧凑的方式表达相同的功能非常有帮助，但这可能不足以成为引入这些新工厂的动机。更重要的是解决`Collections.unmodifiableList()`、`Collections.unmodifiableSet()`和`Collections.unmodifiableMap()`现有实现的弱点。尽管使用这些方法创建的集合在尝试修改或添加/删除其元素时将抛出`UnsupportedOperationException`异常，但它们只是传统可修改集合的包装，因此可能容易受到修改的影响，这取决于它们的构建方式。让我们通过示例来阐述这一点。顺便说一下，现有不可修改实现的另一个弱点是它不会改变源集合的构建方式，因此`List`、`Set`和`Map`之间的差异——它们可以构建的方式——仍然存在，这可能是程序员使用它们时出现错误或甚至挫败感的来源。新的工厂方法也解决了这个问题，通过仅使用`of()`工厂方法（以及为`Map`提供的附加`ofEntries()`方法）提供了一种更统一的方法。话虽如此，让我们回到示例。看看以下代码片段：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Attempts of direct modification of the elements of `unmodifiableList1` lead
    to `UnsupportedOperationException`. Nevertheless, we can modify them via the underlying
    `list` object. If we run the previous example, the output will be as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 直接修改`unmodifiableList1`的元素将导致`UnsupportedOperationException`异常。尽管如此，我们可以通过底层的`list`对象来修改它们。如果我们运行前面的示例，输出将如下所示：
- en: '![Why New Factory Methods?](img/05_26.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![为什么需要新的工厂方法？](img/05_26.jpg)'
- en: 'Even if we use `Arrays.asList()` for the source list creation, it will only
    protect the created collection from adding a new element, but not from modifying
    the existing one. Here is a code example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用`Arrays.asList()`来创建源列表，它也只会保护创建的集合不被添加新元素，但不会阻止修改现有元素。以下是一个代码示例：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we run the previous code, the output will be as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，输出将如下所示：
- en: '![Why New Factory Methods?](img/05_27.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![为什么需要新的工厂方法？](img/05_27.jpg)'
- en: We also included a `null` element to demonstrate how the existing implementation
    treats them, because, by contrast, the new factories of immutable collections
    do not allow `null` to be included. By the way, they do not allow duplicate elements
    in `Set` either (while the existing implementation just ignores them), but we
    will demonstrate this aspect later while using the new factory methods in code
    examples.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个`null`元素来展示现有实现如何处理它们，因为相比之下，新的不可变集合工厂不允许包含`null`。顺便说一下，它们也不允许在`Set`中包含重复元素（而现有实现只是忽略它们），但我们将稍后在代码示例中使用新的工厂方法来展示这一点。
- en: 'To be fair, there is a way to create a truly immutable collection of `List`
    interfaces with the existing implementation too. Look at the following code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 公平起见，使用现有实现也可以创建一个真正的不可变`List`接口集合。看看以下代码：
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Another way to create an immutable list is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 创建不可变列表的另一种方法如下：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following is a variation of the earlier code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码的变体：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If we run the previous three examples, we will see the following output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的三个示例，我们将看到以下输出：
- en: '![Why New Factory Methods?](img/05_28.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![为什么需要新的工厂方法？](img/05_28.jpg)'
- en: Note that although we cannot modify the content of these lists, we can put `null`
    in them.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管我们无法修改这些列表的内容，但我们可以在其中放置`null`。
- en: 'The situation with `Set` is quite similar to what we have seen with the lists
    earlier. Here is the code that shows how an unmodifiable collection of `Set` interfaces
    can be modified:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`的情况与之前看到的列表非常相似。以下是展示如何修改不可修改的`Set`接口集合的代码：'
- en: '[PRE46]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The resulting collection of `Set` interfaces can be modified even if we convert
    the original collection from an array to a list and then to a set, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们将原始集合从数组转换为列表，然后再转换为集合，`Set` 接口的集合仍然可以被修改，如下所示：
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here is the output of running the previous two examples:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前两个示例的输出如下：
- en: '![Why New Factory Methods?](img/05_29.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![为什么需要新的工厂方法？](img/05_29.jpg)'
- en: If you have not worked with sets in Java 9, you may be surprised to see the
    unusually messed up order of the set elements in the output. In fact, it is another
    new feature of set and maps introduced in JDK 9\. In the past, `Set` and `Map`
    implementations did not guarantee to preserve the elements' order. But more often
    than not, the order was preserved and some programmers wrote code that relied
    on it, thus introducing an annoyingly inconsistent and not easily reproducible
    defect into an application. The new `Set` and `Map` implementations change the
    order more often, if not at every new run of the code. This way, it exposes potential
    defects early in development and decreases the chance of its propagation into
    production.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在 Java 9 中使用过集合，你可能会对输出中集合元素的不寻常混乱顺序感到惊讶。实际上，这是 JDK 9 中引入的集合和映射的新特性之一。在过去，`Set`
    和 `Map` 的实现并没有保证保留元素的顺序。但通常情况下，顺序是保留的，一些程序员编写了依赖于它的代码，从而将一个令人烦恼的不一致且难以复现的缺陷引入了应用程序。新的
    `Set` 和 `Map` 实现更频繁地改变顺序，如果不是每次代码的新运行。这样，它可以在开发早期暴露潜在缺陷，并减少其传播到生产环境的机会。
- en: 'Similar to the lists, we can create immutable sets even without using Java
    9''s new immutable set factory. One way to do it is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表类似，即使不使用 Java 9 的新不可变集合工厂，我们也可以创建不可变集合。一种实现方式如下：
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Also, as in the case with lists, here is another way to do it:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与列表的情况类似，这里还有另一种实现方式：
- en: '[PRE49]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Another variant of the previous code is as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的另一种变体如下：
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If we run all three examples of creating an immutable collection of `iSet`
    interfaces that we have just introduced, the result would be as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行我们刚刚介绍的创建不可变 `iSet` 接口集合的三个示例，结果如下：
- en: '![Why New Factory Methods?](img/05_30.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![为什么需要新的工厂方法？](img/05_30.jpg)'
- en: 'With `Map` interfaces, we were able to come up with only one way to modify
    the `unmodifiableMap` object:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Map` 接口，我们只能找到一种修改 `unmodifiableMap` 对象的方法：
- en: '[PRE51]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output of the previous code is as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的输出如下：
- en: '![Why New Factory Methods?](img/05_31.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![为什么需要新的工厂方法？](img/05_31.jpg)'
- en: 'We found four ways to create an immutable collection of `Map` interfaces without
    using Java 9 enhancements. Here is the first example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了四种不使用 Java 9 增强功能创建不可变 `Map` 接口集合的方法。以下是第一个示例：
- en: '[PRE52]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The second example has a bit of a complication:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例有点复杂：
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'A variant of the previous code is as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的另一种变体如下：
- en: '[PRE56]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'After we run all the four last examples, the output is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行完所有四个最后示例之后，输出如下：
- en: '![Why New Factory Methods?](img/05_32.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![为什么需要新的工厂方法？](img/05_32.jpg)'
- en: With that revision of the existing collections implementations, we can now discuss
    and appreciate the new factory methods of collections in Java 9.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在对现有的集合实现进行修订之后，我们现在可以讨论和欣赏 Java 9 中集合的新工厂方法。
- en: The New Factory Methods in Action
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新工厂方法的应用
- en: 'After revisiting the existing methods of collection creation, we can now review
    and enjoy the related API introduced in Java 9\. As in a previous section, we
    start with the `List` interface. Here is how simple and consistent the immutable
    list creation can be using the new `List.of()` factory method:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在回顾了现有的集合创建方法之后，我们现在可以回顾并享受 Java 9 中引入的相关 API。与前面的章节一样，我们从 `List` 接口开始。以下是使用新的
    `List.of()` 工厂方法创建不可变列表的简单和一致的方式：
- en: '[PRE57]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As you can see from the previous code comments, the new factory method does
    not allow including `null` as the list value.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码注释所示，新的工厂方法不允许将 `null` 包含在列表值中。
- en: 'The `immutableSet` creation looks similar to this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`immutableSet` 的创建看起来如下：'
- en: '[PRE58]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see from the previous code comments, the `Set.of()` factory method
    does not allow adding `null` or a duplicate element when creating an immutable
    collection of `Set` interfaces.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码注释所示，`Set.of()` 工厂方法在创建不可变 `Set` 接口集合时不允许添加 `null` 或重复的元素。
- en: 'The immutable collection of `Map` interfaces has similar format too:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map` 接口的不可变集合也有类似的格式：'
- en: '[PRE59]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `Map.of()` method does not allow `null` as a value either. Another feature
    of the `Map.of()` method is that it allows a compile-time check of the element
    type, which decreases the chances of a runtime problem.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map.of()`方法也不允许`null`作为值。`Map.of()`方法的另一个特性是它允许在编译时检查元素类型，这减少了运行时问题的可能性。'
- en: 'For those who prefer more compact code, here is another way to express the
    same functionality:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些喜欢更紧凑代码的人来说，这里有另一种表达相同功能的方法：
- en: '[PRE60]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And here is the output if we run all the previous examples of the usage of
    the new factory methods:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行所有之前使用新工厂方法的示例，以下是输出结果：
- en: '![The New Factory Methods in Action](img/05_33.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![新工厂方法在实际中的应用](img/05_33.jpg)'
- en: 'As we mentioned already, the ability to have immutable collections, including
    empty ones, is very helpful for functional programming as this feature makes sure
    that such a collection cannot be modified as a side effect and cannot introduce
    unexpected and difficult to trace defects. The full variety of the new factories
    methods includes up to 10 explicit entries plus one with an arbitrary number of
    elements. Here''s how it looks for `List` interface:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，拥有不可变集合的能力，包括空集合，对于函数式编程非常有帮助，因为这个特性确保了这样的集合不能作为副作用被修改，并且不会引入意外且难以追踪的缺陷。新的工厂方法包括多达10个显式条目，以及一个可以包含任意数量元素的条目。以下是`List`接口的示例：
- en: '[PRE61]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `Set` factory methods look similar:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`的工厂方法看起来类似：'
- en: '[PRE62]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Also, the `Map` factory methods follow suit:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Map`的工厂方法也遵循同样的模式：
- en: '[PRE63]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The decision not to add new interfaces for immutable collections left them susceptible
    to causing occasional confusion when programmers assumed they could call `add()`
    or `put()` on them. Such an assumption, if not tested, will cause a runtime error
    that throws an `UnsupportedOperationException`. Despite this potential pitfall,
    the new factory methods for immutable collection creation are very useful additions
    to Java.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 决定不添加新的不可变集合接口，使得它们容易在程序员假设可以调用`add()`或`put()`时造成偶尔的混淆。这种假设如果没有经过测试，将导致运行时错误，抛出`UnsupportedOperationException`。尽管存在这种潜在的风险，但新的不可变集合创建工厂方法仍然是Java中非常有用的补充。
- en: CompletableFuture in Support of Asynchronous Processing
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持异步处理的CompletableFuture
- en: The `java.util.concurrent.CompletableFuture<T>` class was first introduced in
    Java 8\. It is the next level of asynchronous call control over `java.util.concurrent.Future<T>`
    interface. It actually implements `Future`, as well as `java.util.concurrent.CompletionStage<T>`.
    In Java 9, `CompletableFuture` was enhanced by adding new factory methods, support
    for delays and timeouts, and improved subclassing--we will discuss these features
    in more details in the sections to follow. But first, let's have an overview of
    the `CompletableFuture` API.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.CompletableFuture<T>`类首次在Java 8中引入。它是`java.util.concurrent.Future<T>`接口异步调用控制的下一级。它实际上实现了`Future`，以及`java.util.concurrent.CompletionStage<T>`。在Java
    9中，`CompletableFuture`通过添加新的工厂方法、支持延迟和超时以及改进子类化得到了增强——我们将在接下来的章节中更详细地讨论这些特性。但首先，让我们先概述一下`CompletableFuture`
    API。'
- en: The CompletableFuture API Overview
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CompletableFuture API概述
- en: The `CompletableFuture` API consists of more than 70 methods, 38 of which are
    implementations of the `CompletionStage` interface, and five are the implementations
    of `Future`. Because the `CompletableFuture`class implements the `Future` interface,
    it can be treated as `Future` and will not break the existing functionality based
    on the `Future` API.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletableFuture` API包含超过70个方法，其中38个是`CompletionStage`接口的实现，5个是`Future`的实现。因为`CompletableFuture`类实现了`Future`接口，所以它可以被当作`Future`来使用，而不会破坏基于`Future`
    API的现有功能。'
- en: 'So, the bulk of the API comes from `CompletionStage`. Most of the methods return
    `CompletableFuture` (in the `CompletionStage` interface, they return `CompletionStage`,
    but they are converted to `CompletableFuture`when implemented in `CompletableFuture`
    class), which means that they allow chaining the operations similar to how the
    `Stream` methods do when only one element goes through a pipe. Each method has
    a signature that accepts a function. Some methods accept `Function<T,U>`, which
    is going to be applied to the passed-in value `T` and return the result `U`. Other
    methods accept `Consumer<T>`, which takes the passed-in value and returns `void`.
    Yet other methods accept `Runnable`, which does not take any input and returns
    `void`. Here is one group of these methods:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，API的大部分内容来自`CompletionStage`。大多数方法返回`CompletableFuture`（在`CompletionStage`接口中，它们返回`CompletionStage`，但在`CompletableFuture`类中实现时，它们被转换为`CompletableFuture`），这意味着它们允许像`Stream`方法那样进行操作链。每个方法都有一个接受函数的签名。一些方法接受`Function<T,U>`，它将被应用于传入的值`T`并返回结果`U`。其他方法接受`Consumer<T>`，它接受传入的值并返回`void`。还有其他方法接受`Runnable`，它不接受任何输入并返回`void`。以下是一组这些方法：
- en: '[PRE64]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'They all return `CompletableFuture`, which carries the result of the function
    or void (in the case of `Runnable`and `Consumer`). Each of them has two companion
    methods that perform the same function asynchronously. For example, let''s take
    the `thenRun(Runnable action)` method. The following are its companions:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都返回`CompletableFuture`，它携带函数的结果或void（在`Runnable`和`Consumer`的情况下）。每个方法都有两个伴随方法，它们以异步方式执行相同的功能。例如，让我们以`thenRun(Runnable
    action)`方法为例。以下是其伴随方法：
- en: The `thenRunAsync(Runnable action)` method, which runs the action in another
    thread from the default `ForkJoinPool.commonPool()` pool
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenRunAsync(Runnable action)`方法，它使用默认的`ForkJoinPool.commonPool()`池中的另一个线程来运行操作'
- en: The `thenRun(Runnable action, Executor executor)` method, which runs the action
    in another thread from the pool passed in as the parameter executor
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenRun(Runnable action, Executor executor)`方法，它使用作为参数传入的池executor中的另一个线程来运行操作'
- en: With that, we have covered nine methods of the `CompletionStage` interface.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经涵盖了`CompletionStage`接口的九种方法。
- en: 'Another group of methods consists of the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 另一组方法包括以下内容：
- en: '[PRE65]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: These methods execute the passed in action after one or both the `CompletableFuture`
    (or `CompletionStage`) objects produce a result that is used as an input to the
    action. By both, we mean the `CompletableFuture` that provides the method and
    the one that is passed in as a parameter of the method. From the name of these
    methods, you can quite reliably guess what their intent is. We will demonstrate
    some of them in the following examples. Each of these seven methods has two companions
    for asynchronous processing, too. This means that we have already described 30
    (out of 38) methods of the `CompletionStage` interface.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法在`CompletableFuture`（或`CompletionStage`）对象产生一个结果并用作操作输入之后执行传入的操作。这里的“两者”指的是提供方法的`CompletableFuture`和作为方法参数传入的`CompletableFuture`。从这些方法的名称中，你可以相当可靠地猜测它们的意图。我们将在下面的示例中演示其中的一些。这七个方法中的每一个也有两个用于异步处理的方法。这意味着我们已经描述了`CompletionStage`接口的30种方法（共38种）。
- en: 'There is a group of two methods that are typically used as terminal operations
    because they can handle either the result of the previous method (passed in as
    `T`) or an exception (passed in as `Throwable`):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 有两组方法通常用作终端操作，因为它们可以处理前一个方法的结果（作为`T`传入）或异常（作为`Throwable`传入）：
- en: '[PRE66]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We will see an example of the use of these methods later. When an exception
    is thrown by a method in the chain, all the rest of the chained methods are skipped
    until the first `handle()` method or `whenComplete()` is encountered. If neither
    of these two methods are present in the chain, then the exception will bubble
    up as any other Java exception. These two also have asynchronous companions, which
    means that we talked about 36 (out of 38) methods of `CompletionStage` interface
    already.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后的示例中看到这些方法的用法。当链中的方法抛出异常时，直到遇到第一个`handle()`方法或`whenComplete()`方法，链中的其余方法都会被跳过。如果链中不存在这两种方法之一，则异常将像任何其他Java异常一样向上冒泡。这两个方法也有异步伴随方法，这意味着我们已经讨论了`CompletionStage`接口的36种方法（共38种）。
- en: 'There is also a method that handles exceptions only (similar to a catch block
    in the traditional programming):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个仅处理异常的方法（类似于传统编程中的catch块）：
- en: '[PRE67]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This method does not have asynchronous companions, just like the last remaining
    method:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法没有异步的配套方法，就像最后一个剩余的方法一样：
- en: '[PRE68]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It just returns a `CompletableFuture` object with the same properties as this
    stage. With that, we have described all 38 methods of the `CompletionStage` interface.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是返回一个与该阶段具有相同属性的`CompletableFuture`对象。这样，我们就描述了`CompletionStage`接口的所有38个方法。
- en: 'There are also some 30 methods in the `CompletableFuture` class that do not
    belong to any of the implemented interfaces. Some of them return the `CompletableFuture`
    object after asynchronously executing the provided function:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CompletableFuture`类中也有一些不属于任何实现接口的30个方法。其中一些在异步执行提供的函数后返回`CompletableFuture`对象：
- en: '[PRE69]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Others execute several objects of `CompletableFuture` in parallel:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 其他对象并行执行几个`CompletableFuture`：
- en: '[PRE70]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'There is also a group of the methods that generate completed futures, so the
    `get()` method on the returned `CompletableFuture` object will not block any more:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一组方法可以生成完成的未来，因此返回的`CompletableFuture`对象的`get()`方法将不再阻塞：
- en: '[PRE71]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The rest of the methods perform various other functions that can be helpful:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的方法执行各种其他可能很有用的功能：
- en: '[PRE72]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Refer to the official Oracle documentation, which describes these and other
    methods of the `CompletableFuture` API at [http://download.java.net/java/jdk9/docs/api/index.html?java/util/concurrent/CompletableFuture.html](http://download.java.net/java/jdk9/docs/api/index.html?java/util/concurrent/CompletableFuture.html).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅官方Oracle文档，其中描述了这些以及其他`CompletableFuture` API的方法，链接为[http://download.java.net/java/jdk9/docs/api/index.html?java/util/concurrent/CompletableFuture.html](http://download.java.net/java/jdk9/docs/api/index.html?java/util/concurrent/CompletableFuture.html)。
- en: The CompletableFuture API Enhancements in Java 9
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 9中CompletableFuture API的增强
- en: 'Java 9 introduces several enhancements to `CompletableFuture`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9对`CompletableFuture`引入了几个增强：
- en: The `CompletionStage<U> failedStage(Throwable ex)` factory method returns the
    `CompletionStage` object completed with the given exception
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionStage<U> failedStage(Throwable ex)`工厂方法返回一个带有给定异常的`CompletionStage`对象'
- en: The `CompletableFuture<U> failedFuture(Throwable ex)` factory method returns
    the `CompletableFuture`object completed with the given exception
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture<U> failedFuture(Throwable ex)`工厂方法返回一个带有给定异常的`CompletableFuture`对象'
- en: The new `CompletionStage<U> completedStage(U value)` factory method returns
    the `CompletionStage` object completed with the given `U` value
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的`CompletionStage<U> completedStage(U value)`工厂方法返回一个带有给定`U`值的`CompletionStage`对象
- en: '`CompletableFuture<T> completeOnTimeout(T value, long timeout, TimeUnit unit)`
    completes `CompletableFuture` task with the given `T` value if not otherwise completed
    before the given timeout'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture<T> completeOnTimeout(T value, long timeout, TimeUnit unit)`如果在未来给定超时时间内未完成，则使用给定的`T`值完成`CompletableFuture`任务'
- en: '`CompletableFuture<T> orTimeout(long timeout, TimeUnit unit)` completes `CompletableFuture`
    with `java.util.concurrent.TimeoutException` if not completed before the given
    timeout'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture<T> orTimeout(long timeout, TimeUnit unit)`如果在未来给定超时时间内未完成，则使用`java.util.concurrent.TimeoutException`完成`CompletableFuture`'
- en: It is possible now to override the `defaultExecutor()` method to support another
    default executor
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在可以重写`defaultExecutor()`方法以支持另一个默认的执行器
- en: A new method, `newIncompleteFuture()`, makes it easier to subclass the `CompletableFuture`
    class
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的方法`newIncompleteFuture()`使得子类化`CompletableFuture`类变得更加容易
- en: The Problem and the Solution using Future
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Future的问题和解决方案
- en: 'To demonstrate and appreciate the power of `CompletableFuture`, let''s start
    with a problem implemented using just `Future` and then see how much more effectively
    it can be solved with `CompletableFuture`. Let''s imagine that we are tasked with
    modeling a building that consists of four stages:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示和欣赏`CompletableFuture`的强大功能，让我们从一个仅使用`Future`实现的问题开始，然后看看如何更有效地使用`CompletableFuture`来解决它。让我们想象一下，我们被分配了一个建模由四个阶段组成的建筑的任务：
- en: Collecting materials for the foundation, walls, and roof
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集地基、墙壁和屋顶的材料
- en: Installing the foundation
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装地基
- en: Raising up the walls
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竖起墙壁
- en: Constructing and finishing the roof
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和完成屋顶
- en: 'In the traditional sequential programming for the single thread, the model
    would look like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的单线程顺序编程中，模型看起来是这样的：
- en: '[PRE73]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Here, `Stage` is an enumeration:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Stage`是一个枚举：
- en: '[PRE74]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `doStage()` method has two overloaded versions. Here is the first one:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`doStage()`方法有两个重载版本。以下是第一个：'
- en: '[PRE75]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The second version is as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个版本如下：
- en: '[PRE76]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `sleepSec()`, `isSuccess()`, and `getResult()` methods look like this:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`sleepSec()`、`isSuccess()`和`getResult()`方法看起来如下：'
- en: '[PRE77]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The successful house construction (if we run the previous code without assigning
    any value to the `failedStage` variable) looks like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不将任何值分配给`failedStage`变量而运行之前的代码，成功的房屋建造看起来是这样的：
- en: '![The Problem and the Solution using Future](img/05_34.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![使用未来解决问题的方法和解决方案](img/05_34.jpg)'
- en: 'If we set `failedStage=Stage.Walls`, the result will be as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`failedStage`设置为`Stage.Walls`，结果将如下所示：
- en: '![The Problem and the Solution using Future](img/05_35.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![使用未来解决问题的方法和解决方案](img/05_35.jpg)'
- en: 'Using `Future`, we can shorten the time it takes to build the house:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Future`，我们可以缩短建造房屋所需的时间：
- en: '[PRE78]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Here, the `getSuccessOrFirstFailure()` method looks like this:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`getSuccessOrFirstFailure()`方法看起来是这样的：
- en: '[PRE79]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The successful building of the house now is faster because material collection
    happens in parallel:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 由于材料收集是并行的，现在成功建造房屋的速度更快：
- en: '![The Problem and the Solution using Future](img/05_36.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![使用未来解决问题的方法和解决方案](img/05_36.jpg)'
- en: 'By taking advantage of Java functional programming, we can change the second
    half of our implementation to the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用Java函数式编程，我们可以将实现的后半部分改为以下内容：
- en: '[PRE80]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The chain of the previous nested functions is triggered by `supplier5.get()`
    in the last line. It blocks until all the functions are completed sequentially,
    so there is no performance improvement:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 之前嵌套函数的链是由最后一行的`supplier5.get()`触发的。它将阻塞，直到所有函数按顺序完成，因此没有性能提升：
- en: '![The Problem and the Solution using Future](img/05_38.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![使用Future解决问题的方法和解决方案](img/05_38.jpg)'
- en: And that is as far as we can go with `Future`. Now let's see if we can improve
    the previous code using `CompletableFuture`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 到此，我们使用`Future`所能做到的也就这样了。现在让我们看看是否可以使用`CompletableFuture`改进之前的代码。
- en: The Solution with CompletableFuture
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CompletableFuture的解决方案
- en: 'Here''s how we can chain the same operations using the `CompletableFuture`
    API:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`CompletableFuture` API链式调用相同操作的方法：
- en: '[PRE81]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'To make it work, we had to change the implementation of one of the `doStage()`
    to `doStageEx()` methods:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让它工作，我们必须将其中一个`doStage()`方法的实现改为`doStageEx()`方法：
- en: '[PRE82]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, let''s see how the system behaves if one of the first stages of collecting
    materials fails (`failedStage = Stage.WallsMaterials`):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果收集材料的第一个阶段之一失败（`failedStage = Stage.WallsMaterials`），系统将如何表现：
- en: '![The Solution with CompletableFuture](img/05_39.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![使用CompletableFuture的解决方案](img/05_39.jpg)'
- en: The exception was thrown by the `WallsMaterials` stage and caught by the `handleAsync()`
    method, as expected. And, again, the processing was done asynchronously after
    the `Out!!!!!` message was printed.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是由`WallsMaterials`阶段抛出并由`handleAsync()`方法捕获的，正如预期的那样。而且，再次，打印出`Out!!!!!`消息后，处理是异步完成的。
- en: Other Useful Features of CompletableFuture
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CompletableFuture的其他有用功能
- en: 'One of the great advantages of `CompletableFuture` is that it can be passed
    around as an object and used several times to start different chains of operations.
    To demonstrate this capability, let''s create several new operations:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletableFuture`的一个巨大优点是它可以作为一个对象传递并多次使用以启动不同的操作链。为了展示这种能力，让我们创建几个新的操作：'
- en: '[PRE84]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The results of these operations are going to be handled by the `myHandler()`
    method:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作的结果将由`myHandler()`方法处理：
- en: '[PRE85]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Note all the different types returned by the operations. Now we can build a
    chain that forks in two at some point:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 注意操作返回的所有不同类型。现在我们可以在某个点将链分成两个分支：
- en: '[PRE86]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The result of this example is as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的结果如下所示：
- en: '![Other Useful Features of CompletableFuture](img/05_40.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![CompletableFuture的其他有用功能](img/05_40.jpg)'
- en: The `CompletableFuture` API provides a very rich and well-thought-through API
    that supports, among other things, the latest trends in reactive microservices
    because it allows processing data fully asynchronously as it comes in, splitting
    the flow if needed, and scaling to accommodate the increase of the input. We encourage
    you to study the examples (many more are provided in the code that accompanies
    this book) and look at the API at [http://download.java.net/java/jdk9/docs/api/index.html?java/util/concurrent/CompletableFuture.html](http://download.java.net/java/jdk9/docs/api/index.html?java/util/concurrent/CompletableFuture.html).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletableFuture` API提供了一个非常丰富且经过深思熟虑的API，它支持许多其他功能，包括反应式微服务的最新趋势，因为它允许完全异步地处理传入的数据，如果需要，可以分割流，并扩展以适应输入的增加。我们鼓励您研究示例（本书附带的代码中提供了更多示例）并查看API
    [http://download.java.net/java/jdk9/docs/api/index.html?java/util/concurrent/CompletableFuture.html](http://download.java.net/java/jdk9/docs/api/index.html?java/util/concurrent/CompletableFuture.html)。'
- en: Stream API Improvements
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stream API改进
- en: 'Most of the new `Stream` API features in Java 9 have already been demonstrated
    in the section that describes `Stream` filtering. To remind you, here are the
    examples we have demonstrated based on the `Stream` API improvements in JDK 9:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9中的大多数新`Stream` API特性已在描述`Stream`过滤的章节中演示。为了提醒你，以下是我们在JDK 9的`Stream` API改进基础上演示的例子：
- en: '[PRE87]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The only one we have not mentioned yet is the new overloaded `iterate()` method:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有提到的是新的重载`iterate()`方法：
- en: '[PRE88]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'An example of its usage is as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 其用法的一个例子如下：
- en: '[PRE89]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We had to add `limit(5)` because this version of the `iterate()` method creates
    an unlimited stream of integer numbers. The result of the previous code is as
    follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不添加`limit(5)`，因为此版本的`iterate()`方法创建了一个无限流整数。前述代码的结果如下：
- en: '![Stream API Improvements](img/05_41.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![Stream API Improvements](img/05_41.jpg)'
- en: 'In Java 9, an overloaded `iterate()` method was added:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中，添加了重载的`iterate()`方法：
- en: '[PRE90]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'As you see, it has now a `Predicate` functional interface as a parameter that
    allows limiting the stream as needed. For example, the following code produces
    exactly the same result as the previous example with `limit(5)`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它现在有一个作为参数的`Predicate`函数式接口，允许根据需要限制流。例如，以下代码产生了与之前使用`limit(5)`的例子完全相同的结果：
- en: '[PRE91]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Note that the type of the stream element does not need to be an integer. It
    can be any type produced by the source. So, the new `iterate()` method can be
    used to provide criteria for the termination of the stream of any type of data.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，流元素的类型不需要是整数。它可以是由源产生的任何类型。因此，新的`iterate()`方法可以用来提供任何类型数据的流终止条件。
- en: Summary
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this lesson, we covered a lot of ground in the area of the new features introduced
    with Java 9\. First, we looked at many ways to stream filtering, starting with
    the basic `filter()` method and ending up using the `Stream` API additions of
    JDK 9\. Then, you learned a better way to analyze the stack trace using the new
    `StackWalker` class. The discussion was illustrated by specific examples that
    help you to see the real working code.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我们深入探讨了Java 9引入的新特性领域。首先，我们探讨了多种流过滤方法，从基本的`filter()`方法开始，最终使用JDK 9的`Stream`
    API新增功能。然后，你学习了使用新的`StackWalker`类分析堆栈跟踪的更好方法。讨论通过具体的例子进行说明，帮助你看到真正的运行代码。
- en: We used the same approach while presenting new convenient factory methods for
    creating immutable collections and new capabilities for asynchronous processing
    that came with the `CompletableFuture` class and its enhancements in JDK 9.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍创建不可变集合的新便捷工厂方法和`CompletableFuture`类及其在JDK 9中的增强功能的新异步处理能力时，我们使用了相同的方法。
- en: We ended this lesson by enumerating the improvements to the `Stream` API--those
    we have demonstrated in the filtering code examples and the new `iterate()` method.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过列举`Stream` API的改进来结束本课——那些我们在过滤代码示例和新`iterate()`方法中演示的改进。
- en: With this, we come to the end of this book. You can now try and apply the tips
    and techniques you have learned to your project or, if it is not suitable for
    that, to build your own Java project for high performance. While doing that, try
    to solve real problems. That will force you to learn new skills and frameworks
    instead of just applying the knowledge you have already, although the latter is
    helpful too--it keeps your knowledge fresh and practical.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们来到了这本书的结尾。你现在可以尝试将所学到的技巧和技术应用到你的项目中，或者如果它不适合那样做，可以构建自己的Java项目以实现高性能。在这样做的时候，尝试解决实际问题。这将迫使你学习新的技能和框架，而不仅仅是应用你已经拥有的知识，尽管后者也很有帮助——它使你的知识保持新鲜和实用。
- en: The best way to learn is to do it yourself. As Java continues to improve and
    expand, watch out for new editions of this and similar books by Packt.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳的学习方式是亲自实践。随着Java的持续改进和扩展，请关注Packt出版的本和类似书籍的新版本。
- en: Assessments
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: The _______ interface was introduced in Java 8 to emit elements and supports
    a variety of operations that perform computations based on stream elements.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 8引入了`_______`接口，用于发出元素，并支持基于流元素执行计算的各种操作。
- en: Which of the following factory methods of the `StackWalker` class creates a
    `StackWalker` class instance with the given option of specifying the stack frame
    information that it can access?
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个`StackWalker`类的工厂方法创建了一个具有指定堆栈帧信息的`StackWalker`类实例？
- en: '`getInstance()`'
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getInstance()`'
- en: '`getInstance(StackWalker.Option option)`'
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getInstance(StackWalker.Option option)`'
- en: '`getInstance(Set<StackWalker.Option> options)`'
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getInstance(Set<StackWalker.Option> options)`'
- en: '`getInstance(Set<StackWalker.Option> options, int estimatedDepth)`'
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getInstance(Set<StackWalker.Option> options, int estimatedDepth)`'
- en: 'State whether True or False: The `CompletableFuture` API consists of many methods
    which are implementations of the `CompletionStage` interface, and are the implementations
    of `Future`.'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错：`CompletableFuture` API 包含许多方法，这些方法是 `CompletionStage` 接口的实现，并且是 `Future`
    的实现。
- en: Which among the following methods is used when a type of filtering is required
    to skip all the duplicate elements in a stream and select only unique element.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下方法中，哪种方法用于在流中需要过滤掉所有重复元素并仅选择唯一元素时使用。
- en: '`distinct()`'
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`distinct()`'
- en: '`unique()`'
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`unique()`'
- en: '`selectall()`'
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`selectall()`'
- en: '`filtertype()`'
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`filtertype()`'
- en: 'State whether True or False: One of the great advantages of `CompletableFuture`
    is that it can be passed around as an object and used several times to start different
    chains of operations.'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错：`CompletableFuture` 的一个巨大优点是它可以作为一个对象传递，并且可以多次使用来启动不同的操作链。
