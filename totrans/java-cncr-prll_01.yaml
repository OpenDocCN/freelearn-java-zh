- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Concurrency, Parallelism, and the Cloud: Navigating the Cloud-Native Landscape'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to an exciting journey into the world of Java’s **concurrency** and
    **parallelism** paradigms, which are crucial for developing efficient and scalable
    cloud-native applications. In this introductory chapter, we’ll establish a solid
    foundation by exploring the fundamental concepts of concurrency and parallelism,
    as well as their significance in contemporary software design. Through practical
    examples and hands-on practice problems, you’ll gain a deep understanding of these
    principles and their application in real-world scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: As we progress, we’ll delve into the transformative impact of cloud computing
    on software development and its synergistic relationship with Java. You’ll learn
    how to leverage Java’s powerful features and libraries to tackle the challenges
    of concurrent programming in cloud-native environments. We’ll also explore case
    studies from industry leaders such as Netflix, LinkedIn, X (formerly Twitter),
    and Alibaba, showcasing how they have successfully harnessed Java’s concurrency
    and parallelism capabilities to build robust and high-performance applications.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, you’ll gain a comprehensive understanding of the software
    paradigms that shape the cloud era and Java’s pivotal role in this landscape.
    By mastering the concepts and techniques presented here, you’ll be well-equipped
    to design and implement concurrent systems that scale seamlessly in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s embark on this exciting journey together and unlock the full potential
    of concurrency and parallelism in Java cloud-native development. Get ready to
    acquire the knowledge and skills necessary to build innovative, efficient, and
    future-proof software solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the minimal Java JRE/JDK setup guide for macOS, Windows, and Linux.
    You can follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the desired version of Java JRE or JDK from the official Oracle website:
    [https://www.oracle.com/java/technologies/javase-downloads.html](https://www.oracle.com/java/technologies/javase-downloads.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the appropriate version and operating system to download.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install Java on your system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'macOS:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Double-click the downloaded `.``dmg` file.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the installation wizard and accept the license agreement.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop the Java icon into the Applications folder.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Windows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the downloaded executable (`.``exe`) file.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the installation wizard and accept the license agreement.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the installation directory and complete the installation.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Linux:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract the downloaded `.tar.gz` archive to a directory of your choice.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For system-wide installation, move the extracted directory to `/usr/local/java`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set the environment variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'macOS and Linux:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Open the terminal.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `~/.bash_profile` or `~/.bashrc` file (depending on your shell).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines (replace `<JDK_DIRECTORY>` with the actual path) in
    the file: `export JAVA_HOME=<JDK_DIRECTORY>` and `export PATH=$JAVA_HOME/bin:$PATH`.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the file and restart the terminal.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Windows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Open the Start menu and search for `JAVA_HOME` and the value as the JDK installation
    directory.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `%JAVA_HOME%\bin` to the **Path** variable.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **OK** to save the changes.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify the installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a new terminal or command prompt.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command: `java -version`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It should display the installed Java version.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For more detailed installation instructions and troubleshooting, you can refer
    to the official Oracle documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'macOS: [https://docs.oracle.com/en/java/javase/17/install/installation-jdk-macos.html](https://docs.oracle.com/en/java/javase/17/install/installation-jdk-macos.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows: [https://docs.oracle.com/en/java/javase/17/install/installation-jdk-microsoft-windows-platforms.html](https://docs.oracle.com/en/java/javase/17/install/installation-jdk-microsoft-windows-platforms.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux: [https://docs.oracle.com/en/java/javase/17/install/installation-jdk-linux-platforms.html](https://docs.oracle.com/en/java/javase/17/install/installation-jdk-linux-platforms.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that the exact steps may vary slightly depending on the specific
    Java version and operating system version you are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to install a Java **Integrated Development Environment** (**IDE**)
    on your laptop. Here are a few Java IDEs and their download URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: IntelliJ IDEA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download URL:[https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pricing: Free Community Edition with limited features, Ultimate Edition with
    full features requires a subscription'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Eclipse IDE:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Download URL: [https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pricing: Free and open source'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apache NetBeans:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Download URL: [https://netbeans.apache.org/front/main/download/index.html](https://netbeans.apache.org/front/main/download/index.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pricing: Free and open source'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Code** (**VS Code**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Download URL: [https://code.visualstudio.com/download](https://code.visualstudio.com/download)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pricing: Free and open source'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: VS Code offers a lightweight and customizable alternative to the other options
    on this list. It’s a great choice for developers who prefer a less resource-intensive
    IDE and want the flexibility to install extensions that are tailored to their
    specific needs. However, it may not have all the features out of the box compared
    to the more established Java IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, the code in this chapter can be found on GitHub: [https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism).'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Due to a recent tech update and page limit constraints, many code snippets in
    this book are shortened versions. They are used in chapters for demonstration
    purposes only. Some code has also been revised based on the update. For the most
    current, complete, and functional code, please refer to the book’s accompanying
    GitHub repository. The repository should be considered the primary and preferred
    source for all code examples.
  prefs: []
  type: TYPE_NORMAL
- en: The dual pillars of concurrency versus parallelism – a kitchen analogy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the kitchen of Java concurrency and parallelism! Here, we’ll whisk
    you through a culinary journey, unveiling the art of multitasking and high-speed
    cooking in programming. Imagine juggling different tasks like a master chef –
    that’s concurrency. Then, picture multiple chefs cooking in harmony for a grand
    feast – that’s parallelism. Get ready to spice up your Java applications with
    these essential skills, from handling user interactions to crunching massive data.
    Bon appétit to the world of efficient and responsive Java cooking!
  prefs: []
  type: TYPE_NORMAL
- en: Defining concurrency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Java, concurrency allows a program to manage multiple tasks such that they
    seem to run simultaneously, enhancing performance even on single-core systems.
    A **core** refers to a processing unit within a computer’s CPU that is capable
    of executing programming instructions. While true parallel execution requires
    multiple cores, with each core handling a different task at the same time, Java’s
    concurrency mechanisms can create the illusion of parallelism by efficiently scheduling
    and executing tasks in a way that maximizes the use of available resources. They
    can do this on a single- or multi-core system. This approach enables Java programs
    to achieve high levels of efficiency and responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: Defining parallelism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parallelism is the simultaneous execution of multiple tasks or calculations,
    typically on multi-core systems. In parallelism, each core handles a separate
    task concurrently, leveraging the principle of dividing large problems into smaller,
    independently solvable subtasks. This approach harnesses the power of multiple
    cores to achieve faster execution and efficient resource utilization. By assigning
    tasks to different cores, parallelism enables true simultaneous processing, as
    opposed to concurrency, which creates the illusion of simultaneous execution through
    time-sharing techniques. Parallelism requires hardware support in the form of
    multiple cores or processors to achieve optimal performance gains.
  prefs: []
  type: TYPE_NORMAL
- en: The analogy of a restaurant kitchen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine a restaurant kitchen as a metaphor for a Java application. From this
    perspective, we will understand the role of concurrency and parallelism in Java
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll consider concurrency. In a concurrent kitchen, there’s one chef
    (the main thread) who can handle multiple tasks such as chopping vegetables, grilling,
    and plating. They do one task at a time, switching between tasks (context switching).
    This is similar to a single-threaded Java application managing multiple tasks
    asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we come to parallelism. In a parallel kitchen, there are multiple chefs
    (multiple threads) working simultaneously, each handling a different task. This
    is like a Java application utilizing multi-threading to process different tasks
    concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a Java code example for concurrency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an explanation of the preceding code example:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a fixed thread pool with two threads using `Executors.newFixedThreadPool(2)`.
    This allows the tasks to be executed concurrently by utilizing multiple threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We submit two tasks to the executor using `executor.submit()`. These tasks are
    analogous to chopping vegetables and grilling meat.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After submitting the tasks, we use `task1.get()` and `task2.get()` to wait for
    both tasks to complete. The `get()` method blocks until the task is finished and
    returns the result (in this case, there is no result since the tasks have a void
    return type).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we shut down the executor using `executor.shutdown()` to release the
    resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will look at a Java code example for parallelism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Explanation of the preceding code example is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: This Java code demonstrates parallel processing using `IntStream` and the parallel
    method, which is ideal for simulating tasks in a `Parallel Kitchen`. The main
    method utilizes an integer stream to create a range of `0` to `9`, representing
    a range of different dishes.
  prefs: []
  type: TYPE_NORMAL
- en: By invoking `.parallel()` on `IntStream`, the code ensures that the processing
    of these dishes happens in parallel, leveraging multiple threads. Each iteration
    simulates cooking a dish, identified by the index, `i`, and is executed concurrently
    with other iterations.
  prefs: []
  type: TYPE_NORMAL
- en: The `Thread.sleep(600)` inside the `forEach` lambda expression mimics the time
    taken to cook each dish. The sleep duration is set for simulation purposes and
    is not indicative of actual cooking times.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `InterruptedException`, the thread’s interrupt flag is set again
    with `Thread.currentThread().interrupt()`, adhering to best practices in handling
    interruptions in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having seen the two examples, let us understand the key differences between
    concurrency and parallelism:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Focus**: Concurrency is about managing multiple tasks, while parallelism
    is about executing tasks simultaneously for performance gains'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Execution**: Concurrency can work on single-core processors, but parallelism
    benefits from multi-core systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both concurrency and parallelism play crucial roles in building efficient and
    responsive Java applications. The right approach for you depends on the specific
    needs of your program and the available hardware resources.
  prefs: []
  type: TYPE_NORMAL
- en: When to use concurrency versus parallelism – a concise guide
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Armed with the strengths of concurrency and parallelism, let’s dive into picking
    the perfect tool. We’ll weigh up complexity, environment, and task nature to ensure
    that your Java applications sing. Buckle up, master chefs, as we unlock optimal
    performance and efficiency!
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Concurrency is essential for effectively managing multiple operations simultaneously,
    particularly in three key areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simultaneous task management**: This is ideal for efficiently handling user
    requests and **Input/Output (I/O)** operations, especially with the use of non-blocking
    I/O. This technique allows programs to execute other tasks without waiting for
    data transfer to complete, significantly enhancing responsiveness and throughput.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource sharing**: Through synchronization tools such as locks, concurrency
    ensures safe access to shared resources among multiple threads, preserving data
    integrity and preventing conflicts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Scalability is crucial in developing systems capable of expansion
    such as microservices in cloud environments. Concurrency facilitates the execution
    of numerous tasks across different servers or processes, improving the system’s
    overall performance and capacity to handle growth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at some examples to illustrate each of the three key areas where
    concurrency is essential.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first example is related to simultaneous task management. Here is a web
    server handling multiple client requests concurrently using non-blocking I/O:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this simplified example, the following happened:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a `ServerSocketChannel` and bound it to a specific address and port.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We configured the server socket to be non-blocking using `configureBlocking(false)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside an infinite loop, we accepted incoming client connections using `serverSocket.accept()`.
    If a client is connected, we will proceed to handle the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We configured the client socket to be non-blocking as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We allocated a buffer to read the client request using `ByteBuffer.allocate()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We read the request from the client socket into the buffer using `clientSocket.read(buffer)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We processed the request and sent a response back to the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we closed the client socket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This simplified example demonstrates the key concept of handling multiple client
    requests concurrently using non-blocking I/O. The server can accept and process
    requests from multiple clients without blocking, allowing for efficient utilization
    of system resources and improved responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this example has been simplified for illustration purposes and may
    not include all the necessary error handling and edge case considerations of a
    production-ready web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second example is resource sharing. Here is an example of multiple threads
    accessing a shared counter using synchronization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, multiple (`CounterThread`) threads accessed a shared `SynchronizedCounter`
    object. The `increment()` and `getCount()` methods of the counter were synchronized
    to ensure that only one thread could access them at a time, preventing race conditions
    and maintaining data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us see an example of scalability. Here is a code example of microservice
    architecture using concurrency to handle a large number of requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a microservice uses an `ExecutorService` with a fixed thread
    pool to handle a large number of requests concurrently. Each request is submitted
    as a task to the executor, which distributes them among the available threads.
    This allows the microservice to process multiple requests simultaneously, improving
    scalability and overall performance.
  prefs: []
  type: TYPE_NORMAL
- en: These examples demonstrate how concurrency is applied in different scenarios
    to achieve simultaneous task management, safe resource sharing, and scalability.
    They showcase the practical applications of concurrency in building efficient
    and high-performing systems.
  prefs: []
  type: TYPE_NORMAL
- en: Parallelism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Parallelism is a powerful concept used to enhance computing efficiency across
    various scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compute-intensive tasks**: It excels at deconstructing elaborate calculations
    into smaller, autonomous sub-tasks that can be executed in parallel. This method
    significantly streamlines complex computational operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance optimization**: By engaging multiple processor cores at once,
    parallelism substantially shortens the time needed to complete tasks. This simultaneous
    utilization of cores ensures a quicker, more efficient execution process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Large data processing**: Parallelism is key in swiftly handling, analyzing,
    and modifying vast datasets. Its capability to process multiple data segments
    concurrently makes it invaluable for big data applications and analytics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let’s look at some short demo code examples to illustrate the concepts of
    parallelism in each of the mentioned scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s explore how parallelism can be applied to compute-intensive tasks,
    such as calculating Fibonacci numbers, using the `Fork/Join` framework in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we used parallelism to compute the Fibonacci number of a given
    value `n`. The computation is split into subtasks using the `Fork/Join` framework.
    The `ParallelFibonacci` class extends `RecursiveAction` and overrides the `compute()`
    method. If the value of `n` is below a certain threshold, the Fibonacci number
    is computed sequentially. Otherwise, the task is split into two subtasks, which
    are forked for parallel execution. Finally, the results are joined to obtain the
    final Fibonacci number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is performance optimization. Parallelism can significantly optimize performance,
    especially when dealing with time-consuming operations such as sorting large arrays.
    Let’s compare the performance of sequential and parallel sorting in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we demonstrated the performance optimization achieved by using
    parallelism for sorting a large array. We generated a random array of size 100,000,000
    and measured the time taken to sort the array using both sequential sorting (`Arrays.sort()`)
    and parallel sorting (`Arrays.parallelSort()`). Parallel sorting utilizes multiple
    processor cores to sort the array concurrently, resulting in faster execution
    compared to sequential sorting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s turn to large data processing. Processing large datasets can be
    greatly accelerated by leveraging parallelism. In this example, we’ll demonstrate
    how parallel streams in Java can efficiently calculate the sum of a large number
    of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we generated a large list of 100,000,000 integers using the `generateData`
    method. We then calculated the sum of all elements using both sequential and parallel
    streams.
  prefs: []
  type: TYPE_NORMAL
- en: The sequential processing is performed using `data.stream()`, which creates
    a sequential stream from the data list. The `mapToInt(Integer::intValue)` operation
    converts each `Integer` object to its primitive `int` value, and the `sum()` method
    calculates the sum of all elements in the stream.
  prefs: []
  type: TYPE_NORMAL
- en: For parallel processing, we use `data.parallelStream()` to create a parallel
    stream. The parallel stream automatically splits the data into multiple chunks
    and processes them concurrently using available processor cores. The same `mapToInt(Integer::intValue)`
    and `sum()` operations are applied to calculate the sum of all elements in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: We measure the execution time of both sequential and parallel processing using
    `System.currentTimeMillis()` before and after each operation. By comparing the
    execution times, we can observe the performance improvement achieved by using
    parallelism.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So, you’ve mastered the power of both concurrency and parallelism. Now comes
    the key question: how do you choose the right tool for the job? It’s a dance between
    performance gains and complexity, where environment and task characteristics play
    their part. Let’s dive into this crucial decision-making process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Complexity versus benefit**: Weigh the performance gain of parallelism against
    its increased complexity and potential debugging challenges'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment**: Consider your cloud infrastructure’s capability for parallel
    processing (number of available cores)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Task nature and dependencies**: Independent, CPU-intensive tasks favor parallelism,
    while tasks with shared resources or I/O operations may benefit from concurrency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve just equipped you with the culinary secrets of concurrency and parallelism,
    the dynamic duo that powers efficient Java applications. Remember, concurrency
    juggles multiple tasks like a master chef, while parallelism unleashes the power
    of multi-core machines for lightning-fast performance.
  prefs: []
  type: TYPE_NORMAL
- en: Why is this culinary wisdom so crucial? In the cloud-native world, Java shines
    as a versatile chef, adapting to diverse tasks. Concurrency and parallelism become
    your essential tools, ensuring responsiveness to user requests, handling complex
    calculations, and processing massive data – all on the ever-evolving canvas of
    the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s take this culinary expertise to the next level. In the next section,
    we’ll explore how these concurrency and parallelism skills seamlessly blend with
    cloud technologies to build truly scalable and high-performance Java applications.
    So sharpen your knives and get ready to conquer the cloud-native kitchen!
  prefs: []
  type: TYPE_NORMAL
- en: Java and the cloud – a perfect alliance for cloud-native development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java’s journey with cloud computing is a testament to its adaptability and innovation.
    The fusion of their capabilities has created a powerful alliance for cloud-native
    development. Imagine yourself as an architect, wielding Java’s toolkit at the
    forefront of cloud technology. Here, Java’s versatility and robustness partner
    with the cloud’s agility and scalability to offer a canvas for innovation and
    growth. We’re not just discussing theoretical concepts – we’re stepping into a
    realm where Java’s pragmatic application in the cloud has revolutionized development,
    deployment, and application management. Let’s uncover how Java in the cloud era
    is not just an option, but a strategic choice for developers seeking to unlock
    the full potential of cloud-native development.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring cloud service models and their impact on software development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java development has entered a new era with cloud computing. Imagine having
    instant access to a vast pool of virtual resources, from servers to storage to
    networking. Cloud services unlock this magic, empowering Java developers to build
    and scale applications faster and more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Three distinct service models dominate the cloud, each impacting development
    needs and Java application architecture. Let us explore each one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure as a service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Infrastructure as a Service** (**IaaS**) offers foundational cloud computing
    resources such as virtual machines and storage. For Java developers, this means
    complete control over the operating environment, allowing for customized Java
    application setups and optimizations. However, it requires a deeper understanding
    of infrastructure management.'
  prefs: []
  type: TYPE_NORMAL
- en: Code example – Java on IaaS (Amazon EC2)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This code snippet showcases how to create and launch an Amazon **Elastic Compute
    Cloud** (**EC2**) instance using the AWS SDK for Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break it down step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Create` `EC2 client`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AmazonEC2Client ec2Client =` `new AmazonEC2Client();`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`setImageId`: The `setInstanceType`: We define the instance type, such as `t2.micro`,
    for a small, cost-effective option'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`setMinCount`: We specify the minimum number of instances to launch (`1` in
    this case)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`setMaxCount`: We specify the maximum number of instances to launch (`3` in
    this case, allowing the system to scale up if needed)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`runInstances` method on the `ec2Client` object, passing the configured `runRequest`
    object. This sends the request to AWS to launch the desired EC2 instances.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`runInstances` method returns a `RunInstancesResult` object containing information
    about the launched instances. We will extract the instance ID of the first instance
    (assuming a successful launch) for further use in the deployment process.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Configure Tomcat and deploy application**: This comment indicates that the
    next steps will involve setting up Tomcat on the launched EC2 instance and deploying
    your web application. The specific code for this would depend on your chosen Tomcat
    installation method and application deployment strategy.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This example demonstrates launching instances with a minimum and maximum count.
    You can adjust these values based on your desired level of redundancy and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Platform as a service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Platform as a Service** (**PaaS**) provides a higher-level environment with
    ready-to-use platforms including operating systems and development tools. This
    is beneficial for Java developers as it simplifies deployment and management,
    though it might limit lower-level control.'
  prefs: []
  type: TYPE_NORMAL
- en: Code example – Java on AWS Lambda
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This code snippet defines a simple Java Lambda function that processes an S3
    object upload event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is a listener for Amazon S3 object uploads. It’s like a robot that
    watches for new files in a specific bucket (such as a folder) and automatically
    does something with them when they arrive:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It checks for new files in the bucket: for each new file, it gets the filename
    and the bucket it’s in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You need to fill in the missing part: write your own code here to say what
    you want the robot to do with the file (e.g., download it, analyze it, or send
    an email)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the robot finishes with all the files, it sends a message back to Amazon
    saying **Processing complete**.
  prefs: []
  type: TYPE_NORMAL
- en: I hope this simplified explanation makes things clearer!
  prefs: []
  type: TYPE_NORMAL
- en: Software as a service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Software as a service** (**SaaS**) delivers complete application functionality
    as a service. For Java developers, this often means focusing on building the application’s
    business logic without worrying about the deployment environment. However, customization
    and control over the platform are limited.'
  prefs: []
  type: TYPE_NORMAL
- en: Code example – Java on SaaS (AWS Lambda)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This code snippet defines a Lambda function for processing event data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This code defines a class called `LambdaHandler` that listens for events in
    a serverless environment such as AWS Lambda. Here’s a breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listening for events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The class is named `LambdaHandler`, signifying its role as a handler for Lambda
    events.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `handleRequest` method is the entry point for processing incoming events.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The event parameter holds the data received from the Lambda invocation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Processing data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `handleRequest` method, the code retrieves the message key from the
    event data using `event.get("message")`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This assumes that the event format includes a key named `message` containing
    the actual data to be processed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The code then processes the message and combines it with a prefix to generate
    a new string stored in the result variable.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returning result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the `handleRequest` method returns the processed message stored in
    the result variable. This is the response that is sent back to the caller of the
    Lambda function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In simpler terms, this code acts like a small service that takes in data (messages)
    through an event, processes it (adds a prefix), and returns the updated version.
    It’s a simple example of how Lambda functions can handle basic data processing
    tasks in a serverless environment.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the strengths and weaknesses of each cloud service model is crucial
    for Java developers to be able to make the best decisions for their projects.
    By choosing the right model, they can unlock the immense potential of cloud computing
    and revolutionize the way in which they build and deploy Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Java’s transformation in the cloud – a story of innovation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine a world transformed by the cloud, where applications soar among the
    constellations of data centers. This is the landscape Java navigates today, not
    as a relic of the past, but as a language reborn in the fires of innovation.
  prefs: []
  type: TYPE_NORMAL
- en: At the heart of this evolution lies the **Java Virtual Machine** (**JVM**),
    the engine that powers Java applications. Once again, it has transformed, shedding
    layers of inefficiency to become lean and mean, ready to conquer the resource-constrained
    world of the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: But power alone is not enough. Security concerns loom large in the vastness
    of the cloud. Java, ever vigilant, has donned the armor of robust security features,
    ensuring that its applications remain unbreachable fortresses in the digital realm.
  prefs: []
  type: TYPE_NORMAL
- en: Yet size and security are mere tools without purpose. Java has embraced the
    new paradigm of microservices, breaking down monolithic structures into nimble,
    adaptable units. Frameworks such as Spring Boot and MicroProfile stand as a testament
    to this evolution, empowering developers to build applications that dance with
    the dynamism of the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: As the cloud offers its vast array of services, Java stands ready to embrace
    them all. Its vast ecosystem and robust APIs act as bridges, connecting applications
    to the boundless resources at their fingertips.
  prefs: []
  type: TYPE_NORMAL
- en: This is not just a story of technical advancement, it’s a testament to the power
    of adaptability and of embracing change and forging a new path in the ever-evolving
    landscape of the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Java – the cloud-native hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java sits comfortably on the throne of cloud-native development. Here’s why:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Platform agnostic**: *Write once, run anywhere* is a feature of Java applications.
    These cloud-agnostic Java applications effortlessly dance across platforms, simplifying
    deployment across diverse cloud infrastructures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability and performance**: Java pairs perfectly with the cloud’s inherent
    scalability, handling fluctuating workloads with ease. Built-in garbage collection
    and memory management further optimize resource utilization and drive high performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security first**: Java’s robust security features, such as sandboxing and
    strong type checking, shield applications from common vulnerabilities, making
    them ideal for the security-conscious cloud environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rich ecosystem**: A vast and mature ecosystem of libraries, frameworks, and
    tools caters specifically to cloud-native development, empowering developers to
    build faster and with less effort.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservices champion**: Java’s modularity and object-oriented design perfectly
    align with the growing trend of microservices architecture, allowing developers
    to build and scale independent services easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CI/CD ready**: Java integrates seamlessly with popular **continuous integration**
    (**CI**) and **continuous deployment** (**CD**) tools and methodologies, enabling
    automated builds, tests, and deployments for rapid cloud-native application delivery.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency king**: Java’s built-in concurrency features, such as threads
    and thread pools, empower developers to create highly concurrent applications
    that leverage the parallel processing capabilities of cloud computing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Community and support**: Java boasts a vibrant community and a wealth of
    online resources and documentation, providing invaluable support for developers
    working with cloud-native Java applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, Java’s inherent characteristics and compatibility with modern
    cloud architectures make it the natural hero for cloud-native development. With
    its rich ecosystem and robust security features, Java empowers developers to build
    and deploy high-performing, scalable, and secure cloud-native applications.
  prefs: []
  type: TYPE_NORMAL
- en: Java’s cloud-focused upgrades – concurrency and beyond
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The cloud demands efficient and scalable applications, and Java continues to
    evolve to meet this need. Here’s a spotlight on key updates for cloud-native development,
    focusing on concurrency and parallelism.
  prefs: []
  type: TYPE_NORMAL
- en: Project Loom – virtual threads for efficient concurrency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine handling a multitude of concurrent tasks without worrying about resource
    overhead. Project Loom introduces lightweight virtual threads, enabling efficient
    management of high concurrency. This is ideal for cloud environments where responsiveness
    and resource efficiency are paramount.
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced garbage collection for high throughput
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Say goodbye to long garbage collection pauses impacting performance. Recent
    Java versions introduce low-pause, scalable garbage collectors such as ZGC and
    Shenandoah GC. These handle large heaps with minimal latency, ensuring smooth
    operation and high throughput even in demanding cloud environments.
  prefs: []
  type: TYPE_NORMAL
- en: Record types – simplifying data modeling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cloud applications frequently deal with data transfer objects and messaging
    between services. Record types, introduced in Java 16, simplify immutable data
    modeling, offering a concise and efficient way to represent data structures. This
    improves code readability, reduces boilerplate code, and ensures data consistency
    in cloud-based microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Sealed classes – controlled inheritance hierarchies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Have you ever wanted to enforce specific inheritance rules in your cloud application?
    Sealed classes, finalized in Java 17, allow you to restrict which classes or interfaces
    can extend or implement others. This promotes clarity, maintainability, and predictable
    behavior within cloud-based domain models.
  prefs: []
  type: TYPE_NORMAL
- en: Other notable updates for cloud development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to these key updates related to concurrency and parallelism, there
    are many other improvements. Here are a few:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pattern matching for instanceof**: Offers a cleaner and more concise solution
    for checking and casting object types, improving code readability and reducing
    boilerplate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Foreign-memory access API**: Allows Java programs to safely and efficiently
    access memory outside the Java heap, unlocking performance potential and facilitating
    seamless integration with native libraries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP client API**: Simplifies HTTP and WebSocket communication for cloud
    applications, enabling developers to build robust and high-performance clients
    for effective communication within the cloud ecosystem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microbenchmark suite**: Helps in accurately measuring the performance of
    code snippets, allowing for precise performance tuning and ensuring your cloud
    applications run at their peak potential'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These advancements demonstrate Java’s commitment to empowering developers to
    build robust, scalable, and high-performing cloud applications. By leveraging
    these features, developers can unlock the full potential of Java in the cloud
    and create innovative solutions for the evolving digital landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples of successful cloud-native Java applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java isn’t just a programming language; it’s a powerhouse fueling some of the
    world’s most innovative companies. Let’s take a peek behind the scenes of four
    industry leaders and see how Java drives their success.
  prefs: []
  type: TYPE_NORMAL
- en: Netflix – microservices maestro
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine millions of people streaming movies and shows simultaneously, without
    a hiccup. That’s the magic of Netflix’s microservices architecture, which was
    meticulously crafted with Java. Spring Boot and Spring Cloud act as the architects,
    building individual services that work together seamlessly. When things get bumpy,
    Hystrix, a Netflix-born Java library, acts as the knight in shining armor, isolating
    issues and keeping the show running. Zuul, another Java gem, stands guard at the
    edge, routing traffic and ensuring everything flows smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: LinkedIn – data’s real-time river
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: LinkedIn’s vibrant network thrives on real-time data. And who keeps this information
    flowing like a mighty river? Apache Kafka, a Java-powered stream processing platform.
    Kafka’s lightning-fast speed and fault tolerance ensure connections are always
    live, allowing for instant updates and personalized experiences. Plus, Kafka seamlessly
    integrates with other Java-based systems at LinkedIn, creating a powerful data
    processing symphony.
  prefs: []
  type: TYPE_NORMAL
- en: X – from Ruby on Rails to the JVM’s soaring heights
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember the days of slow-loading tweets? X (formerly Twitter) does! To conquer
    the challenge of scale, they made a bold move: migrating from Ruby on Rails to
    the JVM. This switch, powered by Java and Scala, unlocked a new era of performance
    and scalability. Finagle, a Twitter-built RPC system for the JVM, further boosted
    concurrency. This allowed millions of tweets to take flight simultaneously.'
  prefs: []
  type: TYPE_NORMAL
- en: Alibaba – the e-commerce titan forged in Java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When it comes to online shopping, Alibaba reigns supreme. And what’s their secret
    weapon? Java! From handling massive spikes in traffic to managing complex data
    landscapes, Java’s ability to handle high concurrency is Alibaba’s golden ticket
    to success. They’ve even optimized Java’s garbage collection to efficiently manage
    their immense heap size, ensuring that their platform runs smoothly even when
    billions of items are flying off the virtual shelves.
  prefs: []
  type: TYPE_NORMAL
- en: These are just a few examples of how Java empowers industry leaders. From streaming
    giants to social media havens and e-commerce titans, Java’s versatility and power
    are undeniable. So, next time you watch a movie, share a post, or click *buy*,
    remember – there’s a good chance Java is quietly pulling the strings, making your
    experience seamless and magical.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve explored Java’s hidden superpower – its seamless integration with the
    cloud! From concurrency and parallelism to microservices architecture, Java empowers
    developers to build robust, scalable, and high-performing cloud-native applications.
    We’ve seen how Netflix, LinkedIn, X, and Alibaba leverage Java’s diverse capabilities
    to achieve their cloud goals.
  prefs: []
  type: TYPE_NORMAL
- en: But the cloud journey isn’t without its challenges. Security, cost optimization,
    and efficient resource management all come knocking at the door of your cloud-native
    development. In the next section, we’ll dive deep into these modern challenges,
    equipping you with the knowledge and tools to navigate them like a seasoned cloud
    explorer. So buckle up, fellow Java adventurers, as we venture into the exciting
    realm of modern challenges in cloud-native development!
  prefs: []
  type: TYPE_NORMAL
- en: Modern challenges in cloud-native concurrency and Java’s weapons of choice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The cloud’s concurrency challenges loom, but Java’s not backing down. We’ll
    tackle these challenges in transactions, data consistency, and microservices states,
    all while wielding tools such as Akka, Vert.x, and reactive programming. Choose
    your weapons wisely, for the cloud-native concurrency challenge is yours to conquer!
  prefs: []
  type: TYPE_NORMAL
- en: Wrangling distributed transactions in Java – beyond classic commits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the wild jungle of distributed systems, managing transactions across services
    and databases can be a daunting task. Traditional methods stumble over network
    delays, partial failures, and diverse systems. But fear not, Java warriors! We’ve
    got your back with a robust arsenal of solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Two-phase commit (2PC)**: This classic protocol ensures all parties in a
    transaction commit or roll back together. While not ideal for high-speed environments
    due to its blocking nature, 2PC remains a reliable option for more controlled
    transactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Saga pattern**: Think of this as a choreographed dance, where each local
    transaction is linked to others through a sequence of events. Java frameworks
    such as Axon and Eventuate help you orchestrate this graceful ballet, ensuring
    data consistency even when things get messy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compensating transactions**: Imagine a safety net for your saga. If a step
    goes wrong, compensating transactions swoop in, reversing the effects of previous
    operations and keeping your data safe. Java services can implement this strategy
    with service compensations, which are ready to clean up any spills.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining data consistency in cloud-native Java applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Data consistency in the cloud can be a tricky tango, especially with NoSQL’s
    eventual rhythm. But Java’s got the notes to keep it harmonious:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kafka’s eventual beat**: Updates become rhythmic pulses, sent out and listened
    to by services. It’s not immediate, but everyone eventually grooves to the same
    tune.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching whispers**: Tools such as Hazelcast and Ignite act as quick assistants,
    keeping data consistent across nodes, even when the main database takes a break.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entity versioning**: When two updates waltz in at once, versioning helps
    us track who came first and resolve conflicts gracefully. No data mosh pits here!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these moves and a bit of Java magic, your cloud applications will keep
    your data safe and sound, moving in perfect rhythm.
  prefs: []
  type: TYPE_NORMAL
- en: Handling state in microservices architectures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Microservices are a beautiful dance of independent services, but what about
    their state? Managing it across this distributed landscape can feel like wrangling
    a herd of wild cats. But fear not, Java offers a map and a torch to guide you
    through:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stateless serenity**: When possible, design microservices as stateless citizens
    of the cloud. This keeps them lightweight, scalable, and effortlessly resilient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distributed session sherpas**: For those services that crave a bit of state,
    distributed session management tools such as Redis and ZooKeeper come to the rescue.
    They keep track of state across nodes, ensuring everyone’s on the same page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CQRS and event sourcing – the stateful waltz**: For truly complex state dances,
    patterns such as **Command Query Responsibility Segregation** (**CQRS**) and Event
    Sourcing offer a graceful solution. Java frameworks such as Axon provide the perfect
    shoes for this intricate choreography.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these strategies in your arsenal, you can navigate the stateful microservices
    maze with confidence, building resilient and scalable systems that thrive in the
    ever-changing cloud landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud database concurrency – Java’s dance moves for shared resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine a crowded dance floor – that’s your cloud database with multiple clients
    vying for attention. It’s a delicate tango of multi-tenancy and resource sharing.
    Keeping everyone in step requires some fancy footwork.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Atomicity, Consistency, Isolation, and Durability** (**ACID**) test adds
    another layer of complexity. Messy concurrency can easily trip up data integrity,
    especially in distributed environments. Java’s got your back with a few fancy
    footwork moves:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sharing (with manners)**: Multi-tenancy and resource sharing are no problem
    with Java’s locking mechanisms, which include synchronized blocks and ReentrantLock.
    They act as bouncers, ensuring everyone gets their turn without stepping on toes
    (or data).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimistic versus pessimistic locking**: Think of these as different dance
    styles. Optimistic locking assumes that everyone plays nice, while pessimistic
    locking keeps a watchful eye, preventing conflicts before they happen. Java frameworks
    such as JPA and Hibernate offer both styles, letting you choose the perfect rhythm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching the craze**: Frequently accessed data gets its own VIP lounge: the
    distributed cache. Java solutions such as Hazelcast and Apache Ignite keep this
    lounge stocked, reducing database load and ensuring smooth data access for everyone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these moves in your repertoire, your Java applications can waltz gracefully
    through cloud database concurrency, ensuring data consistency and smooth performance
    even when the dance floor gets crowded.
  prefs: []
  type: TYPE_NORMAL
- en: Parallelism in big data processing frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine waves of data, rushing in like a flood. You need a way to analyze it
    all – fast. That’s where parallel processing comes in, and Java’s got the tools
    to tackle it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MapReduce**: Java is extensively used in MapReduce programming models, as
    seen in Hadoop. Developers write Map and Reduce functions in Java to process large
    datasets in parallel across a Hadoop cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apache Spark**: Although it is written in Scala, Spark provides Java APIs.
    It enables parallel data processing by distributing data across **Resilient Distributed
    Datasets** (**RDDs**) and executing operations in parallel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stream processing**: Java Stream API, along with tools such as Apache Flink
    and Apache Storm, supports parallel stream processing for real-time data analytics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, when data gets overwhelming, remember Java. It’s got the tools to keep you
    informed and in control, even when the beast roars!
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will kick off the thrilling journey into concurrency and parallelism
    in the cloud-native Java world. Get ready to transform these challenges into opportunities.
    In the pages ahead, you’ll acquire the tools to master concurrency and parallelism.
    This will empower you to build robust, future-proof Java applications that thrive
    in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Cutting-edge tools for conquering cloud-native concurrency challenges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The intricate dance of concurrency in cloud-native applications can be daunting,
    but fear not! Cutting-edge tools and techniques are here to help. Let’s explore
    some tools to address the challenges we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-native concurrency toolkits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following tools fit well into this category:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Akka**: This powerful toolkit leverages the actor model for building highly
    scalable and fault-tolerant applications. It provides features such as message
    passing, supervision, and location transparency, simplifying concurrent programming
    and addressing challenges such as distributed locks and leader election.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vert.x**: This lightweight toolkit focuses on reactive programming and non-blocking
    I/O, making it ideal for building highly responsive and performant applications.
    Vert.x’s event-driven architecture can handle high concurrency effectively and
    simplifies asynchronous programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lagom**: This framework is built on top of Akka and offers a high-level API
    for building microservices. Lagom provides features such as service discovery,
    load balancing, and fault tolerance, making it suitable for building complex,
    distributed systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed coordination mechanisms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tools in this category include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ZooKeeper**: This open source tool provides distributed coordination primitives
    such as locking, leader election, and configuration management. ZooKeeper’s simplicity
    and reliability make it a popular choice for coordinating distributed applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**etcd**: This distributed key-value store provides a high-performance and
    scalable means to store and manage configuration data across nodes. etcd’s features,
    including watches and leases, make it suitable for maintaining consistency and
    coordinating state changes in distributed systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consul**: This service mesh solution offers a comprehensive set of features
    for service discovery, load balancing, and distributed coordination. Consul’s
    web UI and rich API make it easy to manage and monitor distributed systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modern asynchronous programming patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These modern asynchronous patterns enable efficient non-blocking data processing
    and scalable, resilient applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reactive Streams**: This specification provides a standard way to write asynchronous,
    non-blocking programs. Reactive Streams improves responsiveness and scalability
    by ensuring that data is processed efficiently and that backpressure is managed
    effectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous messaging**: This technique utilizes message queues to decouple
    components and handle tasks asynchronously. Asynchronous messaging can improve
    scalability and resilience by enabling parallel processing and handling failures
    gracefully.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the right tool for the job
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each toolkit, mechanism, and pattern has its own strengths and weaknesses,
    making them suitable for different scenarios. Here are some considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Complexity**: Akka offers rich features but can be complex to learn and use.
    Vert.x and Lagom provide a simpler starting point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: All three toolkits are highly scalable but Vert.x excels for
    high-performance applications due to its non-blocking nature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coordination needs**: ZooKeeper is well-suited for basic coordination tasks,
    while etcd’s key-value store offers additional flexibility. Consul provides a
    complete service mesh solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Programming style**: Reactive Streams requires a shift in thinking toward
    asynchronous programming, while asynchronous messaging can be integrated with
    traditional synchronous approaches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By understanding the available solutions and their trade-offs, developers can
    choose the right tools and techniques to address specific concurrency challenges
    in their cloud-native applications. This, in turn, leads to building more scalable,
    responsive, and resilient systems that thrive in the dynamic cloud environment.
  prefs: []
  type: TYPE_NORMAL
- en: Conquering concurrency – best practices for robust cloud-native applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building cloud apps that juggle multiple tasks at once? It’s like managing
    a bustling zoo of data and operations! But fear not, because we’ve got the best
    practices to tame the concurrency beasts and build robust, scalable cloud apps.
    Here are the best practices to embed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Early identification**: Proactively identify and address concurrency challenges
    through early analysis, modeling, and code review:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analyze application requirements**: Identify critical sections, shared resources,
    and potential points of contention early in the design phase'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use concurrency modeling tools**: Utilize modeling tools such as statecharts
    or Petri nets to visualize and analyze potential concurrency issues'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Review existing code for concurrency bugs**: Conduct code reviews and static
    analysis to identify potential race conditions, deadlocks, and other concurrency
    problems'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embrace immutable data**: Embrace unchangeable data to simplify concurrent
    logic and eliminate race conditions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimize mutable state**: Design data structures and objects to be immutable
    by default. This simplifies reasoning about their behavior and eliminates potential
    race conditions related to shared state modifications.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utilize functional programming principles**: Leverage functional programming
    techniques such as immutability, pure functions, and laziness to create inherently
    thread-safe and predictable concurrent code.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ensure thread safety**: Secure concurrent access to shared resources through
    synchronized blocks, thread-safe libraries, and focused thread confinement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use synchronized blocks or other locking mechanisms**: Protect critical sections
    of code that access shared resources to prevent concurrent modifications and data
    inconsistencies'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leverage thread-safe libraries and frameworks**: Choose libraries and frameworks
    that are specifically designed for concurrent programming and utilize their thread-safe
    functionalities'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Employ thread confinement patterns**: Assign threads to specific tasks or
    objects to limit their access to shared resources and simplify reasoning about
    thread interactions'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Design for failure**: Build resilience against concurrency failures through
    fault tolerance mechanisms, proactive monitoring, and rigorous stress testing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implement fault tolerance mechanisms**: Design your application to handle
    and recover from concurrency-related failures gracefully. This includes retry
    mechanisms, circuit breakers, and fail-over strategies.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitor and observe concurrency behavior**: Employ monitoring tools and observability
    practices to identify and diagnose concurrency issues in production environments.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conduct stress testing**: Perform rigorous stress testing to evaluate how
    your application behaves under high load and identify potential concurrency bottlenecks.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leverage cloud-native tools**: Harness the power of cloud-native tools such
    as asynchronous patterns, distributed coordination, and dedicated frameworks to
    conquer concurrent challenges and build robust, scalable cloud applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utilize asynchronous programming patterns**: Embrace asynchronous programming
    models such as reactive streams and asynchronous messaging to improve scalability
    and responsiveness in concurrent applications'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adopt distributed coordination mechanisms**: Utilize distributed coordination
    tools such as ZooKeeper, etcd, or Consul to manage distributed state and ensure
    consistent operation across multiple nodes'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Choose appropriate concurrency frameworks**: Leverage cloud-native concurrency
    frameworks such as Akka, Vert.x, or Lagom to simplify concurrent programming and
    address specific concurrency challenges effectively'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With a solid understanding of best practices, let's turn our attention to code.
  prefs: []
  type: TYPE_NORMAL
- en: Code examples illustrating best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at some code examples.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming with reactive streams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can leverage reactive streams such as RxJava to implement an asynchronous
    processing pipeline. This allows for the concurrent execution of independent tasks,
    improving responsiveness and throughput. Here is a code example using reactive
    streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code defines a service for handling user requests in a reactive way. Think
    of it as a waiter at a restaurant who takes your order (user ID) and brings back
    your food (user information).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the key points to be noted from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UserService` defines the service contract, promising to get a user by ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UserServiceImpl` provides the actual logic for fetching the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mono` from reactive streams, meaning the user data is delivered asynchronously,
    like a waiter who tells you your food is coming later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`600` milliseconds) and then returns a `User` object with the ID and name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getUserById` with a user ID, and it returns `Mono` containing the user data.
    You can then `subscribe` to `Mono` to receive the user information later when
    it’s ready.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, this code shows how to define and implement a reactive service in
    Java using an interface and `Mono` to handle asynchronous data retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-native concurrency frameworks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Akka is a popular cloud-native concurrency framework that provides powerful
    tools for building highly scalable and resilient applications. It offers features
    such as actor-based message passing, fault tolerance, and resource management.
    Here is an example of handling user requests asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the example provided, `UserActor` class in Akka defines an actor that handles
    user requests asynchronously. The class provides a static `props()` method for
    actor instantiation, encapsulating its creation logic. In the `createReceive()`
    method, the actor defines its behavior by using the `receiveBuilder()` to match
    messages of type `GetUserRequest`. When such a message is received, it delegates
    the handling to the private `handleGetUserRequest()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `handleGetUserRequest()` method simulates a delay of 600 milliseconds to
    represent fetching user data. After the delay, it creates a `User` object with
    the provided user ID and a hardcoded name `"Jack Smith"`. The actor then sends
    a `GetUserResponse` message containing the `User` object back to the sender using
    `getSender()` and `getSelf()`. This design ensures that each request is processed
    independently, allowing the system to handle multiple concurrent requests efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: In short, this code uses an actor model to handle user requests asynchronously.
    The actor receives tasks, works on them, and sends back results, making your application
    more responsive and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed coordination with ZooKeeper
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imagine that our application now scales to multiple nodes. To maintain a consistent
    state across the nodes and prevent conflicts, we can utilize a distributed coordination
    tool such as ZooKeeper. The following is an example of using ZooKeeper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This code snippet sets up a simple system to track processed requests using
    ZooKeeper, a distributed coordination service. Here’s a breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/processed-requests` to store processed request IDs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requestId`), the code checks whether a node with that ID already exists under
    the called/processed-requests node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requestId` is created under the called or processed-requests to mark it as
    processed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think of it like a checklist in ZooKeeper. Each request has its own checkbox.
    Checking it means it’s been dealt with. This ensures that requests are not processed
    multiple times, even if the connection drops or the server restarts.
  prefs: []
  type: TYPE_NORMAL
- en: By integrating these best practices into your development process, you can build
    cloud-native applications that are not only highly functional but also robust
    and resilient to the complexities of concurrency. Remember, embracing concurrency-first
    design is not just about solving immediate problems. It’s also about building
    a foundation for future scalability and sustainable growth in the dynamic cloud
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring consistency – the bedrock of robust concurrency strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the dynamic realm of cloud-native applications, concurrency is an ever-present
    companion. Achieving consistent concurrency strategies throughout your application
    is crucial for ensuring its reliability, scalability, and performance. This consistent
    approach offers several key benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Predictability and stability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consistent concurrency strategies unify your code, simplifying development
    and boosting stability through predictable behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Uniformity**: Utilizing consistent concurrency strategies across the application
    promotes predictability and stability. Developers can rely on established patterns
    and behaviors, leading to easier code comprehension, maintenance, and debugging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced complexity**: By avoiding a patchwork of ad hoc solutions, developers
    can focus on core functionalities instead of constantly reinventing the wheel
    for concurrency management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging standard libraries and frameworks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Leverage established libraries and frameworks for built-in expertise, optimized
    performance, and reduced development overhead in concurrent projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliability and expertise**: Utilizing established libraries and frameworks
    designed for concurrent programming leverages the expertise and best practices
    embedded within them. These tools often offer built-in thread safety, error handling,
    and performance optimizations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced overhead**: Standard libraries often offer optimized implementations
    for common concurrency tasks, reducing development time and overhead compared
    to building custom solutions from scratch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pitfalls of ad hoc solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the potential issues with using ad hoc concurrency solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hidden bugs and pitfalls**: Ad hoc concurrency solutions can introduce subtle
    bugs and performance issues that are difficult to detect and debug. These problems
    may surface only under specific conditions or high loads, leading to unexpected
    failures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability challenges**: Implementing and maintaining ad hoc solutions
    can become cumbersome and error-prone over time. This complexity can hinder future
    development and collaboration efforts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared standards and reviews for robust code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Shared guidelines and reviews prevent concurrency chaos, ensuring consistent,
    reliable code through teamwork:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Establish guidelines and standards**: Define clear guidelines and standards
    for concurrency management within your development team. This should include preferred
    libraries, frameworks, and coding practices to be followed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utilize code reviews and peer programming**: Encourage code reviews and peer
    programming practices to identify potential concurrency issues early and ensure
    adherence to established guidelines. Consider using checklists or specific review
    techniques tailored for concurrency concerns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emphasize testing and quality assurance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Concurrency in cloud-native Java applications introduces unique testing challenges.
    To ensure robust and resilient applications, address these challenges head-on
    with targeted testing strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Concurrency-focused unit testing**: Use unit tests to isolate and examine
    the behavior of individual components under concurrent scenarios. This includes
    testing for thread safety and handling of shared resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration testing for distributed interactions**: Conduct integration tests
    to ensure that different components interact correctly under concurrent conditions,
    especially in microservices architectures common in cloud environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance and stress testing**: Stress test your application under high
    load to uncover issues such as deadlocks or livelocks that only emerge under specific
    conditions or heavy concurrent access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated testing for efficiency**: Implement automated tests using frameworks
    such as JUnit, focusing on scenarios that mimic concurrent operations. Use mock
    testing frameworks to simulate complex concurrency scenarios and dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency testing tools**: Leverage tools such as JMeter, Gatling, Locust,
    or Tsung to test how your application handles high concurrent loads. This helps
    you identify performance bottlenecks and scalability issues in cloud-native environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ongoing commitment**: Maintaining consistent concurrency strategies is an
    ongoing commitment. Regularly review and revise your approach as your application
    evolves and new libraries, frameworks, and best practices emerge. By fostering
    a culture of consistency and continuous improvement, you can build reliable, scalable,
    and performant cloud-native applications that thrive in the ever-changing digital
    landscape.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining consistent concurrency strategies is an ongoing commitment. Regularly
    review and revise your approach as your application evolves and new libraries,
    frameworks, and best practices emerge. By fostering a culture of consistency and
    continuous improvement, you can build reliable, scalable, and performant cloud-native
    applications that thrive in the ever-changing digital landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[*Chapter 1*](B20937_01.xhtml#_idTextAnchor014) introduced the fundamental
    concepts of Java cloud-native development, focusing on concurrency and parallelism.
    It distinguished between managing tasks on single-core (concurrency) versus multi-core
    processors (parallelism), with practical Java examples. The chapter highlighted
    Java’s role in cloud computing, emphasizing its scalability, ecosystem, and community.
    Practical applications, including the Java AWS SDK and Lambda functions, illustrated
    Java’s adaptability across cloud models.'
  prefs: []
  type: TYPE_NORMAL
- en: Significant Java updates such as Project Loom and advanced garbage collection
    methods were discussed for optimizing performance. Java’s effectiveness in complex
    environments was showcased through case studies of Netflix and X (formerly Twitter),
    among others. These focused on microservices, real-time data processing, and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: The narrative then shifted to practical strategies for distributed transactions,
    data consistency, and microservices state management. The chapter advocated for
    consistent concurrency strategies in cloud-native applications. It concluded with
    resources for further exploration and tools for mastering Java concurrency and
    parallelism, equipping developers to build scalable cloud-native applications.
    The foundation that has been set here will lead to deeper explorations of Java’s
    concurrency mechanisms in subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will transition to a new chapter that delves into the foundational
    principles of concurrency within the Java ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – exploring Java executors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Objective**: In this exercise, you will explore different types of executors
    provided by the Java Concurrency API. You will refer to the Java documentation,
    use a different executor implementation, and observe its behavior in a sample
    program.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Instructions**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit the Java documentation for the `Executors` class: [https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read through the documentation and familiarize yourself with the different factory
    methods provided by the `Executors` class for creating `Executor` instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Choose a different executor implementation other than the fixed thread pool
    used in the previous examples. Some options include the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Executors.newCachedThreadPool()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Executors.newSingleThreadExecutor()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Executors.newScheduledThreadPool(int corePoolSize)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new Java class called `ExecutorExploration` and replace the Executor
    creation line with the chosen executor implementation. For example, if you chose
    `Executors.newCachedThreadPool()`, your code would look like this:Top of Form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the task creation and submission logic to create and submit a larger
    number of tasks (e.g., 100 tasks) to the executor. Here’s an example of how you
    can modify the code to create and submit 100 tasks to the executor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program and observe the behavior of the chosen executor. Take note of
    how it handles the submitted tasks and any differences compared to the fixed thread
    pool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment with different executor implementations and observe how they behave
    differently in terms of task execution, thread creation, and resource utilization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following questions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does the chosen executor handle the submitted tasks compared to the fixed
    thread pool?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there any differences in the order or concurrency of task execution?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How does the executor manage threads and resource allocation?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Feel free to refer back to the Java documentation to understand the characteristics
    and use cases of each executor implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By completing this exercise, you will gain hands-on experience with different
    types of executors in Java and understand their behavior and use cases. This knowledge
    will help you make informed decisions when choosing an appropriate executor for
    your specific concurrency requirements in Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to review the Java documentation, experiment with different executor
    implementations, and observe their behavior in action. Happy exploring!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the primary advantage of using microservices in cloud-based Java applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increased security through monolithic architecture
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Easier to scale and maintain individual services
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Eliminating the need for databases
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Unified, single-point configuration for all services
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In Java concurrency, which mechanism is used to handle multiple threads trying
    to access a shared resource simultaneously?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Synchronization
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Serialization
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is NOT a feature of Java’s `java.util.concurrent` package?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fork/join framework
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ConcurrentHashMap`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ExecutorService`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Stream API
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In serverless computing, which feature is a key benefit when using Java?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Static typing
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Manual scaling
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Automatic scaling and management of resources
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Low-level hardware access
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a common challenge when managing distributed data in Java cloud applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Graphics rendering
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Data consistency and synchronization
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Single-thread execution
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: User interface design
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
