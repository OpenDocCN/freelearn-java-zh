- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: 'Concurrency, Parallelism, and the Cloud: Navigating the Cloud-Native Landscape'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发、并行和云计算：导航云原生景观
- en: Welcome to an exciting journey into the world of Java’s **concurrency** and
    **parallelism** paradigms, which are crucial for developing efficient and scalable
    cloud-native applications. In this introductory chapter, we’ll establish a solid
    foundation by exploring the fundamental concepts of concurrency and parallelism,
    as well as their significance in contemporary software design. Through practical
    examples and hands-on practice problems, you’ll gain a deep understanding of these
    principles and their application in real-world scenarios.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎您踏上探索Java的**并发**和**并行**范式世界的激动人心之旅，这些范式对于开发高效和可扩展的云原生应用至关重要。在本章介绍中，我们将通过探讨并发和并行性的基本概念及其在当代软件设计中的重要性来建立坚实的基础。通过实际示例和动手实践问题，你将深入理解这些原则及其在现实世界场景中的应用。
- en: As we progress, we’ll delve into the transformative impact of cloud computing
    on software development and its synergistic relationship with Java. You’ll learn
    how to leverage Java’s powerful features and libraries to tackle the challenges
    of concurrent programming in cloud-native environments. We’ll also explore case
    studies from industry leaders such as Netflix, LinkedIn, X (formerly Twitter),
    and Alibaba, showcasing how they have successfully harnessed Java’s concurrency
    and parallelism capabilities to build robust and high-performance applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的深入，我们将探讨云计算对软件开发产生的变革性影响及其与Java的协同关系。你将学习如何利用Java强大的特性和库来应对云原生环境中的并发编程挑战。我们还将探讨来自行业领导者如Netflix、LinkedIn、X（前Twitter）和阿里巴巴的案例研究，展示他们如何成功利用Java的并发和并行能力来构建稳健且高性能的应用。
- en: Throughout this chapter, you’ll gain a comprehensive understanding of the software
    paradigms that shape the cloud era and Java’s pivotal role in this landscape.
    By mastering the concepts and techniques presented here, you’ll be well-equipped
    to design and implement concurrent systems that scale seamlessly in the cloud.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将全面了解塑造云计算时代的软件范式以及Java在这一领域中的关键作用。通过掌握这里介绍的概念和技术，你将能够设计并实现能够在云中无缝扩展的并发系统。
- en: So, let’s embark on this exciting journey together and unlock the full potential
    of concurrency and parallelism in Java cloud-native development. Get ready to
    acquire the knowledge and skills necessary to build innovative, efficient, and
    future-proof software solutions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们共同踏上这场激动人心的旅程，并解锁Java云原生开发中并发和并行性的全部潜力。准备好获取构建创新、高效和未来证明的软件解决方案所需的知识和技能。
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here is the minimal Java JRE/JDK setup guide for macOS, Windows, and Linux.
    You can follow these steps:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是针对macOS、Windows和Linux的最小Java JRE/JDK设置指南。您可以按照以下步骤操作：
- en: 'Download the desired version of Java JRE or JDK from the official Oracle website:
    [https://www.oracle.com/java/technologies/javase-downloads.html](https://www.oracle.com/java/technologies/javase-downloads.html).'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从官方Oracle网站下载所需的Java JRE或JDK版本：[https://www.oracle.com/java/technologies/javase-downloads.html](https://www.oracle.com/java/technologies/javase-downloads.html)。
- en: Choose the appropriate version and operating system to download.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择适当的版本和操作系统进行下载。
- en: 'Install Java on your system:'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的系统上安装Java：
- en: 'macOS:'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS：
- en: Double-click the downloaded `.``dmg` file.
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击下载的 `.dmg` 文件。
- en: Follow the installation wizard and accept the license agreement.
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照安装向导操作并接受许可协议。
- en: Drag and drop the Java icon into the Applications folder.
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Java图标拖放到应用程序文件夹。
- en: 'Windows:'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows：
- en: Run the downloaded executable (`.``exe`) file.
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行下载的可执行文件（`.exe`）。
- en: Follow the installation wizard and accept the license agreement.
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照安装向导操作并接受许可协议。
- en: Choose the installation directory and complete the installation.
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择安装目录并完成安装。
- en: 'Linux:'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux：
- en: Extract the downloaded `.tar.gz` archive to a directory of your choice.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将下载的 `.tar.gz` 归档文件解压到您选择的目录。
- en: For system-wide installation, move the extracted directory to `/usr/local/java`.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于系统级安装，将提取的目录移动到 `/usr/local/java`。
- en: 'Set the environment variables:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置环境变量：
- en: 'macOS and Linux:'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS和Linux：
- en: Open the terminal.
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端。
- en: Edit the `~/.bash_profile` or `~/.bashrc` file (depending on your shell).
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `~/.bash_profile` 或 `~/.bashrc` 文件（根据您的shell而定）。
- en: 'Add the following lines (replace `<JDK_DIRECTORY>` with the actual path) in
    the file: `export JAVA_HOME=<JDK_DIRECTORY>` and `export PATH=$JAVA_HOME/bin:$PATH`.'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the file and restart the terminal.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Windows:'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Open the Start menu and search for `JAVA_HOME` and the value as the JDK installation
    directory.
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `%JAVA_HOME%\bin` to the **Path** variable.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **OK** to save the changes.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify the installation:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a new terminal or command prompt.
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command: `java -version`.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It should display the installed Java version.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For more detailed installation instructions and troubleshooting, you can refer
    to the official Oracle documentation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'macOS: [https://docs.oracle.com/en/java/javase/17/install/installation-jdk-macos.html](https://docs.oracle.com/en/java/javase/17/install/installation-jdk-macos.html)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows: [https://docs.oracle.com/en/java/javase/17/install/installation-jdk-microsoft-windows-platforms.html](https://docs.oracle.com/en/java/javase/17/install/installation-jdk-microsoft-windows-platforms.html)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux: [https://docs.oracle.com/en/java/javase/17/install/installation-jdk-linux-platforms.html](https://docs.oracle.com/en/java/javase/17/install/installation-jdk-linux-platforms.html)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that the exact steps may vary slightly depending on the specific
    Java version and operating system version you are using.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to install a Java **Integrated Development Environment** (**IDE**)
    on your laptop. Here are a few Java IDEs and their download URLs:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: IntelliJ IDEA
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download URL:[https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/)
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pricing: Free Community Edition with limited features, Ultimate Edition with
    full features requires a subscription'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Eclipse IDE:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Download URL: [https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/)'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pricing: Free and open source'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apache NetBeans:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Download URL: [https://netbeans.apache.org/front/main/download/index.html](https://netbeans.apache.org/front/main/download/index.html)'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pricing: Free and open source'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Code** (**VS Code**):'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Download URL: [https://code.visualstudio.com/download](https://code.visualstudio.com/download)'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pricing: Free and open source'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: VS Code offers a lightweight and customizable alternative to the other options
    on this list. It’s a great choice for developers who prefer a less resource-intensive
    IDE and want the flexibility to install extensions that are tailored to their
    specific needs. However, it may not have all the features out of the box compared
    to the more established Java IDEs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, the code in this chapter can be found on GitHub: [https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Due to a recent tech update and page limit constraints, many code snippets in
    this book are shortened versions. They are used in chapters for demonstration
    purposes only. Some code has also been revised based on the update. For the most
    current, complete, and functional code, please refer to the book’s accompanying
    GitHub repository. The repository should be considered the primary and preferred
    source for all code examples.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于最近的技术更新和页面限制约束，本书中的许多代码片段都是缩短版本。它们仅用于章节中的演示目的。一些代码也根据更新进行了修订。对于最新、完整和功能性的代码，请参阅本书的配套GitHub仓库。该仓库应被视为所有代码示例的主要和首选来源。
- en: The dual pillars of concurrency versus parallelism – a kitchen analogy
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行与并发的双重支柱——厨房类比
- en: Welcome to the kitchen of Java concurrency and parallelism! Here, we’ll whisk
    you through a culinary journey, unveiling the art of multitasking and high-speed
    cooking in programming. Imagine juggling different tasks like a master chef –
    that’s concurrency. Then, picture multiple chefs cooking in harmony for a grand
    feast – that’s parallelism. Get ready to spice up your Java applications with
    these essential skills, from handling user interactions to crunching massive data.
    Bon appétit to the world of efficient and responsive Java cooking!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到Java并发和并行性的厨房！在这里，我们将带你进行一次烹饪之旅，揭示编程中多任务处理和高速烹饪的艺术。想象一下像大师级厨师一样同时处理不同的任务——那就是并发。然后，想象多个厨师为了盛大宴会而和谐地烹饪——那就是并行。准备好用这些基本技能让你的Java应用程序增色添彩，从处理用户交互到处理大量数据。为高效且响应迅速的Java烹饪世界干杯！
- en: Defining concurrency
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义并发
- en: In Java, concurrency allows a program to manage multiple tasks such that they
    seem to run simultaneously, enhancing performance even on single-core systems.
    A **core** refers to a processing unit within a computer’s CPU that is capable
    of executing programming instructions. While true parallel execution requires
    multiple cores, with each core handling a different task at the same time, Java’s
    concurrency mechanisms can create the illusion of parallelism by efficiently scheduling
    and executing tasks in a way that maximizes the use of available resources. They
    can do this on a single- or multi-core system. This approach enables Java programs
    to achieve high levels of efficiency and responsiveness.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，并发允许程序管理多个任务，使它们看起来似乎是同时运行的，即使在单核系统上也能提高性能。**核心**指的是计算机CPU内的一个处理单元，能够执行编程指令。虽然真正的并行执行需要多个核心，每个核心同时处理不同的任务，但Java的并发机制可以通过高效地调度和执行任务，以最大化使用可用资源的方式，创造出并行性的错觉。它们可以在单核或多核系统上做到这一点。这种方法使Java程序能够实现高效率和响应性。
- en: Defining parallelism
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义并行性
- en: Parallelism is the simultaneous execution of multiple tasks or calculations,
    typically on multi-core systems. In parallelism, each core handles a separate
    task concurrently, leveraging the principle of dividing large problems into smaller,
    independently solvable subtasks. This approach harnesses the power of multiple
    cores to achieve faster execution and efficient resource utilization. By assigning
    tasks to different cores, parallelism enables true simultaneous processing, as
    opposed to concurrency, which creates the illusion of simultaneous execution through
    time-sharing techniques. Parallelism requires hardware support in the form of
    multiple cores or processors to achieve optimal performance gains.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 并行性是指同时执行多个任务或计算，通常在多核系统上。在并行性中，每个核心同时处理一个单独的任务，利用将大问题分解成较小、可独立解决的子任务的原则。这种方法利用多个核心的力量以实现更快的执行和高效的资源利用。通过将任务分配给不同的核心，并行性实现了真正的并行处理，这与并发不同，并发通过时间共享技术创造了一种同时执行的错觉。并行性需要硬件支持，如多个核心或处理器，以实现最佳性能提升。
- en: The analogy of a restaurant kitchen
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 餐厅厨房的类比
- en: Imagine a restaurant kitchen as a metaphor for a Java application. From this
    perspective, we will understand the role of concurrency and parallelism in Java
    applications.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下将餐厅厨房比作Java应用程序的隐喻。从这个角度来看，我们将理解并发和并行在Java应用程序中的作用。
- en: First, we’ll consider concurrency. In a concurrent kitchen, there’s one chef
    (the main thread) who can handle multiple tasks such as chopping vegetables, grilling,
    and plating. They do one task at a time, switching between tasks (context switching).
    This is similar to a single-threaded Java application managing multiple tasks
    asynchronously.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将考虑并发。在一个并发厨房中，有一个厨师（主线程）可以处理多个任务，如切菜、烤肉和装盘。他们一次只做一项任务，在任务之间切换（上下文切换）。这类似于一个单线程Java应用程序异步管理多个任务。
- en: Next, we come to parallelism. In a parallel kitchen, there are multiple chefs
    (multiple threads) working simultaneously, each handling a different task. This
    is like a Java application utilizing multi-threading to process different tasks
    concurrently.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一下并行性。在一个并行厨房中，有多个厨师（多个线程）同时工作，每个厨师处理不同的任务。这就像一个Java应用程序利用多线程来并发处理不同的任务。
- en: 'The following is a Java code example for concurrency:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个Java并发代码示例：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is an explanation of the preceding code example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对前面代码示例的解释：
- en: We create a fixed thread pool with two threads using `Executors.newFixedThreadPool(2)`.
    This allows the tasks to be executed concurrently by utilizing multiple threads.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`Executors.newFixedThreadPool(2)`创建一个包含两个线程的固定线程池。这允许任务通过利用多个线程来并发执行。
- en: We submit two tasks to the executor using `executor.submit()`. These tasks are
    analogous to chopping vegetables and grilling meat.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`executor.submit()`向执行器提交两个任务。这些任务类似于切菜和烤肉。
- en: After submitting the tasks, we use `task1.get()` and `task2.get()` to wait for
    both tasks to complete. The `get()` method blocks until the task is finished and
    returns the result (in this case, there is no result since the tasks have a void
    return type).
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交任务后，我们使用`task1.get()`和`task2.get()`等待两个任务完成。`get()`方法会阻塞直到任务完成并返回结果（在这种情况下，由于任务具有void返回类型，因此没有结果）。
- en: Finally, we shut down the executor using `executor.shutdown()` to release the
    resources.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`executor.shutdown()`关闭执行器以释放资源。
- en: 'Next, we will look at a Java code example for parallelism:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看一个Java并行代码示例：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Explanation of the preceding code example is as follows.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对前面代码示例的解释。
- en: This Java code demonstrates parallel processing using `IntStream` and the parallel
    method, which is ideal for simulating tasks in a `Parallel Kitchen`. The main
    method utilizes an integer stream to create a range of `0` to `9`, representing
    a range of different dishes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这段Java代码演示了使用`IntStream`和并行方法进行并行处理，这对于模拟`Parallel Kitchen`中的任务非常理想。主方法使用整数流创建一个从`0`到`9`的范围，代表不同菜肴的范围。
- en: By invoking `.parallel()` on `IntStream`, the code ensures that the processing
    of these dishes happens in parallel, leveraging multiple threads. Each iteration
    simulates cooking a dish, identified by the index, `i`, and is executed concurrently
    with other iterations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`IntStream`上调用`.parallel()`，代码确保这些菜肴的处理是并行的，利用了多个线程。每次迭代模拟烹饪一道菜，由索引`i`标识，并且与其他迭代并发执行。
- en: The `Thread.sleep(600)` inside the `forEach` lambda expression mimics the time
    taken to cook each dish. The sleep duration is set for simulation purposes and
    is not indicative of actual cooking times.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`forEach` lambda表达式中`Thread.sleep(600)`模拟了烹饪每道菜所需的时间。睡眠持续时间是为了模拟目的而设置的，并不代表实际的烹饪时间。
- en: In the case of `InterruptedException`, the thread’s interrupt flag is set again
    with `Thread.currentThread().interrupt()`, adhering to best practices in handling
    interruptions in Java.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在`InterruptedException`的情况下，线程的中断标志会再次通过`Thread.currentThread().interrupt()`设置，遵循Java中处理中断的最佳实践。
- en: 'Having seen the two examples, let us understand the key differences between
    concurrency and parallelism:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到这两个示例之后，让我们理解并发和并行之间的关键区别：
- en: '**Focus**: Concurrency is about managing multiple tasks, while parallelism
    is about executing tasks simultaneously for performance gains'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重点**：并发是关于管理多个任务，而并行是关于为了性能提升同时执行任务。'
- en: '**Execution**: Concurrency can work on single-core processors, but parallelism
    benefits from multi-core systems'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行**：并发可以在单核处理器上工作，但并行从多核系统中受益。'
- en: Both concurrency and parallelism play crucial roles in building efficient and
    responsive Java applications. The right approach for you depends on the specific
    needs of your program and the available hardware resources.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 并发和并行都在构建高效和响应式的Java应用程序中扮演着至关重要的角色。最适合你的方法取决于你程序的具体需求和可用的硬件资源。
- en: When to use concurrency versus parallelism – a concise guide
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用并发与并行——简明指南
- en: Armed with the strengths of concurrency and parallelism, let’s dive into picking
    the perfect tool. We’ll weigh up complexity, environment, and task nature to ensure
    that your Java applications sing. Buckle up, master chefs, as we unlock optimal
    performance and efficiency!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 借助并发和并行的优势，让我们深入探讨选择完美工具。我们将权衡复杂性、环境和任务性质，以确保您的Java应用程序能够发挥最佳性能。系好安全带，大师们，我们将解锁最佳性能和效率！
- en: Concurrency
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并发
- en: 'Concurrency is essential for effectively managing multiple operations simultaneously,
    particularly in three key areas:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 并发对于有效地同时管理多个操作至关重要，尤其是在以下三个关键领域：
- en: '**Simultaneous task management**: This is ideal for efficiently handling user
    requests and **Input/Output (I/O)** operations, especially with the use of non-blocking
    I/O. This technique allows programs to execute other tasks without waiting for
    data transfer to complete, significantly enhancing responsiveness and throughput.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同时任务管理**：这对于高效处理用户请求和**输入/输出（I/O）**操作非常理想，尤其是在使用非阻塞I/O的情况下。这种技术允许程序在数据传输完成之前执行其他任务，显著提高响应性和吞吐量。'
- en: '**Resource sharing**: Through synchronization tools such as locks, concurrency
    ensures safe access to shared resources among multiple threads, preserving data
    integrity and preventing conflicts.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源共享**：通过同步工具，如锁，并发确保了多个线程对共享资源的安全访问，从而保护数据完整性并防止冲突。'
- en: '**Scalability**: Scalability is crucial in developing systems capable of expansion
    such as microservices in cloud environments. Concurrency facilitates the execution
    of numerous tasks across different servers or processes, improving the system’s
    overall performance and capacity to handle growth.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：在开发能够扩展的系统（如云环境中的微服务）时，可扩展性至关重要。并发促进了在不同服务器或进程上执行多个任务，从而提高了系统的整体性能和应对增长的能力。'
- en: Let’s look at some examples to illustrate each of the three key areas where
    concurrency is essential.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些示例来说明并发在三个关键领域的重要性。
- en: 'The first example is related to simultaneous task management. Here is a web
    server handling multiple client requests concurrently using non-blocking I/O:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子与同时任务管理相关。以下是一个使用非阻塞I/O并发处理多个客户端请求的Web服务器示例：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this simplified example, the following happened:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简化的例子中，以下情况发生了：
- en: We created a `ServerSocketChannel` and bound it to a specific address and port.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个 `ServerSocketChannel` 并将其绑定到特定的地址和端口。
- en: We configured the server socket to be non-blocking using `configureBlocking(false)`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `configureBlocking(false)` 配置服务器套接字为非阻塞。
- en: Inside an infinite loop, we accepted incoming client connections using `serverSocket.accept()`.
    If a client is connected, we will proceed to handle the request.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个无限循环中，我们使用 `serverSocket.accept()` 接受客户端连接。如果客户端已连接，我们将继续处理请求。
- en: We configured the client socket to be non-blocking as well.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也将客户端套接字配置为非阻塞。
- en: We allocated a buffer to read the client request using `ByteBuffer.allocate()`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `ByteBuffer.allocate()` 分配了一个缓冲区来读取客户端请求。
- en: We read the request from the client socket into the buffer using `clientSocket.read(buffer)`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `clientSocket.read(buffer)` 将客户端套接字中的请求读取到缓冲区中。
- en: We processed the request and sent a response back to the client.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们处理请求并将响应发送回客户端。
- en: Finally, we closed the client socket.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们关闭了客户端套接字。
- en: This simplified example demonstrates the key concept of handling multiple client
    requests concurrently using non-blocking I/O. The server can accept and process
    requests from multiple clients without blocking, allowing for efficient utilization
    of system resources and improved responsiveness.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简化的例子演示了使用非阻塞I/O同时处理多个客户端请求的关键概念。服务器可以接受和处理来自多个客户端的请求而不会阻塞，从而提高系统资源的有效利用和响应性。
- en: Note that this example has been simplified for illustration purposes and may
    not include all the necessary error handling and edge case considerations of a
    production-ready web server.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个例子为了说明目的而简化了，可能不包括生产就绪型Web服务器所需的所有必要的错误处理和边缘情况考虑。
- en: 'The second example is resource sharing. Here is an example of multiple threads
    accessing a shared counter using synchronization:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子是资源共享。以下是一个多个线程使用同步访问共享计数器的示例：
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, multiple (`CounterThread`) threads accessed a shared `SynchronizedCounter`
    object. The `increment()` and `getCount()` methods of the counter were synchronized
    to ensure that only one thread could access them at a time, preventing race conditions
    and maintaining data integrity.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，多个（`CounterThread`）线程访问了一个共享的`SynchronizedCounter`对象。计数器的`increment()`和`getCount()`方法被同步，以确保一次只有一个线程可以访问它们，从而防止竞态条件和维护数据完整性。
- en: 'Now, let us see an example of scalability. Here is a code example of microservice
    architecture using concurrency to handle a large number of requests:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个可扩展性的例子。以下是一个使用并发处理大量请求的微服务架构的代码示例：
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, a microservice uses an `ExecutorService` with a fixed thread
    pool to handle a large number of requests concurrently. Each request is submitted
    as a task to the executor, which distributes them among the available threads.
    This allows the microservice to process multiple requests simultaneously, improving
    scalability and overall performance.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一个微服务使用具有固定线程池的`ExecutorService`来并发处理大量请求。每个请求都作为任务提交给执行器，执行器将它们分配给可用的线程。这使得微服务能够同时处理多个请求，从而提高可扩展性和整体性能。
- en: These examples demonstrate how concurrency is applied in different scenarios
    to achieve simultaneous task management, safe resource sharing, and scalability.
    They showcase the practical applications of concurrency in building efficient
    and high-performing systems.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了如何在不同的场景中应用并发，以实现同时任务管理、安全资源共享和可扩展性。它们展示了并发在构建高效和高性能系统中的实际应用。
- en: Parallelism
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并行计算
- en: 'Parallelism is a powerful concept used to enhance computing efficiency across
    various scenarios:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 并行计算是一个强大的概念，用于在各种场景中提高计算效率：
- en: '**Compute-intensive tasks**: It excels at deconstructing elaborate calculations
    into smaller, autonomous sub-tasks that can be executed in parallel. This method
    significantly streamlines complex computational operations.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算密集型任务**：它擅长将复杂的计算分解成更小、更自主的子任务，这些子任务可以并行执行。这种方法显著简化了复杂的计算操作。'
- en: '**Performance optimization**: By engaging multiple processor cores at once,
    parallelism substantially shortens the time needed to complete tasks. This simultaneous
    utilization of cores ensures a quicker, more efficient execution process.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能优化**：通过同时使用多个处理器核心，并行计算可以显著缩短完成任务所需的时间。这种核心的同时利用确保了更快、更高效的执行过程。'
- en: '**Large data processing**: Parallelism is key in swiftly handling, analyzing,
    and modifying vast datasets. Its capability to process multiple data segments
    concurrently makes it invaluable for big data applications and analytics.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大数据处理**：并行计算在快速处理、分析和修改大量数据集中起着关键作用。其能够同时处理多个数据段的能力使其在大型数据应用和分析中变得非常有价值。'
- en: Now let’s look at some short demo code examples to illustrate the concepts of
    parallelism in each of the mentioned scenarios.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些简短的代码示例，以说明在所提到的每个场景中并行计算的概念。
- en: 'First, let’s explore how parallelism can be applied to compute-intensive tasks,
    such as calculating Fibonacci numbers, using the `Fork/Join` framework in Java:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们探索如何将并行计算应用于计算密集型任务，例如使用Java中的`Fork/Join`框架计算斐波那契数：
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we used parallelism to compute the Fibonacci number of a given
    value `n`. The computation is split into subtasks using the `Fork/Join` framework.
    The `ParallelFibonacci` class extends `RecursiveAction` and overrides the `compute()`
    method. If the value of `n` is below a certain threshold, the Fibonacci number
    is computed sequentially. Otherwise, the task is split into two subtasks, which
    are forked for parallel execution. Finally, the results are joined to obtain the
    final Fibonacci number.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了并行计算来计算给定值`n`的斐波那契数。计算被分割成子任务，使用`Fork/Join`框架。`ParallelFibonacci`类扩展了`RecursiveAction`并重写了`compute()`方法。如果`n`的值低于某个阈值，斐波那契数将顺序计算。否则，任务将被分割成两个子任务，这些子任务被分叉以并行执行。最后，将结果合并以获得最终的斐波那契数。
- en: 'Next is performance optimization. Parallelism can significantly optimize performance,
    especially when dealing with time-consuming operations such as sorting large arrays.
    Let’s compare the performance of sequential and parallel sorting in Java:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是性能优化。并行计算可以显著优化性能，尤其是在处理耗时操作，如排序大型数组时。让我们比较Java中顺序排序和并行排序的性能：
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we demonstrated the performance optimization achieved by using
    parallelism for sorting a large array. We generated a random array of size 100,000,000
    and measured the time taken to sort the array using both sequential sorting (`Arrays.sort()`)
    and parallel sorting (`Arrays.parallelSort()`). Parallel sorting utilizes multiple
    processor cores to sort the array concurrently, resulting in faster execution
    compared to sequential sorting.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们展示了使用并行性对大型数组进行排序所实现的性能优化。我们生成了一个大小为1亿个元素的随机数组，并测量了使用顺序排序（`Arrays.sort()`）和并行排序（`Arrays.parallelSort()`）对数组进行排序所需的时间。并行排序利用多个处理器核心并发排序数组，与顺序排序相比，执行速度更快。
- en: 'Now, let’s turn to large data processing. Processing large datasets can be
    greatly accelerated by leveraging parallelism. In this example, we’ll demonstrate
    how parallel streams in Java can efficiently calculate the sum of a large number
    of elements:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向大数据处理。通过利用并行性，处理大量数据集可以大大加速。在这个例子中，我们将演示Java中的并行流如何有效地计算大量元素的求和：
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this code, we generated a large list of 100,000,000 integers using the `generateData`
    method. We then calculated the sum of all elements using both sequential and parallel
    streams.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们使用 `generateData` 方法生成了一个包含1亿个整数的长列表。然后，我们使用顺序流和并行流分别计算所有元素的总和。
- en: The sequential processing is performed using `data.stream()`, which creates
    a sequential stream from the data list. The `mapToInt(Integer::intValue)` operation
    converts each `Integer` object to its primitive `int` value, and the `sum()` method
    calculates the sum of all elements in the stream.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序处理使用 `data.stream()` 执行，它从数据列表创建一个顺序流。`mapToInt(Integer::intValue)` 操作将每个
    `Integer` 对象转换为它的原始 `int` 值，而 `sum()` 方法计算流中所有元素的总和。
- en: For parallel processing, we use `data.parallelStream()` to create a parallel
    stream. The parallel stream automatically splits the data into multiple chunks
    and processes them concurrently using available processor cores. The same `mapToInt(Integer::intValue)`
    and `sum()` operations are applied to calculate the sum of all elements in parallel.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于并行处理，我们使用 `data.parallelStream()` 创建并行流。并行流自动将数据分割成多个块，并使用可用的处理器核心并发处理它们。相同的
    `mapToInt(Integer::intValue)` 和 `sum()` 操作被应用于并行计算所有元素的总和。
- en: We measure the execution time of both sequential and parallel processing using
    `System.currentTimeMillis()` before and after each operation. By comparing the
    execution times, we can observe the performance improvement achieved by using
    parallelism.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每次操作前后使用 `System.currentTimeMillis()` 测量顺序和并行处理的执行时间。通过比较执行时间，我们可以观察到使用并行性所实现的性能提升。
- en: Choosing the right approach
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择正确的方法
- en: 'So, you’ve mastered the power of both concurrency and parallelism. Now comes
    the key question: how do you choose the right tool for the job? It’s a dance between
    performance gains and complexity, where environment and task characteristics play
    their part. Let’s dive into this crucial decision-making process:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你已经掌握了并发和并行性的力量。现在，关键问题来了：你如何选择合适的工具来完成这项工作？这是一个在性能提升和复杂性之间的舞蹈，其中环境和任务特性扮演着它们的角色。让我们深入了解这个关键决策过程：
- en: '**Complexity versus benefit**: Weigh the performance gain of parallelism against
    its increased complexity and potential debugging challenges'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性与收益的权衡**: 权衡并行性的性能提升与其增加的复杂性和潜在的调试挑战'
- en: '**Environment**: Consider your cloud infrastructure’s capability for parallel
    processing (number of available cores)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境**: 考虑你的云基础设施的并行处理能力（可用的核心数量）'
- en: '**Task nature and dependencies**: Independent, CPU-intensive tasks favor parallelism,
    while tasks with shared resources or I/O operations may benefit from concurrency'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务性质和依赖性**: 独立、CPU密集型任务更适合并行性，而具有共享资源或I/O操作的任务可能从并发中受益'
- en: We’ve just equipped you with the culinary secrets of concurrency and parallelism,
    the dynamic duo that powers efficient Java applications. Remember, concurrency
    juggles multiple tasks like a master chef, while parallelism unleashes the power
    of multi-core machines for lightning-fast performance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚为你提供了并发和并行性的烹饪秘诀，这对动态的Java应用程序提供了动力。记住，并发像一位大师厨师一样处理多个任务，而并行性则释放了多核机器的闪电般性能。
- en: Why is this culinary wisdom so crucial? In the cloud-native world, Java shines
    as a versatile chef, adapting to diverse tasks. Concurrency and parallelism become
    your essential tools, ensuring responsiveness to user requests, handling complex
    calculations, and processing massive data – all on the ever-evolving canvas of
    the cloud.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '为什么这种烹饪智慧如此关键？在云原生世界中，Java作为一个多才多艺的大厨，适应着各种任务。并发和并行成为你的基本工具，确保对用户请求的响应性，处理复杂的计算，以及处理大量数据——所有这些都在不断演变的云画布上。 '
- en: Now let’s take this culinary expertise to the next level. In the next section,
    we’ll explore how these concurrency and parallelism skills seamlessly blend with
    cloud technologies to build truly scalable and high-performance Java applications.
    So sharpen your knives and get ready to conquer the cloud-native kitchen!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这种烹饪专长提升到新的水平。在下一节中，我们将探讨这些并发和并行技能如何无缝地与云计算技术结合，以构建真正可扩展和性能卓越的Java应用程序。所以磨快你的刀具，准备征服云原生厨房！
- en: Java and the cloud – a perfect alliance for cloud-native development
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java与云——云原生开发的完美联盟
- en: Java’s journey with cloud computing is a testament to its adaptability and innovation.
    The fusion of their capabilities has created a powerful alliance for cloud-native
    development. Imagine yourself as an architect, wielding Java’s toolkit at the
    forefront of cloud technology. Here, Java’s versatility and robustness partner
    with the cloud’s agility and scalability to offer a canvas for innovation and
    growth. We’re not just discussing theoretical concepts – we’re stepping into a
    realm where Java’s pragmatic application in the cloud has revolutionized development,
    deployment, and application management. Let’s uncover how Java in the cloud era
    is not just an option, but a strategic choice for developers seeking to unlock
    the full potential of cloud-native development.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Java与云计算的旅程证明了其适应性和创新性。它们能力的融合为云原生开发创造了一个强大的联盟。想象一下，自己作为一名建筑师，在云计算技术的前沿使用Java的工具箱。在这里，Java的灵活性和稳健性与云的敏捷性和可扩展性相结合，为创新和增长提供了画布。我们不仅讨论理论概念，而且正步入一个领域，Java在云时代的实用应用已经彻底改变了开发、部署和应用管理。让我们揭示Java在云时代不仅仅是一个选择，而是寻求解锁云原生开发全部潜力的开发者的一项战略选择。
- en: Exploring cloud service models and their impact on software development
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索云服务模型及其对软件开发的影响
- en: Java development has entered a new era with cloud computing. Imagine having
    instant access to a vast pool of virtual resources, from servers to storage to
    networking. Cloud services unlock this magic, empowering Java developers to build
    and scale applications faster and more efficiently.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云计算的发展，Java开发进入了新时代。想象一下，能够即时访问从服务器到存储再到网络的庞大虚拟资源池。云服务解锁了这种魔力，赋予Java开发者更快、更高效地构建和扩展应用程序的能力。
- en: Three distinct service models dominate the cloud, each impacting development
    needs and Java application architecture. Let us explore each one of them.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 三种不同的服务模型主导着云，每种都对开发需求和Java应用程序架构产生影响。让我们逐一探索它们。
- en: Infrastructure as a service
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础设施即服务
- en: '**Infrastructure as a Service** (**IaaS**) offers foundational cloud computing
    resources such as virtual machines and storage. For Java developers, this means
    complete control over the operating environment, allowing for customized Java
    application setups and optimizations. However, it requires a deeper understanding
    of infrastructure management.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**基础设施即服务** (**IaaS**) 提供了基础云计算资源，如虚拟机和存储。对于Java开发者来说，这意味着对操作环境的完全控制，允许定制Java应用程序设置和优化。然而，这需要更深入的基础设施管理理解。'
- en: Code example – Java on IaaS (Amazon EC2)
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码示例——Java在IaaS（Amazon EC2）上
- en: 'This code snippet showcases how to create and launch an Amazon **Elastic Compute
    Cloud** (**EC2**) instance using the AWS SDK for Java:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码示例展示了如何使用Java AWS SDK创建并启动一个Amazon **弹性计算云** (**EC2**)实例：
- en: '[PRE8]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s break it down step by step:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步来分析：
- en: '`// Create` `EC2 client`'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`// 创建` `EC2 客户端`'
- en: '`AmazonEC2Client ec2Client =` `new AmazonEC2Client();`'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AmazonEC2Client ec2Client =` `new AmazonEC2Client();`'
- en: '`setImageId`: The `setInstanceType`: We define the instance type, such as `t2.micro`,
    for a small, cost-effective option'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setImageId`: The `setInstanceType`: 我们定义实例类型，例如 `t2.micro`，作为一个小巧且经济的选项'
- en: '`setMinCount`: We specify the minimum number of instances to launch (`1` in
    this case)'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setMinCount`: 我们指定要启动的实例的最小数量（在这种情况下为`1`）'
- en: '`setMaxCount`: We specify the maximum number of instances to launch (`3` in
    this case, allowing the system to scale up if needed)'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`runInstances` method on the `ec2Client` object, passing the configured `runRequest`
    object. This sends the request to AWS to launch the desired EC2 instances.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`runInstances` method returns a `RunInstancesResult` object containing information
    about the launched instances. We will extract the instance ID of the first instance
    (assuming a successful launch) for further use in the deployment process.'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Configure Tomcat and deploy application**: This comment indicates that the
    next steps will involve setting up Tomcat on the launched EC2 instance and deploying
    your web application. The specific code for this would depend on your chosen Tomcat
    installation method and application deployment strategy.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This example demonstrates launching instances with a minimum and maximum count.
    You can adjust these values based on your desired level of redundancy and scalability.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Platform as a service
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Platform as a Service** (**PaaS**) provides a higher-level environment with
    ready-to-use platforms including operating systems and development tools. This
    is beneficial for Java developers as it simplifies deployment and management,
    though it might limit lower-level control.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Code example – Java on AWS Lambda
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This code snippet defines a simple Java Lambda function that processes an S3
    object upload event:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This code is a listener for Amazon S3 object uploads. It’s like a robot that
    watches for new files in a specific bucket (such as a folder) and automatically
    does something with them when they arrive:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'It checks for new files in the bucket: for each new file, it gets the filename
    and the bucket it’s in'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You need to fill in the missing part: write your own code here to say what
    you want the robot to do with the file (e.g., download it, analyze it, or send
    an email)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the robot finishes with all the files, it sends a message back to Amazon
    saying **Processing complete**.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: I hope this simplified explanation makes things clearer!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Software as a service
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Software as a service** (**SaaS**) delivers complete application functionality
    as a service. For Java developers, this often means focusing on building the application’s
    business logic without worrying about the deployment environment. However, customization
    and control over the platform are limited.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Code example – Java on SaaS (AWS Lambda)
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This code snippet defines a Lambda function for processing event data:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code defines a class called `LambdaHandler` that listens for events in
    a serverless environment such as AWS Lambda. Here’s a breakdown:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Listening for events:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The class is named `LambdaHandler`, signifying its role as a handler for Lambda
    events.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `handleRequest` method is the entry point for processing incoming events.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The event parameter holds the data received from the Lambda invocation.
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Processing data:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `handleRequest` method, the code retrieves the message key from the
    event data using `event.get("message")`.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This assumes that the event format includes a key named `message` containing
    the actual data to be processed.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The code then processes the message and combines it with a prefix to generate
    a new string stored in the result variable.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returning result:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the `handleRequest` method returns the processed message stored in
    the result variable. This is the response that is sent back to the caller of the
    Lambda function.
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In simpler terms, this code acts like a small service that takes in data (messages)
    through an event, processes it (adds a prefix), and returns the updated version.
    It’s a simple example of how Lambda functions can handle basic data processing
    tasks in a serverless environment.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the strengths and weaknesses of each cloud service model is crucial
    for Java developers to be able to make the best decisions for their projects.
    By choosing the right model, they can unlock the immense potential of cloud computing
    and revolutionize the way in which they build and deploy Java applications.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Java’s transformation in the cloud – a story of innovation
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine a world transformed by the cloud, where applications soar among the
    constellations of data centers. This is the landscape Java navigates today, not
    as a relic of the past, but as a language reborn in the fires of innovation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: At the heart of this evolution lies the **Java Virtual Machine** (**JVM**),
    the engine that powers Java applications. Once again, it has transformed, shedding
    layers of inefficiency to become lean and mean, ready to conquer the resource-constrained
    world of the cloud.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: But power alone is not enough. Security concerns loom large in the vastness
    of the cloud. Java, ever vigilant, has donned the armor of robust security features,
    ensuring that its applications remain unbreachable fortresses in the digital realm.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Yet size and security are mere tools without purpose. Java has embraced the
    new paradigm of microservices, breaking down monolithic structures into nimble,
    adaptable units. Frameworks such as Spring Boot and MicroProfile stand as a testament
    to this evolution, empowering developers to build applications that dance with
    the dynamism of the cloud.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: As the cloud offers its vast array of services, Java stands ready to embrace
    them all. Its vast ecosystem and robust APIs act as bridges, connecting applications
    to the boundless resources at their fingertips.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: This is not just a story of technical advancement, it’s a testament to the power
    of adaptability and of embracing change and forging a new path in the ever-evolving
    landscape of the cloud.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Java – the cloud-native hero
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java sits comfortably on the throne of cloud-native development. Here’s why:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '**Platform agnostic**: *Write once, run anywhere* is a feature of Java applications.
    These cloud-agnostic Java applications effortlessly dance across platforms, simplifying
    deployment across diverse cloud infrastructures.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability and performance**: Java pairs perfectly with the cloud’s inherent
    scalability, handling fluctuating workloads with ease. Built-in garbage collection
    and memory management further optimize resource utilization and drive high performance.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security first**: Java’s robust security features, such as sandboxing and
    strong type checking, shield applications from common vulnerabilities, making
    them ideal for the security-conscious cloud environment.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rich ecosystem**: A vast and mature ecosystem of libraries, frameworks, and
    tools caters specifically to cloud-native development, empowering developers to
    build faster and with less effort.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservices champion**: Java’s modularity and object-oriented design perfectly
    align with the growing trend of microservices architecture, allowing developers
    to build and scale independent services easily.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CI/CD ready**: Java integrates seamlessly with popular **continuous integration**
    (**CI**) and **continuous deployment** (**CD**) tools and methodologies, enabling
    automated builds, tests, and deployments for rapid cloud-native application delivery.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency king**: Java’s built-in concurrency features, such as threads
    and thread pools, empower developers to create highly concurrent applications
    that leverage the parallel processing capabilities of cloud computing.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Community and support**: Java boasts a vibrant community and a wealth of
    online resources and documentation, providing invaluable support for developers
    working with cloud-native Java applications.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, Java’s inherent characteristics and compatibility with modern
    cloud architectures make it the natural hero for cloud-native development. With
    its rich ecosystem and robust security features, Java empowers developers to build
    and deploy high-performing, scalable, and secure cloud-native applications.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Java’s cloud-focused upgrades – concurrency and beyond
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The cloud demands efficient and scalable applications, and Java continues to
    evolve to meet this need. Here’s a spotlight on key updates for cloud-native development,
    focusing on concurrency and parallelism.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Project Loom – virtual threads for efficient concurrency
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine handling a multitude of concurrent tasks without worrying about resource
    overhead. Project Loom introduces lightweight virtual threads, enabling efficient
    management of high concurrency. This is ideal for cloud environments where responsiveness
    and resource efficiency are paramount.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced garbage collection for high throughput
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Say goodbye to long garbage collection pauses impacting performance. Recent
    Java versions introduce low-pause, scalable garbage collectors such as ZGC and
    Shenandoah GC. These handle large heaps with minimal latency, ensuring smooth
    operation and high throughput even in demanding cloud environments.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Record types – simplifying data modeling
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cloud applications frequently deal with data transfer objects and messaging
    between services. Record types, introduced in Java 16, simplify immutable data
    modeling, offering a concise and efficient way to represent data structures. This
    improves code readability, reduces boilerplate code, and ensures data consistency
    in cloud-based microservices.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Sealed classes – controlled inheritance hierarchies
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Have you ever wanted to enforce specific inheritance rules in your cloud application?
    Sealed classes, finalized in Java 17, allow you to restrict which classes or interfaces
    can extend or implement others. This promotes clarity, maintainability, and predictable
    behavior within cloud-based domain models.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Other notable updates for cloud development
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to these key updates related to concurrency and parallelism, there
    are many other improvements. Here are a few:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '**Pattern matching for instanceof**: Offers a cleaner and more concise solution
    for checking and casting object types, improving code readability and reducing
    boilerplate'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Foreign-memory access API**: Allows Java programs to safely and efficiently
    access memory outside the Java heap, unlocking performance potential and facilitating
    seamless integration with native libraries'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP client API**: Simplifies HTTP and WebSocket communication for cloud
    applications, enabling developers to build robust and high-performance clients
    for effective communication within the cloud ecosystem'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microbenchmark suite**: Helps in accurately measuring the performance of
    code snippets, allowing for precise performance tuning and ensuring your cloud
    applications run at their peak potential'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These advancements demonstrate Java’s commitment to empowering developers to
    build robust, scalable, and high-performing cloud applications. By leveraging
    these features, developers can unlock the full potential of Java in the cloud
    and create innovative solutions for the evolving digital landscape.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples of successful cloud-native Java applications
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java isn’t just a programming language; it’s a powerhouse fueling some of the
    world’s most innovative companies. Let’s take a peek behind the scenes of four
    industry leaders and see how Java drives their success.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Netflix – microservices maestro
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine millions of people streaming movies and shows simultaneously, without
    a hiccup. That’s the magic of Netflix’s microservices architecture, which was
    meticulously crafted with Java. Spring Boot and Spring Cloud act as the architects,
    building individual services that work together seamlessly. When things get bumpy,
    Hystrix, a Netflix-born Java library, acts as the knight in shining armor, isolating
    issues and keeping the show running. Zuul, another Java gem, stands guard at the
    edge, routing traffic and ensuring everything flows smoothly.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: LinkedIn – data’s real-time river
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: LinkedIn’s vibrant network thrives on real-time data. And who keeps this information
    flowing like a mighty river? Apache Kafka, a Java-powered stream processing platform.
    Kafka’s lightning-fast speed and fault tolerance ensure connections are always
    live, allowing for instant updates and personalized experiences. Plus, Kafka seamlessly
    integrates with other Java-based systems at LinkedIn, creating a powerful data
    processing symphony.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: X – from Ruby on Rails to the JVM’s soaring heights
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember the days of slow-loading tweets? X (formerly Twitter) does! To conquer
    the challenge of scale, they made a bold move: migrating from Ruby on Rails to
    the JVM. This switch, powered by Java and Scala, unlocked a new era of performance
    and scalability. Finagle, a Twitter-built RPC system for the JVM, further boosted
    concurrency. This allowed millions of tweets to take flight simultaneously.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Alibaba – the e-commerce titan forged in Java
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When it comes to online shopping, Alibaba reigns supreme. And what’s their secret
    weapon? Java! From handling massive spikes in traffic to managing complex data
    landscapes, Java’s ability to handle high concurrency is Alibaba’s golden ticket
    to success. They’ve even optimized Java’s garbage collection to efficiently manage
    their immense heap size, ensuring that their platform runs smoothly even when
    billions of items are flying off the virtual shelves.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: These are just a few examples of how Java empowers industry leaders. From streaming
    giants to social media havens and e-commerce titans, Java’s versatility and power
    are undeniable. So, next time you watch a movie, share a post, or click *buy*,
    remember – there’s a good chance Java is quietly pulling the strings, making your
    experience seamless and magical.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: We’ve explored Java’s hidden superpower – its seamless integration with the
    cloud! From concurrency and parallelism to microservices architecture, Java empowers
    developers to build robust, scalable, and high-performing cloud-native applications.
    We’ve seen how Netflix, LinkedIn, X, and Alibaba leverage Java’s diverse capabilities
    to achieve their cloud goals.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: But the cloud journey isn’t without its challenges. Security, cost optimization,
    and efficient resource management all come knocking at the door of your cloud-native
    development. In the next section, we’ll dive deep into these modern challenges,
    equipping you with the knowledge and tools to navigate them like a seasoned cloud
    explorer. So buckle up, fellow Java adventurers, as we venture into the exciting
    realm of modern challenges in cloud-native development!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Modern challenges in cloud-native concurrency and Java’s weapons of choice
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The cloud’s concurrency challenges loom, but Java’s not backing down. We’ll
    tackle these challenges in transactions, data consistency, and microservices states,
    all while wielding tools such as Akka, Vert.x, and reactive programming. Choose
    your weapons wisely, for the cloud-native concurrency challenge is yours to conquer!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Wrangling distributed transactions in Java – beyond classic commits
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the wild jungle of distributed systems, managing transactions across services
    and databases can be a daunting task. Traditional methods stumble over network
    delays, partial failures, and diverse systems. But fear not, Java warriors! We’ve
    got your back with a robust arsenal of solutions:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '**Two-phase commit (2PC)**: This classic protocol ensures all parties in a
    transaction commit or roll back together. While not ideal for high-speed environments
    due to its blocking nature, 2PC remains a reliable option for more controlled
    transactions.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Saga pattern**: Think of this as a choreographed dance, where each local
    transaction is linked to others through a sequence of events. Java frameworks
    such as Axon and Eventuate help you orchestrate this graceful ballet, ensuring
    data consistency even when things get messy.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compensating transactions**: Imagine a safety net for your saga. If a step
    goes wrong, compensating transactions swoop in, reversing the effects of previous
    operations and keeping your data safe. Java services can implement this strategy
    with service compensations, which are ready to clean up any spills.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining data consistency in cloud-native Java applications
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Data consistency in the cloud can be a tricky tango, especially with NoSQL’s
    eventual rhythm. But Java’s got the notes to keep it harmonious:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '**Kafka’s eventual beat**: Updates become rhythmic pulses, sent out and listened
    to by services. It’s not immediate, but everyone eventually grooves to the same
    tune.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching whispers**: Tools such as Hazelcast and Ignite act as quick assistants,
    keeping data consistent across nodes, even when the main database takes a break.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entity versioning**: When two updates waltz in at once, versioning helps
    us track who came first and resolve conflicts gracefully. No data mosh pits here!'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these moves and a bit of Java magic, your cloud applications will keep
    your data safe and sound, moving in perfect rhythm.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Handling state in microservices architectures
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Microservices are a beautiful dance of independent services, but what about
    their state? Managing it across this distributed landscape can feel like wrangling
    a herd of wild cats. But fear not, Java offers a map and a torch to guide you
    through:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '**Stateless serenity**: When possible, design microservices as stateless citizens
    of the cloud. This keeps them lightweight, scalable, and effortlessly resilient.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distributed session sherpas**: For those services that crave a bit of state,
    distributed session management tools such as Redis and ZooKeeper come to the rescue.
    They keep track of state across nodes, ensuring everyone’s on the same page.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CQRS and event sourcing – the stateful waltz**: For truly complex state dances,
    patterns such as **Command Query Responsibility Segregation** (**CQRS**) and Event
    Sourcing offer a graceful solution. Java frameworks such as Axon provide the perfect
    shoes for this intricate choreography.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these strategies in your arsenal, you can navigate the stateful microservices
    maze with confidence, building resilient and scalable systems that thrive in the
    ever-changing cloud landscape.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Cloud database concurrency – Java’s dance moves for shared resources
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine a crowded dance floor – that’s your cloud database with multiple clients
    vying for attention. It’s a delicate tango of multi-tenancy and resource sharing.
    Keeping everyone in step requires some fancy footwork.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Atomicity, Consistency, Isolation, and Durability** (**ACID**) test adds
    another layer of complexity. Messy concurrency can easily trip up data integrity,
    especially in distributed environments. Java’s got your back with a few fancy
    footwork moves:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '**Sharing (with manners)**: Multi-tenancy and resource sharing are no problem
    with Java’s locking mechanisms, which include synchronized blocks and ReentrantLock.
    They act as bouncers, ensuring everyone gets their turn without stepping on toes
    (or data).'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimistic versus pessimistic locking**: Think of these as different dance
    styles. Optimistic locking assumes that everyone plays nice, while pessimistic
    locking keeps a watchful eye, preventing conflicts before they happen. Java frameworks
    such as JPA and Hibernate offer both styles, letting you choose the perfect rhythm.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching the craze**: Frequently accessed data gets its own VIP lounge: the
    distributed cache. Java solutions such as Hazelcast and Apache Ignite keep this
    lounge stocked, reducing database load and ensuring smooth data access for everyone.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these moves in your repertoire, your Java applications can waltz gracefully
    through cloud database concurrency, ensuring data consistency and smooth performance
    even when the dance floor gets crowded.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Parallelism in big data processing frameworks
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine waves of data, rushing in like a flood. You need a way to analyze it
    all – fast. That’s where parallel processing comes in, and Java’s got the tools
    to tackle it:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '**MapReduce**: Java is extensively used in MapReduce programming models, as
    seen in Hadoop. Developers write Map and Reduce functions in Java to process large
    datasets in parallel across a Hadoop cluster.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apache Spark**: Although it is written in Scala, Spark provides Java APIs.
    It enables parallel data processing by distributing data across **Resilient Distributed
    Datasets** (**RDDs**) and executing operations in parallel.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stream processing**: Java Stream API, along with tools such as Apache Flink
    and Apache Storm, supports parallel stream processing for real-time data analytics.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, when data gets overwhelming, remember Java. It’s got the tools to keep you
    informed and in control, even when the beast roars!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will kick off the thrilling journey into concurrency and parallelism
    in the cloud-native Java world. Get ready to transform these challenges into opportunities.
    In the pages ahead, you’ll acquire the tools to master concurrency and parallelism.
    This will empower you to build robust, future-proof Java applications that thrive
    in the cloud.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Cutting-edge tools for conquering cloud-native concurrency challenges
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The intricate dance of concurrency in cloud-native applications can be daunting,
    but fear not! Cutting-edge tools and techniques are here to help. Let’s explore
    some tools to address the challenges we discussed earlier.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-native concurrency toolkits
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following tools fit well into this category:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '**Akka**: This powerful toolkit leverages the actor model for building highly
    scalable and fault-tolerant applications. It provides features such as message
    passing, supervision, and location transparency, simplifying concurrent programming
    and addressing challenges such as distributed locks and leader election.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vert.x**: This lightweight toolkit focuses on reactive programming and non-blocking
    I/O, making it ideal for building highly responsive and performant applications.
    Vert.x’s event-driven architecture can handle high concurrency effectively and
    simplifies asynchronous programming.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lagom**: This framework is built on top of Akka and offers a high-level API
    for building microservices. Lagom provides features such as service discovery,
    load balancing, and fault tolerance, making it suitable for building complex,
    distributed systems.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed coordination mechanisms
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tools in this category include the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '**ZooKeeper**: This open source tool provides distributed coordination primitives
    such as locking, leader election, and configuration management. ZooKeeper’s simplicity
    and reliability make it a popular choice for coordinating distributed applications.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**etcd**: This distributed key-value store provides a high-performance and
    scalable means to store and manage configuration data across nodes. etcd’s features,
    including watches and leases, make it suitable for maintaining consistency and
    coordinating state changes in distributed systems.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consul**: This service mesh solution offers a comprehensive set of features
    for service discovery, load balancing, and distributed coordination. Consul’s
    web UI and rich API make it easy to manage and monitor distributed systems.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modern asynchronous programming patterns
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These modern asynchronous patterns enable efficient non-blocking data processing
    and scalable, resilient applications:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '**Reactive Streams**: This specification provides a standard way to write asynchronous,
    non-blocking programs. Reactive Streams improves responsiveness and scalability
    by ensuring that data is processed efficiently and that backpressure is managed
    effectively.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous messaging**: This technique utilizes message queues to decouple
    components and handle tasks asynchronously. Asynchronous messaging can improve
    scalability and resilience by enabling parallel processing and handling failures
    gracefully.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the right tool for the job
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each toolkit, mechanism, and pattern has its own strengths and weaknesses,
    making them suitable for different scenarios. Here are some considerations:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '**Complexity**: Akka offers rich features but can be complex to learn and use.
    Vert.x and Lagom provide a simpler starting point.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: All three toolkits are highly scalable but Vert.x excels for
    high-performance applications due to its non-blocking nature.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coordination needs**: ZooKeeper is well-suited for basic coordination tasks,
    while etcd’s key-value store offers additional flexibility. Consul provides a
    complete service mesh solution.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Programming style**: Reactive Streams requires a shift in thinking toward
    asynchronous programming, while asynchronous messaging can be integrated with
    traditional synchronous approaches.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By understanding the available solutions and their trade-offs, developers can
    choose the right tools and techniques to address specific concurrency challenges
    in their cloud-native applications. This, in turn, leads to building more scalable,
    responsive, and resilient systems that thrive in the dynamic cloud environment.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Conquering concurrency – best practices for robust cloud-native applications
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building cloud apps that juggle multiple tasks at once? It’s like managing
    a bustling zoo of data and operations! But fear not, because we’ve got the best
    practices to tame the concurrency beasts and build robust, scalable cloud apps.
    Here are the best practices to embed:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '**Early identification**: Proactively identify and address concurrency challenges
    through early analysis, modeling, and code review:'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analyze application requirements**: Identify critical sections, shared resources,
    and potential points of contention early in the design phase'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use concurrency modeling tools**: Utilize modeling tools such as statecharts
    or Petri nets to visualize and analyze potential concurrency issues'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Review existing code for concurrency bugs**: Conduct code reviews and static
    analysis to identify potential race conditions, deadlocks, and other concurrency
    problems'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embrace immutable data**: Embrace unchangeable data to simplify concurrent
    logic and eliminate race conditions:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimize mutable state**: Design data structures and objects to be immutable
    by default. This simplifies reasoning about their behavior and eliminates potential
    race conditions related to shared state modifications.'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utilize functional programming principles**: Leverage functional programming
    techniques such as immutability, pure functions, and laziness to create inherently
    thread-safe and predictable concurrent code.'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ensure thread safety**: Secure concurrent access to shared resources through
    synchronized blocks, thread-safe libraries, and focused thread confinement'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use synchronized blocks or other locking mechanisms**: Protect critical sections
    of code that access shared resources to prevent concurrent modifications and data
    inconsistencies'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leverage thread-safe libraries and frameworks**: Choose libraries and frameworks
    that are specifically designed for concurrent programming and utilize their thread-safe
    functionalities'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Employ thread confinement patterns**: Assign threads to specific tasks or
    objects to limit their access to shared resources and simplify reasoning about
    thread interactions'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Design for failure**: Build resilience against concurrency failures through
    fault tolerance mechanisms, proactive monitoring, and rigorous stress testing'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implement fault tolerance mechanisms**: Design your application to handle
    and recover from concurrency-related failures gracefully. This includes retry
    mechanisms, circuit breakers, and fail-over strategies.'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitor and observe concurrency behavior**: Employ monitoring tools and observability
    practices to identify and diagnose concurrency issues in production environments.'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conduct stress testing**: Perform rigorous stress testing to evaluate how
    your application behaves under high load and identify potential concurrency bottlenecks.'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leverage cloud-native tools**: Harness the power of cloud-native tools such
    as asynchronous patterns, distributed coordination, and dedicated frameworks to
    conquer concurrent challenges and build robust, scalable cloud applications'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utilize asynchronous programming patterns**: Embrace asynchronous programming
    models such as reactive streams and asynchronous messaging to improve scalability
    and responsiveness in concurrent applications'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adopt distributed coordination mechanisms**: Utilize distributed coordination
    tools such as ZooKeeper, etcd, or Consul to manage distributed state and ensure
    consistent operation across multiple nodes'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Choose appropriate concurrency frameworks**: Leverage cloud-native concurrency
    frameworks such as Akka, Vert.x, or Lagom to simplify concurrent programming and
    address specific concurrency challenges effectively'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With a solid understanding of best practices, let's turn our attention to code.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Code examples illustrating best practices
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at some code examples.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming with reactive streams
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can leverage reactive streams such as RxJava to implement an asynchronous
    processing pipeline. This allows for the concurrent execution of independent tasks,
    improving responsiveness and throughput. Here is a code example using reactive
    streams:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code defines a service for handling user requests in a reactive way. Think
    of it as a waiter at a restaurant who takes your order (user ID) and brings back
    your food (user information).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the key points to be noted from the preceding code:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '`UserService` defines the service contract, promising to get a user by ID.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UserServiceImpl` provides the actual logic for fetching the user.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mono` from reactive streams, meaning the user data is delivered asynchronously,
    like a waiter who tells you your food is coming later.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`600` milliseconds) and then returns a `User` object with the ID and name.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getUserById` with a user ID, and it returns `Mono` containing the user data.
    You can then `subscribe` to `Mono` to receive the user information later when
    it’s ready.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, this code shows how to define and implement a reactive service in
    Java using an interface and `Mono` to handle asynchronous data retrieval.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-native concurrency frameworks
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Akka is a popular cloud-native concurrency framework that provides powerful
    tools for building highly scalable and resilient applications. It offers features
    such as actor-based message passing, fault tolerance, and resource management.
    Here is an example of handling user requests asynchronously:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the example provided, `UserActor` class in Akka defines an actor that handles
    user requests asynchronously. The class provides a static `props()` method for
    actor instantiation, encapsulating its creation logic. In the `createReceive()`
    method, the actor defines its behavior by using the `receiveBuilder()` to match
    messages of type `GetUserRequest`. When such a message is received, it delegates
    the handling to the private `handleGetUserRequest()` method.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: The `handleGetUserRequest()` method simulates a delay of 600 milliseconds to
    represent fetching user data. After the delay, it creates a `User` object with
    the provided user ID and a hardcoded name `"Jack Smith"`. The actor then sends
    a `GetUserResponse` message containing the `User` object back to the sender using
    `getSender()` and `getSelf()`. This design ensures that each request is processed
    independently, allowing the system to handle multiple concurrent requests efficiently.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: In short, this code uses an actor model to handle user requests asynchronously.
    The actor receives tasks, works on them, and sends back results, making your application
    more responsive and efficient.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Distributed coordination with ZooKeeper
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imagine that our application now scales to multiple nodes. To maintain a consistent
    state across the nodes and prevent conflicts, we can utilize a distributed coordination
    tool such as ZooKeeper. The following is an example of using ZooKeeper:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This code snippet sets up a simple system to track processed requests using
    ZooKeeper, a distributed coordination service. Here’s a breakdown:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '`/processed-requests` to store processed request IDs.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requestId`), the code checks whether a node with that ID already exists under
    the called/processed-requests node.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requestId` is created under the called or processed-requests to mark it as
    processed.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think of it like a checklist in ZooKeeper. Each request has its own checkbox.
    Checking it means it’s been dealt with. This ensures that requests are not processed
    multiple times, even if the connection drops or the server restarts.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: By integrating these best practices into your development process, you can build
    cloud-native applications that are not only highly functional but also robust
    and resilient to the complexities of concurrency. Remember, embracing concurrency-first
    design is not just about solving immediate problems. It’s also about building
    a foundation for future scalability and sustainable growth in the dynamic cloud
    environment.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring consistency – the bedrock of robust concurrency strategies
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the dynamic realm of cloud-native applications, concurrency is an ever-present
    companion. Achieving consistent concurrency strategies throughout your application
    is crucial for ensuring its reliability, scalability, and performance. This consistent
    approach offers several key benefits.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Predictability and stability
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consistent concurrency strategies unify your code, simplifying development
    and boosting stability through predictable behavior:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '**Uniformity**: Utilizing consistent concurrency strategies across the application
    promotes predictability and stability. Developers can rely on established patterns
    and behaviors, leading to easier code comprehension, maintenance, and debugging.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced complexity**: By avoiding a patchwork of ad hoc solutions, developers
    can focus on core functionalities instead of constantly reinventing the wheel
    for concurrency management.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging standard libraries and frameworks
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Leverage established libraries and frameworks for built-in expertise, optimized
    performance, and reduced development overhead in concurrent projects:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliability and expertise**: Utilizing established libraries and frameworks
    designed for concurrent programming leverages the expertise and best practices
    embedded within them. These tools often offer built-in thread safety, error handling,
    and performance optimizations.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced overhead**: Standard libraries often offer optimized implementations
    for common concurrency tasks, reducing development time and overhead compared
    to building custom solutions from scratch.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pitfalls of ad hoc solutions
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the potential issues with using ad hoc concurrency solutions:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '**Hidden bugs and pitfalls**: Ad hoc concurrency solutions can introduce subtle
    bugs and performance issues that are difficult to detect and debug. These problems
    may surface only under specific conditions or high loads, leading to unexpected
    failures.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability challenges**: Implementing and maintaining ad hoc solutions
    can become cumbersome and error-prone over time. This complexity can hinder future
    development and collaboration efforts.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared standards and reviews for robust code
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Shared guidelines and reviews prevent concurrency chaos, ensuring consistent,
    reliable code through teamwork:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '**Establish guidelines and standards**: Define clear guidelines and standards
    for concurrency management within your development team. This should include preferred
    libraries, frameworks, and coding practices to be followed.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utilize code reviews and peer programming**: Encourage code reviews and peer
    programming practices to identify potential concurrency issues early and ensure
    adherence to established guidelines. Consider using checklists or specific review
    techniques tailored for concurrency concerns.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emphasize testing and quality assurance
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Concurrency in cloud-native Java applications introduces unique testing challenges.
    To ensure robust and resilient applications, address these challenges head-on
    with targeted testing strategies:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '**Concurrency-focused unit testing**: Use unit tests to isolate and examine
    the behavior of individual components under concurrent scenarios. This includes
    testing for thread safety and handling of shared resources.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration testing for distributed interactions**: Conduct integration tests
    to ensure that different components interact correctly under concurrent conditions,
    especially in microservices architectures common in cloud environments.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance and stress testing**: Stress test your application under high
    load to uncover issues such as deadlocks or livelocks that only emerge under specific
    conditions or heavy concurrent access.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated testing for efficiency**: Implement automated tests using frameworks
    such as JUnit, focusing on scenarios that mimic concurrent operations. Use mock
    testing frameworks to simulate complex concurrency scenarios and dependencies.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency testing tools**: Leverage tools such as JMeter, Gatling, Locust,
    or Tsung to test how your application handles high concurrent loads. This helps
    you identify performance bottlenecks and scalability issues in cloud-native environments.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ongoing commitment**: Maintaining consistent concurrency strategies is an
    ongoing commitment. Regularly review and revise your approach as your application
    evolves and new libraries, frameworks, and best practices emerge. By fostering
    a culture of consistency and continuous improvement, you can build reliable, scalable,
    and performant cloud-native applications that thrive in the ever-changing digital
    landscape.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining consistent concurrency strategies is an ongoing commitment. Regularly
    review and revise your approach as your application evolves and new libraries,
    frameworks, and best practices emerge. By fostering a culture of consistency and
    continuous improvement, you can build reliable, scalable, and performant cloud-native
    applications that thrive in the ever-changing digital landscape.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[*Chapter 1*](B20937_01.xhtml#_idTextAnchor014) introduced the fundamental
    concepts of Java cloud-native development, focusing on concurrency and parallelism.
    It distinguished between managing tasks on single-core (concurrency) versus multi-core
    processors (parallelism), with practical Java examples. The chapter highlighted
    Java’s role in cloud computing, emphasizing its scalability, ecosystem, and community.
    Practical applications, including the Java AWS SDK and Lambda functions, illustrated
    Java’s adaptability across cloud models.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Significant Java updates such as Project Loom and advanced garbage collection
    methods were discussed for optimizing performance. Java’s effectiveness in complex
    environments was showcased through case studies of Netflix and X (formerly Twitter),
    among others. These focused on microservices, real-time data processing, and scalability.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: The narrative then shifted to practical strategies for distributed transactions,
    data consistency, and microservices state management. The chapter advocated for
    consistent concurrency strategies in cloud-native applications. It concluded with
    resources for further exploration and tools for mastering Java concurrency and
    parallelism, equipping developers to build scalable cloud-native applications.
    The foundation that has been set here will lead to deeper explorations of Java’s
    concurrency mechanisms in subsequent chapters.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will transition to a new chapter that delves into the foundational
    principles of concurrency within the Java ecosystem.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – exploring Java executors
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Objective**: In this exercise, you will explore different types of executors
    provided by the Java Concurrency API. You will refer to the Java documentation,
    use a different executor implementation, and observe its behavior in a sample
    program.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '**Instructions**:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit the Java documentation for the `Executors` class: [https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html).'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read through the documentation and familiarize yourself with the different factory
    methods provided by the `Executors` class for creating `Executor` instances.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Choose a different executor implementation other than the fixed thread pool
    used in the previous examples. Some options include the following:'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Executors.newCachedThreadPool()`'
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Executors.newSingleThreadExecutor()`'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Executors.newScheduledThreadPool(int corePoolSize)`'
  id: totrans-382
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new Java class called `ExecutorExploration` and replace the Executor
    creation line with the chosen executor implementation. For example, if you chose
    `Executors.newCachedThreadPool()`, your code would look like this:Top of Form
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Modify the task creation and submission logic to create and submit a larger
    number of tasks (e.g., 100 tasks) to the executor. Here’s an example of how you
    can modify the code to create and submit 100 tasks to the executor:'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Run the program and observe the behavior of the chosen executor. Take note of
    how it handles the submitted tasks and any differences compared to the fixed thread
    pool.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment with different executor implementations and observe how they behave
    differently in terms of task execution, thread creation, and resource utilization.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following questions:'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does the chosen executor handle the submitted tasks compared to the fixed
    thread pool?
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there any differences in the order or concurrency of task execution?
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How does the executor manage threads and resource allocation?
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Feel free to refer back to the Java documentation to understand the characteristics
    and use cases of each executor implementation.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By completing this exercise, you will gain hands-on experience with different
    types of executors in Java and understand their behavior and use cases. This knowledge
    will help you make informed decisions when choosing an appropriate executor for
    your specific concurrency requirements in Java applications.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Remember to review the Java documentation, experiment with different executor
    implementations, and observe their behavior in action. Happy exploring!
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the primary advantage of using microservices in cloud-based Java applications?
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increased security through monolithic architecture
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Easier to scale and maintain individual services
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Eliminating the need for databases
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Unified, single-point configuration for all services
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In Java concurrency, which mechanism is used to handle multiple threads trying
    to access a shared resource simultaneously?
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inheritance
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Synchronization
  id: totrans-404
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Serialization
  id: totrans-405
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Polymorphism
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is NOT a feature of Java’s `java.util.concurrent` package?
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fork/join framework
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ConcurrentHashMap`'
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ExecutorService`'
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Stream API
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In serverless computing, which feature is a key benefit when using Java?
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Static typing
  id: totrans-413
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Manual scaling
  id: totrans-414
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Automatic scaling and management of resources
  id: totrans-415
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Low-level hardware access
  id: totrans-416
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a common challenge when managing distributed data in Java cloud applications?
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Graphics rendering
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Data consistency and synchronization
  id: totrans-419
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Single-thread execution
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: User interface design
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
