["```java\nscala> import java.util\nimport java.util\nscala> val map = new util.HashMap[String, Int] { put(\"zero\", 0) }\nmap: java.util.HashMap[String,Int] = {zero=0}\nscala> val list = new util.ArrayList[String] { add(\"zero\") }\nlist: java.util.ArrayList[String] = [zero]\nscala> println(map.get(\"zero\"))\n0\nscala> println(list.get(0))\nzero\n```", "```java\nscala> println(map.get(\"one\"))\nnull\nscala> :type null\nNull\n```", "```java\nscala> println(map.get(\"one\").toString)\njava.lang.NullPointerException\n  ... 40 elided\n```", "```java\nscala> list.get(1) match {\n     | case null => println(\"Not found\")\n     | case notNull => println(notNull)\n     | }\njava.lang.IndexOutOfBoundsException: Index: 1, Size: 1\n  at java.util.ArrayList.rangeCheck(ArrayList.java:653)\n  at java.util.ArrayList.get(ArrayList.java:429)\n  ... 49 elided\n```", "```java\nsealed abstract class Option[+A]\ncase object None extends Option[Nothing]\nfinal case class Some[+A](value: A) extends Option[A]\n```", "```java\nval opt1 = None\nval opt2 = Some(\"Option\")\n```", "```java\nval opt3 = Some(null)\n```", "```java\ndef opt4[A](a: A): Option[A] = if (a == null) None else Some(a)\n```", "```java\ndef opt5[A](a: A): Option[A] = Option(a)\n```", "```java\nval empty = Option.empty[String]\nval temperature: Int = 26\ndef readExactTemperature: Int = 26.3425 // slow and expensive method call\nval temp1 = Option.when(temperature > 45)(readExactTemperature)\nval temp2 = Option.unless(temperature < 45)(readExactTemperature)\n```", "```java\nif (opt1.isDefined) println(opt1.get)\nif (opt1.isEmpty) println(\"Ooops, option is empty\") else println(opt1.get)\n```", "```java\nscala> None.get\njava.util.NoSuchElementException: None.get\n  at scala.None$.get(Option.scala:378)\n  ... 40 elided\n```", "```java\nif (option.contains(\"boo\")) println(\"non-empty and contains 'boo'\")\nif (option.exists(_ > 10)) println(\"non-empty and greater then 10\")\nif (option.forall(_ > 10)) println(\"empty or greater then 10\")\n```", "```java\nif (opt.isDefined) { val Some(value) = opt }\n```", "```java\nopt match {\n  case Some(value) => println(value)\n  case None => println(\"there is nothing inside\")\n}\n```", "```java\nval resultOrDefault = opt.getOrElse(\"No value\")\n```", "```java\nscala> None.orNull\nres8: Null = null\n```", "```java\nscala> val opt2 = Some(\"I'm a non-empty option\")\nopt2: Some[String] = Some(I'm a non-empty option)\nscala> opt2.foreach(println)\nI'm a non-empty option\n```", "```java\nval moreThen10: Option[Int] = opt.filter(_ > 10)\nval lessOrEqual10: Option[Int] = opt.filterNot(_ > 10)\n```", "```java\nval moreThen20: Option[String] = opt.collect {\n  case i if i > 20 => s\"More then 20: $i\"\n}\n```", "```java\nval buyBait: String => Bait = ???\nval castLine: Bait => Line = ???\nval hookFish: Line => Fish = ???\n\ndef goFishing(bestBaitForFish: Option[String]): Option[Fish] =\n  bestBaitForFish.map(buyBait).map(castLine).map(hookFish)\n```", "```java\nval hookFish: Line => Option[Fish]\n\ndef goFishingOld(bestBaitForFish: Option[String]): Option[Option[Fish]] =\n  bestBaitForFish.map(buyBait).map(castLine).map(hookFish)\n\n```", "```java\ndef goFishingOld(bestBaitForFish: Option[String]): Option[Fish] =\n  bestBaitForFish.map(buyBait).map(castLine).map(hookFish).flatten\n```", "```java\nval castLine: Bait => Option[Line]\nval hookFish: Line => Option[Fish]\n\ndef goFishingOld(bestBaitForFish: Option[String]): Option[Fish] =\n  bestBaitForFish.map(buyBait).map(castLine).map(hookFish).flatten\n```", "```java\nerror: type mismatch;\n found : FishingOptionExample.this.Line => Option[FishingOptionExample.this.Fish]\n required: Option[UserExample.this.Line] => ?\n```", "```java\nval buyBait: String => Option[Bait]\nval makeBait: String => Option[Bait]\nval castLine: Bait => Option[Line]\nval hookFish: Line => Option[Fish]\n\ndef goFishingOld(bestBaitForFish: Option[String]): Option[Fish]   bestBaitForFish.flatMap(buyBait).flatMap(castLine).flatMap(hookFish)\n```", "```java\ndef goFishing(bestBaitForFish: Option[String]): Option[Fish] =\n  for {\n    baitName <- bestBaitForFish\n    bait <- buyBait(baitName).orElse(makeBait(baitName))\n    line <- castLine(bait)\n    fish <- hookFish(line)\n  } yield fish\n```", "```java\nval opt5 = opt0 orElse opt2 orElse opt3 orElse opt4\n```", "```java\nopt.fold(\"Value for an empty case\")((i: Int) => s\"The value is $i\")\n```", "```java\nopt.toRight(\"If opt is empty, I'll be Left[String]\")\n```", "```java\nscala> val opt = Option.empty[String]\nopt: Option[String] = None\n\nscala> opt.toLeft(\"Nonempty opt will be Left, empty - Right[String]\")\nres8: Either[String,String] = Right(Nonempty opt will be Left, empty - Right[String])\n```", "```java\ntype OldFormat\ntype NewFormat\n\ndef runSimulation(): Either[OldFormat, NewFormat]\n```", "```java\ndef catchFish(): Either[Boot, Fish]\n```", "```java\nsealed abstract class Either[+A, +B]\nfinal case class Left[+A, +B](value: A) extends Either[A, B]\nfinal case class Right[+A, +B](value: B) extends Either[A, B]\n```", "```java\nscala> Right(10)\nres1: scala.util.Right[Nothing,Int] = Right(10)\n```", "```java\nscala> Left[String, Int](\"I'm left\")\nres2: scala.util.Left[String,Int] = Left(I'm left)\n```", "```java\nscala> val i = 100\ni: Int = 100\nscala> val either = Either.cond(i > 10, i, \"i is greater then 10\")\neither: scala.util.Either[String,Int] = Right(100)\n```", "```java\nscala> val right = Right(10)\nright: scala.util.Right[Nothing,Int] = Right(10)\nscala> right.withLeft[String]\nres11: scala.util.Either[String,Int] = Right(10)\nscala> Left(new StringBuilder).withRight[BigDecimal]\nres12: scala.util.Either[StringBuilder,BigDecimal] = Left()\n```", "```java\nif (either.isRight) println(\"Got right\")\nif (either.isLeft) println(\"Got left\")\n```", "```java\neither match {\n  case Left(value) => println(s\"Got Left value $value\")\n  case Right(value) => println(s\"Got Right value $value\")\n}\n```", "```java\nif (either.contains(\"boo\")) println(\"Is Right and contains 'boo'\")\nif (either.exists(_ > 10)) println(\"Is Right and > 10\")\nif (either.forall(_ > 10)) println(\"Is Left or > 10\")\n```", "```java\nscala> val left = Left(new StringBuilder).withRight[BigDecimal]\nres14: scala.util.Either[StringBuilder,BigDecimal] = Left()\n\nscala> .getOrElse(\"Default value for the left side\")\nres15: String = Default value for the left side\n```", "```java\nscala> left.toOption\nres17: Option[BigDecimal] = None\n```", "```java\nscala> left.toSeq\nres18: Seq[BigDecimal] = List()\n```", "```java\nscala> left.swap\nres19: scala.util.Either[BigDecimal,StringBuilder] = Right()\n```", "```java\nscala> val left = Left(\"HoHoHo\").withRight[BigDecimal]\nleft: scala.util.Either[String,BigDecimal] = Left(HoHoHo)\nscala> left.foreach(println)\nscala> left.swap.foreach(println)\nHoHoHo\n```", "```java\nscala> left.swap.filterOrElse(_.length > 10, \"Sorry, too short\")\nres27: ... = Left(Sorry, too short)\n```", "```java\nval buyBait: String => Bait = ???\nval makeBait: String => Bait = ???\nval castLine: Bait => Line = ???\nval hookFish: Line => Fish = ???\n```", "```java\ndef goFishing(bestBaitForFishOrCurse: Either[String, String]): Either[String, Fish] =\n  bestBaitForFishOrCurse.map(buyBait).map(castLine).map(hookFish)\n```", "```java\nval buyBait: String => Either[String, Bait]\nval makeBait: String => Either[String, Bait]\nval castLine: Bait => Either[String, Line]\nval hookFish: Line => Either[String, Fish]\n```", "```java\ndef goFishing(bestBaitForFishOrCurse: Either[String, String]): Either[String, Fish] = for {\n  baitName <- bestBaitForFishOrCurse\n  bait <- buyBait(baitName).fold(_ => makeBait(baitName), Right(_))\n  line <- castLine(bait)\n  fish <- hookFish(line)\n} yield fish\n```", "```java\ndef toTry(implicit ev: A <:< Throwable): Try[B] = this match {\n  case Right(b) => Success(b)\n  case Left(a)  => Failure(a)\n}\n```", "```java\nsealed abstract class Try[+T]\nfinal case class Success[+T](value: T) extends Try[T]\nfinal case class Failure[+T](exception: Throwable) extends Try[T]\n```", "```java\nscala> import scala.util._\nimport scala.util._\nscala> Success(\"Well\")\nres1: scala.util.Success[String] = Success(Well)\nscala> Failure(new Exception(\"Not so well\"))\nres2: scala.util.Failure[Nothing] = Failure(java.lang.Exception: Not so well)\n```", "```java\ntry Success(System.console().readLine()) catch {\n  case err: IOError => Failure(err)\n}\n```", "```java\nTry(System.console().readLine())\n```", "```java\nscala>val line = Try {\n  val line = System.console().readLine()\n  println(s\"Got $line from console\")\n  line\n}\n```", "```java\nif (line.isSuccess) println(s\"The line was ${line.get}\")\nif (line.isFailure) println(s\"There was a failure\")\n```", "```java\nscala> Try { throw new Exception(\"No way\") }.get\njava.lang.Exception: No way\n at .$anonfun$res34$1(<console>:1)\n at scala.util.Try$.apply(Try.scala:209)\n ... 40 elided\n```", "```java\nscala> Try { throw new Exception(\"No way\") }.getOrElse(\"There is a way\")\nres35: String = There is a way\n```", "```java\nscala> line.foreach(println)\nHi, I'm the success!\n```", "```java\nscala> line.filter(_.nonEmpty)\nres38: scala.util.Try[String] = Success(Hi, I'm the success!)\nscala> line.filter(_.isEmpty)\nres39: scala.util.Try[String] = Failure(java.util.NoSuchElementException: Predicate does not hold for Hi, I'm the success!)\n```", "```java\nscala> line.collect { case s: String => s * 2 }\nres40: scala.util.Try[String] = Success(Hi, I'm the success!Hi, I'm the success!)\nscala> line.collect { case s: \"Other input\" => s * 10 }\nres41: scala.util.Try[String] = Failure(java.util.NoSuchElementException: Predicate does not hold for Hi, I'm the success!)\n```", "```java\ndef goFishing(bestBaitForFishOrCurse: Try[String]): Try[Fish] =\n  bestBaitForFishOrCurse.map(buyBait).map(castLine).map(hookFish)\n```", "```java\nval buyBait: String => Try[Bait]\nval makeBait: String => Try[Bait]\nval castLine: Bait => Try[Line]\nval hookFish: Line => Try[Fish]\n```", "```java\ndef goFishing(bestBaitForFishOrCurse: Try[String]): Try[Fish] = for {\n  baitName <- bestBaitForFishOrCurse\n  bait <- buyBait(baitName).fold(_ => makeBait(baitName), Success(_))\n  line <- castLine(bait)\n  fish <- hookFish(line)\n} yield fish\n```", "```java\nscala> line.transform((l: String) => Try(println(l)), (ex: Throwable) => Try(throw ex))\nHi, I'm the success!\nres45: scala.util.Try[Unit] = Success(())\n```", "```java\nline.recover {\n  case ex: NumberFormatException => Math.PI\n}\nline.recoverWith {\n  case ex: NoSuchElementException => Try(retryAfterDelay)\n}\n```", "```java\nval result = firstTry orElse secondTry orElse failure orElse success\n```", "```java\nscala> line.toOption\nres51: Option[String] = Some(\"Hi, I'm the success!\")\nscala> line.toEither\nres53: scala.util.Either[Throwable,String] = Right(\"Hi, I'm the success!\")\n```", "```java\nscala> import scala.concurrent._\nimport scala.concurrent._\nscala> import ExecutionContext.Implicits.global\nimport ExecutionContext.Implicits.global\n```", "```java\nval success = Future(\"Well\")\nval runningForever = Future {\n  while (true) Thread.sleep(1000)\n}\n```", "```java\nscala> val success = Future.successful(\"Well\")\nsuccess: scala.concurrent.Future[String] = Future(Success(Well))\nscala> val failure = Future.failed(new IllegalArgumentException)\nfailure: scala.concurrent.Future[Nothing] = Future(Failure(java.lang.IllegalArgumentException))\nscala> val fromTry = Future.fromTry(Try(10 / 0))\nfromTry: scala.concurrent.Future[Int] = Future(Failure(java.lang.ArithmeticException: / by zero))\n```", "```java\nscala> val runningLong = Future.unit.map { _ =>\n | while (math.random() > 0.001) Thread.sleep(1000)\n | }\nrunningLong: scala.concurrent.Future[Unit] = Future(<not completed>)\n```", "```java\nscala> if (runningLong.isCompleted) runningLong.value\nres54: Any = Some(Success(()))\n```", "```java\nscala> runningForever.value match {\n | case Some(Success(value)) => println(s\"Finished successfully with $value\")\n | case Some(Failure(exception)) => println(s\"Failed with $exception\")\n | case None => println(\"Still running\")\n | }\nStill running\n```", "```java\nscala> runningLong.foreach(_ => println(\"First callback\"))\nscala> runningLong.foreach(_ => println(\"Second callback\"))\nscala> Second callback\nFirst callback\n```", "```java\nscala> runningLong.onComplete {\n     | case Success(value) => println(s\"Success with $value\")\n     | case Failure(ex) => println(s\"Failure with $ex\")\n     | }\nscala> Success with ()\n```", "```java\nstringFuture.transform(_.length, ex => new Exception(ex))\nstringFuture.transform {\n  case Success(value) => Success(value.length)\n  case Failure(ex) => Failure(new Exception(ex))\n}\n```", "```java\nstringFuture.filter(_.length > 10)\nstringFuture.collect {\n  case s if s.length > 10 => s.toUpperCase\n}\n```", "```java\nval buyBait: String => Future[Bait]\nval makeBait: String => Future[Bait]\nval castLine: Bait => Future[Line]\nval hookFish: Line => Future[Fish]\n```", "```java\ndef goFishing(bestBaitForFish: Future[String]): Future[Fish] = for {\n  baitName <- bestBaitForFish\n  bait <- buyBait(baitName).fallbackTo(makeBait(baitName))\n  line <- castLine(bait)\n  fish <- hookFish(line)\n} yield fish\n```", "```java\nTry[Int](throw new OutOfMemoryError()).filter(_ > 10).recover {\n  case _: OutOfMemoryError => 100\n}\n```", "```java\nFuture[Int](throw new OutOfMemoryError()).filter(_ > 10).recover {\n  case _: OutOfMemoryError => 100\n}(20)\n```", "```java\ndef either(i: Int): Boolean = \n  Either.cond(i > 10, i * 10, new IllegalArgumentException(\"Give me more\")).forall(_ < 100)\n```"]