- en: Chapter 2. A Look at Reactive Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive Extensions—or Rx—is a Reactive Programming library from Microsoft to
    build complex asynchronous programs. It models time-varying values and events
    as observable sequences and is implemented by extending the Observer design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Its first target platform was .NET, but Netflix has ported Rx to the JVM under
    the name RxJava. Microsoft also develops and maintains a port of Rx to JavaScript
    called RxJS, which is the tool we used to build the sine-wave application. The
    two ports work a treat for us since Clojure runs on the JVM and ClojureScript
    in JavaScript environments.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in [Chapter 1](part0015_split_000.html#page "Chapter 1. What is Reactive
    Programming?"), *What is Reactive Programming?*, Rx is inspired by Functional
    Reactive Programming but uses different terminology. In FRP, the two main abstractions
    are behaviors and events. Although the implementation details are different, observable
    sequences represent events. Rx also provides a behavior-like abstraction through
    another data type called `BehaviorSubject`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Explore Rx''s main abstraction: observables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about the duality between iterators and observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and manipulate observable sequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Observer pattern revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](part0015_split_000.html#page "Chapter 1. What is Reactive Programming?"),
    *What is Reactive Programming?*, we saw a brief overview of the Observer design
    pattern and a simple implementation of it in Clojure using watches. Here''s how
    we did it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, our observable subject is the var, `numbers`. The
    observer is the `adder` watch. When the observable changes, it *pushes* its changes
    to the observer *synchronously*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, contrast this to working with sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This time around, the vector is the subject being observed and the functions
    processing it can be thought of as the observers. However, this works in a pull-based
    model. The vector doesn't push any elements down the sequence. Instead, `map`
    and friends ask the sequence for more elements. This is a synchronous operation.
  prefs: []
  type: TYPE_NORMAL
- en: Rx makes sequences—and more—behave like observables so that you can still map,
    filter, and compose them just as you would compose functions over normal sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Observer – an Iterator's dual
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clojure''s sequence operators such as map, filter, reduce, and so on support
    Java Iterables. As the name implies, an Iterable is an object that can be iterated
    over. At a low level, this is supported by retrieving an Iterator reference from
    such object. Java''s Iterator interface looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When passed in an object that implements this interface, Clojure's sequence
    operators pull data from it by using the `next` method, while using the `hasNext`
    method to know when to stop.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `remove` method is required to remove its last element from the underlying
    collection. This in-place mutation is clearly unsafe in a multithreaded environment.
    Whenever Clojure implements this interface for the purposes of interoperability,
    the `remove` method simply throws `UnsupportedOperationException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An observable, on the other hand, has observers subscribed to it. Observers
    have the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, an Observer implementing this interface will have its `onNext`
    method called with the next value available from whatever observable it's subscribed
    to. Hence, it being a *push*-based notification model.
  prefs: []
  type: TYPE_NORMAL
- en: 'This duality [4] becomes clearer if we look at both the interfaces side by
    side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Observables provide the ability to have producers push items *asynchronously*
    to consumers. A few examples will help solidify our understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter is all about Reactive Extensions, so let''s go ahead and create
    a project called `rx-playground` that we will be using in our exploratory tour.
    We will use RxClojure (see [https://github.com/ReactiveX/RxClojure](https://github.com/ReactiveX/RxClojure)),
    a library that provides Clojure bindings for `RxJava()` (see [https://github.com/ReactiveX/RxJava](https://github.com/ReactiveX/RxJava)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the project file and add a dependency on RxJava''s Clojure bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, fire up a REPL in the project''s root directory so that we can start creating
    some observables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we need to do is import RxClojure, so let''s get this out of
    the way by typing the following in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The simplest way to create a new observable is by calling the `justreturn`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can subscribe to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the string `"Got value: 10"` to the REPL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `subscribe` function of an observable allows us to register handlers for
    three main things that happen throughout its life cycle: new values, errors, or
    a notification that the observable is done emitting values. This corresponds to
    the `onNext`, `onError`, and `onCompleted` methods of the Observer interface,
    respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we are simply subscribing to `onNext`, which is why
    we get notified about the observable's only value, 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'A single-value Observable isn''t terribly interesting though. Let''s create
    and interact with one that emits multiple values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this doesn't yet present any advantages to working with raw values
    or sequences in Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if we need an observable that emits an undefined number of integers
    at a given interval? This becomes challenging to represent as a sequence in Clojure,
    but Rx makes it trivial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RxClojure doesn't yet provide bindings to all of RxJava's API. The `interval`
    method is one such example. We're required to use interoperability and call the
    method directly on the `Observable` class from RxJava.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observable/interval takes as arguments a number and a time unit. In this case,
    we are telling it to emit an integer—starting from zero—every 100 milliseconds.
    If we type this in an REPL-connected editor, however, two things will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: We will not see any output (depending on your REPL; this is true for Emacs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will have a rogue thread emitting numbers indefinitely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both issues arise from the fact that `Observable/interval` is the first factory
    method we have used that doesn't emit values synchronously. Instead, it returns
    an Observable that defers the work to a separate thread.
  prefs: []
  type: TYPE_NORMAL
- en: The first issue is simple enough to fix. Functions such as `prn` will print
    to whatever the dynamic var `*out*` is bound to. When working in certain REPL
    environments such as Emacs', this is bound to the REPL stream, which is why we
    can generally see everything we print.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, since Rx is deferring the work to a separate thread, `*out*` isn''t
    bound to the REPL stream anymore so we don''t see the output. In order to fix
    this, we need to capture the current value of `*out*` and bind it in our subscription.
    This will be incredibly useful as we experiment with Rx in the REPL. As such,
    let''s create a helper function for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is create a var `repl-out` that contains the current REPL
    stream. Next, we create a function `prn-to-repl` that works just like `prn`, except
    it uses the `binding` macro to create a new binding for `*out*` that is valid
    within that scope.
  prefs: []
  type: TYPE_NORMAL
- en: This still leaves us with the rogue thread problem. Now is the appropriate time
    to mention that the `subscribe` method from an Observable returns a subscription
    object. By holding onto a reference to it, we can call its `unsubscribe` method
    to indicate that we are no longer interested in the values produced by that observable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting it all together, our interval example can be rewritten like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We create a new interval observable and immediately subscribe to it, just as
    we did before. This time, however, we assign the resulting subscription to a local
    var. Note that it now uses our helper function `prn-to-repl`, so we will start
    seeing values being printed to the REPL straight away.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we sleep the current—the REPL—thread for a second. This is enough time
    for the Observable to produce numbers from 0 to 9\. That's roughly when the REPL
    thread wakes up and unsubscribes from that observable, causing it to stop emitting
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Observables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rx provides many more factory methods to create Observables (see [https://github.com/ReactiveX/RxJava/wiki/Creating-Observables](https://github.com/ReactiveX/RxJava/wiki/Creating-Observables)),
    but it is beyond the scope of this book to cover them all.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, sometimes, none of the built-in factories is what you want. For
    such cases, Rx provides the `create` method. We can use it to create a custom
    observable from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we''ll create our own version of the just observable we used
    earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While creating custom observables is fairly straightforward, we should make
    sure we exhaust the built-in factory functions first, only then resorting to creating
    our own.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to create observables, we should look at what kinds of
    interesting things we can do with them. In this section, we will see what it means
    to treat Observables as sequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with something simple. Let''s print the sum of the first five
    positive even integers from an observable of all integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is starting to look awfully familiar to us. We create an interval that
    will emit all positive integers starting at zero every 1 microsecond. Then, we
    filter all even numbers in this observable. Obviously, this is too big a list
    to handle, so we simply take the first five elements from it. Finally, we reduce
    the value using `+`. The result is 20.
  prefs: []
  type: TYPE_NORMAL
- en: 'To drive home the point that programming with observables really is just like
    operating on sequences, we will look at one more example where we will combine
    two different Observable sequences. One contains the names of musicians I''m a
    fan of and the other the names of their respective bands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We would like to print to the REPL a string of the format `Musician name –
    from: band name`. An added requirement is that the band names should be printed
    in uppercase for impact.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by creating another observable that contains the uppercased band
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: While not strictly necessary, this makes a reusable piece of code that can be
    handy in several places of the program, thus avoiding duplication. Subscribers
    interested in the original band names can keep subscribing to the `bands` observable.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the two observables in hand, we can proceed to combine them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once more, this example should feel familiar. The solution we were after was
    a way to zip the two observables together. RxClojure provides `zip` behavior through
    map, much like Clojure''s core `map` function does. We call it with three arguments:
    the two observables to `zip` and a function that will be called with both elements,
    one from each observable, and should return an appropriate representation. In
    this case, we simply turn them into a vector.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in our subscriber, we simply destructure the vector in order to access
    the musician and band names. We can finally print the final result to the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Flatmap and friends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to transform and combine observables
    with operations such as map, reduce, and `zip`. However, the two observables above—musicians
    and bands—were perfectly capable of producing values on their own. They did not
    need any extra input.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we examine a different scenario: we''ll learn how we can combine
    observables, where the output of one is the input of another. We encountered `flatmap`
    before in [Chapter 1](part0015_split_000.html#page "Chapter 1. What is Reactive
    Programming?"), *What is Reactive Programming?* If you have been wondering what
    its role is, this section addresses exactly that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what we are going to do: given an observable representing a list of
    all positive integers, we''ll calculate the factorial for all even numbers in
    that list. Since the list is too big, we''ll take five items from it. The end
    result should be the factorials of 0, 2, 4, 6, and 8, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need is a function to calculate the factorial of a number
    *n*, as well as our observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Using some type of visual aid will be helpful in this section, so we''ll start
    with a marble diagram representing the previous observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flatmap and friends](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The middle arrow represents time and it flows from left to right. This diagram
    represents an infinite Observable sequence, as indicated by the use of ellipsis
    at the end of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re combining all the observables now, we''ll create one that, given
    a number, emits its factorial using the helper function defined earlier. We''ll
    use Rx''s `create` method for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is very similar to the `just-obs` observable we created earlier in this
    chapter, except that it calculates the factorial of its argument and emits the
    result/factorial instead, ending the sequence immediately thereafter. The following
    diagram illustrates how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flatmap and friends](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We feed the number 5 to the observable, which in turn emits its factorial, 120\.
    The vertical bar at the end of the time line indicates the sequence terminates
    then.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the code confirms that our function is correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'So far so good. Now, we need to combine both observables in order to achieve
    our goal. This is where `flatmap` of Rx comes in. We''ll first see it in action
    and then get into the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding code, it will print the factorials for 0, 2, 4, 6,
    and 8, just like we wanted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![Flatmap and friends](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Much like `all-positive-integers`, this, too, is an infinite observable.
  prefs: []
  type: TYPE_NORMAL
- en: However, the next line of our code looks a little odd. We call `flatmap` and
    give it the `fact-obs` function. A function we know itself returns another observable.
    `flatmap` will call `fact-obs` with each value it emits. `fact-obs` will, in turn,
    return a single-value observable for each number. However, our subscriber doesn't
    know how to deal with observables! It's simply interested in the factorials!
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why, after calling `fact-obs` to obtain an observable, `flatmap` flattens
    all of them into a single observable we can subscribe to. This is quite a mouthful,
    so let''s visualize what this means:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flatmap and friends](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding diagram, throughout the execution of `flatmap`,
    we end up with a list of observables. However, we don't care about each observable
    but rather about the values they emit. `Flatmap`, then, is the perfect tool as
    it combines—*flattens*—all of them into the observable sequence shown at the bottom
    of the figure.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of `flatmap` as *mapcat* for observable sequences.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code is straightforward. We simply take the first five elements
    from this observable and subscribe to it, as we have been doing so far.
  prefs: []
  type: TYPE_NORMAL
- en: One more flatmap for the road
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might be wondering what would happen if the observable sequence we're *flatmapping*
    emitted more than one value. What then?
  prefs: []
  type: TYPE_NORMAL
- en: We'll see one last example before we begin the next section in order to illustrate
    the behavior of `flatMap` in such cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an observable that emits its argument twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Using it is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As previously, we'll now combine this observable with the one we created earlier,
    `all-positive-integers`. Before reading on, think about what you expect the output
    to be for, say, the first three positive integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The result might be unexpected for some readers. Let''s have a look at the
    marble diagram for this example and make sure we understand how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![One more flatmap for the road](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Each time `repeat-obs` gets called, it emits two values and terminates. `flatmap`
    then combines them all in a single observable, making the previous output clearer.
  prefs: []
  type: TYPE_NORMAL
- en: One last thing worth mentioning about `flatmap`—and the title of this section—is
    that its "friends" refer to the several names by which `flatmap` is known.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, Rx.NET calls it `selectMany`. RxJava and Scala call it `flatMap`—though
    RxJava has an alias for it called `mapMany`. The Haskell community calls it *bind*.
    Though they have different names, these functions semantics are the same and are
    part of a higher-order abstraction called a Monad. We don't need to know anything
    about Monads to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to keep in mind is that when you're sitting at the bar talking
    to your friends about **Compositional Event Systems**, all these names mean the
    same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very important aspect of building reliable applications is knowing what to
    do when things go wrong. It is naive to assume that the network is reliable, that
    hardware won't fail, or that we, as developers, won't make mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: RxJava embraces this fact and provides a rich set of combinators to deal with
    failure, a few of which we examine here.
  prefs: []
  type: TYPE_NORMAL
- en: OnError
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get started by creating a badly behaved observable that always throws
    an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s watch what happens if we subscribe to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The exception thrown by `exceptional-obs` isn't caught anywhere so it simply
    bubbles up to the REPL. If this was a web application our users would be presented
    with a web server error such as the **HTTP code 500 – Internal Server Error**.
    Those users would probably not use our system again.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we would like to get a chance to handle this exception gracefully,
    possibly rendering a friendly error message that will let ours users know we care
    about them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen earlier in the chapter, the `subscribe` function can take up
    to 3 functions as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The first, or the `onNext` handler, is called when the observable emits a new
    value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second, or `onError`, is called whenever the observable throws an exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third and last function, or `onComplete`, is called when the observable
    has completed and will not emit any new items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our purposes we are interested in the `onError` handler, and using it is
    straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This time, instead of throwing the exception, our error handler gets called
    with it. This gives us the opportunity to display an appropriate message to our
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Catch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of `onError` gives us a much better experience overall but it isn't
    very flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine a different scenario where we have an observable retrieving data
    from the network. What if, when this observer fails, we would like to present
    the user with a cached value instead of an error message?
  prefs: []
  type: TYPE_NORMAL
- en: This is where the `catch` combinator comes in. It allows us to specify a function
    to be invoked when the observable throws an exception, much like `OnError` does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Differently from `OnError`, however, `catch` has to return a new Observable
    that will be the new source of items from the moment the exception was thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we are essentially specifying that, whenever `exceptional-obs`
    throws, we should return the value `10`. We are not limited to single values,
    however. In fact, we can use any Observable we like as the new source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Retry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last error handling combinator we'll examine is `retry`. This combinator
    is useful when we know an error or exception is only transient so we should probably
    give it another shot by resubscribing to the Observable.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll create an observable that fails when it is subscribed to for
    the first time. However, the next time it is subscribed to, it succeeds and emits
    a new item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what happens if we simply subscribe to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the exception simply bubbles up as in our first example. However
    we know—for the purposes of this example—that this is a transient failure. Let''s
    see what changes if we use `retry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now, our code is responsible for retrying the Observable and as expected we
    get the correct output.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that `retry` will attempt to resubscribe indefinitely
    until it succeeds. This might not be what you want so Rx provides a variation,
    called `retryWith`, which allows us to specify a predicate function that controls
    when and if retrying should stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'All these operators give us the tools we need to build reliable reactive applications
    and we should always keep them in mind as they are, without a doubt, a great addition
    to our toolbox. The RxJava wiki on the subject should be referred to for more
    information: [https://github.com/ReactiveX/RxJava/wiki/Error-Handling-Operators](https://github.com/ReactiveX/RxJava/wiki/Error-Handling-Operators).'
  prefs: []
  type: TYPE_NORMAL
- en: Backpressure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another issue we might be faced with is the one of observables that produce
    items faster than we can consume. The problem that arises in this scenario is
    what to do with this ever-growing backlog of items.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, think about zipping two observables together. The `zip` operator
    (or `map` in RxClojure) will only emit a new value when all observables have emitted
    an item.
  prefs: []
  type: TYPE_NORMAL
- en: 'So if one of these observables is a lot faster at producing items than the
    others, `map` will need to buffer these items and wait for the others, which will
    most likely cause an error, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As seen in the preceding code, we have a fast producing observable that emits
    items 500 times faster than the slower Observable. Clearly, we can't keep up with
    it and surely enough, Rx throws `MissingBackpressureException`.
  prefs: []
  type: TYPE_NORMAL
- en: What this exception is telling us is that the fast producing observable doesn't
    support any type of backpressure—what Rx calls *Reactive pull backpressure*—that
    is, consumers can't tell it to go slower. Thankfully Rx provides us with combinators
    that are helpful in these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Sample
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One such combinator is `sample`, which allows us to sample an observable at
    a given interval, thus throttling the source observable''s output. Let''s apply
    it to our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The only change is that we call `sample` on our fast producing Observable before
    calling `map`. We will sample it every 200 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: By ignoring all other items emitted in this time slice, we have mitigated our
    initial problem, even though the original Observable doesn't support any form
    of backpressure.
  prefs: []
  type: TYPE_NORMAL
- en: The sample combinator is only one of the combinators useful in such cases. Others
    include `throttleFirst`, `debounce`, `buffer`, and `window`. One drawback of this
    approach, however, is that a lot of the items generated end up being ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the type of application we are building, this might be an acceptable
    compromise. But what if we are interested in all items?
  prefs: []
  type: TYPE_NORMAL
- en: Backpressure strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If an Observable doesn't support backpressure but we are still interested in
    all items it emits, we can use one of the built-in backpressure combinators provided
    by Rx.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example we will look at one such combinator, `onBackpressureBuffer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The example is very similar to the one where we used `sample`, but the output
    is fairly different. This time we get all items emitted by both observables.
  prefs: []
  type: TYPE_NORMAL
- en: The `onBackpressureBuffer` strategy implements a strategy that simply buffers
    all items emitted by the slower Observable, emitting them whenever the consumer
    is ready. In our case, that happens every 500 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Other strategies include `onBackpressureDrop` and `onBackpressureBlock`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth noting that Reactive pull backpressure is still work in progress
    and the best way to keep up to date with progress is on the RxJava wiki on the
    subject: [https://github.com/ReactiveX/RxJava/wiki/Backpressure](https://github.com/ReactiveX/RxJava/wiki/Backpressure).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a deep dive into RxJava, a port form Microsoft's Reactive
    Extensions from .NET. We learned about its main abstraction, the observable, and
    how it relates to iterables.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to create, manipulate, and combine observables in several
    ways. The examples shown here were contrived to keep things simple. Nevertheless,
    all concepts presented are extremely useful in real applications and will come
    in handy for our next chapter, where we put them to use in a more substantial
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we finished by looking at error handling and backpressure, both of
    which are important characteristics of reliable applications that should always
    be kept in mind.
  prefs: []
  type: TYPE_NORMAL
