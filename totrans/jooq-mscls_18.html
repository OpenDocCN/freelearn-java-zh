<html><head></head><body>
		<div id="_idContainer105">
			<h1 id="_idParaDest-285"><em class="italic"><a id="_idTextAnchor284"/>Chapter 14</em>: Derived Tables, CTEs, and Views</h1>
			<p>Derived tables, <strong class="bold">CTEs</strong>, and views are important players in the SQL context. They're useful to organize and optimize the reuse of long and complex queries – typically, base queries and/or expensive queries (in performance terms), and to improve readability by breaking down the code into separate steps. Mainly, they link a certain query to a name, possibly stored in the schema. In other words, they hold the query text, which can be referenced and executed via the associated name when needed. If results materialize, then the database engine can reuse these cached results, otherwise, they have to be recomputed at each call. </p>
			<p>Derived tables, CTEs, and views have specific particularities (including database vendor-specific options), and choosing between them is a decision that strongly depends on the use case, the involved data and queries, the database vendor and optimizer, and so on. As usual, we handle this topic from the jOOQ perspective, so our agenda includes the following:</p>
			<ul>
				<li>Derived tables</li>
				<li>CTEs</li>
				<li>Views</li>
			</ul>
			<p>Let's get started!</p>
			<h1 id="_idParaDest-286"><a id="_idTextAnchor285"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter14">https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter14</a>.</p>
			<h1 id="_idParaDest-287"><a id="_idTextAnchor286"/>Derived tables</h1>
			<p>Have <a id="_idIndexMarker1432"/>you ever used a nested <strong class="source-inline">SELECT</strong> (a <strong class="source-inline">SELECT</strong> in a table expression)? Of course, you have! Then, you've used a so-called <em class="italic">derived table</em> having the scope of the statement that creates it. Roughly, a derived table should be treated in the same way as a base table. In other words, it is advisable to give it and its columns meaningful names via the <strong class="source-inline">AS</strong> operator. This way, you can reference the derived table without ambiguity, and you'll respect the fact that most databases don't support unnamed (unaliased) derived tables. </p>
			<p>jOOQ allows us to transform any <strong class="source-inline">SELECT</strong> in a derived table via <strong class="source-inline">asTable()</strong>, or its synonym <strong class="source-inline">table()</strong>. Let's have a simple example starting from this <strong class="source-inline">SELECT</strong>:</p>
			<pre class="source-code">select(inline(1).as("one"));</pre>
			<p>This is not a derived table, but it can become one as follows (these two are synonyms):</p>
			<pre class="source-code">Table&lt;?&gt; t = select(inline(1).as("one")).asTable();</pre>
			<pre class="source-code">Table&lt;?&gt; t = table(select(inline(1).as("one")));</pre>
			<p>In jOOQ, we can <a id="_idIndexMarker1433"/>further refer to this derived table via the local variable <strong class="source-inline">t</strong>. It is convenient to declare <strong class="source-inline">t</strong> as <strong class="source-inline">Table&lt;?&gt;</strong> or to simply use <strong class="source-inline">var</strong>. But, of course, you can explicitly specify the data types as well. Here, <strong class="source-inline">Table&lt;Record1&lt;Integer&gt;&gt;</strong>. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The <strong class="source-inline">org.jooq.Table</strong> type can reference a derived table.</p>
			<p>Now, the resulting <strong class="source-inline">t</strong> is an unnamed derived table since there is no explicit alias associated with it. Let's see what happens when we select something from <strong class="source-inline">t</strong>:</p>
			<pre class="source-code">ctx.selectFrom(t).fetch();</pre>
			<p>jOOQ generates the following SQL (we've arbitrarily chosen the PostgreSQL dialect):</p>
			<pre class="source-code">SELECT "alias_30260683"."one" </pre>
			<pre class="source-code">  FROM (SELECT 1 AS "one") AS "alias_30260683"</pre>
			<p>jOOQ detected the missing alias for the derived table, therefore it generated one (<strong class="source-inline">alias_30260683</strong>) on our behalf.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">We earlier iterated that most database vendors require an explicit alias for every derived table. But, as you just saw, jOOQ allows us to omit such aliases, and when we do, jOOQ will generate one on our behalf to guarantee that the generated SQL is syntactically correct. The generated alias is a random number suffixed by <strong class="source-inline">alias_</strong>. This alias should not be referenced explicitly. jOOQ will use it internally to render a correct/valid SQL.</p>
			<p>Of course, if we explicitly <a id="_idIndexMarker1434"/>specify an alias then jOOQ will use it:</p>
			<pre class="source-code">Table&lt;?&gt; t = select(inline(1).as("one")).asTable("t");</pre>
			<pre class="source-code">Table&lt;?&gt; t = table(select(inline(1).as("one"))).as("t");</pre>
			<p>The SQL corresponding to PostgreSQL is as follows:</p>
			<pre class="source-code">SELECT "t"."one" FROM (SELECT 1 AS "one") AS "t"</pre>
			<p>Here is another example using the <strong class="source-inline">values()</strong> constructor:</p>
			<pre class="source-code">Table&lt;?&gt; t = values(row(1, "John"), row(2, "Mary"), </pre>
			<pre class="source-code">                    row(3, "Kelly"))</pre>
			<pre class="source-code">  .as("t", "id", "name"); // or, .asTable("t", "id", "name");</pre>
			<p>Typically, we explicitly specify an alias when we also reference it explicitly, but there is nothing wrong in doing it every time. For instance, jOOQ doesn't require an explicit alias for the following inlined derived table, but there is nothing wrong with adding it:</p>
			<pre class="source-code">ctx.select()</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .crossApply(select(count().as("sales_count")).from(SALE)</pre>
			<pre class="source-code">     .where(SALE.EMPLOYEE_NUMBER</pre>
			<pre class="source-code">        .eq(EMPLOYEE.EMPLOYEE_NUMBER))<strong class="bold">.asTable("t")</strong>)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>jOOQ relies on the <strong class="source-inline">t</strong> alias<a id="_idIndexMarker1435"/> instead of generating one.</p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor287"/>Extracting/declaring a derived table in a local variable</h2>
			<p>jOOQ allows us to <a id="_idIndexMarker1436"/>extract/declare a <a id="_idIndexMarker1437"/>derived table outside the statement that used it, and, in such a case, its presence and role are better outlined than in the case of nesting it in a table expression. </p>
			<p>Extracting/declaring a derived table in a local variable can be useful if we need to refer to the derived table in multiple statements, we need it as part of a dynamic query, or we just want to decongest a complex query.</p>
			<p>For instance, consider the following query:</p>
			<pre class="source-code">ctx.select().from(</pre>
			<pre class="source-code"><strong class="bold">    select(ORDERDETAIL.PRODUCT_ID, ORDERDETAIL.PRICE_EACH)</strong></pre>
			<pre class="source-code"><strong class="bold">     .from(ORDERDETAIL)</strong></pre>
			<pre class="source-code"><strong class="bold">     .where(ORDERDETAIL.QUANTITY_ORDERED.gt(50))</strong>)</pre>
			<pre class="source-code">   .innerJoin(PRODUCT)</pre>
			<pre class="source-code">   .on(field(name("price_each")).eq(PRODUCT.BUY_PRICE))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>The highlighted subquery represents an inlined derived table. jOOQ automatically associates to it an alias and uses that alias to reference the columns <strong class="source-inline">product_id</strong> and <strong class="source-inline">price_each</strong> in the outer <strong class="source-inline">SELECT</strong>. Of course, we can provide an explicit alias as well, but this is not required:</p>
			<pre class="source-code">ctx.select().from(</pre>
			<pre class="source-code"><strong class="bold">    select(ORDERDETAIL.PRODUCT_ID, ORDERDETAIL.PRICE_EACH)</strong></pre>
			<pre class="source-code"><strong class="bold">     .from(ORDERDETAIL)</strong></pre>
			<pre class="source-code"><strong class="bold">     </strong><strong class="bold">.where(ORDERDETAIL.QUANTITY_ORDERED.gt(50))</strong></pre>
			<pre class="source-code"><strong class="bold">       .asTable("t")</strong>)</pre>
			<pre class="source-code">   .innerJoin(PRODUCT)</pre>
			<pre class="source-code">   .on(field(name(<strong class="bold">"t"</strong>, "price_each")).eq(PRODUCT.BUY_PRICE))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>This time, jOOQ relies on the <strong class="source-inline">t</strong> alias instead of generating one. Next, let's add this subquery to another query as follows:</p>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_LINE, </pre>
			<pre class="source-code">           PRODUCT.PRODUCT_NAME, field(name("price_each")))</pre>
			<pre class="source-code">   .from(<strong class="bold">select(ORDERDETAIL.PRODUCT_ID,  </strong></pre>
			<pre class="source-code"><strong class="bold">           ORDERDETAIL.PRICE_EACH).from(ORDERDETAIL)</strong></pre>
			<pre class="source-code"><strong class="bold">           .where(ORDERDETAIL.QUANTITY_ORDERED.gt(50))</strong>)</pre>
			<pre class="source-code">   .innerJoin(PRODUCT)</pre>
			<pre class="source-code">   .on(field(name("product_id")).eq(PRODUCT.PRODUCT_ID))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>This <a id="_idIndexMarker1438"/>query fails at compilation <a id="_idIndexMarker1439"/>time because the reference to the <strong class="source-inline">product_id</strong> column in <strong class="source-inline">on(field(name("product_id")).eq(PRODUCT.PRODUCT_ID))</strong> is ambiguous. jOOQ automatically associates a generated alias to the inlined derived table, but it cannot decide whether the <strong class="source-inline">product_id</strong> column comes from the derived table or from the <strong class="source-inline">PRODUCT</strong> table. Resolving this issue can be done explicitly by adding and using an alias for the derived table:</p>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_LINE, PRODUCT.PRODUCT_NAME, </pre>
			<pre class="source-code">           field(name(<strong class="bold">"t"</strong>, "price_each")))</pre>
			<pre class="source-code">   .from(<strong class="bold">select(ORDERDETAIL.PRODUCT_ID</strong>, </pre>
			<pre class="source-code"><strong class="bold">          ORDERDETAIL.PRICE_EACH).from(ORDERDETAIL)</strong></pre>
			<pre class="source-code"><strong class="bold">          .where(ORDERDETAIL.QUANTITY_ORDERED.gt(50))</strong></pre>
			<pre class="source-code"><strong class="bold">            .asTable("t"))</strong></pre>
			<pre class="source-code">   .innerJoin(PRODUCT)</pre>
			<pre class="source-code">   .on(field(name("t", "product_id"))</pre>
			<pre class="source-code">     .eq(PRODUCT.PRODUCT_ID))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Now, jOOQ relies on the <strong class="source-inline">t</strong> alias, and the ambiguity issues have been resolved. Alternatively, we can explicitly associate a unique alias only to the <strong class="source-inline">ORDERDETAIL.PRODUCT_ID</strong> field as <strong class="source-inline">select(ORDERDETAIL.PRODUCT_ID.as("pid")…</strong>, and reference it via this alias as <strong class="source-inline">field(name("pid"))…</strong>.</p>
			<p>At this<a id="_idIndexMarker1440"/> point, we have two queries<a id="_idIndexMarker1441"/> with the same inline derived table. We can avoid code repetition by extracting this derived table in a Java local variable before using it in these two statements. In other words, we declare the derived table in a Java local variable, and we refer to it in the statements via this local variable:</p>
			<pre class="source-code">Table&lt;?&gt; t = select(</pre>
			<pre class="source-code">     ORDERDETAIL.PRODUCT_ID, ORDERDETAIL.PRICE_EACH)</pre>
			<pre class="source-code">  .from(ORDERDETAIL)</pre>
			<pre class="source-code">  .where(ORDERDETAIL.QUANTITY_ORDERED.gt(50)).asTable("t");</pre>
			<p>So, <strong class="source-inline">t</strong> is our derived table. Running this snippet of code doesn't have an effect on and doesn't produce any SQL. jOOQ evaluates <strong class="source-inline">t</strong> only when we reference it in queries, but in order to be evaluated, <strong class="source-inline">t</strong> must be declared before the queries that use it. This is just Java; we can use a variable only if it was declared upfront. When a query uses <strong class="source-inline">t</strong> (for instance, via <strong class="source-inline">t.field()</strong>), jOOQ evaluates <strong class="source-inline">t</strong> and renders the proper SQL.</p>
			<p>For instance, we can use <strong class="source-inline">t</strong> to rewrite our queries as follows:</p>
			<pre class="source-code">ctx.select()</pre>
			<pre class="source-code">   .from(t)</pre>
			<pre class="source-code">   .innerJoin(PRODUCT)</pre>
			<pre class="source-code">   .on(t.field(name("price_each"), BigDecimal.class)</pre>
			<pre class="source-code">        .eq(PRODUCT.BUY_PRICE))</pre>
			<pre class="source-code">   .fetch();</pre>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_LINE, </pre>
			<pre class="source-code">           PRODUCT.PRODUCT_NAME, t.field(name("price_each")))</pre>
			<pre class="source-code">   .from(t)</pre>
			<pre class="source-code">   .innerJoin(PRODUCT)</pre>
			<pre class="source-code">   .on(t.field(name("product_id"), Long.class)</pre>
			<pre class="source-code">        .eq(PRODUCT.PRODUCT_ID))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>But, why this time do we need explicit types in <strong class="source-inline">on(t.field(name("price_each"), BigDecimal.class)</strong> and <strong class="source-inline">.on(t.field(name("product_id"), Long.class)</strong>? The answer is that the fields cannot be dereferenced from <strong class="source-inline">t</strong> in a type-safe way. Therefore it is our job to specify the proper data types. This is a pure Java issue, and has nothing to do with SQL!</p>
			<p>But, there<a id="_idIndexMarker1442"/> is a trick that can help us to<a id="_idIndexMarker1443"/> keep type safety and reduce verbosity, and that trick consists of using the <strong class="source-inline">&lt;T&gt; Field&lt;T&gt; field(Field&lt;T&gt; field)</strong> method. The best explanation of this method is given by the jOOQ documentation itself. The following figure is a screenshot from the jOOQ official documentation:</p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B16833_Figure_14.1.jpg" alt="Figure 14.1 – The &lt;T&gt; Field&lt;T&gt; field(Field&lt;T&gt; field) method documentation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.1 – The &lt;T&gt; Field&lt;T&gt; field(Field&lt;T&gt; field) method documentation</p>
			<p>The expression <strong class="source-inline">t.field(name("price_each"), …)</strong> indirectly refers to the field <strong class="source-inline">ORDERDETAIL.PRICE_EACH</strong>, and <strong class="source-inline">t.field(name("product_id"), …)</strong> indirectly refers to the field <strong class="source-inline">ORDERDETAIL.PRODUCT_ID</strong>. Therefore, based on the previous figure, we can re-write our queries in a type-safe manner as follows:</p>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_LINE, PRODUCT.PRODUCT_NAME, </pre>
			<pre class="source-code"><strong class="bold">           t.field(ORDERDETAIL.PRICE_EACH)</strong>)</pre>
			<pre class="source-code">   .from(t)</pre>
			<pre class="source-code">   .innerJoin(PRODUCT)</pre>
			<pre class="source-code">   .on(<strong class="bold">t.field(ORDERDETAIL.PRODUCT_ID</strong>)</pre>
			<pre class="source-code">     .eq(PRODUCT.PRODUCT_ID))</pre>
			<pre class="source-code">   .fetch();</pre>
			<pre class="source-code">ctx.select()</pre>
			<pre class="source-code">   .from(t)</pre>
			<pre class="source-code">   .innerJoin(PRODUCT)</pre>
			<pre class="source-code">   .on(<strong class="bold">t.field(ORDERDETAIL.PRICE_EACH</strong>)</pre>
			<pre class="source-code">     .eq(PRODUCT.BUY_PRICE))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Cool! Now, we can reuse <strong class="source-inline">t</strong> in a "type-safe" manner! However, keep in mind that &lt;T&gt; Field&lt;T&gt; field(Field&lt;T&gt; field)  just looks type safe. It's actually as good as an unsafe cast in Java, because the lookup only considers the identifier, not the type. Nor does it coerce the expression. This is why we have the quotes around type-safe.</p>
			<p>Here is <a id="_idIndexMarker1444"/>another example that uses <a id="_idIndexMarker1445"/>two extracted <strong class="source-inline">Field</strong> in the extracted derived table and the query itself:</p>
			<pre class="source-code">// fields</pre>
			<pre class="source-code">Field&lt;BigDecimal&gt; avg = avg(ORDERDETAIL.PRICE_EACH).as("avg");</pre>
			<pre class="source-code">Field&lt;Long&gt; ord = ORDERDETAIL.ORDER_ID.as("ord");</pre>
			<pre class="source-code">// derived table</pre>
			<pre class="source-code">Table&lt;?&gt; t = select(avg, ord).from(ORDERDETAIL)</pre>
			<pre class="source-code">    .groupBy(ORDERDETAIL.ORDER_ID).asTable("t");</pre>
			<pre class="source-code">// query</pre>
			<pre class="source-code">ctx.select(ORDERDETAIL.ORDER_ID, ORDERDETAIL</pre>
			<pre class="source-code">          .ORDERDETAIL_ID,ORDERDETAIL.PRODUCT_ID,</pre>
			<pre class="source-code">           ORDERDETAIL.PRICE_EACH)</pre>
			<pre class="source-code">   .from(ORDERDETAIL, t)</pre>
			<pre class="source-code">   .where(ORDERDETAIL.ORDER_ID.eq(ord)</pre>
			<pre class="source-code">     .and(ORDERDETAIL.PRICE_EACH.lt(avg)))</pre>
			<pre class="source-code">   .orderBy(ORDERDETAIL.ORDER_ID)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Here, <strong class="source-inline">ord</strong> and <strong class="source-inline">avg</strong> are<a id="_idIndexMarker1446"/> rendered<a id="_idIndexMarker1447"/> unqualified (without being prefixed with the derived table alias). But, thanks to <strong class="source-inline">&lt;T&gt; Field&lt;T&gt; field(Field&lt;T&gt; field)</strong>, we can obtain the qualified version:</p>
			<pre class="source-code">...where(ORDERDETAIL.ORDER_ID.eq(t.field(ord))        </pre>
			<pre class="source-code">   .and(ORDERDETAIL.PRICE_EACH.lt(t.field(avg))))  </pre>
			<pre class="source-code">...</pre>
			<p>Next, let's see an example that uses <strong class="source-inline">fields()</strong> and <strong class="source-inline">asterisk()</strong> to refer to all columns of a derived table extracted in a local variable:</p>
			<pre class="source-code">Table&lt;?&gt; t = ctx.select(SALE.EMPLOYEE_NUMBER, </pre>
			<pre class="source-code">                 count(SALE.SALE_).as("sales_count"))</pre>
			<pre class="source-code">   .from(SALE).groupBy(SALE.EMPLOYEE_NUMBER).asTable("t");</pre>
			<pre class="source-code">ctx.select(t.fields()).from(t)</pre>
			<pre class="source-code">   .orderBy(t.field(name("sales_count"))).fetch();</pre>
			<pre class="source-code">ctx.select(t.asterisk(), </pre>
			<pre class="source-code">           EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">   .from(EMPLOYEE, t)</pre>
			<pre class="source-code">   .where(EMPLOYEE.EMPLOYEE_NUMBER.eq(</pre>
			<pre class="source-code">          t.field(name("employee_number"), Long.class)))</pre>
			<pre class="source-code">   .orderBy(t.field(name("sales_count"))).fetch();</pre>
			<p>Notice that extracting a subquery is not mandatory for it to be transformed in a <strong class="source-inline">Table</strong>. There are cases when extracting it as a simple <strong class="source-inline">SELECT</strong> is all you need. For instance, when the subquery isn't a derived table, we can do this:</p>
			<pre class="source-code">ctx.selectFrom(PRODUCT)</pre>
			<pre class="source-code">   .where(row(PRODUCT.PRODUCT_ID, PRODUCT.BUY_PRICE).in(</pre>
			<pre class="source-code"><strong class="bold">     select(ORDERDETAIL.PRODUCT_ID, ORDERDETAIL.PRICE_EACH)</strong></pre>
			<pre class="source-code"><strong class="bold">       .from(ORDERDETAIL)</strong></pre>
			<pre class="source-code"><strong class="bold">       .where(ORDERDETAIL.QUANTITY_ORDERED.gt(50))</strong>))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>This <a id="_idIndexMarker1448"/>subquery (which is not a derived table) can <a id="_idIndexMarker1449"/>be extracted locally and used like this:</p>
			<pre class="source-code">// SelectConditionStep&lt;Record2&lt;Long, BigDecimal&gt;&gt;</pre>
			<pre class="source-code">var s = select(</pre>
			<pre class="source-code">      ORDERDETAIL.PRODUCT_ID, ORDERDETAIL.PRICE_EACH)</pre>
			<pre class="source-code">   .from(ORDERDETAIL)</pre>
			<pre class="source-code">   .where(ORDERDETAIL.QUANTITY_ORDERED.gt(50));</pre>
			<pre class="source-code">ctx.selectFrom(PRODUCT)</pre>
			<pre class="source-code">   .where(row(PRODUCT.PRODUCT_ID, PRODUCT.BUY_PRICE).in(s))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>There is <a id="_idIndexMarker1450"/>no need for an alias (jOOQ knows <a id="_idIndexMarker1451"/>that this is not a derived table and no alias is needed therefore it will not generate one) and no need to transform it into a <strong class="source-inline">Table</strong>. Actually, jOOQ is so flexible that it allows us to do even this:</p>
			<pre class="source-code">var t = select(ORDERDETAIL.PRODUCT_ID, ORDERDETAIL.PRICE_EACH)</pre>
			<pre class="source-code">   .from(ORDERDETAIL)</pre>
			<pre class="source-code">   .where(ORDERDETAIL.QUANTITY_ORDERED.gt(50));</pre>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_LINE, PRODUCT.PRODUCT_NAME,  </pre>
			<pre class="source-code">           t.field(ORDERDETAIL.PRICE_EACH))</pre>
			<pre class="source-code">   .from(t)</pre>
			<pre class="source-code">   .innerJoin(PRODUCT)</pre>
			<pre class="source-code">   .on(t.field(ORDERDETAIL.PRODUCT_ID)</pre>
			<pre class="source-code">   .eq(PRODUCT.PRODUCT_ID))</pre>
			<pre class="source-code">   .fetch();</pre>
			<pre class="source-code">ctx.select()</pre>
			<pre class="source-code">   .from(t)</pre>
			<pre class="source-code">   .innerJoin(PRODUCT)</pre>
			<pre class="source-code">   .on(t.field(ORDERDETAIL.PRICE_EACH)</pre>
			<pre class="source-code">   .eq(PRODUCT.BUY_PRICE))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Don't worry, jOOQ will not ask you to transform <strong class="source-inline">t</strong> into a <strong class="source-inline">Table</strong>. jOOQ infers that this is a derived table and associates and references a generated alias as expected in the rendered SQL. So, as long as you don't want to associate an explicit alias to the derived table and jOOQ doesn't specifically require a <strong class="source-inline">Table</strong> instance in your query, there is no need to transform the extracted <strong class="source-inline">SELECT</strong> into a <strong class="source-inline">Table</strong> instance. When you need a <strong class="source-inline">Table</strong> instance <a id="_idIndexMarker1452"/>but not an alias for it, just use<a id="_idIndexMarker1453"/> the <strong class="source-inline">asTable()</strong> method without arguments:</p>
			<pre class="source-code">Table&lt;?&gt; t = select(</pre>
			<pre class="source-code">       ORDERDETAIL.PRODUCT_ID, ORDERDETAIL.PRICE_EACH)</pre>
			<pre class="source-code">   .from(ORDERDETAIL)</pre>
			<pre class="source-code">   .where(ORDERDETAIL.QUANTITY_ORDERED.gt(50)).asTable();</pre>
			<p>You can check out these examples along with others in <em class="italic">DerivedTable</em>.</p>
			<h1 id="_idParaDest-289"><a id="_idTextAnchor288"/>Exploring Common Table Expressions (CTEs) in jOOQ</h1>
			<p>CTEs are <a id="_idIndexMarker1454"/>represented by the SQL-99 <strong class="source-inline">WITH</strong> clause. You already saw several examples of CTE in previous chapters, for instance, in <a href="B16833_13.xhtml#_idTextAnchor245"><em class="italic">Chapter 13</em></a>, <em class="italic">Exploiting SQL Functions</em>, you saw a CTE for computing z-scores.</p>
			<p>Roughly, via CTEs, we factor out the code that otherwise should be repeated as derived tables. Typically, a CTE contains a list of derived tables placed in front of a <strong class="source-inline">SELECT</strong> statement in a certain order. The order is important because these derived tables are created conforming to this order and a CTE element can reference only prior CTE elements. </p>
			<p>Basically, we distinguish between regular (non-recursive) CTEs and recursive CTEs.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor289"/>Regular CTEs</h2>
			<p>A regular <a id="_idIndexMarker1455"/>CTE associates a name to a temporary result set <a id="_idIndexMarker1456"/>that has the scope of a statement such as <strong class="source-inline">SELECT</strong>, <strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, <strong class="source-inline">DELETE</strong>, or <strong class="source-inline">MERGE</strong> (CTEs for DML statements are very useful vendor-specific extensions). But, a derived table or another type of subquery can have its own CTE as well, such as <strong class="source-inline">SELECT x.a FROM (WITH t (a) AS (SELECT 1) SELECT a FROM t) x</strong>. </p>
			<p>The basic syntax of a CTE (for the exact syntax of a certain database vendor, you should consult the documentation) is as follows:</p>
			<pre class="source-code">WITH CTE_name [(column_name [, ...])]</pre>
			<pre class="source-code">AS</pre>
			<pre class="source-code"> (CTE_definition) [, ...]</pre>
			<pre class="source-code">SQL_statement_using_CTE;</pre>
			<p>In jOOQ, a CTE is represented by the <strong class="source-inline">org.jooq.CommonTableExpression</strong> class and extends the commonly used <strong class="source-inline">org.jooq.Table</strong>, therefore a CTE can be used everywhere a <strong class="source-inline">Table</strong> can be used. The <strong class="source-inline">CTE_name</strong> represents the name used later in the query to refer to the CTE and, in jOOQ, can be specified as the argument of the method <strong class="source-inline">name()</strong> or <strong class="source-inline">with()</strong>.</p>
			<p>The <strong class="source-inline">column_name</strong> marks the spot for a list of comma-separated columns that comes after <a id="_idIndexMarker1457"/>the <strong class="source-inline">CTE_name</strong>. The number of columns specified here, and the number of columns defined in the <strong class="source-inline">CTE_definition</strong> must be equal. In jOOQ, when the <strong class="source-inline">name()</strong> method is used for <strong class="source-inline">CTE_name</strong>, this list can be<a id="_idIndexMarker1458"/> specified via the <strong class="source-inline">fields()</strong> method. Otherwise, it can be specified as part of the <strong class="source-inline">with()</strong> arguments after the <strong class="source-inline">CTE_name</strong>.</p>
			<p>The <strong class="source-inline">AS</strong> keyword is rendered in jOOQ via the <strong class="source-inline">as(Select&lt;?&gt; select)</strong> method. So, the argument of <strong class="source-inline">as()</strong> is the <strong class="source-inline">CTE_definition</strong>. Starting with jOOQ 3.15, the CTE <strong class="source-inline">as(ResultQuery&lt;?&gt;)</strong> method accepts a <strong class="source-inline">ResultQuery&lt;?&gt;</strong> to allow for using <strong class="source-inline">INSERT ... RETURNING</strong> and other <strong class="source-inline">DML ... RETURNING</strong> statements as CTEs in PostgreSQL.</p>
			<p>Finally, we have the SQL that uses the CTE and references it via <strong class="source-inline">CTE_name</strong>.</p>
			<p>For instance, the following CTE named <strong class="source-inline">cte_sales</strong> computes the sum of sales per employee:</p>
			<pre class="source-code">CommonTableExpression&lt;Record2&lt;Long, BigDecimal&gt;&gt; t </pre>
			<pre class="source-code">   = name("cte_sales").fields("employee_nr", "sales")</pre>
			<pre class="source-code">       .as(select(SALE.EMPLOYEE_NUMBER, sum(SALE.SALE_))</pre>
			<pre class="source-code">       .from(SALE).groupBy(SALE.EMPLOYEE_NUMBER));</pre>
			<p>This is the CTE declaration that can be referenced via the local variable <strong class="source-inline">t</strong> in any future SQL queries expressed via jOOQ. Running this snippet of code now doesn't execute the <strong class="source-inline">SELECT</strong> and doesn't produce any effect. Once we use <strong class="source-inline">t</strong> in a SQL query, jOOQ will evaluate it to render the expected CTE. That CTE will be executed by the database.</p>
			<p>Exactly <a id="_idIndexMarker1459"/>as in the case of declaring derived tables in local variables, in the case of CTE, the fields cannot be dereferenced from <strong class="source-inline">t</strong> in a type-safe way, therefore it is our job to specify the proper data types in the queries that use the CTE. Again, let me point out that this is a pure Java issue, and has nothing to do with SQL!</p>
			<p>Lukas Eder shared this: <em class="italic">Regarding the lack of type safety when dereferencing CTE or derived table fields: This is often an opportunity to rewrite the SQL statement again to something that doesn't use a CTE. On Stack Overflow, I've seen many cases of questions where the person tried to put *everything* in several layers of confusing CTE, when the actual factored-out query could have been *much* easier (for example, if they knew window functions, or the correct logical order of operations, and so on). Just because you can use CTEs, doesn't mean you have to use them *everywhere</em>*.</p>
			<p>So, here is a usage of our CTE, <strong class="source-inline">t</strong>, for<a id="_idIndexMarker1460"/> fetching the employee having the biggest sales:</p>
			<pre class="source-code">ctx.with(t)</pre>
			<pre class="source-code">   .select() // or, .select(t.field("employee_nr"),  </pre>
			<pre class="source-code">             //             t.field("sales"))</pre>
			<pre class="source-code">   .from(t)</pre>
			<pre class="source-code">   .where(t.field("sales", Double.class)</pre>
			<pre class="source-code">      .eq(select(max(t.field("sales" ,Double.class)))</pre>
			<pre class="source-code">           .from(t))).fetch();</pre>
			<p>By extracting the CTE fields as local variables, we can rewrite our CTE declaration like this:</p>
			<pre class="source-code">Field&lt;Long&gt; e = SALE.EMPLOYEE_NUMBER;</pre>
			<pre class="source-code">Field&lt;BigDecimal&gt; s = sum(SALE.SALE_);</pre>
			<pre class="source-code">CommonTableExpression&lt;Record2&lt;Long, BigDecimal&gt;&gt; t </pre>
			<pre class="source-code"> = name("cte_sales").fields(e.getName(), s.getName())</pre>
			<pre class="source-code">    .as(select(e, s).from(SALE).groupBy(e));</pre>
			<p>The SQL that uses this CTE is as follows:</p>
			<pre class="source-code">ctx.with(t)</pre>
			<pre class="source-code">   .select() // or, .select(t.field(e.getName()), </pre>
			<pre class="source-code">             //             t.field(s.getName()))</pre>
			<pre class="source-code">   .from(t)</pre>
			<pre class="source-code">   .where(t.field(s.getName(), s.getType())</pre>
			<pre class="source-code">      .eq(select(max(t.field(s.getName(), s.getType())))</pre>
			<pre class="source-code">           .from(t))).fetch();</pre>
			<p>And, of course, relying on <strong class="source-inline">&lt;T&gt; Field&lt;T&gt; field(Field&lt;T&gt; field)</strong>, introduced in the previous section, can <a id="_idIndexMarker1461"/>help us to write a type-safe CTE as follows:</p>
			<pre class="source-code">ctx.with(t)</pre>
			<pre class="source-code">   .select() // or, .select(t.field(e), t.field(s))</pre>
			<pre class="source-code">   .from(t)</pre>
			<pre class="source-code">   .where(t.field(s)</pre>
			<pre class="source-code">           .eq(select(max(t.field(s))).from(t))).fetch();</pre>
			<p>As an <a id="_idIndexMarker1462"/>alternative to the previous explicit CTE, we can write an inline CTE as follows:</p>
			<pre class="source-code">ctx.with("cte_sales", "employee_nr", "sales")</pre>
			<pre class="source-code">   .as(select(SALE.EMPLOYEE_NUMBER, sum(SALE.SALE_))</pre>
			<pre class="source-code">   .from(SALE)</pre>
			<pre class="source-code">   .groupBy(SALE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">   .select() // or, field(name("employee_nr")),  </pre>
			<pre class="source-code">             //     field(name("sales"))</pre>
			<pre class="source-code">   .from(name("cte_sales"))</pre>
			<pre class="source-code">   .where(field(name("sales"))</pre>
			<pre class="source-code">      .eq(select(max(field(name("sales"))))</pre>
			<pre class="source-code">   .from(name("cte_sales")))).fetch();</pre>
			<p>By arbitrarily choosing the PostgreSQL dialect, we have the following rendered SQL for all the previous CTEs:</p>
			<pre class="source-code">WITH "cte_sales"("employee_nr", "sales") AS</pre>
			<pre class="source-code">  (SELECT "public"."sale"."employee_number",</pre>
			<pre class="source-code">          sum("public"."sale"."sale")</pre>
			<pre class="source-code">   FROM "public"."sale"</pre>
			<pre class="source-code">   GROUP BY "public"."sale"."employee_number")</pre>
			<pre class="source-code">SELECT * FROM "cte_sales"</pre>
			<pre class="source-code">WHERE "sales" = (SELECT max("sales") FROM "cte_sales")</pre>
			<p>You can <a id="_idIndexMarker1463"/>check these examples in the bundled code named <em class="italic">CteSimple</em>. So far, our CTE is used only in <strong class="source-inline">SELECT</strong> statements. But, CTE can be used<a id="_idIndexMarker1464"/> in DML statements such as <strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, <strong class="source-inline">DELETE</strong>, and <strong class="source-inline">MERGE</strong> as well.</p>
			<h3>CTE as SELECT and DML</h3>
			<p>jOOQ <a id="_idIndexMarker1465"/>supports using CTE in <strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, <strong class="source-inline">DELETE</strong>, and <strong class="source-inline">MERGE</strong>. For instance, the following snippet of code inserts into a brand-new table a random part from the <strong class="source-inline">SALE</strong> table:</p>
			<pre class="source-code">ctx.createTableIfNotExists("sale_training").as(</pre>
			<pre class="source-code">      selectFrom(SALE)).withNoData().execute();</pre>
			<pre class="source-code">ctx.with("training_sale_ids", "sale_id")</pre>
			<pre class="source-code">   .as(select(SALE.SALE_ID).from(SALE)</pre>
			<pre class="source-code">       .orderBy(rand()).limit(10))</pre>
			<pre class="source-code">   .insertInto(table(name("sale_training")))</pre>
			<pre class="source-code">     .select(select().from(SALE).where(SALE.SALE_ID.notIn(</pre>
			<pre class="source-code">      select(field(name("sale_id"), Long.class))</pre>
			<pre class="source-code">        .from(name("training_sale_ids")))))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Here is another example that updates the prices of the products (<strong class="source-inline">PRODUCT.BUY_PRICE</strong>) to the maximum order prices (<strong class="source-inline">max(ORDERDETAIL.PRICE_EACH)</strong>) via a CTE used in <strong class="source-inline">UPDATE</strong>:</p>
			<pre class="source-code">ctx.with("product_cte", "product_id", "max_buy_price")</pre>
			<pre class="source-code">   .as(select(ORDERDETAIL.PRODUCT_ID, </pre>
			<pre class="source-code">              max(ORDERDETAIL.PRICE_EACH))</pre>
			<pre class="source-code">         .from(ORDERDETAIL)</pre>
			<pre class="source-code">         .groupBy(ORDERDETAIL.PRODUCT_ID))</pre>
			<pre class="source-code">   .update(PRODUCT)</pre>
			<pre class="source-code">     .set(PRODUCT.BUY_PRICE, coalesce(field(</pre>
			<pre class="source-code">     select(field(name("max_buy_price"), BigDecimal.class))</pre>
			<pre class="source-code">       .from(name("product_cte"))</pre>
			<pre class="source-code">       .where(PRODUCT.PRODUCT_ID.eq(</pre>
			<pre class="source-code">          field(name("product_id"), Long.class)))),  </pre>
			<pre class="source-code">          PRODUCT.BUY_PRICE)).execute();</pre>
			<p>You can practice <a id="_idIndexMarker1466"/>these examples along with others including using CTE in <strong class="source-inline">DELETE</strong> and <strong class="source-inline">MERGE</strong> in <em class="italic">CteSelectDml</em>. Next, let's see how we can express a CTE as DML in PostgreSQL.</p>
			<h3>A CTE as DML</h3>
			<p>Starting with <a id="_idIndexMarker1467"/>jOOQ 3.15, the CTE <strong class="source-inline">as(ResultQuery&lt;?&gt;)</strong> method accepts a <strong class="source-inline">ResultQuery&lt;?&gt;</strong> to allow for using <strong class="source-inline">INSERT ... RETURNING</strong> and other <strong class="source-inline">DML … RETURNING</strong> statements as CTE in PostgreSQL. Here is a simple CTE storing the returned <strong class="source-inline">SALE_ID</strong>:</p>
			<pre class="source-code">ctx.with("cte", "sale_id")</pre>
			<pre class="source-code">   .as(insertInto(SALE, SALE.FISCAL_YEAR, SALE.SALE_, </pre>
			<pre class="source-code">                  SALE.EMPLOYEE_NUMBER, SALE.FISCAL_MONTH, </pre>
			<pre class="source-code">                  SALE.REVENUE_GROWTH)</pre>
			<pre class="source-code">   .values(2005, 1250.55, 1504L, 1, 0.0)</pre>
			<pre class="source-code">   .returningResult(SALE.SALE_ID))</pre>
			<pre class="source-code">   .selectFrom(name("cte"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Let's write a<a id="_idIndexMarker1468"/> CTE that updates the <strong class="source-inline">SALE.REVENUE_GROWTH</strong> of all employees having a null <strong class="source-inline">EMPLOYEE.COMMISSION</strong>. All the updated <strong class="source-inline">SALE.EMPLOYEE_NUMBER</strong> are stored in the CTE and used further to insert in <strong class="source-inline">EMPLOYEE_STATUS</strong> as follows:</p>
			<pre class="source-code">ctx.with("cte", "employee_number")</pre>
			<pre class="source-code"> .as(update(SALE).set(SALE.REVENUE_GROWTH, 0.0)</pre>
			<pre class="source-code">   .where(SALE.EMPLOYEE_NUMBER.in(</pre>
			<pre class="source-code">     select(EMPLOYEE.EMPLOYEE_NUMBER).from(EMPLOYEE)</pre>
			<pre class="source-code">      .where(EMPLOYEE.COMMISSION.isNull())))</pre>
			<pre class="source-code">   .returningResult(SALE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code"> .insertInto(EMPLOYEE_STATUS, EMPLOYEE_STATUS</pre>
			<pre class="source-code">             .EMPLOYEE_NUMBER,EMPLOYEE_STATUS.STATUS, </pre>
			<pre class="source-code">              EMPLOYEE_STATUS.ACQUIRED_DATE)</pre>
			<pre class="source-code"> .select(select(field(name("employee_number"), Long.class), </pre>
			<pre class="source-code">    val("REGULAR"), val(LocalDate.now())).from(name("cte")))</pre>
			<pre class="source-code"> .execute();</pre>
			<p>You can <a id="_idIndexMarker1469"/>check out more examples in the bundled code named <em class="italic">CteDml</em> for PostgreSQL. Next, let's see how we can embed plain SQL in a CTE.</p>
			<h3>CTEs and plain SQL</h3>
			<p>Using plain<a id="_idIndexMarker1470"/> SQL in CTE is straightforward<a id="_idIndexMarker1471"/> as you can see in the following example:</p>
			<pre class="source-code">CommonTableExpression&lt;Record2&lt;Long, String&gt;&gt;cte = name("cte")</pre>
			<pre class="source-code"> .fields("pid", "ppl").as(resultQuery(</pre>
			<pre class="source-code">    // Put any plain SQL statement here</pre>
			<pre class="source-code">    """</pre>
			<pre class="source-code">    select "public"."product"."product_id", </pre>
			<pre class="source-code">           "public"."product"."product_line" </pre>
			<pre class="source-code">    from "public"."product" </pre>
			<pre class="source-code">    where "public"."product"."quantity_in_stock" &gt; 0</pre>
			<pre class="source-code">    """</pre>
			<pre class="source-code">  ).coerce(field("pid", BIGINT), field("ppl", VARCHAR)));</pre>
			<pre class="source-code">Result&lt;Record2&lt;Long, String&gt;&gt; result = </pre>
			<pre class="source-code">   ctx.with(cte).selectFrom(cte).fetch();</pre>
			<p>You can test this example in the bundled code named <em class="italic">CtePlainSql</em>. Next, let's tackle some common types of CTEs, and let's continue with a query that uses two or more CTEs.</p>
			<h3>Chaining CTEs</h3>
			<p>Sometimes, a <a id="_idIndexMarker1472"/>query must exploit more than one CTE. For instance, let's consider the tables <strong class="source-inline">PRODUCTLINE</strong>, <strong class="source-inline">PRODUCT</strong>, and <strong class="source-inline">ORDERDETAIL</strong>. Our goal is to fetch for each product line some info (for instance, the description), the total number of products, and the total sales. For this, we can write a CTE that joins <strong class="source-inline">PRODUCTLINE</strong> with <strong class="source-inline">PRODUCT</strong> and count the total number of products per product line, and another CTE that joins <strong class="source-inline">PRODUCT</strong> with <strong class="source-inline">ORDERDETAIL</strong> and computes the total sales per product line. Then, both CTEs are used in a <strong class="source-inline">SELECT</strong> to fetch the final result as in the following inlined CTE:</p>
			<pre class="source-code">ctx.with("cte_productline_counts")</pre>
			<pre class="source-code">     .as(select(PRODUCT.PRODUCT_LINE, PRODUCT.CODE,</pre>
			<pre class="source-code">          count(PRODUCT.PRODUCT_ID).as("product_count"),</pre>
			<pre class="source-code">          PRODUCTLINE.TEXT_DESCRIPTION.as("description"))</pre>
			<pre class="source-code">         .from(PRODUCTLINE).join(PRODUCT).onKey()</pre>
			<pre class="source-code">         .groupBy(PRODUCT.PRODUCT_LINE, PRODUCT.CODE, </pre>
			<pre class="source-code">                  PRODUCTLINE.TEXT_DESCRIPTION))</pre>
			<pre class="source-code">     .with("cte_productline_sales")</pre>
			<pre class="source-code">       .as(select(PRODUCT.PRODUCT_LINE,</pre>
			<pre class="source-code">             sum(ORDERDETAIL.QUANTITY_ORDERED</pre>
			<pre class="source-code">               .mul(ORDERDETAIL.PRICE_EACH)).as("sales"))</pre>
			<pre class="source-code">             .from(PRODUCT).join(ORDERDETAIL).onKey()</pre>
			<pre class="source-code">       .groupBy(PRODUCT.PRODUCT_LINE))</pre>
			<pre class="source-code">     .select(field(name("cte_productline_counts", </pre>
			<pre class="source-code">        "product_line")), field(name("code")),</pre>
			<pre class="source-code">        field(name("product_count")),</pre>
			<pre class="source-code">        field(name("description")),</pre>
			<pre class="source-code">        field(name("sales")))</pre>
			<pre class="source-code">     .from(name("cte_productline_counts"))</pre>
			<pre class="source-code">     .join(name("cte_productline_sales"))</pre>
			<pre class="source-code">     .on(field(name("cte_productline_counts", </pre>
			<pre class="source-code">               "product_line"))</pre>
			<pre class="source-code">       .eq(field(name("cte_productline_sales", </pre>
			<pre class="source-code">                      "product_line"))))</pre>
			<pre class="source-code">     .orderBy(field(name("cte_productline_counts", </pre>
			<pre class="source-code">                         "product_line")))</pre>
			<pre class="source-code">     .fetch();</pre>
			<p>In the bundled<a id="_idIndexMarker1473"/> code (<em class="italic">CteSimple</em>), you can see the explicit CTE version as well.</p>
			<h3>Nested CTEs</h3>
			<p>CTEs can be <a id="_idIndexMarker1474"/>nested as well. For instance, here we have a "base" CTE that computes the employees' average salary per office. The next two CTEs <a id="_idIndexMarker1475"/>fetch from the "base" CTE the minimum and maximum average respectively. Finally, our query cross-joins these CTEs:</p>
			<pre class="source-code">ctx.with("avg_per_office")</pre>
			<pre class="source-code">   .as(select(EMPLOYEE.OFFICE_CODE.as("office"),</pre>
			<pre class="source-code">          avg(EMPLOYEE.SALARY).as("avg_salary_per_office"))</pre>
			<pre class="source-code">        .from(EMPLOYEE)</pre>
			<pre class="source-code">        .groupBy(EMPLOYEE.OFFICE_CODE))</pre>
			<pre class="source-code">   .with("min_salary_office")</pre>
			<pre class="source-code">   .as(select(min(field(name("avg_salary_per_office")))</pre>
			<pre class="source-code">          .as("min_avg_salary_per_office"))</pre>
			<pre class="source-code">        .from(name("avg_per_office")))</pre>
			<pre class="source-code">   .with("max_salary_office")</pre>
			<pre class="source-code">   .as(select(max(field(name("avg_salary_per_office")))</pre>
			<pre class="source-code">          .as("max_avg_salary_per_office"))</pre>
			<pre class="source-code">        .from(name("avg_per_office")))</pre>
			<pre class="source-code">   .select()</pre>
			<pre class="source-code">        .from(name("avg_per_office"))</pre>
			<pre class="source-code">        .crossJoin(name("min_salary_office"))</pre>
			<pre class="source-code">        .crossJoin(name("max_salary_office"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>The potential output is shown in the next figure:</p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B16833_Figure_14.2.jpg" alt="Figure 14.2 – Output of nested CTEs example&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.2 – Output of nested CTEs example</p>
			<p>In the <a id="_idIndexMarker1476"/>bundled code (<em class="italic">CteSimple</em>), you can see the explicit CTE version as well.</p>
			<p>Some <a id="_idIndexMarker1477"/>databases (for instance, MySQL and PostgreSQL) allow you to nest CTEs via the <strong class="source-inline">FROM</strong> clause. Here is an example:</p>
			<pre class="source-code">ctx.with("t2")</pre>
			<pre class="source-code">   .as(select(avg(field("sum_min_sal", Float.class))</pre>
			<pre class="source-code">           .as("avg_sum_min_sal")).from(</pre>
			<pre class="source-code">        with("t1")</pre>
			<pre class="source-code">           .as(select(min(EMPLOYEE.SALARY).as("min_sal"))</pre>
			<pre class="source-code">                .from(EMPLOYEE)</pre>
			<pre class="source-code">                .groupBy(EMPLOYEE.OFFICE_CODE)).select(</pre>
			<pre class="source-code">                   sum(field("min_sal", Float.class))</pre>
			<pre class="source-code">                       .as("sum_min_sal"))</pre>
			<pre class="source-code">                     .from(name("t1"))</pre>
			<pre class="source-code">                     .groupBy(field("min_sal"))))</pre>
			<pre class="source-code">   .select()</pre>
			<pre class="source-code">   .from(name("t2"))</pre>
			<pre class="source-code">   .fetch(); </pre>
			<p>So, this is a<a id="_idIndexMarker1478"/> three-step query: first, we <a id="_idIndexMarker1479"/>compute the minimum salary per office; second, we compute the sum of salaries per minimum salary; and third, we compute the average of these sums.</p>
			<h3>Materialized CTEs</h3>
			<p>Do you <a id="_idIndexMarker1480"/>have an expensive CTE that fetches a relatively <a id="_idIndexMarker1481"/>small result set and is used two or more times? Then most probably you have a CTE that you may want to materialize. The materialized CTE can then be referenced multiple times by the parent query without recomputing the results.</p>
			<p>In jOOQ, materializing a CTE can be done via <strong class="source-inline">asMaterialized()</strong>. Depending on the database, jOOQ will render the proper SQL. For instance, consider the following materialized CTE:</p>
			<pre class="source-code">ctx.with("cte", "customer_number", </pre>
			<pre class="source-code">         "order_line_number", "sum_price", "sum_quantity") </pre>
			<pre class="source-code">   .asMaterialized(</pre>
			<pre class="source-code">           select(ORDER.CUSTOMER_NUMBER, </pre>
			<pre class="source-code">                  ORDERDETAIL.ORDER_LINE_NUMBER,</pre>
			<pre class="source-code">                  sum(ORDERDETAIL.PRICE_EACH),</pre>
			<pre class="source-code">                  sum(ORDERDETAIL.QUANTITY_ORDERED))</pre>
			<pre class="source-code">               .from(ORDER)</pre>
			<pre class="source-code">               .join(ORDERDETAIL)</pre>
			<pre class="source-code">               .on(ORDER.ORDER_ID.eq(ORDERDETAIL.ORDER_ID))</pre>
			<pre class="source-code">               .groupBy(ORDERDETAIL.ORDER_LINE_NUMBER, </pre>
			<pre class="source-code">                        ORDER.CUSTOMER_NUMBER))</pre>
			<pre class="source-code">   .select(field(name("customer_number")), </pre>
			<pre class="source-code">      inline("Order Line Number").as("metric"),</pre>
			<pre class="source-code">      field(name("order_line_number"))).from(name("cte")) // 1</pre>
			<pre class="source-code">   .unionAll(select(field(name("customer_number")), </pre>
			<pre class="source-code">      inline("Sum Price").as("metric"),</pre>
			<pre class="source-code">      field(name("sum_price"))).from(name("cte")))        // 2 </pre>
			<pre class="source-code">   .unionAll(select(field(name("customer_number")),  </pre>
			<pre class="source-code">      inline("Sum Quantity").as("metric"),</pre>
			<pre class="source-code">      field(name("sum_quantity"))).from(name("cte")))     // 3 </pre>
			<pre class="source-code">   .fetch();</pre>
			<p>This <a id="_idIndexMarker1482"/>CTE should be evaluated three<a id="_idIndexMarker1483"/> times (denoted in code as //1, //2, and //3). Hopefully, thanks to <strong class="source-inline">asMaterialized()</strong>, the result of the CTE should be materialized and reused instead of being recomputed.</p>
			<p>Some databases detect that a CTE is used more than once (the <strong class="source-inline">WITH</strong> clause is referenced more than once in the outer query) and automatically try to materialize the result set as an optimization fence. For instance, PostgreSQL will materialize the above CTE even if we don't use <strong class="source-inline">asMaterialized()</strong> and we simply use <strong class="source-inline">as()</strong> because the <strong class="source-inline">WITH</strong> query is called three times. </p>
			<p>But, PostgreSQL allows us to control the CTE materialization and change the default behavior. If we want to force inlining the CTE instead of it being materialized, then we add the <strong class="source-inline">NOT MATERIALIZED</strong> hint to the CTE. In jOOQ, this is accomplished via <strong class="source-inline">asNotMaterialized()</strong>:</p>
			<pre class="source-code">ctx.with("cte", "customer_number", </pre>
			<pre class="source-code">         "order_line_number", "sum_price", "sum_quantity") </pre>
			<pre class="source-code">   .asNotMaterialized(select(ORDER.CUSTOMER_NUMBER, </pre>
			<pre class="source-code">                      ORDERDETAIL.ORDER_LINE_NUMBER, ...</pre>
			<p>On the other hand, in Oracle, we can control materialization via the <strong class="source-inline">/*+ materialize */</strong> and <strong class="source-inline">/*+ inline */</strong> hints. Using jOOQ's <strong class="source-inline">asMaterialized()</strong> renders the <strong class="source-inline">/*+ materialize */</strong> hint, while <strong class="source-inline">asNotMaterialized()</strong> renders the <strong class="source-inline">/*+ inline */</strong> hint. Using jOOQ's <strong class="source-inline">as()</strong> doesn't render any hint, so Oracle's optimizer is free to act as the default.</p>
			<p>However, Lukas Eder said: <em class="italic">Note that the Oracle hints aren't documented, so they might change (though all possible Oracle guru blogs document their de facto functionality, so knowing Oracle, they won't break easily). If not explicitly documented, there's never any *guarantee* for any *materialization trick* to keep working.</em></p>
			<p>Other databases don't support<a id="_idIndexMarker1484"/> materialization at <a id="_idIndexMarker1485"/>all or use it only as an internal mechanism of the optimizer (for instance, MySQL). Using jOOQ's <strong class="source-inline">as()</strong>, <strong class="source-inline">asMaterialized()</strong>, and <strong class="source-inline">asNotMaterialized()</strong> renders the same SQL for MySQL, therefore we cannot rely on explicit materialization. In such cases, we can attempt to rewrite our CTE to avoid recalls. For instance, the previous CTE can be optimized to not need materialization in MySQL via <strong class="source-inline">LATERAL</strong>:</p>
			<pre class="source-code">ctx.with("cte")</pre>
			<pre class="source-code"> .as(</pre>
			<pre class="source-code">   select(ORDER.CUSTOMER_NUMBER, </pre>
			<pre class="source-code">          ORDERDETAIL.ORDER_LINE_NUMBER,</pre>
			<pre class="source-code">          sum(ORDERDETAIL.PRICE_EACH).as("sum_price"),</pre>
			<pre class="source-code">          sum(ORDERDETAIL.QUANTITY_ORDERED)</pre>
			<pre class="source-code">              .as("sum_quantity"))</pre>
			<pre class="source-code">    .from(ORDER)</pre>
			<pre class="source-code">    .join(ORDERDETAIL)</pre>
			<pre class="source-code">      .on(ORDER.ORDER_ID.eq(ORDERDETAIL.ORDER_ID))</pre>
			<pre class="source-code">    .groupBy(ORDERDETAIL.ORDER_LINE_NUMBER, </pre>
			<pre class="source-code">             ORDER.CUSTOMER_NUMBER))</pre>
			<pre class="source-code"> .select(field(name("customer_number")),</pre>
			<pre class="source-code">   field(name("t", "metric")), field(name("t", "value")))</pre>
			<pre class="source-code">    .from(table(name("cte")), lateral(</pre>
			<pre class="source-code">      select(inline("Order Line Number").as("metric"),</pre>
			<pre class="source-code">       field(name("order_line_number")).as("value"))</pre>
			<pre class="source-code">      .unionAll(select(inline("Sum Price").as("metric"),</pre>
			<pre class="source-code">        field(name("sum_price")).as("value")))</pre>
			<pre class="source-code">      .unionAll(select(inline("Sum Quantity").as("metric"),</pre>
			<pre class="source-code">        field(name("sum_quantity")).as("value"))))</pre>
			<pre class="source-code"> .as("t")).fetch();</pre>
			<p>Here is the<a id="_idIndexMarker1486"/> alternative for SQL Server (like MySQL, SQL Server doesn't expose any support for explicit materialization; however, there is <a id="_idIndexMarker1487"/>a proposal for Microsoft to add a dedicated hint similar to what Oracle has) using <strong class="source-inline">CROSS APPLY</strong> and the <strong class="source-inline">VALUES</strong> constructor:</p>
			<pre class="source-code">ctx.with("cte")</pre>
			<pre class="source-code"> .as(select(ORDER.CUSTOMER_NUMBER, </pre>
			<pre class="source-code">            ORDERDETAIL.ORDER_LINE_NUMBER,</pre>
			<pre class="source-code">            sum(ORDERDETAIL.PRICE_EACH).as("sum_price"),</pre>
			<pre class="source-code">            sum(ORDERDETAIL.QUANTITY_ORDERED)</pre>
			<pre class="source-code">                .as("sum_quantity"))</pre>
			<pre class="source-code"> .from(ORDER)</pre>
			<pre class="source-code"> .join(ORDERDETAIL)</pre>
			<pre class="source-code">   .on(ORDER.ORDER_ID.eq(ORDERDETAIL.ORDER_ID))</pre>
			<pre class="source-code"> .groupBy(ORDERDETAIL.ORDER_LINE_NUMBER, </pre>
			<pre class="source-code">          ORDER.CUSTOMER_NUMBER))</pre>
			<pre class="source-code"> .select(field(name("customer_number")),</pre>
			<pre class="source-code">    field(name("t", "metric")), field(name("t", "value")))</pre>
			<pre class="source-code"> .from(name("cte")).crossApply(</pre>
			<pre class="source-code">   values(row("Order Line Number",</pre>
			<pre class="source-code">          field(name("cte", "order_line_number"))),</pre>
			<pre class="source-code">     row("Sum Price", field(name("cte", "sum_price"))),</pre>
			<pre class="source-code">     row("Sum Quantity", field(name("cte", "sum_quantity"))))</pre>
			<pre class="source-code">      .as("t", "metric", "value")).fetch();</pre>
			<p>A good cost-based optimizer should always rewrite all SQL statements to the optimal execution plan, so what may work today, might not work tomorrow – such as this <strong class="source-inline">LATERAL</strong>/<strong class="source-inline">CROSS APPLY</strong> trick. If the optimizer is ever smart enough to detect that <strong class="source-inline">LATERAL</strong>/<strong class="source-inline">CROSS APPLY</strong> is unnecessary (for example, because of the lack of correlation), then it might be (should be) eliminated.</p>
			<p>You can check out all these <a id="_idIndexMarker1488"/>examples in <em class="italic">CteSimple</em>. Moreover, in the <em class="italic">CteAggRem</em> application, you can practice a CTE for calculating the top N items and aggregating (summing) the remainder in a separate row. Basically, while ranking items in the <a id="_idIndexMarker1489"/>database is a common problem to compute top/bottom N items, another common requirement that is related to this one is to obtain all the other rows (that don't fit in top/bottom N) in a separate row. This is helpful to provide a complete context when presenting data. </p>
			<p>In the <em class="italic">CteWMAvg</em> code, you can check out a statistics problem with the main goal being to highlight recent points. This <a id="_idIndexMarker1490"/>problem is known as <strong class="bold">Weighted Moving Average</strong> (<strong class="bold">WMA</strong>). This is part of the moving average<a id="_idIndexMarker1491"/> family (<a href="https://en.wikipedia.org/wiki/Moving_average">https://en.wikipedia.org/wiki/Moving_average</a>) and, in a nutshell, WMA is a moving average where the previous values (points) range in the sliding window are given different (fractional) weights.</p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor290"/>Recursive CTEs</h2>
			<p>Besides regular CTEs, we<a id="_idIndexMarker1492"/> have<a id="_idIndexMarker1493"/> recursive CTEs. </p>
			<p>In a nutshell, recursive CTEs reproduce the concept of for-loops in programming. A recursive CTE can handle and explore hierarchical data by referencing themselves. Behind a recursive CTE, there are two main members:</p>
			<ul>
				<li>The <em class="italic">anchor</em> member – Its goal is to select the starting rows of the involved recursive steps.</li>
				<li>The <em class="italic">recursive</em> member – Its goal is to generate rows for the CTE. The first iteration step acts against the anchor rows, while the second iteration step acts against the rows previously created in recursions steps. This member occurs after a <strong class="source-inline">UNION ALL</strong> in the CTE definition part. To be more accurate, <strong class="source-inline">UNION ALL</strong> is required by a few dialects, but others are capable of recurring with <strong class="source-inline">UNION</strong> as well, with slightly different semantics.</li>
			</ul>
			<p>In jOOQ, recursive CTEs can be expressed via the <strong class="source-inline">withRecursive()</strong> method.</p>
			<p>Here's a simple recursive CTE that computes the famous Fibonacci numbers. The <em class="italic">anchor</em> member is equal to 1, and the <em class="italic">recursive</em> member applies the Fibonacci formula up to the number 20:</p>
			<pre class="source-code">ctx.withRecursive("fibonacci", "n", "f", "f1")</pre>
			<pre class="source-code">   .as(select(inline(1L), inline(0L), inline(1L))</pre>
			<pre class="source-code">   .unionAll(select(field(name("n"), Long.class).plus(1),</pre>
			<pre class="source-code">     field(name("f"), Long.class).plus(field(name("f1"))),</pre>
			<pre class="source-code">     field(name("f"), Long.class))</pre>
			<pre class="source-code">   .from(name("fibonacci"))</pre>
			<pre class="source-code">   .where(field(name("n")).lt(20))))</pre>
			<pre class="source-code">   .select(field(name("n")), field(name("f")).as("f_nbr"))</pre>
			<pre class="source-code">   .from(name("fibonacci"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Well, that <a id="_idIndexMarker1494"/>was easy, wasn't it? Next, let's tackle a famous problem that can be solved <a id="_idIndexMarker1495"/>via recursive CTE, known as the Travelling Salesman Problem. Consider <a id="_idIndexMarker1496"/>reading more details here: <a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem">https://en.wikipedia.org/wiki/Travelling_salesman_problem</a>. In a nutshell, we interpret this problem to find the shortest private flight through several cities representing locations of our offices. Basically, in <strong class="source-inline">OFFICE_FLIGHTS</strong>, we have the routes between our offices as <strong class="source-inline">OFFICE_FLIGHTS.DEPART_TOWN</strong>, <strong class="source-inline">OFFICE_FLIGHTS.ARRIVAL_TOWN</strong>, and <strong class="source-inline">OFFICE_FLIGHTS.DISTANCE_KM</strong>. For instance, our CTE will use <em class="italic">Los Angeles</em> as its anchor city, and then recursively traverse every other city in order to reach <em class="italic">Tokyo</em>:</p>
			<pre class="source-code">String from = "Los Angeles";</pre>
			<pre class="source-code">String to = "Tokyo";</pre>
			<pre class="source-code">ctx.withRecursive("flights", </pre>
			<pre class="source-code">      "arrival_town", "steps", "total_distance_km", "path")</pre>
			<pre class="source-code"> .as(selectDistinct(OFFICE_FLIGHTS.DEPART_TOWN</pre>
			<pre class="source-code">   .as("arrival_town"), inline(0).as("steps"), inline(0)</pre>
			<pre class="source-code">   .as("total_distance_km"), cast(from, SQLDataType.VARCHAR)</pre>
			<pre class="source-code">   .as("path"))</pre>
			<pre class="source-code"> .from(OFFICE_FLIGHTS)</pre>
			<pre class="source-code"> .where(OFFICE_FLIGHTS.DEPART_TOWN.eq(from))</pre>
			<pre class="source-code"> .unionAll(select(field(name("arrivals", "arrival_town"), </pre>
			<pre class="source-code">            String.class), field(name("flights", "steps"), </pre>
			<pre class="source-code">            Integer.class).plus(1), field(name("flights", </pre>
			<pre class="source-code">            "total_distance_km"), Integer.class).plus(</pre>
			<pre class="source-code">            field(name("arrivals", "distance_km"))),</pre>
			<pre class="source-code">            concat(field(name("flights", "path")),inline(","), </pre>
			<pre class="source-code">            field(name("arrivals", "arrival_town"))))</pre>
			<pre class="source-code">          .from(OFFICE_FLIGHTS.as("arrivals"),  </pre>
			<pre class="source-code">            table(name("flights")))</pre>
			<pre class="source-code">          .where(field(name("flights", "arrival_town"))</pre>
			<pre class="source-code">           .eq(field(name("arrivals", "depart_town")))</pre>
			<pre class="source-code">            .and(field(name("flights", "path"))</pre>
			<pre class="source-code">             .notLike(concat(inline("%"),</pre>
			<pre class="source-code">              field(name("arrivals", "arrival_town")),</pre>
			<pre class="source-code">               inline("%")))))))</pre>
			<pre class="source-code">          .select()</pre>
			<pre class="source-code">            .from(name("flights"))</pre>
			<pre class="source-code">            .where(field(name("arrival_town")).eq(to))</pre>
			<pre class="source-code">            .orderBy(field(name("total_distance_km")))</pre>
			<pre class="source-code"> .fetch();</pre>
			<p>Some possible<a id="_idIndexMarker1497"/> output is in the <a id="_idIndexMarker1498"/>next figure:</p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B16833_Figure_14.3.jpg" alt="Figure 14.3 – Shortest private flight from Los Angeles to Tokyo, 18,983 km&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.3 – Shortest private flight from Los Angeles to Tokyo, 18,983 km</p>
			<p>You can practice these examples in <em class="italic">CteRecursive</em>.</p>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor291"/>CTEs and window functions</h2>
			<p>In this section, let's<a id="_idIndexMarker1499"/> look at two examples that combine CTE and window functions, and let's start with an example that computes the gaps in IDs. For instance, each <strong class="source-inline">EMPLOYEE</strong> has an associated <strong class="source-inline">EMPLOYEE_NUMBER</strong> and we want to find out how many values are missing from the data values (missing <strong class="source-inline">EMPLOYEE_NUMBER</strong>), and how many existing values are consecutive. This is a job for the <strong class="source-inline">ROW_NUMBER()</strong> window and the following CTE:</p>
			<pre class="source-code">ctx.with("t", "data_val", "data_seq", "absent_data_grp")</pre>
			<pre class="source-code">   .as(select(EMPLOYEE.EMPLOYEE_NUMBER,</pre>
			<pre class="source-code">       rowNumber().over()</pre>
			<pre class="source-code">         .orderBy(EMPLOYEE.EMPLOYEE_NUMBER)))</pre>
			<pre class="source-code">       EMPLOYEE.EMPLOYEE_NUMBER.minus(</pre>
			<pre class="source-code">       rowNumber().over()</pre>
			<pre class="source-code">          .orderBy(EMPLOYEE.EMPLOYEE_NUMBER)))</pre>
			<pre class="source-code">       .from(EMPLOYEE))</pre>
			<pre class="source-code">   .select(field(name("absent_data_grp")), count(),</pre>
			<pre class="source-code">       min(field(name("data_val"))).as("start_data_val"))</pre>
			<pre class="source-code">   .from(name("t"))</pre>
			<pre class="source-code">   .groupBy(field(name("absent_data_grp")))</pre>
			<pre class="source-code">   .orderBy(field(name("absent_data_grp")))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>While you can see this example in the bundled code, let's look at another one that finds the percentile rank of every product line by order values:</p>
			<pre class="source-code">ctx.with("t", "product_line", "sum_price_each")</pre>
			<pre class="source-code">   .as(select(PRODUCT.PRODUCT_LINE, </pre>
			<pre class="source-code">          sum(ORDERDETAIL.PRICE_EACH))</pre>
			<pre class="source-code">        .from(PRODUCT)</pre>
			<pre class="source-code">        .join(ORDERDETAIL)</pre>
			<pre class="source-code">          .on(PRODUCT.PRODUCT_ID.eq(ORDERDETAIL.PRODUCT_ID))</pre>
			<pre class="source-code">        .groupBy(PRODUCT.PRODUCT_LINE))</pre>
			<pre class="source-code">   .select(field(name("product_line")),  </pre>
			<pre class="source-code">           field(name("sum_price_each")),</pre>
			<pre class="source-code">           round(percentRank().over()</pre>
			<pre class="source-code">           .orderBy(field(name("sum_price_each"))).mul(100), 2)</pre>
			<pre class="source-code">           .concat("%").as("percentile_rank"))</pre>
			<pre class="source-code">   .from(name("t"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>You can find <a id="_idIndexMarker1500"/>these examples along with another one that finds the top three highest-valued orders each year in <em class="italic">CteWf</em>.</p>
			<h2 id="_idParaDest-293"><a id="_idTextAnchor292"/>Using CTEs to generate data</h2>
			<p>CTEs are quite <a id="_idIndexMarker1501"/>handy for generating data – they<a id="_idIndexMarker1502"/> act as the source of data for the SQL statement that uses a CTE. For instance, using a CTE and the <strong class="source-inline">VALUES</strong> constructor can be done as follows:</p>
			<pre class="source-code">ctx.with("dt")</pre>
			<pre class="source-code">   .as(select()</pre>
			<pre class="source-code">   .from(values(row(1, "John"), row(2, "Mary"), row(3, "Kelly"))</pre>
			<pre class="source-code">            .as("t", "id", "name")))</pre>
			<pre class="source-code">   .select()</pre>
			<pre class="source-code">   .from(name("dt"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Or, using a CTE to unnest an array can be done as follows:</p>
			<pre class="source-code">ctx.with("dt")</pre>
			<pre class="source-code">   .as(select().from(unnest(new String[]</pre>
			<pre class="source-code">       {"John", "Mary", "Kelly"}).as("n")))</pre>
			<pre class="source-code">   .select()</pre>
			<pre class="source-code">   .from(name("dt"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Or, here is an example of unnesting an array to pick up a random value:</p>
			<pre class="source-code">ctx.with("dt")</pre>
			<pre class="source-code">   .as(select().from(unnest(new String[]</pre>
			<pre class="source-code">        {"John", "Mary", "Kelly"}).as("n")))</pre>
			<pre class="source-code">   .select()</pre>
			<pre class="source-code">   .from(name("dt"))</pre>
			<pre class="source-code">   .orderBy(rand())</pre>
			<pre class="source-code">   .limit(1)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Or, maybe you <a id="_idIndexMarker1503"/>need a random sample from the<a id="_idIndexMarker1504"/> database (here, 10 random products):</p>
			<pre class="source-code">ctx.with("dt")</pre>
			<pre class="source-code">   .as(selectFrom(PRODUCT).orderBy(rand()).limit(10))</pre>
			<pre class="source-code">   .select()</pre>
			<pre class="source-code">   .from(name("dt"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>However, keep in mind that <strong class="source-inline">ORDER BY RAND()</strong> should be avoided for large tables, as <strong class="source-inline">ORDER BY</strong> performs with O(N log N).</p>
			<p>If you need more sophisticated sources of data, then probably you'll be interested in generating a series. Here is an example of generating the odd numbers between 1 and 10:</p>
			<pre class="source-code">ctx.with("dt")</pre>
			<pre class="source-code">   .as(select().from(generateSeries(1, 10, 2).as("t", "s")))</pre>
			<pre class="source-code">   .select()</pre>
			<pre class="source-code">   .from(name("dt"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Here is an example <a id="_idIndexMarker1505"/>that associates grades between 1 and 100 with the letters A to F and counts them as well – in other words, custom <a id="_idIndexMarker1506"/>binning of grades:</p>
			<pre class="source-code">ctx.with("grades")</pre>
			<pre class="source-code">   .as(select(round(inline(70).plus(sin(</pre>
			<pre class="source-code">         field(name("serie", "sample"), Integer.class))</pre>
			<pre class="source-code">           .mul(30))).as("grade"))</pre>
			<pre class="source-code">   .from(generateSeries(1, 100).as("serie", "sample")))</pre>
			<pre class="source-code">   .select(</pre>
			<pre class="source-code">     case_().when(field(name("grade")).lt(60), "F")</pre>
			<pre class="source-code">            .when(field(name("grade")).lt(70), "D")</pre>
			<pre class="source-code">            .when(field(name("grade")).lt(80), "C")</pre>
			<pre class="source-code">            .when(field(name("grade")).lt(90), "B")</pre>
			<pre class="source-code">            .else_("A").as("letter_grade"),count())</pre>
			<pre class="source-code">   .from(name("grades"))</pre>
			<pre class="source-code">   .groupBy(field(name("letter_grade")))</pre>
			<pre class="source-code">   .orderBy(field(name("letter_grade")))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>In the bundled code, you can see more binning examples including custom binning of grades via <strong class="source-inline">PERCENT_RANK()</strong>, equal height binning, equal-width binning, the PostgreSQL <strong class="source-inline">width_bucket()</strong> function, and binning with a chart.</p>
			<p>After all these <a id="_idIndexMarker1507"/>snippets, let's tackle the following<a id="_idIndexMarker1508"/> famous problem: Consider <strong class="source-inline">p</strong> student classes of certain sizes, and <strong class="source-inline">q</strong> rooms of certain sizes, where <strong class="source-inline">q</strong>&gt;= <strong class="source-inline">p</strong>. Write a CTE for assigning as many classes as possible to rooms of proper size. Let's assume that the given data is in the left-hand side figure and the expected result is in the right-hand side figure:</p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/B16833_Figure_14.4.jpg" alt="Figure 14.4 – Input and expected output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.4 – Input and expected output</p>
			<p>In order to solve this problem, we can generate the input data as follows:</p>
			<pre class="source-code">ctx.with("classes")</pre>
			<pre class="source-code"> .as(select()</pre>
			<pre class="source-code"> .from(values(row("c1", 80), row("c2", 70), row("c3", 65),</pre>
			<pre class="source-code">              row("c4", 55), row("c5", 50), row("c6", 40))</pre>
			<pre class="source-code">              .as("t", "class_nbr", "class_size")))</pre>
			<pre class="source-code"> .with("rooms")</pre>
			<pre class="source-code"> .as(select()</pre>
			<pre class="source-code"> .from(values(row("r1", 70), row("r2", 40), row("r3", 50),</pre>
			<pre class="source-code">   row("r4", 85), row("r5", 30), row("r6", 65), row("r7", 55))</pre>
			<pre class="source-code"> .as("t", "room_nbr", "room_size")))</pre>
			<pre class="source-code">…</pre>
			<p>The complete <a id="_idIndexMarker1509"/>query is quite large to be listed here, but<a id="_idIndexMarker1510"/> you can find it in the <em class="italic">CteGenData</em> application next to all the examples from this section.</p>
			<h2 id="_idParaDest-294"><a id="_idTextAnchor293"/>Dynamic CTEs</h2>
			<p>Commonly, when <a id="_idIndexMarker1511"/>we need to dynamically create a CTE, we<a id="_idIndexMarker1512"/> plan to dynamically shape its name, derived table(s), and the outer query. For instance, the following method allows us to pass these components as arguments and return the result of executing the query:</p>
			<pre class="source-code">public Result&lt;Record&gt; cte(String cteName, Select select, </pre>
			<pre class="source-code">          SelectField&lt;?&gt;[] fields, Condition condition, </pre>
			<pre class="source-code">          GroupField[] groupBy, SortField&lt;?&gt;[] orderBy) {</pre>
			<pre class="source-code">  var cte = ctx.with(cteName).as(select);</pre>
			<pre class="source-code">  var cteSelect = fields == null </pre>
			<pre class="source-code">    ? cte.select() : cte.select(fields)</pre>
			<pre class="source-code">        .from(table(name(cteName)));</pre>
			<pre class="source-code">  if (condition != null) {</pre>
			<pre class="source-code">     cteSelect.where(condition);</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  if (groupBy != null) {</pre>
			<pre class="source-code">     cteSelect.groupBy(groupBy);</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  if (orderBy != null) {</pre>
			<pre class="source-code">     cteSelect.orderBy(orderBy);</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  return cteSelect.fetch();</pre>
			<pre class="source-code">}</pre>
			<p>Here is a calling sample <a id="_idIndexMarker1513"/>for solving the problem presented<a id="_idIndexMarker1514"/> earlier, in the <em class="italic">CTEs and window functions</em> section:</p>
			<pre class="source-code">Result&lt;Record&gt; result = cte("t",</pre>
			<pre class="source-code"> select(EMPLOYEE.EMPLOYEE_NUMBER.as("data_val"),</pre>
			<pre class="source-code">   rowNumber().over().orderBy(EMPLOYEE.EMPLOYEE_NUMBER)</pre>
			<pre class="source-code">   .as("data_seq"), EMPLOYEE.EMPLOYEE_NUMBER.minus(</pre>
			<pre class="source-code">   rowNumber().over().orderBy(EMPLOYEE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">   .as("absent_data_grp"))</pre>
			<pre class="source-code">   .from(EMPLOYEE),</pre>
			<pre class="source-code">   new Field[]{field(name("absent_data_grp")), count(),</pre>
			<pre class="source-code">        min(field(name("data_val"))).as("start_data_val")},</pre>
			<pre class="source-code">   null, new GroupField[]{field(name("absent_data_grp"))},</pre>
			<pre class="source-code">   null);</pre>
			<p>Whenever you try to implement a CTE, as here, consider this Lukas Eder note: <em class="italic">This example uses the DSL in a mutable way, which works but is discouraged. A future jOOQ version might turn to an immutable DSL API and this code will stop working. It's unlikely to happen soon, because of the huge backward incompatibility, but the discouragement is real already today :) In IntelliJ, you should already get a warning in this code, because of the API's </em><strong class="source-inline">@CheckReturnValue</strong><em class="italic"> annotation usage, at least in jOOQ 3.15</em>.</p>
			<p>On the other<a id="_idIndexMarker1515"/> hand, if you just need to pass a variable number <a id="_idIndexMarker1516"/>of CTEs to the outer query, then you can do this:</p>
			<pre class="source-code">public void CTE(List&lt;CommonTableExpression&lt;?&gt;&gt; CTE) {</pre>
			<pre class="source-code">  ctx.with(CTE)</pre>
			<pre class="source-code">     ...</pre>
			<pre class="source-code">}</pre>
			<p>Or, you can do this:</p>
			<pre class="source-code">public void CTE(CommonTableExpression&lt;?&gt; cte1, </pre>
			<pre class="source-code">  CommonTableExpression&lt;?&gt;cte2, </pre>
			<pre class="source-code">  CommonTableExpression&lt;?&gt;cte3, ...) {</pre>
			<pre class="source-code"> ctx.with(cte1, cte2, cte3)</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">}</pre>
			<p>You can <a id="_idIndexMarker1517"/>practice these<a id="_idIndexMarker1518"/> examples in <em class="italic">CteDynamic</em>.</p>
			<h2 id="_idParaDest-295"><a id="_idTextAnchor294"/>Expressing a query via a derived table, a temporary table, and a CTE</h2>
			<p>Sometimes, we<a id="_idIndexMarker1519"/> prefer to express a query in several ways to <a id="_idIndexMarker1520"/>compare their execution plans. For instance, we may have a query and express it via derived tables, temporary tables, and CTE to see which approach fits best. Since jOOQ supports these approaches, let's try to express a query starting from the derived tables approach:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME,</pre>
			<pre class="source-code">   sum(SALE.SALE_), field(select(sum(SALE.SALE_)).from(SALE))</pre>
			<pre class="source-code">     .divide(field(select(countDistinct(SALE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">    .from(SALE))).as("avg_sales"))</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .innerJoin(SALE)</pre>
			<pre class="source-code">   .on(EMPLOYEE.EMPLOYEE_NUMBER.eq(SALE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">   .groupBy(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">   .having(sum(SALE.SALE_).gt(field(select(sum(SALE.SALE_))</pre>
			<pre class="source-code">    .from(SALE))</pre>
			<pre class="source-code">   .divide(field(select(countDistinct(SALE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">    .from(SALE))))).fetch();</pre>
			<p>So, this query returns all employees with above-average sales. For each employee, we compare their average sales to the total average sales for all employees. Essentially, this query works on the <strong class="source-inline">EMPLOYEE</strong> and <strong class="source-inline">SALE</strong> tables, and we must know the total sales for all employees, the number of employees, and the sum of sales for each employee.</p>
			<p>If we extract<a id="_idIndexMarker1521"/> what we must know in three temporary tables, then we<a id="_idIndexMarker1522"/> obtain this:</p>
			<pre class="source-code">ctx.createTemporaryTable("t1").as(</pre>
			<pre class="source-code">  select(sum(SALE.SALE_).as("sum_all_sales"))</pre>
			<pre class="source-code">   .from(SALE)).execute();</pre>
			<pre class="source-code">ctx.createTemporaryTable("t2").as(</pre>
			<pre class="source-code">  select(countDistinct(SALE.EMPLOYEE_NUMBER)</pre>
			<pre class="source-code">    .as("nbr_employee")).from(SALE)).execute();</pre>
			<pre class="source-code">ctx.createTemporaryTable("t3").as(</pre>
			<pre class="source-code">  select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME, </pre>
			<pre class="source-code">       sum(SALE.SALE_).as("employee_sale"))</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .innerJoin(SALE)</pre>
			<pre class="source-code">   .on(EMPLOYEE.EMPLOYEE_NUMBER.eq(SALE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">   .groupBy(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Having these <a id="_idIndexMarker1523"/>three temporary <a id="_idIndexMarker1524"/>tables, we can rewrite our query as follows:</p>
			<pre class="source-code">ctx.select(field(name("first_name")),field(name("last_name")),</pre>
			<pre class="source-code">    field(name("employee_sale")), field(name("sum_all_sales"))</pre>
			<pre class="source-code"> .divide(field(name("nbr_employee"), Integer.class))</pre>
			<pre class="source-code">   .as("avg_sales"))</pre>
			<pre class="source-code"> .from(table(name("t1")),table(name("t2")), table(name("t3")))</pre>
			<pre class="source-code"> .where(field(name("employee_sale")).gt(</pre>
			<pre class="source-code">   field(name("sum_all_sales")).divide(</pre>
			<pre class="source-code">     field(name("nbr_employee"), Integer.class))))</pre>
			<pre class="source-code"> .fetch();</pre>
			<p>Finally, the same <a id="_idIndexMarker1525"/>query can be expressed via CTE (by replacing <strong class="source-inline">as()</strong> with <strong class="source-inline">asMaterialized()</strong>, you<a id="_idIndexMarker1526"/> can practice the materialization of this CTE):</p>
			<pre class="source-code">ctx.with("cte1", "sum_all_sales")</pre>
			<pre class="source-code"> .as(select(sum(SALE.SALE_)).from(SALE)) </pre>
			<pre class="source-code"> .with("cte2", "nbr_employee")</pre>
			<pre class="source-code"> .as(select(countDistinct(SALE.EMPLOYEE_NUMBER)).from(SALE))</pre>
			<pre class="source-code"> .with("cte3", "first_name", "last_name", "employee_sale")</pre>
			<pre class="source-code"> .as(select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME, </pre>
			<pre class="source-code">    sum(SALE.SALE_).as("employee_sale"))</pre>
			<pre class="source-code">     .from(EMPLOYEE)</pre>
			<pre class="source-code">     .innerJoin(SALE)</pre>
			<pre class="source-code">     .on(EMPLOYEE.EMPLOYEE_NUMBER.eq(SALE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">     .groupBy(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME))</pre>
			<pre class="source-code">     .select(field(name("first_name")), </pre>
			<pre class="source-code">      field(name("last_name")), field(name("employee_sale")),    </pre>
			<pre class="source-code">      field(name("sum_all_sales"))</pre>
			<pre class="source-code">       .divide(field(name("nbr_employee"), Integer.class))</pre>
			<pre class="source-code">         .as("avg_sales"))</pre>
			<pre class="source-code">       .from(table(name("cte1")), table(name("cte2")), </pre>
			<pre class="source-code">             table(name("cte3")))</pre>
			<pre class="source-code">       .where(field(name("employee_sale")).gt(</pre>
			<pre class="source-code">         field(name("sum_all_sales")).divide(</pre>
			<pre class="source-code">         field(name("nbr_employee"), Integer.class))))</pre>
			<pre class="source-code"> .fetch();</pre>
			<p>Now you just have to run these queries against your database and compare their performances and execution plans. The bundled code contains one more example and is available as <em class="italic">ToCte</em>.</p>
			<h1 id="_idParaDest-296"><a id="_idTextAnchor295"/>Handling views in jOOQ</h1>
			<p>The last section of this chapter is reserved for database views.</p>
			<p>A view <a id="_idIndexMarker1527"/>acts as an actual physical table that can be invoked by name. They fit well for reporting tasks or integration with third-party tools that need a guided query API. By default, the database vendor decides to materialize the results of the view or to rely on other mechanisms to get the same effect. Most vendors (hopefully) don't default to materializing views! Views should behave just like CTE or derived tables and should be transparent to the optimizer. In most cases (in Oracle), we would expect a view to be inlined, even when selected several times, because each time, a different predicate might be pushed down into the view. Actual materialized views are supported only by a few vendors, while the optimizer can decide to materialize the view contents when a view is queried several times. The view's definition is stored in the schema tables so it can be invoked by name wherever a regular/base table could be used. If the view is updatable, then some additional rules come to sustain it.</p>
			<p>A view differs by a base, temporary, or derived table in several essential aspects. Base and temporary tables accept constraints, while a view doesn't (in most databases). A view has no presence in the database until it is invoked, whereas a temporary table is persistent. Finally, a derived table has the same scope as the query in which it is created. The view definition cannot contain a reference to itself, since it does not exist yet, but it can contain references to other views.</p>
			<p>The basic syntax of a view is as follows (for the exact syntax of a certain database vendor, you should consult the documentation):</p>
			<pre class="source-code">CREATE VIEW &lt;table name&gt; [(&lt;view column list&gt;)]</pre>
			<pre class="source-code">   AS &lt;query expression&gt;</pre>
			<pre class="source-code">    [WITH [&lt;levels clause&gt;] CHECK OPTION]</pre>
			<pre class="source-code">       &lt;levels clause&gt;::= CASCADED | LOCAL</pre>
			<p>Some RDBMS support constraints on views (for instance, Oracle), though with limitations: <a href="https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/constraint.html">https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/constraint.html</a>. The documented <strong class="source-inline">WITH CHECK OPTION</strong> is actually a constraint.</p>
			<p>Next, let's see some examples of views expressed via jOOQ.</p>
			<h2 id="_idParaDest-297"><a id="_idTextAnchor296"/>Updatable and read-only views</h2>
			<p>Views can<a id="_idIndexMarker1528"/> be either <a id="_idIndexMarker1529"/>updatable or <a id="_idIndexMarker1530"/>read-only, but not <a id="_idIndexMarker1531"/>both. In jOOQ, they can be created via the <strong class="source-inline">createView()</strong> and <strong class="source-inline">createViewIfNotExists()</strong> methods. Dropping a view can be done via <strong class="source-inline">dropView()</strong>, respectively <strong class="source-inline">dropViewIfExists()</strong>. Here is an example of creating a read-only view:</p>
			<pre class="source-code">ctx.createView("sales_1504_1370")</pre>
			<pre class="source-code">   .as(select().from(SALE).where(</pre>
			<pre class="source-code">       SALE.EMPLOYEE_NUMBER.eq(1504L))</pre>
			<pre class="source-code">   .unionAll(select().from(SALE)</pre>
			<pre class="source-code">   .where(SALE.EMPLOYEE_NUMBER.eq(1370L))))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Roughly, in standard SQL, an updatable view is built on only one table; it cannot contain <strong class="source-inline">GROUP BY</strong>, <strong class="source-inline">HAVING</strong>, <strong class="source-inline">INTERSECT</strong>, <strong class="source-inline">EXCEPT</strong>, <strong class="source-inline">SELECT DISTINCT</strong>, or <strong class="source-inline">UNION</strong> (however, at least in theory, a <strong class="source-inline">UNION</strong> between two disjoint tables, neither of which has duplicate rows in itself, should be updatable), aggregate functions, calculated columns, and any columns excluded from the view must have <strong class="source-inline">DEFAULT</strong> in the base table or be null-able. However, according to the standard SQL T111 optional feature, joins and unions aren't an impediment to updatability per se, so an updatable view doesn't have to be built "on only one table." Also (for the avoidance of any doubt), not all columns of an updatable view have to be updatable, but of course, only updatable columns can be updated.</p>
			<p>When the view is modified, the<a id="_idIndexMarker1532"/> modifications pass through the view to the <a id="_idIndexMarker1533"/>corresponding underlying base table. In other words, an updatable view has a 1:1 match between its rows and the rows of the underlying base table, therefore the previous view is not updatable. But we can rewrite it without <strong class="source-inline">UNION ALL</strong> to transform it into a valid updatable view:</p>
			<pre class="source-code">ctx.createView("sales_1504_1370_u")</pre>
			<pre class="source-code">   .as(select().from(SALE)</pre>
			<pre class="source-code">   .where(SALE.EMPLOYEE_NUMBER.in(1504L, 1370L)))</pre>
			<pre class="source-code">   .execute();  </pre>
			<p>Some views are "partially" updatable. For instance, views <a id="_idIndexMarker1534"/>that contain <strong class="source-inline">JOIN</strong> statements <a id="_idIndexMarker1535"/>like this one:</p>
			<pre class="source-code">ctx.createView("employees_and_sales", "first_name", </pre>
			<pre class="source-code">      "last_name", "sale_id", "sale")</pre>
			<pre class="source-code">   .as(select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME, </pre>
			<pre class="source-code">              SALE.SALE_ID, SALE.SALE_)</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .join(SALE)</pre>
			<pre class="source-code">   .on(EMPLOYEE.EMPLOYEE_NUMBER.eq(SALE.EMPLOYEE_NUMBER)))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>While in PostgreSQL this view is not updatable at all, in MySQL, SQL Server, and Oracle, this view is "partially" updatable. In other words, as long as the modifications affect only one of the two involved base tables, the view is updatable, otherwise, it is not. If more base tables are involved in the update, then an error occurs. For instance, in SQL Server, we get an error of <em class="italic">View or function 'employees_and_sales' is not updatable because the modification affects multiple base tables</em>, while in Oracle, we get <em class="italic">ORA-01776</em>.</p>
			<p>You can check out these examples in <em class="italic">DbViews</em>.</p>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor297"/>Types of views (unofficial categorization)</h2>
			<p>In this section, let's<a id="_idIndexMarker1536"/> define several common types of views depending on their usage, and let's start with views of the type single-table projection and restriction.</p>
			<h3>Single-table projection and restriction</h3>
			<p>Sometimes, for security <a id="_idIndexMarker1537"/>reasons, we rely on projections/restrictions of a single base table to remove certain rows and/or columns that should not be seen by a particular group of users. For instance, the following view represents a projection of the <strong class="source-inline">BANK_TRANSACTION</strong> base table to restrict/hide the details about the involved banks:</p>
			<pre class="source-code">ctx.createView("transactions", </pre>
			<pre class="source-code">               "customer_number", "check_number",</pre>
			<pre class="source-code">               "caching_date", "transfer_amount", "status")</pre>
			<pre class="source-code">   .as(select(BANK_TRANSACTION.CUSTOMER_NUMBER, </pre>
			<pre class="source-code">              BANK_TRANSACTION.CHECK_NUMBER,</pre>
			<pre class="source-code">              BANK_TRANSACTION.CACHING_DATE, </pre>
			<pre class="source-code">              BANK_TRANSACTION.TRANSFER_AMOUNT,</pre>
			<pre class="source-code">              BANK_TRANSACTION.STATUS)</pre>
			<pre class="source-code">   .from(BANK_TRANSACTION))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Another type of view tackles computed columns.</p>
			<h3>Calculated columns</h3>
			<p>Providing summary data is <a id="_idIndexMarker1538"/>another use case of views. For instance, we prefer to <a id="_idIndexMarker1539"/>compute the columns in as meaningful a way as possible and expose them to the clients as views. Here is an example of computing the payroll of each employee as salary plus commission:</p>
			<pre class="source-code">ctx.createView("payroll", "employee_number", "paycheck_amt")</pre>
			<pre class="source-code">   .as(select(EMPLOYEE.EMPLOYEE_NUMBER, EMPLOYEE.SALARY</pre>
			<pre class="source-code">     .plus(coalesce(EMPLOYEE.COMMISSION, 0.00)))</pre>
			<pre class="source-code">   .from(EMPLOYEE))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Another type of <a id="_idIndexMarker1540"/>view tackles <a id="_idIndexMarker1541"/>translated columns.</p>
			<h3>Translated columns</h3>
			<p>Views are also useful for<a id="_idIndexMarker1542"/> translating codes into texts to increase the readability of the <a id="_idIndexMarker1543"/>fetched result set. A common case is a suite of <strong class="source-inline">JOIN</strong> statements between several tables via one or more foreign keys. For instance, in the following view, we have a detailed report of customers, orders, and products by translating the <strong class="source-inline">CUSTOMER_NUMBER</strong>, <strong class="source-inline">ORDER_ID</strong>, and <strong class="source-inline">PRODUCT_ID</strong> codes (foreign keys):</p>
			<pre class="source-code">ctx.createView("customer_orders")</pre>
			<pre class="source-code">   .as(select(CUSTOMER.CUSTOMER_NAME, </pre>
			<pre class="source-code">      CUSTOMER.CONTACT_FIRST_NAME, CUSTOMER.CONTACT_LAST_NAME,</pre>
			<pre class="source-code">      ORDER.SHIPPED_DATE, ORDERDETAIL.QUANTITY_ORDERED, </pre>
			<pre class="source-code">      ORDERDETAIL.PRICE_EACH, PRODUCT.PRODUCT_NAME, </pre>
			<pre class="source-code">      PRODUCT.PRODUCT_LINE)</pre>
			<pre class="source-code">   .from(CUSTOMER)</pre>
			<pre class="source-code">   .innerJoin(ORDER)</pre>
			<pre class="source-code">   .on(CUSTOMER.CUSTOMER_NUMBER.eq(ORDER.CUSTOMER_NUMBER))</pre>
			<pre class="source-code">   .innerJoin(ORDERDETAIL)</pre>
			<pre class="source-code">   .on(ORDER.ORDER_ID.eq(ORDERDETAIL.ORDER_ID))</pre>
			<pre class="source-code">   .innerJoin(PRODUCT)</pre>
			<pre class="source-code">   .on(ORDERDETAIL.PRODUCT_ID.eq(PRODUCT.PRODUCT_ID)))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Next, let's tackle grouped views.</p>
			<h3>Grouped views</h3>
			<p>A <a id="_idIndexMarker1544"/>grouped view relies on a query containing a <strong class="source-inline">GROUP BY</strong> clause. Commonly, such read-only<a id="_idIndexMarker1545"/> views contain one or more aggregate functions and they are useful for creating different kinds of reports. Here is an example of creating a grouped view that fetches big sales per employee:</p>
			<pre class="source-code">ctx.createView("big_sales", "employee_number", "big_sale")</pre>
			<pre class="source-code">   .as(select(SALE.EMPLOYEE_NUMBER, max(SALE.SALE_))</pre>
			<pre class="source-code">   .from(SALE)                        </pre>
			<pre class="source-code">   .groupBy(SALE.EMPLOYEE_NUMBER))                </pre>
			<pre class="source-code">   .execute();</pre>
			<p>Here is another example that relies on a grouped view to "flatten out" a one-to-many relationship:</p>
			<pre class="source-code">ctx.createView("employee_sales", </pre>
			<pre class="source-code">               "employee_number", "sales_count")</pre>
			<pre class="source-code">   .as(select(SALE.EMPLOYEE_NUMBER, count())</pre>
			<pre class="source-code">   .from(SALE)</pre>
			<pre class="source-code">   .groupBy(SALE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">   .execute();</pre>
			<pre class="source-code">var result = ctx.select(</pre>
			<pre class="source-code">        EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME,</pre>
			<pre class="source-code">        coalesce(field(name("sales_count")), 0) </pre>
			<pre class="source-code">         .as("sales_count"))</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .leftOuterJoin(table(name("employee_sales")))</pre>
			<pre class="source-code">   .on(EMPLOYEE.EMPLOYEE_NUMBER</pre>
			<pre class="source-code">    .eq(field(name("employee_sales", "employee_number"),   </pre>
			<pre class="source-code">        Long.class))).fetch();</pre>
			<p>Next, let's tackle <strong class="source-inline">UNION</strong>-ed views.</p>
			<h3>UNION-ed views</h3>
			<p>Using <strong class="source-inline">UNION</strong>/<strong class="source-inline">UNION ALL</strong> in views is <a id="_idIndexMarker1546"/>also a common usage case <a id="_idIndexMarker1547"/>of views. Here is the previous query of flattening one-to-many relationships rewritten via <strong class="source-inline">UNION</strong>:</p>
			<pre class="source-code">ctx.createView("employee_sales_u", </pre>
			<pre class="source-code">      "employee_number", "sales_count")</pre>
			<pre class="source-code">   .as(select(SALE.EMPLOYEE_NUMBER, count())</pre>
			<pre class="source-code">   .from(SALE)</pre>
			<pre class="source-code">   .groupBy(SALE.EMPLOYEE_NUMBER)</pre>
			<pre class="source-code">   .union(select(EMPLOYEE.EMPLOYEE_NUMBER, inline(0))</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .whereNotExists(select().from(SALE)</pre>
			<pre class="source-code">   .where(SALE.EMPLOYEE_NUMBER</pre>
			<pre class="source-code">     .eq(EMPLOYEE.EMPLOYEE_NUMBER))))).execute();</pre>
			<pre class="source-code">var result = ctx.select(EMPLOYEE.FIRST_NAME,  </pre>
			<pre class="source-code">            EMPLOYEE.LAST_NAME, field(name("sales_count")))</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .innerJoin(table(name("employee_sales_u")))</pre>
			<pre class="source-code">   .on(EMPLOYEE.EMPLOYEE_NUMBER</pre>
			<pre class="source-code">    .eq(field(name("employee_sales_u", "employee_number"), </pre>
			<pre class="source-code">        Long.class)))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Finally, let's see an example of nested views.</p>
			<h3>Nested views</h3>
			<p>A view can be built on <a id="_idIndexMarker1548"/>another view. Pay attention to avoid circular references in the query<a id="_idIndexMarker1549"/> expressions of the views and don't forget that a view must be ultimately built on base tables. Moreover, pay attention if you have different updatable views that reference the same base table at the same time. Using such views in other views may cause ambiguity issues since it is hard to infer what will happen if the highest-level view is modified.</p>
			<p>Here is an example of using nested views:</p>
			<pre class="source-code">ctx.createView("customer_orders_1", </pre>
			<pre class="source-code">               "customer_number", "orders_count")</pre>
			<pre class="source-code">   .as(select(ORDER.CUSTOMER_NUMBER, count())</pre>
			<pre class="source-code">   .from(ORDER)</pre>
			<pre class="source-code">   .groupBy(ORDER.CUSTOMER_NUMBER)).execute();</pre>
			<pre class="source-code">ctx.createView("customer_orders_2", "first_name", </pre>
			<pre class="source-code">               "last_name", "orders_count")  </pre>
			<pre class="source-code">   .as(select(CUSTOMER.CONTACT_FIRST_NAME, </pre>
			<pre class="source-code">              CUSTOMER.CONTACT_LAST_NAME,</pre>
			<pre class="source-code">              coalesce(field(name("orders_count")), 0))</pre>
			<pre class="source-code">   .from(CUSTOMER)</pre>
			<pre class="source-code">   .leftOuterJoin(table(name("customer_orders_1")))</pre>
			<pre class="source-code">   .on(CUSTOMER.CUSTOMER_NUMBER</pre>
			<pre class="source-code">     .eq(field(name("customer_orders_1", </pre>
			<pre class="source-code">         "customer_number"), Long.class)))).execute();</pre>
			<p>The first <a id="_idIndexMarker1550"/>view, <strong class="source-inline">customer_orders_1</strong>, counts the total orders per customer, and the second <a id="_idIndexMarker1551"/>view, <strong class="source-inline">customer_orders_2</strong>, fetches the name of those customers.</p>
			<p>You can see these examples in <em class="italic">DbTypesOfViews</em>.</p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor298"/>Some examples of views</h2>
			<p>In this <a id="_idIndexMarker1552"/>section, we rely on views to solve several problems. For instance, the following view is used to compute the cumulative distribution values by the headcount of each office:</p>
			<pre class="source-code">ctx.createView("office_headcounts", </pre>
			<pre class="source-code">               "office_code", "headcount")</pre>
			<pre class="source-code">   .as(select(OFFICE.OFFICE_CODE, </pre>
			<pre class="source-code">              count(EMPLOYEE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">   .from(OFFICE)</pre>
			<pre class="source-code">   .innerJoin(EMPLOYEE)</pre>
			<pre class="source-code">   .on(OFFICE.OFFICE_CODE.eq(EMPLOYEE.OFFICE_CODE))</pre>
			<pre class="source-code">   .groupBy(OFFICE.OFFICE_CODE))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Next, the query that uses this view for computing the cumulative distribution is as follows:</p>
			<pre class="source-code">ctx.select(field(name("office_code")),  </pre>
			<pre class="source-code">           field(name("headcount")),</pre>
			<pre class="source-code">           round(cumeDist().over().orderBy(</pre>
			<pre class="source-code">              field(name("headcount"))).mul(100), 2)</pre>
			<pre class="source-code">                 .concat("%").as("cume_dist_val"))</pre>
			<pre class="source-code">   .from(name("office_headcounts"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Views can be<a id="_idIndexMarker1553"/> combined with CTE. Here is an example that creates a view on top of the CTE for detecting gaps in IDs – a problem tackled earlier, in the <em class="italic">CTE and window functions</em> section:</p>
			<pre class="source-code">ctx.createView("absent_values",</pre>
			<pre class="source-code">          "data_val", "data_seq", "absent_data_grp")</pre>
			<pre class="source-code">   .as(with("t", "data_val", "data_seq", "absent_data_grp")</pre>
			<pre class="source-code">     .as(select(EMPLOYEE.EMPLOYEE_NUMBER,</pre>
			<pre class="source-code">      rowNumber().over().orderBy(EMPLOYEE.EMPLOYEE_NUMBER),</pre>
			<pre class="source-code">      EMPLOYEE.EMPLOYEE_NUMBER.minus(rowNumber().over()</pre>
			<pre class="source-code">           .orderBy(EMPLOYEE.EMPLOYEE_NUMBER)))</pre>
			<pre class="source-code">           .from(EMPLOYEE))</pre>
			<pre class="source-code">     .select(field(name("absent_data_grp")), count(),</pre>
			<pre class="source-code">        min(field(name("data_val"))).as("start_data_val"))</pre>
			<pre class="source-code">        .from(name("t"))</pre>
			<pre class="source-code">        .groupBy(field(name("absent_data_grp"))))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>The query is straightforward:</p>
			<pre class="source-code">ctx.select().from(name("absent_values")).fetch();</pre>
			<pre class="source-code">ctx.selectFrom(name("absent_values")).fetch();</pre>
			<p>Finally, let's see an example that attempts to optimize shipping costs in the future based on historical data from <em class="italic">2003</em>. Let's assume that we are shipping orders with a specialized company that can provide us, on demand, the list of trucks with their available periods per year as follows:</p>
			<pre class="source-code">Table truck = select().from(values(</pre>
			<pre class="source-code"> row("Truck1",LocalDate.of(2003,1,1),LocalDate.of(2003,1,12)),</pre>
			<pre class="source-code"> row("Truck2",LocalDate.of(2003,1,8),LocalDate.of(2003,1,27)),</pre>
			<pre class="source-code"> ...</pre>
			<pre class="source-code">)).asTable("truck", "truck_id", "free_from", "free_to");</pre>
			<p>Booking trucks<a id="_idIndexMarker1554"/> in advance for certain periods takes advantage of certain discounts, therefore, based on the orders from 2003, we can analyze some queries that can tell us whether this action can optimize shipping costs.</p>
			<p>We start with a view named <strong class="source-inline">order_truck</strong>, which tells us which trucks are available for each order:</p>
			<pre class="source-code">ctx.createView("order_truck", "truck_id", "order_id")</pre>
			<pre class="source-code">   .as(select(field(name("truck_id")), ORDER.ORDER_ID)</pre>
			<pre class="source-code">   .from(truck, ORDER)</pre>
			<pre class="source-code">   .where(not(field(name("free_to")).lt(ORDER.ORDER_DATE)</pre>
			<pre class="source-code">   .or(field(name("free_from")).gt(ORDER.REQUIRED_DATE)))))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Based on this view, we can run several queries that provide important information. For instance, how many orders can be shipped by each truck?</p>
			<pre class="source-code">ctx.select(field(name("truck_id")), count().as("order_count"))</pre>
			<pre class="source-code">   .from(name("order_truck"))</pre>
			<pre class="source-code">   .groupBy(field(name("truck_id")))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Or, how many trucks can ship the same order?</p>
			<pre class="source-code">ctx.select(field(name("order_id")), count()</pre>
			<pre class="source-code">   .as("truck_count"))</pre>
			<pre class="source-code">   .from(name("order_truck"))</pre>
			<pre class="source-code">   .groupBy(field(name("order_id")))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Moreover, based<a id="_idIndexMarker1555"/> on this view, we can create another view named <strong class="source-inline">order_truck_all</strong> that can tell us the earliest and latest points in both intervals:</p>
			<pre class="source-code">ctx.createView("order_truck_all", "truck_id", </pre>
			<pre class="source-code">               "order_id", "entry_date", "exit_date")</pre>
			<pre class="source-code">   .as(select(field(name("t", "truck_id")), </pre>
			<pre class="source-code">              field(name("t", "order_id")),</pre>
			<pre class="source-code">              ORDER.ORDER_DATE, ORDER.REQUIRED_DATE)</pre>
			<pre class="source-code">   .from(table(name("order_truck")).as("t"), ORDER)</pre>
			<pre class="source-code">   .where(ORDER.ORDER_ID.eq(field(name("t", "order_id"), </pre>
			<pre class="source-code">     Long.class)))</pre>
			<pre class="source-code">   .union(select(field(name("t", "truck_id")), </pre>
			<pre class="source-code">                 field(name("t", "order_id")),</pre>
			<pre class="source-code">                 truck.field(name("free_from")),  </pre>
			<pre class="source-code">                 truck.field(name("free_to")))</pre>
			<pre class="source-code">           .from(table(name("order_truck")).as("t"), truck)</pre>
			<pre class="source-code">           .where(truck.field(name("truck_id"))</pre>
			<pre class="source-code">             .eq(field(name("t", "truck_id"))))))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Getting the exact <a id="_idIndexMarker1556"/>points in both intervals can be determined based on the previous view as follows:</p>
			<pre class="source-code">ctx.createView("order_truck_exact", "truck_id", </pre>
			<pre class="source-code">               "order_id", "entry_date", "exit_date")</pre>
			<pre class="source-code">   .as(select(field(name("truck_id")), </pre>
			<pre class="source-code">              field(name("order_id")),</pre>
			<pre class="source-code">              max(field(name("entry_date"))), </pre>
			<pre class="source-code">              min(field(name("exit_date"))))</pre>
			<pre class="source-code">         .from(name("order_truck_all"))</pre>
			<pre class="source-code">         .groupBy(field(name("truck_id")), </pre>
			<pre class="source-code">                  field(name("order_id"))))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Depending on how deeply we want to analyze the data, we can continue adding more queries and views, but I think you've got the idea. You can check out these examples in the bundled code, named <em class="italic">DbViewsEx</em>.</p>
			<p>For those that expected to cover table-valued functions here (also called "parameterized views") as well, please consider the next chapter. </p>
			<p>On the other <a id="_idIndexMarker1557"/>hand, in this chapter, you saw at work several jOOQ methods useful to trigger DDL statements, such as <strong class="source-inline">createView()</strong>, <strong class="source-inline">createTemporaryTable()</strong>, and so on. Actually, jOOQ provides a comprehensive API for programmatically generating DDL that is covered by examples in the bundled code named <em class="italic">DynamicSchema</em>. Take your time to practice those examples and get familiar with them.</p>
			<h1 id="_idParaDest-300"><a id="_idTextAnchor299"/>Summary</h1>
			<p>In this chapter, you've learned how to express derived tables, CTEs, and views in jOOQ. Since these are powerful SQL tools, it is very important to be familiar with them, therefore, besides the examples from this chapter, it is advisable to challenge yourself and try to solve more problems via jOOQ's DSL. </p>
			<p>In the next chapter, we will tackle stored functions/procedures.</p>
		</div>
	</body></html>