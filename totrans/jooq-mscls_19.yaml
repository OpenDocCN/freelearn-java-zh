- en: '*Chapter 15*: Calling and Creating Stored Functions and Procedures'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL is a declarative language, but it also has procedural features such as stored
    functions/procedures, triggers, and cursors, which means SQL is considered to
    be a **Fourth-Generation Programming Language** (**4GL**). In this chapter, we
    will see how to call and create stored functions/procedures, or in other words,
    how to call and create Persistent Stored Modules (SQL/PSM) for MySQL, PostgreSQL,
    SQL Server, and Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just in case you need a quick reminder about the key differences between the
    stored procedures and functions, check out the following head-to-head table (some
    of these differences are entirely or partially true depending on the database):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1 – Key differences between procedures and functions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.1 – Key differences between procedures and functions
  prefs: []
  type: TYPE_NORMAL
- en: As you can infer from the previous comparison, the main difference is that procedures
    (may) produce a side effect, whereas functions are (generally) expected not to.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our agenda includes the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling stored functions/procedures from jOOQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stored procedures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating stored functions/procedures via jOOQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Right before getting started, let''s have some insight from Lukas Eder who
    shared that: "*This may come up later, but it might be worth mentioning early:
    there are some users who use jOOQ *only* for its stored procedure code generation
    capabilities. When you have a lot of stored procedures, it''s almost impossible
    to bind to them without code generation, and jOOQ works very well out of the box,
    kind of like when you have a WSDL file (or something comparable), and you generate
    all the stubs with Axis or Metro, and so on."*'
  prefs: []
  type: TYPE_NORMAL
- en: OK, now let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter15](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter15).
  prefs: []
  type: TYPE_NORMAL
- en: Calling stored functions/procedures from jOOQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you start dealing with stored functions/procedures across different database
    vendors, you'll be hit by the lack of standardization. For instance, the vendor-specific
    syntax for expressing functions/procedures, the wide variety of vendor-specific
    functions/procedure types, and different ways of supporting and treating the output
    parameters are just a few non-standard aspects of stored functions/procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Calling stored functions/procedures via plain JDBC code is not easy either,
    especially if advanced data types are involved (for instance, arrays or UDTs).
    But, as you already know, using the jOOQ DSL saves us from interacting directly
    with the JDBC API, so it saves us from making cutting-edge decisions regarding
    JDBC workarounds.
  prefs: []
  type: TYPE_NORMAL
- en: The jOOQ DSL represents stored functions/procedures via the `org.jooq.Routine`
    API, so there is a common API for both. Whenever the jOOQ generator detects a
    stored function/procedure it generates (among other things) a dedicated class
    in the proper package (in our case, `jooq.generated.routines`) that reflects its
    name (for instance, by default, a stored function named `get_emps_in_office()`
    results in a class named `GetEmpsInOffice`) and extends the jOOQ `AbstractRoutine`
    class. The generated class exposes the API needed to call this stored function/procedure
    via jOOQ DSL. Moreover, as you'll see soon, calling a stored function/procedure
    can also be done in an anonymous procedural block via `DSLContext.begin()` and
    directly via `DSLContext.call()`. But, enough theory, next let's tackle some different
    kinds of stored functions/procedures from the jOOQ perspective, and let's start
    with stored functions.
  prefs: []
  type: TYPE_NORMAL
- en: Stored functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stored functions return a result (for instance, the result of a computation).
    They can be called in SQL statements and, usually, they don't support output (`OUT`)
    parameters. However, in Oracle and PostgreSQL, stored functions may have output
    parameters that can be interpreted as returned results. Moreover, until version
    11, PostgreSQL supports only stored functions that combine the features of stored
    functions and procedures. On the other hand, PostgreSQL 11 and beyond, Oracle,
    MySQL, and SQL Server distinguish between stored functions and procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's see how we can call from jOOQ different kinds of stored functions
    expressed in one of these four dialects, and let's start by calling some scalar
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Scalar functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A stored function that takes none, one, or more parameters, and returns a single
    value is commonly referred to as a scalar function. As a common practice, scalar
    functions encapsulate complex calculations that appear in many queries. Instead
    of expressing the calculation in every query, you can write a scalar function
    that encapsulates this calculation and uses it in each query. Roughly, the syntax
    of a scalar function is a variation of this skeleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, a simple scalar function expressed in MySQL may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For this scalar function, the jOOQ Code Generator produces a dedicated class
    named `jooq.generated.routines.SalePrice`. Among its methods, this class exposes
    setters that allow us to provide the input parameters of the function. In our
    example, we will have `setQuantity(Integer value)`, `setQuantity(Field<Integer>
    field)`, `setListPrice(Double value)`, `setListPrice(Field<Double> field)`, `setFractionOfPrice(Double
    value)`, and `setFractionOfPrice(Field<Double> field)`. The function can be executed
    via jOOQ''s well-known `execute()` methods. If the function already has a `Configuration`
    attached, then you can rely on `execute()` without parameters, otherwise use the
    `execute(Configuration c)` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting the returned scalar result can be done via the `getReturnValue()` method.
    In this case, you can use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you just saw, each setter has a flavor that gets a `Field` as an argument.
    This means that we can write something like this (check the first two setters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The previous examples are useful if the routine has more than 254 parameters
    (which isn't allowed in Java), if there are default parameters, which users don't
    want to set, or if the parameters need to be set dynamically. Otherwise, most
    probably, you'll prefer to use the static convenience API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing these two examples in a more convenient/compact way can be done via
    the `Routines.salePrice()` static method. The `jooq.generated.Routines` class
    provides convenient static methods for accessing all stored functions/procedures
    that jOOQ has found in your database. In this case, the following two examples
    compact the previous examples (of course, you can shorten this example further
    by importing the `jooq.generated.Routines.salePrice` static):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Scalar functions can be used in queries as well. Here is an example via another
    flavor of `Routines.salePrice()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'For MySQL, jOOQ renders the following plain SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: You can practice this example in *ScalarFunction*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this context, here is another function that was written for PostgreSQL that
    updates a `PRODUCT.MSRP` and returns it via `UPDATE … RETURNING` (do not confuse
    it with the function `RETURN` statement!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'jOOQ can call such a function as you saw in the previous example. For instance,
    here it is called in a `SELECT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'And the rendered SQL is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: You can practice this example in *UpdateFunction* for PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: If your scalar functions are under Oracle, then you can take advantage of a
    nice Oracle feature known as *scalar subquery caching*. Basically, this feature
    renders the calls of stored functions wrapped in SQL statements as a scalar subquery.
    This feature avoids switching between PL/SQL and SQL contexts and this may result
    in better performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following scalar function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling this scalar function in a query can be done here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'But keep in mind Lukas Eder''s note: *"Just in case, scalar subquery caching
    isn''t documented in Oracle, as far as I know. The context switch isn''t avoided
    entirely, but it happens only once per scalar subquery input value, and thus per
    function argument value, and per query. So, instead of having 1 switch per row,
    we now have 1 switch per function input value."*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time we execute this code, jOOQ renders a query that requires switching
    between PL/SQL and SQL contexts in order to execute the scalar function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'But jOOQ has the `withRenderScalarSubqueriesForStoredFunctions()` flag-setting
    that is by default set to `false`. Once we set it to `true`, jOOQ turns on Oracle''s
    *scalar subquery caching* feature. In the following example, we turn this feature
    on only for the current SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the call of the `cardCommission()` stored function is rendered as
    a scalar subquery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: You can practice this example in *ScalarSubqueryCaching* for Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: Functions returning arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PostgreSQL is a convenient way to write a function that returns an array. For
    instance, here is a function returning `DEPARTMENT.TOPIC`, which is declared in
    our schema as an array of type `TEXT[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling this function in `SELECT` via the dedicated method, `departmentTopicArr()`,
    generated by jOOQ in `Routines` can be done by unnesting the returned array as
    in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s take a function having an anonymous parameter (no explicit name)
    that builds and returns an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, let''s instantiate `EmployeeOfficeArr`, and let''s pass the required
    parameter via a setter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Since the function's parameter doesn't have a name, jOOQ has used its default
    implementation and generated a `set__1()` setter. If you had two no-name parameters,
    then jOOQ would generate `set__1()` and `set__2()`, and so on. In other words,
    jOOQ generates setters based on parameter positions starting from 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, using the generated `Routines.employeeOfficeArr()` in a
    `SELECT` query can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'For PostgreSQL, jOOQ renders this SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples in *ArrayFunction* for PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Functions with output parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we said earlier, PostgreSQL and Oracle allow output parameters in functions.
    Here is an example in PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'This function doesn''t have a `RETURN`, but it has three `OUT` parameters that
    help us to obtain the results of execution. For each such parameter, jOOQ generates
    a getter, so we can call it via the generated `jooq.generated.routines.GetSalaryStat`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'This code (more precisely the `execute()` call) leads to the following `SELECT`
    (or `CALL`, in Oracle):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the same result via `Routines.getSalaryStat(Configuration c)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are two more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'But pay attention that both of these examples lead to two `SELECT` statements
    (or, a `CALL` and a `SELECT` statement in Oracle) since functions with output
    parameters cannot be called from plain SQL. In other words, jOOQ calls the routine
    and fetches the `OUT` parameters as you can see next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'And, afterward, it executes the `SELECT` that uses the results extracted from
    the output parameters. The following `SELECT` fits our second example (65652.17
    is the average salary computed via `getSalaryStat(Configuration c)`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'Lukas Eder shared: *"In Oracle, functions with OUT parameters aren''t "SQL
    callable," though... In PostgreSQL, they''re just "syntax sugar" (or un-sugar,
    depending on taste) for a function returning a record."*'
  prefs: []
  type: TYPE_NORMAL
- en: You can practice these examples in *InOutFunction* for PostgreSQL (here, you
    can find an `IN OUT` example as well).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, using `OUT` (or `IN OUT`) parameters in functions is not such a great idea
    and must be avoided. As Oracle mentioned, besides preventing a function from being
    used in SQL queries (more details here: [https://oracle-base.com/articles/12c/with-clause-enhancements-12cr1](https://oracle-base.com/articles/12c/with-clause-enhancements-12cr1)),
    the presence of output parameters in a function prevents a function from being
    marked as a `DETERMINISTIC` function or used as a result-cached function. Unlike
    PostgreSQL, Oracle functions having output parameters must have an explicit `RETURN`.
    Next to the jOOQ getters dedicated to output parameters, you can call `getReturnValue()`
    to obtain the result returned explicitly via the `RETURN` statement. When this
    book was written, functions with `OUT` parameters couldn''t be called in jOOQ
    from plain SQL. Follow this feature request here: [https://github.com/jOOQ/jOOQ/issues/3426](https://github.com/jOOQ/jOOQ/issues/3426).'
  prefs: []
  type: TYPE_NORMAL
- en: You can practice an example in *InOutFunction* for Oracle (here, you can find
    an `IN OUT` example too).
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphic functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some databases support the so-called polymorphic functions that accept and
    return polymorphic types. For instance, PostgreSQL supports the following polymorphic
    types: `anyelement`, `anyarray`, `anynonarray`, `anyenum`, and `anyrange`. Here
    is an example that builds an array from two passed arbitrary data type elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling this function from jOOQ can be done as follows (notice the positional
    setters at work again):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned result is `org.postgresql.jdbc.PgArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'In the bundled code you can see further processing of this array. For now,
    let''s call `make_array()` from `SELECT` to build an array of integers and an
    array of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'How about a function that combines polymorphic types and output parameters?
    Here is one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'Call it via jOOQ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'Or use it in a `SELECT` (remember from the previous section that this leads
    to two statements against the database):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples in *PolymorphicFunction* for PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Functions returning explicit cursors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A function can return an explicit cursor (an explicit pointer that points to
    a result of a query) as well. Most probably, you''re familiar with PostgreSQL
    `REFCURSOR` and Oracle `SYS_REFCURSOR`. Here is an example for Oracle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling this function via the generated `jooq.generated.routines.GetCustomer`
    can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is mapped by jOOQ to `Result<Record>`, so a list of records is fitted
    entirely into memory. For better accommodation of large datasets, jOOQ has some
    pending feature requests to stream the cursors, so you can check the progress
    of issues #4503 and #4472 on the jOOQ repository. Alternatively, you can wrap
    the returned cursor in a table-valued function and fetch the results via a `SELECT`
    statement using jOOQ''s `ResultQuery.fetchLazy()` method, as you saw in [*Chapter
    8*](B16833_08.xhtml#_idTextAnchor128), *Fetching and Mapping*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, going further, you can loop the `Result<Record>` and process each record,
    but to access a certain column (for instance, the customer name) of a certain
    row (for instance, the first row), then you can use `getValue()` or `get()` as
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: To get multiple names (or other columns) rely on `getValues()`, which comes
    in many flavors that you can find in the official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obtaining the same `Result<Record>` can be done more compactly via the generated
    static `Routines.getCustomer()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need a `Table` instead of this `Result<Record>`, then simply rely on
    `org.jooq.impl.DSL.table` as in the following two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you can use `t` in queries like any regular `Table`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, another flavor of `Routines.getCustomer()` returns the result
    wrapped in a `Field` as `Field<Result<Record>>`. This allows us to use this result
    as a `Field`. For instance, here is a `SELECT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples in *CursorFunction* for Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about a function that returns multiple cursors? Here is a sample that was
    written for PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, each cursor produces a `Result<Record>` wrapped in a generated
    `Record` class. Here, we have two cursors, therefore two `Result<Record>` wrapped
    in two instances of the generated `GetOfficesMultipleRecord`. When we call `Routines.getOfficesMultiple(Configuration
    c)` we get a `Result<GetOfficesMultipleRecord>` that can be expanded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples in *CursorFunction* for PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Table-valued functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apart from database views, one of the underrated features of SQL is table-valued
    functions. This is not the first time in this book that we've discussed this feature,
    but this time, let's add a few more details. So, a table-valued function is a
    function that returns a set of data as a table data type. The returned table can
    be used just like a regular table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table-valued functions are not supported in MySQL, but they are supported in
    PostgreSQL, Oracle, and SQL Server. Next is a snippet of code from a PostgreSQL
    table-valued function (notice the `RETURNS TABLE` syntax, which indicates that
    the `SELECT` query from the function returns the data as a table to whatever calls
    the function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: By default, the jOOQ Code Generator will generate for this function a class
    named `ProductOfProductLine` in the `jooq.generated.tables` package, not in the
    `jooq.generated.routines` package. The explanation is simple; jOOQ (like most
    databases) treats table-valued functions as ordinary tables that can be used in
    the `FROM` clause of `SELECT` like any other table. An exception from this practice
    is Oracle, where it is quite common to treat them as standalone routines – in
    this context, jOOQ has a flag setting that allows us to indicate whether table-valued
    functions should be treated as ordinary tables (generated in `jooq.generated.tables`)
    or as plain routines (generated in `jooq.generated.routines`). This is detailed
    in [*Chapter 6*](B16833_06.xhtml#_idTextAnchor093), *Tackling Different Kinds
    of JOIN Statements*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling a table-valued function (with arguments) can be done via the `call()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: 'In queries, we may prefer to use the `PRODUCT_OF_PRODUCT_LINE` static field
    that was generated by the jOOQ generator in `ProductOfProductLine`. Both of the
    following examples produce the same SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are two more examples of calling this table-valued function in the `FROM`
    clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: Since a table-valued function returns a table, we should be able to use them
    in joins. But the regular `JOIN` feature doesn't allow us to join a table-valued
    function, so we need another approach. Here is where `CROSS APPLY` and `OUTER
    APPLY` (or `LATERAL`) enter into the scene. In [*Chapter 6*](B16833_06.xhtml#_idTextAnchor093),
    *Tackling Different Kinds of JOIN Statements*, you saw an example of using `CROSS`/`OUTER
    APPLY` to solve the popular task of joining two tables based on the results of
    a TOP-N query. So, `CROSS`/`OUTER APPLY` allows us to combine in a query the results
    returned by a table-valued function with the results of other tables or, in short,
    to join table-valued functions to other tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s use `CROSS`/`OUTER APPLY` (you can think of it as a `Stream.flatMap()`
    in Java) to join the `PRODUCTLINE` table to our table-valued function. Let''s
    say that we have added a new `PRODUCTLINE` without products named *Helicopters*
    and let''s see how `CROSS APPLY` works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: Since the *Helicopters* product line has no products, `CROSS APPLY` will not
    fetch it because `CROSS APPLY` acts as `CROSS JOIN LATERAL`. How about `OUTER
    APPLY`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, `OUTER APPLY` acts as `LEFT OUTER JOIN LATERAL`, so the *Helicopters*
    product line is returned as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lukas Eder shared an opinion here: *"In fact, for historic reasons, APPLY or
    LATERAL is optional in at least Db2, Oracle, and PostgreSQL, under some conditions.
    SQL Server had APPLY for a long time, but the others introduced LATERAL only relatively
    recently. I personally don''t understand the value of making LATERAL explicit.
    It''s always clear what an implicit LATERAL means..."*'
  prefs: []
  type: TYPE_NORMAL
- en: You can check out these examples in the bundled code, *TableValuedFunction*
    for PostgreSQL, Oracle, and SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: Oracle's package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Oracle allows us to group the functions/procedures that are commonly logically
    related into a package. A package has two parts: the first part contains the public
    items and is known as the *package specification*, while the second part, known
    as the *package body*, provides the code of the cursors or subprograms declared
    in the package specification. If no cursors/subprograms were declared in the package
    specification, then the package body can be skipped. If you are not an Oracle
    fan, then the following syntax should help you to digest this topic a little bit
    easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2 – Syntax of Oracle package'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.2 – Syntax of Oracle package
  prefs: []
  type: TYPE_NORMAL
- en: 'Lukas Eder shared an analogy that''s useful to better understand this topic:
    *"If it helps, package specifications are like interfaces, and bodies are like
    singleton instances, kind of. In a way, like this*: [https://twitter.com/lukaseder/status/1443855980693962755](https://twitter.com/lukaseder/status/1443855980693962755)."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Packages sustain modularity, facilitate clear design, and increase code maintainability
    by hiding the implementation details in the package body. Moreover, packages are
    loaded into memory as a whole at the first invocation of a function/procedure
    so any subsequent invocations of functions/procedures from this package require
    no disk I/O. While more information on using Oracle packages is available in the
    official documentation, let''s have an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: 'A spicy tip from Lukas Eder: *"The ''*`/`*'' is a SQL*Plus ''spool'' token
    (also supported by SQL Developer), and not an actual PL/SQL syntax element. For
    example, it doesn''t work in DBeaver.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'And, another tip regarding quoted identifiers: *Might be a good reminder that,
    to be better interoperable with non-jOOQ code, perhaps not using quoted identifiers
    is better. It will be a PITA if all callers will have to always quote that identifier
    if they''re not using jOOQ :)"*'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here we have a package named `DEPARTMENT_PKG` containing a user-defined
    type named `BGT` and two functions, `GET_BGT()` and `GET_MAX_CASH()`. At the source
    code generation stage, jOOQ will reflect this package and its content via Java
    sub-packages as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jooq.generated.packages` – Contains the `DepartmentPkg` class representing
    the package and exposing the `DEPARTMENT_PKG` static that can be used to call
    the functions as `DEPARTMENT_PKG.getMaxCash()` and `DEPARTMENT_PKG.getBgt()` and
    get the result as a `Field`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jooq.generated.packages.department_pkg` – Contains the `GetBgt` and `GetMaxCash`
    classes representing the two functions from the package. Moreover, it contains
    the `UDTs` class containing the static `BGT` for `CLASSICMODELS.DEPARTMENT_PKG.BGT`
    (`jooq.generated.packages.department_pkg.udt.Bgt.BGT`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jooq.generated.packages.department_pkg.udt` – Contains the class `Bgt` mapping
    the `BGT` UDT type as an extension of `UDTImpl`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jooq.generated.packages.department_pkg.udt.records` – Contains the `BgtRecord`
    class representing the `BGT` UDT type as an extension of `UDTRecordImpl`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Calling these two functions (`GET_BGT()` and `GET_MAX_CASH()`) can be done
    by instantiating the `GetMaxCash` class, respectively the `GetBgt` class and call
    `execute()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also compact these examples via the statics `DepartmentPkg.getBgt()`
    and `DepartmentPkg.getMaxCash()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling these functions from queries is also possible. For instance, here are
    two trivial examples of calling them in `SELECT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example that uses both functions in the same query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: Check out these examples next to a few others not presented here in *Package*
    for Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: Oracle's member function/procedure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mainly, an Oracle PL/SQL object type contains attributes and members (or methods).
    Attributes or fields have data types and they are used to store data, while members
    are subprograms (functions/procedures) that are defined in the object type and
    manipulate the attributes for implementing certain functionalities. In this way,
    Oracle UDTs are a fully-fledged attempt at implementing an Object Relational Database
    Management System (ORDBMS). PostgreSQL didn't go quite as far as Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not an Oracle fan, then the following syntax should shed some light
    on this topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3 – Syntax of Oracle members'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.3 – Syntax of Oracle members
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this syntax, let''s have an example. Our `MANAGER` table has a field
    named `MANAGER_EVALUATION` that is of type `EVALUATION_CRITERIA` (in jOOQ, of
    type `TableField<ManagerRecord, EvaluationCriteriaRecord>`) defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have an object type containing four attributes (`communication_ability`,
    `ethics`, `performance`, and `employee_input`), two member functions (`IMPROVE()`
    and `SCORE()`), and no member procedures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The jOOQ Code Generator produces the following artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jooq.generated.udt` – In this package, we have the UDT type named `EvaluationCriteria`,
    representing an extension of jOOQ''s `UDTImpl<EvaluationCriteriaRecord>`. It contains
    the statics `EVALUATION_CRITERIA`, `COMMUNICATION_ABILITY`, `ETHICS`, `PERFORMANCE`,
    and `EMPLOYEE_INPUT` to refer to these UDT attributes and several flavors of the
    `improve()` and `score()` member functions returning the plain result or wrapped
    in a `Field`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jooq.generated.udt.records` – Contains the `EvaluationCriteriaRecord` representing
    the UDT record as an extension of the jOOQ''s `UDTRecordImpl<EvaluationCriteriaRecord>`.
    The `EvaluationCriteriaRecord` contains getters/setters for the object type attributes
    and contains the methods `improve()` and `score()` as well. These methods encapsulate
    the code needed to call the actual `improve()` and `score()` member functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jooq.generated.udt.evaluation_criteria` – Contains the `Improve` and `Score`
    classes (routines), so a class for each member function. Both `EvaluationCriteria`
    and `EvaluationCriteriaRecord` use these classes internally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, we can distinguish between calling the member functions starting from an
    empty record or from an existing record (for instance, a record fetched from the
    database). The conventional approach for starting from an empty record relies
    on `DSLContext.newRecord()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: The created record is already attached. Alternatively, we can instantiate `EvaluationCriteriaRecord`
    or use `EVALUATION_CRITERIA.newRecord()`, but the resulting record is not attached
    to a configuration (database), so you'll have to explicitly attach it by calling
    `attach()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we set the values of the attributes and call the member functions. Here,
    we call the `score()` method, which returns a `BigDecimal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the `improve()` methods increase the evaluation attributes
    by the given value and return a new `EvaluationCriteriaRecord`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: The `newEcr` record has `communication_ability` at *68* instead of *58*, `ethics`
    at *40* instead of *30*, and `performance` at *36* instead of *26*. Only `employee_input`
    remains unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `ecr`/`newEcr` in queries as well. Here is an example of using `newEcr`
    that originates from an empty record next to `MANAGER.MANAGER_EVALUATION`, which
    is fetched from the database (remember that `MANAGER.MANAGER_EVALUATION` is a
    `TableField<ManagerRecord, EvaluationCriteriaRecord>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s another example that combines the calls of `improve()` and `score()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: Check out these examples next to others omitted here in *MemberFunction* for
    Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: User-defined aggregate stored functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Oracle and SQL Server allow us to define aggregate stored functions (if you
    are not familiar with this topic, then please search these on Google: *Oracle
    User-Defined Aggregate Functions Interface* for Oracle and *SQL Server User-Defined
    Aggregate Functions* for SQL Server).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, the code of such functions is quite big to be listed here so please
    check the bundled code. For Oracle, check the application *UserDefinedAggFunction*,
    which calls a user-defined aggregate function named `secondMax()` that finds the
    second maximum value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: 'And for SQL Server, check the application also named *UserDefinedAggFunction*.
    Here, we call an aggregate stored function named `concatenate()` that simply concatenates
    the given strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: In order to work, please pay attention that you need to place the `StringUtilities.dll`
    DLL file (available in the bundled code) in the path specified in the function
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Stored procedures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: jOOQ allows you to call stored procedures via the same `Routines` API. Next,
    let's see several examples of calling different kinds of stored procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Stored procedures and output parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For instance, let''s consider the following stored procedure expressed in Oracle
    and having an `OUT` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: 'jOOQ generates the Java version of this stored procedure as a class named `GetAvgPriceByProductLine`
    in the `jooq.generated.routines` package. The methods of this class allow us to
    prepare the parameters (each input parameter has associated a setter, while each
    output parameter has associated a getter) and call our stored procedure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: 'We can express this more compactly via the generated `jooq.generated.Routines.getAvgPriceByProductLine()`
    static as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling a stored procedure in a jOOQ query can be done via the `getAvgPriceByProductLine(Configuration
    configuration, String pl)` flavor as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: 'jOOQ first renders the call of the stored procedure and fetches the `OUT` parameter
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the fetched value (*64*, in this example) is used to render the `SELECT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's call a stored procedure without output parameters that fetches a
    single result set.
  prefs: []
  type: TYPE_NORMAL
- en: Stored procedures fetching a single result set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a MySQL example of a stored procedure that doesn''t contain output
    parameters and fetches a single result set via `SELECT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling this stored procedure from jOOQ can be done via the generated `GetProduct`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: The result is obtained via `gp.getResults()`. Since there is a single result
    (the result set produced by the `SELECT`), we have to call `get(0)`. If there
    were two results involved (for instance, if we had two `SELECT` statements in
    the stored procedure), then we would call `get(0)` to get the first result and
    `get(1)` to get the second result. Or, in the case of even more results, simply
    loop the results. Notice that, in the case of stored procedures, the `getReturnValue()`
    method returns `void` since stored procedures don't return results as a stored
    function (they don't contain a `RETURN` statement). In fact, SQL Server's procedures
    can return an error code, which is an `int`. You can see that in SQL Server generated
    code for procedures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling the previous stored procedure via `Routines.getProduct()` returns `void`
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: 'The results obtained via `getResults()` are of type `Result<Record>`. This
    can be easily transformed into a regular `Table` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's take the `get_product()` stored procedure and let's express it in
    Oracle by adding an `OUT` parameter of type `SYS_REFCURSOR`.
  prefs: []
  type: TYPE_NORMAL
- en: Stored procedures with a single cursor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following stored procedure fetches the same result set as the previous
    `get_product()`, but it returns it via a cursor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, in `GetProduct`, jOOQ generates a getter for the `OUT` parameter
    named `getCursorResult()`, which allows us to fetch the result as a `Result<Record>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can fetch it more compactly via `Routines.getProduct(Configuration configuration,
    Number pid)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, this `Result<Record>` can be easily transformed into a regular `Table`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: Next, you can use this `Table` in queries.
  prefs: []
  type: TYPE_NORMAL
- en: Stored procedures fetching multiple result sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Going further, let''s tackle a stored procedure returning multiple result sets.
    Here, it''s expressed in MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: 'As you already know, jOOQ generates the `GetEmpsInOffice` class and the result
    sets are available via `getResults()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: '`Routines.getEmpsInOffice(Configuration c, String inOfficeCode)` returns `void`.'
  prefs: []
  type: TYPE_NORMAL
- en: Stored procedures with multiple cursors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let''s take the `get_emps_in_office()` stored procedure, and let''s express
    it in Oracle by adding two `OUT` parameters of type `SYS_REFCURSOR`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, besides `getResults()`, which you are already familiar with, we
    can take advantage of the getters produced by jOOQ for the `OUT` parameters as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, relying on `Routines.getEmpsInOffice(Configuration c, String inOfficeCode)`
    is quite convenient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you can rely on `results.getCursorInfo()` respectively on `results.getCursorEmployee()`
    or by looping the results as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, loop each `Result<Record>` as `for (Record record : result) …`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Not sure it''s worth mentioning, but at least Oracle also knows typed `REF
    CURSORS` (instead of just `SYS_REFCURSOR`), which jOOQ will support as well soon
    (when you''re reading this book, these features should be available): [https://github.com/jOOQ/jOOQ/issues/11708](https://github.com/jOOQ/jOOQ/issues/11708).'
  prefs: []
  type: TYPE_NORMAL
- en: Calling stored procedures via the CALL statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, let''s tackle the API of calling a stored procedure via the `CALL`
    statement in an anonymous procedural block and via `CALL` directly. Consider the
    following stored procedure expressed in Oracle (the complete code is available
    in the bundled code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling this stored procedure via the `CALL` statement in an anonymous procedural
    block can be done via `DSLContext.begin()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, call it directly via `DSLContext.call()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: You can practice all these examples in *CallProcedure*.
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ and creating stored functions/procedures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting with version 3.15, jOOQ began to add an API for creating stored functions,
    procedures, and triggers. Among others, we have support for `CREATE FUNCTION`,
    `CREATE OR REPLACE FUNCTION`, `CREATE PROCEDURE`, `CREATE OR REPLACE PROCEDURE`,
    `DROP FUNCTION`, and `DROP PROCEDURE`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating stored functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For instance, creating a scalar function for MySQL can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we create a scalar function having three input parameters created via
    the intuitive `Parameter` API by specifying their name and types. For MySQL, jOOQ
    renders the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in order to work, you should be aware of the following note.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'In MySQL, we can execute statement batches if we turn on the `allowMultiQueries`
    flag, which defaults to `false`; otherwise, we get an error. The previously generated
    SQL chains two statements, therefore this flag needs to be turned on – we can
    do it via the JDBC URL as `jdbc:mysql:…/classicmodels?allowMultiQueries=true`.
    Alternatively, in this particular case, we can rely on the `dropFunctionIfExists()`,`createFunction()`
    combo instead of `createOrReplaceFunction()`. I strongly advise you to take a
    couple of minutes to read this article by Lukas Eder, which explains in detail
    the implication of this flag in the jOOQ context: [https://blog.jooq.org/mysqls-allowmultiqueries-flag-with-jdbc-and-jooq/](https://blog.jooq.org/mysqls-allowmultiqueries-flag-with-jdbc-and-jooq/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You already know how to call this function from jOOQ via the generated code.
    This means that you have to run this code to create the stored function in the
    database, and afterward, run the jOOQ Code Generator to obtain the expected jOOQ
    artifacts. On the other hand, you can call it via plain SQL via the DSL''s `function()`
    as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: You can practice this example in *CreateFunction*.
  prefs: []
  type: TYPE_NORMAL
- en: How about creating the following PostgreSQL function having output parameters?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: 'From jOOQ, this function can be created like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling this function can be done via plain SQL as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: You can practice this example next to another one using `OUT` parameters in
    *CreateFunction* for PostgreSQL. For more examples that allow you to explore this
    API in detail, please consider the bundled code and the jOOQ manual.
  prefs: []
  type: TYPE_NORMAL
- en: Creating stored procedures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s begin with a stored procedure expressed in the SQL Server dialect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: 'This stored procedure, which has two input parameters and updates the `PRODUCT.MSRP`
    field, can be created through the jOOQ API as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: 'You already know how to call this procedure from jOOQ via the generated code,
    so this time, let''s call it via the `CALL` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: The returned result represents the number of rows affected by this `UPDATE`.
    This example is available in *CreateProcedure* for SQL Server and PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s pick up an example expressed in Oracle dialect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the jOOQ code for creating this procedure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: Since you are already familiar with this stored procedure from the previous
    section, *Stored procedures and output parameters*, you should have no problem
    calling it. The example is available in *CreateProcedure* for Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s tackle a MySQL stored procedure that fetches a result set via
    `SELECT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: 'The jOOQ code that creates the stored procedure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: In order for this code to work, we need to turn on the `allowMultiQueries` flag
    as explained in the previous section, *Creating stored functions*.
  prefs: []
  type: TYPE_NORMAL
- en: You can find this example next to another one that fetches two result sets in
    the application named *CreateProcedure* for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you've learned how to call and create some typical stored functions
    and procedures. Since these are powerful SQL tools, jOOQ strives to provide a
    comprehensive API to cover the tons of possibilities to express these artifacts
    in different dialects. Most probably, by the time you read this book, jOOQ will
    have already enriched this API even further and more examples will be available
    in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we tackle aliases and SQL templating.
  prefs: []
  type: TYPE_NORMAL
