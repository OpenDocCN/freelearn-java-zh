- en: '*Chapter 15*: Calling and Creating Stored Functions and Procedures'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第15章*：调用和创建存储函数和过程'
- en: SQL is a declarative language, but it also has procedural features such as stored
    functions/procedures, triggers, and cursors, which means SQL is considered to
    be a **Fourth-Generation Programming Language** (**4GL**). In this chapter, we
    will see how to call and create stored functions/procedures, or in other words,
    how to call and create Persistent Stored Modules (SQL/PSM) for MySQL, PostgreSQL,
    SQL Server, and Oracle.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: SQL是一种声明性语言，但它也具有存储函数/过程、触发器和游标等程序性功能，这意味着SQL被认为是**第四代编程语言**（**4GL**）。在本章中，我们将看到如何调用和创建存储函数/过程，换句话说，如何调用和创建MySQL、PostgreSQL、SQL
    Server和Oracle的持久化存储模块（SQL/PSM）。
- en: 'Just in case you need a quick reminder about the key differences between the
    stored procedures and functions, check out the following head-to-head table (some
    of these differences are entirely or partially true depending on the database):'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要快速回顾存储过程和函数之间的关键区别，请查看以下对头对头的表格（以下差异根据数据库的不同，有些是完全或部分正确的）：
- en: '![Figure 15.1 – Key differences between procedures and functions'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.1 – 程序和函数的关键区别](img/Figure_15.1.jpg)'
- en: '](img/Figure_15.1.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: Figure 15.1 – Key differences between procedures and functions
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 – 程序和函数的关键区别
- en: As you can infer from the previous comparison, the main difference is that procedures
    (may) produce a side effect, whereas functions are (generally) expected not to.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的比较中可以推断出的，主要区别在于程序（可能）会产生副作用，而函数（通常）预期不会。
- en: 'So, our agenda includes the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的议程包括以下主题：
- en: Calling stored functions/procedures from jOOQ
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从jOOQ调用存储函数/过程
- en: Stored procedures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储过程
- en: Creating stored functions/procedures via jOOQ
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过jOOQ创建存储函数/过程
- en: 'Right before getting started, let''s have some insight from Lukas Eder who
    shared that: "*This may come up later, but it might be worth mentioning early:
    there are some users who use jOOQ *only* for its stored procedure code generation
    capabilities. When you have a lot of stored procedures, it''s almost impossible
    to bind to them without code generation, and jOOQ works very well out of the box,
    kind of like when you have a WSDL file (or something comparable), and you generate
    all the stubs with Axis or Metro, and so on."*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们从Lukas Eder那里得到一些见解，他分享说：“*这可能会稍后出现，但可能值得早点提一下：有一些用户只使用jOOQ的存储过程代码生成功能。当你有很多存储过程时，没有代码生成几乎不可能将它们绑定起来，而jOOQ开箱即用，有点像当你有一个WSDL文件（或类似的东西），然后使用Axis或Metro等生成所有存根，等等。”*
- en: OK, now let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们开始吧！
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter15](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter15).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：[https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter15](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter15)。
- en: Calling stored functions/procedures from jOOQ
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从jOOQ调用存储函数/过程
- en: Once you start dealing with stored functions/procedures across different database
    vendors, you'll be hit by the lack of standardization. For instance, the vendor-specific
    syntax for expressing functions/procedures, the wide variety of vendor-specific
    functions/procedure types, and different ways of supporting and treating the output
    parameters are just a few non-standard aspects of stored functions/procedures.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开始处理不同数据库供应商的存储函数/过程，你将面临标准化的缺乏。例如，用于表示函数/过程的供应商特定语法、供应商特定函数/过程类型的广泛多样性，以及支持和处理输出参数的不同方式，只是存储函数/过程的几个非标准化方面。
- en: Calling stored functions/procedures via plain JDBC code is not easy either,
    especially if advanced data types are involved (for instance, arrays or UDTs).
    But, as you already know, using the jOOQ DSL saves us from interacting directly
    with the JDBC API, so it saves us from making cutting-edge decisions regarding
    JDBC workarounds.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过纯JDBC代码调用存储函数/过程也不容易，尤其是当涉及到高级数据类型时（例如，数组或UDTs）。但是，正如你所知道的那样，使用jOOQ DSL可以让我们避免直接与JDBC
    API交互，因此它节省了我们做出关于JDBC解决方案的尖端决策。
- en: The jOOQ DSL represents stored functions/procedures via the `org.jooq.Routine`
    API, so there is a common API for both. Whenever the jOOQ generator detects a
    stored function/procedure it generates (among other things) a dedicated class
    in the proper package (in our case, `jooq.generated.routines`) that reflects its
    name (for instance, by default, a stored function named `get_emps_in_office()`
    results in a class named `GetEmpsInOffice`) and extends the jOOQ `AbstractRoutine`
    class. The generated class exposes the API needed to call this stored function/procedure
    via jOOQ DSL. Moreover, as you'll see soon, calling a stored function/procedure
    can also be done in an anonymous procedural block via `DSLContext.begin()` and
    directly via `DSLContext.call()`. But, enough theory, next let's tackle some different
    kinds of stored functions/procedures from the jOOQ perspective, and let's start
    with stored functions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ DSL通过`org.jooq.Routine` API表示存储函数/过程，因此有一个共同的API。每当jOOQ生成器检测到一个存储函数/过程时，它会在适当的包中生成一个专用类（在我们的例子中，是`jooq.generated.routines`），该类反映了其名称（例如，默认情况下，名为`get_emps_in_office()`的存储函数会产生名为`GetEmpsInOffice`的类）并扩展了jOOQ的`AbstractRoutine`类。生成的类公开了通过jOOQ
    DSL调用此存储函数/过程的API。此外，正如您很快就会看到的，调用存储函数/过程也可以通过`DSLContext.begin()`和直接通过`DSLContext.call()`在匿名过程块中完成。但是，理论就到这里，接下来让我们从jOOQ的角度探讨一些不同类型的存储函数/过程，让我们从存储函数开始。
- en: Stored functions
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储函数
- en: Stored functions return a result (for instance, the result of a computation).
    They can be called in SQL statements and, usually, they don't support output (`OUT`)
    parameters. However, in Oracle and PostgreSQL, stored functions may have output
    parameters that can be interpreted as returned results. Moreover, until version
    11, PostgreSQL supports only stored functions that combine the features of stored
    functions and procedures. On the other hand, PostgreSQL 11 and beyond, Oracle,
    MySQL, and SQL Server distinguish between stored functions and procedures.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 存储函数返回一个结果（例如，计算的输出）。它们可以在SQL语句中调用，并且通常不支持输出（`OUT`）参数。然而，在Oracle和PostgreSQL中，存储函数可能有输出参数，这些参数可以解释为返回结果。此外，直到版本11，PostgreSQL只支持结合存储函数和过程特征的存储函数。另一方面，PostgreSQL
    11及以后，Oracle、MySQL和SQL Server在存储函数和过程之间进行了区分。
- en: Next, let's see how we can call from jOOQ different kinds of stored functions
    expressed in one of these four dialects, and let's start by calling some scalar
    functions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何从jOOQ调用用这四种方言之一表达的不同类型的存储函数，让我们先调用一些标量函数。
- en: Scalar functions
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标量函数
- en: 'A stored function that takes none, one, or more parameters, and returns a single
    value is commonly referred to as a scalar function. As a common practice, scalar
    functions encapsulate complex calculations that appear in many queries. Instead
    of expressing the calculation in every query, you can write a scalar function
    that encapsulates this calculation and uses it in each query. Roughly, the syntax
    of a scalar function is a variation of this skeleton:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个接受零个、一个或多个参数并返回单个值的存储函数通常被称为标量函数。作为一种常见做法，标量函数封装了出现在许多查询中的复杂计算。您不必在每次查询中都表达这个计算，而是可以编写一个封装此计算的标量函数，并在每次查询中使用它。大致来说，标量函数的语法是这个骨架的变体：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For instance, a simple scalar function expressed in MySQL may look as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个简单的标量函数在MySQL中可能看起来如下所示：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For this scalar function, the jOOQ Code Generator produces a dedicated class
    named `jooq.generated.routines.SalePrice`. Among its methods, this class exposes
    setters that allow us to provide the input parameters of the function. In our
    example, we will have `setQuantity(Integer value)`, `setQuantity(Field<Integer>
    field)`, `setListPrice(Double value)`, `setListPrice(Field<Double> field)`, `setFractionOfPrice(Double
    value)`, and `setFractionOfPrice(Field<Double> field)`. The function can be executed
    via jOOQ''s well-known `execute()` methods. If the function already has a `Configuration`
    attached, then you can rely on `execute()` without parameters, otherwise use the
    `execute(Configuration c)` method as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个标量函数，jOOQ代码生成器生成一个名为`jooq.generated.routines.SalePrice`的专用类。在其方法中，这个类公开了允许我们提供函数输入参数的设置器。在我们的例子中，我们将有`setQuantity(Integer
    value)`、`setQuantity(Field<Integer> field)`、`setListPrice(Double value)`、`setListPrice(Field<Double>
    field)`、`setFractionOfPrice(Double value)`和`setFractionOfPrice(Field<Double> field)`。函数可以通过jOOQ的知名`execute()`方法执行。如果函数已经附加了`Configuration`，则可以依赖`execute()`不带参数，否则使用`execute(Configuration
    c)`方法，如下所示：
- en: '[PRE16]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Getting the returned scalar result can be done via the `getReturnValue()` method.
    In this case, you can use it like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `getReturnValue()` 方法获取返回的标量结果。在这种情况下，你可以这样使用它：
- en: '[PRE21]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you just saw, each setter has a flavor that gets a `Field` as an argument.
    This means that we can write something like this (check the first two setters):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，每个设置器都有一个获取 `Field` 作为参数的风味。这意味着我们可以写点这样的东西（检查前两个设置器）：
- en: '[PRE22]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The previous examples are useful if the routine has more than 254 parameters
    (which isn't allowed in Java), if there are default parameters, which users don't
    want to set, or if the parameters need to be set dynamically. Otherwise, most
    probably, you'll prefer to use the static convenience API.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果例程有超过 254 个参数（Java 中不允许），或者有默认参数，用户不想设置，或者参数需要动态设置，那么前面的示例将很有用。否则，你很可能更愿意使用静态便利
    API。
- en: 'Writing these two examples in a more convenient/compact way can be done via
    the `Routines.salePrice()` static method. The `jooq.generated.Routines` class
    provides convenient static methods for accessing all stored functions/procedures
    that jOOQ has found in your database. In this case, the following two examples
    compact the previous examples (of course, you can shorten this example further
    by importing the `jooq.generated.Routines.salePrice` static):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `Routines.salePrice()` 静态方法以更方便/紧凑的方式编写这两个示例。`jooq.generated.Routines` 类提供了方便的静态方法来访问
    jOOQ 在你的数据库中找到的所有存储函数/过程。在这种情况下，以下两个示例紧凑了前面的示例（当然，你可以通过导入 `jooq.generated.Routines.salePrice`
    静态进一步缩短这个示例）：
- en: '[PRE29]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Scalar functions can be used in queries as well. Here is an example via another
    flavor of `Routines.salePrice()`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 标量函数也可以用在查询中。这里是一个通过 `Routines.salePrice()` 的另一种风味示例：
- en: '[PRE43]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'For MySQL, jOOQ renders the following plain SQL:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 MySQL，jOOQ 生成的以下 SQL 是这样的：
- en: '[PRE51]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You can practice this example in *ScalarFunction*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *ScalarFunction* 中练习这个示例。
- en: 'In this context, here is another function that was written for PostgreSQL that
    updates a `PRODUCT.MSRP` and returns it via `UPDATE … RETURNING` (do not confuse
    it with the function `RETURN` statement!):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，这里还有一个为 PostgreSQL 编写的函数，它更新 `PRODUCT.MSRP` 并通过 `UPDATE … RETURNING`
    返回（不要与 `RETURN` 语句混淆）：
- en: '[PRE59]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'jOOQ can call such a function as you saw in the previous example. For instance,
    here it is called in a `SELECT`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 可以像上一个示例中看到的那样调用这样的函数。例如，这里是在一个 `SELECT` 中调用的：
- en: '[PRE66]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'And the rendered SQL is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 SQL 如下所示：
- en: '[PRE70]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You can practice this example in *UpdateFunction* for PostgreSQL.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *UpdateFunction* 中为 PostgreSQL 练习这个示例。
- en: If your scalar functions are under Oracle, then you can take advantage of a
    nice Oracle feature known as *scalar subquery caching*. Basically, this feature
    renders the calls of stored functions wrapped in SQL statements as a scalar subquery.
    This feature avoids switching between PL/SQL and SQL contexts and this may result
    in better performance.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的标量函数在 Oracle 上，那么你可以利用一个称为 *标量子查询缓存* 的很好的 Oracle 功能。基本上，这个功能将存储函数的调用封装在
    SQL 语句中，作为标量子查询。这个功能避免了在 PL/SQL 和 SQL 上下文之间切换，这可能会导致更好的性能。
- en: 'Consider the following scalar function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下标量函数：
- en: '[PRE76]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Calling this scalar function in a query can be done here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询中调用这个标量函数可以在这里完成：
- en: '[PRE87]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'But keep in mind Lukas Eder''s note: *"Just in case, scalar subquery caching
    isn''t documented in Oracle, as far as I know. The context switch isn''t avoided
    entirely, but it happens only once per scalar subquery input value, and thus per
    function argument value, and per query. So, instead of having 1 switch per row,
    we now have 1 switch per function input value."*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住卢卡斯·埃德（Lukas Eder）的笔记：“据我所知，标量子查询缓存在 Oracle 中没有文档。上下文切换并没有完全避免，但它只发生在每个标量子查询输入值、每个函数参数值和每个查询上。因此，我们现在每个函数输入值只有一个切换，而不是每行有一个切换。”
- en: 'Each time we execute this code, jOOQ renders a query that requires switching
    between PL/SQL and SQL contexts in order to execute the scalar function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们执行这段代码时，jOOQ 都会生成一个查询，该查询需要在 PL/SQL 和 SQL 上下文之间切换以执行标量函数：
- en: '[PRE93]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'But jOOQ has the `withRenderScalarSubqueriesForStoredFunctions()` flag-setting
    that is by default set to `false`. Once we set it to `true`, jOOQ turns on Oracle''s
    *scalar subquery caching* feature. In the following example, we turn this feature
    on only for the current SQL:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但 jOOQ 有一个 `withRenderScalarSubqueriesForStoredFunctions()` 标志设置，默认设置为 `false`。一旦我们将它设置为
    `true`，jOOQ 就会开启 Oracle 的 *标量子查询缓存* 功能。在下面的示例中，我们只为当前的 SQL 开启这个功能：
- en: '[PRE96]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'This time, the call of the `cardCommission()` stored function is rendered as
    a scalar subquery:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`cardCommission()` 存储函数的调用被渲染为一个标量子查询：
- en: '[PRE102]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: You can practice this example in *ScalarSubqueryCaching* for Oracle.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*ScalarSubqueryCaching*（针对Oracle）中练习这个示例。
- en: Functions returning arrays
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回数组的函数
- en: 'PostgreSQL is a convenient way to write a function that returns an array. For
    instance, here is a function returning `DEPARTMENT.TOPIC`, which is declared in
    our schema as an array of type `TEXT[]`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL是编写返回数组的函数的便捷方式。例如，这里是一个返回`DEPARTMENT.TOPIC`的函数，它在我们的模式中声明为一个`TEXT[]`类型的数组：
- en: '[PRE107]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Calling this function in `SELECT` via the dedicated method, `departmentTopicArr()`,
    generated by jOOQ in `Routines` can be done by unnesting the returned array as
    in the following examples:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过jOOQ在`Routines`中生成的专用方法`departmentTopicArr()`在`SELECT`中调用此函数，可以通过以下示例中的展开返回的数组来完成：
- en: '[PRE115]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Next, let''s take a function having an anonymous parameter (no explicit name)
    that builds and returns an array:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑一个具有匿名参数（没有显式名称）的函数，该函数构建并返回一个数组：
- en: '[PRE118]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'This time, let''s instantiate `EmployeeOfficeArr`, and let''s pass the required
    parameter via a setter:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，让我们实例化`EmployeeOfficeArr`，并通过设置器传递所需的参数：
- en: '[PRE125]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Since the function's parameter doesn't have a name, jOOQ has used its default
    implementation and generated a `set__1()` setter. If you had two no-name parameters,
    then jOOQ would generate `set__1()` and `set__2()`, and so on. In other words,
    jOOQ generates setters based on parameter positions starting from 1.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数的参数没有名称，jOOQ使用了其默认实现并生成了一个`set__1()`设置器。如果你有两个无名称的参数，那么jOOQ将生成`set__1()`和`set__2()`，依此类推。换句话说，jOOQ根据参数位置从1开始生成设置器。
- en: 'On the other hand, using the generated `Routines.employeeOfficeArr()` in a
    `SELECT` query can be done as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在`SELECT`查询中使用生成的`Routines.employeeOfficeArr()`可以如下进行：
- en: '[PRE129]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'For PostgreSQL, jOOQ renders this SQL:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于PostgreSQL，jOOQ生成的SQL如下：
- en: '[PRE134]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: You can practice these examples in *ArrayFunction* for PostgreSQL.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*ArrayFunction*（针对PostgreSQL）中练习这些示例。
- en: Functions with output parameters
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有输出参数的函数
- en: 'As we said earlier, PostgreSQL and Oracle allow output parameters in functions.
    Here is an example in PostgreSQL:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，PostgreSQL和Oracle允许函数中有输出参数。以下是一个PostgreSQL中的示例：
- en: '[PRE140]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'This function doesn''t have a `RETURN`, but it has three `OUT` parameters that
    help us to obtain the results of execution. For each such parameter, jOOQ generates
    a getter, so we can call it via the generated `jooq.generated.routines.GetSalaryStat`
    like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数没有`RETURN`，但它有三个`OUT`参数，帮助我们获得执行结果。对于每个这样的参数，jOOQ生成一个getter，因此我们可以通过生成的`jooq.generated.routines.GetSalaryStat`来调用它，如下所示：
- en: '[PRE152]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'This code (more precisely the `execute()` call) leads to the following `SELECT`
    (or `CALL`, in Oracle):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码（更确切地说，是`execute()`调用）导致以下`SELECT`（或者在Oracle中是`CALL`）：
- en: '[PRE157]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Here''s the same result via `Routines.getSalaryStat(Configuration c)`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`Routines.getSalaryStat(Configuration c)`也可以得到相同的结果：
- en: '[PRE159]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Here are two more examples:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有两个更多示例：
- en: '[PRE161]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'But pay attention that both of these examples lead to two `SELECT` statements
    (or, a `CALL` and a `SELECT` statement in Oracle) since functions with output
    parameters cannot be called from plain SQL. In other words, jOOQ calls the routine
    and fetches the `OUT` parameters as you can see next:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，这两个示例都会导致两个`SELECT`语句（或者在Oracle中是一个`CALL`和一个`SELECT`语句），因为带有输出参数的函数不能从纯SQL中调用。换句话说，jOOQ调用例程并检索您接下来可以看到的`OUT`参数：
- en: '[PRE169]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'And, afterward, it executes the `SELECT` that uses the results extracted from
    the output parameters. The following `SELECT` fits our second example (65652.17
    is the average salary computed via `getSalaryStat(Configuration c)`):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它执行使用从输出参数中提取的结果的`SELECT`。以下`SELECT`符合我们的第二个示例（65652.17是通过`getSalaryStat(Configuration
    c)`计算出的平均工资）：
- en: '[PRE171]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Lukas Eder shared: *"In Oracle, functions with OUT parameters aren''t "SQL
    callable," though... In PostgreSQL, they''re just "syntax sugar" (or un-sugar,
    depending on taste) for a function returning a record."*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Lukas Eder分享说：“在Oracle中，带有OUT参数的函数并不是“SQL可调用的”，尽管如此...在PostgreSQL中，它们只是函数返回记录的“语法糖”（或者根据口味，是“去糖”）。”
- en: You can practice these examples in *InOutFunction* for PostgreSQL (here, you
    can find an `IN OUT` example as well).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*InOutFunction*（针对PostgreSQL）中练习这些示例（在这里，你还可以找到一个`IN OUT`示例）。
- en: 'So, using `OUT` (or `IN OUT`) parameters in functions is not such a great idea
    and must be avoided. As Oracle mentioned, besides preventing a function from being
    used in SQL queries (more details here: [https://oracle-base.com/articles/12c/with-clause-enhancements-12cr1](https://oracle-base.com/articles/12c/with-clause-enhancements-12cr1)),
    the presence of output parameters in a function prevents a function from being
    marked as a `DETERMINISTIC` function or used as a result-cached function. Unlike
    PostgreSQL, Oracle functions having output parameters must have an explicit `RETURN`.
    Next to the jOOQ getters dedicated to output parameters, you can call `getReturnValue()`
    to obtain the result returned explicitly via the `RETURN` statement. When this
    book was written, functions with `OUT` parameters couldn''t be called in jOOQ
    from plain SQL. Follow this feature request here: [https://github.com/jOOQ/jOOQ/issues/3426](https://github.com/jOOQ/jOOQ/issues/3426).'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在函数中使用 `OUT`（或 `IN OUT`）参数并不是一个好主意，必须避免。正如 Oracle 所说，除了防止函数在 SQL 查询中使用（更多细节请参阅[这里](https://oracle-base.com/articles/12c/with-clause-enhancements-12cr1)）之外，函数中输出参数的存在还防止了函数被标记为
    `DETERMINISTIC` 函数或用作结果缓存的函数。与 PostgreSQL 不同，具有输出参数的 Oracle 函数必须有一个显式的 `RETURN`。在
    jOOQ 专门用于输出参数的获取器旁边，你可以调用 `getReturnValue()` 来获取通过 `RETURN` 语句显式返回的结果。当这本书编写时，具有
    `OUT` 参数的函数不能在 jOOQ 中从纯 SQL 调用。在此功能请求中查看：[https://github.com/jOOQ/jOOQ/issues/3426](https://github.com/jOOQ/jOOQ/issues/3426)。
- en: You can practice an example in *InOutFunction* for Oracle (here, you can find
    an `IN OUT` example too).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *InOutFunction* 的 Oracle 示例中进行练习（在这里，你还可以找到一个 `IN OUT` 示例）。
- en: Polymorphic functions
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多态函数
- en: 'Some databases support the so-called polymorphic functions that accept and
    return polymorphic types. For instance, PostgreSQL supports the following polymorphic
    types: `anyelement`, `anyarray`, `anynonarray`, `anyenum`, and `anyrange`. Here
    is an example that builds an array from two passed arbitrary data type elements:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据库支持所谓的多态函数，这些函数可以接受和返回多态类型。例如，PostgreSQL 支持以下多态类型：`anyelement`、`anyarray`、`anynonarray`、`anyenum`
    和 `anyrange`。以下是一个从两个传递的任意数据类型元素构建数组的示例：
- en: '[PRE176]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Calling this function from jOOQ can be done as follows (notice the positional
    setters at work again):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 jOOQ 调用此函数可以这样进行（注意位置设置器再次起作用）：
- en: '[PRE181]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'The returned result is `org.postgresql.jdbc.PgArray`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的结果是 `org.postgresql.jdbc.PgArray`：
- en: '[PRE185]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'In the bundled code you can see further processing of this array. For now,
    let''s call `make_array()` from `SELECT` to build an array of integers and an
    array of strings:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以看到对这个数组的进一步处理。现在，让我们从 `SELECT` 中调用 `make_array()` 来构建一个整数数组和字符串数组：
- en: '[PRE186]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'How about a function that combines polymorphic types and output parameters?
    Here is one:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 那么一个结合多态类型和输出参数的函数呢？这里有一个示例：
- en: '[PRE188]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Call it via jOOQ:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 jOOQ 调用它：
- en: '[PRE191]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Or use it in a `SELECT` (remember from the previous section that this leads
    to two statements against the database):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在 `SELECT` 中使用它（记住，从上一节中提到的，这将导致对数据库的两个语句）：
- en: '[PRE195]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: You can practice these examples in *PolymorphicFunction* for PostgreSQL.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *PolymorphicFunction* 的 PostgreSQL 中练习这些示例。
- en: Functions returning explicit cursors
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回显式游标的函数
- en: 'A function can return an explicit cursor (an explicit pointer that points to
    a result of a query) as well. Most probably, you''re familiar with PostgreSQL
    `REFCURSOR` and Oracle `SYS_REFCURSOR`. Here is an example for Oracle:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 函数还可以返回一个显式游标（一个指向查询结果的显式指针）。你很可能熟悉 PostgreSQL 的 `REFCURSOR` 和 Oracle 的 `SYS_REFCURSOR`。以下是一个
    Oracle 的示例：
- en: '[PRE197]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'Calling this function via the generated `jooq.generated.routines.GetCustomer`
    can be done as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 通过生成的 `jooq.generated.routines.GetCustomer` 函数调用可以这样进行：
- en: '[PRE209]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'The result is mapped by jOOQ to `Result<Record>`, so a list of records is fitted
    entirely into memory. For better accommodation of large datasets, jOOQ has some
    pending feature requests to stream the cursors, so you can check the progress
    of issues #4503 and #4472 on the jOOQ repository. Alternatively, you can wrap
    the returned cursor in a table-valued function and fetch the results via a `SELECT`
    statement using jOOQ''s `ResultQuery.fetchLazy()` method, as you saw in [*Chapter
    8*](B16833_08.xhtml#_idTextAnchor128), *Fetching and Mapping*.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '结果被 jOOQ 映射为 `Result<Record>`，因此记录列表完全适合内存。为了更好地适应大数据集，jOOQ 有一些待处理的功能请求以流式传输游标，因此你可以检查
    jOOQ 仓库中的问题 #4503 和 #4472。或者，你可以将返回的游标包装在一个表值函数中，并通过 jOOQ 的 `ResultQuery.fetchLazy()`
    方法使用 `SELECT` 语句获取结果，就像你在 [*第 8 章*](B16833_08.xhtml#_idTextAnchor128) 的 *获取和映射*
    中看到的那样。'
- en: 'Now, going further, you can loop the `Result<Record>` and process each record,
    but to access a certain column (for instance, the customer name) of a certain
    row (for instance, the first row), then you can use `getValue()` or `get()` as
    here:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更进一步，你可以循环 `Result<Record>` 并处理每条记录，但要访问某一行（例如，第一行）的某个列（例如，客户名称），那么你可以使用
    `getValue()` 或 `get()`，就像这里一样：
- en: '[PRE213]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: To get multiple names (or other columns) rely on `getValues()`, which comes
    in many flavors that you can find in the official documentation.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取多个名称（或其他列），请依赖于 `getValues()`，它有多种风味，你可以在官方文档中找到。
- en: 'Obtaining the same `Result<Record>` can be done more compactly via the generated
    static `Routines.getCustomer()`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 通过生成的静态 `Routines.getCustomer()` 可以更紧凑地获取相同的 `Result<Record>`：
- en: '[PRE215]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'If you need a `Table` instead of this `Result<Record>`, then simply rely on
    `org.jooq.impl.DSL.table` as in the following two examples:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个 `Table` 而不是这个 `Result<Record>`，那么简单地依赖于 `org.jooq.impl.DSL.table`，就像以下两个示例中那样：
- en: '[PRE217]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Next, you can use `t` in queries like any regular `Table`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以在查询中使用 `t`，就像使用任何常规的 `Table` 一样：
- en: '[PRE219]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'On the other hand, another flavor of `Routines.getCustomer()` returns the result
    wrapped in a `Field` as `Field<Result<Record>>`. This allows us to use this result
    as a `Field`. For instance, here is a `SELECT`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Routines.getCustomer()` 的另一种风味返回的结果被一个 `Field` 包装，作为 `Field<Result<Record>>`。这允许我们使用这个结果作为
    `Field`。例如，这里有一个 `SELECT`：
- en: '[PRE227]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: You can practice these examples in *CursorFunction* for Oracle.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Oracle 的 *CursorFunction* 中练习这些示例。
- en: 'How about a function that returns multiple cursors? Here is a sample that was
    written for PostgreSQL:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 那么一个返回多个游标的函数呢？这里是一个为 PostgreSQL 编写的示例：
- en: '[PRE230]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: 'In this case, each cursor produces a `Result<Record>` wrapped in a generated
    `Record` class. Here, we have two cursors, therefore two `Result<Record>` wrapped
    in two instances of the generated `GetOfficesMultipleRecord`. When we call `Routines.getOfficesMultiple(Configuration
    c)` we get a `Result<GetOfficesMultipleRecord>` that can be expanded as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个游标产生一个 `Result<Record>`，被一个生成的 `Record` 类包装。这里，我们有两个游标，因此有两个 `Result<Record>`
    被两个生成的 `GetOfficesMultipleRecord` 实例包装。当我们调用 `Routines.getOfficesMultiple(Configuration
    c)` 时，我们得到一个 `Result<GetOfficesMultipleRecord>`，它可以如下展开：
- en: '[PRE249]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: You can practice these examples in *CursorFunction* for PostgreSQL.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 PostgreSQL 的 *CursorFunction* 中练习这些示例。
- en: Table-valued functions
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表值函数
- en: Apart from database views, one of the underrated features of SQL is table-valued
    functions. This is not the first time in this book that we've discussed this feature,
    but this time, let's add a few more details. So, a table-valued function is a
    function that returns a set of data as a table data type. The returned table can
    be used just like a regular table.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据库视图之外，SQL 中被低估的功能之一是表值函数。这本书中我们已经讨论过这个特性不止一次了，但这次，让我们添加一些更多细节。所以，表值函数是一个返回一组数据作为表数据类型的函数。返回的表可以像常规表一样使用。
- en: 'Table-valued functions are not supported in MySQL, but they are supported in
    PostgreSQL, Oracle, and SQL Server. Next is a snippet of code from a PostgreSQL
    table-valued function (notice the `RETURNS TABLE` syntax, which indicates that
    the `SELECT` query from the function returns the data as a table to whatever calls
    the function):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 表值函数在 MySQL 中不受支持，但在 PostgreSQL、Oracle 和 SQL Server 中受支持。下面是一个 PostgreSQL 表值函数的代码片段（注意
    `RETURNS TABLE` 语法，它表示函数的 `SELECT` 查询返回的数据作为表给调用函数的任何东西）：
- en: '[PRE258]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: By default, the jOOQ Code Generator will generate for this function a class
    named `ProductOfProductLine` in the `jooq.generated.tables` package, not in the
    `jooq.generated.routines` package. The explanation is simple; jOOQ (like most
    databases) treats table-valued functions as ordinary tables that can be used in
    the `FROM` clause of `SELECT` like any other table. An exception from this practice
    is Oracle, where it is quite common to treat them as standalone routines – in
    this context, jOOQ has a flag setting that allows us to indicate whether table-valued
    functions should be treated as ordinary tables (generated in `jooq.generated.tables`)
    or as plain routines (generated in `jooq.generated.routines`). This is detailed
    in [*Chapter 6*](B16833_06.xhtml#_idTextAnchor093), *Tackling Different Kinds
    of JOIN Statements*.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，jOOQ代码生成器将为该函数生成一个名为`ProductOfProductLine`的类，位于`jooq.generated.tables`包中，而不是`jooq.generated.routines`包中。解释很简单；jOOQ（像大多数数据库一样）将表值函数视为普通表，可以在`SELECT`语句的`FROM`子句中使用，就像任何其他表一样。Oracle是一个例外，在那里将它们视为独立的程序——在这个上下文中，jOOQ有一个标志设置，允许我们指示表值函数应该被视为普通表（在`jooq.generated.tables`中生成）还是作为普通程序（在`jooq.generated.routines`中生成）。这详细说明在[*第6章*](B16833_06.xhtml#_idTextAnchor093)，*处理不同类型的JOIN语句*。
- en: 'Calling a table-valued function (with arguments) can be done via the `call()`
    method:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`call()`方法调用表值函数（带有参数）：
- en: '[PRE268]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: 'In queries, we may prefer to use the `PRODUCT_OF_PRODUCT_LINE` static field
    that was generated by the jOOQ generator in `ProductOfProductLine`. Both of the
    following examples produce the same SQL:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询中，我们可能更喜欢使用jOOQ生成器在`ProductOfProductLine`中生成的`PRODUCT_OF_PRODUCT_LINE`静态字段。以下两个示例生成相同的SQL：
- en: '[PRE274]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: 'Here are two more examples of calling this table-valued function in the `FROM`
    clause:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个在`FROM`子句中调用此表值函数的示例：
- en: '[PRE278]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: Since a table-valued function returns a table, we should be able to use them
    in joins. But the regular `JOIN` feature doesn't allow us to join a table-valued
    function, so we need another approach. Here is where `CROSS APPLY` and `OUTER
    APPLY` (or `LATERAL`) enter into the scene. In [*Chapter 6*](B16833_06.xhtml#_idTextAnchor093),
    *Tackling Different Kinds of JOIN Statements*, you saw an example of using `CROSS`/`OUTER
    APPLY` to solve the popular task of joining two tables based on the results of
    a TOP-N query. So, `CROSS`/`OUTER APPLY` allows us to combine in a query the results
    returned by a table-valued function with the results of other tables or, in short,
    to join table-valued functions to other tables.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 由于表值函数返回一个表，我们应该能够在连接中使用它们。但是常规的`JOIN`功能不允许我们将表值函数与表连接，因此我们需要另一种方法。这就是`CROSS
    APPLY`和`OUTER APPLY`（或`LATERAL`）出现的地方。在[*第6章*](B16833_06.xhtml#_idTextAnchor093)，*处理不同类型的JOIN语句*中，你看到了使用`CROSS`/`OUTER
    APPLY`来解决基于TOP-N查询结果连接两个表的流行任务的示例。因此，`CROSS`/`OUTER APPLY`允许我们在查询中结合表值函数返回的结果与其他表的结果，简而言之，就是将表值函数与其他表连接。
- en: 'For instance, let''s use `CROSS`/`OUTER APPLY` (you can think of it as a `Stream.flatMap()`
    in Java) to join the `PRODUCTLINE` table to our table-valued function. Let''s
    say that we have added a new `PRODUCTLINE` without products named *Helicopters*
    and let''s see how `CROSS APPLY` works:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们使用`CROSS`/`OUTER APPLY`（你可以将其视为Java中的`Stream.flatMap()`）将`PRODUCTLINE`表与我们的表值函数连接起来。假设我们已经添加了一个没有产品的名为*直升机*的新`PRODUCTLINE`，让我们看看`CROSS
    APPLY`是如何工作的：
- en: '[PRE286]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: Since the *Helicopters* product line has no products, `CROSS APPLY` will not
    fetch it because `CROSS APPLY` acts as `CROSS JOIN LATERAL`. How about `OUTER
    APPLY`?
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*直升机*产品线没有产品，`CROSS APPLY`不会检索它，因为`CROSS APPLY`的作用类似于`CROSS JOIN LATERAL`。那么`OUTER
    APPLY`呢？
- en: '[PRE292]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: On the other hand, `OUTER APPLY` acts as `LEFT OUTER JOIN LATERAL`, so the *Helicopters*
    product line is returned as well.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`OUTER APPLY`的作用类似于`LEFT OUTER JOIN LATERAL`，因此*直升机*产品线也会被返回。
- en: 'Lukas Eder shared an opinion here: *"In fact, for historic reasons, APPLY or
    LATERAL is optional in at least Db2, Oracle, and PostgreSQL, under some conditions.
    SQL Server had APPLY for a long time, but the others introduced LATERAL only relatively
    recently. I personally don''t understand the value of making LATERAL explicit.
    It''s always clear what an implicit LATERAL means..."*'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: Lukas Eder在这里分享了一个观点：“实际上，出于历史原因，在Db2、Oracle和PostgreSQL中，在某些条件下，APPLY或LATERAL是可选的。SQL
    Server长期以来都有APPLY，但其他数据库最近才引入LATERAL。我个人不明白明确LATERAL的价值。隐式LATERAL的含义总是很清楚...”
- en: You can check out these examples in the bundled code, *TableValuedFunction*
    for PostgreSQL, Oracle, and SQL Server.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的代码中查看这些示例，*TableValuedFunction*适用于PostgreSQL、Oracle和SQL Server。
- en: Oracle's package
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Oracle的包
- en: 'Oracle allows us to group the functions/procedures that are commonly logically
    related into a package. A package has two parts: the first part contains the public
    items and is known as the *package specification*, while the second part, known
    as the *package body*, provides the code of the cursors or subprograms declared
    in the package specification. If no cursors/subprograms were declared in the package
    specification, then the package body can be skipped. If you are not an Oracle
    fan, then the following syntax should help you to digest this topic a little bit
    easier:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 允许我们将逻辑上常见相关的函数/过程组合成一个包。包有两个部分：第一部分包含公共项，称为 *包规范*，而第二部分，称为 *包主体*，提供了在包规范中声明的游标或子程序的代码。如果在包规范中没有声明游标/子程序，则可以跳过包主体。如果您不是
    Oracle 的粉丝，那么以下语法可能有助于您更容易地消化这个主题：
- en: '![Figure 15.2 – Syntax of Oracle package'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.2 – Oracle 包的语法'
- en: '](img/Figure_15.2.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_15.2.jpg)'
- en: Figure 15.2 – Syntax of Oracle package
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2 – Oracle 包的语法
- en: 'Lukas Eder shared an analogy that''s useful to better understand this topic:
    *"If it helps, package specifications are like interfaces, and bodies are like
    singleton instances, kind of. In a way, like this*: [https://twitter.com/lukaseder/status/1443855980693962755](https://twitter.com/lukaseder/status/1443855980693962755)."'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 卢卡斯·埃德分享了一个有助于更好地理解这个主题的类比："如果有助于理解，包规范就像接口，而主体就像单例实例，有点像。在某种程度上，就像这样：" [https://twitter.com/lukaseder/status/1443855980693962755](https://twitter.com/lukaseder/status/1443855980693962755)。
- en: 'Packages sustain modularity, facilitate clear design, and increase code maintainability
    by hiding the implementation details in the package body. Moreover, packages are
    loaded into memory as a whole at the first invocation of a function/procedure
    so any subsequent invocations of functions/procedures from this package require
    no disk I/O. While more information on using Oracle packages is available in the
    official documentation, let''s have an example:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 包通过隐藏包体内的实现细节来维持模块化，促进清晰的设计，并提高代码的可维护性。此外，包在第一次调用函数/过程时作为一个整体加载到内存中，因此从该包中后续调用函数/过程不需要磁盘
    I/O。虽然有关使用 Oracle 包的更多信息可在官方文档中找到，但让我们举一个例子：
- en: '[PRE298]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: 'A spicy tip from Lukas Eder: *"The ''*`/`*'' is a SQL*Plus ''spool'' token
    (also supported by SQL Developer), and not an actual PL/SQL syntax element. For
    example, it doesn''t work in DBeaver.*'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 卢卡斯·埃德（Lukas Eder）的一个辛辣的小贴士：*"`/*` 是 SQL*Plus 的 'spool' 令牌（也由 SQL Developer
    支持），而不是实际的 PL/SQL 语法元素。例如，它在 DBeaver 中不起作用。)*
- en: 'And, another tip regarding quoted identifiers: *Might be a good reminder that,
    to be better interoperable with non-jOOQ code, perhaps not using quoted identifiers
    is better. It will be a PITA if all callers will have to always quote that identifier
    if they''re not using jOOQ :)"*'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，关于引号标识符的一个小贴士：*可能是一个很好的提醒，为了与非 jOOQ 代码更好地互操作，可能不使用引号标识符会更好。如果所有调用者都必须始终引用该标识符，而不是使用
    jOOQ，那将会很麻烦：)*
- en: 'So, here we have a package named `DEPARTMENT_PKG` containing a user-defined
    type named `BGT` and two functions, `GET_BGT()` and `GET_MAX_CASH()`. At the source
    code generation stage, jOOQ will reflect this package and its content via Java
    sub-packages as follows:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个名为 `DEPARTMENT_PKG` 的包，其中包含一个名为 `BGT` 的用户定义类型和两个函数，`GET_BGT()` 和 `GET_MAX_CASH()`。在源代码生成阶段，jOOQ
    将通过以下 Java 子包反映此包及其内容：
- en: '`jooq.generated.packages` – Contains the `DepartmentPkg` class representing
    the package and exposing the `DEPARTMENT_PKG` static that can be used to call
    the functions as `DEPARTMENT_PKG.getMaxCash()` and `DEPARTMENT_PKG.getBgt()` and
    get the result as a `Field`.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jooq.generated.packages` – 包含代表包并公开 `DEPARTMENT_PKG` 静态的 `DepartmentPkg` 类，可以用来调用函数，如
    `DEPARTMENT_PKG.getMaxCash()` 和 `DEPARTMENT_PKG.getBgt()`，并将结果作为 `Field` 获取。'
- en: '`jooq.generated.packages.department_pkg` – Contains the `GetBgt` and `GetMaxCash`
    classes representing the two functions from the package. Moreover, it contains
    the `UDTs` class containing the static `BGT` for `CLASSICMODELS.DEPARTMENT_PKG.BGT`
    (`jooq.generated.packages.department_pkg.udt.Bgt.BGT`).'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jooq.generated.packages.department_pkg` – 包含代表包中两个函数的 `GetBgt` 和 `GetMaxCash`
    类。此外，它还包含一个 `UDTs` 类，其中包含静态 `BGT`，用于 `CLASSICMODELS.DEPARTMENT_PKG.BGT` (`jooq.generated.packages.department_pkg.udt.Bgt.BGT`)。'
- en: '`jooq.generated.packages.department_pkg.udt` – Contains the class `Bgt` mapping
    the `BGT` UDT type as an extension of `UDTImpl`.'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jooq.generated.packages.department_pkg.udt` – 包含将 `BGT` UDT 类型映射为 `UDTImpl`
    扩展的 `Bgt` 类。'
- en: '`jooq.generated.packages.department_pkg.udt.records` – Contains the `BgtRecord`
    class representing the `BGT` UDT type as an extension of `UDTRecordImpl`.'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jooq.generated.packages.department_pkg.udt.records` – 包含代表 `BGT` UDT 类型作为
    `UDTRecordImpl` 扩展的 `BgtRecord` 类。'
- en: 'Calling these two functions (`GET_BGT()` and `GET_MAX_CASH()`) can be done
    by instantiating the `GetMaxCash` class, respectively the `GetBgt` class and call
    `execute()` as follows:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这两个函数（`GET_BGT()` 和 `GET_MAX_CASH()`）可以通过实例化 `GetMaxCash` 类，分别 `GetBgt` 类，并按如下方式调用
    `execute()`：
- en: '[PRE310]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: 'We can also compact these examples via the statics `DepartmentPkg.getBgt()`
    and `DepartmentPkg.getMaxCash()` as follows:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过静态方法 `DepartmentPkg.getBgt()` 和 `DepartmentPkg.getMaxCash()` 来压缩这些示例，如下所示：
- en: '[PRE317]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: 'Calling these functions from queries is also possible. For instance, here are
    two trivial examples of calling them in `SELECT`:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 从查询中调用这些函数也是可能的。例如，以下是在 `SELECT` 中调用它们的两个简单示例：
- en: '[PRE319]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: 'Here is another example that uses both functions in the same query:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个示例，它使用了同一个查询中的两个函数：
- en: '[PRE324]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: Check out these examples next to a few others not presented here in *Package*
    for Oracle.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下示例，这些示例位于 *Package* for Oracle 的旁边，而这里没有展示的其他几个示例。
- en: Oracle's member function/procedure
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Oracle 的成员函数/过程
- en: Mainly, an Oracle PL/SQL object type contains attributes and members (or methods).
    Attributes or fields have data types and they are used to store data, while members
    are subprograms (functions/procedures) that are defined in the object type and
    manipulate the attributes for implementing certain functionalities. In this way,
    Oracle UDTs are a fully-fledged attempt at implementing an Object Relational Database
    Management System (ORDBMS). PostgreSQL didn't go quite as far as Oracle.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 主要来说，Oracle PL/SQL 对象类型包含属性和成员（或方法）。属性或字段具有数据类型，它们用于存储数据，而成员是定义在对象类型中的子程序（函数/过程），用于操作属性以实现某些功能。这样，Oracle
    UDTs 是实现对象关系数据库管理系统（ORDBMS）的全面尝试。PostgreSQL 并没有像 Oracle 那样走得更远。
- en: 'If you are not an Oracle fan, then the following syntax should shed some light
    on this topic:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是 Oracle 的粉丝，那么以下语法应该能对这个主题有所帮助：
- en: '![Figure 15.3 – Syntax of Oracle members'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 15.3 – Oracle 成员语法](img/Figure_15.3.jpg)'
- en: '](img/Figure_15.3.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 15.3 – Oracle 成员语法](img/Figure_15.3.jpg)'
- en: Figure 15.3 – Syntax of Oracle members
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.3 – Oracle 成员语法
- en: 'Based on this syntax, let''s have an example. Our `MANAGER` table has a field
    named `MANAGER_EVALUATION` that is of type `EVALUATION_CRITERIA` (in jOOQ, of
    type `TableField<ManagerRecord, EvaluationCriteriaRecord>`) defined as follows:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个语法，让我们举一个例子。我们的 `MANAGER` 表有一个名为 `MANAGER_EVALUATION` 的字段，其类型为 `EVALUATION_CRITERIA`（在
    jOOQ 中为 `TableField<ManagerRecord, EvaluationCriteriaRecord>` 类型），定义如下：
- en: '[PRE334]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: Here, we have an object type containing four attributes (`communication_ability`,
    `ethics`, `performance`, and `employee_input`), two member functions (`IMPROVE()`
    and `SCORE()`), and no member procedures.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个包含四个属性（`communication_ability`、`ethics`、`performance` 和 `employee_input`）、两个成员函数（`IMPROVE()`
    和 `SCORE()`）以及没有成员过程的对象类型。
- en: 'The jOOQ Code Generator produces the following artifacts:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 代码生成器生成以下工件：
- en: '`jooq.generated.udt` – In this package, we have the UDT type named `EvaluationCriteria`,
    representing an extension of jOOQ''s `UDTImpl<EvaluationCriteriaRecord>`. It contains
    the statics `EVALUATION_CRITERIA`, `COMMUNICATION_ABILITY`, `ETHICS`, `PERFORMANCE`,
    and `EMPLOYEE_INPUT` to refer to these UDT attributes and several flavors of the
    `improve()` and `score()` member functions returning the plain result or wrapped
    in a `Field`.'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jooq.generated.udt` – 在这个包中，我们有一个名为 `EvaluationCriteria` 的 UDT 类型，代表 jOOQ
    的 `UDTImpl<EvaluationCriteriaRecord>` 的扩展。它包含静态 `EVALUATION_CRITERIA`、`COMMUNICATION_ABILITY`、`ETHICS`、`PERFORMANCE`
    和 `EMPLOYEE_INPUT`，用于引用这些 UDT 属性，以及几种 `improve()` 和 `score()` 成员函数的变体，这些函数返回纯结果或包装在
    `Field` 中。'
- en: '`jooq.generated.udt.records` – Contains the `EvaluationCriteriaRecord` representing
    the UDT record as an extension of the jOOQ''s `UDTRecordImpl<EvaluationCriteriaRecord>`.
    The `EvaluationCriteriaRecord` contains getters/setters for the object type attributes
    and contains the methods `improve()` and `score()` as well. These methods encapsulate
    the code needed to call the actual `improve()` and `score()` member functions.'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jooq.generated.udt.records` – 包含代表 UDT 记录作为 jOOQ 的 `UDTRecordImpl<EvaluationCriteriaRecord>`
    扩展的 `EvaluationCriteriaRecord`。`EvaluationCriteriaRecord` 包含对象类型属性的获取器/设置器，并包含
    `improve()` 和 `score()` 方法。这些方法封装了调用实际的 `improve()` 和 `score()` 成员函数所需的代码。'
- en: '`jooq.generated.udt.evaluation_criteria` – Contains the `Improve` and `Score`
    classes (routines), so a class for each member function. Both `EvaluationCriteria`
    and `EvaluationCriteriaRecord` use these classes internally.'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jooq.generated.udt.evaluation_criteria` – 包含 `Improve` 和 `Score` 类（例程），因此每个成员函数都有一个类。`EvaluationCriteria`
    和 `EvaluationCriteriaRecord` 都在内部使用这些类。'
- en: 'So, we can distinguish between calling the member functions starting from an
    empty record or from an existing record (for instance, a record fetched from the
    database). The conventional approach for starting from an empty record relies
    on `DSLContext.newRecord()`:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以区分从空记录或现有记录（例如，从数据库中检索的记录）开始调用成员函数。从空记录开始的传统方法依赖于 `DSLContext.newRecord()`：
- en: '[PRE346]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: The created record is already attached. Alternatively, we can instantiate `EvaluationCriteriaRecord`
    or use `EVALUATION_CRITERIA.newRecord()`, but the resulting record is not attached
    to a configuration (database), so you'll have to explicitly attach it by calling
    `attach()`.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的记录已经附加。或者，我们可以实例化 `EvaluationCriteriaRecord` 或使用 `EVALUATION_CRITERIA.newRecord()`，但生成的记录不会附加到配置（数据库）上，因此您必须显式调用
    `attach()` 来附加它。
- en: 'Next, we set the values of the attributes and call the member functions. Here,
    we call the `score()` method, which returns a `BigDecimal`:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置属性的值并调用成员函数。在这里，我们调用 `score()` 方法，它返回一个 `BigDecimal`：
- en: '[PRE348]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: 'On the other hand, the `improve()` methods increase the evaluation attributes
    by the given value and return a new `EvaluationCriteriaRecord`:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`improve()` 方法通过给定的值增加评估属性，并返回一个新的 `EvaluationCriteriaRecord`：
- en: '[PRE353]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: The `newEcr` record has `communication_ability` at *68* instead of *58*, `ethics`
    at *40* instead of *30*, and `performance` at *36* instead of *26*. Only `employee_input`
    remains unchanged.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '`newEcr` 记录的 `communication_ability` 为 *68* 而不是 *58*，`ethics` 为 *40* 而不是 *30*，`performance`
    为 *36* 而不是 *26*。只有 `employee_input` 保持不变。'
- en: 'We can use `ecr`/`newEcr` in queries as well. Here is an example of using `newEcr`
    that originates from an empty record next to `MANAGER.MANAGER_EVALUATION`, which
    is fetched from the database (remember that `MANAGER.MANAGER_EVALUATION` is a
    `TableField<ManagerRecord, EvaluationCriteriaRecord>`):'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在查询中使用 `ecr`/`newEcr`。以下是一个使用 `newEcr` 的示例，它从一个空的记录开始，紧邻 `MANAGER.MANAGER_EVALUATION`，该记录是从数据库中检索到的（请记住，`MANAGER.MANAGER_EVALUATION`
    是一个 `TableField<ManagerRecord, EvaluationCriteriaRecord>`）：
- en: '[PRE354]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: 'Here''s another example that combines the calls of `improve()` and `score()`:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个结合 `improve()` 和 `score()` 调用的示例：
- en: '[PRE359]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: Check out these examples next to others omitted here in *MemberFunction* for
    Oracle.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 检查这里与省略的 *MemberFunction* 中的其他示例。
- en: User-defined aggregate stored functions
  id: totrans-506
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户定义的聚合存储函数
- en: 'Oracle and SQL Server allow us to define aggregate stored functions (if you
    are not familiar with this topic, then please search these on Google: *Oracle
    User-Defined Aggregate Functions Interface* for Oracle and *SQL Server User-Defined
    Aggregate Functions* for SQL Server).'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 和 SQL Server 允许我们定义聚合存储函数（如果您不熟悉这个主题，请在 Google 上搜索：*Oracle 用户定义聚合函数接口*
    和 *SQL Server 用户定义聚合函数*）。
- en: 'Moreover, the code of such functions is quite big to be listed here so please
    check the bundled code. For Oracle, check the application *UserDefinedAggFunction*,
    which calls a user-defined aggregate function named `secondMax()` that finds the
    second maximum value:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些函数的代码相当长，无法在此列出，请检查捆绑的代码。对于 Oracle，请检查应用程序 *UserDefinedAggFunction*，它调用一个名为
    `secondMax()` 的用户定义聚合函数，该函数找到第二个最大值：
- en: '[PRE365]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: 'And for SQL Server, check the application also named *UserDefinedAggFunction*.
    Here, we call an aggregate stored function named `concatenate()` that simply concatenates
    the given strings:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 SQL Server，请检查也命名为 *UserDefinedAggFunction* 的应用程序。在这里，我们调用一个名为 `concatenate()`
    的聚合存储函数，该函数简单地连接给定的字符串：
- en: '[PRE372]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: In order to work, please pay attention that you need to place the `StringUtilities.dll`
    DLL file (available in the bundled code) in the path specified in the function
    code.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 为了工作，请注意您需要将 `StringUtilities.dll` DLL 文件（在捆绑的代码中可用）放置在函数代码中指定的路径上。
- en: Stored procedures
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储过程
- en: jOOQ allows you to call stored procedures via the same `Routines` API. Next,
    let's see several examples of calling different kinds of stored procedures.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 允许您通过相同的 `Routines` API 调用存储过程。接下来，让我们看看调用不同类型存储过程的几个示例。
- en: Stored procedures and output parameters
  id: totrans-524
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储过程和输出参数
- en: 'For instance, let''s consider the following stored procedure expressed in Oracle
    and having an `OUT` parameter:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑以下用 Oracle 表达的存储过程，它有一个 `OUT` 参数：
- en: '[PRE376]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: 'jOOQ generates the Java version of this stored procedure as a class named `GetAvgPriceByProductLine`
    in the `jooq.generated.routines` package. The methods of this class allow us to
    prepare the parameters (each input parameter has associated a setter, while each
    output parameter has associated a getter) and call our stored procedure as follows:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ将此存储过程的Java版本生成为一个名为`GetAvgPriceByProductLine`的类，位于`jooq.generated.routines`包中。这个类的各种方法允许我们准备参数（每个输入参数都有一个setter，每个输出参数都有一个getter），并按如下方式调用我们的存储过程：
- en: '[PRE385]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: 'We can express this more compactly via the generated `jooq.generated.Routines.getAvgPriceByProductLine()`
    static as follows:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过生成的`jooq.generated.Routines.getAvgPriceByProductLine()`静态方法更简洁地表达如下：
- en: '[PRE389]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: 'Calling a stored procedure in a jOOQ query can be done via the `getAvgPriceByProductLine(Configuration
    configuration, String pl)` flavor as in the following example:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`getAvgPriceByProductLine(Configuration configuration, String pl)`风味在jOOQ查询中调用存储过程，如下例所示：
- en: '[PRE391]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: 'jOOQ first renders the call of the stored procedure and fetches the `OUT` parameter
    value:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ首先渲染存储过程的调用并获取`OUT`参数的值：
- en: '[PRE399]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: 'Next, the fetched value (*64*, in this example) is used to render the `SELECT`:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，获取的值（在本例中为*64*）用于渲染`SELECT`：
- en: '[PRE401]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: Next, let's call a stored procedure without output parameters that fetches a
    single result set.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们调用一个不带输出参数的存储过程，该存储过程通过`SELECT`语句获取单个结果集。
- en: Stored procedures fetching a single result set
  id: totrans-564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取单个结果集的存储过程
- en: 'Here is a MySQL example of a stored procedure that doesn''t contain output
    parameters and fetches a single result set via `SELECT`:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个MySQL示例，展示了不包含输出参数的存储过程，通过`SELECT`语句获取单个结果集：
- en: '[PRE408]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: 'Calling this stored procedure from jOOQ can be done via the generated `GetProduct`
    class:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 通过生成的`GetProduct`类从jOOQ调用此存储过程：
- en: '[PRE414]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: The result is obtained via `gp.getResults()`. Since there is a single result
    (the result set produced by the `SELECT`), we have to call `get(0)`. If there
    were two results involved (for instance, if we had two `SELECT` statements in
    the stored procedure), then we would call `get(0)` to get the first result and
    `get(1)` to get the second result. Or, in the case of even more results, simply
    loop the results. Notice that, in the case of stored procedures, the `getReturnValue()`
    method returns `void` since stored procedures don't return results as a stored
    function (they don't contain a `RETURN` statement). In fact, SQL Server's procedures
    can return an error code, which is an `int`. You can see that in SQL Server generated
    code for procedures.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 结果通过`gp.getResults()`获得。由于只有一个结果（由`SELECT`产生的结果集），我们必须调用`get(0)`。如果有两个结果（例如，如果存储过程中有两个`SELECT`语句），那么我们将调用`get(0)`以获取第一个结果，调用`get(1)`以获取第二个结果。或者，在更多结果的情况下，简单地循环结果。请注意，在存储过程中，`getReturnValue()`方法返回`void`，因为存储过程不作为存储函数返回结果（它们不包含`RETURN`语句）。实际上，SQL
    Server的存储过程可以返回一个错误代码，这是一个`int`。您可以在为存储过程生成的SQL Server代码中看到这一点。
- en: 'Calling the previous stored procedure via `Routines.getProduct()` returns `void`
    as well:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`Routines.getProduct()`调用之前的存储过程也返回`void`：
- en: '[PRE418]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: 'The results obtained via `getResults()` are of type `Result<Record>`. This
    can be easily transformed into a regular `Table` as follows:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`getResults()`获得的结果类型为`Result<Record>`。可以很容易地将其转换为常规的`Table`，如下所示：
- en: '[PRE419]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: Next, let's take the `get_product()` stored procedure and let's express it in
    Oracle by adding an `OUT` parameter of type `SYS_REFCURSOR`.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将`get_product()`存储过程用Oracle表达，并添加一个类型为`SYS_REFCURSOR`的`OUT`参数。
- en: Stored procedures with a single cursor
  id: totrans-585
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有一个游标的存储过程
- en: 'The following stored procedure fetches the same result set as the previous
    `get_product()`, but it returns it via a cursor:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 以下存储过程获取与之前的`get_product()`相同的结果集，但它通过游标返回：
- en: '[PRE422]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: 'This time, in `GetProduct`, jOOQ generates a getter for the `OUT` parameter
    named `getCursorResult()`, which allows us to fetch the result as a `Result<Record>`:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，在`GetProduct`中，jOOQ为名为`getCursorResult()`的`OUT`参数生成了一个getter，这使得我们能够以`Result<Record>`的形式获取结果：
- en: '[PRE429]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: 'Or you can fetch it more compactly via `Routines.getProduct(Configuration configuration,
    Number pid)`:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过`Routines.getProduct(Configuration configuration, Number pid)`更简洁地获取它：
- en: '[PRE433]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: 'As usual, this `Result<Record>` can be easily transformed into a regular `Table`:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，这个`Result<Record>`可以很容易地转换为常规的`Table`：
- en: '[PRE434]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '[PRE439]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: Next, you can use this `Table` in queries.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以在查询中使用这个`Table`。
- en: Stored procedures fetching multiple result sets
  id: totrans-610
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取多个结果集的存储过程
- en: 'Going further, let''s tackle a stored procedure returning multiple result sets.
    Here, it''s expressed in MySQL:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步，让我们处理一个返回多个结果集的存储过程。这里以MySQL为例：
- en: '[PRE441]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '[PRE444]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: 'As you already know, jOOQ generates the `GetEmpsInOffice` class and the result
    sets are available via `getResults()`:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，jOOQ 会生成 `GetEmpsInOffice` 类，并且结果集可以通过 `getResults()` 获取：
- en: '[PRE455]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '[PRE456]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '[PRE458]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: '[PRE459]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '`Routines.getEmpsInOffice(Configuration c, String inOfficeCode)` returns `void`.'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '`Routines.getEmpsInOffice(Configuration c, String inOfficeCode)` 返回 `void`。'
- en: Stored procedures with multiple cursors
  id: totrans-638
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多游标存储过程
- en: 'Next, let''s take the `get_emps_in_office()` stored procedure, and let''s express
    it in Oracle by adding two `OUT` parameters of type `SYS_REFCURSOR`:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们以 `get_emps_in_office()` 存储过程为例，并在 Oracle 中通过添加两个类型为 `SYS_REFCURSOR`
    的 `OUT` 参数来表示它：
- en: '[PRE465]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: '[PRE468]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: '[PRE469]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '[PRE474]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '[PRE480]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: 'This time, besides `getResults()`, which you are already familiar with, we
    can take advantage of the getters produced by jOOQ for the `OUT` parameters as
    follows:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，除了你已熟悉的 `getResults()` 之外，我们还可以利用 jOOQ 为 `OUT` 参数生成的获取器，如下所示：
- en: '[PRE481]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '[PRE482]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: '[PRE483]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: 'Also, relying on `Routines.getEmpsInOffice(Configuration c, String inOfficeCode)`
    is quite convenient:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，依赖 `Routines.getEmpsInOffice(Configuration c, String inOfficeCode)` 非常方便：
- en: '[PRE486]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '[PRE487]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: 'Next, you can rely on `results.getCursorInfo()` respectively on `results.getCursorEmployee()`
    or by looping the results as follows:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以分别依赖 `results.getCursorInfo()`、`results.getCursorEmployee()` 或通过以下方式循环结果：
- en: '[PRE488]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '[PRE490]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: 'Next, loop each `Result<Record>` as `for (Record record : result) …`.'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，循环每个 `Result<Record>` 作为 `for (Record record : result) …`。'
- en: 'Not sure it''s worth mentioning, but at least Oracle also knows typed `REF
    CURSORS` (instead of just `SYS_REFCURSOR`), which jOOQ will support as well soon
    (when you''re reading this book, these features should be available): [https://github.com/jOOQ/jOOQ/issues/11708](https://github.com/jOOQ/jOOQ/issues/11708).'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 不确定是否值得提及，但至少 Oracle 也知道有类型的 `REF CURSORS`（而不是仅仅 `SYS_REFCURSOR`），jOOQ 也将很快支持这些功能（当你阅读这本书时，这些功能应该已经可用）：[https://github.com/jOOQ/jOOQ/issues/11708](https://github.com/jOOQ/jOOQ/issues/11708)。
- en: Calling stored procedures via the CALL statement
  id: totrans-671
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 `CALL` 语句调用存储过程
- en: 'Finally, let''s tackle the API of calling a stored procedure via the `CALL`
    statement in an anonymous procedural block and via `CALL` directly. Consider the
    following stored procedure expressed in Oracle (the complete code is available
    in the bundled code):'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们解决通过匿名过程块中的 `CALL` 语句和直接 `CALL` 调用存储过程的 API。考虑以下用 Oracle 表达的存储过程（完整的代码可在捆绑的代码中找到）：
- en: '[PRE491]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '[PRE492]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: '[PRE493]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '[PRE494]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: '[PRE495]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: '[PRE496]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '[PRE497]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: 'Calling this stored procedure via the `CALL` statement in an anonymous procedural
    block can be done via `DSLContext.begin()` as follows:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在匿名过程块中通过 `DSLContext.begin()` 调用 `CALL` 语句来调用此存储过程可以这样做：
- en: '[PRE498]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '[PRE499]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: '[PRE500]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: 'Or, call it directly via `DSLContext.call()`:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，直接通过 `DSLContext.call()` 调用：
- en: '[PRE501]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: '[PRE502]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: You can practice all these examples in *CallProcedure*.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *CallProcedure* 中练习所有这些示例。
- en: jOOQ and creating stored functions/procedures
  id: totrans-689
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jOOQ 和创建存储函数/过程
- en: Starting with version 3.15, jOOQ began to add an API for creating stored functions,
    procedures, and triggers. Among others, we have support for `CREATE FUNCTION`,
    `CREATE OR REPLACE FUNCTION`, `CREATE PROCEDURE`, `CREATE OR REPLACE PROCEDURE`,
    `DROP FUNCTION`, and `DROP PROCEDURE`.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 3.15 开始，jOOQ 开始添加用于创建存储函数、过程和触发器的 API。其中包括对 `CREATE FUNCTION`、`CREATE OR
    REPLACE FUNCTION`、`CREATE PROCEDURE`、`CREATE OR REPLACE PROCEDURE`、`DROP FUNCTION`
    和 `DROP PROCEDURE` 的支持。
- en: Creating stored functions
  id: totrans-691
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建存储函数
- en: 'For instance, creating a scalar function for MySQL can be done as follows:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，创建 MySQL 的标量函数可以这样做：
- en: '[PRE504]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '[PRE505]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: '[PRE508]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: '[PRE509]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '[PRE510]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[PRE511]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: '[PRE512]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: '[PRE513]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: '[PRE514]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: 'Here, we create a scalar function having three input parameters created via
    the intuitive `Parameter` API by specifying their name and types. For MySQL, jOOQ
    renders the following code:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个具有三个输入参数的标量函数，这些参数通过直观的 `Parameter` API 创建，指定了它们的名称和类型。对于 MySQL，jOOQ
    生成以下代码：
- en: '[PRE515]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: '[PRE516]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: '[PRE517]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: '[PRE518]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: '[PRE519]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: '[PRE520]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: '[PRE521]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: '[PRE522]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: '[PRE523]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: Notice that in order to work, you should be aware of the following note.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了使其工作，你应该注意以下注意事项。
- en: Important Note
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: 'In MySQL, we can execute statement batches if we turn on the `allowMultiQueries`
    flag, which defaults to `false`; otherwise, we get an error. The previously generated
    SQL chains two statements, therefore this flag needs to be turned on – we can
    do it via the JDBC URL as `jdbc:mysql:…/classicmodels?allowMultiQueries=true`.
    Alternatively, in this particular case, we can rely on the `dropFunctionIfExists()`,`createFunction()`
    combo instead of `createOrReplaceFunction()`. I strongly advise you to take a
    couple of minutes to read this article by Lukas Eder, which explains in detail
    the implication of this flag in the jOOQ context: [https://blog.jooq.org/mysqls-allowmultiqueries-flag-with-jdbc-and-jooq/](https://blog.jooq.org/mysqls-allowmultiqueries-flag-with-jdbc-and-jooq/).'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MySQL 中，如果我们打开 `allowMultiQueries` 标志（默认为 `false`），就可以执行语句批处理；否则，我们会得到一个错误。之前生成的
    SQL 链接了两个语句，因此需要打开此标志——我们可以通过 JDBC URL 作为 `jdbc:mysql:…/classicmodels?allowMultiQueries=true`
    来实现。或者，在这种情况下，我们可以依靠 `dropFunctionIfExists()` 和 `createFunction()` 组合而不是 `createOrReplaceFunction()`。我强烈建议你花几分钟时间阅读
    Lukas Eder 的这篇文章，它详细解释了此标志在 jOOQ 上下文中的含义：[https://blog.jooq.org/mysqls-allowmultiqueries-flag-with-jdbc-and-jooq/](https://blog.jooq.org/mysqls-allowmultiqueries-flag-with-jdbc-and-jooq/)。
- en: 'You already know how to call this function from jOOQ via the generated code.
    This means that you have to run this code to create the stored function in the
    database, and afterward, run the jOOQ Code Generator to obtain the expected jOOQ
    artifacts. On the other hand, you can call it via plain SQL via the DSL''s `function()`
    as in this example:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道如何通过生成的代码从 jOOQ 调用此函数。这意味着你必须运行此代码来在数据库中创建存储函数，然后运行 jOOQ 代码生成器以获取预期的 jOOQ
    元数据。另一方面，你可以通过 DSL 的 `function()` 以普通 SQL 的方式调用它，如下例所示：
- en: '[PRE524]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: '[PRE525]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: '[PRE526]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: You can practice this example in *CreateFunction*.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *CreateFunction* 中练习这个示例。
- en: How about creating the following PostgreSQL function having output parameters?
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 关于创建以下具有输出参数的 PostgreSQL 函数呢？
- en: '[PRE527]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: '[PRE528]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: '[PRE529]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: '[PRE530]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: '[PRE531]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: '[PRE532]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: 'From jOOQ, this function can be created like this:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 从 jOOQ，此函数可以创建如下：
- en: '[PRE533]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: '[PRE534]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: '[PRE535]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: '[PRE536]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: '[PRE537]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: '[PRE538]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: '[PRE539]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: 'Calling this function can be done via plain SQL as in this example:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过如下示例中的普通 SQL 调用此函数：
- en: '[PRE540]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: '[PRE541]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: '[PRE542]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: You can practice this example next to another one using `OUT` parameters in
    *CreateFunction* for PostgreSQL. For more examples that allow you to explore this
    API in detail, please consider the bundled code and the jOOQ manual.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *CreateFunction* for PostgreSQL 中练习这个示例旁边另一个使用 `OUT` 参数的示例。为了更详细地探索此 API
    的更多示例，请考虑捆绑的代码和 jOOQ 手册。
- en: Creating stored procedures
  id: totrans-742
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建存储过程
- en: 'Let''s begin with a stored procedure expressed in the SQL Server dialect:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从用 SQL Server 方言表示的存储过程开始：
- en: '[PRE543]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: '[PRE544]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: '[PRE545]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: '[PRE546]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: '[PRE547]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: '[PRE548]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: '[PRE549]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: '[PRE550]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: '[PRE551]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: 'This stored procedure, which has two input parameters and updates the `PRODUCT.MSRP`
    field, can be created through the jOOQ API as follows:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有两个输入参数并更新 `PRODUCT.MSRP` 字段的存储过程可以通过 jOOQ API 如下创建：
- en: '[PRE552]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: '[PRE553]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: '[PRE554]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: '[PRE555]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: '[PRE556]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: '[PRE557]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: '[PRE558]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: '[PRE559]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: 'You already know how to call this procedure from jOOQ via the generated code,
    so this time, let''s call it via the `CALL` statement:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道如何通过生成的代码从 jOOQ 调用此过程，所以这次，让我们通过 `CALL` 语句来调用它：
- en: '[PRE560]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: '[PRE561]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: '[PRE562]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: '[PRE563]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: '[PRE564]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: '[PRE565]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: '[PRE566]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: '[PRE567]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: The returned result represents the number of rows affected by this `UPDATE`.
    This example is available in *CreateProcedure* for SQL Server and PostgreSQL.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的结果表示此 `UPDATE` 影响的行数。此示例在 *CreateProcedure* for SQL Server 和 PostgreSQL 中可用。
- en: 'Next, let''s pick up an example expressed in Oracle dialect:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们选择一个用 Oracle 方言表示的示例：
- en: '[PRE568]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: '[PRE569]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: '[PRE570]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: '[PRE571]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: '[PRE572]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: '[PRE573]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: '[PRE574]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: '[PRE575]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: 'This time, the jOOQ code for creating this procedure is as follows:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，创建此过程的 jOOQ 代码如下：
- en: '[PRE576]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: '[PRE577]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: '[PRE578]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: '[PRE579]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: '[PRE580]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: '[PRE581]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: '[PRE582]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: '[PRE583]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: '[PRE584]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: Since you are already familiar with this stored procedure from the previous
    section, *Stored procedures and output parameters*, you should have no problem
    calling it. The example is available in *CreateProcedure* for Oracle.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你已经从上一节“存储过程和输出参数”熟悉了这个存储过程，因此调用它应该没有问题。示例在 *CreateProcedure* for Oracle 中可用。
- en: 'Finally, let''s tackle a MySQL stored procedure that fetches a result set via
    `SELECT`:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们解决一个通过 `SELECT` 获取结果集的 MySQL 存储过程：
- en: '[PRE585]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: '[PRE586]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: '[PRE587]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: '[PRE588]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: '[PRE589]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: '[PRE590]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: '[PRE591]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: '[PRE592]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: 'The jOOQ code that creates the stored procedure is as follows:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 创建存储过程的 jOOQ 代码如下：
- en: '[PRE593]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: '[PRE594]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: '[PRE595]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: '[PRE596]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: '[PRE597]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: '[PRE598]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: '[PRE599]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: In order for this code to work, we need to turn on the `allowMultiQueries` flag
    as explained in the previous section, *Creating stored functions*.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此代码正常工作，我们需要打开 `allowMultiQueries` 标志，正如上一节“创建存储函数”中所述。
- en: You can find this example next to another one that fetches two result sets in
    the application named *CreateProcedure* for MySQL.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在名为 *CreateProcedure* for MySQL 的应用程序中找到这个示例旁边另一个获取两个结果集的示例。
- en: Summary
  id: totrans-811
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you've learned how to call and create some typical stored functions
    and procedures. Since these are powerful SQL tools, jOOQ strives to provide a
    comprehensive API to cover the tons of possibilities to express these artifacts
    in different dialects. Most probably, by the time you read this book, jOOQ will
    have already enriched this API even further and more examples will be available
    in the bundled code.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学会了如何调用和创建一些典型的存储函数和过程。由于这些是强大的SQL工具，jOOQ致力于提供一个全面的API，以涵盖在不同方言中表达这些工具的各种可能性。很可能会在你阅读这本书的时候，jOOQ已经进一步丰富了这一API，并且捆绑代码中将提供更多示例。
- en: In the next chapter, we tackle aliases and SQL templating.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨别名和SQL模板。
