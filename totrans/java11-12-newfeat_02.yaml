- en: Type Inference
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断
- en: The ability to use type inference with local variables (`var`) is one of the
    star features of Java 10\. It reduces the verbosity of the language without compromising
    Java's dependable static binding and type safety. The compiler infers the type
    by using the information available in the code, and adds it to the bytecode that
    it generates.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 能够使用局部变量（`var`）进行类型推断是Java 10的明星特性之一。它减少了语言的冗长性，同时没有牺牲Java的可靠静态绑定和类型安全。编译器通过使用代码中可用的信息来推断类型，并将其添加到它生成的字节码中。
- en: Every new concept has its own set of benefits, limitations, and complexities.
    Using type inference with `var` is no exception. As you work through this chapter,
    using `var` will enthrall and frustrate you, but you will emerge triumphantly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新概念都有自己的优点、局限性和复杂性。使用`var`进行类型推断也不例外。当你通过这一章工作时，使用`var`会既让你着迷又让你沮丧，但最终你会胜利地出现。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is type inference?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是类型推断？
- en: Type inference with `var`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`var`进行类型推断
- en: Dos and don'ts of working with `var`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`var`一起工作的注意事项和禁忌
- en: Type inference versus dynamic binding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型推断与动态绑定
- en: What is type inference?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是类型推断？
- en: 'Imagine solving a riddle, such as the one shown in the following image, with
    multiple constraints in the form of hints. You resolve the constraints to derive
    the answer. You can compare type inference to generating constraints and then
    resolving them, in order to determine the data types in a programming language.
    Type inference is the capability of the compiler to determine the type of the
    data, by using the information that is already available in the code—literal values,
    method invocations, and their declarations. For a developer, type inference reduces
    verbosity, as indicated by the following diagram:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，用以下图像中显示的多个以提示形式存在的约束条件来解决一个谜题。你通过解决约束条件来得出答案。你可以将类型推断与生成约束条件然后解决它们，以确定编程语言中的数据类型进行比较。类型推断是编译器通过使用代码中已存在的信息（如字面值、方法调用及其声明）来确定数据类型的能力。对于开发者来说，类型推断减少了冗长性，如下面的图所示：
- en: '![](img/4af82659-f9ce-473f-8cbe-c161f66fc7c3.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4af82659-f9ce-473f-8cbe-c161f66fc7c3.png)'
- en: For your reference, the answer to the preceding riddle is 87 (just turn the
    image upside down, and you'll find the numbers in a sequence).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了参考，前面谜题的答案是87（只需将图像颠倒过来，你就能找到数字的顺序）。
- en: Type inference is not new to Java. It has been taken to the next level with
    the introduction of `var` (with local variables) in Java 10.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断对Java来说并不新鲜。随着Java 10中引入`var`（局部变量）的概念，它被提升到了一个新的水平。
- en: Let's dive into the topic by looking at some examples of `var`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看一些`var`的示例来深入了解这个主题。
- en: Type inference with var
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`var`进行类型推断
- en: 'The following lines of code show how local variables (and all other variables)
    were defined prior to Java 10:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行显示了在Java 10之前如何定义局部变量（以及所有其他变量）：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Starting with Java 10, by using `var`, you can drop the mandatory explicit
    type in the declaration of local variables, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java 10开始，通过使用`var`，你可以在局部变量的声明中省略强制显式类型，如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Does it look like the preceding code doesn''t offer a lot of benefits? Imagine
    you could take the following code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码看起来没有提供很多好处吗？想象一下，你可以用以下代码替换它：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And replace it with this code, instead:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 并用以下代码替换它：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By replacing `HashMap<Integer, String>` with `var`, the preceding line of code
    is much shorter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`HashMap<Integer, String>`替换为`var`，前面的代码行变得更短了。
- en: When you move away from explicitly stating the data type of the variables, the
    compiler takes over to determine, or infer, the variable type. Type inference
    is the compiler's ability to evaluate the information that is already present
    in the code, like the literal values, operations, and method invocations or their
    declarations, to determine the variable type. It follows a set of rules to infer
    the variable type. As a developer, when you choose type inference with `var`,
    you should be aware of the compiler's inference algorithm, so that you don't get
    unexpected results.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不再明确声明变量的数据类型时，编译器就会接管以确定或推断变量类型。类型推断是编译器评估代码中已存在的信息（如字面值、操作和方法调用或它们的声明）以确定变量类型的能力。它遵循一系列规则来推断变量类型。作为开发者，当你选择使用`var`进行类型推断时，你应该了解编译器的推断算法，以免得到意外结果。
- en: With every new feature, you should adhere to a few rules and restrictions and
    try to follow the best practices to benefit from that feature. Let's start with
    the compulsory initialization of the variables that are defined using `var`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每当有新的功能时，您都应该遵守一些规则和限制，并尝试遵循最佳实践以充分利用该功能。让我们从使用 `var` 定义的变量强制初始化开始。
- en: Type inference with `var` is not dynamic typing; Java is still a strong, static-typed
    language. The usage of `var` makes your code leaner; you can drop the type of
    the local variable from its definition.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`var` 的类型推断不是动态类型；Java 仍然是一种强静态类型语言。使用 `var` 可以使您的代码更简洁；您可以从局部变量的定义中省略其类型。'
- en: Compulsory non-null initialization
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制非空初始化
- en: 'A local variable defined with `var` must be initialized with its declaration,
    or the code won''t compile. The compiler can''t infer the type of an uninitialized
    variable or a variable that is assigned a `null` value. The following code won''t
    compile:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `var` 定义的局部变量必须在声明时进行初始化，否则代码将无法编译。编译器无法推断未初始化变量或被赋予 `null` 值的变量的类型。以下代码将无法编译：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following image illustrates what would happen if the uninitialized variable
    `age` went to seek entrance to the Mr. Java compiler place. The compiler won''t
    let `age` in:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像说明了如果未初始化的变量 `age` 去寻求进入 Mr. Java 编译器的位置会发生什么。编译器不会让 `age` 进入：
- en: '![](img/0c52345b-2379-4400-8a0a-a2aea3e251bb.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c52345b-2379-4400-8a0a-a2aea3e251bb.png)'
- en: Variable definition using `var` must always be accompanied by its initialization,
    or the code will fail to compile.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `var` 定义变量时，必须始终伴随其初始化，否则代码将无法编译。
- en: Local variables
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 局部变量
- en: The usage of `var` is limited to local variables. These variables are used to
    store intermediate values and have the shortest life span, as compared to the
    instance and static variables. The local variables are defined within a method,
    constructor, or initializer block (both instance and static). Within a method
    or initializer, they can be defined within constructs, such as `if..else` loops,
    `switch` statements, and the `try-with-resources` construct.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`var` 的使用仅限于局部变量。这些变量用于存储中间值，与实例和静态变量相比，生命周期最短。局部变量在方法、构造函数或初始化块（实例和静态）内定义。在方法或初始化块内，它们可以在诸如
    `if..else` 循环、`switch` 语句和 `try-with-resources` 构造等结构中定义。'
- en: 'The following is an example of  `Person` class, showing possible usage of `var`
    to define local variables in initializer blocks, methods (including constructors),
    loops, as a local variable within `switch` branches, or a `try with resources`
    statement:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 `Person` 类的示例，展示了在初始化块、方法（包括构造函数）、循环、`switch` 分支内的局部变量或 `try with resources`
    语句中使用 `var` 定义局部变量的可能用法：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can notice from the preceding code, a local variable can be declared
    using `var` at varied places in a class. Do you remember most of them? If not,
    let's make it simple for you.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码中可以看出，局部变量可以在类的不同位置使用 `var` 进行声明。您还记得大多数吗？如果不记得，让我们为您简化一下。
- en: 'Let''s use an application to *find* all possible places where you could define
    local variables using `var` and mark it pictorially:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个应用程序来 *查找* 所有可以定义使用 `var` 的局部变量的可能位置，并以图示方式标记：
- en: '![](img/6a261681-49a1-4214-8854-6f01e24711bd.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a261681-49a1-4214-8854-6f01e24711bd.png)'
- en: This chapter includes a couple of code-check exercises for you to try. The exercises
    use the names of two hypothetical programmers—Pavni and Aarav.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含一些代码检查练习供您尝试。这些练习使用了两位假设程序员的名称——Pavni 和 Aarav。
- en: Code check – part 1
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码检查 – 第1部分
- en: 'One of our programmers, Aarav, refactored some code by his team member, Pavni.
    The code no longer provides `char` and the corresponding ASCII numbers of the
    values stored by the `char` array. Can you help Aarav? The following is the code
    to use:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序员 Aarav 通过他的团队成员 Pavni 重构了一些代码。代码不再提供 `char` 数组存储的值的 `char` 和相应的 ASCII
    数字。你能帮助 Aarav 吗？以下是要使用的代码：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The answer to the code check: The `var` type can''t be used to specify the
    types of exceptions in the `catch` handler, `(var e)`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查的答案：`var` 类型不能用于指定 `catch` 处理程序中异常的类型，`(var e)`。
- en: Using var with primitive data types
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `var` 与原始数据类型
- en: 'Using `var` with primitive data types seems to be the simplest scenario, but
    appearances can be deceptive. Try to execute the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `var` 与原始数据类型似乎是最简单的情况，但外表可能具有欺骗性。尝试执行以下代码：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You might assume that an integer literal value (`9_009_998_992_887`, in this
    case) that doesn''t fit into the range of primitive `int` types will be inferred
    to be a `long` type. However, this doesn''t happen. Since the default type of
    an integer literal value is `int`, you''ll have to append the preceding value
    with the suffix `L` or `l`, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为一个不适用于原始`int`类型范围的整数字面量（例如`9_009_998_992_887`）会被推断为`long`类型。然而，事实并非如此。由于整数字面量的默认类型是`int`，你必须将前缀`L`或`l`附加到值的前面，如下所示：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Similarly, for an `int` literal value to be inferred as a `char` type, you
    must use an explicit cast, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，要使`int`字面量被推断为`char`类型，你必须使用显式转换，如下所示：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'What is the result when you divide `5` by `2`? Did you think it''s `2.5`? This
    isn''t how it (always) works in Java! When integer values are used as operands
    in the division, the result is not a decimal number, but an integer value. The
    fraction part is dropped, to get the result as an integer. Though this is normal,
    it might seem weird when you expect the compiler to infer the type of your variable.
    The following is an example of this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将`5`除以`2`时，结果是什么？你以为它是`2.5`吗？但这并不是Java中（总是）的工作方式！当整数用作除法的操作数时，结果是整数，而不是小数。小数部分被舍弃，以得到整数结果。虽然这是正常的，但当你期望编译器推断变量类型时，可能会觉得有点奇怪。以下是一个例子：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Though these cases aren''t specifically related to the `var` type, the developer''s
    assumption that the compiler will infer a specific type results in a mismatch.
    Here''s a quick diagram to help you remember this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些情况与`var`类型没有直接关系，但开发者认为编译器会推断特定类型的假设导致了不匹配。以下是一个快速图解，帮助你记住这一点：
- en: '![](img/047f3487-368c-4b58-8308-b0a3e7637726.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/047f3487-368c-4b58-8308-b0a3e7637726.png)'
- en: The default type of integer literals is `int`, and the default type of floating
    point numbers is `double`. Assigning `100` to a variable defined with `var` will
    infer its type as `int`, not `byte` or `short`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 整数字面量的默认类型是`int`，浮点数的默认类型是`double`。将`100`赋值给用`var`定义的变量时，其类型会被推断为`int`，而不是`byte`或`short`。
- en: 'In arithmetic operation, if either of the operands is `char`, `byte`, `short`,
    or `int`, the result is at least promoted to `int`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在算术运算中，如果任一操作数是`char`、`byte`、`short`或`int`，结果至少会被提升到`int`：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Similarly, for an arithmetic operation that includes at least one operand as
    a `long`, `float`, or `double` value, the result is promoted to the type `long`,
    `float`, or `double`, respectively:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于包含至少一个操作数为`long`、`float`或`double`值的算术运算，结果会被提升到`long`、`float`或`double`类型，分别：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The rules of the implicit widening of primitive variables play an important
    role in understanding how the Java compiler infers variables with primitive values.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 原始变量隐式扩展的规则在理解Java编译器如何推断原始值变量方面起着重要作用。
- en: Type inference with derived classes
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 派生类的类型推断
- en: In JDK 9 and other previous versions, you could define a variable of the base
    class and assign an instance of its derived class to it. The members that you
    could access using the variable were limited to the ones that were defined in
    the base class. This is no longer the case with `var`, since the type of the variable
    is inferred by using the specific type of the instance that is assigned to it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在JDK 9和其他早期版本中，你可以定义一个基类变量并将其赋值为其派生类的实例。你可以通过变量访问的成员仅限于在基类中定义的成员。但是，使用`var`的情况不再是这样，因为变量的类型是通过为其分配的实例的具体类型来推断的。
- en: 'Imagine a class  `Child` extends a class `Parent`. When you create a local
    variable and assign it an instance of the `Child` class, the type of the variable
    is inferred as `Child`. This looks simple. The following is an example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个类`Child`继承自类`Parent`。当你创建一个局部变量并将其赋值为`Child`类的实例时，变量的类型被推断为`Child`。这看起来很简单。以下是一个例子：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'What happens if you assign the value of the `obj` variable using a method that
    can return an instance of the `Child` class or `Parent` classes? Here''s the modified
    code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用可以返回`Child`类或`Parent`类实例的方法来赋值给`obj`变量，会发生什么？以下是修改后的代码：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, the type of the instance returned by the `getObject()` method
    can't be determined before the code execution. During compilation, the type of
    the `obj` variable is inferred as `Parent`, the return type of the `getObject()` method. Since
    the `Parent` class doesn't define `stand()`, the `main()` methods fail to compile.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`getObject()` 方法返回的实例类型在代码执行之前无法确定。在编译期间，`obj` 变量的类型被推断为 `Parent`，这是
    `getObject()` 方法的返回类型。由于 `Parent` 类没有定义 `stand()`，因此 `main()` 方法无法编译。
- en: The types of variables defined using `var` are inferred at compile time. If
    the return type of a method is used to assign a variable that is defined using
    `var`, its inferred type is the return type of the method, not the type of the
    instance returned during runtime.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `var` 定义的变量类型是在编译时推断的。如果使用 `var` 定义的方法的返回类型来分配变量，其推断类型是方法的返回类型，而不是在运行时返回的实例类型。
- en: Type inference with interfaces
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口的类型推断
- en: 'Let''s extend the content of the preceding section to the use of interfaces.
    Imagine that the `Child` class implements a `MarathonRunner` interface, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将上一节的内容扩展到接口的使用。想象一下，`Child` 类实现了 `MarathonRunner` 接口，如下所示：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s define an `obj` local variable, assigning it an instance of the `Child` class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个 `obj` 局部变量，将其赋值为 `Child` 类的实例：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If the same variable is initialized using a method whose return type is `MarathonRunner`,
    its inferred type is `MarathonRunner` (irrespective of the type of the instance
    returned by it):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用返回类型为 `MarathonRunner` 的方法初始化相同的变量，其推断类型为 `MarathonRunner`（无论它返回的实例类型如何）：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using var with arrays
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `var` 与数组
- en: 'Using `var` doesn''t imply just dropping the type of the local variable; what
    remains should enable the compiler to infer its type. Imagine a method that defines
    an array of the `char` type, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `var` 并不意味着只是丢弃局部变量的类型；剩下的应该能够使编译器推断其类型。想象一下一个定义 `char` 类型数组的函数，如下所示：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can''t replace the data type name, that is, `char`, in the preceding code
    with `var` and define it using any of the following code samples:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在上述代码中将数据类型名称，即 `char`，替换为 `var` 并使用以下任何一种代码示例来定义它：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here''s one of the ways to include relevant information, so that the compiler
    can infer the type:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种包含相关信息的方法之一，以便编译器可以推断类型：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It seems like the Java compiler is already struggling with this assumption
    from the programmers, as shown in the following image:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来 Java 编译器已经对程序员的这个假设感到困扰，如下面的图像所示：
- en: '![](img/c93bfaae-5ff6-45cf-b181-b12079a8a95e.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c93bfaae-5ff6-45cf-b181-b12079a8a95e.png)'
- en: You can't just drop the data types in order to use `var`. What remains should
    enable the compiler to infer the type of the value being assigned.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能仅仅为了使用 `var` 而丢弃数据类型。剩下的应该能够使编译器推断出所赋值的类型。
- en: Type inference with generics
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型的类型推断
- en: Generics were introduced in Java to promote type safety. It enabled developers
    to specify their intentions of using classes, interfaces, and collection classes
    with fixed types or a range of types. Violations of these intentions were enforced
    with compilation errors, rather than runtime exceptions, raising the compliance
    bar.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型被引入 Java 中是为了促进类型安全。它使开发者能够指定他们使用具有固定类型或一系列类型的类、接口和集合类的意图。违反这些意图将通过编译错误而不是运行时异常来强制执行，从而提高了合规性标准。
- en: 'For example, the following shows how you would define `ArrayList` to store
    `String` values (repeating `<String>` is optional, on the right-hand side of the
    assignment):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下展示了如何定义 `ArrayList` 来存储 `String` 值（在赋值右侧重复 `<String>` 是可选的）：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'However, replacing `List<String>` with `var` will put the type safety of the
    generics at stake:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将 `List<String>` 替换为 `var` 将会使泛型的类型安全受到威胁：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code allows for the addition of multiple data types to `names`,
    which is not the intention. With generics, the preferred approach is to make relevant
    information available to the compiler, so that it can infer its type correctly:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码允许向 `names` 添加多个数据类型，这并不是我们的意图。使用泛型时，更推荐的方法是向编译器提供相关信息，以便它可以正确推断其类型：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When using `var` with generics, ensure that you pass the relevant data types
    within the angular brackets on the right-hand side of the assignment, so that
    you don't lose type safety.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `var` 与泛型一起时，确保在赋值右侧的尖括号内传递相关数据类型，这样就不会丢失类型安全。
- en: Now, it's time for our next code check.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是我们进行下一项代码检查的时候了。
- en: Code check – part 2
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码检查 – 第二部分
- en: 'One of our programmers, Pavni, tried using `var` with generics and collection
    classes, but her code doesn''t seem to output the sorted collection of pens. Can
    you help? Check out the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一位程序员，Pavni，尝试在泛型和集合类中使用`var`，但她的代码似乎没有输出排序好的钢笔集合。你能帮忙吗？查看以下代码：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The answer to the code check: The issue here is trying to modify the immutable
    collection by using `Collections.sort()`. This is to emphasize that not all issues
    are related to the use of `var`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查的答案：这里的问题是试图通过使用`Collections.sort()`来修改不可变集合。这是为了强调并非所有问题都与`var`的使用相关。
- en: Passing inferred variables to a method
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将推断变量传递给方法
- en: Though the use of `var` is limited to the declaration of local variables, these
    variables (both primitive and reference) can be passed to methods as values. The
    inferred types and the types expected by the methods must match, to allow the
    code to compile.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`var`的使用仅限于局部变量的声明，但这些变量（包括原始类型和引用类型）可以作为值传递给方法。推断的类型和方法期望的类型必须匹配，以便代码能够编译。
- en: In the following example code, the `Child` class implements the `MarathonRunner`
    interface. The `start()` method in the `Marathon` class expects the `MarathonRunner`
    object (the instances of the class implementing this interface) as its method
    argument. The inferred type of the `aRunner` variable is `Child`. Since the `Child` class
    implements `MarathonRunner`, `aRunner` can be passed to the `start()` method, the
    inferred type of `aRunner` (`Child`) and the expected type of `start()` (`MarathonRunner`)
    match, allowing the code to compile.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例代码中，`Child`类实现了`MarathonRunner`接口。`Marathon`类中的`start()`方法期望`MarathonRunner`对象（实现此接口的类的实例）作为其方法参数。`aRunner`变量的推断类型是`Child`。由于`Child`类实现了`MarathonRunner`，`aRunner`可以被传递给`start()`方法，`aRunner`的推断类型（`Child`）和`start()`期望的类型（`MarathonRunner`）匹配，允许代码编译。
- en: 'The code is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As long as the inferred type of a variable matches the type of the method parameter,
    it can be passed to it as an argument.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 只要变量的推断类型与方法参数的类型相匹配，就可以将其作为参数传递给它。
- en: Reassigning values to inferred variables
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新分配推断变量的值
- en: 'As is applicable to all non-final variables, you can reassign value to inferred
    variables. Just ensure that the reassigned value matches its inferred type. In
    the following code, since the type of the `age` variable is inferred as `int`,
    you can''t assign a decimal value of `10.9` to it. Similarly, since the type of
    the `query` variable is inferred as `StringBuilder`. The type of a variable is
    inferred just once, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有非最终变量，你可以重新分配值给推断变量。只需确保重新分配的值与其推断类型匹配。在以下代码中，由于`age`变量的类型被推断为`int`，你不能将其分配为小数`10.9`。同样，由于`query`变量的类型被推断为`StringBuilder`。变量的类型只推断一次，如下所示：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The type of a local variable defined using `var` is inferred only once.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`var`定义的局部变量的类型只推断一次。
- en: Explicit casting with inferred variables
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推断变量的显式转换
- en: 'Imagine that a co-programmer assigned `29` to an inferred local variable (let''s
    say `age`), assuming that the compiler would infer the type of the variable `age` as `byte`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个合作程序员将`29`赋值给推断的局部变量（比如说`age`），假设编译器会推断变量`age`的类型为`byte`：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'However, the compiler would infer the type of the variable `age` as `int`,
    since the default type of an integer literal value is `int`. To fix the preceding
    assumption, you can either use the explicit data type or override the compiler''s
    default inference mechanism by using explicit casting, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编译器会推断变量`age`的类型为`int`，因为整型字面值的默认类型是`int`。为了修复前面的假设，你可以使用显式数据类型或通过使用显式转换覆盖编译器的默认推断机制，如下所示：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: By using explicit casting type inference, you can override the compiler's default
    type inference mechanism. This might be required to fix the assumptions in the
    existing code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用显式转换类型推断，你可以覆盖编译器的默认类型推断机制。这可能是为了修复现有代码中的假设。
- en: 'Similarly, you can use explicit casting with other primitive data types, like
    `char` and `float`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可以使用显式转换与其他原始数据类型，如`char`和`float`：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Without the explicit casting in the preceding examples, variables that are assigned
    integer literal values would be inferred as `int`, and decimal as `double`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中没有使用显式转换的情况下，被分配整型字面值的变量会被推断为`int`，而小数会被推断为`double`。
- en: 'The following example shows explicit casting with reference variables:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了引用变量的显式转换：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Use explicit casting with type inference to fix any existing assumptions. I
    wouldn't recommend using explicit casting to initialize inferred variables; it
    defeats the purpose of using `var`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型推断进行显式类型转换以修复任何现有的假设。我不建议使用显式类型转换来初始化推断变量；这违背了使用`var`的目的。
- en: Assigning null with explicit casting
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用显式类型转换赋值null
- en: 'Again, although it doesn''t make sense to use explicit casting with `null`
    to assign it to a `var` type, it is a valid code, shown as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，虽然使用显式类型转换将`null`赋值给`var`类型没有意义，但它是一种有效的代码，如下所示：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Though the preceding line of code is correct syntax-wise, it is a bad coding
    practice. Avoid it!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的代码在语法上是正确的，但它是一种不良的编码实践。请避免使用它！
- en: Type inference in previous versions of Java
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java先前版本中的类型推断
- en: Although `var` takes inference to a new level in Java 10, the concept of type
    inference existed in Java's previous versions. Let's look at some examples of
    type inference in the previous versions of Java.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`var`在Java 10中将推断提升到了一个新的水平，但在Java的先前版本中已经存在类型推断的概念。让我们看看Java先前版本中类型推断的一些例子。
- en: Type inference in Java 5
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 5中的类型推断
- en: Generics introduced a type system to enable the developers to abstract over
    types. It restricted a class, interface, or method to working with instances of
    specified types, providing compile type safety. Generics were defined to add compile
    type safety to the Collections framework. Generics enable programs to detect certain
    bugs during compilation, so they can't creep into the runtime code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型引入了一种类型系统，使开发者能够对类型进行抽象。它限制了一个类、接口或方法只能与指定类型的实例一起工作，提供了编译时的类型安全性。泛型被定义为向集合框架添加编译时的类型安全性。泛型使程序能够在编译期间检测某些错误，因此它们不能渗透到运行时代码中。
- en: 'Java used type inference for generic method type arguments in Java 5\. Consider
    the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Java 5中使用了类型推断来推断泛型方法类型参数。考虑以下代码：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Instead of the preceding code, you could use the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是前面的代码，你可以使用以下代码：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Type inference in Java 7
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 7中的类型推断
- en: 'Java 7 introduced type inference for constructor arguments with generics. Consider
    the following line of code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7引入了对泛型构造函数参数的类型推断。考虑以下代码行：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In Java 7, the preceding line of code could be replaced with the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7中，前面的代码行可以用以下代码替换：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding code shouldn''t be confused with the following, which is trying
    to mix the generics with the raw types:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码不应与以下代码混淆，后者试图将泛型与原始类型混合：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Java 7 also allowed type inference to invoke generic methods. For a generic
    method (say, `print()`) defined in a class (say, `MyClass`), the code would be
    as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7还允许对泛型方法进行类型推断。对于一个在类中定义的泛型方法（例如，`print()`），代码如下：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The preceding code can be called in either of the following ways (the third
    line of code uses type inference to infer the type of the argument passed to the
    `print()` method):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可以用以下两种方式之一调用（第三行代码使用类型推断来推断传递给`print()`方法的参数的类型）：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Type inference in Java 8
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 8中的类型推断
- en: 'Java, version 8, introduced functional programming, with lambda functions.
    The lambda expression can infer the type of its formal parameters. Consider the
    following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8引入了函数式编程，包括lambda函数。lambda表达式可以推断其形式参数的类型。考虑以下代码：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Instead of the preceding code, you could type the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是前面的代码，你可以输入以下代码：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Challenges
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战
- en: The use of `var` doesn't come without its share of challenges, for both the
    developers of the Java language and its users. Let's start with the reasons why
    `var` has limited usage.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`的使用并非没有其挑战，这既包括Java语言的开发者，也包括其用户。让我们从`var`使用受限的原因开始。'
- en: Limiting the scope of failed assumptions
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制失败假设的范围
- en: As you know, the use of `var` types is limited to local variables in Java. They
    are not allowed in the public API, as method parameters or as the return type
    of methods. Some languages support type inference for all types of variables.
    Java may allow us to do so in the future, but we don't know when.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，`var`类型的用法仅限于Java中的局部变量。它们不允许在公共API中使用，例如作为方法参数或方法的返回类型。一些语言支持对所有类型变量的类型推断。Java可能在将来允许我们这样做，但我们不知道具体何时。
- en: However, there are strong reasons for limiting the scope of the inferred variables,
    to spot the errors due to mismatch of assumptions and the actual, early on. The
    contracts of the public APIs should be explicit. Type inference with public APIs
    would allow for these errors to be caught and corrected much later.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有强烈的理由限制推断变量的作用域，以便尽早发现由于假设与实际情况不匹配而产生的错误。公共 API 的合同应该是明确的。使用公共 API 进行类型推断将允许这些错误被捕获和纠正得晚得多。
- en: The contract of the public APIs should be explicit; they shouldn't depend on
    type inference.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 公共 API 的合同应该是明确的；它们不应该依赖于类型推断。
- en: The following is a practical example of how a mismatch between an assumption
    and the actual case can lead to errors.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个实际示例，说明了假设与实际情况之间的不匹配可能导致错误。
- en: Recently, my daughter was traveling overseas with her school for a student exchange
    program. The school asked me to send back a set of photographs for her visa application.
    I called a photographer, requesting that he print photos for the visa (and specifying
    the country). Two days later, the school asked me to resubmit the photos because
    they didn't match the rules.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，我的女儿随学校出国参加学生交流项目。学校要求我为她签证申请发送一组照片。我联系了一位摄影师，要求他打印签证照片（并指定了国家）。两天后，学校要求我重新提交照片，因为它们不符合规则。
- en: What went wrong? Neither the school nor myself were explicit with the specifications
    of the photograph. The school assumed that I would know the specifications; I
    assumed that the photographer would know the specifications (because he had been
    doing it for years). In this case, at least one person assumed that the result
    conformed to a specific output, without explicitly specifying the output. Without
    an explicit contract, there is always the chance of mismatching the expectation
    with the actual case.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么问题？学校和我自己都没有明确照片的规格。学校认为我会知道规格；我假设摄影师会知道规格（因为他已经做了很多年）。在这种情况下，至少有一个人假设结果符合特定的输出，而没有明确指定输出。没有明确的合同，总是有可能期望与实际情况不符。
- en: Despite the confusion, the mistake was spotted and corrected before the applications
    were submitted to the embassy.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在困惑，但在应用程序提交给大使馆之前，错误已被发现并纠正。
- en: 'The following is a fun image, included showing why the use of type inference
    is limited to local variables. The local instances and static variables are competing
    in a race, and only the local variables can make it to the finish line:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个有趣的图像，展示了为什么类型推断的使用仅限于局部变量。局部实例和静态变量在比赛中竞争，只有局部变量才能到达终点线：
- en: '![](img/309764b7-7013-437e-a81c-0bbdae2884b9.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/309764b7-7013-437e-a81c-0bbdae2884b9.png)'
- en: Breaking existing code
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 破坏现有代码
- en: As of Java 10, `var` is a restricted local variable type and cannot be used
    for type declarations. Code that uses `var` as the name of a class, interface,
    method, method parameters, or variables, will no longer compile in JDK 10 and
    later releases.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Java 10，`var` 是一个受限的局部变量类型，不能用于类型声明。使用 `var` 作为类、接口、方法、方法参数或变量名称的代码，在 JDK
    10 及以后的版本中将无法编译。
- en: 'The following is an example of code that uses `var` at multiple places and
    won''t compile:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用 `var` 在多个位置且无法编译的代码示例：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It is important to test your production code with the latest Java release versions,
    even if you are not planning to deploy your production code to them. It will help
    to iron out any compatibility issues with your production code, helping to migrate
    it to a future version of Java.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你计划不将生产代码部署到最新版本的 Java 中，也很重要使用最新的 Java 发布版本测试你的生产代码。这有助于解决与你的生产代码的任何兼容性问题，帮助你将其迁移到
    Java 的未来版本。
- en: Non-denotable types
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可表示类型
- en: Java types that you can use in a program, like `int`, `Byte`, `Comparable`,
    or `String`, are called **denotable** types. The types used by a compiler internally,
    like the subclass of an anonymous class, which you can't write in your program,
    are called **non-denotable** types.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在程序中使用的 Java 类型，如 `int`、`Byte`、`Comparable` 或 `String`，被称为 **可表示** 类型。编译器内部使用的类型，如匿名类的子类，你无法在程序中编写，被称为
    **不可表示** 类型。
- en: Up until now, type inference with variables seemed quite easy to implement—just
    get the information about the values passed to a method and returned from a method,
    and infer the type. However, it isn't as simple as that when it comes to inference
    with non-denotable types—`null` types, intersection types, anonymous class types,
    and capture types.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，变量的类型推断似乎很容易实现——只需获取传递给方法的价值和从方法返回的价值的信息，并推断类型。然而，当涉及到不可表示类型的推断时——`null`类型、交集类型、匿名类类型和捕获类型，事情并不像那样简单。
- en: 'For example, consider the following code and think about the type of the inferred
    variables:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码并思考推断变量的类型：
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Type of variable `a` and `b` isn't a type that you would have read before. But
    that doesn't stop them from being inferred. The compiler infers them to a non-denotable
    type.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`a`和`b`的类型并不是你之前读过的类型。但这并不妨碍它们被推断。编译器将它们推断为一个不可表示的类型。
- en: Meaningful variable names
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有意义的变量名
- en: Type inference with `var` should be used responsibly. When you remove explicit
    data type from a variable declaration, the variable name takes the center stage.
    With inferred types, it is your responsibility to use descriptive and appropriate
    variable names, so that they make more sense in code. As you know, a piece of
    code is written once, but read many times.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`var`进行类型推断应负责任地使用。当你从变量声明中移除显式数据类型时，变量名就成为了焦点。在使用推断类型的情况下，你有责任使用描述性和适当的变量名，以便它们在代码中更有意义。正如你所知，一段代码只编写一次，但会被阅读多次。
- en: 'For example, the following line of code won''t make much sense to you or to
    your team members (especially with a big or distributed team) after a period of
    time:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码行在一段时间后对你或你的团队成员（尤其是大型或分布式团队）来说可能没有太多意义：
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The key questions are—what is the variable `i` used for? What does the method
    `getData()` return? Imagine the plight of the other team members that will work
    with this code after you leave.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 关键问题是——变量`i`用于什么？`getData()`方法返回什么？想象一下你离开后将与这段代码一起工作的其他团队成员的困境。
- en: 'Also, it doesn''t help to define variable names that are mismatched with their
    purposes. For example, it doesn''t make much sense to create a connection object
    named `database` and assign a `URL` instance to it, or to define a variable with
    the name `query` and assign a `Connection` instance to it:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，定义与目的不匹配的变量名也没有帮助。例如，创建一个名为`database`的连接对象并将其分配给一个`URL`实例，或者定义一个名为`query`的变量并将其分配给一个`Connection`实例，都没有太多意义：
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When variables are defined using `var`, variable names become more important.
    Without a type, it can become difficult to understand the purpose of a variable,
    especially if its name is not expressive enough. Choose variable names carefully
    and responsibly, making their purpose clear.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`var`定义变量时，变量名变得更加重要。没有类型，可能难以理解变量的目的，尤其是如果其名称不够表达。仔细且负责任地选择变量名，使其目的明确。
- en: Code refactoring
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码重构
- en: Type inference with `var` was introduced to reduce the verbosity of the Java
    language. It will help the programmers to be more concise in their methods. The
    compiler infers the type of the variables declared using `var` and inserts it
    in the bytecode. There is no need to refactor existing or legacy code, replacing
    explicit data types of local variables with `var`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`var`进行类型推断是为了减少Java语言的冗长。这将帮助程序员在方法中更加简洁。编译器会推断使用`var`声明的变量的类型，并将其插入到字节码中。无需重构现有或遗留代码，将局部变量的显式数据类型替换为`var`。
- en: Type inference versus dynamic binding
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断与动态绑定
- en: The use of type inference with `var` isn't pushing Java towards the dynamic
    binding domain. Java is still a strongly-typed static language. The type inference
    in Java is syntactic sugar. The compiler infers the type and adds it to the bytecode.
    In dynamic binding, a variable type is inferred at runtime. This can lead to more
    errors being discovered later.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`var`进行类型推断并没有推动Java走向动态绑定领域。Java仍然是一个强类型静态语言。Java中的类型推断是语法糖。编译器推断类型并将其添加到字节码中。在动态绑定中，变量类型在运行时推断。这可能导致更晚发现更多的错误。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered local variable inference, or `var`, as introduced
    in Java 10\. The `var` type enables you to drop the explicit data type for a local
    variable in a method. We covered the various dos and don'ts for the usage of `var`.
    Limited to local variables, variables defined using `var` must be initialized
    with a value. They can be used with all types of variables—primitives and objects.
    Variables defined with `var` can also be passed to methods and returned from methods;
    method declaration compatibility rules apply.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Java 10中引入的局部变量推断，或称为`var`。`var`类型允许你在方法中省略局部变量的显式数据类型。我们讨论了使用`var`的各种注意事项。限于局部变量，使用`var`定义的变量必须初始化。它们可以与所有类型的变量一起使用——原始类型和对象。使用`var`定义的变量也可以传递给方法并从方法返回；方法声明兼容性规则适用。
- en: To avoid risking your type safety with generics, ensure that you pass relevant
    information when using `var` with generics. Although it doesn't make a lot of
    sense, the use of explicit casting is allowed with variables defined using `var`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在使用泛型时冒着类型安全的风险，确保在使用`var`与泛型一起使用时传递相关信息。尽管这样做没有太多意义，但使用显式转换在用`var`定义的变量中是允许的。
- en: We also covered ways in which type inference existed in previous versions of
    Java (5, 7, and 8). Toward the end, we covered why type inference is limited to
    local variables and is not allowed in the public API.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了类型推断在Java的先前版本（5、7和8）中存在的方式。在结尾部分，我们讨论了为什么类型推断仅限于局部变量，并且不允许在公共API中使用。
- en: The use of meaningful variable names has always been recommended, and it is
    important. With `var`, it becomes even more important. Since `var` offers syntactic
    sugar, it doesn't make any sense to refactor your existing or legacy code to add
    the use of `var`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用有意义的变量名一直被推荐，并且这一点非常重要。有了`var`，这一点变得更加重要。由于`var`提供了语法糖，因此没有必要重构现有的或遗留代码以添加`var`的使用。
