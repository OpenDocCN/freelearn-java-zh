- en: Type Inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to use type inference with local variables (`var`) is one of the
    star features of Java 10\. It reduces the verbosity of the language without compromising
    Java's dependable static binding and type safety. The compiler infers the type
    by using the information available in the code, and adds it to the bytecode that
    it generates.
  prefs: []
  type: TYPE_NORMAL
- en: Every new concept has its own set of benefits, limitations, and complexities.
    Using type inference with `var` is no exception. As you work through this chapter,
    using `var` will enthrall and frustrate you, but you will emerge triumphantly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is type inference?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type inference with `var`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dos and don'ts of working with `var`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type inference versus dynamic binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is type inference?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine solving a riddle, such as the one shown in the following image, with
    multiple constraints in the form of hints. You resolve the constraints to derive
    the answer. You can compare type inference to generating constraints and then
    resolving them, in order to determine the data types in a programming language.
    Type inference is the capability of the compiler to determine the type of the
    data, by using the information that is already available in the code—literal values,
    method invocations, and their declarations. For a developer, type inference reduces
    verbosity, as indicated by the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4af82659-f9ce-473f-8cbe-c161f66fc7c3.png)'
  prefs: []
  type: TYPE_IMG
- en: For your reference, the answer to the preceding riddle is 87 (just turn the
    image upside down, and you'll find the numbers in a sequence).
  prefs: []
  type: TYPE_NORMAL
- en: Type inference is not new to Java. It has been taken to the next level with
    the introduction of `var` (with local variables) in Java 10.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive into the topic by looking at some examples of `var`.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference with var
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following lines of code show how local variables (and all other variables)
    were defined prior to Java 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting with Java 10, by using `var`, you can drop the mandatory explicit
    type in the declaration of local variables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Does it look like the preceding code doesn''t offer a lot of benefits? Imagine
    you could take the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And replace it with this code, instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By replacing `HashMap<Integer, String>` with `var`, the preceding line of code
    is much shorter.
  prefs: []
  type: TYPE_NORMAL
- en: When you move away from explicitly stating the data type of the variables, the
    compiler takes over to determine, or infer, the variable type. Type inference
    is the compiler's ability to evaluate the information that is already present
    in the code, like the literal values, operations, and method invocations or their
    declarations, to determine the variable type. It follows a set of rules to infer
    the variable type. As a developer, when you choose type inference with `var`,
    you should be aware of the compiler's inference algorithm, so that you don't get
    unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: With every new feature, you should adhere to a few rules and restrictions and
    try to follow the best practices to benefit from that feature. Let's start with
    the compulsory initialization of the variables that are defined using `var`.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference with `var` is not dynamic typing; Java is still a strong, static-typed
    language. The usage of `var` makes your code leaner; you can drop the type of
    the local variable from its definition.
  prefs: []
  type: TYPE_NORMAL
- en: Compulsory non-null initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A local variable defined with `var` must be initialized with its declaration,
    or the code won''t compile. The compiler can''t infer the type of an uninitialized
    variable or a variable that is assigned a `null` value. The following code won''t
    compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image illustrates what would happen if the uninitialized variable
    `age` went to seek entrance to the Mr. Java compiler place. The compiler won''t
    let `age` in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c52345b-2379-4400-8a0a-a2aea3e251bb.png)'
  prefs: []
  type: TYPE_IMG
- en: Variable definition using `var` must always be accompanied by its initialization,
    or the code will fail to compile.
  prefs: []
  type: TYPE_NORMAL
- en: Local variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The usage of `var` is limited to local variables. These variables are used to
    store intermediate values and have the shortest life span, as compared to the
    instance and static variables. The local variables are defined within a method,
    constructor, or initializer block (both instance and static). Within a method
    or initializer, they can be defined within constructs, such as `if..else` loops,
    `switch` statements, and the `try-with-resources` construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of  `Person` class, showing possible usage of `var`
    to define local variables in initializer blocks, methods (including constructors),
    loops, as a local variable within `switch` branches, or a `try with resources`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can notice from the preceding code, a local variable can be declared
    using `var` at varied places in a class. Do you remember most of them? If not,
    let's make it simple for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use an application to *find* all possible places where you could define
    local variables using `var` and mark it pictorially:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a261681-49a1-4214-8854-6f01e24711bd.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter includes a couple of code-check exercises for you to try. The exercises
    use the names of two hypothetical programmers—Pavni and Aarav.
  prefs: []
  type: TYPE_NORMAL
- en: Code check – part 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of our programmers, Aarav, refactored some code by his team member, Pavni.
    The code no longer provides `char` and the corresponding ASCII numbers of the
    values stored by the `char` array. Can you help Aarav? The following is the code
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The answer to the code check: The `var` type can''t be used to specify the
    types of exceptions in the `catch` handler, `(var e)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using var with primitive data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using `var` with primitive data types seems to be the simplest scenario, but
    appearances can be deceptive. Try to execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You might assume that an integer literal value (`9_009_998_992_887`, in this
    case) that doesn''t fit into the range of primitive `int` types will be inferred
    to be a `long` type. However, this doesn''t happen. Since the default type of
    an integer literal value is `int`, you''ll have to append the preceding value
    with the suffix `L` or `l`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for an `int` literal value to be inferred as a `char` type, you
    must use an explicit cast, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'What is the result when you divide `5` by `2`? Did you think it''s `2.5`? This
    isn''t how it (always) works in Java! When integer values are used as operands
    in the division, the result is not a decimal number, but an integer value. The
    fraction part is dropped, to get the result as an integer. Though this is normal,
    it might seem weird when you expect the compiler to infer the type of your variable.
    The following is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Though these cases aren''t specifically related to the `var` type, the developer''s
    assumption that the compiler will infer a specific type results in a mismatch.
    Here''s a quick diagram to help you remember this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/047f3487-368c-4b58-8308-b0a3e7637726.png)'
  prefs: []
  type: TYPE_IMG
- en: The default type of integer literals is `int`, and the default type of floating
    point numbers is `double`. Assigning `100` to a variable defined with `var` will
    infer its type as `int`, not `byte` or `short`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In arithmetic operation, if either of the operands is `char`, `byte`, `short`,
    or `int`, the result is at least promoted to `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for an arithmetic operation that includes at least one operand as
    a `long`, `float`, or `double` value, the result is promoted to the type `long`,
    `float`, or `double`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The rules of the implicit widening of primitive variables play an important
    role in understanding how the Java compiler infers variables with primitive values.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference with derived classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In JDK 9 and other previous versions, you could define a variable of the base
    class and assign an instance of its derived class to it. The members that you
    could access using the variable were limited to the ones that were defined in
    the base class. This is no longer the case with `var`, since the type of the variable
    is inferred by using the specific type of the instance that is assigned to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a class  `Child` extends a class `Parent`. When you create a local
    variable and assign it an instance of the `Child` class, the type of the variable
    is inferred as `Child`. This looks simple. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens if you assign the value of the `obj` variable using a method that
    can return an instance of the `Child` class or `Parent` classes? Here''s the modified
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the type of the instance returned by the `getObject()` method
    can't be determined before the code execution. During compilation, the type of
    the `obj` variable is inferred as `Parent`, the return type of the `getObject()` method. Since
    the `Parent` class doesn't define `stand()`, the `main()` methods fail to compile.
  prefs: []
  type: TYPE_NORMAL
- en: The types of variables defined using `var` are inferred at compile time. If
    the return type of a method is used to assign a variable that is defined using
    `var`, its inferred type is the return type of the method, not the type of the
    instance returned during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference with interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s extend the content of the preceding section to the use of interfaces.
    Imagine that the `Child` class implements a `MarathonRunner` interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define an `obj` local variable, assigning it an instance of the `Child` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If the same variable is initialized using a method whose return type is `MarathonRunner`,
    its inferred type is `MarathonRunner` (irrespective of the type of the instance
    returned by it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Using var with arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using `var` doesn''t imply just dropping the type of the local variable; what
    remains should enable the compiler to infer its type. Imagine a method that defines
    an array of the `char` type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can''t replace the data type name, that is, `char`, in the preceding code
    with `var` and define it using any of the following code samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s one of the ways to include relevant information, so that the compiler
    can infer the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It seems like the Java compiler is already struggling with this assumption
    from the programmers, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c93bfaae-5ff6-45cf-b181-b12079a8a95e.png)'
  prefs: []
  type: TYPE_IMG
- en: You can't just drop the data types in order to use `var`. What remains should
    enable the compiler to infer the type of the value being assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference with generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics were introduced in Java to promote type safety. It enabled developers
    to specify their intentions of using classes, interfaces, and collection classes
    with fixed types or a range of types. Violations of these intentions were enforced
    with compilation errors, rather than runtime exceptions, raising the compliance
    bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following shows how you would define `ArrayList` to store
    `String` values (repeating `<String>` is optional, on the right-hand side of the
    assignment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'However, replacing `List<String>` with `var` will put the type safety of the
    generics at stake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code allows for the addition of multiple data types to `names`,
    which is not the intention. With generics, the preferred approach is to make relevant
    information available to the compiler, so that it can infer its type correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When using `var` with generics, ensure that you pass the relevant data types
    within the angular brackets on the right-hand side of the assignment, so that
    you don't lose type safety.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time for our next code check.
  prefs: []
  type: TYPE_NORMAL
- en: Code check – part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of our programmers, Pavni, tried using `var` with generics and collection
    classes, but her code doesn''t seem to output the sorted collection of pens. Can
    you help? Check out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The answer to the code check: The issue here is trying to modify the immutable
    collection by using `Collections.sort()`. This is to emphasize that not all issues
    are related to the use of `var`.'
  prefs: []
  type: TYPE_NORMAL
- en: Passing inferred variables to a method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though the use of `var` is limited to the declaration of local variables, these
    variables (both primitive and reference) can be passed to methods as values. The
    inferred types and the types expected by the methods must match, to allow the
    code to compile.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example code, the `Child` class implements the `MarathonRunner`
    interface. The `start()` method in the `Marathon` class expects the `MarathonRunner`
    object (the instances of the class implementing this interface) as its method
    argument. The inferred type of the `aRunner` variable is `Child`. Since the `Child` class
    implements `MarathonRunner`, `aRunner` can be passed to the `start()` method, the
    inferred type of `aRunner` (`Child`) and the expected type of `start()` (`MarathonRunner`)
    match, allowing the code to compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As long as the inferred type of a variable matches the type of the method parameter,
    it can be passed to it as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Reassigning values to inferred variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As is applicable to all non-final variables, you can reassign value to inferred
    variables. Just ensure that the reassigned value matches its inferred type. In
    the following code, since the type of the `age` variable is inferred as `int`,
    you can''t assign a decimal value of `10.9` to it. Similarly, since the type of
    the `query` variable is inferred as `StringBuilder`. The type of a variable is
    inferred just once, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The type of a local variable defined using `var` is inferred only once.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit casting with inferred variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine that a co-programmer assigned `29` to an inferred local variable (let''s
    say `age`), assuming that the compiler would infer the type of the variable `age` as `byte`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the compiler would infer the type of the variable `age` as `int`,
    since the default type of an integer literal value is `int`. To fix the preceding
    assumption, you can either use the explicit data type or override the compiler''s
    default inference mechanism by using explicit casting, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: By using explicit casting type inference, you can override the compiler's default
    type inference mechanism. This might be required to fix the assumptions in the
    existing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can use explicit casting with other primitive data types, like
    `char` and `float`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Without the explicit casting in the preceding examples, variables that are assigned
    integer literal values would be inferred as `int`, and decimal as `double`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows explicit casting with reference variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Use explicit casting with type inference to fix any existing assumptions. I
    wouldn't recommend using explicit casting to initialize inferred variables; it
    defeats the purpose of using `var`.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning null with explicit casting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again, although it doesn''t make sense to use explicit casting with `null`
    to assign it to a `var` type, it is a valid code, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Though the preceding line of code is correct syntax-wise, it is a bad coding
    practice. Avoid it!
  prefs: []
  type: TYPE_NORMAL
- en: Type inference in previous versions of Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although `var` takes inference to a new level in Java 10, the concept of type
    inference existed in Java's previous versions. Let's look at some examples of
    type inference in the previous versions of Java.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference in Java 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics introduced a type system to enable the developers to abstract over
    types. It restricted a class, interface, or method to working with instances of
    specified types, providing compile type safety. Generics were defined to add compile
    type safety to the Collections framework. Generics enable programs to detect certain
    bugs during compilation, so they can't creep into the runtime code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java used type inference for generic method type arguments in Java 5\. Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of the preceding code, you could use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Type inference in Java 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java 7 introduced type inference for constructor arguments with generics. Consider
    the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In Java 7, the preceding line of code could be replaced with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shouldn''t be confused with the following, which is trying
    to mix the generics with the raw types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Java 7 also allowed type inference to invoke generic methods. For a generic
    method (say, `print()`) defined in a class (say, `MyClass`), the code would be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be called in either of the following ways (the third
    line of code uses type inference to infer the type of the argument passed to the
    `print()` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Type inference in Java 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java, version 8, introduced functional programming, with lambda functions.
    The lambda expression can infer the type of its formal parameters. Consider the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of the preceding code, you could type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of `var` doesn't come without its share of challenges, for both the
    developers of the Java language and its users. Let's start with the reasons why
    `var` has limited usage.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the scope of failed assumptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know, the use of `var` types is limited to local variables in Java. They
    are not allowed in the public API, as method parameters or as the return type
    of methods. Some languages support type inference for all types of variables.
    Java may allow us to do so in the future, but we don't know when.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are strong reasons for limiting the scope of the inferred variables,
    to spot the errors due to mismatch of assumptions and the actual, early on. The
    contracts of the public APIs should be explicit. Type inference with public APIs
    would allow for these errors to be caught and corrected much later.
  prefs: []
  type: TYPE_NORMAL
- en: The contract of the public APIs should be explicit; they shouldn't depend on
    type inference.
  prefs: []
  type: TYPE_NORMAL
- en: The following is a practical example of how a mismatch between an assumption
    and the actual case can lead to errors.
  prefs: []
  type: TYPE_NORMAL
- en: Recently, my daughter was traveling overseas with her school for a student exchange
    program. The school asked me to send back a set of photographs for her visa application.
    I called a photographer, requesting that he print photos for the visa (and specifying
    the country). Two days later, the school asked me to resubmit the photos because
    they didn't match the rules.
  prefs: []
  type: TYPE_NORMAL
- en: What went wrong? Neither the school nor myself were explicit with the specifications
    of the photograph. The school assumed that I would know the specifications; I
    assumed that the photographer would know the specifications (because he had been
    doing it for years). In this case, at least one person assumed that the result
    conformed to a specific output, without explicitly specifying the output. Without
    an explicit contract, there is always the chance of mismatching the expectation
    with the actual case.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the confusion, the mistake was spotted and corrected before the applications
    were submitted to the embassy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a fun image, included showing why the use of type inference
    is limited to local variables. The local instances and static variables are competing
    in a race, and only the local variables can make it to the finish line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/309764b7-7013-437e-a81c-0bbdae2884b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Breaking existing code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of Java 10, `var` is a restricted local variable type and cannot be used
    for type declarations. Code that uses `var` as the name of a class, interface,
    method, method parameters, or variables, will no longer compile in JDK 10 and
    later releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of code that uses `var` at multiple places and
    won''t compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: It is important to test your production code with the latest Java release versions,
    even if you are not planning to deploy your production code to them. It will help
    to iron out any compatibility issues with your production code, helping to migrate
    it to a future version of Java.
  prefs: []
  type: TYPE_NORMAL
- en: Non-denotable types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java types that you can use in a program, like `int`, `Byte`, `Comparable`,
    or `String`, are called **denotable** types. The types used by a compiler internally,
    like the subclass of an anonymous class, which you can't write in your program,
    are called **non-denotable** types.
  prefs: []
  type: TYPE_NORMAL
- en: Up until now, type inference with variables seemed quite easy to implement—just
    get the information about the values passed to a method and returned from a method,
    and infer the type. However, it isn't as simple as that when it comes to inference
    with non-denotable types—`null` types, intersection types, anonymous class types,
    and capture types.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following code and think about the type of the inferred
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Type of variable `a` and `b` isn't a type that you would have read before. But
    that doesn't stop them from being inferred. The compiler infers them to a non-denotable
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Meaningful variable names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type inference with `var` should be used responsibly. When you remove explicit
    data type from a variable declaration, the variable name takes the center stage.
    With inferred types, it is your responsibility to use descriptive and appropriate
    variable names, so that they make more sense in code. As you know, a piece of
    code is written once, but read many times.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following line of code won''t make much sense to you or to
    your team members (especially with a big or distributed team) after a period of
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The key questions are—what is the variable `i` used for? What does the method
    `getData()` return? Imagine the plight of the other team members that will work
    with this code after you leave.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, it doesn''t help to define variable names that are mismatched with their
    purposes. For example, it doesn''t make much sense to create a connection object
    named `database` and assign a `URL` instance to it, or to define a variable with
    the name `query` and assign a `Connection` instance to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: When variables are defined using `var`, variable names become more important.
    Without a type, it can become difficult to understand the purpose of a variable,
    especially if its name is not expressive enough. Choose variable names carefully
    and responsibly, making their purpose clear.
  prefs: []
  type: TYPE_NORMAL
- en: Code refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type inference with `var` was introduced to reduce the verbosity of the Java
    language. It will help the programmers to be more concise in their methods. The
    compiler infers the type of the variables declared using `var` and inserts it
    in the bytecode. There is no need to refactor existing or legacy code, replacing
    explicit data types of local variables with `var`.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference versus dynamic binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of type inference with `var` isn't pushing Java towards the dynamic
    binding domain. Java is still a strongly-typed static language. The type inference
    in Java is syntactic sugar. The compiler infers the type and adds it to the bytecode.
    In dynamic binding, a variable type is inferred at runtime. This can lead to more
    errors being discovered later.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered local variable inference, or `var`, as introduced
    in Java 10\. The `var` type enables you to drop the explicit data type for a local
    variable in a method. We covered the various dos and don'ts for the usage of `var`.
    Limited to local variables, variables defined using `var` must be initialized
    with a value. They can be used with all types of variables—primitives and objects.
    Variables defined with `var` can also be passed to methods and returned from methods;
    method declaration compatibility rules apply.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid risking your type safety with generics, ensure that you pass relevant
    information when using `var` with generics. Although it doesn't make a lot of
    sense, the use of explicit casting is allowed with variables defined using `var`.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered ways in which type inference existed in previous versions of
    Java (5, 7, and 8). Toward the end, we covered why type inference is limited to
    local variables and is not allowed in the public API.
  prefs: []
  type: TYPE_NORMAL
- en: The use of meaningful variable names has always been recommended, and it is
    important. With `var`, it becomes even more important. Since `var` offers syntactic
    sugar, it doesn't make any sense to refactor your existing or legacy code to add
    the use of `var`.
  prefs: []
  type: TYPE_NORMAL
