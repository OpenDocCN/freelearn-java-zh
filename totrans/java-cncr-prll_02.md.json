["```java\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\npublic class KitchenSimulator {\n    private static final ExecutorService kitchen = Executors.    newFixedThreadPool(3);\n    public static void main(String[] args) {\n        String dishToPrepare = \"Spaghetti Bolognese\";\n        String menuToUpdate = \"Today's Specials\";\n        kitchen.submit(() -> {\n            prepareDish(dishToPrepare);\n        });\n        kitchen.submit(() -> {\n            searchRecipes(\"Italian\");\n        });\n        kitchen.submit(() -> {\n            updateMenu(menuToUpdate, \"Risotto alla Milanese\");\n        });\n        kitchen.shutdown();\n    }\n    private static void prepareDish(String dish) {\n        System.out.println(\"Preparing \" + dish);\n        try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n      }\n    private static void searchRecipes(String cuisine) {\n        System.out.println(\"Searching for \" + cuisine + \" recipes\");\n        try {\n                Thread.sleep(1000);\n          } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n      }\n    private static void updateMenu(String menu, String dishToAdd) {\n        System.out.println(\"Updating \" + menu + \" with \" + dishToAdd);\n        try {\n                Thread.sleep(1000);\n          } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n      }\n    }\n```", "```java\n        import java.util.concurrent.ArrayBlockingQueue;\n        import java.util.concurrent.ThreadPoolExecutor;\n        import java.util.concurrent.TimeUnit;\n        import java.util.stream.IntStream;\n        public class DirectThreadPoolExample {\n            public static void main(String[] args) {\n                int corePoolSize = 2;\n                int maxPoolSize = 4;\n                long keepAliveTime = 5000;\n                TimeUnit unit = TimeUnit.MILLISECONDS;\n                int taskCount = 15; // Make this 4, 10, 12, 14, and         finally 15 and observe the output.\n                ArrayBlockingQueue<Runnable> workQueue = new         ArrayBlockingQueue<>(10);\n                ThreadPoolExecutor executor = new         ThreadPoolExecutor(corePoolSize, maxPoolSize,         keepAliveTime, unit, workQueue);\n                IntStream.range(0, taskCount).forEach(\n                    i -> executor.execute(\n                        () -> System.out.println(\n                            String.format(\"Task %d executed. Pool size                      = %d. Queue size = %d.\", i, \n                            executor.getPoolSize(), \n                            executor. getQueue().size())\n                        )\n                    )\n                );\n                executor.shutdown();\n                executor.close();\n            }\n        }\n        ```", "```java\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\npublic class OrderProcessingSystem {\n    private final ExecutorService executorService = Executors.    newFixedThreadPool(10);\n    private final ConcurrentLinkedQueue<Order> orderQueue = new     ConcurrentLinkedQueue<>();\n    private final CopyOnWriteArrayList<Order> processedOrders = new     CopyOnWriteArrayList<>();\n    private final ConcurrentHashMap<Integer, String> orderStatus = new     ConcurrentHashMap<>();\n    private final Lock paymentLock = new ReentrantLock();\n    private final Semaphore validationSemaphore = new Semaphore(5);\n    private final AtomicInteger processedCount = new AtomicInteger(0);\n    public void startProcessing() {\n        while (!orderQueue.isEmpty()) {\n            Order order = orderQueue.poll();\n            executorService.submit(() -> processOrder(order));\n        }\n        executorService.close();\n    }\n    private void processOrder(Order order) {\n        try {\n            validateOrder(order);\n            paymentLock.lock();\n            try {\n                processPayment(order);\n            } finally {\n                paymentLock.unlock();\n            }\n            shipOrder(order);\n            processedOrders.add(order);\n            processedCount.incrementAndGet();\n            orderStatus.put(order.getId(), \"Completed\");\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n    private void validateOrder(Order order) throws     InterruptedException {\n        validationSemaphore.acquire();\n        try {\n            Thread.sleep(100);\n        } finally {\n            validationSemaphore.release();\n        }\n    }\n    private void processPayment(Order order) {\n        System.out.println(\"Payment Processed for Order \" + order.        getId());\n    }\n    private void shipOrder(Order order) {\n        System.out.println(\"Shipped Order \" + order.getId());\n    }\n    public void placeOrder(Order order) {\n        orderQueue.add(order);\n        orderStatus.put(order.getId(), \"Received\");\n        System.out.println(\"Order \" + order.getId() + \" placed.\");\n    }\n    public static void main(String[] args) {\n        OrderProcessingSystem system = new OrderProcessingSystem();\n        for (int i = 0; i < 20; i++) {\n            system.placeOrder(new Order(i));\n        }\n        system.startProcessing();\n        System.out.println(\"All Orders Processed!\");\n    }\n    static class Order {\n        private final int id;\n        public Order(int id) {\n            this.id = id;\n        }\n        public int getId() {\n            return id;\n        }\n    }\n}\n```", "```java\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.concurrent.TimeUnit;\npublic class PrinterManager {\n    private final ReentrantLock printerLock = new ReentrantLock();\n    private final Condition readyCondition = printerLock.    newCondition();\n    private boolean isPrinterReady = false;\n    public void makePrinterReady() {\n        printerLock.lock();\n        try {\n            isPrinterReady = true;\n            readyCondition.signal(); // Signal one waiting thread that             the printer is ready\n        } finally {\n            printerLock.unlock();\n        }\n    }\n    public void printDocument(String document) {\n        printerLock.lock();\n        try {\n            // Wait until the printer is ready\n            while (!isPrinterReady) {\n                System.out.println(Thread.currentThread().getName() +                 \" waiting for the printer to be ready.\");\n                if (!readyCondition.await(\n                    2000, TimeUnit.MILLISECONDS)) {\n                    System.out.println(\n                       Thread.currentThread().getName()\n                            + \" could not print. Timeout while waiting                             for the printer to be ready.\");\n                    return;\n                }\n            }\n            // Printer is ready. Proceed to print the document\n            System.out.println(Thread.currentThread().getName() + \" is             printing: \" + document);\n            Thread.sleep(1000); // Simulates printing time\n            // Reset the printer readiness for demonstration purposes\n            isPrinterReady = false;\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } finally {\n            printerLock.unlock();\n        }\n    }\n    public static void main(String[] args) {\n        PrinterManager printerManager = new PrinterManager();\n        // Simulating multiple threads (office workers) trying to use            the printer\n        Thread worker1 = new Thread(() -> printerManager.        printDocument(\"Document1\"), \"Worker1\");\n        Thread worker2 = new Thread(() -> printerManager.        printDocument(\"Document2\"), \"Worker2\");\n        Thread worker3 = new Thread(() -> printerManager.        printDocument(\"Document3\"), \"Worker3\");\n        worker1.start();\n        worker2.start();\n        worker3.start();\n        // Simulate making the printer ready after a delay\n        new Thread(() -> {\n            try {\n                Thread.sleep(2000); // Simulate some delay\n                printerManager.makePrinterReady();\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }).start();\n    }\n}\n```", "```java\npublic class DynamoDBDeadlockDemo {\n    private static final Object Item1Lock = new Object();\n    private static final Object Item2Lock = new Object();\n    public static void main(String[] args) {\n        Thread lambdaFunction1 = new Thread(() -> {\n            synchronized (Item1Lock) {\n                System.out.println(\n                    \"Lambda Function 1 locked Item 1\");\n                try { Thread.sleep(100);\n                } catch (InterruptedException e) {}\n                System.out.println(\"Lambda Function 1 waiting to lock                 Item 2\");\n                synchronized (Item2Lock) {\n                    System.out.println(\"Lambda Function 1 locked Item                     1 & 2\");\n                }\n            }\n        });\n        Thread lambdaFunction2 = new Thread(() -> {\n            synchronized (Item2Lock) {\n                System.out.println(\"Lambda Function 2 locked Item 2\");\n                try { Thread.sleep(100);\n                } catch (InterruptedException e) {}\n                System.out.println(\"Lambda Function 2 waiting to lock                 Item 1\");\n                synchronized (Item1Lock) {\n                    System.out.println(\"Lambda Function 2 locked Item                     1 & 2\");\n                }\n            }\n        });\n        lambdaFunction1.start();\n        lambdaFunction2.start();\n    }\n}\n```", "```java\n        // Thread representing Lambda Function 1\npublic class DynamoDBDeadlockDemo {\n private static final Object Item1Lock = new Object();\n private static final Object Item2Lock = new Object();\n    public static void main(String[] args) {\n        Thread lambdaFunction1 = new Thread(() -> {\n            synchronized (Item1Lock) {\n                System.out.println(\n                    \"Lambda Function 1 locked Item 1\");\n                try { Thread.sleep(100);\n                } catch (InterruptedException e) {}\n                System.out.println(\"Lambda Function 1 waiting to lock                 Item 2\");\n                synchronized (Item2Lock) {\n                    System.out.println(\"Lambda Function 1 locked Item                     1 & 2\");\n                }\n            }\n        });\n        Thread lambdaFunction2 = new Thread(() -> {\n            synchronized (Item1Lock) {\n                System.out.println(\n                    \"Lambda Function 2 locked Item 1\");\n                try { Thread.sleep(100);\n                    } catch (InterruptedException e) {}\n                System.out.println(\"Lambda Function 2 waiting to lock                 Item 2\");\n                // Then, attempt to lock Item2\n                synchronized (Item2Lock) {\n                    System.out.println(\"Lambda Function 2 locked Item                     1 & 2\");\n                }\n            }\n        });\n        lambdaFunction1.start();\n        lambdaFunction2.start();\n    }\n}\n```", "```java\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.concurrent.TimeUnit;\npublic class FileDeadlockDetectionDemo {\n    private static final ReentrantLock fileLock1 = new     ReentrantLock();\n    private static final ReentrantLock fileLock2 = new     ReentrantLock();\n    public static void main(String[] args) {\n        Thread process1 = new Thread(() -> {\n            try {\n                acquireFileLocksWithTimeout(\n                    fileLock1, fileLock2);\n            } catch (InterruptedException e) {\n                if (fileLock1.isHeldByCurrentThread()) fileLock1.                unlock();\n                if (fileLock2.isHeldByCurrentThread()) fileLock2.                unlock();\n            }\n        });\n        Thread process2 = new Thread(() -> {\n            try {\n                acquireFileLocksWithTimeout(\n                    fileLock2, fileLock1);\n            } catch (InterruptedException e) {\n                if (fileLock1.isHeldByCurrentThread()) fileLock1.                unlock();\n                if (fileLock2.isHeldByCurrentThread()) fileLock2.                unlock();\n            }\n        });\n        process1.start();\n        process2.start();\n        try {\n            Thread.sleep(2000);\n            if (process1.isAlive() && process2.isAlive()) {\n                System.out.println(\"Deadlock suspected, interrupting                 process 2\");\n                process2.interrupt();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\nprivate static void acquireFileLocksWithTimeout(\n    ReentrantLock firstFileLock, ReentrantLock secondFileLock) throws     InterruptedException {\n        if (!firstFileLock.tryLock(1000, TimeUnit.MILLISECONDS)) {\n            throw new InterruptedException(\"Failed to acquire first             file lock\");\n        }\n        try {\n            if (!secondFileLock.tryLock(\n                1000, TimeUnit.MILLISECONDS)) {\n                throw new InterruptedException(\n                    \"Failed to acquire second file lock\");\n            }\n            System.out.println(Thread.currentThread().getName() + \"             acquired both file locks\");\n            try { Thread.sleep(500);\n                } catch (InterruptedException e) {}\n        } finally {\n            if (secondFileLock.isHeldByCurrentThread())             secondFileLock.unlock();\n            if (firstFileLock.isHeldByCurrentThread()) firstFileLock.            unlock();\n        }\n    }\n}\n```", "```java\nExecutorService executor = Executors.newFixedThreadPool(2);\nCallable<Integer> task = () -> {\n    // perform some computation\n    return 42;\n};\nFuture<Integer> future = executor.submit(task);\n// do something else while the task is executing\nInteger result = future.get(); // Retrieves the result, waiting if necessary\n// Check if the task is completed\n    if (!future.isDone()) {\n        System.out.println(\"Calculation is still in progress...\");\n    }\nexecutor.shutdown();\n```", "```java\npublic class Tuple<X, Y> {\n      public final X first;\n      public final Y second;\n      public Tuple(X first, Y second) {\n          this.first = first;\n          this.second = second;\n      }\n      public static void main(String[] args) {\n          // Creating a tuple of String and Integer\n          Tuple<String, Integer> personAge = new Tuple<>(\n              \"Joe\", 30);\n      }\n}\n```"]