- en: Enhanced Enums in Project Amber
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Java 5, enums introduced a powerful way to define finite and predefined set
    of constants, with type safety. Enums enabled you to define a new type (like classes
    or interfaces) with state and behavior. **Project Amber** is enhancing enums,
    taking it to the next level; by adding type variables (generics) and allowing
    sharper type checking for enums. These two features will enable an enum to have
    constant specific type information and constant specific state and behavior. These
    enhancements will reduce the need of refactoring enums to classes, to use generics.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the reason for enhancing enums?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding state and behavior to enum constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create generic enums?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing constant specific state and behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform sharper type checking for enum constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to enums in Java 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Enums** introduced type safety to the use of constants, which were earlier
    defined using static final variables of type, say, `int`, or others. Imagine limiting
    the sizes of a shirt to some predefined sizes, say, `Small`, `Medium`, or `Large`.
    Here''s how you can do that with an enum, say, `Size`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Java's coding conventions recommend use of uppercase to define enum constants
    (like `SMALL`).  Multiple words in a constant can be separated using an underscore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how you can use enum `Size` in a class, say, `Shirt`, to restrict its
    sizes to constants defined in enum `Size`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The instance variable of type `Size` in `Shirt` class limits the values that
    are assigned to it to `Size.SMALL`, `Size.MEDIUM` and `Size.LARGE`. Here''s an
    example of how another class, say, `GarmentFactory` class uses enum constants
    to create instances of class `Shirt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Enums define a new type with a predefined set of constant values. Enums add
    type safety to the constant values.
  prefs: []
  type: TYPE_NORMAL
- en: Decompiled enum – behind the scenes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every user defined `enum` implicitly extends `java.lang.Enum` class. Behind
    the scenes, the one liner enum `Size` (defined in the preceding section) is compiled
    into something similar like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Enums are syntactic sugar. The compiler takes your enum construct and extends
    `java.lang.Enum` to create a class. It adds the variables, initializers and methods
    to get the required behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Adding state and behavior to enum constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The enum constants can have their own state and behavior. One of the ways to
    do so is to define instance variables and methods in an enum. All of these are
    accessible to the enum constants. Let's modify the enum `Size` defined in the
    previous section, adding state and behavior to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each enum constant can define a constant specific class body - defining new
    state and behaviour or override the default behaviour of enum methods in which
    it is defined. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, enum Size defines three enum constants - `SMALL`,
    `MEDIUM` and `LARGE`. It also defines instance variables (`length` and `breadth`),
    a constructor and methods `getLength()`, `getWidth` and `toText()`.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing state and behaviour of enum constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At present, an enum constant can access:'
  prefs: []
  type: TYPE_NORMAL
- en: State and behavior common to all enum constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods overridden by an enum constant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the `Size` enum (defined in the preceding section), you can access the
    state and behavior common to all enum constants, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also access the behavior, which a specific enum constant overrides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'But, you can''t access the state or behavior that is specific to an enum constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getSize()` method or the `number` variable can''t be accessed using the
    `MEDIUM` constant. This is because, `MEDIUM` creates an anonymous class and overrides
    the methods of the `Size` enum. It can''t access constant specific state or behavior
    because it''s still referenced by a variable of the `Size` type; which doesn''t
    define them. Here''s an image to help you remember this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76889c86-0dcf-4762-a00e-53e8d8025604.png)'
  prefs: []
  type: TYPE_IMG
- en: Existing enums don't allow access to state or behavior that is specific to an
    enum constant because it create an anonymous class to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Workaround to access state and behaviour of enum specific constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One the ways to get around it and access enum constant specific members is
    to define them for all members, but allow the usage only for specific members
    (I know, this is a dumb way). I''ve removed code not relevant to show how this
    works, on purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to access method `getSize()` using enum constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Exception in thread—`java.lang.UnsupportedOperationException`.
  prefs: []
  type: TYPE_NORMAL
- en: First and foremost, adding code (method `getSize()`) which is not applicable
    to all enum constants breaks encapsulation. In the preceding example, I defined
    `getSize()` in the main body, whereas only enum constant `MEDIUM` required the
    method `getSize()`. This is neither desirable, nor recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Compare it with an arrangement of a base class and its derived classes, and
    adding all behavior, specific to different derived classes in your base class.
    This sure sounds insane to me. Please don't try it at your work.
  prefs: []
  type: TYPE_NORMAL
- en: Don't attempt this workaround at work; it doesn't define encapsulated code.
  prefs: []
  type: TYPE_NORMAL
- en: Another example – using inheritance with enum constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s another example of an enum, which works with a set of subclasses by
    passing instances of subclasses to enum constructor. To get the point across,
    I''ve modified the `Size` enum, with which we have been working since the beginning
    of this chapter. Here''s the modified code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, you can''t access the state and behavior of enum constant specific code.
    Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here comes enhanced enums to the rescue. JEP 301 introduces enhanced enums by
    adding type variables or generic to it. Let's see how it works in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding generics to Enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s rewrite the enum code in the preceding example (listing 8.x), adding
    type variables to the enum `Size.` Here''s the modified code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code can be used to access constant specific behavior, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With the enhanced enums (generics added), you will be able to access an enum
    constant specific state or behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Let's work with another example of a generic enum, which can be used to restrict
    the user data to certain types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example creates a generic enum Data, which can be passed a type
    parameter, `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The class `FormData` defines a generic method, which can accept constant of
    enum `Data` and a value of the same type that is used for the enum constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how you can use the constants of enum `Data` to restrict the combination
    of type of values you pass to method `add`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With the mismatched data, the code fails at compilation, making it easier for
    the developer to correct her assumptions or program flow.
  prefs: []
  type: TYPE_NORMAL
- en: Compilation failures are always better than runtime exceptions. Usage of generic
    enum `Data` will make the code fail at compile time, for mismatched combination
    of values passed to `add()`.
  prefs: []
  type: TYPE_NORMAL
- en: Sharper typing of enum constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the two major goals of enhanced enums is to perform sharper type checking
    for enums. At present, the type of all enum constants is the enum in which they
    are defined. Referring to our example on enum, `Size`, this essentially means
    that the type of all the enum constants, that is, `SMALL`, `MEDIUM` and `LARGE`,
    is `Size`, which is incorrect (as depicted in the following image):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6dda7fab-7afa-47d5-b909-8299e36dfb9b.png)'
  prefs: []
  type: TYPE_IMG
- en: Though enum constants are allowed to define constant specific class body, which
    includes variables and methods, the constant type is not sharp enough to allow
    access to enum constant-specific values. Even in the case of generic enums, the
    static type of an enum constant is not sharp enough to capture the full type information
    of individual constants.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you started with how the enums in Java 5 introduced type safety
    to constants. You covered how enums can have state and behavior, not just the
    one that applies to all constants in an enum; but also specific to the constants.
    However, its not feasible to access the state and behavior that is specific to
    an enum constant, with the existing enums.
  prefs: []
  type: TYPE_NORMAL
- en: You covered how the enhanced enums can use generics and enable access to constant
    specific state and behaviour. With examples, you also covered how type parameters
    when added to enums facilitate sharper typing of enum constants.
  prefs: []
  type: TYPE_NORMAL
