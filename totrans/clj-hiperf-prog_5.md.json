["```java\n// Java example\nsynchronized (someObject) {\n    // do something\n}\n;; Clojure example\n(locking some-object\n  ;; do something\n  )\n\n```", "```java\n// Java example\npublic class Person {\n    volatile long age;\n}\n;; Clojure example\n(deftype Person [^:volatile-mutable ^long age])\n```", "```java\nuser=> (def a (volatile! 10))\n#'user/a\nuser=> (vswap! a inc)\n11\nuser=> @a\n11\nuser=> (vreset! a 20)\n20\nuser=> (volatile? a)\ntrue\n```", "```java\n(import 'java.util.concurrent.atomic.AtomicReference)\n(def ^AtomicReference x (AtomicReference. \"foo\"))\n(.compareAndSet x \"foo\" \"bar\")\n(import 'java.util.concurrent.atomic.AtomicInteger)\n(def ^AtomicInteger y (AtomicInteger. 10))\n(.getAndAdd y 5)\n```", "```java\nuser=> (def a (atom 0))\n#'user/a\nuser=> (swap! a inc)\n1\nuser=> @a\n1\nuser=> (compare-and-set! a 1 5)\ntrue\nuser=> (reset! a 20)\n20\n```", "```java\nuser=> (def a (atom 0 :meta {:foo :bar}))\nuser=> (meta a)\n{:foo :bar}\nuser=> (def age (atom 0 :validator (fn [x] (if (> x 200) false true))))\nuser=> (reset! age 200)\n200\nuser=> (swap! age inc)\nIllegalStateException Invalid reference state  clojure.lang.ARef.validate (ARef.java:33)\n```", "```java\n(def ^:const n-cpu (.availableProcessors (Runtime/getRuntime)))\n(def counters (vec (repeatedly n-cpu #(atom 0))))\n(defn inc! []\n  ;; consider java.util.concurrent.ThreadLocalRandom in Java 7+\n  ;; which is faster than Math/random that rand-int is based on\n  (let [i (rand-int n-cpu)]\n    (swap! (get counters i) inc)))\n(defn value []\n  (transduce (map deref) + counters))\n```", "```java\n(import 'java.util.concurrent.ThreadLocalRandom)\n(defn inc! []\n  (let [i (.nextLong (ThreadLocalRandom/current) n-cpu)]\n    (swap! (get counters i) inc)))\n```", "```java\n(def a (agent 0))\n;; invoke (inc 0) in another thread and set state of a to result\n(send a inc)\n@a  ; returns 1\n;; invoke (+ 1 2 3) in another thread and set state of a to result\n(send a + 2 3)\n@a  ; returns 6\n\n(shutdown-agents)  ; shuts down the thread-pools\n;; no execution of action anymore, hence no result update either\n(send a inc)\n@a  ; returns 6\n```", "```java\n(import 'clojure.lang.Agent)\nAgent/pooledExecutor  ; thread-pool for low latency actions\nAgent/soloExecutor  ; thread-pool for I/O actions\n(import 'java.util.concurrent.Executors)\n(def a-pool (Executors/newFixedThreadPool 10))  ; thread-pool with 10 threads\n(def b-pool (Executors/newFixedThreadPool 100)) ; 100 threads pool\n(def a (agent 0))\n(send-via a-pool a inc)  ; use 'a-pool' for the action\n(set-agent-send-executor! a-pool)  ; override default thread-pool\n(set-agent-send-off-executor! b-pool)  ; override default pool\n```", "```java\n(def g (agent 0))\n(send g (partial / 10))  ; ArithmeticException due to divide-by-zero\n@g  ; returns 0, because the error did not change the old state\n(send g inc)  ; throws the cached ArithmeticException\n(agent-error g)  ; returns (doesn't throw) the exception object\n(restart-agent g @g)  ; clears the suspension of the agent\n(agent-error g)  ; returns nil\n(send g inc)  ; works now because we cleared the cached error\n@g  ; returns 1\n(dotimes [_ 1000] (send-off g long-task))\n;; block for 100ms or until all actions over (whichever earlier)\n(await-for 100 g)\n(await g)  ; block until all actions dispatched till now are over\n```", "```java\n(def g (agent 0 :error-handler (fn [x] (println \"Found:\" x))))  ; incorrect arity\n(send g (partial / 10))  ; no error encountered because error-handler arity is wrong\n(def g (agent 0 :error-handler (fn [ag x] (println \"Found:\" x))))  ; correct arity\n(send g (partial / 10))  ; prints the message\n(set-error-handler! g (fn [ag x] (println \"Found:\" x)))  ; equiv of :error-handler arg\n(def h (agent 0 :error-mode :continue))\n(send h (partial / 10))  ; error encountered, but agent not suspended\n(send h inc)\n@h  ; returns 1\n(set-error-mode! h :continue)  ; equiv of :error-mode arg, other possible value :fail\n```", "```java\n(def r1 (ref [:a :b :c]))\n(def r2 (ref [1 2 3]))\n(alter r1 conj :d)  ; IllegalStateException No transaction running...\n(dosync (let [v (last @r1)] (alter r1 pop) (alter r2 conj v)))\n@r1  ; returns [:a :b]\n@r2  ; returns [1 2 3 :c]\n(dosync (ref-set r1 (conj @r1 (last @r2))) (ref-set r2 (pop @r2)))\n@r1  ; returns [:a :b :c]\n@r2  ; returns [1 2 3]\n```", "```java\n(def r (ref 0 :min-history 5 :max-history 10))\n(ref-history-count r)  ; returns 0, because no snapshot instances are queued so far\n(ref-min-history r)  ; returns 5\n(ref-max-history r)  ; returns 10\n(future (dosync (println \"Sleeping 20 sec\") (Thread/sleep 20000) (ref-set r 10)))\n(dosync (alter r inc))  ; enter this within few seconds after the previous expression\n;; The message \"Sleeping 20 sec\" should appear twice due to transaction-retry\n(ref-history-count r)  ; returns 2, the number of snapshot history elements\n(.trimHistory ^clojure.lang.Ref r)\n(ref-history-count r)  ; returns 0 because we wiped the history\n(ref-min-history r 10)  ; reset the min history\n(ref-max-history r 20)  ; reset the max history count\n```", "```java\n(def ^:dynamic *foo* \"bar\")\n(println *foo*)  ; prints bar\n(binding [*foo* \"baz\"] (println *foo*))  ; prints baz\n(binding [*foo* \"bar\"] (set! *foo* \"quux\") (println *foo*))  ; prints quux\n```", "```java\n(def t (atom 1 :validator pos?))\n(def g (agent 1 :validator pos?))\n(def r (ref 1 :validator pos?))\n(swap! t inc)  ; goes through, because value after increment (2) is positive\n(swap! t (constantly -3))  ; throws exception\n(def v 10)\n(set-validator! (var v) pos?)\n(set-validator! t (partial < 10)) ; throws exception\n(set-validator! g (partial < 10)) ; throws exception\n(set-validator! r #(< % 10)) ; works\n```", "```java\n(def t (atom 1))\n(defn w [key iref oldv newv] (println \"Key:\" key \"Old:\" oldv \"New:\" newv))\n(add-watch t :foo w)\n(swap! t inc)  ; prints \"Key: :foo Old: 1 New: 2\"\n```", "```java\n(import 'java.util.concurrent.ConcurrentHashMap)\n(def ^ConcurrentHashMap m (ConcurrentHashMap.))\n(.put m :english \"hi\")                    ; individual operation\n(.get m :english)                           ; individual operation\n(.putIfAbsent m :spanish \"alo\")    ; individual operation\n(.replace m :spanish \"hola\")         ; individual operation\n(.replace m :english \"hi\" \"hello\")  ; individual compare-and-swap atomic operation\n(.remove m :english)                     ; individual operation\n(.clear m)    ; aggregate operation\n(.size m)      ; aggregate operation\n(count m)    ; internally uses the .size() method\n;; aggregate operation\n(.putAll m {:french \"bonjour\" :italian \"buon giorno\"})\n(.keySet m)  ; aggregate operation\n(keys m)      ; calls CHM.entrySet() and on each pair java.util.Map.Entry.getKey()\n(vals m)       ; calls CHM.entrySet() and on each pair java.util.Map.Entry.getValue()\n```", "```java\n(import 'java.util.concurrent.ConcurrentLinkedQueue)\n(def ^ConcurrentLinkedQueue q (ConcurrentLinkedQueue.))\n(.add q :foo)\n(.add q :bar)\n(.poll q)  ; returns :foo\n(.poll q)  ; returns :bar\n```", "```java\n(defn foo5 [] (dotimes [_ 5] (println \"Foo\")))\n(defn barN [n] (dotimes [_ n] (println \"Bar\")))\n(.start (Thread. foo5))  ; prints \"Foo\" 5 times\n(.start (Thread. (partial barN 3)))  ; prints \"Bar\" 3 times\n```", "```java\n(import 'java.util.concurrent.Executors)\n(import 'java.util.concurrent.ExecutorService)\n(def ^ExecutorService a (Executors/newSingleThreadExecutor))  ; bounded pool\n(def ^ExecutorService b (Executors/newCachedThreadPool))  ; unbounded pool\n(def ^ExecutorService c (Executors/newFixedThreadPool 5))  ; bounded pool\n(.execute b #(dotimes [_ 5] (println \"Foo\")))  ; prints \"Foo\" 5 times\n```", "```java\n(import 'java.util.concurrent.Callable)\n(import 'java.util.concurrent.Future)\n(def ^ExecutorService e (Executors/newSingleThreadExecutor))\n(def ^Future f (.submit e (cast Callable #(reduce + (range 10000000)))))\n(.get f)  ; blocks until result is processed, then returns it\n```", "```java\n;; runs body in new thread\n(def f (future (println \"Calculating\") (reduce + (range 1e7))))\n(def g (future-call #(do (println \"Calculating\") (reduce + (range 1e7)))))  ; takes no-arg fn\n(future? f)                  ; returns true\n(future-cancel g)        ; cancels execution unless already over (can stop mid-way)\n(future-cancelled? g) ; returns true if canceled due to request\n(future-done? f)         ; returns true if terminated successfully, or canceled\n(realized? f)               ; same as future-done? for futures\n@f                              ; blocks if computation not yet over (use deref for timeout)\n```", "```java\n(let [f (future (println \"[f] Before sleep\")\n                (Thread/sleep 2000)\n                (println \"[f] After sleep\")\n                2000)]\n  (Thread/sleep 1000)\n  (future-cancel f)\n  (future-cancelled? f))\n;; [f] Before sleep  ← printed message (second message is never printed)\n;; true  ← returned value (due to future-cancelled?)\n```", "```java\n(def p (promise))\n(realized? p)  ; returns false\n@p  ; at this point, this will block until another thread delivers the promise\n(deliver p :foo)\n@p  ; returns :foo (for timeout use deref)\n```", "```java\n(pmap (partial reduce +)\n        [(range 1000000)\n         (range 1000001 2000000)\n         (range 2000001 3000000)])\n```"]