- en: '*Chapter 6*: Tackling Different Kinds of JOINs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The SQL `JOIN` clause represents one of the most used SQL features. From the
    well-known `INNER` and `OUTER JOIN` clauses, the fictional Semi and Anti Join,
    to the fancy `LATERAL` join, this chapter is a comprehensive set of examples meant
    to help you practice a wide range of `JOIN` clauses via the jOOQ DSL API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics of this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Practicing the most popular types of JOINs (`CROSS`, `INNER`, and `OUTER`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SQL `USING` and jOOQ `onKey()` shortcuts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practicing more types of `JOINs` (Implicit, Self, `NATURAL`, `STRAIGHT`, Semi,
    Anti, and `LATERAL`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter06](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Practicing the most popular types of JOINs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By most popular types of `JOIN` statements we are referring to `CROSS JOIN`,
    `INNER JOIN`, `LEFT JOIN`, `RIGHT JOIN`, and `FULL JOIN`. Let's tackle each of
    them via the jOOQ DSL API, starting with the most basic type of `JOIN`.
  prefs: []
  type: TYPE_NORMAL
- en: CROSS JOIN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`CROSS JOIN` is the most basic type of `JOIN` that gets materialized in a Cartesian
    product. Having two tables, `A` and `B`, the `CROSS JOIN` operation between them
    is represented as `A x B`, and practically, it means the combination of every
    row from `A` with every row from `B`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In jOOQ, `CROSS JOIN` can be rendered by enlisting the tables in the `FROM`
    clause (non`-ANSI JOIN` syntax) or via the `crossJoin()` method that renders the
    `CROSS JOIN` keywords (`ANSI JOIN` syntax). Here is the first case â€“ let''s `CROSS
    JOIN` the `OFFICE` and `DEPARTMENT` tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this query doesn''t expose explicitly or clearly, its intention of using
    `CROSS JOIN` is not as friendly as the following one, which uses the jOOQ `crossJoin()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `crossJoin()` method renders the `CROSS JOIN` keywords (`ANSI JOIN`
    syntax), which clearly communicate our intentions and remove any potential confusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Since some offices have `NULL` values for `CITY` and/or `COUNTRY` columns,
    we can easily exclude them from the `OFFICE x DEPARTMENT` via a predicate. Moreover,
    just for fun, we may prefer to concatenate the results as *city, country: department*
    (for example, *San Francisco, USA: Advertising*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Basically, once we've added a predicate, this becomes `INNER JOIN`, as discussed
    in the following section. More examples are available in the bundled code as *CrossJoin*.
  prefs: []
  type: TYPE_NORMAL
- en: INNER JOIN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`INNER JOIN` (or simply `JOIN`) represents a Cartesian product filtered by
    some predicate commonly placed in the `ON` clause. So, with the `A` and `B` tables,
    `INNERJOIN` returns the rows of `A x B` that validate the specified predicate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In jOOQ, we render `INNER JOIN` via `innerJoin()` (or simply `join()`, if omitting
    `INNER` is supported by your database vendor) and the `on()` methods. Here is
    an example that applies `INNER JOIN` between `EMPLOYEE` and `OFFICE` to fetch
    employee names and the cities of their offices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The rendered SQL for the MySQL dialect is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: By default, jOOQ doesn't render the optional `INNER` keyword. But, you can alter
    this default via the `withRenderOptionalInnerKeyword()` setting and the argument
    `RenderOptionalKeyword.ON`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In jOOQ, chaining multiple `JOIN`s is quite easy. For example, fetching the
    managers and their offices requires two `INNER JOIN` clauses, since between `MANAGER`
    and `OFFICE`, we have a many-to-many relationship mapped by the `MANAGER_HAS_OFFICE`
    junction table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In these examples, we called the jOOQ join method on `org.jooq.SelectFromStep`
    and the rendered SQL for PostgreSQL dialect is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'But, for convenience, we can call the join method directly after the `FROM`
    clause on `org.jooq.Table`. In such case, we obtain a nested fluent code as below
    (feel free to use the approach that you find most convenient):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The rendered SQL for the PostgreSQL dialect is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's talk about `OUTER JOIN`.
  prefs: []
  type: TYPE_NORMAL
- en: OUTER JOIN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While `INNER JOIN` returns only the combinations that pass the `ON` predicate,
    `OUTER JOIN` will also fetch rows that have no match on the left-hand side (`LEFT`
    [`OUTER`] `JOIN`) or right-hand side (`RIGHT` [`OUTER`] `JOIN`) of the join operation.
    Of course, we have to mention here `FULL` [`OUTER`] `JOIN` as well. This fetches
    all rows from both sides of the join operation.
  prefs: []
  type: TYPE_NORMAL
- en: The jOOQ API renders `OUTER JOIN` via `leftOuterJoin()`, `rightOuterJoin()`,
    and `fullOuterJoin()`. Since the `OUTER` keyword is optional, we can omit it via
    the analogs, `leftJoin()`, `rightJoin()`, and `fullJoin()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s fetch all employees (on the left-hand side) and their sales
    (on the right-hand side). By using `LEFT` [`OUTER`] `JOIN`, we retain all employees,
    even if they have no sales:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to retain only the employees that have no sales, then we can rely
    on an exclusive `LEFT` [`OUTER`] `JOIN` by adding a `WHERE` clause that excludes
    all matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The rendered SQL for the SQL Server dialect is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prefer to use the Oracle (+) symbol shorthand for performing `OUTER
    JOIN` then check this example of an `LEFT [OUTER] JOIN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'And, the Oracle SQL is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: By default, jOOQ render the optional `OUTER` keyword for both, `leftOuterJoin()`
    and `leftJoin()`. Alter this default via the `withRenderOptionalOuterKeyword()`
    setting and the argument `RenderOptionalKeyword.ON`.
  prefs: []
  type: TYPE_NORMAL
- en: In the bundled code, you can practice more examples, including `RIGHT`/`FULL`
    [`OUTER`] `JOIN`. For MySQL, which doesn't support `FULL` [`OUTER`] `JOIN`, we
    wrote some emulation code based on the `UNION` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: A special case of `OUTER JOIN` is represented by Oracle's partitioned `OUTER
    JOIN`.
  prefs: []
  type: TYPE_NORMAL
- en: PARTITIONED OUTER JOIN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A special case of `OUTER JOIN` is represented by the Oracle's partitioned `OUTER
    JOIN`. Such a join represents an extension of the classical `OUTER JOIN` syntax
    and is applied to each logical partition defined via an expression in the `PARTITION
    BY` clause. A partitioned `OUTER JOIN` returns a `UNION` of the outer joins of
    each of the partitions in the partitioned table (logically partitions) with the
    table on the other side of the join.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioned outer joins are specific to Oracle and they allow us to do the same
    "densifying" (fill gaps in sparse data) of data using a quite convenient syntax
    and an efficient Execution Plan.
  prefs: []
  type: TYPE_NORMAL
- en: 'A classical scenario where the Oracle''s partitioned `OUTER JOIN` can be used
    sounds like this: write a query returning the sales of every employee (*Sales
    Representative*) in every fiscal year while taking into account that some employees
    had no sales in some years - fill gaps in sparse data with 0\. For instance, if
    we try to see the sales of all employees (*Sales Representative*) grouped by fiscal
    year via a trivial `JOIN` then we obtain some gaps in data as in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 â€“ Fill gaps in sparse data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_6.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 â€“ Fill gaps in sparse data
  prefs: []
  type: TYPE_NORMAL
- en: 'In figure (a) is what we can easily get from a trivial `JOIN`, while in figure
    (b) is what we plan to get. So, we want to see all the *Sales Representative*
    even if they donâ€™t have sales in certain years. This is a job for Oracle partitioned
    `OUTER JOIN` where the logical partition is `FISCAL_YEAR`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you can express/emulate this query without partitioned `OUTER JOIN`,
    but for this you have to check out the application *PartitionedOuterJoin*.
  prefs: []
  type: TYPE_NORMAL
- en: The SQL USING and jOOQ onKey() shortcuts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've covered the typical `JOIN`s that are commonly used in daily work.
    Before we continue with more types of `JOIN`s, let's introduce two convenient
    shortcuts that are useful for expressing more concise `JOIN`s.
  prefs: []
  type: TYPE_NORMAL
- en: SQL JOIN â€¦ USING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In certain cases, the SQL `JOIN â€¦ USING` clause can be a convenient alternative
    to the classical `JOIN â€¦ ON` clause. Instead of specifying a condition in the
    `JOIN â€¦ ON` clause, we enlist the `JOIN â€¦ USING` clause in the set of fields (columns)
    whose names are common to both tables â€“ the left-hand side table and right-hand
    side table of a `JOIN` operation. In jOOQ, the `USING` clause is rendered via
    the `using()` method, as shown in the following example. The `EMPLOYEE_NUMBER`
    column mentioned in `using()` is the primary key of the `EMPLOYEE` table and the
    foreign key of the `SALE` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'So, `using(EMPLOYEE.EMPLOYEE_NUMBER)` is a less verbose representation of `on(EMPLOYEE.EMPLOYEE_NUMBER.eq(SALE.EMPLOYEE_NUMBER)`,
    and the rendered SQL for the MySQL dialect is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'But we can use any other field(s). Here is the `USING` clause for a composite
    primary key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, this is a `USING` clause for two fields that are not primary/foreign
    keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Note that `using()` without arguments will render `ON TRUE`, so no filter is
    applied to the join operation. Practice the complete examples via the *JoinUsing*
    bundled application. Next, let's introduce a very handy tool from jOOQ named `onKey()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, as I said, `USING` fits only for certain cases. Lukas Eder enforces
    this statement: "*The* `USING` *clause leads to a bit more difficult to maintain
    queries when queries get complex, so it''s generally not recommended. It''s less
    type-safe (in jOOQ). When you rename a column, your jOOQ code might still compile.
    It wouldn''t if you had been using* `ON`*. When you add a column that accidentally
    matches a column referenced from* `USING`*, you might get unintended consequences
    in unrelated queries. Example,* `A JOIN B USING (X) JOIN C USING (Y)`*. This assumes*
    `A(X)`*,* `B(X, Y)`*,* `C(Y)`*. So, what happens if you add* `A(Y)`*? A runtime
    exception, because* `Y` *is now ambiguous. Or, even worse: What happens if you
    add* `A(Y)` *but remove* `B(Y)`*? No runtime exception, but possibly (and quietly)
    wrong query. Moreover, in Oracle, columns referenced from* `USING` *can no longer
    be qualified in the query. In conclusion,* `USING` *can be useful for quick and
    dirty ad-hoc querying, just like* `NATURAL`*. But I wouldn''t use it in production
    queries. Especially, because implicit joins work much better in jOOQ.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*The essence here is always the fact (and this is frequently misunderstood)
    that joins are *binary* operators between two tables. For instance,* `A JOIN B
    USING (X) JOIN C USING (Y)` *is just short for* `(A JOIN B USING (X)) JOIN C USING
    (Y)`*, so* `C` *is joined to* `(A JOIN B USING (X)`*) not to B alone. This is
    also the case for* `onKey()`*.*"'
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ onKey()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whenever we join a well-known foreign key relationship, we can rely on the
    jOOQ `onKey()` method. Since this is quite easy to understand for a simple foreign
    key, let''s pick up a composite foreign key containing two fields. Check out the
    following `ON` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'The (`CUSTOMER_NUMBER`, `CHECK_NUMBER`) represents a composite foreign key
    in the `BANK_TRANSACTION` table. jOOQ allows us to replace this verbose `ON` clause
    with the `onKey()` method without arguments, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Really cool, isn''t it? jOOQ infers the `ON` condition on our behalf, and the
    rendered SQL for MySQL is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'In case of ambiguity caused by multiple keys'' potential matches, we can also
    rely on foreign keys'' field references via `onKey(TableField<?,?>... tfs)`, or
    the generated foreign keys'' references via `onKey(ForeignKey<?,?> fk)`. For instance,
    in order to avoid the `DataAccessException`*: Key ambiguous between tables X and
    Y* exception, while joining table X with table Y via `onKey()`, we can explicitly
    indicate the foreign key that should be used as follows (here, via the SQL Server
    generated foreign key reference, `jooq.generated.Keys.PRODUCTLINEDETAIL_PRODUCTLINE_FK)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the rendered SQL is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'But despite its appeal, this method can lead into issues. As Lukas Eder shared
    here: "*The* `onKey()` *method is not type-safe, and can break in subtle ways,
    when tables are modified.*"'
  prefs: []
  type: TYPE_NORMAL
- en: More examples are available in the application named *JoinOnKey*. For now, let's
    continue with more types of `JOIN`s.
  prefs: []
  type: TYPE_NORMAL
- en: Practicing more types of JOINs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, let's cover more `JOIN`s, such as Implicit/Self Joins, `NATURAL JOIN`,
    `STRAIGHT JOIN`, Semi/Anti Joins, and `LATERAL` Joins. Let's continue with Implicit/Self
    Joins.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit and Self Join
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implicit and Self Joins can be easily expressed in jOOQ via type-safe navigation
    methods produced by the jOOQ generator in classes that mirror the database tables.
    Let's dissect this aspect of Implicit Joins.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit Join
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As an example, an explicit join that fetches a parent table''s column from
    a given child table can be expressed as an Implicit Join. Here is the explicit
    join:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the less verbose Implicit Join version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'If we check the generated Java-based schema, then we notice that the `jooq.generated.tables.Employee`
    class mirroring the `EMPLOYEE` table contains a method named `office()` especially
    for expressing this syntax. Here is the previous Implicit Join, written via the
    jOOQ DSL API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example that chains several navigation methods to express an
    Implicit Join, starting from the `ORDERDETAIL` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'The names of these navigation methods correspond to the parent table name.
    Here is another example of writing an Implicit Join in a m:n relationship. If
    we think to an m:n relationship from the relationship table then we see two to-one
    relationships that we exploit as follows (between `MANAGER` and `OFFICE` there
    is a many-to-many relationship):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the Implicit Joins covered in this section are *foreign key path-based*.
    Most probably, you are also familiar with Implicit Joins where you enlist all
    the tables you want to fetch data from in the `FROM` clause followed by the `WHERE`
    clause having conditions based on primary/foreign keys values for filtering the
    result. Here is an example of jOOQ code for such an Implicit Join:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, note that these kind of Implicit Joins are quite prone to human
    mistakes, and it is better to rely on the ANSI JOIN syntax by explicitly using
    the `JOIN` keyword. Let me take advantage of this context to say that whenever
    you have old code that should be updated to an ANSI JOIN, you can rely on jOOQ.
    Besides the jOOQ DSL API, you can check out [https://www.jooq.org/translate](https://www.jooq.org/translate),
    and for a quick and neat guide, read this article: [https://blog.jooq.org/2020/11/17/automatically-transform-oracle-style-implicit-joins-to-ansi-join-using-jooq/](https://blog.jooq.org/2020/11/17/automatically-transform-oracle-style-implicit-joins-to-ansi-join-using-jooq/).'
  prefs: []
  type: TYPE_NORMAL
- en: In the absence of explicit foreign keys in the schema for whatever reasons (including
    the tables are actually views), users of the commercial editions can specify synthetic
    foreign keys to the Code Generator as you can see in [*Chapter 11*](B16833_11.xhtml#_idTextAnchor209),
    *jOOQ keys*.
  prefs: []
  type: TYPE_NORMAL
- en: Please, consider the jOOQ manual and [https://github.com/jOOQ/jOOQ/issues/12037](https://github.com/jOOQ/jOOQ/issues/12037)
    for covering the limitations of Implicit Joins support. Leaving the context of
    Implicit Joins, the jOOQ navigation methods are useful for expressing Self Joins
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Self Join
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whenever a table is joined with itself, we can rely on Self Joins. Writing
    a Self Join is done via a navigation method that has the same name as the table
    itself. For example, here is a Self Join that fetches a result set containing
    the name of each employee and the name of their boss (`EMPLOYEE.REPORTS_TO`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, *ImplicitAndSelfJoin*, you can practice more examples with
    implicit and Self Joins.
  prefs: []
  type: TYPE_NORMAL
- en: NATURAL JOIN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, we used the `JOIN â€¦ USING` syntax by enlisting the fields whose names
    are common to both tables (the left and right tables of a join operation) and
    should be rendered in the condition of the `ON` clause. Alternatively, we can
    rely on `NATURAL JOIN`, which doesn't require any `JOIN` criteria. This leads
    to a minimalist syntax but also makes our query a sword with two edges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, `NATURAL JOIN` automatically identifies all the columns that share
    the same name from both joined tables and use them to define the `JOIN` criteria.
    This can be quite useful when the primary/foreign keys columns share the same
    names, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: The jOOQ API for `NATURAL JOIN` relies on the `naturalJoin()` method. Next to
    this method, we have the methods corresponding to `LEFT`/`RIGHT`/`FULL NATURAL
    OUTER JOIN` as `naturalLeftOuterJoin()`, `naturalRightOuterJoin()`, and `naturalFullOuterJoin()`.
    Also, you may like to read the article at [https://blog.jooq.org/2020/08/05/use-natural-full-join-to-compare-two-tables-in-sql/](https://blog.jooq.org/2020/08/05/use-natural-full-join-to-compare-two-tables-in-sql/)
    about using `NATURAL FULL JOIN` to compare two tables. You can see all these at
    work in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, the rendered SQL for the PostgreSQL dialect is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: The `EMPLOYEE` and `SALE` tables share a single column name, `EMPLOYEE_NUMBER`
    â€“ the primary key in `EMPLOYEE` and the foreign key in `SALE`. This column is
    used behind the scenes by `NATURAL JOIN` for filtering the result, which is the
    expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, remember that `NATURAL JOIN` picks up all columns that share the same
    name, not only the primary/foreign key columns, therefore this `JOIN` may produce
    undesirable results. For instance, if we join the `PAYMENT` and `BANK_TRANSACTION`
    tables, then `NATURAL JOIN` will use the common composite key (`CUSTOMER_NUMBER`,
    `CHECK_NUMBER`) but will also use the `CACHING_DATE` column. If this is not our
    intention, then `NATURAL JOIN` is not the proper choice. Expecting that only the
    (`CUSTOMER_NUMBER`, `CHECK_NUMBER`) is used is a wrong assumption, and it is recommended
    to rely on the `ON` clause or the jOOQ `onKey()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if we expect that only the `CACHING_DATE` column will be
    used (which is hard to believe), then the `USING` clause can be a good alternative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: The `USING` clause is useful if we need any custom combination of columns that
    share the same name. On the other hand, `NATURAL JOIN` is considerably more prone
    to issues, since any schema changes that lead to a new matching column name will
    cause `NATURAL JOIN` to combine that new column as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also worth keeping in mind that Oracle doesn''t accept that the columns
    used by `NATURAL JOIN` for filtering the result have qualifiers (*ORA-25155 â€“
    column used in NATURAL join cannot have qualifiers*). In this context, using the
    jOOQ Java-based schema with default settings comes with some issues. For instance,
    the expression `ctx.select().from(EMPLOYEE).naturalJoin(SALE)â€¦` results in ORA-25155,
    since, by default, jOOQ qualifies the columns rendered in `SELECT`, including
    the common `EMPLOYEE_NUMBER` column, which is used by `NATURAL JOIN`. A quick
    workaround consists of explicitly rendering `*` via `asterisk()` instead of the
    columns list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can avoid using Java-based schema and write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: Unqualified references to a common column are considered to belong to the left-hand
    side table if the join is `INNER`/`LEFT OUTER JOIN`, or to the right-hand side
    table if it is `RIGHT OUTER JOIN`.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the Oracle `NATURAL JOIN` is the same as the Oracle proprietary
    Equi Join with a join condition (an Equi Join relies on a join condition containing
    an equality operator).
  prefs: []
  type: TYPE_NORMAL
- en: As usual, you can practice all these examples and more in the bundled code.
    The application is named *NaturalJoin*. Next, let's tackle `STRAIGHT JOIN`.
  prefs: []
  type: TYPE_NORMAL
- en: STRAIGHT JOIN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right from the start, we have to mention that `STRAIGHT JOIN` is specific to
    MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, `STRAIGHT JOIN` instructs MySQL to always read the left-hand side
    table before the right-hand side table of `JOIN`. In this context, `STRAIGHT JOIN`
    may be useful to affect the execution plan chosen by MySQL for a certain `JOIN`.
    Whenever we consider that the query optimizer has put the `JOIN` tables in the
    wrong order, we can affect this order via `STRAIGHT JOIN`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s assume that the `PRODUCT` table has 5,000 rows, the `ORDERDETAIL`
    table has 200,000,000 rows, the `ORDER` table has 3,000 rows, and we have a join,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, MySQL may or may not take into account the size of the intersection between
    `ORDER.ORDER_ID` and `ORDERDETAIL.ORDER_ID` versus `PRODUCT.PRODUCT_ID` and `ORDERDETAIL.PRODUCT_ID`.
    If the join between `ORDERDETAIL` and `ORDER` returns just as many rows as `ORDERDETAIL`,
    then this is not an optimal choice. And if starting the join with `PRODUCT` will
    filter down `ORDERDETAIL` to as many rows as `PRODUCT`, then this will be an optimal
    choice. This behavior can be enforced via the jOOQ `straightJoin()` method, which
    renders a `STRAIGHT JOIN` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'In Oracle, the order of `JOINs` can be altered via `/*+LEADING(a, b)*/` hint.
    In jOOQ this kind of hints can be passed via `hint()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: 'In SQL Server this can be accomplished via `OPTION (FORCE ORDER)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: 'Nevertheless, as Lukas Eder shared here: "*MySQL''s problems should have been
    made significantly less severe since they added hash join support. In any case,
    I think a disclaimer about premature optimization using hints could be added.
    With reasonable optimizers, hints should almost never be necessary anymore.*"'
  prefs: []
  type: TYPE_NORMAL
- en: You can see the rendered SQL by running the *StraightJoin* application available
    for MySQL. Next, let's cover Semi and Anti Joins.
  prefs: []
  type: TYPE_NORMAL
- en: Semi and Anti Joins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Semi and Anti Joins are two of the relational algebra operators that don't have
    a direct correspondent in SQL syntax. Apart from the case of using Cloudera Impala,
    which provides a native syntax for Semi/Anti Joins, we have to rely on workarounds.
    In this context, Semi Join can be emulated via `EXISTS`/`IN` and Anti Join via
    `NOT EXISTS`/`NOT IN` predicates.
  prefs: []
  type: TYPE_NORMAL
- en: Since Semi/Anti Joins can be emulated via (`NOT`) `EXISTS`/(`NOT`) `IN` predicates,
    it means that we don't really join the right-hand side. In the case of a Semi
    Join, we just fetch the rows from the first table (left-hand side table) where
    there are matches found in the second table (right-hand side table), while in
    the case of Anti Join, we do exactly the opposite of the Semi Join; we just fetch
    the rows from the first table (the left-hand side table) where there are no matches
    found in the second table (the right-hand side table).
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s fetch the names of all `EMPLOYEE` that have `CUSTOMER`.
    Accomplishing this via a Semi Join emulated via the `EXISTS` predicate can be
    done in SQL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: 'In the bundled code, you can see how to express this SQL via the jOOQ DSL API.
    In addition, you can practice this use case emulated via the `IN` predicate. For
    now, let''s use the jOOQ approach, which fills up the gap in expressiveness and
    enforces the clear intention of using a Semi Join via the `leftSemiJoin()` method.
    This jOOQ method saves us a lot of headaches â€“ having neat code that is always
    emulated correctly in different SQL dialects and no brain-teasing in handling
    complex cases such as nesting `EXISTS`/`IN` predicates will make you fall in love
    with this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: This is just awesome! Check out the bundled code, *SemiAndAntiJoin*, to see
    more examples about chaining and/or nesting Semi Joins via the jOOQ DSL API. Every
    time, check out the rendered SQL and give a big thanks to jOOQ for it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s focus on Anti Join. The Anti Join is the opposite of the Semi
    Join and is emulated via the `NOT EXISTS`/`NOT IN` predicates. For example, let''s
    write an SQL representing an Anti Join to fetch the names of all `EMPLOYEE` that
    don''t have `CUSTOMER` via `NOT EXISTS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, you can see how to express this SQL via the jOOQ DSL API
    and the same example based on the `NOT IN` predicate. Nevertheless, I strongly
    encourage you to avoid `NOT IN` and opt for `NOT EXISTS`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Most probably, you already know this, but just as a quick reminder, let''s
    mention that the `EXISTS` and `IN` predicates are equivalent, but the `NOT EXISTS`
    and `NOT IN` predicates are not because the `NULL` values (if any) lead to undesirable
    results. For more details, please read this short but essential article: [https://blog.jooq.org/2012/01/27/sql-incompatibilities-not-in-and-null-values/](https://blog.jooq.org/2012/01/27/sql-incompatibilities-not-in-and-null-values/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, and even better, use the jOOQ Anti Join represented by the `leftAntiJoin()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: Check out the rendered SQL and more examples in the application named *SemiAndAntiJoin*.
  prefs: []
  type: TYPE_NORMAL
- en: A typical problem solved by Anti Joins refers to relational division or simply
    division. This is another operator of relational algebra without a direct correspondent
    in SQL syntax. In short, division is the inverse of the `CROSS JOIN` operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s consider the `ORDERDETAIL` and `TOP3PRODUCT` tables. While
    `CROSS JOIN` gives us the Cartesian product as `ORDERDETAIL x TOP3PRODUCT`, the
    division gives us `ORDERDETAIL Ã· TOP3PRODUCT` or `TOP3PRODUCT Ã· ORDERDETAIL`.
    Let''s assume that we want the IDs of all orders that contain at least three products
    contained in `TOP3PRODUCT`. This kind of task is a division and is commonly solved
    via two nested Anti Joins. The jOOQ code that solves this problem is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: 'This is cool and much less verbose than writing the same thing via `NOT EXISTS`.
    But that''s not all! jOOQ comes with an even more elegant solution that can be
    used to express divisions. This solution uses the `divideBy()` and `returning()`
    methods to express a division in a concise, expressive, and very intuitive way.
    Check out the following code that can replace the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: Check out this example and another one about finding the orders that contain
    at least the products of a given order in the *BootAntiJoinDivision* application.
  prefs: []
  type: TYPE_NORMAL
- en: 'As Lukas Eder pointed out here: "*If you want to see how x is the inverse of
    Ã·, you can choose two different tables, for instance A x B = C and C Ã· B = A*".'
  prefs: []
  type: TYPE_NORMAL
- en: Next, letâ€™s cover the `LATERAL`/`APPLY` Join.
  prefs: []
  type: TYPE_NORMAL
- en: LATERAL/APPLY Join
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last topic covered in this chapter refers to the `LATERAL`/`APPLY` Join.
    This is part of standard SQL and is quite similar to a correlated subquery that
    allows us to return more than one row and/or column or to the Java `Stream.flatMap()`.
    Mainly, a lateral inner subquery sits on the right-hand side of `JOIN` (`INNER`,
    `OUTER`, and so on), and it can be materialized as a classical subquery, a derived
    table, a function call, an array unnesting, and so on. Its power consists of the
    fact that it can refer to (or *laterally* access) tables/columns from the left-hand
    side to determine which rows to retain. A `LATERAL` Join iterates through each
    row on the left-hand side, evaluating the inner subquery (the right-hand side)
    for each row, like a typical for-each loop. The rows returned by the inner subquery
    are retained to the result of the join with the outer query. The `LATERAL` keyword
    is essential because, without it, each subquery is evaluated separately (independently)
    and can't access columns from the left-hand side (from the `FROM` clause).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, selecting all `OFFICE` that has `DEPARTMENT` can be done via the
    `LATERAL` Join:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the jOOQ DSL API provides the `lateral()` method for shaping
    `LATERAL` Joins. The SQL rendered for the MySQL dialect is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: 'Without an explicit `JOIN`, you would expect that `CROSS JOIN` (`INNER JOIN
    ON true / INNER JOIN IN 1=1`) is automatically inferred. Writing the previous
    query via `LEFT OUTER JOIN LATERAL` requires a dummy `ON true / ON 1=1` clause,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: A `LATERAL` Join has several use cases where it fits like a glove. For instance,
    it can be used for lateral unnesting of the array columns, for finding TOP-N per
    *Foo* (joining TOP-N query to a normal table), and it works nicely in combination
    with the so-called table-valued functions.
  prefs: []
  type: TYPE_NORMAL
- en: Unnesting the array columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are an Oracle or PostgreSQL fan, then you know about their support for
    nested arrays (or nested collections). In PostgreSQL, we can declare a column
    of type array exactly as any other type but suffixed with square brackets â€“ `[]`
    (for example, `text[]`). Since Oracle recognizes only nominal array types, we
    have to create them first via `CREATE TYPE`. I will not insist on this pure SQL
    aspect, since our goal is to jump into jOOQ DSL API usage.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's consider the `DEPARTMENT` table, which has an array column named `TOPIC`.
    For each department, we have a list of topics (area of activities), and more departments
    may have interleaved topics. For instance, for the `Sale` department, we have
    four topics â€“ `'commerce'`, `'trade'`, `'sellout'`, and `'transaction'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s assume that we want to fetch the departments that have in common
    the `''commerce''` and `''business''` topics. For this, we can write a `LATERAL`
    Join via the jOOQ DSL API using the `lateral()` method, and we unnest the array
    (transform the array into a useable/queryable table) via the `unnest()` method,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: 'For the PostgreSQL dialect, the rendered SQL is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: Note that MySQL and SQL Server don't have support for array (collection) columns,
    but we can still declare anonymously typed arrays that can be unnested via the
    same jOOQ `unnest()` method. Next, let's talk about solving TOP-N per *Foo* tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Solving TOP-N per Foo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While solving TOP-N problems over the entire dataset can be quite challenging,
    solving TOP-N per *Foo* problems can be really hard to digest. Fortunately, the
    `LATERAL` Join fits perfectly for these kinds of problems. For instance, fetching
    TOP-3 sales per employee can be expressed in jOOQ as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: 'The fact that the `LATERAL` Join allows us to access the `EMPLOYEE.EMPLOYEE_NUMBER`
    field/column does all the magic! The rendered SQL for MySQL dialect is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: 'If we think of the derived table obtained via the inner `SELECT` as a table-valued
    function that has the employee number as an argument, then, in Oracle, we can
    write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can use a `LATERAL` Join to call this function. The jOOQ code is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: 'The rendered SQL for Oracle is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TOP_THREE_SALES_PER_EMPLOYEE` static field was generated by the jOOQ generator
    and is basically an ordinary table placed in the `jooq.generated.tables` package
    under the name `TopThreeSalesPerEmployee`. It can be used in the `FROM` clause
    of `SELECT` like any other table. Nevertheless, note that we have access to a
    method named `call()`, which is used for calling (with arguments) this table-valued
    function. However, while most databases treat table-valued functions as ordinary
    tables, in Oracle, it is quite common to treat them as standalone routines. In
    this context, jOOQ has a flag setting that allows us to indicate whether table-valued
    functions should be treated as ordinary tables (`true`) or as plain routines (`false`).
    Depending on this setting, jOOQ places the generated code in tables-section or
    the routines-section. This setting is set to `true` in all supported databases
    except Oracle. To enable this, we have to set the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, programmatic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: While the `LATERAL` keyword (which, by the way, is a pretty confusing word)
    can be used in MySQL, PostgreSQL, and Oracle, it cannot be used in SQL Server.
    Actually, SQL Server and Oracle have support for `CROSS APPLY` and `OUTER APPLY`
    via the `APPLY` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: CROSS APPLY and OUTER APPLY
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Specific to T-SQL, `CROSS APPLY`, and `OUTER APPLY` use the more suggestive
    `APPLY` keyword, which suggests that we apply a function to each table row. Mainly,
    `CROSS APPLY` is the same thing as `CROSS JOIN LATERAL`, and `OUTER APPLY` is
    the same thing as `LEFT OUTER JOIN LATERAL`. This is exactly how jOOQ will emulate
    `CROSS`/`OUTER APPLY` when they are not supported (for example, in PostgreSQL).
  prefs: []
  type: TYPE_NORMAL
- en: 'I guess everyone agrees with Lukas Eder''s statement: "*I find APPLY much more
    intuitive, especially when cross applying a table valued function. T CROSS APPLY
    F (T.X) means we''re applying F to each row in T and create the cross product
    between T and the result of F. On the other hand, LATERAL is so weird, syntactically,
    especially this stupid requirement of writing ON TRUE all the time.*"'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning of this section, we wrote a `LATERAL` Join to select all `OFFICE`
    that has `DEPARTMENT`. Writing the same thing but using `CROSS APPLY` can be done
    via the jOOQ `crossApply()` method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: 'The render SQL for SQL Server is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing the previous query via `LEFT OUTER JOIN LATERAL` requires a dummy `ON
    true/1=1` clause, but using `OUTER APPLY` via the jOOQ `outerApply()` method eliminates
    this little inconvenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: 'And the SQL rendered for the SQL Server dialect is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: Done! In the bundled code, you can practice examples of `cross`/`outerApply()`
    and table-valued functions as well.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In the examples of this chapter, we have used `fooJoin(TableLike<?> table)`and
    `cross`/`outerApply(TableLike<?> table)`, but the jOOQ API also contains other
    flavors, such as `fooJoin(String sql)`, `cross`/`outerApply(String sql)`, `fooJoin(SQL
    sql)`, `cross`/`outerApply(SQL sql`), `fooJoin(String sql, Object... bindings)`,
    `cross`/`outerApply(String sql, Object... bindings)`, `fooJoin(String sql, QueryPart...
    parts)`, and `cross`/`outerApply(String sql, QueryPart... parts)`. All of them
    are available in the jOOQ documentation and are marked with `@PlainSQL`. This
    annotation points out methods/types that allow us to produce a `QueryPart` that
    renders "plain SQL" inside of an AST, which are covered in [*Chapter 16*](B16833_16.xhtml#_idTextAnchor315),
    *Tackling Aliases and SQL Templating*.
  prefs: []
  type: TYPE_NORMAL
- en: All the examples (and more) from this chapter can be found in the *LateralJoin*
    application. Take your time to practice each example.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered a comprehensive list of SQL `JOIN`s and how
    they can be expressed via the jOOQ DSL API. We started with the well-known `INNER`/`OUTER`/`CROSS
    JOIN`, continued with Implicit Joins, Self Joins, `NATURAL` and `STRAIGHT JOIN`s,
    and ended with Semi/Anti Joins, `CROSS APPLY`, `OUTER APPLY`, and `LATERAL` Joins.
    Also, among others, we covered the `USING` clause and the amazing jOOQ `onKey()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we tackle the jOOQ types, converters, and bindings.
  prefs: []
  type: TYPE_NORMAL
