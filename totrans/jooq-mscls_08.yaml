- en: '*Chapter 6*: Tackling Different Kinds of JOINs'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 6 章*：处理不同类型的 JOIN'
- en: The SQL `JOIN` clause represents one of the most used SQL features. From the
    well-known `INNER` and `OUTER JOIN` clauses, the fictional Semi and Anti Join,
    to the fancy `LATERAL` join, this chapter is a comprehensive set of examples meant
    to help you practice a wide range of `JOIN` clauses via the jOOQ DSL API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 的 `JOIN` 子句代表了最常用的 SQL 功能之一。从众所周知的 `INNER` 和 `OUTER JOIN` 子句，到虚构的半和反 JOIN，再到花哨的
    `LATERAL` JOIN，本章提供了一套全面的示例，旨在帮助您通过 jOOQ DSL API 练习各种 `JOIN` 子句。
- en: 'The topics of this chapter include the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题包括以下内容：
- en: Practicing the most popular types of JOINs (`CROSS`, `INNER`, and `OUTER`)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习最流行的 JOIN 类型（`CROSS`、`INNER` 和 `OUTER`）
- en: The SQL `USING` and jOOQ `onKey()` shortcuts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL 的 `USING` 和 jOOQ 的 `onKey()` 快捷方式
- en: Practicing more types of `JOINs` (Implicit, Self, `NATURAL`, `STRAIGHT`, Semi,
    Anti, and `LATERAL`)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习更多类型的 `JOINs`（隐式、自身、`NATURAL`、`STRAIGHT`、半、反和 `LATERAL`）
- en: Let's get started!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter06](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter06).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 GitHub 上找到：[https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter06](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter06)。
- en: Practicing the most popular types of JOINs
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习最流行的 JOIN 类型
- en: By most popular types of `JOIN` statements we are referring to `CROSS JOIN`,
    `INNER JOIN`, `LEFT JOIN`, `RIGHT JOIN`, and `FULL JOIN`. Let's tackle each of
    them via the jOOQ DSL API, starting with the most basic type of `JOIN`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过最流行的 `JOIN` 语句类型，我们指的是 `CROSS JOIN`、`INNER JOIN`、`LEFT JOIN`、`RIGHT JOIN`
    和 `FULL JOIN`。让我们通过 jOOQ DSL API 来解决每个问题，从最基本的 `JOIN` 类型开始。
- en: CROSS JOIN
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CROSS JOIN
- en: '`CROSS JOIN` is the most basic type of `JOIN` that gets materialized in a Cartesian
    product. Having two tables, `A` and `B`, the `CROSS JOIN` operation between them
    is represented as `A x B`, and practically, it means the combination of every
    row from `A` with every row from `B`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`CROSS JOIN` 是最基本的 `JOIN` 类型，它在笛卡尔积中实现。有两个表 `A` 和 `B`，它们之间的 `CROSS JOIN` 操作表示为
    `A x B`，实际上，这意味着 `A` 表的每一行与 `B` 表的每一行的组合。'
- en: 'In jOOQ, `CROSS JOIN` can be rendered by enlisting the tables in the `FROM`
    clause (non`-ANSI JOIN` syntax) or via the `crossJoin()` method that renders the
    `CROSS JOIN` keywords (`ANSI JOIN` syntax). Here is the first case – let''s `CROSS
    JOIN` the `OFFICE` and `DEPARTMENT` tables:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 jOOQ 中，`CROSS JOIN` 可以通过在 `FROM` 子句中列出表（非 `-ANSI JOIN` 语法）或通过 `crossJoin()`
    方法来渲染，该方法渲染 `CROSS JOIN` 关键字（`ANSI JOIN` 语法）。以下是第一种情况——让我们将 `OFFICE` 和 `DEPARTMENT`
    表进行 `CROSS JOIN`：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since this query doesn''t expose explicitly or clearly, its intention of using
    `CROSS JOIN` is not as friendly as the following one, which uses the jOOQ `crossJoin()`
    method:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此查询没有明确或清晰地表达其使用 `CROSS JOIN` 的意图，因此它不如以下使用 jOOQ `crossJoin()` 方法的查询友好：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using the `crossJoin()` method renders the `CROSS JOIN` keywords (`ANSI JOIN`
    syntax), which clearly communicate our intentions and remove any potential confusion:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `crossJoin()` 方法渲染 `CROSS JOIN` 关键字（`ANSI JOIN` 语法），这清楚地传达了我们的意图，并消除了任何潜在的混淆：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since some offices have `NULL` values for `CITY` and/or `COUNTRY` columns,
    we can easily exclude them from the `OFFICE x DEPARTMENT` via a predicate. Moreover,
    just for fun, we may prefer to concatenate the results as *city, country: department*
    (for example, *San Francisco, USA: Advertising*):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一些办公室的 `CITY` 和/或 `COUNTRY` 列具有 `NULL` 值，我们可以通过谓词轻松排除它们从 `OFFICE x DEPARTMENT`
    中。此外，仅为了好玩，我们可能更喜欢将结果连接为 *城市，国家：部门*（例如，*旧金山，美国：广告*）：
- en: '[PRE10]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Basically, once we've added a predicate, this becomes `INNER JOIN`, as discussed
    in the following section. More examples are available in the bundled code as *CrossJoin*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，一旦我们添加了一个谓词，这就会变成 `INNER JOIN`，正如以下章节所讨论的。更多示例可以在捆绑的代码中的 *CrossJoin* 中找到。
- en: INNER JOIN
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: INNER JOIN
- en: '`INNER JOIN` (or simply `JOIN`) represents a Cartesian product filtered by
    some predicate commonly placed in the `ON` clause. So, with the `A` and `B` tables,
    `INNERJOIN` returns the rows of `A x B` that validate the specified predicate.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`INNER JOIN`（或简称 `JOIN`）表示通过某些谓词进行筛选的笛卡尔积，这些谓词通常放在 `ON` 子句中。因此，对于 `A` 和 `B`
    表，`INNER JOIN` 返回满足指定谓词的 `A x B` 的行。'
- en: 'In jOOQ, we render `INNER JOIN` via `innerJoin()` (or simply `join()`, if omitting
    `INNER` is supported by your database vendor) and the `on()` methods. Here is
    an example that applies `INNER JOIN` between `EMPLOYEE` and `OFFICE` to fetch
    employee names and the cities of their offices:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在jOOQ中，我们通过`innerJoin()`（如果您的数据库供应商支持省略`INNER`，则可以简单地使用`join()`）和`on()`方法渲染`INNER
    JOIN`。以下是一个在`EMPLOYEE`和`OFFICE`之间应用`INNER JOIN`以获取员工姓名及其办公室城市的示例：
- en: '[PRE15]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The rendered SQL for the MySQL dialect is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MySQL方言的渲染SQL如下：
- en: '[PRE21]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By default, jOOQ doesn't render the optional `INNER` keyword. But, you can alter
    this default via the `withRenderOptionalInnerKeyword()` setting and the argument
    `RenderOptionalKeyword.ON`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，jOOQ不会渲染可选的`INNER`关键字。但是，您可以通过`withRenderOptionalInnerKeyword()`设置和`RenderOptionalKeyword.ON`参数来更改此默认设置。
- en: 'In jOOQ, chaining multiple `JOIN`s is quite easy. For example, fetching the
    managers and their offices requires two `INNER JOIN` clauses, since between `MANAGER`
    and `OFFICE`, we have a many-to-many relationship mapped by the `MANAGER_HAS_OFFICE`
    junction table:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在jOOQ中，链式调用多个`JOIN`操作相当简单。例如，获取经理及其办公室需要两个`INNER JOIN`子句，因为`MANAGER`和`OFFICE`之间有一个多对多关系，由`MANAGER_HAS_OFFICE`连接表映射：
- en: '[PRE28]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In these examples, we called the jOOQ join method on `org.jooq.SelectFromStep`
    and the rendered SQL for PostgreSQL dialect is:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，我们在`org.jooq.SelectFromStep`上调用jOOQ的连接方法，对于PostgreSQL方言的渲染SQL如下：
- en: '[PRE37]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'But, for convenience, we can call the join method directly after the `FROM`
    clause on `org.jooq.Table`. In such case, we obtain a nested fluent code as below
    (feel free to use the approach that you find most convenient):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为了方便起见，我们可以在`org.jooq.Table`的`FROM`子句之后直接调用连接方法。在这种情况下，我们得到以下嵌套流畅代码（请随意使用您认为最方便的方法）：
- en: '[PRE46]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The rendered SQL for the PostgreSQL dialect is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于PostgreSQL方言的渲染SQL如下：
- en: '[PRE55]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Next, let's talk about `OUTER JOIN`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈`OUTER JOIN`。
- en: OUTER JOIN
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外连接
- en: While `INNER JOIN` returns only the combinations that pass the `ON` predicate,
    `OUTER JOIN` will also fetch rows that have no match on the left-hand side (`LEFT`
    [`OUTER`] `JOIN`) or right-hand side (`RIGHT` [`OUTER`] `JOIN`) of the join operation.
    Of course, we have to mention here `FULL` [`OUTER`] `JOIN` as well. This fetches
    all rows from both sides of the join operation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`INNER JOIN`只返回通过`ON`谓词的组合，但`OUTER JOIN`还会获取在连接操作的左侧（`LEFT`【外】`JOIN`）或右侧（`RIGHT`【外】`JOIN`）没有匹配的行。当然，我们还要提到`FULL`【外】`JOIN`。这会获取连接操作两边的所有行。
- en: The jOOQ API renders `OUTER JOIN` via `leftOuterJoin()`, `rightOuterJoin()`,
    and `fullOuterJoin()`. Since the `OUTER` keyword is optional, we can omit it via
    the analogs, `leftJoin()`, `rightJoin()`, and `fullJoin()`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ API通过`leftOuterJoin()`、`rightOuterJoin()`和`fullOuterJoin()`渲染`OUTER JOIN`。由于`OUTER`关键字是可选的，我们可以通过类似的方法省略它，即`leftJoin()`、`rightJoin()`和`fullJoin()`。
- en: 'For example, let''s fetch all employees (on the left-hand side) and their sales
    (on the right-hand side). By using `LEFT` [`OUTER`] `JOIN`, we retain all employees,
    even if they have no sales:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们获取所有员工（左侧）及其销售（右侧）。通过使用`LEFT`【外】`JOIN`，我们可以保留所有员工，即使他们没有销售：
- en: '[PRE66]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If we want to retain only the employees that have no sales, then we can rely
    on an exclusive `LEFT` [`OUTER`] `JOIN` by adding a `WHERE` clause that excludes
    all matches:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想保留没有销售的员工，则可以通过添加一个排除所有匹配项的`WHERE`子句来依赖一个专用的`LEFT`【外】`JOIN`：
- en: '[PRE72]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The rendered SQL for the SQL Server dialect is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SQL Server方言的渲染SQL如下：
- en: '[PRE79]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'If you prefer to use the Oracle (+) symbol shorthand for performing `OUTER
    JOIN` then check this example of an `LEFT [OUTER] JOIN`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢使用Oracle的`+`符号简写来执行`OUTER JOIN`，请查看以下`LEFT [OUTER] JOIN`的示例：
- en: '[PRE90]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'And, the Oracle SQL is:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，Oracle SQL如下：
- en: '[PRE96]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: By default, jOOQ render the optional `OUTER` keyword for both, `leftOuterJoin()`
    and `leftJoin()`. Alter this default via the `withRenderOptionalOuterKeyword()`
    setting and the argument `RenderOptionalKeyword.ON`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，jOOQ为`leftOuterJoin()`和`leftJoin()`都渲染可选的`OUTER`关键字。通过`withRenderOptionalOuterKeyword()`设置和`RenderOptionalKeyword.ON`参数来更改此默认设置。
- en: In the bundled code, you can practice more examples, including `RIGHT`/`FULL`
    [`OUTER`] `JOIN`. For MySQL, which doesn't support `FULL` [`OUTER`] `JOIN`, we
    wrote some emulation code based on the `UNION` clause.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，您可以练习更多示例，包括`RIGHT`/`FULL`【外】`JOIN`。对于不支持`FULL`【外】`JOIN`的MySQL，我们基于`UNION`子句编写了一些模拟代码。
- en: Important Note
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A special case of `OUTER JOIN` is represented by Oracle's partitioned `OUTER
    JOIN`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`OUTER JOIN`的一个特殊情况是Oracle的分区`OUTER JOIN`。'
- en: PARTITIONED OUTER JOIN
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分区外连接
- en: A special case of `OUTER JOIN` is represented by the Oracle's partitioned `OUTER
    JOIN`. Such a join represents an extension of the classical `OUTER JOIN` syntax
    and is applied to each logical partition defined via an expression in the `PARTITION
    BY` clause. A partitioned `OUTER JOIN` returns a `UNION` of the outer joins of
    each of the partitions in the partitioned table (logically partitions) with the
    table on the other side of the join.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle的分区外部连接是`OUTER JOIN`的一个特殊情况。这种连接代表了对经典`OUTER JOIN`语法的扩展，并应用于通过`PARTITION
    BY`子句中的表达式定义的每个逻辑分区。分区外部连接返回分区表（逻辑分区）中每个分区的外部连接与连接另一侧的表的`UNION`。
- en: Partitioned outer joins are specific to Oracle and they allow us to do the same
    "densifying" (fill gaps in sparse data) of data using a quite convenient syntax
    and an efficient Execution Plan.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 分区外部连接是Oracle特有的，它们允许我们使用相当方便的语法和高效的执行计划来执行相同的“密集化”（填充稀疏数据）操作。
- en: 'A classical scenario where the Oracle''s partitioned `OUTER JOIN` can be used
    sounds like this: write a query returning the sales of every employee (*Sales
    Representative*) in every fiscal year while taking into account that some employees
    had no sales in some years - fill gaps in sparse data with 0\. For instance, if
    we try to see the sales of all employees (*Sales Representative*) grouped by fiscal
    year via a trivial `JOIN` then we obtain some gaps in data as in the following
    figure:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle分区外部连接可以使用的经典场景听起来是这样的：编写一个查询，返回每个员工（*销售代表*）在每个财政年度的销售情况，同时考虑到一些员工在某些年份没有销售——用0填充稀疏数据中的空白。例如，如果我们尝试通过简单的`JOIN`查看所有员工（*销售代表*）按财政年度分组的销售情况，那么我们会在以下图中获得一些数据空白：
- en: '![Figure 6.1 – Fill gaps in sparse data'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.1 – Fill gaps in sparse data'
- en: '](img/B16833_Figure_6.1.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16833_Figure_6.1.jpg](img/B16833_Figure_6.1.jpg)'
- en: Figure 6.1 – Fill gaps in sparse data
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 填充稀疏数据中的空白
- en: 'In figure (a) is what we can easily get from a trivial `JOIN`, while in figure
    (b) is what we plan to get. So, we want to see all the *Sales Representative*
    even if they don’t have sales in certain years. This is a job for Oracle partitioned
    `OUTER JOIN` where the logical partition is `FISCAL_YEAR`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在图(a)中是我们容易从简单的`JOIN`中得到的，而在图(b)中是我们计划得到的。因此，我们希望看到所有的*销售代表*，即使他们在某些年份没有销售。这是Oracle分区外部连接的工作，其中逻辑分区是`FISCAL_YEAR`：
- en: '[PRE106]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Of course, you can express/emulate this query without partitioned `OUTER JOIN`,
    but for this you have to check out the application *PartitionedOuterJoin*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以不使用分区的外部连接来表示/模拟这个查询，但为此你必须查看*PartitionedOuterJoin*应用程序。
- en: The SQL USING and jOOQ onKey() shortcuts
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL的USING和jOOQ onKey()快捷方式
- en: So far, we've covered the typical `JOIN`s that are commonly used in daily work.
    Before we continue with more types of `JOIN`s, let's introduce two convenient
    shortcuts that are useful for expressing more concise `JOIN`s.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了在日常工作中最常用的典型`JOIN`。在我们继续介绍更多类型的`JOIN`之前，让我们介绍两个方便的快捷方式，这些快捷方式对于表达更简洁的`JOIN`非常有用。
- en: SQL JOIN … USING
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL JOIN … USING
- en: 'In certain cases, the SQL `JOIN … USING` clause can be a convenient alternative
    to the classical `JOIN … ON` clause. Instead of specifying a condition in the
    `JOIN … ON` clause, we enlist the `JOIN … USING` clause in the set of fields (columns)
    whose names are common to both tables – the left-hand side table and right-hand
    side table of a `JOIN` operation. In jOOQ, the `USING` clause is rendered via
    the `using()` method, as shown in the following example. The `EMPLOYEE_NUMBER`
    column mentioned in `using()` is the primary key of the `EMPLOYEE` table and the
    foreign key of the `SALE` table:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，SQL的`JOIN … USING`子句可以是一个方便的替代经典`JOIN … ON`子句的选择。我们不需要在`JOIN … ON`子句中指定条件，而是将`JOIN
    … USING`子句列入一组字段（列）中，这些字段的名称是两个表共有的——`JOIN`操作的左侧表和右侧表。在jOOQ中，`USING`子句通过`using()`方法实现，如下面的示例所示。`using()`中提到的`EMPLOYEE_NUMBER`列是`EMPLOYEE`表的主键，也是`SALE`表的外键：
- en: '[PRE117]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'So, `using(EMPLOYEE.EMPLOYEE_NUMBER)` is a less verbose representation of `on(EMPLOYEE.EMPLOYEE_NUMBER.eq(SALE.EMPLOYEE_NUMBER)`,
    and the rendered SQL for the MySQL dialect is as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`using(EMPLOYEE.EMPLOYEE_NUMBER)`是`on(EMPLOYEE.EMPLOYEE_NUMBER.eq(SALE.EMPLOYEE_NUMBER))`的一个更简洁的表达，MySQL方言的渲染SQL如下：
- en: '[PRE123]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'But we can use any other field(s). Here is the `USING` clause for a composite
    primary key:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以使用任何其他字段。以下是用于组合主键的`USING`子句：
- en: '[PRE128]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Alternatively, this is a `USING` clause for two fields that are not primary/foreign
    keys:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，这是一个用于两个非主键/外键字段的`USING`子句：
- en: '[PRE129]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Note that `using()` without arguments will render `ON TRUE`, so no filter is
    applied to the join operation. Practice the complete examples via the *JoinUsing*
    bundled application. Next, let's introduce a very handy tool from jOOQ named `onKey()`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有参数的 `using()` 会渲染 `ON TRUE`，因此不会对连接操作应用任何过滤器。通过捆绑的 *JoinUsing* 应用程序练习完整的示例。接下来，让我们介绍
    jOOQ 中的一个非常有用的工具，名为 `onKey()`。
- en: 'However, as I said, `USING` fits only for certain cases. Lukas Eder enforces
    this statement: "*The* `USING` *clause leads to a bit more difficult to maintain
    queries when queries get complex, so it''s generally not recommended. It''s less
    type-safe (in jOOQ). When you rename a column, your jOOQ code might still compile.
    It wouldn''t if you had been using* `ON`*. When you add a column that accidentally
    matches a column referenced from* `USING`*, you might get unintended consequences
    in unrelated queries. Example,* `A JOIN B USING (X) JOIN C USING (Y)`*. This assumes*
    `A(X)`*,* `B(X, Y)`*,* `C(Y)`*. So, what happens if you add* `A(Y)`*? A runtime
    exception, because* `Y` *is now ambiguous. Or, even worse: What happens if you
    add* `A(Y)` *but remove* `B(Y)`*? No runtime exception, but possibly (and quietly)
    wrong query. Moreover, in Oracle, columns referenced from* `USING` *can no longer
    be qualified in the query. In conclusion,* `USING` *can be useful for quick and
    dirty ad-hoc querying, just like* `NATURAL`*. But I wouldn''t use it in production
    queries. Especially, because implicit joins work much better in jOOQ.*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我所说的，`USING` 只适用于某些情况。Lukas Eder 强调了这一点：“*`USING` 子句在查询变得复杂时会导致维护查询变得更加困难，因此通常不推荐使用。它在类型安全性方面较差（在
    jOOQ 中）。当你重命名一个列时，你的 jOOQ 代码可能仍然可以编译。如果你使用的是 `ON`，则不会这样。当你添加一个意外匹配 `USING` 中引用的列的新列时，你可能会在不相关的查询中得到意外的后果。例如，*`A
    JOIN B USING (X) JOIN C USING (Y)`*。这假设了*`A(X)`*、*`B(X, Y)`*、*`C(Y)`*。那么，如果你添加*`A(Y)`*会发生什么？会抛出一个运行时异常，因为*`Y`*现在变得模糊不清。或者，更糟糕的是：如果你添加*`A(Y)`*但移除*`B(Y)`*会发生什么？不会抛出运行时异常，但可能（并且悄无声息地）得到错误的查询。此外，在
    Oracle 中，从 `USING` 引用的列不能再在查询中进行限定。总之，`USING` 可以用于快速且简单的即席查询，就像 `NATURAL` 一样。但我不建议在生产查询中使用它。特别是，因为隐式连接在
    jOOQ 中工作得更好。”
- en: '*The essence here is always the fact (and this is frequently misunderstood)
    that joins are *binary* operators between two tables. For instance,* `A JOIN B
    USING (X) JOIN C USING (Y)` *is just short for* `(A JOIN B USING (X)) JOIN C USING
    (Y)`*, so* `C` *is joined to* `(A JOIN B USING (X)`*) not to B alone. This is
    also the case for* `onKey()`*.*"'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: “这里的本质始终是事实（这一点经常被误解），连接是两个表之间的 *二元* 操作符。例如，*`A JOIN B USING (X) JOIN C USING
    (Y)`* 简短地等同于 *`(A JOIN B USING (X)) JOIN C USING (Y)`*，因此 *`C`* 是连接到 *`(A JOIN
    B USING (X))`* 而不是单独连接到 *`B`*。这也适用于 *`onKey()`*。”
- en: jOOQ onKey()
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jOOQ onKey()
- en: 'Whenever we join a well-known foreign key relationship, we can rely on the
    jOOQ `onKey()` method. Since this is quite easy to understand for a simple foreign
    key, let''s pick up a composite foreign key containing two fields. Check out the
    following `ON` clause:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们连接一个已知的 foreign key 关系时，我们都可以依赖 jOOQ 的 `onKey()` 方法。由于这对于简单的 foreign key
    来说很容易理解，让我们选择一个包含两个字段的复合 foreign key。查看以下 `ON` 子句：
- en: '[PRE130]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The (`CUSTOMER_NUMBER`, `CHECK_NUMBER`) represents a composite foreign key
    in the `BANK_TRANSACTION` table. jOOQ allows us to replace this verbose `ON` clause
    with the `onKey()` method without arguments, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: (`CUSTOMER_NUMBER`, `CHECK_NUMBER`) 代表 `BANK_TRANSACTION` 表中的一个复合外键。jOOQ 允许我们使用不带参数的
    `onKey()` 方法替换这个冗长的 `ON` 子句，如下所示：
- en: '[PRE137]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Really cool, isn''t it? jOOQ infers the `ON` condition on our behalf, and the
    rendered SQL for MySQL is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 真的很酷，不是吗？jOOQ 代表我们推断 `ON` 条件，渲染的 MySQL SQL 如下所示：
- en: '[PRE142]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'In case of ambiguity caused by multiple keys'' potential matches, we can also
    rely on foreign keys'' field references via `onKey(TableField<?,?>... tfs)`, or
    the generated foreign keys'' references via `onKey(ForeignKey<?,?> fk)`. For instance,
    in order to avoid the `DataAccessException`*: Key ambiguous between tables X and
    Y* exception, while joining table X with table Y via `onKey()`, we can explicitly
    indicate the foreign key that should be used as follows (here, via the SQL Server
    generated foreign key reference, `jooq.generated.Keys.PRODUCTLINEDETAIL_PRODUCTLINE_FK)`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个键的潜在匹配引起的歧义情况下，我们也可以通过 `onKey(TableField<?,?>... tfs)` 使用外键的字段引用，或者通过生成的外键引用
    `onKey(ForeignKey<?,?> fk)`。例如，为了避免在通过 `onKey()` 连接表 X 和表 Y 时出现的 `DataAccessException`：*“X
    和 Y 表之间的键模糊”* 异常，我们可以明确指出应使用的外键如下（在这里，通过 SQL Server 生成的外键引用 `jooq.generated.Keys.PRODUCTLINEDETAIL_PRODUCTLINE_FK`）：
- en: '[PRE149]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'This time, the rendered SQL is as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，渲染的 SQL 如下所示：
- en: '[PRE154]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'But despite its appeal, this method can lead into issues. As Lukas Eder shared
    here: "*The* `onKey()` *method is not type-safe, and can break in subtle ways,
    when tables are modified.*"'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 但尽管这种方法很有吸引力，它可能会导致问题。正如卢卡斯·埃德尔在这里分享的：“*`onKey()` 方法不是类型安全的，当表被修改时，可能会以微妙的方式出错。*”
- en: More examples are available in the application named *JoinOnKey*. For now, let's
    continue with more types of `JOIN`s.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为 *JoinOnKey* 的应用程序中提供了更多示例。现在，让我们继续探讨更多类型的 `JOIN`。
- en: Practicing more types of JOINs
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习更多类型的 JOIN
- en: Next, let's cover more `JOIN`s, such as Implicit/Self Joins, `NATURAL JOIN`,
    `STRAIGHT JOIN`, Semi/Anti Joins, and `LATERAL` Joins. Let's continue with Implicit/Self
    Joins.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探讨更多 `JOIN` 类型，例如隐式/自连接、`NATURAL JOIN`、`STRAIGHT JOIN`、半/反连接和 `LATERAL`
    连接。让我们继续探讨隐式/自连接。
- en: Implicit and Self Join
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式和自连接
- en: Implicit and Self Joins can be easily expressed in jOOQ via type-safe navigation
    methods produced by the jOOQ generator in classes that mirror the database tables.
    Let's dissect this aspect of Implicit Joins.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 jOOQ 生成器在镜像数据库表的类中产生的类型安全导航方法，隐式连接和自连接可以很容易地在 jOOQ 中表达。让我们分析隐式连接的这一方面。
- en: Implicit Join
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式连接
- en: 'As an example, an explicit join that fetches a parent table''s column from
    a given child table can be expressed as an Implicit Join. Here is the explicit
    join:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个显式连接，它从给定的子表中检索父表的列，可以表示为一个隐式连接。以下是显式连接：
- en: '[PRE164]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Here is the less verbose Implicit Join version:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是更简洁的隐式连接版本：
- en: '[PRE167]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'If we check the generated Java-based schema, then we notice that the `jooq.generated.tables.Employee`
    class mirroring the `EMPLOYEE` table contains a method named `office()` especially
    for expressing this syntax. Here is the previous Implicit Join, written via the
    jOOQ DSL API:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查生成的基于 Java 的模式，那么我们会注意到镜像 `EMPLOYEE` 表的 `jooq.generated.tables.Employee`
    类包含一个名为 `office()` 的方法，专门用于表达这种语法。以下是之前的隐式连接，通过 jOOQ DSL API 编写：
- en: '[PRE169]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Here is another example that chains several navigation methods to express an
    Implicit Join, starting from the `ORDERDETAIL` table:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个示例，它通过链式调用几个导航方法来表达隐式连接，从 `ORDERDETAIL` 表开始：
- en: '[PRE173]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'The names of these navigation methods correspond to the parent table name.
    Here is another example of writing an Implicit Join in a m:n relationship. If
    we think to an m:n relationship from the relationship table then we see two to-one
    relationships that we exploit as follows (between `MANAGER` and `OFFICE` there
    is a many-to-many relationship):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这些导航方法的名称与父表名称相对应。以下是一个在多对多关系（m:n）中编写隐式连接的另一个示例。如果我们从关系表考虑 m:n 关系，那么我们会看到两个一对一关系，我们可以如下利用它们（在
    `MANAGER` 和 `OFFICE` 之间存在多对多关系）：
- en: '[PRE182]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Notice that the Implicit Joins covered in this section are *foreign key path-based*.
    Most probably, you are also familiar with Implicit Joins where you enlist all
    the tables you want to fetch data from in the `FROM` clause followed by the `WHERE`
    clause having conditions based on primary/foreign keys values for filtering the
    result. Here is an example of jOOQ code for such an Implicit Join:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本节中介绍的隐式连接是基于 *外键路径* 的。很可能你也熟悉隐式连接，其中你在 `FROM` 子句中列出所有想要从中获取数据的表，然后是 `WHERE`
    子句，它基于主键/外键值的条件来过滤结果。以下是一个此类隐式连接的 jOOQ 代码示例：
- en: '[PRE186]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Note
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Nevertheless, note that these kind of Implicit Joins are quite prone to human
    mistakes, and it is better to rely on the ANSI JOIN syntax by explicitly using
    the `JOIN` keyword. Let me take advantage of this context to say that whenever
    you have old code that should be updated to an ANSI JOIN, you can rely on jOOQ.
    Besides the jOOQ DSL API, you can check out [https://www.jooq.org/translate](https://www.jooq.org/translate),
    and for a quick and neat guide, read this article: [https://blog.jooq.org/2020/11/17/automatically-transform-oracle-style-implicit-joins-to-ansi-join-using-jooq/](https://blog.jooq.org/2020/11/17/automatically-transform-oracle-style-implicit-joins-to-ansi-join-using-jooq/).'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，这类隐式连接很容易出错，最好通过显式使用 `JOIN` 关键字依赖 ANSI JOIN 语法。让我利用这个上下文来说明，无论何时你有应该更新为
    ANSI JOIN 的旧代码，你都可以依赖 jOOQ。除了 jOOQ DSL API 之外，你可以查看 [https://www.jooq.org/translate](https://www.jooq.org/translate)，并且为了快速而简洁的指南，阅读这篇文章：[https://blog.jooq.org/2020/11/17/automatically-transform-oracle-style-implicit-joins-to-ansi-join-using-jooq/](https://blog.jooq.org/2020/11/17/automatically-transform-oracle-style-implicit-joins-to-ansi-join-using-jooq/)。
- en: In the absence of explicit foreign keys in the schema for whatever reasons (including
    the tables are actually views), users of the commercial editions can specify synthetic
    foreign keys to the Code Generator as you can see in [*Chapter 11*](B16833_11.xhtml#_idTextAnchor209),
    *jOOQ keys*.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有在模式中明确的外键（包括表实际上是视图的任何原因）的情况下，商业版用户可以像在[*第11章*](B16833_11.xhtml#_idTextAnchor209)中看到的那样，将合成外键指定给代码生成器，即*jOOQ键*。
- en: Please, consider the jOOQ manual and [https://github.com/jOOQ/jOOQ/issues/12037](https://github.com/jOOQ/jOOQ/issues/12037)
    for covering the limitations of Implicit Joins support. Leaving the context of
    Implicit Joins, the jOOQ navigation methods are useful for expressing Self Joins
    as well.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑jOOQ手册和[https://github.com/jOOQ/jOOQ/issues/12037](https://github.com/jOOQ/jOOQ/issues/12037)以了解隐式连接支持的局限性。离开隐式连接的上下文，jOOQ的导航方法也适用于表达自连接。
- en: Self Join
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自连接
- en: 'Whenever a table is joined with itself, we can rely on Self Joins. Writing
    a Self Join is done via a navigation method that has the same name as the table
    itself. For example, here is a Self Join that fetches a result set containing
    the name of each employee and the name of their boss (`EMPLOYEE.REPORTS_TO`):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个表与自身连接时，我们可以依赖自连接。通过具有与表本身相同名称的导航方法来编写自连接。例如，以下是一个自连接，它检索包含每个员工及其老板名称（`EMPLOYEE.REPORTS_TO`）的结果集：
- en: '[PRE192]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: In the bundled code, *ImplicitAndSelfJoin*, you can practice more examples with
    implicit and Self Joins.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码*ImplicitAndSelfJoin*中，您可以练习更多关于隐式和自连接的示例。
- en: NATURAL JOIN
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NATURAL JOIN
- en: Earlier, we used the `JOIN … USING` syntax by enlisting the fields whose names
    are common to both tables (the left and right tables of a join operation) and
    should be rendered in the condition of the `ON` clause. Alternatively, we can
    rely on `NATURAL JOIN`, which doesn't require any `JOIN` criteria. This leads
    to a minimalist syntax but also makes our query a sword with two edges.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们通过列出两个表（连接操作的左表和右表）中名称相同的字段（`JOIN … USING`语法）来使用`JOIN … USING`语法，这些字段应该在`ON`子句的条件中呈现。或者，我们可以依赖`NATURAL
    JOIN`，它不需要任何`JOIN`条件。这导致了一种极简的语法，但也使得我们的查询具有双刃剑的特点。
- en: 'Basically, `NATURAL JOIN` automatically identifies all the columns that share
    the same name from both joined tables and use them to define the `JOIN` criteria.
    This can be quite useful when the primary/foreign keys columns share the same
    names, as in the following example:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`NATURAL JOIN`自动识别两个连接表中共享名称的所有列，并使用它们来定义`JOIN`条件。当主键/外键列具有相同的名称时，这非常有用，如下例所示：
- en: '[PRE198]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: The jOOQ API for `NATURAL JOIN` relies on the `naturalJoin()` method. Next to
    this method, we have the methods corresponding to `LEFT`/`RIGHT`/`FULL NATURAL
    OUTER JOIN` as `naturalLeftOuterJoin()`, `naturalRightOuterJoin()`, and `naturalFullOuterJoin()`.
    Also, you may like to read the article at [https://blog.jooq.org/2020/08/05/use-natural-full-join-to-compare-two-tables-in-sql/](https://blog.jooq.org/2020/08/05/use-natural-full-join-to-compare-two-tables-in-sql/)
    about using `NATURAL FULL JOIN` to compare two tables. You can see all these at
    work in the bundled code.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ API中的`NATURAL JOIN`依赖于`naturalJoin()`方法。除了这个方法之外，我们还有对应于`LEFT`/`RIGHT`/`FULL
    NATURAL OUTER JOIN`的`naturalLeftOuterJoin()`、`naturalRightOuterJoin()`和`naturalFullOuterJoin()`方法。此外，您可能还想阅读关于使用`NATURAL
    FULL JOIN`比较两个表的[https://blog.jooq.org/2020/08/05/use-natural-full-join-to-compare-two-tables-in-sql/](https://blog.jooq.org/2020/08/05/use-natural-full-join-to-compare-two-tables-in-sql/)文章。您可以在捆绑的代码中看到所有这些方法的应用。
- en: 'For our example, the rendered SQL for the PostgreSQL dialect is as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，PostgreSQL方言的渲染SQL如下：
- en: '[PRE201]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: The `EMPLOYEE` and `SALE` tables share a single column name, `EMPLOYEE_NUMBER`
    – the primary key in `EMPLOYEE` and the foreign key in `SALE`. This column is
    used behind the scenes by `NATURAL JOIN` for filtering the result, which is the
    expected behavior.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`EMPLOYEE`和`SALE`表共享一个单列名称，`EMPLOYEE_NUMBER`——在`EMPLOYEE`中是主键，在`SALE`中是外键。这个列在幕后被`NATURAL
    JOIN`用于过滤结果，这是预期的行为。'
- en: 'But, remember that `NATURAL JOIN` picks up all columns that share the same
    name, not only the primary/foreign key columns, therefore this `JOIN` may produce
    undesirable results. For instance, if we join the `PAYMENT` and `BANK_TRANSACTION`
    tables, then `NATURAL JOIN` will use the common composite key (`CUSTOMER_NUMBER`,
    `CHECK_NUMBER`) but will also use the `CACHING_DATE` column. If this is not our
    intention, then `NATURAL JOIN` is not the proper choice. Expecting that only the
    (`CUSTOMER_NUMBER`, `CHECK_NUMBER`) is used is a wrong assumption, and it is recommended
    to rely on the `ON` clause or the jOOQ `onKey()` method:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'On the other hand, if we expect that only the `CACHING_DATE` column will be
    used (which is hard to believe), then the `USING` clause can be a good alternative:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: The `USING` clause is useful if we need any custom combination of columns that
    share the same name. On the other hand, `NATURAL JOIN` is considerably more prone
    to issues, since any schema changes that lead to a new matching column name will
    cause `NATURAL JOIN` to combine that new column as well.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also worth keeping in mind that Oracle doesn''t accept that the columns
    used by `NATURAL JOIN` for filtering the result have qualifiers (*ORA-25155 –
    column used in NATURAL join cannot have qualifiers*). In this context, using the
    jOOQ Java-based schema with default settings comes with some issues. For instance,
    the expression `ctx.select().from(EMPLOYEE).naturalJoin(SALE)…` results in ORA-25155,
    since, by default, jOOQ qualifies the columns rendered in `SELECT`, including
    the common `EMPLOYEE_NUMBER` column, which is used by `NATURAL JOIN`. A quick
    workaround consists of explicitly rendering `*` via `asterisk()` instead of the
    columns list:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'Or, we can avoid using Java-based schema and write this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: Unqualified references to a common column are considered to belong to the left-hand
    side table if the join is `INNER`/`LEFT OUTER JOIN`, or to the right-hand side
    table if it is `RIGHT OUTER JOIN`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the Oracle `NATURAL JOIN` is the same as the Oracle proprietary
    Equi Join with a join condition (an Equi Join relies on a join condition containing
    an equality operator).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: As usual, you can practice all these examples and more in the bundled code.
    The application is named *NaturalJoin*. Next, let's tackle `STRAIGHT JOIN`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: STRAIGHT JOIN
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right from the start, we have to mention that `STRAIGHT JOIN` is specific to
    MySQL.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Basically, `STRAIGHT JOIN` instructs MySQL to always read the left-hand side
    table before the right-hand side table of `JOIN`. In this context, `STRAIGHT JOIN`
    may be useful to affect the execution plan chosen by MySQL for a certain `JOIN`.
    Whenever we consider that the query optimizer has put the `JOIN` tables in the
    wrong order, we can affect this order via `STRAIGHT JOIN`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s assume that the `PRODUCT` table has 5,000 rows, the `ORDERDETAIL`
    table has 200,000,000 rows, the `ORDER` table has 3,000 rows, and we have a join,
    as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'Now, MySQL may or may not take into account the size of the intersection between
    `ORDER.ORDER_ID` and `ORDERDETAIL.ORDER_ID` versus `PRODUCT.PRODUCT_ID` and `ORDERDETAIL.PRODUCT_ID`.
    If the join between `ORDERDETAIL` and `ORDER` returns just as many rows as `ORDERDETAIL`,
    then this is not an optimal choice. And if starting the join with `PRODUCT` will
    filter down `ORDERDETAIL` to as many rows as `PRODUCT`, then this will be an optimal
    choice. This behavior can be enforced via the jOOQ `straightJoin()` method, which
    renders a `STRAIGHT JOIN` statement, as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，MySQL 可能会或不会考虑 `ORDER.ORDER_ID` 和 `ORDERDETAIL.ORDER_ID` 与 `PRODUCT.PRODUCT_ID`
    和 `ORDERDETAIL.PRODUCT_ID` 之间的交集大小。如果 `ORDERDETAIL` 和 `ORDER` 之间的连接返回与 `ORDERDETAIL`
    相同数量的行，那么这并不是一个最佳选择。如果从 `PRODUCT` 开始连接可以将 `ORDERDETAIL` 过滤到与 `PRODUCT` 相同数量的行，那么这将是一个最佳选择。这种行为可以通过
    jOOQ 的 `straightJoin()` 方法强制执行，该方法生成一个 `STRAIGHT JOIN` 语句，如下所示：
- en: '[PRE227]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'In Oracle, the order of `JOINs` can be altered via `/*+LEADING(a, b)*/` hint.
    In jOOQ this kind of hints can be passed via `hint()`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Oracle 中，可以通过 `/*+LEADING(a, b)*/` 提示来更改 `JOINs` 的顺序。在 jOOQ 中，这种提示可以通过 `hint()`
    方法传递：
- en: '[PRE234]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'In SQL Server this can be accomplished via `OPTION (FORCE ORDER)`:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL Server 中，这可以通过 `OPTION (FORCE ORDER)` 实现：
- en: '[PRE238]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'Nevertheless, as Lukas Eder shared here: "*MySQL''s problems should have been
    made significantly less severe since they added hash join support. In any case,
    I think a disclaimer about premature optimization using hints could be added.
    With reasonable optimizers, hints should almost never be necessary anymore.*"'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，正如 Lukas Eder 在这里分享的：“*MySQL 的问题应该由于他们添加了哈希连接支持而大大减轻。无论如何，我认为应该添加一个关于使用提示进行过早优化的免责声明。在有合理优化器的系统中，提示几乎不再需要了。*”
- en: You can see the rendered SQL by running the *StraightJoin* application available
    for MySQL. Next, let's cover Semi and Anti Joins.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行可用的 *StraightJoin* 应用程序来查看生成的 SQL。接下来，让我们介绍半连接和反连接。
- en: Semi and Anti Joins
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 半连接和反连接
- en: Semi and Anti Joins are two of the relational algebra operators that don't have
    a direct correspondent in SQL syntax. Apart from the case of using Cloudera Impala,
    which provides a native syntax for Semi/Anti Joins, we have to rely on workarounds.
    In this context, Semi Join can be emulated via `EXISTS`/`IN` and Anti Join via
    `NOT EXISTS`/`NOT IN` predicates.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 半连接和反连接是关系代数运算符，在 SQL 语法中没有直接对应项。除了使用 Cloudera Impala 的情况，它为半/反连接提供了原生语法，我们不得不依赖解决方案。在这种情况下，半连接可以通过
    `EXISTS`/`IN` 和反连接通过 `NOT EXISTS`/`NOT IN` 谓词来模拟。
- en: Since Semi/Anti Joins can be emulated via (`NOT`) `EXISTS`/(`NOT`) `IN` predicates,
    it means that we don't really join the right-hand side. In the case of a Semi
    Join, we just fetch the rows from the first table (left-hand side table) where
    there are matches found in the second table (right-hand side table), while in
    the case of Anti Join, we do exactly the opposite of the Semi Join; we just fetch
    the rows from the first table (the left-hand side table) where there are no matches
    found in the second table (the right-hand side table).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 由于半/反连接可以通过 (`NOT`) `EXISTS`/(`NOT`) `IN` 谓词来模拟，这意味着我们实际上并没有连接右侧。在半连接的情况下，我们只从第一个表（左侧表）中获取在第二个表（右侧表）中找到匹配的行，而在反连接的情况下，我们正好与半连接相反；我们只从第一个表（左侧表）中获取在第二个表（右侧表）中没有找到匹配的行。
- en: 'For instance, let''s fetch the names of all `EMPLOYEE` that have `CUSTOMER`.
    Accomplishing this via a Semi Join emulated via the `EXISTS` predicate can be
    done in SQL as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们获取所有具有 `CUSTOMER` 的 `EMPLOYEE` 的名称。通过通过 `EXISTS` 谓词模拟的半连接来完成此操作，在 SQL
    中可以这样进行：
- en: '[PRE242]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'In the bundled code, you can see how to express this SQL via the jOOQ DSL API.
    In addition, you can practice this use case emulated via the `IN` predicate. For
    now, let''s use the jOOQ approach, which fills up the gap in expressiveness and
    enforces the clear intention of using a Semi Join via the `leftSemiJoin()` method.
    This jOOQ method saves us a lot of headaches – having neat code that is always
    emulated correctly in different SQL dialects and no brain-teasing in handling
    complex cases such as nesting `EXISTS`/`IN` predicates will make you fall in love
    with this method:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以看到如何通过 jOOQ DSL API 表达这种 SQL。此外，你可以通过 `IN` 谓词模拟这种用例进行练习。现在，让我们使用
    jOOQ 方法，它填补了表达能力的空白，并通过 `leftSemiJoin()` 方法强制执行使用半连接的明确意图。这个 jOOQ 方法为我们节省了很多麻烦——整洁的代码总是能够在不同的
    SQL 方言中正确模拟，而且处理复杂情况（如嵌套 `EXISTS`/`IN` 谓词）时不会让人头疼，这会让你爱上这个方法：
- en: '[PRE247]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: This is just awesome! Check out the bundled code, *SemiAndAntiJoin*, to see
    more examples about chaining and/or nesting Semi Joins via the jOOQ DSL API. Every
    time, check out the rendered SQL and give a big thanks to jOOQ for it!
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是太棒了！查看捆绑的代码，*SemiAndAntiJoin*，以查看更多关于通过 jOOQ DSL API 链接和/或嵌套半连接的示例。每次，查看生成的
    SQL 并对 jOOQ 表示衷心的感谢！
- en: 'Next, let''s focus on Anti Join. The Anti Join is the opposite of the Semi
    Join and is emulated via the `NOT EXISTS`/`NOT IN` predicates. For example, let''s
    write an SQL representing an Anti Join to fetch the names of all `EMPLOYEE` that
    don''t have `CUSTOMER` via `NOT EXISTS`:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们专注于反连接。反连接是半连接的相反，通过 `NOT EXISTS`/`NOT IN` 谓词来模拟。例如，让我们编写一个表示反连接的 SQL，通过
    `NOT EXISTS` 检索所有没有 `CUSTOMER` 的 `EMPLOYEE` 的名称：
- en: '[PRE253]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: In the bundled code, you can see how to express this SQL via the jOOQ DSL API
    and the same example based on the `NOT IN` predicate. Nevertheless, I strongly
    encourage you to avoid `NOT IN` and opt for `NOT EXISTS`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以看到如何通过 jOOQ DSL API 表达这个 SQL，以及基于 `NOT IN` 谓词的相同示例。然而，我强烈建议你避免使用
    `NOT IN` 并选择 `NOT EXISTS`。
- en: Important note
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Most probably, you already know this, but just as a quick reminder, let''s
    mention that the `EXISTS` and `IN` predicates are equivalent, but the `NOT EXISTS`
    and `NOT IN` predicates are not because the `NULL` values (if any) lead to undesirable
    results. For more details, please read this short but essential article: [https://blog.jooq.org/2012/01/27/sql-incompatibilities-not-in-and-null-values/](https://blog.jooq.org/2012/01/27/sql-incompatibilities-not-in-and-null-values/).'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，你已经知道了这一点，但只是为了快速提醒，让我们提一下，`EXISTS` 和 `IN` 谓词是等价的，但 `NOT EXISTS` 和 `NOT
    IN` 谓词则不是，因为（如果有）`NULL` 值会导致不希望的结果。有关更多详细信息，请阅读这篇简短但至关重要的文章：[https://blog.jooq.org/2012/01/27/sql-incompatibilities-not-in-and-null-values/](https://blog.jooq.org/2012/01/27/sql-incompatibilities-not-in-and-null-values/)。
- en: 'Alternatively, and even better, use the jOOQ Anti Join represented by the `leftAntiJoin()`
    method:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，甚至更好，使用由 `leftAntiJoin()` 方法表示的 jOOQ 反连接：
- en: '[PRE259]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: Check out the rendered SQL and more examples in the application named *SemiAndAntiJoin*.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 查看名为 *SemiAndAntiJoin* 的应用程序中的生成的 SQL 和更多示例。
- en: A typical problem solved by Anti Joins refers to relational division or simply
    division. This is another operator of relational algebra without a direct correspondent
    in SQL syntax. In short, division is the inverse of the `CROSS JOIN` operation.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 反连接通常解决的问题是指关系除法或简单地除法。这是关系代数中的一个运算符，在 SQL 语法中没有直接对应物。简而言之，除法是 `CROSS JOIN`
    操作的逆。
- en: 'For instance, let''s consider the `ORDERDETAIL` and `TOP3PRODUCT` tables. While
    `CROSS JOIN` gives us the Cartesian product as `ORDERDETAIL x TOP3PRODUCT`, the
    division gives us `ORDERDETAIL ÷ TOP3PRODUCT` or `TOP3PRODUCT ÷ ORDERDETAIL`.
    Let''s assume that we want the IDs of all orders that contain at least three products
    contained in `TOP3PRODUCT`. This kind of task is a division and is commonly solved
    via two nested Anti Joins. The jOOQ code that solves this problem is as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑 `ORDERDETAIL` 和 `TOP3PRODUCT` 表。虽然 `CROSS JOIN` 给我们的是笛卡尔积 `ORDERDETAIL
    x TOP3PRODUCT`，但除法给出的是 `ORDERDETAIL ÷ TOP3PRODUCT` 或 `TOP3PRODUCT ÷ ORDERDETAIL`。假设我们想要包含在
    `TOP3PRODUCT` 中的至少三个产品的所有订单的 ID。这类任务是一种除法，通常通过两个嵌套的反连接来解决。解决此问题的 jOOQ 代码如下：
- en: '[PRE265]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'This is cool and much less verbose than writing the same thing via `NOT EXISTS`.
    But that''s not all! jOOQ comes with an even more elegant solution that can be
    used to express divisions. This solution uses the `divideBy()` and `returning()`
    methods to express a division in a concise, expressive, and very intuitive way.
    Check out the following code that can replace the previous code:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这很酷，比通过 `NOT EXISTS` 写同样的事情要简洁得多。但这还不是全部！jOOQ 提供了一个更优雅的解决方案，可以用来表达除法。这个解决方案使用
    `divideBy()` 和 `returning()` 方法以简洁、表达性强且非常直观的方式表达除法。查看以下可以替换先前代码的代码：
- en: '[PRE275]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: Check out this example and another one about finding the orders that contain
    at least the products of a given order in the *BootAntiJoinDivision* application.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这个示例以及另一个关于在 *BootAntiJoinDivision* 应用程序中查找包含至少给定订单产品订单的示例。
- en: 'As Lukas Eder pointed out here: "*If you want to see how x is the inverse of
    ÷, you can choose two different tables, for instance A x B = C and C ÷ B = A*".'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 正如卢卡斯·埃德尔在这里指出的：“*如果你想看到 x 是 ÷ 的逆，你可以选择两个不同的表，例如 A x B = C 和 C ÷ B = A*”。
- en: Next, let’s cover the `LATERAL`/`APPLY` Join.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来探讨 `LATERAL`/`APPLY` 连接。
- en: LATERAL/APPLY Join
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LATERAL/APPLY 连接
- en: The last topic covered in this chapter refers to the `LATERAL`/`APPLY` Join.
    This is part of standard SQL and is quite similar to a correlated subquery that
    allows us to return more than one row and/or column or to the Java `Stream.flatMap()`.
    Mainly, a lateral inner subquery sits on the right-hand side of `JOIN` (`INNER`,
    `OUTER`, and so on), and it can be materialized as a classical subquery, a derived
    table, a function call, an array unnesting, and so on. Its power consists of the
    fact that it can refer to (or *laterally* access) tables/columns from the left-hand
    side to determine which rows to retain. A `LATERAL` Join iterates through each
    row on the left-hand side, evaluating the inner subquery (the right-hand side)
    for each row, like a typical for-each loop. The rows returned by the inner subquery
    are retained to the result of the join with the outer query. The `LATERAL` keyword
    is essential because, without it, each subquery is evaluated separately (independently)
    and can't access columns from the left-hand side (from the `FROM` clause).
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最后讨论的是`LATERAL`/`APPLY`连接。这是标准SQL的一部分，与关联子查询非常相似，允许我们返回多行和多/或列，或者与Java的`Stream.flatMap()`类似。主要的是，横向内部子查询位于`JOIN`（`INNER`、`OUTER`等）的右侧，它可以被物化为经典子查询、派生表、函数调用、数组展开等。它的力量在于它可以引用（或*横向访问*）左侧的表/列来确定要保留哪些行。`LATERAL`连接会遍历左侧的每一行，为每一行评估内部子查询（右侧），就像典型的for-each循环一样。内部子查询返回的行保留到与外部查询的连接结果中。`LATERAL`关键字是必不可少的，因为没有它，每个子查询都会单独（独立）评估，无法访问左侧的列（`FROM`子句中的列）。
- en: 'For example, selecting all `OFFICE` that has `DEPARTMENT` can be done via the
    `LATERAL` Join:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，选择所有具有`DEPARTMENT`的`OFFICE`可以通过`LATERAL`连接来完成：
- en: '[PRE281]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: 'As you can see, the jOOQ DSL API provides the `lateral()` method for shaping
    `LATERAL` Joins. The SQL rendered for the MySQL dialect is as follows:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，jOOQ DSL API提供了`lateral()`方法来塑造`LATERAL`连接。为MySQL方言渲染的SQL如下所示：
- en: '[PRE286]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: 'Without an explicit `JOIN`, you would expect that `CROSS JOIN` (`INNER JOIN
    ON true / INNER JOIN IN 1=1`) is automatically inferred. Writing the previous
    query via `LEFT OUTER JOIN LATERAL` requires a dummy `ON true / ON 1=1` clause,
    as follows:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 没有显式的`JOIN`，你会期望`CROSS JOIN`（`INNER JOIN ON true / INNER JOIN IN 1=1`）会自动推断。通过`LEFT
    OUTER JOIN LATERAL`编写前面的查询需要一个虚拟的`ON true / ON 1=1`子句，如下所示：
- en: '[PRE295]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: A `LATERAL` Join has several use cases where it fits like a glove. For instance,
    it can be used for lateral unnesting of the array columns, for finding TOP-N per
    *Foo* (joining TOP-N query to a normal table), and it works nicely in combination
    with the so-called table-valued functions.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`LATERAL`连接有几个用例，它非常适合。例如，它可以用于数组的横向展开，用于查找每个*Foo*的TOP-N（将TOP-N查询与普通表连接），并且与所谓的表值函数结合得很好。'
- en: Unnesting the array columns
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展开数组列
- en: If you are an Oracle or PostgreSQL fan, then you know about their support for
    nested arrays (or nested collections). In PostgreSQL, we can declare a column
    of type array exactly as any other type but suffixed with square brackets – `[]`
    (for example, `text[]`). Since Oracle recognizes only nominal array types, we
    have to create them first via `CREATE TYPE`. I will not insist on this pure SQL
    aspect, since our goal is to jump into jOOQ DSL API usage.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个Oracle或PostgreSQL的粉丝，那么你应该知道它们对嵌套数组（或嵌套集合）的支持。在PostgreSQL中，我们可以声明一个类型为数组的列，就像声明任何其他类型一样，但以方括号`[]`（例如，`text[]`）结尾。由于Oracle只识别名义数组类型，我们必须首先通过`CREATE
    TYPE`来创建它们。我不会坚持这个纯SQL方面，因为我们的目标是跳入jOOQ DSL API的使用。
- en: So, let's consider the `DEPARTMENT` table, which has an array column named `TOPIC`.
    For each department, we have a list of topics (area of activities), and more departments
    may have interleaved topics. For instance, for the `Sale` department, we have
    four topics – `'commerce'`, `'trade'`, `'sellout'`, and `'transaction'`.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们考虑具有名为`TOPIC`的数组列的`DEPARTMENT`表。对于每个部门，我们有一个主题列表（活动领域），并且可能有更多部门有交错的主题。例如，对于`Sale`部门，我们有四个主题——`'commerce'`、`'trade'`、`'sellout'`和`'transaction'`。
- en: 'Now, let''s assume that we want to fetch the departments that have in common
    the `''commerce''` and `''business''` topics. For this, we can write a `LATERAL`
    Join via the jOOQ DSL API using the `lateral()` method, and we unnest the array
    (transform the array into a useable/queryable table) via the `unnest()` method,
    as follows:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要获取具有共同主题`'commerce'`和`'business'`的部门。为此，我们可以通过jOOQ DSL API使用`lateral()`方法编写一个`LATERAL`连接，并通过`unnest()`方法展开数组（将数组转换为可用的/可查询的表），如下所示：
- en: '[PRE302]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: 'For the PostgreSQL dialect, the rendered SQL is as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: Note that MySQL and SQL Server don't have support for array (collection) columns,
    but we can still declare anonymously typed arrays that can be unnested via the
    same jOOQ `unnest()` method. Next, let's talk about solving TOP-N per *Foo* tasks.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: Solving TOP-N per Foo
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While solving TOP-N problems over the entire dataset can be quite challenging,
    solving TOP-N per *Foo* problems can be really hard to digest. Fortunately, the
    `LATERAL` Join fits perfectly for these kinds of problems. For instance, fetching
    TOP-3 sales per employee can be expressed in jOOQ as follows:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: 'The fact that the `LATERAL` Join allows us to access the `EMPLOYEE.EMPLOYEE_NUMBER`
    field/column does all the magic! The rendered SQL for MySQL dialect is as follows:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: 'If we think of the derived table obtained via the inner `SELECT` as a table-valued
    function that has the employee number as an argument, then, in Oracle, we can
    write this:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: 'Next, we can use a `LATERAL` Join to call this function. The jOOQ code is as
    follows:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: 'The rendered SQL for Oracle is as follows:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: 'The `TOP_THREE_SALES_PER_EMPLOYEE` static field was generated by the jOOQ generator
    and is basically an ordinary table placed in the `jooq.generated.tables` package
    under the name `TopThreeSalesPerEmployee`. It can be used in the `FROM` clause
    of `SELECT` like any other table. Nevertheless, note that we have access to a
    method named `call()`, which is used for calling (with arguments) this table-valued
    function. However, while most databases treat table-valued functions as ordinary
    tables, in Oracle, it is quite common to treat them as standalone routines. In
    this context, jOOQ has a flag setting that allows us to indicate whether table-valued
    functions should be treated as ordinary tables (`true`) or as plain routines (`false`).
    Depending on this setting, jOOQ places the generated code in tables-section or
    the routines-section. This setting is set to `true` in all supported databases
    except Oracle. To enable this, we have to set the following:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: 'Or, programmatic:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: While the `LATERAL` keyword (which, by the way, is a pretty confusing word)
    can be used in MySQL, PostgreSQL, and Oracle, it cannot be used in SQL Server.
    Actually, SQL Server and Oracle have support for `CROSS APPLY` and `OUTER APPLY`
    via the `APPLY` keyword.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: CROSS APPLY and OUTER APPLY
  id: totrans-537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Specific to T-SQL, `CROSS APPLY`, and `OUTER APPLY` use the more suggestive
    `APPLY` keyword, which suggests that we apply a function to each table row. Mainly,
    `CROSS APPLY` is the same thing as `CROSS JOIN LATERAL`, and `OUTER APPLY` is
    the same thing as `LEFT OUTER JOIN LATERAL`. This is exactly how jOOQ will emulate
    `CROSS`/`OUTER APPLY` when they are not supported (for example, in PostgreSQL).
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: 'I guess everyone agrees with Lukas Eder''s statement: "*I find APPLY much more
    intuitive, especially when cross applying a table valued function. T CROSS APPLY
    F (T.X) means we''re applying F to each row in T and create the cross product
    between T and the result of F. On the other hand, LATERAL is so weird, syntactically,
    especially this stupid requirement of writing ON TRUE all the time.*"'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning of this section, we wrote a `LATERAL` Join to select all `OFFICE`
    that has `DEPARTMENT`. Writing the same thing but using `CROSS APPLY` can be done
    via the jOOQ `crossApply()` method, like this:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: 'The render SQL for SQL Server is as follows:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: 'Writing the previous query via `LEFT OUTER JOIN LATERAL` requires a dummy `ON
    true/1=1` clause, but using `OUTER APPLY` via the jOOQ `outerApply()` method eliminates
    this little inconvenience:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: 'And the SQL rendered for the SQL Server dialect is as follows:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: Done! In the bundled code, you can practice examples of `cross`/`outerApply()`
    and table-valued functions as well.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: In the examples of this chapter, we have used `fooJoin(TableLike<?> table)`and
    `cross`/`outerApply(TableLike<?> table)`, but the jOOQ API also contains other
    flavors, such as `fooJoin(String sql)`, `cross`/`outerApply(String sql)`, `fooJoin(SQL
    sql)`, `cross`/`outerApply(SQL sql`), `fooJoin(String sql, Object... bindings)`,
    `cross`/`outerApply(String sql, Object... bindings)`, `fooJoin(String sql, QueryPart...
    parts)`, and `cross`/`outerApply(String sql, QueryPart... parts)`. All of them
    are available in the jOOQ documentation and are marked with `@PlainSQL`. This
    annotation points out methods/types that allow us to produce a `QueryPart` that
    renders "plain SQL" inside of an AST, which are covered in [*Chapter 16*](B16833_16.xhtml#_idTextAnchor315),
    *Tackling Aliases and SQL Templating*.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: All the examples (and more) from this chapter can be found in the *LateralJoin*
    application. Take your time to practice each example.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-577
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered a comprehensive list of SQL `JOIN`s and how
    they can be expressed via the jOOQ DSL API. We started with the well-known `INNER`/`OUTER`/`CROSS
    JOIN`, continued with Implicit Joins, Self Joins, `NATURAL` and `STRAIGHT JOIN`s,
    and ended with Semi/Anti Joins, `CROSS APPLY`, `OUTER APPLY`, and `LATERAL` Joins.
    Also, among others, we covered the `USING` clause and the amazing jOOQ `onKey()`
    method.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we tackle the jOOQ types, converters, and bindings.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
