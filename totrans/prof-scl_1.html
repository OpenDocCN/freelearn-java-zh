<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Setting up the Development Environment"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Setting up the Development Environment</h1></div></div></div><p>Before we start writing the various programs in this book, let's talk a little about the Scala language itself. Why is it necessary, and what has made Scala unique? What are the most important aspects of the language?</p><p>Scala was created in 2001 in EPFL (École Polytechnique Fédérale de Lausanne), by Martin Odersky.  This is the same lab where Pascal language (widely used up to the end of the 1990s) was created.</p><p>Scala is an abbreviation for 'Scalable Language'—a language which can be scaled, that is, it allows you to write complex systems with gigantic amounts of functionality. As specified on Scala's home page: "
<span class="emphasis"><em>Scala combines object-oriented and functional programming in one concise, high-level language.</em></span>" 
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>You can visit Scala's official home page here: 
<a class="ulink" href="https://www.scala-lang.org/">https://www.scala-lang.org/</a>
</p></div></div><p>By the end of this chapter, you will be able to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Recognize the structure of a Scala project</li><li class="listitem" style="list-style-type: disc">Identify the use of Scala's sbt tool (interactive build tool) for building and running your project</li><li class="listitem" style="list-style-type: disc">Identify how to use the IDE</li><li class="listitem" style="list-style-type: disc">Implement interactions with a simple chatbot</li></ul></div><p>Scala is built on top of the JVM platform (the Scala program is compiled to use JVM bytecode).</p><p>Now, the language is used as one of the most preferred platforms in many areas, such as high-load soft-realtime applications, ad servers for data science toolkits.</p><p>Some characteristics of Scala are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An advanced type system, which makes Scala superior (but at the same time, more complex) compared to most other industrial programming languages.</li><li class="listitem" style="list-style-type: disc">Static typing, which allows you to write code in a safe way when errors are checked during compilation.</li></ul></div><p>In this chapter, we will learn the basics of Scala, such as what the simple Scala program looks like and what a typical developer flow is. A significant part of development is interaction with tools—build tools, dependency extractors, IDEs, and so on, which form the tool ecosystem with the language. We will build a simple program using mainstream tools.</p><div class="section" title="Simple Program"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec07"/>Simple Program</h1></div></div></div><p>In this section, we will be covering the structure of a basic Scala program. We will be covering definitions such as packages, imports, and objects. We will also be looking into the main method of a Scala program.</p><p>Let's create the simplest possible program in Scala. We will implement a program which will print "Hello World" on the screen. The structure of this program is defined as follows:</p><div class="informalexample"><pre class="programlisting">package com.packt.courseware
import scala.io.StdIn
object Chatbot1
{
   def main(args: Array[String]):Unit =  {
     // do something
   }
}</pre></div><div class="section" title="Definitions: Packages, Imports, and Objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Definitions: Packages, Imports, and Objects</h2></div></div></div><p>If you look at the preceding code, the first line is a package name. In our case, this is 
<code class="literal">com.packt.courseware</code>.
</p><p>All compilation units are organized into packages. Packages can be nested, forming hierarchical namespaces for code objects.</p><p>When a compilation unit has no package declaration, it belongs to a so-called '
<code class="literal">default</code>' package. Modules from a default package can't be imported from another package.
</p><p>Usually, the source directory in a Scala project is organized in the same way as packages. This is not mandatory, but becomes a rule of thumb. Some tools (such as IDEs) use these conventions for default project settings.</p><p>Now we will look at 
<code class="literal">import</code> statements.
</p><div class="section" title="Object Definition"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Object Definition</h3></div></div></div><p>Here, we define the object 
<code class="literal">Chatbot1.</code>
</p><p>If you are familiar with the traditional classes, since they are implemented in Java, you can look at the object of a class with one default instance, that is, an object is an implementation of the singleton pattern: on the JVM level, the object definition creates a class and one predefined instance of this class.</p></div><div class="section" title="The main Method"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>The main Method</h3></div></div></div><p>Finally, the 
<code class="literal">main</code> method is an entry point for our program. It must accept an array of strings (command-line arguments) and return a unit.
</p><p>Historically, the 
<code class="literal">main</code> method name is used in Scala. This is because the Java language is following the same tradition, which takes the name of an entry method from C, which take this from BCPL.
</p><p>The method is defined as follows:</p><div class="informalexample"><pre class="programlisting">         package com.packt.couserware
    object X  { def f() = { … } }</pre></div></div></div><div class="section" title="Inside main"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Inside main</h2></div></div></div><p>The 
<code class="literal">main</code> method is an essential part of any Scala program. The execution of a program first starts from the 
<code class="literal">main</code> method.
</p><p>Let's look inside the 
<code class="literal">main</code> method:
</p><div class="informalexample"><pre class="programlisting">def main(args: Array[String]): Unit = {
val name = StdIn.readLine("Hi! What is your name?")
println(s" $name, tell me something interesting, say 'bye' to end the talk")
var timeToBye = false  
while (!timeToBye)timeToBye = StdIn.readLine("&gt;") 
match {case "bye" =&gt; println("ok, bye")
                             truecase  _      =&gt; println("interesting...")false}
}</pre></div><p>Here, we define an immutable value with the name 
<code class="literal">name</code>, which keeps the user's input from 
<code class="literal">stdin</code>. Scala is a statically typed language, and so the value is of type 
<code class="literal">String</code>.
</p><p>As we can see, the type of the value is not explicitly written, but automatically inferred from its context.</p><p>At the next line, the value is printed using the "string interpolation" operator: In a string with a prefix of 
<code class="literal">s</code>, all occurrences of expressions inside 
<code class="literal">${}</code> brackets in strings are replaced with values of these expressions, casted to strings. For simple identifiers, we can 
<code class="literal">omit {}</code> brackets, for example, in a string interpolation of 
<code class="literal">s"x=$y"</code>, the value of y will be substituted instead with 
<code class="literal">$y</code>.
</p><p>
<code class="literal">var timeToBye</code> is a mutable variable with a 
<code class="literal">Boolean</code> type. Unlike values, mutable variables can be assigned more than once.
</p><p>Looking forward at the loop, we can see that the program is trying to be a good listener and answer 
<code class="literal">interesting</code> to any message, except 
<code class="literal">bye</code>.
</p><p>The result of the case statement is assigned to 
<code class="literal">timeToBye</code>, and is checked in the 
<code class="literal">while</code> loop condition
</p><p>Scala, as a multiparadigm language, has both mutable and immutable variables. For nearly any task, we can choose more than one way of implementing this.</p><p>If guidelines exist, where should we use mutable variables and where should we use immutable variables?</p><p>Generally, reasoning about immutable variables is simpler. The usual heuristic is to use immutable values as much as possible, leaving mutable variables for performance-critical sections and state-check language constructs (such as while loops).</p><p>In our small example, we can eliminate the mutable flag by putting an expression for the loop exit condition inside 
<code class="literal">while</code>. The resulting code is smaller and better to read, but adding new functionality becomes harder. Yet there is one possibility—use the 
<code class="literal">recursive</code> function instead of the loop language construction.
</p><p>Now let's add some functionality to our 
<code class="literal">chatbot</code>: when the user asks for the 
<code class="literal">time</code>, the 
<code class="literal">chatbot</code> should report the current time.
</p><p>To do this, we must retrieve the current time using the Java API and display the output of the time using string interpolators.</p><p>For example, use the 
<code class="literal">now</code> method of 
<code class="literal">java.time.LocalTime.</code>
</p><p>The code used to display this will be 
<code class="literal">println("time is ${java.time.LocalTime.now()}").</code>
</p><p>The following is the code for this functionality, but we will actually implement this after setting up the working environment we will be playing with:</p><div class="informalexample"><pre class="programlisting">package com.packt.coursewarepackage com.packt.courseware

import scala.io.StdIn

object Chatbot1 {

  def main(args: Array[String]): Unit = {
    val name = StdIn.readLine("Hi! What is your name?")
    println(s" $name, tell me something interesting, say 'bye' to end the talk")
    var timeToBye = false
    while (!timeToBye)
       timeToBye = StdIn.readLine("&gt;") match {
         case "bye" =&gt; println("ok, bye")
         true
         case "time" =&gt; println(s"time is ${java.time.LocalTime.now()}")
         true
         case _ =&gt; println("interesting...")
         false
       }
}

}</pre></div></div></div></div>
<div class="section" title="Structure of a Scala Project"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Structure of a Scala Project</h1></div></div></div><p>Let's look at our 
<code class="literal">chatbot</code> program in a complete runnable project. Let's navigate to the 
<code class="literal">/day1-lesson1/1-project</code> directory in our code supplement.
</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl4sec01"/>
</h2></div></div></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>The code is available on Github at the following link: 
<a class="ulink" href="https://github.com/TrainingByPackt/Professional-Scala">https://github.com/TrainingByPackt/Professional-Scala</a>
</p></div></div><div class="mediaobject"><img alt="" src="graphics/1_01.jpg"/></div><p>The preceding diagram is the typical directory structure of a Scala project. If you are familiar with the Java tools ecosystem, then you will notice the similarities between the 
<code class="literal">maven</code> project layout.
</p><p>In 
<code class="literal">src</code>, we can
<a class="indexterm" id="id0"/> see project sources (
<code class="literal">main</code> and 
<code class="literal">test</code>). 
<code class="literal">target</code> is a place where output artifacts are created, whereas 
<code class="literal">project</code> is used as a place to
<a class="indexterm" id="id1"/> internally build the project. We will cover all of these concepts later on.
</p><div class="informalexample"><pre class="programlisting">organization := "com.packt.courseware"name := "chatbot1"version := "0.1-SNAPSHOT"
scalaVersion := "2.12.4"</pre></div><p>The head of any project is its 
<code class="literal">build.sbt</code> file. It consists of the following code:
</p><p>The text inside it is a plain Scala snippet.</p><p>
<code class="literal">organization</code>, 
<code class="literal">name</code>, and 
<code class="literal">version</code> are instances of 
<code class="literal">sbt.key</code>. For this point of view, 
<code class="literal">:=</code> is a binary operator defined on 
<code class="literal">keys</code>. In Scala, any method with two arguments can be used with the syntax of a binary operator. 
<code class="literal">:=</code> is a valid method name.
</p><p>
<code class="literal">build.sbt</code> is interpreted by the 
<code class="literal">sbt</code> tool.
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>
<code class="literal">sbt</code> – The original intention for the name, when 
<code class="literal">sbt</code> was created by Mark Harrah, was '
<code class="literal">Simple Build Tool</code>'. Later on, the author decided to avoid such a decipherment, and kept it as it was. You can read about the details of 
<code class="literal">sbt</code> here: 
<a class="ulink" href="https://www.scala-sbt.org/1.x/docs/index.html">https://www.scala-sbt.org/1.x/docs/index.html</a>.
</p></div></div></div><div class="section" title="Basic sbt Commands"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Basic sbt Commands</h2></div></div></div><p>We will now 
<a class="indexterm" id="id2"/>talk about the basic 
<code class="literal">sbt</code> commands.
</p><p>
<code class="literal">sbt</code> compile should compile 
<a class="indexterm" id="id3"/>the project and live somewhere in its target compiled Java classes.
</p><p>
<code class="literal">sbt run</code> executes
<a class="indexterm" id="id4"/> the 
<code class="literal">main</code> function of the project. Therefore, we can try to interact with our 
<code class="literal">chatbot</code>:
</p><div class="informalexample"><pre class="programlisting">rssh3:1-project rssh$ sbt run
[info] Loading global plugins from /Users/rssh/.sbt/0.13/plugins
[info] Set current project to chatbot1 (in build file:/Users/rssh/work/packt/professional-scala/Lesson 1/1-project/)
[info] Running com.packt.courseware.Chatbot1
Hi! What is your name? Jon
  Jon, tell me something interesting, say 'bye' to end the talk</pre></div><div class="informalexample"><pre class="programlisting">&gt;qqq
interesting..
&gt;ddd
interesting...
&gt;bye
ok, bye
 [success] Total time: 19 s, completed Dec 1, 2017 7:18:42 AM</pre></div><p>The output of the code is as follows:</p><p>
<code class="literal">sbt package</code> prepares
<a class="indexterm" id="id5"/> an output artifact. After running it, it will create file called 
<code class="literal">target/chatbot1_2.12-0.1-SNAPSHOT.jar</code>.
</p><p>
<code class="literal">chatbot1</code> is the name of  our project; 
<code class="literal">0.1-SNAPSHOT – version. 2.12</code> is the version of the Scala compiler.
</p><p>Scala 
<a class="indexterm" id="id6"/>guarantees binary compatibility only within the scope of a minor version. If, for some reason, the project still uses 
<code class="literal">scala-2.11</code>, then it must use the library, which was created for 
<code class="literal">scala-2.11</code>. On the other hand, updating to the next compiler version can be a long process for projects with many dependencies. To allow the same library to exist in the repository with different 
<code class="literal">scalaVersions</code>, we need to have an appropriate
<a class="indexterm" id="id7"/> suffix in the jar file.
</p><p>
<code class="literal">sbt publish-local</code> – publishes the artifact on to your local repository.
</p><p>Now let's see 
<a class="indexterm" id="id8"/>our sample project and 
<code class="literal">sbt</code> tool.
</p></div><div class="section" title="Activity: Performing Basic Operations with sbt: Build, Run, Package"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Activity: Performing Basic Operations with sbt: Build, Run, Package</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install sbt on your computer, if not installed beforehand.</li><li class="listitem">Start the <code class="literal">sbt</code> console by typing <code class="literal">sbt console</code> in the root directory of the <code class="literal">1-project </code>(where <code class="literal">build.sbt</code> is situated).</li><li class="listitem">Compile the code by typing the <code class="literal">compile</code> command into the <code class="literal">sbt</code> console.</li><li class="listitem">Run the program by typing the <code class="literal">sbt run</code> command into the <code class="literal">sbt</code> console.</li><li class="listitem">When running this, say <code class="literal">bye</code> to the bot and return to the console.</li><li class="listitem">Package<a class="indexterm" id="id9"/> the program by typing <code class="literal">package</code> into the <code class="literal">sbt</code> console.</li></ol></div></div><div class="section" title="IDE"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>IDE</h2></div></div></div><p>Another part of the 
<a class="indexterm" id="id10"/>developer toolbox is an IDE tool (Integrated Development Environment). For our book, we will use Intellij IDEA community edition with the Scala plugin. This is not the only option: other alternatives are scala-ide, based on IBM Eclipse and Ensime (<a class="ulink" href="http://ensime.github.io/">http://ensime.github.io/</a>), which brings IDE features to any programmable text editors, from vi to emacs.
</p><p>All tools support importing the project layout from 
<code class="literal">build.sbt</code>.
</p></div><div class="section" title="Activity: Loading and Running a Sample Project in the IDE"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Activity: Loading and Running a Sample Project in the IDE</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Import <a class="indexterm" id="id11"/>our <a class="indexterm" id="id12"/>project:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Go to <code class="literal">File</code> -&gt; <code class="literal">Import</code> -&gt; navigate to <code class="literal">build.sbt</code></li></ul></div></li><li class="listitem">Open the program in IDE:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Start IDEA</li><li class="listitem" style="list-style-type: disc">Press <code class="literal">Open</code></li><li class="listitem" style="list-style-type: disc">Select <code class="literal">day1-lesson1/1-project/build.sbt</code></li></ul></div></li><li class="listitem">In the dialog window, which asks whether to <a class="indexterm" id="id13"/>open it as a file or as a project, select <code class="literal">project</code>.</li><li class="listitem">On the left part of the project's structure, unfold <code class="literal">src</code> entry.</li><li class="listitem">Click on <code class="literal">main.</code></li><li class="listitem">Ensure that you can see <code class="literal">main</code>, as specified in the code.</li><li class="listitem">Ensure that project can be compiled and run via the <code class="literal">sbt</code> console.</li></ol></div><p>For running our project from the IDE, we should edit the project's configuration (Menu: 
<code class="literal">Build</code>/
<code class="literal">Edit configuration</code> or 
<code class="literal">Run</code>/
<code class="literal">Edit</code> configuration, depending on which version of IDEA you are using).
</p><p>
<span class="strong"><strong>Running the Project from IDE:</strong></span>
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Select <code class="literal">Run</code>/<code class="literal">Edit Configuration.</code></li><li class="listitem">Select <code class="literal">Application</code>.</li><li class="listitem">Set the<a class="indexterm" id="id14"/> application's name. In our case, use <code class="literal">Chatbot1</code>.</li><li class="listitem">Set the<a class="indexterm" id="id15"/> name of the <code class="literal">Main</code> class. In our case, it must be <code class="literal">com.packt.courseware.Chatbot1</code>.</li><li class="listitem">Actually run the application: select Run, then Chatbot1 from the dropdown menu.</li></ol></div></div><div class="section" title="REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>REPL</h2></div></div></div><p>Another tool 
<a class="indexterm" id="id16"/>that we will frequently use is REPL (Read Eval Print Loop). It is often used for quickly evaluating Scala expressions.
</p><p>From 
<code class="literal">sbt</code>, we can enter REPL mode with the help of the 
<code class="literal">sbt console</code> command. Let's try some 
<a class="indexterm" id="id17"/>simple expressions.
</p><p>Now, we'll look at how to evaluate expressions. Follow these steps to do so:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">sbt</code> tool.</li><li class="listitem">Open <code class="literal">REPL</code> by typing the following command:<div class="informalexample"><pre class="programlisting">sbt console</pre></div></li><li class="listitem">Type the following expressions and press <span class="emphasis"><em>Enter</em></span>:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">2 + 2</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">"2" + 2</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">2 + "2"</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">(1 to 8).sum</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.time.LocalTime.now()</code></li></ul></div></li></ol></div><p>Please note that we can have an interactive Scala 
<code class="literal">playboard</code> inside IDE by creating a special file type: a Scala Worksheet. It's useful, but is mainly for demonstration purposes.
</p></div><div class="section" title="Obtaining the Time Request from Our Chatbot Program"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Obtaining the Time Request from Our Chatbot Program</h2></div></div></div><p>For now, let's return to our task: modifying the 
<code class="literal">chatbot</code> program so that it replies with 
<a class="indexterm" id="id18"/>the current time, as requested by the use of 
<code class="literal">time</code>. Let's learn how to do this:
</p><p>
<span class="strong"><strong>Steps for C</strong></span>
<span class="strong"><strong>ompletion</strong></span>
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Check for <code class="literal">time</code> to match the statement:<div class="informalexample"><pre class="programlisting">case "time" =&gt;</pre></div></li><li class="listitem">Retrieve the current time using the Java API. Use the <code class="literal">now</code> method of <code class="literal">java.time.LocalTime</code>:<div class="informalexample"><pre class="programlisting">     java.time.LocalTime.now()</pre></div></li><li class="listitem">Display the output of the time using string interpolators, as follows:<div class="informalexample"><pre class="programlisting">println("time is ${java.time.LocalTime.now()}")</pre></div></li></ol></div><p>The 
<code class="literal">main</code> method will look like this:
</p><div class="informalexample"><pre class="programlisting">def main(args: Array[String]): Unit = {
val name = StdIn.readLine("Hi! What is your name?")
println(s" $name, tell me something interesting, say 'bay' to end the talk")
var timeToBye = false
while (!timeToBye)timeToBye = StdIn.readLine("&gt;") 
match {case "bye" =&gt; println("ok, bye")truecase "time" =&gt; 
println(s"time is ${java.time.LocalTime.now()}")truecase _ =&gt; 
println("interesting...")false}
}</pre></div><p>After we prepare and package our artifacts, we need to run them as well.</p><p>In this book, we will 
<a class="indexterm" id="id19"/>use the running system from unpackaged sources via 
<code class="literal">sbt</code> (as in the early days of Ruby applications), assuming that sources and 
<code class="literal">sbt</code> tools are accessible from the production environment. Using this, we can use build tool commands for sources such as 
<code class="literal">sbt run</code>. In real life, packaging for production is a bit more complex.
</p><p>Popular methods for doing this are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Preparing a fat jar (which includes all dependencies). An <code class="literal">sbt</code> plugin for this exists, which can be found at the following link: <a class="ulink" href="https://github.com/sbt/sbt-assembly">https://github.com/sbt/sbt-assembly</a>.</li><li class="listitem" style="list-style-type: disc">Preparing a native system package (which includes jars, dependencies, custom layouts, and so on). There is also an <code class="literal">sbt</code> plugin to create native system packages, which can be found at the following link: <a class="ulink" href="https://github.com/sbt/sbt-native-packager">https://github.com/sbt/sbt-native-packager</a>.</li></ul></div></div></div>
<div class="section" title="Base Syntax"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Base Syntax</h1></div></div></div><p>Now that we
<a class="indexterm" id="id20"/> can use REPL, let's understand the base Scala syntax. For now, it's not 
<a class="indexterm" id="id21"/>necessary to learn it in detail, but let's get familiar with it by using an example.
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>For a formal, detailed description, refer to the SLS: Scala Language Specification here: 
<a class="ulink" href="http://scala-lang.org/files/archive/spec/2.12/">http://scala-lang.org/files/archive/spec/2.12/</a>.
</p></div></div><div class="section" title="Base Syntax for Definitions"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Base Syntax for Definitions</h2></div></div></div><p>Scala 
<a class="indexterm" id="id22"/>compilation unit – This is a set of definitions inside an entity  (template-entity), which can be an object, a class, or a trait. We will speak about the Object-Oriented part of the Scala language in detail later. Now, let's look at the basic syntax. Let's define some classes in REPL:
</p><div class="informalexample"><pre class="programlisting">&gt; class X {  def f():Int = 1 }
&gt; Class X defined  // answer in REPL</pre></div><p>Definitions inside the entity can be nested entities, functions, or values:</p><div class="informalexample"><pre class="programlisting">&gt; def f():Int = 1</pre></div><p>Here, the function 
<code class="literal">f</code> is defined, returning 
<code class="literal">1</code>. We will talk about this function in detail in 
<a class="link" href="ch03.html" title="Chapter 3. Functions">Chapter 3</a>, 
<span class="emphasis"><em>Functions</em></span>. Now, let's stay on the top-level view:
</p><div class="informalexample"><pre class="programlisting">&gt; val x = 1</pre></div><p>Here, the value 
<code class="literal">x</code> is defined with value 
<code class="literal">1</code>:
</p><div class="informalexample"><pre class="programlisting">&gt; var y = 2</pre></div><p>Here, the mutable variable 
<code class="literal">y</code> is defined with value 
<code class="literal">2</code>.
</p><p>Other high-level entities include objects and traits. We can create objects by writing object or trait definitions:</p><div class="informalexample"><pre class="programlisting">&gt;  object O {  def f():Int =1  }
&gt;  trait O {  def f():Int =1  } </pre></div><p>We will talk about classes, objects, and traits in the next chapter.</p><p>Now, let's look at defining an object in REPL with the name ZeroPoint.</p><p>
<span class="strong"><strong>Steps for Completion:</strong></span>
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open REPL <a class="indexterm" id="id23"/>by typing the following command in <code class="literal">sbt</code>:<div class="informalexample"><pre class="programlisting">sbt console</pre></div></li><li class="listitem">Type in the following commands in REPL:<div class="informalexample"><pre class="programlisting">&gt;  object ZeroPoint {
&gt;     val x:Int = 0
&gt;     val y:Int = 0
&gt; }</pre></div></li></ol></div></div><div class="section" title="Base Syntax for Expressions"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Base Syntax for Expressions</h2></div></div></div><p>Scala is an 
<a class="indexterm" id="id24"/>expression-based language, which means that everything is an expression (in the right-hand side of function and value/variable definitions).
</p><p>Some of the base expressions are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Primitive expression: Constant or value/variable name.</li><li class="listitem" style="list-style-type: disc">Function calls: These can be:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Usual function calls <code class="literal">f(x, y)</code>.</li><li class="listitem" style="list-style-type: disc">Operator call syntax:</li><li class="listitem" style="list-style-type: disc">binary: <code class="literal">x + y</code>.</li></ul></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>Any method with an argument can be used as a binary operator. A set of predefined binary operators are similar to Java:</p></div></div></li><li class="listitem" style="list-style-type: disc">unary: <code class="literal">!x</code></li><li class="listitem" style="list-style-type: disc">Constructors: <code class="literal">new x</code> creates an instance of class x.</li><li class="listitem" style="list-style-type: disc">Assignments to mutable variables:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">y = 3</code>: Assigns a value of <code class="literal">3</code> to <code class="literal">y</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">x = 3</code>: This is a compiler error, and a value can't be assigned.</li></ul></div></li><li class="listitem" style="list-style-type: disc">Block:<div class="informalexample"><pre class="programlisting">{ A; B }</pre></div><p>The value 
<a class="indexterm" id="id25"/>of a block expression is the last expression. Note that 
<code class="literal">;</code> can be omitted if 
<code class="literal">A</code> and 
<code class="literal">B</code> are situated on different lines. The syntax for this is shown as follows:
</p><div class="informalexample"><pre class="programlisting">{
   A
   B
}</pre></div></li></ul></div><p>The preceding syntax will have the same output as 
<code class="literal">{ A; B }</code>.
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Control structures<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">if</code> statement:<div class="informalexample"><pre class="programlisting">       &gt;  if (1 == 1)  "A"  else "B"
       - let's eval one in REPL</pre></div></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">match/case expressions:<div class="informalexample"><pre class="programlisting">    &gt;  x match {
         case "Jon"  =&gt;  doSomethingSpecialForJon()
         case "Joe" =&gt;   doSomethingSpecialForJoe()
         case   _   =&gt; doForAll()
      }</pre></div></li><li class="listitem" style="list-style-type: disc">Loops:</li><li class="listitem" style="list-style-type: disc"><code class="literal">while</code>/<code class="literal">do</code><div class="informalexample"><pre class="programlisting">     var i=0
      var s=0
      while(i &lt; 10) {
          s = s+i
          i = i +1
      }</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">Do</code>/<code class="literal">while</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Foreach</code>, <code class="literal">for</code></li></ul></div></li></ul></div><p>Shortcuts for
<a class="indexterm" id="id26"/> height-order functions will be described in detail in, 
<a class="link" href="ch04.html" title="Chapter 4. Scala Collections">Chapter 4</a>, 
<span class="emphasis"><em>Scala Collections</em></span>.
</p><p>We'll look at defining a main function which prints something onscreen and calls the main function.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">You should have already opened <code class="literal">project1</code>. If you haven't, import it into the IDE.</li><li class="listitem">Insert the new method inside the object definition.</li><li class="listitem">Insert call at the <code class="literal">main</code> method.</li></ol></div><p>The full method should look something like this:</p><div class="informalexample"><pre class="programlisting">  object Chatbot1 {def printHello():Unit = {
println("Hello")}def main(args: Array[String]): Unit = {
printHello() … // unchanged code here
     }
}</pre></div></div></div>
<div class="section" title="Unit Testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Unit Testing</h1></div></div></div><p>In any program 
<a class="indexterm" id="id27"/>which is bigger than arithmetic operations, programmers should make themselves comfortable when it is possible to ensure that new changes are not breaking old functionalities.
</p><p>The most 
<a class="indexterm" id="id28"/>common technique for this is unit testing, which is where the programmer tests the functionality of the code in parallel with its development by creating a test code which will verify that the code really satisfies their requirements.
</p><p>The theme of this section will be introducing tools for unit testing in Scala.</p><div class="section" title="Adding a Test to Our Project"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>Adding a Test to Our Project</h2></div></div></div><p>Let's add tests 
<a class="indexterm" id="id29"/>to our small program. We'll import 
<code class="literal">&lt;for-students/lesson1/2-project&gt;</code> in our IDE.
</p><p>This is the
<a class="indexterm" id="id30"/> directory schema of a Scala project. For adding tests, we should do the following:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add test dependencies to <code class="literal">build.sbt</code></li><li class="listitem" style="list-style-type: disc">Write tests in the source test directory</li></ul></div><p>For adding dependency, let's add the following line to our 
<code class="literal">build.sbt</code>:
</p><div class="informalexample"><pre class="programlisting">libraryDependencies += "org.scalatest" %% "scalatest" % "3.0.4" % "test"</pre></div><p>It's an 
<a class="indexterm" id="id31"/>expression in Scala DSL (domain-specific language), which means that we should add 
<code class="literal">scalatest</code> to our set of library 
<a class="indexterm" id="id32"/>dependencies. Operators 
<code class="literal">%%</code> and 
<code class="literal">%</code> are used for forming the name and classifier for published artifacts. You can refer to the 
<code class="literal">sb</code>
<code class="literal">t</code> documentation for more detail: 
<a class="ulink" href="http://www.scala-sbt.org/1.x/docs/Library-Dependencies.html">http://www.scala-sbt.org/1.x/docs/Library-Dependencies.html</a>.
</p><p>Before compilation, 
<code class="literal">sbt</code> will download 
<code class="literal">scalatest</code> from a publicly available repository (Maven central), and when running tests, it will add 
<code class="literal">scalatest</code> to the classpath.
</p><p>We will 
<a class="indexterm" id="id33"/>now run 
<code class="literal">sbt</code> tests from the command line.
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the command-line environment, navigate to<a class="indexterm" id="id34"/> the root of the project and select the following test:<div class="informalexample"><pre class="programlisting">  Lesson 1/2-project</pre></div></li><li class="listitem">If you are using a Unix/Linux machine and your code is situated in <code class="literal">courses/pactscala</code> of your home <code class="literal">directory</code>, then run the following command:<div class="informalexample"><pre class="programlisting"> &gt; cd  ~/courses/packscala/Lesson 1/2-project</pre></div></li><li class="listitem">Run the following command<code class="literal">:</code><div class="informalexample"><pre class="programlisting">    &gt; sbt test</pre></div></li><li class="listitem">You will <a class="indexterm" id="id35"/>get the<a class="indexterm" id="id36"/> expected output, which will include the following strings:<div class="informalexample"><pre class="programlisting">[info] ExampleSpec:
[info] - example test should pass
[info] StepTest:
[info] - step of unparded word must be interesting</pre></div></li></ol></div><p>We will now see how to
<a class="indexterm" id="id37"/> run 
<code class="literal">sbt</code> tests from IDEA IDE.
</p><p>We'll now run sbt Tests from IDEA IDE.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open<a class="indexterm" id="id38"/> the project in the IDE.</li><li class="listitem">Navigate to <span class="strong"><strong>Run</strong></span>/<span class="strong"><strong>Edit Configurations:</strong></span><div class="mediaobject"><img alt="Adding a Test to Our Project" src="graphics/1_02.jpg"/></div></li><li class="listitem">Choose s<code class="literal">bt test</code> as the configuration.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Check<a class="indexterm" id="id39"/> the<a class="indexterm" id="id40"/> checkbox <span class="strong"><strong>Use sbt:</strong></span></li></ul></div><div class="mediaobject"><img alt="Adding a Test to Our Project" src="graphics/1_03.jpg"/></div></li><li class="listitem">Select <span class="strong"><strong>Run sbt-test</strong></span>.</li></ol></div></div><div class="section" title="Inside Tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Inside Tests</h2></div></div></div><p>Now let's look at 
<a class="indexterm" id="id41"/>a simple test:
</p><div class="informalexample"><pre class="programlisting">package com.packt.courseware.l1
import org.scalatest.FunSuite

class ExampleSpec extends FunSuite {

  test("example test  should pass") {
     assert(1==1)
  }

}</pre></div><p>Here, we define 
<a class="indexterm" id="id42"/>a class which is inherited from scalatest FunSuite.
</p><p>The test expression is called. When the 
<code class="literal">FunSuite</code> class is initialized and added to a set of tests, the test with 
<code class="literal">name example test should pass</code> and assert an expression as an argument. For now, this looks like magic, but we will show you how to build such DSLs in the next chapter.
</p><p>Let's run our test with the help of 
<code class="literal">sbt</code>:
</p><div class="informalexample"><pre class="programlisting">sbt test</pre></div><p>This command will run all tests and evaluate the test expression.</p><p>Now, we'll add another test.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add one more test to the same file: <code class="literal">src/test/scala/com/packt/courseware/l1/ExampleSpec.scala in 2-project</code></li><li class="listitem">We write one <code class="literal">trivial</code> test, which asserts the <code class="literal">false</code> expression:<div class="informalexample"><pre class="programlisting">      test("trivial")  {
            assert(false)
       }</pre></div></li><li class="listitem">Run the test and look at error reporting.</li><li class="listitem">Invert the <a class="indexterm" id="id43"/>expression in assert so that the test passes:<div class="informalexample"><pre class="programlisting">      test("trivial")  {
            assert(true)
       }</pre></div></li><li class="listitem">Run the <code class="literal">sbt</code> test again to ensure that all of the tests pass.</li></ol></div></div><div class="section" title="Running Tests for Chatbot"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"/>Running Tests for Chatbot</h2></div></div></div><p>Remember that, 
<a class="indexterm" id="id44"/>when writing 
<code class="literal">chatbot</code>, we want to test one functionality. Our original program only has one function (
<code class="literal">main</code>), which contains all of the logic and can't be split into testable parts.
</p><p>Let's look at Version 2.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>Please import 
<code class="literal">Lesson 1/2-project</code> into your IDE.
</p></div></div><div class="informalexample"><pre class="programlisting">package com.packt.courseware.l1

import java.time.LocalTime
import java.time.format.DateTimeFormatter
import scala.io.StdIn

case class LineProcessResult(answer:String,timeToBye:Boolean)

object Chatbot2 {

  def main(args: Array[String]): Unit = {
    val name = StdIn.readLine("Hi! What is your name? ")
    println(s" $name, tell me something interesting, say 'bye' to end the talk")

    var c = LineProcessResult("",false)
    while(!c.timeToBye){
      c = step(StdIn.readLine("&gt;"))
      println(c.answer)
    }

  }

  def step(input:String): LineProcessResult = {
    input match {
      case "bye" =&gt; LineProcessResult("ok, bye", true)
      case "time" =&gt; LineProcessResult(LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm:ss")),false)
      case _ =&gt; LineProcessResult("interesting...", false)
    }
  }

}</pre></div><p>Here, we see some new constructs:</p><p>
<code class="literal">LineProcessingResult</code> is a case class, where the result of processing one of the lines (that is, the 
<code class="literal">chatbot</code> answer and quit flag) is stored.
</p><p>What is the word 
<code class="literal">case</code> before class?
</p><p>
<code class="literal">case</code> classes can 
<a class="indexterm" id="id45"/>participate in pattern matching (while we call one 
<code class="literal">case</code>) and are usually used for data objects. We will look at 
<code class="literal">case</code> classes during the next chapter. It is important to see that an instance of 
<code class="literal">case</code> classes can be created with the 
<code class="literal">LineProcessingResult(x,y)</code> syntax (that is, without 
<code class="literal">new</code>) and an argument to case class constructors (
<code class="literal">answers</code> and 
<code class="literal">timeToBye</code>), which automatically become instance variables of the 
<code class="literal">case</code> class.
</p><p>The functionality of processing one line is encapsulated in the 
<code class="literal">step</code> method, which we can test.
</p><p>
<code class="literal">Step</code> receives input from the method argument, not from 
<code class="literal">System.in</code>, therefore making it easier to test. In the case of directly testing the 
<code class="literal">main</code> method, we will need to substitute 
<code class="literal">System.in</code> before 
<code class="literal">test</code> and return one back after the test is finished.
</p><p>Ok, let's focus on the first test:</p><div class="informalexample"><pre class="programlisting">package com.packt.courseware.l1

import org.scalatest.FunSuite

class StepTestSpec extends FunSuite {

  test("step of unparded word must be interesting") {
    val r = Chatbot2.step("qqqq")
    assert(! r.timeToBye)
    assert(r.answer == "interesting...")
  }

}</pre></div><p>Writing the 
<a class="indexterm" id="id46"/>second test in the same manner will be an easy task. We will look at this in the following exercise.
</p><p>Now, let's add the second test, which checks bye.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a second test to the <code class="literal">StepTestSpec</code> class in our project:<div class="informalexample"><pre class="programlisting">test("after bye, timeToBye should be set to true")
{

}</pre></div></li><li class="listitem">In this test:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Call the step function with <code class="literal">bye</code> as a parameter:<div class="informalexample"><pre class="programlisting">val r = Chatbot2.step("bye")</pre></div></li><li class="listitem" style="list-style-type: disc">Check that after this call that <code class="literal">timeToQuit</code> in the returned class is set to <code class="literal">true</code>:<div class="informalexample"><pre class="programlisting">assert(! r.timeToBye)</pre></div></li></ul></div></li><li class="listitem">The whole code should be as follows:<div class="informalexample"><pre class="programlisting">
<code class="literal">test("after bye, timeToBye should be set to true") {  
val r = Chatbot2.step("bye")</code>
assert(! r.timeToBye)
</pre></div></li><li class="listitem">Run <code class="literal">sbt test.</code></li></ol></div><p>A more 
<a class="indexterm" id="id47"/>complex task would be to write a test for the time query.
</p><p>Please note that we can't run the test with the concrete time value, but at least we can be sure that the bot answer can't be parsed back to the time form.</p><p>So, what can we do to check the line answer and try to transform it back to time? The solution is provided in the following code:</p><div class="informalexample"><pre class="programlisting">test("local time must be parser") {
val r = Chatbot2.step("time")
val formatter = DateTimeFormatter.ofPattern("HH:mm:ss")
val t = LocalTime.parse(r.answer,formatter)// assertion is not necessary
}</pre></div><p>Note that assertion is not necessary. If time does not satisfy the given format, then an exception will be thrown.</p><p>It is a good practice to separate functional and effects time for testing. To do this, we will need to substitute the provider of the system time via own.</p><p>This will be the first practical task in the next chapter.</p><p>Now, let's add the date command to our chatbot program.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"> Add the following code to the match statement so that it checks for the <code class="literal">date</code> command, which should output the local date in <code class="literal">DD:MM:YYYY</code> format:<div class="informalexample"><pre class="programlisting">  case "date" =&gt; LineProcessResult(LocalDate.now().format(DateTimeFormatter.ofPattern("dd:YYYY-MM")),false)</pre></div></li><li class="listitem">Add a<a class="indexterm" id="id48"/> test case for this function.</li><li class="listitem">The resulting code will be as follows:<div class="informalexample"><pre class="programlisting">test("local date must be parser") {
val r = Chatbot2.step("date")
val formatter = DateTimeFormatter.ofPattern("dd:MM-YYYY")
val t = LocalDate.parse(r.answer,formatter)// assertion is not necessary
}</pre></div></li></ol></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Summary</h1></div></div></div><p>We have reached the end of the chapter. In this chapter, we learned various aspects of setting up the development environment. We covered the structure of a Scala project, and we identified the use of 
<code class="literal">sbt</code> for building and running projects. We covered REPL, which is a command-line interface for running Scala code. We also covered how to develop and run code over the IDEA IDE. Finally, we implemented interactions with our simple 
<code class="literal">chatbot</code> application.
</p><p>In the next chapter, we will cover the structure of a Scala program and dive deep into the object-oriented properties in Scala, such as like classes, objects, and traits. We will also cover the syntax for calling functions and various parameter-passing models.</p></div></body></html>