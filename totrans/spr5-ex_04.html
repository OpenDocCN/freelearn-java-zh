<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Kotlin Basics and Spring Data Redis</h1>
                </header>
            
            <article>
                
<p class="mce-root">Spring Boot allows developers to create different styles of application. In <a href="8b857b24-87be-4066-acb3-daa9a596b61e.xhtml" target="_blank">Chapter 2</a>, <em>Starting in the Spring World – the CMS Application</em>, and <a href="827e9516-ff3d-44d7-8a16-95579684f453.xhtml" target="_blank">Chapter 3</a>,<a href="827e9516-ff3d-44d7-8a16-95579684f453.xhtml" target="_blank"/><em> Persistence with Spring Data and Reactive Fashion</em>, we have created a portal application, and now we will create an application based on message-driven architecture. It demonstrates how the Spring Framework fits well in a wide range of application architectures.</p>
<p>In this chapter, we will start to create an application which keeps the tracked hashtags on the Redis database. The application will get hashtags and <span>put them in a couple of queues to our other projects, and consume and handle them appropriately.</span></p>
<p>As we have been doing in our previous projects, we will continue to use the Reactive Foundation to provide scalable characteristics in the application.</p>
<p>At the end of this chapter, we will have:</p>
<ul>
<li>Learned Kotlin basics</li>
<li><span>Created the project structure</span></li>
<li>Created the Reactive Redis repositories</li>
<li>Applied some techniques in reactive programming, using the Reactive Redis Client</li>
</ul>
<p>Let's start right now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning Kotlin basics</h1>
                </header>
            
            <article>
                
<p>The Kotlin language was released officially in February 2016. JetBrains created it and has been developing the language ever since. The company is the owner of the IntelliJ IDEA IDE. </p>
<p>In February 2012, JetBrains made the language open source under the Apache v2 license; the license <span>allows developers to create applications.</span></p>
<p>The language is one option for <strong>JVM</strong> <span>(</span><strong>Java Virtual Machine</strong><span>) </span>languages such as Clojure and Scala, which means that the language can compile bytecode for JVM. As we will see, Kotlin has many similarities with Scala. Kotlin has the Scala language as a reference, but the JetBrains teams believe that Scala has problems with the compilation time.</p>
<p>Kotlin was becoming an adopted language in the Android world and because of this, in the Google I/O, 2017, the Google Team announced official support for the Android ecosystem. Since then, the language has been growing year by year and increasing in popularity.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Main characteristics of Kotlin</h1>
                </header>
            
            <article>
                
<p>The Kotlin language was designed to maintain the interoperability with Java code. It means we can start to code with Java idioms in the Kotlin file.</p>
<p>The language is statically-typed, and it is an excellent attribute because it can help us find some problems at compilation time. Also, <span>statically-typed languages are much faster than dynamic languages.</span> The IDEs can help developers much better than dynamic languages, as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Syntax</h1>
                </header>
            
            <article>
                
<p>The syntax is different from Java syntax. At first glance, it can be a problem but after some hours of playing with Kotlin, it is not a problem at all.</p>
<p>There are two interesting reserved words to understand the usage and concepts:</p>
<ul>
<li><kbd>var</kbd>: This is a variable declaration. It indicates the variable is mutable and can be reassigned, as developers need.</li>
<li><kbd>val</kbd>: This is a variable declaration which indicates the variable is immutable and cannot be reassigned anymore. This definition is like a final declaration in the Java language.</li>
</ul>
<p>The variable declarations have a name, and after the desired data type, the colon is necessary in the middle as a separator. If the variable is initialized, the type is not necessary because the compiler can infer the correct data type. Let's try it out to understand it better.</p>
<p>Here is a variable with the data type specified:</p>
<pre><strong>var </strong>bookName: String</pre>
<p>In this case, we need to keep the data type because the variable is not initialized, then the compiler cannot infer the type. The variable, <kbd>bookName</kbd>, can be <span>reassigned</span> because of the modifier <kbd>var</kbd>.</p>
<p>Here is a variable without the data type:</p>
<pre><strong>val </strong>book = <span>"Spring 5.0 by Example"</span></pre>
<p>It is not a necessity to declare the data type because we have initialized the variable with the value, <kbd>Spring 5.0 by Example</kbd>. The compiler can infer the type is a kind of <em><span>syntactic sugar</span>.</em> The variable cannot be reassigned because of the modifier <kbd>val</kbd>. If we try to reassign the instruction, we will get a compilation error.</p>
<p>The semicolons are optional in Kotlin, the compiler can detect the statement terminator. This is another point where Kotlin diverges from the Java programming language:</p>
<pre><span>val </span>book = <span>"Spring 5.0 by Example"<br/></span><span>var </span>bookName: String<br/><span>println</span>(<span>"Hello, world!"</span>)</pre>
<p>The semicolons were not provided, and the instructions were compiled.</p>
<div class="packt_tip">Immutable programming in the Kotlin language is recommended. It performs better on the multi-core environments. Also, it makes the developer's life easier to debug and troubleshoot scenarios.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Semantics</h1>
                </header>
            
            <article>
                
<p>In Kotlin, there are classes and functions. However, there is no method anymore. The <kbd>fun</kbd> keyword should be used to declare a function.</p>
<p>Kotlin gets some concepts of the Scala language and brings some special classes such as Data classes and Object classes (which we will learn soon). Before that, we will understand how to declare a function in Kotlin. Let's do that!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Declaring functions in Kotlin</h1>
                </header>
            
            <article>
                
<p>There are many variations in function declarations. We will create some declarations to understand the slight difference from Java methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Simple function with parameters and return type</h1>
                </header>
            
            <article>
                
<p>This simple function has two parameters and a String as a return type. Take a look at a parameter declaration and observe the order, name and data type.</p>
<pre><strong>fun greetings(name:String,greeting:String):String{</strong><br/>  return greeting + name<br/>}</pre>
<p>As we can see, the type of argument which comes after the variable name is the <span>same as</span> on the variable declarations. The return type comes after the arguments list is separated with semicolons. The same function can be declared in the following way in Java:</p>
<pre><strong>public String greetings(String name,String greeting)</strong>{<br/>  return greeting + name;<br/>}</pre>
<p>There are some differences here. Firstly, there are semicolons in the Java code, and we can see the order of the methods and functions declarations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Simple function without return</h1>
                </header>
            
            <article>
                
<p>Let's understand how we can construct functions without a return value, the following function will not return any value:</p>
<pre><span>fun </span><span>prin</span><span>tGreetings</span>(name:String<span>,</span>greeting:String):<strong>Unit</strong>{<br/><span>  println</span>(greeting + name)<br/>}</pre>
<p>There is one difference, in this case, the <kbd>Unit</kbd> was introduced; this type of object corresponds to <kbd>void</kbd> in Java language. Then, in the preceding code, we have a function without a return. The <kbd>Unit</kbd> object can be removed if you want the compiler to understand the function has no return value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Single expressions functions</h1>
                </header>
            
            <article>
                
<p>When the function has a single expression we can remove the curly braces, the same as in Scala, and the function body should be specified after the <kbd>=</kbd> symbol. Let's refactor our first function, as follows:</p>
<pre><span>fun</span> <span>greetings</span>(name:String<span>,</span>greeting:String) = greeting + name</pre>
<p>We can remove the <kbd>return</kbd> keyword, as well. Our function is pretty concise now. We removed <kbd>return</kbd> and the type of return as well. As we can see, the code is more readable now. If you want, the return type can be declared too.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overriding a function</h1>
                </header>
            
            <article>
                
<p>To override a function on Kotlin, it is necessary to put an <kbd>override</kbd> keyword on the function declaration, and the base function needs to have the <kbd>open</kbd> keyword as well.</p>
<p>Let's look at an example:</p>
<pre style="padding-left: 30px">open class Greetings {<br/>  <strong>open</strong> fun greeting() {}<br/>}<br/> <br/>class SuperGreeting() : Greetings() {<br/><strong>  override</strong> fun greeting() {<br/>  // my super greeting<br/>  }<br/>}</pre>
<p>This way is more explicit than Java, it increases the legibility of the code as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data classes</h1>
                </header>
            
            <article>
                
<p>Data classes are the right solution when we want to hold and transfer data between system layers. Like in Scala, these classes offer some built-in functionalities such as <kbd>getters/setters</kbd>, <kbd>equals</kbd> and <kbd>hashCode</kbd>, <kbd>toString</kbd> method and the <kbd>copy</kbd> function.</p>
<p>Let's create an example for that:</p>
<pre><span>data class</span> Book(<span>val</span> <span>author</span>:String<span>,val</span> <span>name</span>:String<span>,val</span> <span>description</span>:String<span>,val</span> <span>new</span>:Boolean = <span>false</span>)</pre>
<p>We have some interesting things in the code. The first thing we notice is that all of the attributes are immutable. It means there are no setters for all of them. The second is that in the class declaration, we can see a list of attributes. In this case, Kotlin will create a constructor with all attributes present in this class and because they are <kbd>val</kbd> it means final attributes.</p>
<p>In this case, there is no default constructor anymore.</p>
<p>Another interesting feature in Kotlin is that it enables developers to have default values on constructors, in our case the <kbd>new</kbd> attribute, if omitted, will assume the <kbd>false</kbd> value. We can get the same behavior in the parameters list in functions as well.</p>
<p>Finally, there is a fantastic way to copy objects. The <kbd>copy</kbd> method allows developers to copy objects with named parameters. This means we can change only attributes as we need. Let's take a look at an example:</p>
<pre><span>fun</span> <span>main</span>(args : Array&lt;String&gt;) {<br/><span>  val</span> springFiveOld = Book(<span>"Claudio E. de Oliveira"</span><span>,</span><span>"Spring 5.0 by Example"</span><span>,</span><span>"Amazing example of Spring Boot Apps"</span><span>,false</span>)<br/>  <span>val</span> springFiveNew = <strong>springFiveOld.copy(new = true)</strong><br/>  <span>println</span>(springFiveOld)<br/>  <span>println</span>(springFiveNew)<br/>}</pre>
<p>In the first object, we have created a book instance with <kbd>false</kbd> for the <kbd>new</kbd> attribute, then we copied a new object with <kbd>true</kbd> for the <kbd>new</kbd> attribute, and the other attributes are not changed. Goodbye to the complex clone logic and nice to meet the new way to copy objects.</p>
<p>The output of this code should look like the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3b9b01fb-bf93-4708-9fee-443e96cb94d9.png"/></div>
<p>As we can see, only the <kbd>new</kbd> attribute is changed and the <kbd>toString</kbd> function was generated in good shape as well.</p>
<p>There are some restrictions on Data classes. They cannot be abstract, open, sealed, or inner.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Objects</h1>
                </header>
            
            <article>
                
<p>The singleton pattern is commonly used in applications, and Kotlin provides an easy way to do that without much boilerplate code.</p>
<p><span>We can instruct Kotlin to create a singleton object using the <kbd>object</kbd> keyword</span>. Once again,  Kotlin used Scala as a reference because there are the same functionalities in the Scala language.</p>
<p>Let's try it:</p>
<pre><strong>object</strong> BookNameFormatter{<br/><span>  fun</span> <span>format</span>(book: Book):String = <span>"The book name is"</span> + book.<span>name<br/></span>}</pre>
<p>We have created a formatter to return a message with the book name. Then, we try to use this function:</p>
<pre><span>val</span> springFiveOld = Book(<span>"Claudio E. de Oliveira"</span><span>,</span><span>"Spring 5.0 by Example"</span><span>,</span><span>"Amazing example of Spring Boot Apps"</span><span>,false</span>)<br/><strong>BookNameFormatter.format(springFiveOld)</strong></pre>
<p>The function format can be called in a static context. There is no instance to call the function because it is a singleton object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Companion objects</h1>
                </header>
            
            <article>
                
<p>A <strong>companion object</strong> is an object which is common for all instances of that class. It means there are many instances of a book, for example, but there is a single instance of their companion object. Usually, the developers use companion objects as a factory method. Let's create our first <kbd>companion object</kbd>:</p>
<pre><span>data class</span> Book(<span>val</span> <span>author</span>:String<span>,val</span> <span>name</span>:String<span>,val </span><span>description</span>:String<span>,val</span> <span>new</span>:Boolean = <span>false</span>{<br/> <br/>  <strong>companion object</strong> {<br/><span>    fun</span> <span>create</span>(name:String<span>,</span>description: String<span>,</span>author: String):Book{<br/><span>      return</span> Book(author<span>,</span>name<span>,</span>description)<br/>    }<br/>  }<br/><br/>}</pre>
<p>If the name of the <kbd>companion object</kbd> was omitted, the function could be called in a singleton way, without an instance, like this:</p>
<pre><span>val</span> myBookWithFactory = <strong>Book.create</strong>(<span>"Claudio E. de Oliveira"</span><span>,</span><span>"Spring 5.0 by Example"</span><span>,</span><span>"Amazing example of Spring Boot Apps"</span>)</pre>
<p>It is like an <kbd>object</kbd> behavior. We can call it in a static context.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Kotlin idioms</h1>
                </header>
            
            <article>
                
<p>Koltin idioms are a kind of syntax sugar for Java programmers. It is a collection of pieces of code which help developers to create a concise code in Kotlin languages. Let's take a look at common Kotlin idioms.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">String interpolation</h1>
                </header>
            
            <article>
                
<p>Kotlin supports string interpolation, it is a little bit complex to do it in the Java language but it is not a problem for Kotlin. We do not require a lot of code to do this task as Kotlin supports it natively. It makes the code easier to read and understand. Let's create an example:</p>
<pre><span>val</span> bookName = <span>"Spring 5.0"<br/></span><span>val</span> phrase = <span>"The name of the book is</span> <strong>$bookName</strong><span>"</span></pre>
<p>As we can see,  it is a piece of cake to interpolate strings in Kotlin. Goodbye <kbd>String.format()</kbd> with a lot of arguments. We can use <kbd>$bookName</kbd> to replace the <kbd>bookName</kbd> variable value. Also, we can access the functions present in objects, but for that, we need to put curly braces. Check the following code:</p>
<pre><span>val</span> springFiveOld = Book(<span>"Claudio E. de Oliveira"</span><span>,</span><span>"Spring 5.0 by Example"</span><span>,</span><span>"Amazing example of Spring Boot Apps"</span><span>,false</span>)<br/><span>val</span> phrase = <span>"The name of the book is</span> <strong>${springFiveOld.name}</strong><span>"</span></pre>
<p>Thanks, Kotlin we appreciate this feature.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Smart Casts</h1>
                </header>
            
            <article>
                
<p>Kotlin supports the feature called Smart Casts which enables developers to use the cast operators automatically. After checking the variable type, in Java, the cast operator must be explicit. Let's check it out:</p>
<pre><span>fun</span> <span>returnValue</span>(instance: Any): String {<br/>  <strong>if (instance is String) {</strong><br/>    <strong>return instance</strong><br/>  <strong>}</strong><br/>  <span>throw</span> IllegalArgumentException(<span>"Instance is not String"</span>)<br/>} </pre>
<p>As we can see, the cast operator is not present anymore. After checking the type, Kotlin can infer the expected type. Let's check the Java version for the same piece of code:</p>
<pre>public String returnValue(Object instance) {<br/>  if (instance instanceof String) {<br/>    <strong>String value = (String) instance;</strong><br/>      <strong>return value;</strong><br/>    <strong>}</strong><br/>    throw IllegalArgumentException("Instance is not String");<br/>}</pre>
<p>It makes the cast safer because we do not need to check and apply the cast operator.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Range expressions</h1>
                </header>
            
            <article>
                
<p>Range expressions permit developers to work with ranges in <kbd>for</kbd> loops and <kbd>if</kbd> comparison. There are a lot of ways to work with ranges in Kotlin. We will take a look at most of the common ones here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Simple case</h1>
                </header>
            
            <article>
                
<p>Let's look at one simple case:</p>
<pre><span>for</span> ( i <strong>in</strong> <span>1</span>..<span>5</span>){<br/><span>  println</span>(i)<br/>}</pre>
<p>It will iterate from <kbd>1</kbd> to <kbd>5</kbd> inclusive because we have used them in the <kbd>in</kbd> keyword.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The until case</h1>
                </header>
            
            <article>
                
<p>We also can use the <kbd>until</kbd> keyword in <kbd>for</kbd> loops, in this case, the end element will be excluded from the interaction. Let's see an example:</p>
<pre><span>for</span> (i <span>in</span> <span>1</span> <strong>until</strong> <span>5</span>) {<br/><span>  println</span>(i)<br/>}</pre>
<p>In this case, the <kbd>5</kbd> value will not be printed on the console, because the end element is not included in the interaction.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The downTo case</h1>
                </header>
            
            <article>
                
<p>The <kbd>downTo</kbd> keyword enables developers to interact with the numbers in reverse order. The instruction is self-explanatory, as well. Let's see it in practice:</p>
<pre><span>for</span> (i <span>in</span> <span>5</span> <strong>downTo</strong> <span>1</span>) {<br/><span>  println</span>(i)<br/>}</pre>
<p>It is pretty easy as well. The interaction will occur in the reverse order, in this case, the value <kbd>1</kbd> will be included. As we can see, the code is pretty easy to understand.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step case</h1>
                </header>
            
            <article>
                
<p>Sometimes we need to interact over values but with the arbitrary steps, not one by one, for example. Then we can use the <kbd>step</kbd> instruction. Let's practice:</p>
<pre><span>for</span> (i <span>in</span> <span>1</span>..<span>6</span> <span>step</span> <span>2</span>) {<br/><span>  print</span>(i)<br/>}</pre>
<p>Here, we will see the following output: <kbd>135</kbd>, because the interaction will start on the <kbd>1</kbd> value and will be increased by two points.</p>
<p>Awesome. The Kotlin ranges can add more readability to our source code and help to increase the quality of code as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Null safety</h1>
                </header>
            
            <article>
                
<p>Kotlin has amazing stuff to work with null references. The null reference is a nightmare for Java developers. The Java 8 has an <kbd>Optional</kbd> object, which helps developers work with nullable objects, but is not concise like in Kotlin.</p>
<p>Now, we will explore how Kotlin can help developers to avoid the <kbd>NullPointerException</kbd>. Let's understand.</p>
<p>The Kotlin type system makes a distinction between references which can hold null and those which cannot hold null. Due to this, the code is more concise and readable because it is a kind of advice for developers.</p>
<p>When the reference does not allow null, the declaration should be:</p>
<pre>var myNonNullString:String = "my non null string"</pre>
<p>The preceding variable cannot be assigned to a null reference, if we do this, we will get a compilation error. Look how easy the code is to understand.</p>
<p>Sometimes, we need to allow for a variable to have null references, in these cases, we can use the <kbd>?</kbd> as an operator, such as follows:</p>
<pre>var allowNull:String<strong>?</strong> = "permits null references"</pre>
<p>Easy. Pay attention to a variable declaration on the <kbd>?</kbd> operator, it makes the variable accept null references. </p>
<p>There are two different ways to avoid the <kbd>NullPointerReference</kbd> in Kotlin. The first one can be called <strong>safe calls</strong>, and the other can be called the <strong>Elvis Operator</strong>. Let's take a look at those.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Safe calls</h1>
                </header>
            
            <article>
                
<p>The safe call can be written using the <kbd>.?</kbd>. It can be called when the reference holds a non-null value when the value holds a null reference then the null value will be returned:</p>
<pre>val hash:TrackedHashTag? = TrackedHashTag(hashTag="java",queue="java")<br/>val queueString = hash?.queue</pre>
<p>When the <kbd>hash?</kbd> holds null, the null value will be assigned to a <kbd>queueString</kbd> attribute. If the <kbd>hash?</kbd> has a valid reference, the queue attribute will be assigned to a <kbd>queueString</kbd> attribute.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Elvis operator</h1>
                </header>
            
            <article>
                
<p>It can be used when developers expect to return a default value when the reference is null:</p>
<pre>val hash:TrackedHashTag? = TrackedHashTag(hashTag="java",queue="java")<br/>val queueString = hash?.queue ?: "unrecognized-queue"</pre>
<p>When the value holds null, the default value will be returned.</p>
<p>Time to use Kotlin in the real world. Let's begin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wrapping it up</h1>
                </header>
            
            <article>
                
<p>Now, we can use the basics of the Kotlin language. We saw some examples and practiced a little bit.</p>
<p>We looked at the main concepts of Kotlin. We have learned how data classes can help developers to transfer data between application layers. Also, we learned about singleton and companion objects. Now we can try to create a real project with the pretty new support from Spring Framework.</p>
<p>In the next sections, we will create a project using the Kotlin language, for now, we can forget about the Java language.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the project</h1>
                </header>
            
            <article>
                
<p>Now, we have a good idea about how we can use programming in Kotlin language. In this section, we will create the basic structure for our new project in which the main feature is consuming the Twitter stream. Let's do that.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project use case</h1>
                </header>
            
            <article>
                
<p>Before we start to code, we need to track the application requirements. The application is message-driven, we will use a broker to provide the messaging infrastructure. We choose the RabbitMQ broker because it provides <span>reliability, high availability, and clustering options. Also, the RabbitMQ is a popular choice for the modern message-driven applications.<br/></span></p>
<p>The software is powered by the Pivotal company, the same company which maintains Spring Framework. There is a huge community which supports the project. </p>
<p>We will have three projects. These three projects will collect the Twitter stream and send it to a recipient to show Tweets in a formatted way to the end user.</p>
<p>The first one, which will be created in this chapter, will be responsible for keeping the tracked hashtags on the Redis cache.</p>
<p>When the new hashtags are registered, it will send a message to the second project which will start to consume the Twitter stream and redirect it to the desired queue. This queue will be consumed by the other project which will format the Tweet, and finally, show them to the end user.</p>
<p>We will have three microservices. Let's create these things.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the project with Spring Initializr</h1>
                </header>
            
            <article>
                
<p>We have learned how to use the Spring Initializr page. We will go to the page and then select the following modules:</p>
<ul>
<li>
<p><kbd>Reactive Web</kbd></p>
</li>
<li>
<p><kbd>Reactive Redis</kbd></p>
</li>
</ul>
<p>The page content should look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ba757251-3e98-4c43-8957-d017f813ea1a.png"/></div>
<p>We can choose the group and artifact. There is no problem with using the different name. Then, we can click on <span class="packt_screen">Generate Project</span> and wait until the download ends.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding Jackson for Kotlin</h1>
                </header>
            
            <article>
                
<p>We need to add Jackson for Kotlin dependencies for Maven projects. In fact, we need a Kotlin standard library on our <kbd>pom.xml</kbd>. Also, we need to put <kbd>jackson-module-kotlin</kbd>, it allows us to work with JSON on Kotlin, there are some differences from Java in these parts.</p>
<p>This part is pretty simple, and we will add these following dependencies in the dependencies sections in <kbd>pom.xml</kbd>. The dependencies are as follows:</p>
<pre style="padding-left: 30px"><span><br/>&lt;dependency&gt;<br/></span> <span>&lt;groupId&gt;</span>com.fasterxml.jackson.module<span>&lt;/groupId&gt;<br/></span> <span>&lt;artifactId&gt;</span><strong>jackson-module-kotlin</strong><span>&lt;/artifactId&gt;<br/></span> <span>&lt;version&gt;</span>${jackson.version}<span>&lt;/version&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<p>Now, we have the dependencies configured, and we can set the plugins to compile the Kotlin source code. In the next section, we will do that.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Looking for the Maven plugins for Kotlin</h1>
                </header>
            
            <article>
                
<p>The project was created with Kotlin configured successfully. Now, we will take a look at the Maven plugin in our <kbd>pom.xml</kbd>. The configuration is necessary to instruct Maven on how to compile the Kotlin source code and add in the artifacts.</p>
<p>We will add the following plugins in the plugins section:</p>
<pre style="padding-left: 30px"><span>&lt;plugin&gt;<br/></span><span>  &lt;artifactId&gt;</span>kotlin-maven-plugin<span>&lt;/artifactId&gt;<br/></span><span>  &lt;groupId&gt;</span>org.jetbrains.kotlin<span>&lt;/groupId&gt;<br/></span><span>  &lt;version&gt;</span>${kotlin.version}<span>&lt;/version&gt;<br/></span><span>  &lt;configuration&gt;<br/></span><span>    &lt;jvmTarget&gt;</span>1.8<span>&lt;/jvmTarget&gt;<br/></span><span>  &lt;/configuration&gt;<br/></span><span>  &lt;executions&gt;<br/></span><span>    &lt;execution&gt;<br/></span><span>      &lt;id&gt;</span>compile<span>&lt;/id&gt;<br/></span><span>      &lt;phase&gt;</span>process-sources<span>&lt;/phase&gt;<br/></span><span>      &lt;goals&gt;<br/></span><span>        &lt;goal&gt;</span>compile<span>&lt;/goal&gt;<br/></span><span>      &lt;/goals&gt;<br/></span><span>    &lt;/execution&gt;<br/></span><span>    &lt;execution&gt;<br/></span><span>      &lt;id&gt;</span>test-compile<span>&lt;/id&gt;<br/></span><span>      &lt;phase&gt;</span>process-test-sources<span>&lt;/phase&gt;<br/></span><span>      &lt;goals&gt;<br/></span><span>        &lt;goal&gt;</span>test-compile<span>&lt;/goal&gt;<br/></span><span>      &lt;/goals&gt;<br/></span><span>    &lt;/execution&gt;<br/></span><span>  &lt;/executions&gt;<br/></span><span>&lt;/plugin&gt;</span></pre>
<p>There is one more thing to do. Take a look how Maven configures the path for our Kotlin code. It is easy peasy. Look at the following:</p>
<pre>    &lt;build&gt;<br/> <br/>    <strong>&lt;sourceDirectory&gt;${project.basedir}/src/main/kotlin&lt;<br/>    /sourceDirectory</strong><strong>&lt;testSourceDirectory&gt;${project.basedir}/src/<br/>    test/kotlin&lt;/testSourceDirectory&gt;</strong><br/> <br/>    .....<br/> <br/>    &lt;/build&gt;</pre>
<p>We added our Kotlin folders in the source paths.</p>
<p>Awesome, the project structure is ready, and we can start coding!</p>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a Docker network for our application</h1>
                </header>
            
            <article>
                
<p>To create isolation for our application, we will create a custom Docker network. This network was created using the bridge driver. Let's do that using the following command:</p>
<pre><strong>docker network create twitter</strong></pre>
<p>Good, now we can check the network list by typing the following command:</p>
<pre><strong>docker network list</strong></pre>
<p>The Twitter network should be on the list, like the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/dab7b12b-2cbb-4e31-9c38-b64a7abdaf4f.png"/></div>
<p>The last one is our Twitter network. Let's pull the Redis image from the Docker Hub. Take a look at the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pulling the Redis image from the Docker Hub</h1>
                </header>
            
            <article>
                
<p>The first thing we need to do is download the Redis image from the Docker Hub. To do that, it is necessary to execute the following command:</p>
<pre><strong>docker pull redis:4.0.6-alpine</strong></pre>
<p>We have used the alpine version from Redis because it is smaller than the others and has a reasonable security. While the image is downloaded, we can see the downloading status progress.</p>
<p>We can check the result using the following command:</p>
<pre><strong>docker images</strong></pre>
<p>The result should look like the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d6b1b2df-7c96-42c3-b1e0-f55f5ddecc29.png"/></div>
<p>Take a look at the images downloaded. The Redis must be on the list. </p>
<p>Awesome, now we will start the Redis instance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the Redis instance</h1>
                </header>
            
            <article>
                
<p>The image was downloaded, then we will start the Redis instance for our application. The command can be:</p>
<pre><strong>docker run -d --name redis --net twitter -p 6379:6379 redis:4.0.6-alpine</strong></pre>
<p>We have interesting attributes here. We named our Redis instance with <kbd>redis</kbd>, it will be useful for running our application in containers in the next chapters. Also, we exposed the Redis container ports to the host machine, the command argument used for that is <kbd>-p</kbd>. Finally, we attached the container to our Twitter network.</p>
<p>Good, the Redis instance is ready to use. Let's check out the Spring Data Reactive Redis stuff.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the redis-cli  tool</h1>
                </header>
            
            <article>
                
<p>There is an excellent tool to connect with the Redis instance which is called <kbd>redis-cli</kbd>. There are some Docker images for that, but we will install it on our Linux machine.</p>
<p>To install it, we can execute the following command:</p>
<pre><strong>sudo apt-get install redis-tools -y</strong></pre>
<p>Excellent, now we can connect and interact with our Redis container. The tool can perform the read and write instructions, then we need to be careful to avoid instructions unintentionally.</p>
<p>Let's connect. The default configuration is enough for us because we have exported the port <kbd>6379</kbd> on the <kbd>run</kbd> instruction. Type the following command in the Terminal:</p>
<pre><strong>redis-cli</strong></pre>
<p>Then we will connect with our running instance. The command line should display the Redis host and port, like the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d6f4c049-3109-4ddf-b08b-88fe1ae2ea19.png"/></div>
<p>Excellent, the client is configured and tested.</p>
<p>Now, we will execute some Redis commands on our container.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding Redis</h1>
                </header>
            
            <article>
                
<p>Redis is an open source in-memory data structure. Redis fits well for a database cache and is not common, but it can be used as a message broker using the publish-subscribe feature, it can be useful to decouple applications.</p>
<p>There are some interesting features supported by Redis such as transactions, atomic operations, and support for time-to-live keys. Time-to-live is useful for giving a time for the key, the eviction strategy is always hard to implement, and Redis has a built-in solution for us.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data types</h1>
                </header>
            
            <article>
                
<p>There are a lot of supported data types by Redis. The most common ones are strings, hashes, lists, and sorted sets. We will understand each of these a little bit because it is important to help us to choose the correct data type for our use case.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Strings</h1>
                </header>
            
            <article>
                
<p>Strings are the more basic data type of Redis. The string value can be at max 512 MB in length. We can store it as a JSON in the value of the key, or maybe as an image as well because the Redis is binary safe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Main commands</h1>
                </header>
            
            <article>
                
<p>Let's look at some important commands we would need:</p>
<ul>
<li><kbd>SET</kbd>: It sets the key and holds the value. It is a simple and basic command of Redis. Here's an example:</li>
</ul>
<pre><strong>       SET "user:id:10" "joe"</strong></pre>
<p style="padding-left: 60px">The return of the command should be <kbd>OK</kbd>. It indicates the instruction has been executed with success.</p>
<ul>
<li><kbd>GET</kbd>:<span> </span>This command gets the value of the requested key. Remember<span> </span><kbd>GET</kbd><span> </span>can only be used with a string data type:</li>
</ul>
<pre><strong>         GET "user:id:10"</strong></pre>
<p style="padding-left: 60px">As we can see, the return of that command should be<span> </span><kbd>joe</kbd>.</p>
<ul>
<li><kbd>INCR</kbd>:<strong> </strong>The<span> </span><kbd>INCR</kbd><span> </span>command increments the key by one. It can be useful to handle sequential numbers atomically in distributed systems. The number increment will be returned as a command output:</li>
</ul>
<pre><strong>        SET "users" "0"</strong><br/><strong>        INCR "users"</strong><br/><strong>        GET "users"</strong></pre>
<p style="padding-left: 60px">As we can see, the<span> </span><kbd>INCR</kbd><span> </span>command returned<span> </span><kbd>1</kbd><span> </span>as a command output and then we can check this using the<span> </span><kbd>GET</kbd><span> </span>and obtain the value.</p>
<ul>
<li><kbd>DECR</kbd>: The<span> </span><kbd>DECR</kbd><span> </span>command is opposite of<span> </span><kbd>INCR</kbd>, it will decrement the value atomically as well:</li>
</ul>
<pre><strong>        GET "users"</strong><br/><strong>        DECR "users"</strong><br/><strong>        GET "users"</strong></pre>
<p style="padding-left: 60px">The value of the<span> </span><kbd>users</kbd><span> </span>key was decremented by one and then transformed to<span> </span><kbd>0</kbd>. </p>
<ul>
<li><kbd>INCRBY</kbd>:<strong> </strong>It will increment the value of the key by the argument. The new incremented value will be returned:</li>
</ul>
<pre><strong>         GET "users"</strong><br/><strong>         INCRBY "users" 2</strong><br/><strong>         GET "users</strong>"</pre>
<p style="padding-left: 60px">The new value was returned as a command output.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lists</h1>
                </header>
            
            <article>
                
<p><strong>Lists</strong> are simple lists of strings. They are ordered by the insertion order. Redis also offers instructions to add new elements at the head or tail of the list.</p>
<p>Lists can be useful for storing groups of things, groups of categories, for example, grouped by the<span> </span><kbd>categories</kbd><span> </span>key.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Main commands</h1>
                </header>
            
            <article>
                
<p><kbd>LPUSH</kbd>: Insert the new element at the head of the key. The command also supports multiple arguments, in this case, the values will be stored in the reverse order as we passed on the arguments.</p>
<p>Here are some command examples:</p>
<pre><strong>    LPUSH "categories" "sports"</strong><br/><strong>    LPUSH "categories" "movies"</strong><br/><strong>    LRANGE "categories" 0 -1</strong></pre>
<p>Take a look at the<span> </span><kbd>LRANGE</kbd><span> </span>output, as we can see the value of the<span> </span><kbd>movie</kbd><span> </span>is the first one on the list because the<span> </span><kbd>LPUSH</kbd><span> </span>inserted the new element on the head.</p>
<p><kbd>RPUSH</kbd>: Insert the new element at the tail of the key. The command supports multiple arguments as well, in this case, the values will respect the respective order.</p>
<p>Here are some command examples:</p>
<pre><strong>    RPUSH "categories" "kitchen"</strong><br/><strong>    RPUSH "categories" "room"</strong><br/><strong>    LRANGE "categories" 0 -1</strong></pre>
<p>As we can see, in the<span> </span><kbd>LRANGE</kbd><span> </span>output, the new values are inserted at the tail of the values. It is the behavior of the<span> </span><kbd>RPUSH</kbd><span> </span>command.</p>
<p><kbd>LSET</kbd>:<strong> </strong>It sets the element on the requested index.</p>
<p>Here are some command examples:</p>
<pre><strong>    LSET "categories" 0 "series""</strong><br/><strong>    LRANGE "categories" 0 -1</strong></pre>
<p>The new value of the zero index is<span> </span><kbd>series</kbd>. The<span> </span><kbd>LSET</kbd><span> </span>command does that for us.</p>
<p><kbd>LRANGE</kbd>: It returns the specified elements of the key. The command arguments are the key, the start index, and finally the stop element. The<span> </span><kbd>-1</kbd><span> </span>on the stop argument will return the whole list:</p>
<pre><strong>      LRANGE "categories" 0 2</strong><br/><strong>      LRANGE "categories" 0 -1</strong></pre>
<p>As we can see, the first command will return three elements because the zero index will be grouped.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sets</h1>
                </header>
            
            <article>
                
<p>A <strong>set</strong> is a collection of strings. They have a property which does not allow repeated values. It means that if we add the pre-existing value on the sets, it will result in the same element, in this case, the advantage is not necessary to verify if the element exists on the set. Another important characteristic is that the sets are unordered. This behavior is different from the Redis lists. It can be useful in different use cases such as count the unique visitor, track the unique IPs, and much more.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Main commands</h1>
                </header>
            
            <article>
                
<p>The following are the main commands listed with their usages:</p>
<ul>
<li><kbd>SADD</kbd>:<strong> </strong>It adds the element in a requested key. Also, the return of this command is the number of the element added<span> </span>to<span> </span>the set:</li>
</ul>
<pre><strong>        SADD "unique-visitors" "joe"</strong><br/><strong>        SADD "unique-visitors" "mary"</strong></pre>
<p style="padding-left: 60px">As we can see, the command returned one because we added one user each time.</p>
<ul>
<li><kbd>SMEMBERS</kbd>:<strong> </strong>It returns all the members of a requested key:</li>
</ul>
<pre><strong>       SMEMBERS "unique-visitors"</strong></pre>
<p style="padding-left: 60px">The command will return<span> </span><kbd>joe</kbd><span> </span>and<span> </span><kbd>mary</kbd><span> </span>because those are the values stored in the<span> </span><kbd>unique-visitors</kbd><span> </span>key.</p>
<ul>
<li><kbd>SCARD</kbd>: It returns the numbers of elements of a requested key:</li>
</ul>
<pre><strong>        SCARD "unique-visitors"</strong></pre>
<p style="padding-left: 60px">The command will return the number of elements stored in the requested keys, in this case, the output will be<span> </span><kbd>2</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Data Reactive Redis</h1>
                </header>
            
            <article>
                
<p>Spring Data Redis provides an easy way to interact with the Redis Server from Spring Boot Apps. The project is part of the Spring Data family and provides high-level and low-level abstractions for the developers.</p>
<p>The Jedis and Lettuce connectors are supported as a driver for this project.</p>
<p>The project offers a lot of features and facilities to interact with Redis. The <kbd>Repository</kbd> interfaces are supported as well. There is a <kbd>CrudRepository</kbd> for Redis like in other implementations, Spring Data JPA, for example. </p>
<p>The central class for this project is the <kbd>RedisTemplate</kbd> which provides a high-level API  to perform Redis operations and serialization support. We will use this class to interact with set data structures on Redis.</p>
<p>The Reactive implementation is supported by this project, these are important characteristics for us because we are looking for Reactive implementations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the ReactiveRedisConnectionFactory</h1>
                </header>
            
            <article>
                
<p>To configure the <kbd>ReactiveRedisConnectionFactory</kbd>, we can use the <kbd>application.yaml file</kbd>, because it is easier to maintain and centralize our configuration.</p>
<p>The principle is the same as other Spring Data Projects, we should provide the host and port configurations in the <kbd>application.yaml</kbd> file, as follows:</p>
<pre style="padding-left: 30px"><span>spring:<br/></span>  <span>redis:<br/></span>    <span>host:</span> localhost<br/>    <span>port:</span> <span>6379<br/></span></pre>
<p>In the preceding configuration file, we point the Redis configuration to the <kbd>localhost</kbd>, as we can see. The configuration is pretty simple and easy to understand as well.</p>
<p>Done. The connection factory is configured. The next step is to provide a <kbd>RedisTemplate</kbd> to interact with our Redis instance. Take a look at the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Providing a ReactiveRedisTemplate</h1>
                </header>
            
            <article>
                
<p>The main class from Spring Data Redis is the <kbd>ReactiveRedisTemplate</kbd>, then we need to configure and provide an instance for the Spring container.</p>
<p>We need to provide an instance and configure the correct serializer for the desired <kbd>ReactiveRedisTemplate</kbd>. <kbd>Serializers</kbd> is the way Spring Data Redis uses to serialize and deserialize objects from raw bytes stored in Redis in the <kbd>Key</kbd> and <kbd>Value</kbd> fields.</p>
<p>We will use only the <kbd>StringRedisSerializer</kbd> because our <kbd>Key</kbd> and <kbd>Value</kbd> are simple strings and the Spring Data Redis has this serializer ready for us.</p>
<p>Let's produce our <kbd>ReactiveRedisTemplate</kbd>. The implementation should look like the following:</p>
<pre><span>pac</span>kage springfive.twittertracked.infra.redis<br/> <br/><span>import</span> org.springframework.context.annotation.<span>Bean<br/></span><span>import</span> org.springframework.context.annotation.<span>Configuration<br/></span><span>import</span> org.springframework.data.redis.connection.ReactiveRedisConnectionFactory<br/><span>import</span> org.springframework.data.redis.core.ReactiveRedisTemplate<br/><span>import</span> org.springframework.data.redis.serializer.RedisSerializationContext<br/> <span><br/></span><span>@Configuration<br/></span><span>open class</span> RedisConfiguration {<br/> <br/><span>  @Bean<br/></span>  <strong>open fun</strong> <span>reactiveRedisTemplate</span>(<strong>connectionFactory:ReactiveRedisConnectionFactory</strong>):  <br/><strong>                                 ReactiveRedisTemplate&lt;String, String&gt;</strong> {<br/>      <span>return</span> ReactiveRedisTemplate(connectionFactory<span>,</span> RedisSerializationContext.string())<br/>  }<br/><br/>}</pre>
<p>Awesome. That is our first code using Kotlin in the Spring Framework. The keyword <kbd>open</kbd> is the opposite of Java's <kbd>final</kbd> keyword. It means this function can be inherited from this class. By default, all classes in Kotlin are final. Spring Framework requires non-final functions on <kbd>@Bean</kbd> on the <kbd>@Configuration</kbd> class and then we need to insert <kbd>open</kbd>.</p>
<p>We received <kbd>ReactiveRedisConnectionFactory</kbd> as a parameter. Spring knows which we produced in the <kbd>application.yaml</kbd> file using the configurations for Redis. Then the container can inject the factory.</p>
<p>Finally, we declare <kbd>ReactiveRedisTemplate&lt;String, String&gt;</kbd> as a return value for our function.</p>
<p>Interesting work, we are ready to work with our Redis template. Now, we will implement our first repository for Redis. See you in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating Tracked Hashtag repository</h1>
                </header>
            
            <article>
                
<p>We have created the <kbd>ReactiveRedisTemplate</kbd>, then we can use this object in our repository implementation. We will create a simple repository to interact with Redis, remember the repository should be reactive, it is an important characteristic of our application. Then we need to return <kbd>Mono</kbd> or <kbd>Flux</kbd> to make the repository Reactive. Let's look at our repository implementation:</p>
<pre style="padding-left: 30px">package springfive.twittertracked.domain.repository<br/> <br/><span>import</span> org.springframework.data.redis.core.ReactiveRedisTemplate<br/><span>import</span> org.springframework.stereotype.<span>Service<br/></span><span>import</span> reactor.core.publisher.Flux<br/><span>import</span> reactor.core.publisher.Mono<br/><span>import</span> springfive.twitterconsumer.domain.TrackedHashTag<br/> <span><br/></span><span>@Service<br/></span><span>class</span> TrackedHashTagRepository(<strong>private val redisTemplate: ReactiveRedisTemplate&lt;String, String&gt;</strong>){<br/> <br/><strong>  fun save</strong>(trackedHashTag: TrackedHashTag): <strong>Mono&lt;TrackedHashTag&gt;?</strong> {<br/>    <span>return this</span>.<span>redisTemplate<br/></span>             .opsForSet().add(<span>"hash-tags"</span><span>,</span> <span>"</span><span>${</span>trackedHashTag.<span>hashTag</span><span>}</span><span>:</span><span>${</span>trackedHashTag.<span>queue</span><span>}</span><span>"</span>)<br/>             .flatMap <span>{</span> Mono.just(trackedHashTag) <span>}<br/></span>  }<br/> <br/>  <strong>fun findAll()</strong>: <strong>Flux&lt;TrackedHashTag&gt;</strong> {<br/>    <span>return this</span>.<span>redisTemplate</span>.opsForSet().members(<span>"hash-tags"</span>).flatMap <span>{</span> el <span>-&gt;<br/></span>      <span>val</span> data = el.<span>split</span>(<span>":"</span>)<br/>      Flux.just(TrackedHashTag(<span>hashTag =</span> data[<span>0</span>]<span>,</span><span>queue =</span> data[<span>1</span>]))<br/>    <span>}<br/></span>  }<br/>}</pre>
<p>We received the <kbd>ReactiveRedisTemplate&lt;String, String&gt;</kbd> as an injection on our class, the Spring Framework can detect the constructor and inject the correct implementation.</p>
<p>For now, we need these two functions. The first one is responsible for inserting our entity, <kbd>TrackedHashTag</kbd> on the set structure from Redis. We add the value of the <kbd>hash-tags</kbd> key on Redis. This function returns a <kbd>Mono</kbd> with the <span><kbd>TrackedHashTag</kbd> value. Pay attention to the <kbd>save</kbd> function. We have created a pattern for our value, the pattern follows the <kbd>hashtag</kbd>, <kbd>queue</kbd> where the hashtag is the value to gather Tweets and the queue we will use in the next sections to send to a RabbitMQ queue.</span></p>
<p><span>The second function returns all values from the</span> <kbd>hash-tags</kbd><strong> </strong><span>key, it means all tracked hashtags from our system. Moreover, we need to do some logic to create our model, <kbd>TrackedHashTag</kbd></span>, <span>as well.</span></p>
<p>The repository is finished, now we can create our service layer to encapsulate the repository. Let's do that in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the service layer</h1>
                </header>
            
            <article>
                
<p>Our repository is ready to use, now we can create our service layer. This layer is responsible for orchestrating our repository calls. In our case, it is pretty simple but in some complex scenarios, it can help us to encapsulate the repository calls.</p>
<p>Our service will be called  <kbd>TrackedHashTagService</kbd>, which will be responsible for interacting with our repository created previously. The implementation should look like the following:</p>
<pre style="padding-left: 30px">package springfive.twittertracked.domain.service<br/> <br/><span>import</span> org.springframework.stereotype.<span>Service<br/></span><span>import</span> springfive.twitterconsumer.domain.TrackedHashTag<br/><span>import</span> springfive.twitterconsumer.domain.repository.TrackedHashTagRepository<br/> <span><br/></span><span>@Service<br/></span><span>class</span> TrackedHashTagService(<strong>private val repository: TrackedHashTagRepository</strong>) {<br/> <br/>  <span>fun</span> <span>save</span>(hashTag:TrackedHashTag) = <span>this</span>.<span>repository</span>.save(hashTag)<br/> <br/>  <span>fun</span> <span>all</span>() = <span>this</span>.<span>repository</span>.findAll()<br/> <br/>}</pre>
<p>Well done. Here, there is basic stuff. We have the construct which injects our repository to interact with Redis. The interesting point here is the function declarations. There is not a body and return type because the Kotlin compiler can infer the return type, it helps the developer to avoid writing boilerplate code. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exposing the REST resources</h1>
                </header>
            
            <article>
                
<p>Now, we have created the repository and service layer, and we are ready to expose our service through HTTP endpoints:</p>
<pre style="padding-left: 30px"><span>pack</span>age springfive.twittertracked.domain.resource<br/> <br/><span>import</span> org.springframework.web.bind.annotation.*<br/><span>import</span> springfive.twitterconsumer.domain.TrackedHashTag<br/><span>import</span> springfive.twitterconsumer.domain.service.TrackedHashTagService<br/> <br/><span><br/></span><span>@RestController<br/></span><span>@RequestMapping</span>(<span>"/api/tracked-hash-tag"</span>)<br/><span>class</span> TrackedHashTagResource(<strong>private val service:TrackedHashTagService</strong>) {<br/> <br/><span>  @GetMapping<br/></span><span>  fun</span> <span>all</span>() = <span>this</span>.<span>service</span>.all()<br/> <br/><span>  @PostMapping<br/></span><span>  fun</span> <span>save</span>(<span>@RequestBody</span> hashTag:TrackedHashTag) = <span>this</span>.<span>service</span>.save(hashTag)<br/><br/>}</pre>
<p>The code is pretty concise and simple. Take a look at how concise this piece of code is. The preceding code is an example of how Kotlin helps developers to create readable codes. Thanks, Kotlin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a Twitter application</h1>
                </header>
            
            <article>
                
<p>For this project, we will need to configure an application on the Twitter platform. It is necessary, because we will use Twitter's API to search Tweets, for example, and the Twitter account is the requirement for that. We will not explain how to create a Twitter account. There are plenty of articles about that on the internet.</p>
<p>After the Twitter account is created, we need to go to <a href="https://apps.twitter.com/">https://apps.twitter.com/</a> and create a new app. The page is quite similar to the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4e51796d-f765-40b5-9ef2-a4213313e2b6.png"/></div>
<p>We will click on the <span class="packt_screen">Create New App</span> button to start the creation process. When we click on that button, the following page will be displayed. We need to fill the required fields and accept the Twitter agreements:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c320ffd1-053a-45d3-a6aa-bafa36a77bc8.png"/></div>
<p><span>We can choose the application name, fill in the description, and website. These details are up to you.</span></p>
<p>Then, we need to accept the agreements and click on <span class="packt_screen">Create your Twitter application</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img height="107" src="assets/534b0919-c437-4e2b-b6c9-e608c3a862a8.png" width="586"/></div>
<p>Awesome job. Our Twitter application is almost ready to use.</p>
<p>Now, we just need to configure the application for usage.</p>
<p>We need to check if our Keys and Access Tokens are correctly configured. Let's click on the <span class="packt_screen">Keys and Access Tokens</span> tab and check the values, shown as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a159e216-d108-4936-80b5-757625629a85.png"/></div>
<p>As we can see, there are some important configurations in the preceding screenshot. The <span class="packt_screen">Consumer Key</span> and <span class="packt_screen">Consumer Secret</span> are mandatory to authenticate with Twitter APIs. Another important point here is the <span class="packt_screen">Access Level</span>; be sure it is configured as <span>read-only,</span> as in <span>the preceding screenshot, we will not do write actions on Twitter.</span></p>
<p>Let's Dockerize it.</p>
<p>Awesome. We have the system which keeps the tracked hashtags on the Redis instance. The application is fully Reactive and has no blocking threads. </p>
<p>Now, we will configure the Maven plugin to generate the Docker images. The configuration is quite similar to what we did in <a href="827e9516-ff3d-44d7-8a16-95579684f453.xhtml" target="_blank">Chapter 3</a>, <em>Persistence with Spring Data and Reactive Fashion</em>. However, now we will create a first container which we will run with the Kotlin language. Let's do that.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring pom.xml</h1>
                </header>
            
            <article>
                
<p>Now, we will configure our <kbd>pom.xml</kbd> to be able to generate our Docker image. The first thing we need to change is our final name artifact because Docker images do not allow the - character, then we need to configure properly.</p>
<p>The configuration is pretty simple, put the <kbd>&lt;finalName&gt;</kbd> tag on the <kbd>&lt;build&gt;</kbd> node. Let's do that:</p>
<pre style="padding-left: 30px"><span>&lt;build&gt;<br/></span><span><br/></span><span>  &lt;finalName&gt;</span>tracked_hashtag<span>&lt;/finalName&gt;<br/> <br/>  ....<br/></span><br/>&lt;/build&gt;</pre>
<p>Good. We have configured the final name properly to generate the Docker image correctly. Now, we will configure the Maven Docker plugin to generate the Docker image by the Maven goal.</p>
<p>In the plugins section inside the build node, we should put in the following plugin configuration:</p>
<pre style="padding-left: 30px"><span>&lt;plugin&gt;<br/></span><span>  &lt;groupId&gt;</span>io.fabric8<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>docker-maven-plugin<span>&lt;/artifactId&gt;<br/></span><span>  &lt;version&gt;</span>0.21.0<span>&lt;/version&gt;<br/></span><span>  &lt;configuration&gt;<br/></span><span>    &lt;images&gt;<br/></span><span>      &lt;image&gt;<br/></span><span>        &lt;name&gt;</span>springfivebyexample/${project.build.finalName}<span>&lt;/name&gt;<br/></span><span>        &lt;build&gt;<br/></span><span>          &lt;from&gt;</span>openjdk:latest<span>&lt;/from&gt;<br/></span><span>          &lt;entryPoint&gt;</span>java -Dspring.profiles.active=container -jar <br/>       /application/${project.build.finalName}.jar<span>&lt;/entryPoint&gt;<br/></span><span>          &lt;assembly&gt;<br/></span><span>            &lt;basedir&gt;</span>/application<span>&lt;/basedir&gt;<br/></span><span>            &lt;descriptorRef&gt;</span>artifact<span>&lt;/descriptorRef&gt;<br/></span><span>            &lt;inline&gt;<br/></span><span>              &lt;id&gt;</span>assembly<span>&lt;/id&gt;<br/></span><span>              &lt;files&gt;<br/></span><span>                &lt;file&gt;<br/></span><span>               &lt;source&gt;</span>target/${project.build.finalName}.jar<span>&lt;/source&gt;<br/></span><span>                &lt;/file&gt;<br/></span><span>              &lt;/files&gt;<br/></span><span>            &lt;/inline&gt;<br/></span><span>          &lt;/assembly&gt;<br/></span><span>          &lt;tags&gt;<br/></span><span>            &lt;tag&gt;</span>latest<span>&lt;/tag&gt;<br/></span><span>          &lt;/tags&gt;<br/></span><span>          &lt;ports&gt;<br/></span><span>            &lt;port&gt;</span>9090<span>&lt;/port&gt;<br/></span><span>          &lt;/ports&gt;<br/></span><span>        &lt;/build&gt;<br/></span><span>        &lt;run&gt;<br/></span><span>          &lt;namingStrategy&gt;</span>alias<span>&lt;/namingStrategy&gt;<br/></span><span>        &lt;/run&gt;<br/></span><span>        &lt;alias&gt;</span>${project.build.finalName}<span>&lt;/alias&gt;<br/></span><span>      &lt;/image&gt;<br/></span><span>    &lt;/images&gt;<br/></span><span>  &lt;/configuration&gt;<br/></span><span>&lt;/plugin&gt;</span></pre>
<p>The configuration is pretty simple. We did this before. In the configuration section, we configured from the image, in our case the <kbd>openjdk:latest</kbd>, Docker entry point and exposed ports as well.</p>
<p>Let's create our Docker image in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the image</h1>
                </header>
            
            <article>
                
<p>Our project was previously configured with the Maven Docker plugin. We can generate the Docker image with the Maven Docker plugin using the <kbd>docker:build</kbd> goal. Then, it is time to generate our Docker image.</p>
<p>To generate the Docker image, type the following command:</p>
<pre><strong>mvn clean install docker:build</strong></pre>
<p>Now, we must wait for the Maven build and check if the Docker image was generated with success.</p>
<p>Check the Docker images and we should see the new image generated. To do this, we can use the <kbd>docker images</kbd> command:</p>
<pre><strong>docker images</strong></pre>
<p>Right, we should see the <kbd>springfivebyexample/tracked_hashtag:latest</kbd> on the image list, like the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0c5c8842-0851-44f5-aa01-6694dced52d3.png"/></div>
<p>Awesome, our Docker image is ready to run with our first Spring Boot Application in the Kotlin language. Let's run it right now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the container</h1>
                </header>
            
            <article>
                
<p>Let's run our container. Before that, we need to keep in mind some things. The container should be run on the Twitter network to be able to connect to our Redis instance which is running on the Twitter network as well. Remember the <kbd>localhost</kbd> address for Redis does not work anymore when running in the containers infrastructure.</p>
<p>To run our container, we can execute the following command:</p>
<pre><strong>docker run -d --name hashtag-tracker --net twitter -p 9090:9090 springfivebyexample/tracked_hashtag</strong></pre>
<p>Congratulations, our application is running in the Docker container and connected to our Redis instance. Let's create and test our APIs to check the desired behaviors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing APIs</h1>
                </header>
            
            <article>
                
<p>Our container is running. Now, we can try to call the APIs to check the behaviors. In this part, we will use the <kbd>curl</kbd> command line. The <kbd>curl</kbd> allows us to call APIs by the command line on Linux. Also, we will use <kbd>jq</kbd> to make the JSON readable on the command line, if you do not have these, look at the Tip Box to install these tools.</p>
<p>Let's call our create API, remember to create we can use the <kbd>POST</kbd> method in the base path of API. Then type the following command:</p>
<pre><strong>curl -H "Content-Type: application/json" -X POST -d '{"hashTag":"java","queue":"java"}' \</strong><br/><strong> http://localhost:9090/api/tracked-hash-tag</strong></pre>
<p>There are interesting things here. The <kbd>-H</kbd> argument instructs <kbd>curl</kbd> to put it in the request headers and <kbd>-d</kbd> indicates the request body. Moreover, finally, we have the server address.</p>
<p>We have created the new <kbd>tracked-hash-tag</kbd>. Let's check our <kbd>GET</kbd> API to obtain this data:</p>
<pre><strong>curl 'http://localhost:9090/api/tracked-hash-tag' | jq '.'</strong></pre>
<p>Awesome, we called the <kbd>curl</kbd> tool and printed the JSON value with the <kbd>jq</kbd> tool. The command output should look like the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/78a874e0-1f2d-44cd-a9fc-3b323f458a48.png"/></div>
<div class="packt_tip">To install <kbd>curl</kbd> on Ubuntu, we can use <kbd>sudo apt-get install curl -y</kbd>. Moreover, to install <kbd>jq,</kbd> we can use <kbd>sudo apt-get install jq -y</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have been introduced to the Kotlin language, which is the most prominent language for the JVM, because it has a super-fast compiler, if we compare it to Scala, for example. It also brings the simplicity of code and helps developers to create more concise and readable code.</p>
<p>We have also created our first application in the Spring Framework using Kotlin as the basic concepts of the language, and we saw how Kotlin helps the developers in a practical way.</p>
<p>We have introduced Redis as a cache and Spring Data Reactive Redis, which supports  Redis in a Reactive paradigm.</p>
<p>In the last part of the chapter, we learned how to create a Twitter application which required us to create our next application, and start to consume the Twitter API in reactive programming with a Reactive Rest Client.</p>
<p>Let's jump to the next chapter and learn more about Spring Reactive.</p>
<p> </p>
<p> </p>
<p> </p>


            </article>

            
        </section>
    </body></html>