<html><head></head><body>
<div id="_idContainer068">
<h1 class="chapter-number" id="_idParaDest-170"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-171"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.2.1">Hexagonal Architecture –Decoupling External Systems</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We’ve already learned how to write tests using the arrange, act, and assert template. </span><span class="koboSpan" id="kobo.3.2">We’ve also learned about some software design principles, known as the SOLID principles, that help us break our software down into smaller components. </span><span class="koboSpan" id="kobo.3.3">Finally, we’ve learned how test doubles can stand in for collaborating components to make FIRST unit tests easier to write. </span><span class="koboSpan" id="kobo.3.4">In this chapter, we’re going to combine all those techniques into a powerful design approach known as the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">hexagonal architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Using this approach, we will benefit from getting more of our application logic under unit tests and reducing the number of integration and end-to-end tests required. </span><span class="koboSpan" id="kobo.5.2">We will build in a natural resilience to changes outside our application. </span><span class="koboSpan" id="kobo.5.3">Development chores such as changing a database supplier will be simplified, by having fewer places where our code needs to be changed. </span><span class="koboSpan" id="kobo.5.4">We will also be able to unit test across larger units, bringing some tests that require end-to-end testing in other approaches under unit </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">tests instead.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Why external systems </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">are difficult</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Dependency inversion to </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">the rescue</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Abstracting out the </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">external system</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Writing the </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">domain code</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Substituting test doubles for </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">external systems</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Unit testing </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">bigger units</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Wordz – abstracting </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">the database</span></span></li>
</ul>
<h1 id="_idParaDest-172"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.23.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.24.1">The code for this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">at </span></span><a href="https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter09"><span class="No-Break"><span class="koboSpan" id="kobo.26.1">https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter09</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.27.1">.</span></span></p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.28.1">Why external systems are difficult</span></h1>
<p><span class="koboSpan" id="kobo.29.1">In this section, we’re going to review</span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.30.1"> the driving force behind the hexagonal architecture approach – the difficulty of working with external systems. </span><span class="koboSpan" id="kobo.30.2">Dependencies on external systems cause problems in development. </span><span class="koboSpan" id="kobo.30.3">The solution leads to a nice </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">design approach.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">Let’s look at a simple way of handling external systems. </span><span class="koboSpan" id="kobo.32.2">The task of our user is to pull a report of this month’s sales from a database. </span><span class="koboSpan" id="kobo.32.3">We will write one piece of code that does exactly that. </span><span class="koboSpan" id="kobo.32.4">The software design looks </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<span class="koboSpan" id="kobo.34.1"><img alt="Figure 9.1 – One piece of code does everything" src="image/Figure_9.1_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.35.1">Figure 9.1 – One piece of code does everything</span></p>
<p><span class="koboSpan" id="kobo.36.1">In this design, we have sales data stored in a database in the usual way. </span><span class="koboSpan" id="kobo.36.2">We write some code to pull the report on behalf of our user. </span><span class="koboSpan" id="kobo.36.3">It is a single piece of code that does the whole job as a single step. </span><span class="koboSpan" id="kobo.36.4">It will connect to the database, send a query, receive the results, do some processing, and format the results ready for the user </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">to read.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">On the plus side, we know this style of coding works. </span><span class="koboSpan" id="kobo.38.2">It will achieve its aim of providing that sales report to the user. </span><span class="koboSpan" id="kobo.38.3">On the</span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.39.1"> downside, the code combines three different responsibilities – accessing a database, performing logic, and formatting a report. </span><span class="koboSpan" id="kobo.39.2">It might mix up SQL statements to the database with </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">html5</span></strong><span class="koboSpan" id="kobo.41.1"> tags to make a formatted report. </span><span class="koboSpan" id="kobo.41.2">As we saw in a previous chapter, this can make future code changes in one area ripple out and impact the other areas. </span><span class="koboSpan" id="kobo.41.3">Ideally, that should not happen. </span><span class="koboSpan" id="kobo.41.4">But the real challenge is writing a test for this one piece of code. </span><span class="koboSpan" id="kobo.41.5">We’ll need to parse and understand whatever format we send the report to the user in. </span><span class="koboSpan" id="kobo.41.6">We’ll also need to work directly with </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">that database.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">In the following subsections, we’ll review some wider challenges that external systems present to testing. </span><span class="koboSpan" id="kobo.43.2">These include environmental problems, accidental transactions, uncertain data, operating system calls, and </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">third-party libraries.</span></span></p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.45.1">Environmental problems bring trouble</span></h2>
<p><span class="koboSpan" id="kobo.46.1">The environment</span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.47.1"> that our software runs in often causes challenges. </span><span class="koboSpan" id="kobo.47.2">Suppose our code reads data from a database. </span><span class="koboSpan" id="kobo.47.3">Even if the code is correct, it might not be able to read that data, due to problems in the environment beyond our control. </span><span class="koboSpan" id="kobo.47.4">Such problems include </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.49.1">Network connection dropped</span></strong><span class="koboSpan" id="kobo.50.1">: Many reasons can cause this. </span><span class="koboSpan" id="kobo.50.2">Locally, a network cable is pulled out by mistake. </span><span class="koboSpan" id="kobo.50.3">Maybe the database is hosted over the internet somewhere, and our ISP has dropped </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">the connection.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.52.1">Power failures</span></strong><span class="koboSpan" id="kobo.53.1">: A power failure on the database server, or a local network switch is enough to put the database out of </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">our reach.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.55.1">Equipment limits</span></strong><span class="koboSpan" id="kobo.56.1">: Maybe the database server itself has run out of disk space and cannot operate. </span><span class="koboSpan" id="kobo.56.2">Maybe the exact query we have written is hitting the database in a way that takes a long time to complete, perhaps due to </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">missing indices.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.58.1">Whatever the cause, if our code cannot access the data in the database, it’s not going to work. </span><span class="koboSpan" id="kobo.58.2">As this is a possibility, writing a test for our report generation code is made </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">much harder.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">Even when our code can access the data in the database, it’s not that easy to work with in testing. </span><span class="koboSpan" id="kobo.60.2">Suppose we write a test that verifies that we can read the production database correctly, by reading a username. </span><span class="koboSpan" id="kobo.60.3">What username would we expect to read? </span><span class="koboSpan" id="kobo.60.4">We don’t know, because the test is not in control of what data gets added. </span><span class="koboSpan" id="kobo.60.5">The available usernames will be whatever names were added by real users. </span><span class="koboSpan" id="kobo.60.6">We could make the test add a known test username to the database – but then, we have just created a fake user that real users can interact with. </span><span class="koboSpan" id="kobo.60.7">This is not what we want </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">at all.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">A database stores data, causing further problems for our tests. </span><span class="koboSpan" id="kobo.62.2">Suppose we write a test against a test database, which begins by writing a test username. </span><span class="koboSpan" id="kobo.62.3">If we have run this test before, the test username will already be stored in the database. </span><span class="koboSpan" id="kobo.62.4">Typically, the database will report a duplicate item error and the test </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">will fail.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">Tests against databases </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.65.1">need cleaning up. </span><span class="koboSpan" id="kobo.65.2">Any test data stored must be deleted after the tests have been completed. </span><span class="koboSpan" id="kobo.65.3">If we attempt to delete data after the test has succeeded, the deletion code may never run if the test fails. </span><span class="koboSpan" id="kobo.65.4">We could avoid this by always deleting the data before the test runs. </span><span class="koboSpan" id="kobo.65.5">Such tests will be slow </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">to run.</span></span></p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.67.1">Accidentally triggering real transactions from tests</span></h2>
<p><span class="koboSpan" id="kobo.68.1">When our code is limited to only accessing</span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.69.1"> a production system, then every time we use that code, something will happen in production. </span><span class="koboSpan" id="kobo.69.2">The payment processor may issue charges. </span><span class="koboSpan" id="kobo.69.3">Real bank accounts may become debited. </span><span class="koboSpan" id="kobo.69.4">Alarms may be activated, causing real evacuations. </span><span class="koboSpan" id="kobo.69.5">In a famous example from Hawaii, a system test triggered a real text message saying Hawaii was under missile attack – which it wasn’t. </span><span class="koboSpan" id="kobo.69.6">This is </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">serious stuff.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.71.1">Hawaii false missile attack warning</span></p>
<p class="callout"><span class="koboSpan" id="kobo.72.1">For details on this example</span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.73.1"> of testing going wrong, </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">see </span></span><a href="https://en.wikipedia.org/wiki/2018_Hawaii_false_missile_alert"><span class="No-Break"><span class="koboSpan" id="kobo.75.1">https://en.wikipedia.org/wiki/2018_Hawaii_false_missile_alert</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.76.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">Accidental real transactions can result in real losses to a company. </span><span class="koboSpan" id="kobo.77.2">They could end up as losses to the 3Rs of a business – revenue, reputation, and retention. </span><span class="koboSpan" id="kobo.77.3">None of those are good. </span><span class="koboSpan" id="kobo.77.4">Our tests mustn’t accidentally trigger real consequences from </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">production systems.</span></span></p>
<h2 id="_idParaDest-176"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.79.1">What data should we expect?</span></h2>
<p><span class="koboSpan" id="kobo.80.1">In our sales report</span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.81.1"> example, the biggest problem with writing a test is that we would need to know what the correct answer is to the monthly sales report in advance. </span><span class="koboSpan" id="kobo.81.2">How do we do that when we are connected to the production system? </span><span class="koboSpan" id="kobo.81.3">The answer will be whatever the sales report says it is. </span><span class="koboSpan" id="kobo.81.4">We have no other way </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">of knowing.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">The fact that we need the sales report code to be working correctly before we can test that the sales report code is working correctly is a big problem here! </span><span class="koboSpan" id="kobo.83.2">This is a circular dependency we </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">cannot break.</span></span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.85.1">Operating system calls and system time</span></h2>
<p><span class="koboSpan" id="kobo.86.1">Sometimes, our code</span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.87.1"> may need to make calls to the operating system</span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.88.1"> to do its job. </span><span class="koboSpan" id="kobo.88.2">Perhaps it needs to delete all the files in a directory from time to time or it may be dependent on the system time. </span><span class="koboSpan" id="kobo.88.3">An example would be a log file cleanup utility, which runs every Monday at 02:00 A.M. </span><span class="koboSpan" id="kobo.88.4">The utility will delete every file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">logfiles/</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.91.1"> directory.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">Testing such a utility would be difficult. </span><span class="koboSpan" id="kobo.92.2">We would have to wait until 02:00 A.M. </span><span class="koboSpan" id="kobo.92.3">on Monday and verify that all the log files have been deleted. </span><span class="koboSpan" id="kobo.92.4">While we could make this work, it isn’t very effective. </span><span class="koboSpan" id="kobo.92.5">It would be nice to find a better approach that allowed us to test anytime we liked, ideally without deleting </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">any files.</span></span></p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.94.1">Challenges with third-party services</span></h2>
<p><span class="koboSpan" id="kobo.95.1">A common task in business software</span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.96.1"> is to accept payment from a customer. </span><span class="koboSpan" id="kobo.96.2">For that, we inevitably use a third-party payment processor such as PayPal or Stripe, as two examples. </span><span class="koboSpan" id="kobo.96.3">In addition to the challenges of network connectivity, third-party APIs provide us with </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">further challenges:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.98.1">Service downtime</span></strong><span class="koboSpan" id="kobo.99.1">: Many third-party APIs will have a period of scheduled maintenance where the service is unavailable for a time. </span><span class="koboSpan" id="kobo.99.2">That spells “test failed” </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">for us.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.101.1">API changes</span></strong><span class="koboSpan" id="kobo.102.1">: Suppose our code uses API version 1 and API version 2 is pushed live. </span><span class="koboSpan" id="kobo.102.2">Our code will still be using version 1 calls, which might no longer work on version 2 of the API. </span><span class="koboSpan" id="kobo.102.3">Now, that is considered rather bad practice – it’s called breaking a </span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.103.1">published interface – but it can and does happen. </span><span class="koboSpan" id="kobo.103.2">Worse, with our one piece of code, the version 2 changes might cause changes everywhere in </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">our code.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.105.1">Slow responses</span></strong><span class="koboSpan" id="kobo.106.1">: If our code makes an API call to an external service, there is always a possibility that the response will come back later than expected by our code. </span><span class="koboSpan" id="kobo.106.2">Our code will fail in some way usually and cause tests </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">to fail.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.108.1">Plenty of challenges exist when we mix external services</span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.109.1"> and a single monolithic piece of code, complicating both maintenance and testing. </span><span class="koboSpan" id="kobo.109.2">The question is what can we do about it? </span><span class="koboSpan" id="kobo.109.3">The next section looks at how the </span><strong class="bold"><span class="koboSpan" id="kobo.110.1">Dependency Inversion Principle</span></strong><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.111.1"> can help us follow a design approach known as a hexagonal architecture, which makes external systems easier to </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">deal with.</span></span></p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.113.1">Dependency inversion to the rescue</span></h1>
<p><span class="koboSpan" id="kobo.114.1">In this section, we will review</span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.115.1"> a design approach known as the hexagonal architecture, based on the SOLID principles we already know. </span><span class="koboSpan" id="kobo.115.2">Using this approach allows us to use TDD more effectively across more of our </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">We learned about the </span><strong class="bold"><span class="koboSpan" id="kobo.118.1">Dependency Inversion Principle</span></strong><span class="koboSpan" id="kobo.119.1"> previously in this book. </span><span class="koboSpan" id="kobo.119.2">We saw that it helps us isolate some code we wanted to test from the details of its collaborators. </span><span class="koboSpan" id="kobo.119.3">We noted that was useful for testing things that connected to external systems that were outside of our control. </span><span class="koboSpan" id="kobo.119.4">We saw how the single responsibility principle guided us into splitting up software into smaller, more </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">focused tasks.</span></span></p>
<p><span class="koboSpan" id="kobo.121.1">Applying these ideas to our earlier sales reporting example, we would arrive at an improved design, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<span class="koboSpan" id="kobo.123.1"><img alt="Figure 9.2 – Applying SOLID to our sales report" src="image/Figure_9.2_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.124.1">Figure 9.2 – Applying SOLID to our sales report</span></p>
<p><span class="koboSpan" id="kobo.125.1">The preceding diagram shows how we have applied SOLID principles to splitting up our sales report code. </span><span class="koboSpan" id="kobo.125.2">We have used the single responsibility principle to break down the overall task into three </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">separate tasks:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.127.1">Formatting </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">the report</span></span></li>
<li><span class="koboSpan" id="kobo.129.1">Calculating the </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">sales total</span></span></li>
<li><span class="koboSpan" id="kobo.131.1">Reading the sales data from </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">the database</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.133.1">This already makes the application</span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.134.1"> a little easier to work with. </span><span class="koboSpan" id="kobo.134.2">More importantly, we’ve isolated the code that calculates the sales total from both the user and the database. </span><span class="koboSpan" id="kobo.134.3">This calculation no longer directly accesses the database. </span><span class="koboSpan" id="kobo.134.4">It goes through another piece of code responsible for doing only that. </span><span class="koboSpan" id="kobo.134.5">Likewise, the calculation result isn’t directly formatted and sent to the user. </span><span class="koboSpan" id="kobo.134.6">Another piece of code is responsible </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">for that.</span></span></p>
<p><span class="koboSpan" id="kobo.136.1">We can apply the </span><strong class="bold"><span class="koboSpan" id="kobo.137.1">Dependency Inversion Principle</span></strong><span class="koboSpan" id="kobo.138.1"> here as well. </span><span class="koboSpan" id="kobo.138.2">By inverting the dependencies on the formatting and database access code, our calculated sales total is now free from knowing any of their details. </span><span class="koboSpan" id="kobo.138.3">We’ve made a </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">significant breakthrough:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.140.1">The calculation code is now fully isolated from the database </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">and formatting</span></span></li>
<li><span class="koboSpan" id="kobo.142.1">We can swap in any piece of code that can access </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">any database</span></span></li>
<li><span class="koboSpan" id="kobo.144.1">We can swap in any piece of code that can format </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">a report</span></span></li>
<li><span class="koboSpan" id="kobo.146.1">We can use test doubles in place of the formatting and database </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">access code</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.148.1">The biggest benefit is that we can swap in any piece of code that can access any database, without changing the calculation code. </span><span class="koboSpan" id="kobo.148.2">For example, we could change from a Postgres SQL database to a Mongo</span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.149.1"> NoSQL database without changing the calculation code. </span><span class="koboSpan" id="kobo.149.2">We can use a test double for the database so that we can test the calculation code as a FIRST unit test. </span><span class="koboSpan" id="kobo.149.3">These are very significant advantages, not just in terms of TDD and testing, but also in terms of how our code is organized. </span><span class="koboSpan" id="kobo.149.4">Considering the one-piece sales report solution to this one, we have moved from pure writing code to software engineering. </span><span class="koboSpan" id="kobo.149.5">We’re thinking beyond just getting code to work and focusing on making code easy to work with. </span><span class="koboSpan" id="kobo.149.6">The next few subsections will look at how we can generalize this approach, resulting in the hexagonal architecture. </span><span class="koboSpan" id="kobo.149.7">We will understand how this approach delivers a logical organization of code that helps us apply TDD </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">more effectively.</span></span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.151.1">Generalizing this approach to the hexagonal architecture</span></h2>
<p><span class="koboSpan" id="kobo.152.1">This combination of the single</span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.153.1"> responsibility principle and dependency inversion seems to have brought us some benefits. </span><span class="koboSpan" id="kobo.153.2">Could we extend this approach to the entire application and get the same benefits? </span><span class="koboSpan" id="kobo.153.3">Could we find a way to separate all our application logic and data representations from the constraints of external influence? </span><span class="koboSpan" id="kobo.153.4">We most certainly can, and the general form of this design is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer063">
<span class="koboSpan" id="kobo.155.1"><img alt="Figure 9.3 – Hexagonal architecture" src="image/Figure_9.3_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.156.1">Figure 9.3 – Hexagonal architecture</span></p>
<p><span class="koboSpan" id="kobo.157.1">The preceding diagram</span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.158.1"> shows what happens when we generalize the use of dependency inversion and single responsibility to an entire application. </span><span class="koboSpan" id="kobo.158.2">It is called the</span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.159.1"> hexagonal architecture, also known as ports and adapters after the original term used by Alastair Cockburn, who first described this approach. </span><span class="koboSpan" id="kobo.159.2">The benefit is that it completely isolates the core logic of our application from the details of external systems. </span><span class="koboSpan" id="kobo.159.3">This helps us with testing that core logic. </span><span class="koboSpan" id="kobo.159.4">It also provides a reasonable template for a well-engineered design for </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">our code.</span></span></p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.161.1">Overview of the hexagonal architecture’s components</span></h2>
<p><span class="koboSpan" id="kobo.162.1">To provide us with this isolation</span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.163.1"> of our core application logic, the hexagonal architecture divides the whole program into </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">four spaces:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.165.1">External systems, including web browsers, databases, and other </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">computing services</span></span></li>
<li><span class="koboSpan" id="kobo.167.1">Adapters implement the specific APIs required by the </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">external systems</span></span></li>
<li><span class="koboSpan" id="kobo.169.1">Ports are the abstraction of what our application needs from the </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">external system</span></span></li>
<li><span class="koboSpan" id="kobo.171.1">The domain model contains our application logic, free of external </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">system details</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.173.1">The central core of our application</span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.174.1"> is the domain model, surrounded by the support it needs from external systems. </span><span class="koboSpan" id="kobo.174.2">It indirectly uses but is not defined by those external systems. </span><span class="koboSpan" id="kobo.174.3">Let’s walk through each component in the hexagonal architecture in more detail, to understand what each one is and is not </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">responsible for.</span></span></p>
<h3><span class="koboSpan" id="kobo.176.1">External systems connect to adapters</span></h3>
<p><span class="koboSpan" id="kobo.177.1">External systems are all the things</span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.178.1"> that live outside of our code base. </span><span class="koboSpan" id="kobo.178.2">They include things that the user directly interacts with, such as the web browser and the console application in the preceding diagram. </span><span class="koboSpan" id="kobo.178.3">They also include data stores, such as both the SQL database and the NoSQL database. </span><span class="koboSpan" id="kobo.178.4">Other examples of common external systems include desktop graphical user interfaces, filesystems, downstream web service APIs, and hardware device drivers. </span><span class="koboSpan" id="kobo.178.5">Most applications will need to interact with systems </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">like these.</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">In the hexagonal architecture, the core of our application code does not know any details about how the external systems are interacted with. </span><span class="koboSpan" id="kobo.180.2">The responsibility of communicating with external systems</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.181.1"> is given to a piece of code known as </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">an adapter.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">As an example, the following diagram shows how a web browser would connect to our code via a </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">REST adapter:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer064">
<span class="koboSpan" id="kobo.185.1"><img alt="Figure 9.4 – Browser connecting to a REST adapter" src="image/Figure_9.4_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.186.1">Figure 9.4 – Browser connecting to a REST adapter</span></p>
<p><span class="koboSpan" id="kobo.187.1">In the preceding diagram, we can see the web browser connecting to a REST adapter. </span><span class="koboSpan" id="kobo.187.2">This adapter understands HTTP requests and responses, which are the very core of the web. </span><span class="koboSpan" id="kobo.187.3">It also understands the JSON data format, often using libraries to convert the JSON data into some internal representation for our code. </span><span class="koboSpan" id="kobo.187.4">This adapter will also understand the specific protocol that we will have designed for our application’s REST API – the precise sequence of HTTP verbs, responses, status codes, and JSON-encoded payload data we come up with as </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">an API.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.189.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.190.1">Adapters</span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.191.1"> encapsulate all the knowledge our system needs to interact with an external system – and nothing else. </span><span class="koboSpan" id="kobo.191.2">This knowledge is defined by the external system’s specifications. </span><span class="koboSpan" id="kobo.191.3">Some of those may be designed </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">by ourselves.</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">Adapters have the single</span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.194.1"> responsibility of knowing how to interact with an external system. </span><span class="koboSpan" id="kobo.194.2">If that external system changes its public interface, only our adapter will need </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">to change.</span></span></p>
<h3><span class="koboSpan" id="kobo.196.1">Adapters connect to ports</span></h3>
<p><span class="koboSpan" id="kobo.197.1">Moving toward the domain model, adapters</span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.198.1"> connect to ports. </span><span class="koboSpan" id="kobo.198.2">Ports are part of the domain model. </span><span class="koboSpan" id="kobo.198.3">They abstract away the details of the adapter’s intricate knowledge of its external system. </span><span class="koboSpan" id="kobo.198.4">Ports answer a slightly different question: what do we need that external system for? </span><span class="koboSpan" id="kobo.198.5">The ports use the </span><strong class="bold"><span class="koboSpan" id="kobo.199.1">Dependency Inversion Principle</span></strong><span class="koboSpan" id="kobo.200.1"> to isolate our domain code from knowing any details about the adapters. </span><span class="koboSpan" id="kobo.200.2">They are written purely in terms of our </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">domain model:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer065">
<span class="koboSpan" id="kobo.202.1"><img alt="Figure 9.5 – Adapters connect to ports" src="image/Figure_9.5_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.203.1">Figure 9.5 – Adapters connect to ports</span></p>
<p><span class="koboSpan" id="kobo.204.1">The REST adapter described previously encapsulates the details of running a REST API, using knowledge</span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.205.1"> of HTTP and JSON. </span><span class="koboSpan" id="kobo.205.2">It connects to a commands port, which provides our abstraction of commands coming in from the web – or anywhere else, for that matter. </span><span class="koboSpan" id="kobo.205.3">Given our sales report example earlier, the commands port would include a technology-free way of requesting a sales report. </span><span class="koboSpan" id="kobo.205.4">In code, it might look as simple </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">as this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.207.1">
package com.sales.domain;
import java.time.LocalDate;
public interface Commands {
    SalesReport calculateForPeriod(LocalDate start,
                                   LocalDate end);
}</span></pre>
<p><span class="koboSpan" id="kobo.208.1">This code fragment features </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.210.1">No references to </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">HttpServletRequest</span></strong><span class="koboSpan" id="kobo.212.1"> or anything to do </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">with HTTP</span></span></li>
<li><span class="koboSpan" id="kobo.214.1">No references to </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">JSON formats</span></span></li>
<li><span class="koboSpan" id="kobo.216.1">References to our domain model – </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">SalesReport</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.218.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">java.time.LocalDate</span></strong></span></li>
<li><span class="koboSpan" id="kobo.220.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">public</span></strong><span class="koboSpan" id="kobo.222.1"> access modifier, so it can be called from the </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">REST adapter</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.224.1">This interface is a port. </span><span class="koboSpan" id="kobo.224.2">It gives us a general-purpose way to get a sales report from our application. </span><span class="koboSpan" id="kobo.224.3">Referring to </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.225.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.226.1">.3</span></em><span class="koboSpan" id="kobo.227.1">, we can see that the console adapter also connects to this port, providing the user with a command-line interface to our application. </span><span class="koboSpan" id="kobo.227.2">The reason is that while users can access our application using different kinds of external systems – the web and the command line – our application does the same thing in either case. </span><span class="koboSpan" id="kobo.227.3">It only supports one set of commands, no matter where those commands are requested from. </span><span class="koboSpan" id="kobo.227.4">Fetching a </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">SalesReport</span></strong><span class="koboSpan" id="kobo.229.1"> object is just that, no matter which technology you request </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">it from.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.231.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.232.1">Ports provide a logical view of what our application needs from an external system, without constraining how those needs should be </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">met technically.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">Ports are where</span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.235.1"> we invert dependencies. </span><span class="koboSpan" id="kobo.235.2">Ports represent the reason our domain model needs those external systems. </span><span class="koboSpan" id="kobo.235.3">If the adapters represent the how, ports represent </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">the why.</span></span></p>
<h3><span class="koboSpan" id="kobo.237.1">Ports connect to our domain model</span></h3>
<p><span class="koboSpan" id="kobo.238.1">The final step in the chain is connecting</span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.239.1"> to the domain model itself. </span><span class="koboSpan" id="kobo.239.2">This is where our application logic lives. </span><span class="koboSpan" id="kobo.239.3">Think of it as pure logic for the problem our application is solving. </span><span class="koboSpan" id="kobo.239.4">Because of the ports and adapters, the domain logic is unconstrained by details of </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">external systems:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<span class="koboSpan" id="kobo.241.1"><img alt="Figure 9.6 – Ports connect to the domain model" src="image/Figure_9.6_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.242.1">Figure 9.6 – Ports connect to the domain model</span></p>
<p><span class="koboSpan" id="kobo.243.1">The domain model represents the things our users want to do, in code. </span><span class="koboSpan" id="kobo.243.2">Every user story is described by code here. </span><span class="koboSpan" id="kobo.243.3">Ideally, the code in this layer uses the language of the problem we are solving, instead of technology details. </span><span class="koboSpan" id="kobo.243.4">When we do this well, this code becomes storytelling – it describes actions our users care about in terms they have told us about. </span><span class="koboSpan" id="kobo.243.5">It uses their language – the language of our users – not obscure </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">computer language.</span></span></p>
<p><span class="koboSpan" id="kobo.245.1">The domain model can</span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.246.1"> contain code written in any paradigm. </span><span class="koboSpan" id="kobo.246.2">It might use </span><strong class="bold"><span class="koboSpan" id="kobo.247.1">functional programming</span></strong><span class="koboSpan" id="kobo.248.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.249.1">FP</span></strong><span class="koboSpan" id="kobo.250.1">) ideas. </span><span class="koboSpan" id="kobo.250.2">It may even use </span><strong class="bold"><span class="koboSpan" id="kobo.251.1">object-oriented programming</span></strong><span class="koboSpan" id="kobo.252.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.253.1">OOP</span></strong><span class="koboSpan" id="kobo.254.1">) ideas. </span><span class="koboSpan" id="kobo.254.2">It might be procedural. </span><span class="koboSpan" id="kobo.254.3">It might even</span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.255.1"> use an off-the-shelf library that we configure declaratively. </span><span class="koboSpan" id="kobo.255.2">My current style is to use OOP for the overall structure and organization of a program, then use FP ideas inside the object methods to implement them. </span><span class="koboSpan" id="kobo.255.3">It makes no difference to either the hexagonal architecture or TDD how we implement this domain model. </span><span class="koboSpan" id="kobo.255.4">Whatever way suits your coding style is just fine here, so long as you use the ideas of ports </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">and adapters.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.257.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.258.1">The domain model contains code that describes how the user’s problem is being solved. </span><span class="koboSpan" id="kobo.258.2">This is the essential logic of our application that creates </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">business value.</span></span></p>
<p><span class="koboSpan" id="kobo.260.1">At the center of the entire application</span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.261.1"> is the domain model. </span><span class="koboSpan" id="kobo.261.2">It contains the logic that brings the user’s stories </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">to life.</span></span></p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.263.1">The golden rule – the domain never connects directly to adapters</span></h2>
<p><span class="koboSpan" id="kobo.264.1">To preserve the benefits</span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.265.1"> of isolating the domain model from adapters and external systems, we follow one simple rule: the domain model never connects directly to any of the adapters. </span><span class="koboSpan" id="kobo.265.2">This is always done through </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">a port.</span></span></p>
<p><span class="koboSpan" id="kobo.267.1">When our code follows this design approach, it is straightforward to check whether we’ve got the ports and adapters split right. </span><span class="koboSpan" id="kobo.267.2">We can make two high-level </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">structural decisions:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.269.1">The domain model lives in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">domain</span></strong><span class="koboSpan" id="kobo.271.1"> package (and </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">sub packages)</span></span></li>
<li><span class="koboSpan" id="kobo.273.1">The adapters live in an </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">adapters</span></strong><span class="koboSpan" id="kobo.275.1"> package (and </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">sub packages)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.277.1">We can analyze the code to check that anything in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">domain</span></strong><span class="koboSpan" id="kobo.279.1"> package contains no import statements from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">adapters</span></strong><span class="koboSpan" id="kobo.281.1"> package. </span><span class="koboSpan" id="kobo.281.2">Import checks can be done visually in code reviews or pairing/mobbing. </span><span class="koboSpan" id="kobo.281.3">Static analysis tools such as SonarQube can automate import checks as part of the </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">build pipeline.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.283.1">The golden rules of the hexagonal architecture</span></p>
<p class="callout"><span class="koboSpan" id="kobo.284.1">The domain model never connects directly to anything in the adapter layer so that our application logic does not depend on details of </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">external systems.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.286.1">The adapters connect to ports so that code connecting to external systems </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">is isolated.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.288.1">Ports are part of the domain model to create abstractions of </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">external systems.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.290.1">The domain model and the adapters depend on the ports only. </span><span class="koboSpan" id="kobo.290.2">This is dependency inversion </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">at work.</span></span></p>
<p><span class="koboSpan" id="kobo.292.1">These simple rules keep our design</span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.293.1"> in line and preserve the isolation of the </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">domain model.</span></span></p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.295.1">Why the hexagon shape?</span></h2>
<p><span class="koboSpan" id="kobo.296.1">The idea behind the hexagon shape</span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.297.1"> used in the diagram is that each face represents one external system. </span><span class="koboSpan" id="kobo.297.2">In terms of a graphical representation of a design, having up to six external systems represented is usually sufficient. </span><span class="koboSpan" id="kobo.297.3">The idea of the inner and outer hexagons to represent the domain model and adapter layer shows graphically how the domain model is the core of our application and that it is isolated from external systems by the ports and </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">adapter layer.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">The critical idea behind the hexagonal architecture is the ports and adapters technique. </span><span class="koboSpan" id="kobo.299.2">The actual number of sides depends on how many external systems there are. </span><span class="koboSpan" id="kobo.299.3">The number of those is </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">not important.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">In this section, we introduced the hexagonal architecture and the benefits it provides, and provided a general overview of how all the essential pieces fit together. </span><span class="koboSpan" id="kobo.301.2">Let’s turn to the next section and look specifically at the decisions we need to make to abstract out an </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">external system.</span></span></p>
<h1 id="_idParaDest-184"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.303.1">Abstracting out the external system</span></h1>
<p><span class="koboSpan" id="kobo.304.1">In this section, we will consider some of the decisions</span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.305.1"> we need to make when applying the hexagonal architecture approach. </span><span class="koboSpan" id="kobo.305.2">We’ll take a step-by-step approach to handling external systems, where we will first decide what the domain model needs, then work out the right abstractions that hide their technical details. </span><span class="koboSpan" id="kobo.305.3">We will consider two common external systems: web requests and </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">database access.</span></span></p>
<h2 id="_idParaDest-185"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.307.1">Deciding what our domain model needs</span></h2>
<p><span class="koboSpan" id="kobo.308.1">The place to begin our design</span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.309.1"> is with our domain model. </span><span class="koboSpan" id="kobo.309.2">We need to devise a suitable port for our domain model to interact with. </span><span class="koboSpan" id="kobo.309.3">This port has to be free from any details of our external system, and at the same time, it must answer the question of what our application needs this system for. </span><span class="koboSpan" id="kobo.309.4">We are creating </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">an abstraction.</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">A good way to think about abstractions is to think about what would stay the same if we changed how we performed a task. </span><span class="koboSpan" id="kobo.311.2">Suppose we want to eat warm soup for lunch. </span><span class="koboSpan" id="kobo.311.3">We might warm it in a pan on the stove or perhaps warm it in the microwave. </span><span class="koboSpan" id="kobo.311.4">No matter how we choose to do it, what we are doing stays the same. </span><span class="koboSpan" id="kobo.311.5">We are warming the soup and that is the abstraction we’re </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">looking for.</span></span></p>
<p><span class="koboSpan" id="kobo.313.1">We don’t often warm soup in software</span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.314.1"> systems unless we are building an automated soup vending machine. </span><span class="koboSpan" id="kobo.314.2">But there are several common kinds of abstractions we will be using. </span><span class="koboSpan" id="kobo.314.3">This is because common kinds of external systems are used when building a typical web application. </span><span class="koboSpan" id="kobo.314.4">The first and most obvious is the connection to the web itself. </span><span class="koboSpan" id="kobo.314.5">In most applications, we will encounter some kind of data store, typically a third-party database system. </span><span class="koboSpan" id="kobo.314.6">For many applications, we will also be calling out to another web service. </span><span class="koboSpan" id="kobo.314.7">In turn, this service may call others in a fleet of services, all internal to our company. </span><span class="koboSpan" id="kobo.314.8">Another typical web service call is to a third-party web service provider, such as a credit card payment processor, as </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">an example.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">Let’s look at ways of abstracting these common </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">external systems.</span></span></p>
<h3><span class="koboSpan" id="kobo.318.1">Abstracting web requests and responses</span></h3>
<p><span class="koboSpan" id="kobo.319.1">Our application will respond to HTTP</span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.320.1"> requests and responses. </span><span class="koboSpan" id="kobo.320.2">The port we need to design represents the request and the response in terms of our domain model, stripping away the </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">web technology.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">Our sales report example could introduce these ideas as two simple domain objects. </span><span class="koboSpan" id="kobo.322.2">These requests can be represented by a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">RequestSalesReport</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.324.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.325.1">
package com.sales.domain;
import java.time.LocalDate;
public class RequestSalesReport {
    private final LocalDate start;
    private final LocalDate end;
    public RequestSalesReport(LocalDate start,
                              LocalDate end){
        this.start = start;
        this.end = end;
    }
    public SalesReport produce(SalesReporting reporting) {
        return reporting.reportForPeriod(start, end);
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.326.1">Here, we can see the critical pieces of our domain model of </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">the request:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.328.1">What we are requesting – that is, a sales report, captured in the </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">class name</span></span></li>
<li><span class="koboSpan" id="kobo.330.1">The parameters of that request – that is, the start and end dates of the </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">reporting period</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.332.1">We can see how the response </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">is represented:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.334.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">SalesReport</span></strong><span class="koboSpan" id="kobo.336.1"> class will contain the raw </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">information requested</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.338.1">We can also see what is </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">not present:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.340.1">The data formats used in the </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">web request</span></span></li>
<li><span class="koboSpan" id="kobo.342.1">HTTP status codes, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">200 OK</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">HTTPServletRequest</span></strong><span class="koboSpan" id="kobo.345.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">HttpServletResponse</span></strong><span class="koboSpan" id="kobo.347.1"> or equivalent </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">framework objects</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.349.1">This is a pure domain model representation of a request for a sales report between two dates. </span><span class="koboSpan" id="kobo.349.2">There is no hint of this having come from the web, a fact that is very useful as we can request it from other input sources, such as a desktop GUI or a command line. </span><span class="koboSpan" id="kobo.349.3">Even better, we can create these domain model objects very easily in a </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">unit test.</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">The preceding example</span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.352.1"> shows an object-oriented, tell-don’t-ask approach. </span><span class="koboSpan" id="kobo.352.2">We could just as easily choose an FP approach. </span><span class="koboSpan" id="kobo.352.3">If we did, we would represent the request and response as pure data structures. </span><span class="koboSpan" id="kobo.352.4">The record facility that was added to Java 17 is well suited to representing such data structures. </span><span class="koboSpan" id="kobo.352.5">What’s important is that the request and response are written purely in domain model terms – nothing of the web technology should </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">be present.</span></span></p>
<h3><span class="koboSpan" id="kobo.354.1">Abstracting the database</span></h3>
<p><span class="koboSpan" id="kobo.355.1">Without data, most applications</span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.356.1"> aren’t particularly useful. </span><span class="koboSpan" id="kobo.356.2">Without data storage, they become rather forgetful of the data we supply. </span><span class="koboSpan" id="kobo.356.3">Accessing data stores such as relational databases and NoSQL databases is a common task in web </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">application development.</span></span></p>
<p><span class="koboSpan" id="kobo.358.1">In a hexagonal architecture, we start by designing the port that the domain model will interact with, again in pure domain terms. </span><span class="koboSpan" id="kobo.358.2">The way to create a database abstraction is to think about what data needs storing and not how it will </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">be stored.</span></span></p>
<p><span class="koboSpan" id="kobo.360.1">A database port</span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.361.1"> has </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">two components:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.363.1">An interface to invert the dependency on </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">the database.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.365.1">The interface</span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.366.1"> is often known as a repository. </span><span class="koboSpan" id="kobo.366.2">It has also been termed a data access object. </span><span class="koboSpan" id="kobo.366.3">Whatever the name, it has the job of isolating the domain model from any part of our database and its </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">access technology.</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.368.1">Value objects</span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.369.1"> representing the data itself, in domain </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">model terms.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.371.1">A value object exists to transfer data from place to place. </span><span class="koboSpan" id="kobo.371.2">Two value objects that each hold the same data values are considered equal. </span><span class="koboSpan" id="kobo.371.3">They are ideal for transferring data between the database and </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">our code.</span></span></p>
<p><span class="koboSpan" id="kobo.373.1">Returning to our sales report</span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.374.1"> example, one possible design for our repository would </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">be this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.376.1">
package com.sales.domain;
public interface SalesRepository {
    List&lt;Sale&gt; allWithinDateRange(LocalDate start,
                                  LocalDate end);
}</span></pre>
<p><span class="koboSpan" id="kobo.377.1">Here, we have a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">allWithinDateRange()</span></strong><span class="koboSpan" id="kobo.379.1"> that allows us to fetch a set of individual sales transactions falling within a particular date range. </span><span class="koboSpan" id="kobo.379.2">The data is returned as </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">java.util.List</span></strong><span class="koboSpan" id="kobo.381.1"> of simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">Sale</span></strong><span class="koboSpan" id="kobo.383.1"> value objects. </span><span class="koboSpan" id="kobo.383.2">These are fully featured domain model objects. </span><span class="koboSpan" id="kobo.383.3">They may well have methods on them that perform some of the critical application logic. </span><span class="koboSpan" id="kobo.383.4">They may be little more than basic data structures, perhaps using a Java 17 </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">record</span></strong><span class="koboSpan" id="kobo.385.1"> structure. </span><span class="koboSpan" id="kobo.385.2">This choice is part of our job in deciding what a well-engineered design looks like in our </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">specific case.</span></span></p>
<p><span class="koboSpan" id="kobo.387.1">Again, we can see what is </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">not present:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.389.1">Database </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">connection strings</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">JDBC</span></strong><span class="koboSpan" id="kobo.392.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">JPA</span></strong><span class="koboSpan" id="kobo.394.1"> API details – the standard Java Database </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">Connectivity library</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">SQL</span></strong><span class="koboSpan" id="kobo.397.1"> queries (or </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">NoSQL queries)</span></span></li>
<li><span class="koboSpan" id="kobo.399.1">Database schema and </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">table names</span></span></li>
<li><span class="koboSpan" id="kobo.401.1">Database stored </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">procedure details</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.403.1">Our repository designs focus on what our domain model needs our database to provide but does not constrain how it provides. </span><span class="koboSpan" id="kobo.403.2">As a result, some interesting decisions have to be taken in designing our repository, concerning how much work we put into the database and how much we do in the domain model itself. </span><span class="koboSpan" id="kobo.403.3">Examples of this include deciding whether we will write a complex query in the database adapter, or whether we will write simpler ones and perform additional work in the domain model. </span><span class="koboSpan" id="kobo.403.4">Likewise, will we make use of stored procedures in </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">the database?</span></span></p>
<p><span class="koboSpan" id="kobo.405.1">Whatever trade-offs</span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.406.1"> we decide in these decisions, once again, the database adapter is where all those decisions reside. </span><span class="koboSpan" id="kobo.406.2">The adapter is where we see the database connection strings, query strings, table names, and so on. </span><span class="koboSpan" id="kobo.406.3">The adapter encapsulates the design details of our data schema and </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">database technology.</span></span></p>
<h3><span class="koboSpan" id="kobo.408.1">Abstracting calls to web services</span></h3>
<p><span class="koboSpan" id="kobo.409.1">Making calls to other web services</span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.410.1"> is a frequent development task. </span><span class="koboSpan" id="kobo.410.2">Examples include calls to payment processors and address lookup services. </span><span class="koboSpan" id="kobo.410.3">Sometimes, these are third-party external services, and sometimes, they live inside our web service fleet. </span><span class="koboSpan" id="kobo.410.4">Either way, they generally require some HTTP calls to be made from </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">our application.</span></span></p>
<p><span class="koboSpan" id="kobo.412.1">Abstracting these calls proceeds along similar lines to abstracting the database. </span><span class="koboSpan" id="kobo.412.2">Our port is made up of an interface that inverts the dependency on the web service we are calling, and some value objects that </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">transfer data.</span></span></p>
<p><span class="koboSpan" id="kobo.414.1">An example of abstracting a call to a mapping API such as Google Maps, for example, might look </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.416.1">
package com.sales.domain;
public interface MappingService {
    void addReview(GeographicLocation location,
                   Review review);
}</span></pre>
<p><span class="koboSpan" id="kobo.417.1">We have an interface representing </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">MappingService</span></strong><span class="koboSpan" id="kobo.419.1"> as a whole. </span><span class="koboSpan" id="kobo.419.2">We’ve added a method to add a review of a particular location on whichever service provider we end up using. </span><span class="koboSpan" id="kobo.419.3">We’re using </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">GeographicLocation</span></strong><span class="koboSpan" id="kobo.421.1"> to represent a place, defined in our terms. </span><span class="koboSpan" id="kobo.421.2">It may well have a latitude and longitude pair in it or it may be based on postal code. </span><span class="koboSpan" id="kobo.421.3">That’s another design decision. </span><span class="koboSpan" id="kobo.421.4">Again, we see no sign of the underlying map service or its API details. </span><span class="koboSpan" id="kobo.421.5">That code lives in the adapter, which would connect to the real external mapping </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">web service.</span></span></p>
<p><span class="koboSpan" id="kobo.423.1">This abstraction</span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.424.1"> offers us benefits in being able to use a test double for that external service and being able to change service providers in the future. </span><span class="koboSpan" id="kobo.424.2">You never know when an external service might shut down or become too costly to use. </span><span class="koboSpan" id="kobo.424.3">It’s nice to keep our options open by using the </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">hexagonal architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">This section has presented some ideas for the most common tasks in working with external systems in a hexagonal architecture. </span><span class="koboSpan" id="kobo.426.2">In the next section, we’ll discuss general approaches to writing code in the </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">domain model.</span></span></p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.428.1">Writing the domain code</span></h1>
<p><span class="koboSpan" id="kobo.429.1">In this section, we will look at some of the things</span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.430.1"> we need to think about as we write the code for our domain model. </span><span class="koboSpan" id="kobo.430.2">We’ll cover what kinds of libraries we should and should not use in the domain model, how we deal with application configuration and initialization, and we’ll also think about what impact popular </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">frameworks have.</span></span></p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.432.1">Deciding what should be in our domain model</span></h2>
<p><span class="koboSpan" id="kobo.433.1">Our domain model is the very</span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.434.1"> core of our application and the hexagonal architecture puts it up front and center. </span><span class="koboSpan" id="kobo.434.2">A good domain model is written using the language of our users’ problem domain; that’s where the name comes from. </span><span class="koboSpan" id="kobo.434.3">We should see the names of program elements that our users would recognize. </span><span class="koboSpan" id="kobo.434.4">We should recognize the problem being solved over and above the mechanisms we are using to solve it. </span><span class="koboSpan" id="kobo.434.5">Ideally, we will see terms from our user stories being used in our </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">domain model.</span></span></p>
<p><span class="koboSpan" id="kobo.436.1">Applying the hexagonal architecture, we choose our domain model to be independent of those things that are not essential to solving the problem. </span><span class="koboSpan" id="kobo.436.2">That’s why external systems are isolated. </span><span class="koboSpan" id="kobo.436.3">We may initially think that creating a sales report means that we must read a file and we must create an HTML document. </span><span class="koboSpan" id="kobo.436.4">But that’s not the essential heart of the problem. </span><span class="koboSpan" id="kobo.436.5">We simply need to get sales data from somewhere, perform some calculations to get totals for our report, then format it somehow. </span><span class="koboSpan" id="kobo.436.6">The somewhere and somehow can change, without affecting the essence of </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">our solution.</span></span></p>
<p><span class="koboSpan" id="kobo.438.1">Bearing this constraint in mind, we can take any standard analysis and design approach. </span><span class="koboSpan" id="kobo.438.2">We are free to choose objects or decompose them into functions as we normally do. </span><span class="koboSpan" id="kobo.438.3">We only have to preserve that distinction between the essence of the problem and the </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">implementation details.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">We need to exercise judgment</span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.441.1"> in these decisions. </span><span class="koboSpan" id="kobo.441.2">In our sales report example, the source of the sales data is of no consequence. </span><span class="koboSpan" id="kobo.441.3">As a counter-example, suppose we are making a linter for our Java program files – it’s quite reasonable to have the concept of files represented directly in our domain model. </span><span class="koboSpan" id="kobo.441.4">This problem domain is all about working with Java files, so we should make that clear. </span><span class="koboSpan" id="kobo.441.5">We may still decouple the domain model of a file from the OS-specific details of reading and writing it, but the concept would be in the </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">domain model.</span></span></p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.443.1">Using libraries and frameworks in the domain model</span></h2>
<p><span class="koboSpan" id="kobo.444.1">The domain model can use any pre-written</span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.445.1"> library or framework</span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.446.1"> to help do its job. </span><span class="koboSpan" id="kobo.446.2">Popular libraries such as Apache Commons or the Java Standard Runtime library generally present no problems here. </span><span class="koboSpan" id="kobo.446.3">However, we need to be aware of frameworks that bind us to the world of external systems and our adapter layer. </span><span class="koboSpan" id="kobo.446.4">We need to invert dependencies on those frameworks, leaving them to be just an implementation detail of the </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">adapter layer.</span></span></p>
<p><span class="koboSpan" id="kobo.448.1">An example might be the </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">@RestController</span></strong><span class="koboSpan" id="kobo.450.1"> annotation of Spring Boot. </span><span class="koboSpan" id="kobo.450.2">It looks like pure domain code at first sight, but it ties the class tightly to generated code that is specific to the </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">web adapter.</span></span></p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.452.1">Deciding on a programming approach</span></h2>
<p><span class="koboSpan" id="kobo.453.1">The domain model</span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.454.1"> can be written using any programming paradigm. </span><span class="koboSpan" id="kobo.454.2">This flexibility means that we will need to decide on which approach to use. </span><span class="koboSpan" id="kobo.454.3">This is never a purely technical decision, like with so many things in software. </span><span class="koboSpan" id="kobo.454.4">We should consider </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.456.1">Existing team skills and preferences</span></strong><span class="koboSpan" id="kobo.457.1">: What paradigm does the team know best? </span><span class="koboSpan" id="kobo.457.2">Which paradigm would they like to use, given </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">the chance?</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.459.1">Existing libraries, frameworks, and code bases</span></strong><span class="koboSpan" id="kobo.460.1">: If we are going to be using pre-written code – and let’s face it, we almost certainly will – then what paradigm would best suit </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">that code?</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.462.1">Style guides and other code mandates</span></strong><span class="koboSpan" id="kobo.463.1">: Are we working with an existing style guide or paradigm? </span><span class="koboSpan" id="kobo.463.2">If we are being paid for our work – or we are contributing to an existing open source project – we will need to adopt the paradigm set out </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">for us.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.465.1">The good news is that whatever</span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.466.1"> paradigm we choose, we will be able to write our domain model successfully. </span><span class="koboSpan" id="kobo.466.2">While the code may look different, equivalent functionality can be written using any of </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">the paradigms.</span></span></p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.468.1">Substituting test doubles for external systems</span></h1>
<p><span class="koboSpan" id="kobo.469.1">In this section, we’ll discuss </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.470.1">one of the biggest advantages</span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.471.1"> that the hexagonal architecture brings to TDD: high testability. </span><span class="koboSpan" id="kobo.471.2">It also brings some </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">workflow advantages.</span></span></p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.473.1">Replacing the adapters with test doubles</span></h2>
<p><span class="koboSpan" id="kobo.474.1">The key advantage the hexagonal</span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.475.1"> architecture brings to TDD</span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.476.1"> is that it is trivially easy to replace all the adapters with test doubles, giving us the ability to test the entire domain model with FIRST unit tests. </span><span class="koboSpan" id="kobo.476.2">We can test the entire application core logic without test environments, test databases, or HTTP tools such as Postman or curl – just fast, repeatable unit tests. </span><span class="koboSpan" id="kobo.476.3">Our testing setup looks </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<span class="koboSpan" id="kobo.478.1"><img alt="Figure 9.7 – Testing the domain model" src="image/Figure_9.7_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.479.1">Figure 9.7 – Testing the domain model</span></p>
<p><span class="koboSpan" id="kobo.480.1">We can see that all the adapters</span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.481.1"> have been replaced by test doubles, completely</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.482.1"> freeing us from our environment of external systems. </span><span class="koboSpan" id="kobo.482.2">Unit tests can now cover the whole domain model, reducing the need for </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">integration tests.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">We gain several benefits</span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.485.1"> by </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">doing this:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.487.1">We can write TDD tests first with ease</span></strong><span class="koboSpan" id="kobo.488.1">: There’s no friction in writing a simple test double that lives entirely in memory and has no dependencies on the </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">test environment.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.490.1">We gain FIRST unit test benefits</span></strong><span class="koboSpan" id="kobo.491.1">: Our tests run very fast indeed and are repeatable. </span><span class="koboSpan" id="kobo.491.2">Typically, testing an entire domain model takes the order of seconds, not hours. </span><span class="koboSpan" id="kobo.491.3">The tests will repeatably pass or fail, meaning we are never wondering whether a build failure was due to a flaky integration </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">test failure.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.493.1">It unlocks our team</span></strong><span class="koboSpan" id="kobo.494.1">: We can do useful work building the core logic of our system, without having to wait for test environments to be designed </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">and built.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.496.1">The techniques for creating the test doubles were outlined in </span><a href="B18384_08.xhtml#_idTextAnchor149"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.497.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.498.1">, </span><em class="italic"><span class="koboSpan" id="kobo.499.1">Test Doubles – Stubs and Mocks</span></em><span class="koboSpan" id="kobo.500.1">. </span><span class="koboSpan" id="kobo.500.2">There is nothing new required in terms of implementing </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">these doubles.</span></span></p>
<p><span class="koboSpan" id="kobo.502.1">One consequence</span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.503.1"> of being able to test the whole domain model</span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.504.1"> is that we can apply TDD and FIRST unit tests to much larger program units. </span><span class="koboSpan" id="kobo.504.2">The next section discusses what that means </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">for us.</span></span></p>
<h1 id="_idParaDest-192"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.506.1">Unit testing bigger units</span></h1>
<p><span class="koboSpan" id="kobo.507.1">The previous section introduced</span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.508.1"> the idea of surrounding our domain model with test doubles for every port. </span><span class="koboSpan" id="kobo.508.2">This gives us some interesting opportunities to discuss in this section. </span><span class="koboSpan" id="kobo.508.3">We can test units that are as large as a </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">user story.</span></span></p>
<p><span class="koboSpan" id="kobo.510.1">We’re familiar with unit tests as being things that test in the small. </span><span class="koboSpan" id="kobo.510.2">There’s a good chance you’ll have heard somebody say that a unit test should only ever apply to a single function, or that every class should have one unit test for every method. </span><span class="koboSpan" id="kobo.510.3">We’ve already seen how that’s not the best way to use unit tests. </span><span class="koboSpan" id="kobo.510.4">Tests like those miss out on some advantages. </span><span class="koboSpan" id="kobo.510.5">We are better served by thinking of tests as covering </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">behavior instead.</span></span></p>
<p><span class="koboSpan" id="kobo.512.1">The combined approach of designing with the hexagonal architecture and testing behaviors instead of implementation details leads to an interesting system layering. </span><span class="koboSpan" id="kobo.512.2">Instead of having traditional layers, as we might do in a three-tier architecture, we have circles of increasingly higher-level behavior. </span><span class="koboSpan" id="kobo.512.3">Inside our domain model, we will find those tests-in-the-small. </span><span class="koboSpan" id="kobo.512.4">But as we move outward, toward the adapter layer, we will find bigger units </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">of behavior.</span></span></p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.514.1">Unit testing entire user stories</span></h2>
<p><span class="koboSpan" id="kobo.515.1">The ports in the domain model</span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.516.1"> form a natural high-level boundary of the domain model. </span><span class="koboSpan" id="kobo.516.2">If we review what we’ve learned in this chapter, we’ll see that this boundary consists of </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.518.1">The essence of requests </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">from users</span></span></li>
<li><span class="koboSpan" id="kobo.520.1">The essence of a response from </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">our application</span></span></li>
<li><span class="koboSpan" id="kobo.522.1">The essence of how data needs storing </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">and accessing</span></span></li>
<li><span class="koboSpan" id="kobo.524.1">All using </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">technology-free code</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.526.1">This layer is the essence of what our application does, free from the details of how it does it. </span><span class="koboSpan" id="kobo.526.2">It is nothing less than the original user stories themselves. </span><span class="koboSpan" id="kobo.526.3">The most significant thing about this domain model is that we can write FIRST unit tests against it. </span><span class="koboSpan" id="kobo.526.4">We have all we need to replace difficult-to-test external systems with simple test doubles. </span><span class="koboSpan" id="kobo.526.5">We can write unit tests that cover entire user stories, confirming that our core logic </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">is correct.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.528.1">Faster, more reliable testing</span></p>
<p class="callout"><span class="koboSpan" id="kobo.529.1">Traditionally, testing user stories involved slower integration tests in a test environment. </span><span class="koboSpan" id="kobo.529.2">The hexagonal architecture enables unit tests to replace some of these integration tests, speeding up our builds and providing greater repeatability of </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">our testing.</span></span></p>
<p><span class="koboSpan" id="kobo.531.1">We can now test-drive at three granularities against our </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">domain model:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.533.1">Against a single method </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">or function</span></span></li>
<li><span class="koboSpan" id="kobo.535.1">Against the public behaviors of a class and any collaborators </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">it has</span></span></li>
<li><span class="koboSpan" id="kobo.537.1">Against the core logic of an entire </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">user story</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.539.1">This is a big benefit of the hexagonal architecture. </span><span class="koboSpan" id="kobo.539.2">The isolation from external services has the effect of pushing the essential logic of a user story into the domain model, where it interacts with ports. </span><span class="koboSpan" id="kobo.539.3">As we’ve seen, those ports – by design – are trivially easy to write test doubles for. </span><span class="koboSpan" id="kobo.539.4">It’s worth restating the key benefits of FIRST </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">unit tests:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.541.1">They are very fast, so testing our user stories will be </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">very fast</span></span></li>
<li><span class="koboSpan" id="kobo.543.1">They are highly repeatable, so we can trust test passes </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">and failures</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.545.1">As we cover wide areas of functionality</span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.546.1"> with unit tests, we blur the line between integration and unit testing. </span><span class="koboSpan" id="kobo.546.2">We remove friction from developers testing more of the user stories by making that testing easier. </span><span class="koboSpan" id="kobo.546.3">Using more unit tests improves build times, as the tests run quickly and give reliable pass/fail results. </span><span class="koboSpan" id="kobo.546.4">Fewer integration tests are needed, which is good as they run more slowly and are more prone to </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">incorrect results.</span></span></p>
<p><span class="koboSpan" id="kobo.548.1">In the next section, we’ll apply what we’ve learned to our Wordz application. </span><span class="koboSpan" id="kobo.548.2">We will write a port that abstracts out the details of fetching a word for our users </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">to guess.</span></span></p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.550.1">Wordz – abstracting the database</span></h1>
<p><span class="koboSpan" id="kobo.551.1">In this section, we will apply what we’ve learned </span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.552.1">to our Wordz application and create a port suitable for fetching the words to present to a user. </span><span class="koboSpan" id="kobo.552.2">We will write the adapters and integration tests in </span><a href="B18384_14.xhtml#_idTextAnchor293"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.553.1">Chapter 14</span></em></span></a><span class="koboSpan" id="kobo.554.1">, </span><em class="italic"><span class="koboSpan" id="kobo.555.1">Driving the </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.556.1">Database Layer</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">.</span></span></p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.558.1">Designing the repository interface</span></h2>
<p><span class="koboSpan" id="kobo.559.1">The first job in designing our port</span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.560.1"> is to decide what it should be doing. </span><span class="koboSpan" id="kobo.560.2">For a database port, we need to think about the split between what we want our domain model to be responsible for and what we will push out to the database. </span><span class="koboSpan" id="kobo.560.3">The ports we use for </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.561.1">a database are generally called </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">repository interfaces.</span></span></p>
<p><span class="koboSpan" id="kobo.563.1">Three broad principles</span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.564.1"> should </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">guide us:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.566.1">Think about what the domain model needs – why do we need this data? </span><span class="koboSpan" id="kobo.566.2">What will it be </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">used for?</span></span></li>
<li><span class="koboSpan" id="kobo.568.1">Don’t simply echo an assumed database implementation – don’t think in terms of tables and foreign keys at this stage. </span><span class="koboSpan" id="kobo.568.2">That comes later when we decide how to implement the storage. </span><span class="koboSpan" id="kobo.568.3">Sometimes, database performance considerations mean we have to revisit the abstraction we create here. </span><span class="koboSpan" id="kobo.568.4">We would then trade off leaking some database implementation details here if it allowed the database to function better. </span><span class="koboSpan" id="kobo.568.5">We should defer such decisions as late as </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">we can.</span></span></li>
<li><span class="koboSpan" id="kobo.570.1">Consider when we should leverage the database engine more. </span><span class="koboSpan" id="kobo.570.2">Perhaps we intend to use complex stored procedures in the database engine. </span><span class="koboSpan" id="kobo.570.3">Reflect this split of behavior in the repository interface. </span><span class="koboSpan" id="kobo.570.4">It may suggest a higher-level abstraction in the </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">repository interface.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.572.1">For our running example application, let’s consider the task of fetching a word at random for the user to guess. </span><span class="koboSpan" id="kobo.572.2">How should we divide the work between the domain and database? </span><span class="koboSpan" id="kobo.572.3">There are two </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">broad options:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.574.1">Let the database choose a word </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">at random</span></span></li>
<li><span class="koboSpan" id="kobo.576.1">Let the domain model generate a random number and let the database supply a </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">numbered word</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.578.1">In general, letting the database</span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.579.1"> do more work results in faster data handling; the database</span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.580.1"> code is closer to the data and isn’t dragging it over a network connection into our domain model. </span><span class="koboSpan" id="kobo.580.2">But how do we persuade a database to choose something at random? </span><span class="koboSpan" id="kobo.580.3">We know that for relational databases, we can issue a query that will return results in no guaranteed order. </span><span class="koboSpan" id="kobo.580.4">That’s sort of random. </span><span class="koboSpan" id="kobo.580.5">But would it be random enough? </span><span class="koboSpan" id="kobo.580.6">Across all possible implementations? </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">Seems unlikely.</span></span></p>
<p><span class="koboSpan" id="kobo.582.1">The alternative is to let the domain model code decide which word to pick by generating a random number. </span><span class="koboSpan" id="kobo.582.2">We can then issue a query to fetch the word associated with that number. </span><span class="koboSpan" id="kobo.582.3">This also suggests that each word has an associated number with it – something we can provide when we design the database </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">schema later.</span></span></p>
<p><span class="koboSpan" id="kobo.584.1">This approach implies we need the domain model to pick a random number from all the numbers associated with the words. </span><span class="koboSpan" id="kobo.584.2">That implies the domain model needs to know the full set of numbers to choose from. </span><span class="koboSpan" id="kobo.584.3">We can make another design decision here. </span><span class="koboSpan" id="kobo.584.4">The numbers used to identify a word will start at 1 and increase by one for each word. </span><span class="koboSpan" id="kobo.584.5">We can provide a method on our port that returns the upper bound of these numbers. </span><span class="koboSpan" id="kobo.584.6">Then, we are all set to define that repository interface – with </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">a test.</span></span></p>
<p><span class="koboSpan" id="kobo.586.1">The test class starts with the package declaration and library imports </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">we need:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.588.1">
package com.wordz.domain;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import static org.assertj.core.api.Assertions.*;
import static org.mockito.Mockito.when;</span></pre>
<p><span class="koboSpan" id="kobo.589.1">We enable Mockito integration with an annotation provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">junit-jupiter</span></strong><span class="koboSpan" id="kobo.591.1"> library. </span><span class="koboSpan" id="kobo.591.2">We add the annotation at the </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">class level:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.593.1">
@ExtendWith(MockitoExtension.class)
public class WordSelectionTest {</span></pre>
<p><span class="koboSpan" id="kobo.594.1">This will ensure</span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.595.1"> that Mockito is initialized on each test run. </span><span class="koboSpan" id="kobo.595.2">The next</span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.596.1"> part of the test defines some integer constants </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">for readability:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.598.1">
    private static final int HIGHEST_WORD_NUMBER = 3;
    private static final int WORD_NUMBER_SHINE = 2;</span></pre>
<p><span class="koboSpan" id="kobo.599.1">We need two test doubles, which we want Mockito to generate. </span><span class="koboSpan" id="kobo.599.2">We need a stub for the word repository and a stub for a random number generator. </span><span class="koboSpan" id="kobo.599.3">We must add fields for these stubs. </span><span class="koboSpan" id="kobo.599.4">We will mark the fields with the Mockito </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">@Mock</span></strong><span class="koboSpan" id="kobo.601.1"> annotation so that Mockito will generate the doubles </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">for us:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.603.1">
    @Mock
    private WordRepository repository;
    @Mock
    private RandomNumbers random;</span></pre>
<p><span class="koboSpan" id="kobo.604.1">Mockito sees no difference between a mock or stub when we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">@Mock</span></strong><span class="koboSpan" id="kobo.606.1"> annotation. </span><span class="koboSpan" id="kobo.606.2">It simply creates a test double that can be configured for use either as a mock or a stub. </span><span class="koboSpan" id="kobo.606.3">This is done later in the </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">test code.</span></span></p>
<p><span class="koboSpan" id="kobo.608.1">We will name the test method </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">selectsWordAtRandom()</span></strong><span class="koboSpan" id="kobo.610.1">. </span><span class="koboSpan" id="kobo.610.2">We want to drive out a class that we will call </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">WordSelection</span></strong><span class="koboSpan" id="kobo.612.1"> and make it responsible for choosing one word at random </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">WordRepository</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.616.1">
    @Test
    void selectsWordAtRandom() {
        when(repository.highestWordNumber())
            .thenReturn(HIGHEST_WORD_NUMBER);
        when(repository.fetchWordByNumber(WORD_NUMBER_SHINE))
            .thenReturn("SHINE");
        when(random.next(HIGHEST_WORD_NUMBER))
            .thenReturn(WORD_NUMBER_SHINE);
        var selector = new WordSelection(repository,
                                         random);
        String actual = selector.chooseRandomWord();
        assertThat(actual).isEqualTo("SHINE");
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.617.1">The preceding test was written in the normal</span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.618.1"> way, adding lines to capture</span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.619.1"> each </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">design decision:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.621.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">WordSelection</span></strong><span class="koboSpan" id="kobo.623.1"> class encapsulates the algorithm, which selects a word </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">to guess</span></span></li>
<li><span class="koboSpan" id="kobo.625.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">WordSelection</span></strong><span class="koboSpan" id="kobo.627.1"> constructor takes </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">two dependencies:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">WordRepository</span></strong><span class="koboSpan" id="kobo.630.1"> is the port for </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">stored words</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">RandomNumbers</span></strong><span class="koboSpan" id="kobo.633.1"> is the port for random </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">number generation</span></span></li></ul></li>
<li><span class="koboSpan" id="kobo.635.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">chooseRandomWord()</span></strong><span class="koboSpan" id="kobo.637.1"> method will return a randomly chosen word as </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">a String</span></span></li>
<li><span class="koboSpan" id="kobo.639.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">arrange</span></strong><span class="koboSpan" id="kobo.641.1"> section is moved out to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">beforeEachTest()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.643.1"> method:</span></span><pre class="console"><span class="koboSpan" id="kobo.644.1">
@BeforeEach</span></pre><pre class="console"><span class="koboSpan" id="kobo.645.1">
void beforeEachTest() {</span></pre><pre class="console"><span class="koboSpan" id="kobo.646.1">
    when(repository.highestWordNumber())</span></pre><pre class="console"><span class="koboSpan" id="kobo.647.1">
                  .thenReturn(HIGHEST_WORD_NUMBER);</span></pre><pre class="console"><span class="koboSpan" id="kobo.648.1">
    when(repository.fetchWordByNumber(WORD_NUMBER_SHINE))</span></pre><pre class="console"><span class="koboSpan" id="kobo.649.1">
                  .thenReturn("SHINE");</span></pre><pre class="console"><span class="koboSpan" id="kobo.650.1">
}</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.651.1">This will set up the test data in the stub for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">WordRepository</span></strong><span class="koboSpan" id="kobo.653.1"> at the start of each test. </span><span class="koboSpan" id="kobo.653.2">The word identified by number 2 is defined as </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">SHINE</span></strong><span class="koboSpan" id="kobo.655.1">, so we can check that in </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">the assert.</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.657.1">Out of that test code</span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.658.1"> flows the following definition</span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.659.1"> of two </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">interface methods:</span></span><pre class="console"><span class="koboSpan" id="kobo.661.1">
package com.wordz.domain;</span></pre><pre class="console"><span class="koboSpan" id="kobo.662.1">
public interface WordRepository {</span></pre><pre class="console"><span class="koboSpan" id="kobo.663.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.664.1">String fetchWordByNumber(int number);</span></strong></pre><pre class="console">
<strong class="bold"><span class="koboSpan" id="kobo.665.1">    int highestWordNumber();</span></strong></pre><pre class="console"><span class="koboSpan" id="kobo.666.1">
}</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.667.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">WordRepository</span></strong><span class="koboSpan" id="kobo.669.1"> interface defines our application’s view of the database. </span><span class="koboSpan" id="kobo.669.2">We only need two facilities for our </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">current needs:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.671.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">fetchWordByNumber()</span></strong><span class="koboSpan" id="kobo.673.1"> method to fetch a word, given its </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">identifying number</span></span></li>
<li><span class="koboSpan" id="kobo.675.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">highestWordNumber()</span></strong><span class="koboSpan" id="kobo.677.1"> method to say what the highest word number </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">will be</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.679.1">The test has also driven out the interface needed for our random </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">number generator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.681.1">
package com.wordz.domain;
public interface RandomNumbers {
    int next(int upperBoundInclusive);
}</span></pre>
<p><span class="koboSpan" id="kobo.682.1">The single </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">next()</span></strong><span class="koboSpan" id="kobo.684.1"> method returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">int</span></strong><span class="koboSpan" id="kobo.686.1"> in the range of 1 to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">upperBoundInclusive</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.688.1"> number.</span></span></p>
<p><span class="koboSpan" id="kobo.689.1">With both the test and port interfaces</span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.690.1"> defined, we can write the domain</span><a id="_idIndexMarker501"/> <span class="No-Break"><span class="koboSpan" id="kobo.691.1">model code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.692.1">
package com.wordz.domain;
public class WordSelection {
    private final WordRepository repository;
    private final RandomNumbers random;
    public WordSelection(WordRepository repository,
                         RandomNumbers random) {
        this.repository = repository;
        this.random = random;
    }
    public String chooseRandomWord() {
        int wordNumber =
           random.next(repository.highestWordNumber());
        return repository.fetchWordByNumber(wordNumber);
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.693.1">Notice how this code does</span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.694.1"> not import anything from outside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">com.wordz.domain</span></strong><span class="koboSpan" id="kobo.696.1"> package. </span><span class="koboSpan" id="kobo.696.2">It is pure</span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.697.1"> application logic, relying only on the port interfaces to access stored words and random numbers. </span><span class="koboSpan" id="kobo.697.2">With this, our production code for the domain model of </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">WordSelection</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.699.1">is complete.</span></span></p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.700.1">Designing the database and random numbers adapters</span></h2>
<p><span class="koboSpan" id="kobo.701.1">The next job</span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.702.1"> is to implement</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.703.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">RandomNumbers</span></strong><span class="koboSpan" id="kobo.705.1"> port and database</span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.706.1"> access code</span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.707.1"> that implements our </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">WordRepository</span></strong><span class="koboSpan" id="kobo.709.1"> interface. </span><span class="koboSpan" id="kobo.709.2">In outline, we’ll choose a database product, research how to connect to it and run database queries, then test-drive that code using an integration test. </span><span class="koboSpan" id="kobo.709.3">We will defer doing these tasks to part three of this book, in </span><a href="B18384_13.xhtml#_idTextAnchor275"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.710.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.711.1">, </span><em class="italic"><span class="koboSpan" id="kobo.712.1">Driving the Domain Layer</span></em><span class="koboSpan" id="kobo.713.1">, and </span><a href="B18384_14.xhtml#_idTextAnchor293"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.714.1">Chapter 14</span></em></span></a><span class="koboSpan" id="kobo.715.1">, </span><em class="italic"><span class="koboSpan" id="kobo.716.1">Driving the </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.717.1">Database Layer</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">.</span></span></p>
<h1 id="_idParaDest-197"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.719.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.720.1">In this chapter, we learned how to apply the SOLID principles to decouple external systems completely, leading to an application architecture known as the hexagonal architecture. </span><span class="koboSpan" id="kobo.720.2">We saw how this allows us to use test doubles in place of external systems, making our tests simpler to write, with repeatable results. </span><span class="koboSpan" id="kobo.720.3">This, in turn, allows us to test entire user stories with a FIRST unit test. </span><span class="koboSpan" id="kobo.720.4">As a bonus, we isolate ourselves from future changes in those external systems, limiting the amount of rework that would be required to support new technologies. </span><span class="koboSpan" id="kobo.720.5">We’ve seen how the hexagonal architecture combined with dependency injection allows us to support several different external systems choices and select the one we want at runtime </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">via configuration.</span></span></p>
<p><span class="koboSpan" id="kobo.722.1">The next chapter will look at the different styles of automated testing that apply to the different sections of a hexagonal architecture application. </span><span class="koboSpan" id="kobo.722.2">This approach is summarized as the Test Pyramid, and we shall learn more about </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">it there.</span></span></p>
<h1 id="_idParaDest-198"><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.724.1">Questions and answers</span></h1>
<p><span class="koboSpan" id="kobo.725.1">Take a look at the following questions and answers regarding this </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">chapter’s content:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.727.1">Can we add the hexagonal </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">architecture later?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.729.1">Not always. </span><span class="koboSpan" id="kobo.729.2">We can refactor it. </span><span class="koboSpan" id="kobo.729.3">The challenge can be too much code that directly depends on details of external systems. </span><span class="koboSpan" id="kobo.729.4">If that’s the starting point, this refactoring will be challenging. </span><span class="koboSpan" id="kobo.729.5">There will be a lot of rework to do. </span><span class="koboSpan" id="kobo.729.6">This implies that some degree of up-front design and architectural discussion is required before we </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">start work.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.731.1">Is the hexagonal architecture specific </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">to OOP?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.733.1">No. </span><span class="koboSpan" id="kobo.733.2">It is a way of organizing dependencies in our code. </span><span class="koboSpan" id="kobo.733.3">It can be applied to OOP, FP, procedural programming, or anything else – so long as those dependencies are </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">managed correctly.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.735.1">When should we not use the </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">hexagonal architecture?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.737.1">When we have no real logic in our domain model. </span><span class="koboSpan" id="kobo.737.2">This is common for very small CRUD microservices that typically frontend a database table. </span><span class="koboSpan" id="kobo.737.3">With no logic to isolate, putting in all this code has no benefit. </span><span class="koboSpan" id="kobo.737.4">We may as well do TDD with integration tests only and accept that we won’t be able to use FIRST </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">unit tests.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.739.1">Can we only have one port for an </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">external system?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.741.1">No. </span><span class="koboSpan" id="kobo.741.2">It is often better if we have more ports. </span><span class="koboSpan" id="kobo.741.3">Suppose we have a single Postgres database connected to our application, holding data on users, sales, and product inventory. </span><span class="koboSpan" id="kobo.741.4">We could simply have a single repository interface, with methods to work with those three datasets. </span><span class="koboSpan" id="kobo.741.5">But it will be better to split that interface up (following ISP) and have </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">UserRepository</span></strong><span class="koboSpan" id="kobo.743.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">SalesRepository</span></strong><span class="koboSpan" id="kobo.745.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">InventoryRepository</span></strong><span class="koboSpan" id="kobo.747.1">. </span><span class="koboSpan" id="kobo.747.2">The ports provide a view of what our domain model wants from external systems. </span><span class="koboSpan" id="kobo.747.3">Ports are not a one-to-one mapping </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">to hardware.</span></span></p>
<h1 id="_idParaDest-199"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.749.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.750.1">To learn more about the topics that were covered in this chapter, take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">following resources:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.752.1">Hexagonal architecture, Alastair </span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">Cockburn: </span></span><a href="https://alistair.cockburn.us/hexagonal-architecture/"><span class="No-Break"><span class="koboSpan" id="kobo.754.1">https://alistair.cockburn.us/hexagonal-architecture/</span></span></a></li>
</ul>
<p><span class="koboSpan" id="kobo.755.1">The original description of the hexagonal architecture in terms of ports </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">and adapters.</span></span></p>
<ul>
<li><a href="https://medium.com/pragmatic-programmers/unit-tests-are-first-fast-isolated-repeatable-self-verifying-and-timely-a83e8070698e"><span class="No-Break"><span class="koboSpan" id="kobo.757.1">https://medium.com/pragmatic-programmers/unit-tests-are-first-fast-isolated-repeatable-self-verifying-and-timely-a83e8070698e</span></span></a></li>
</ul>
<p><span class="koboSpan" id="kobo.758.1">Credits the original inventors of the term FIRST, Tim Ottinger and </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">Brett Schuchert.</span></span></p>
<ul>
<li><a href="https://launchdarkly.com/blog/testing-in-production-for-safety-and-sanity/"><span class="No-Break"><span class="koboSpan" id="kobo.760.1">https://launchdarkly.com/blog/testing-in-production-for-safety-and-sanity/</span></span></a></li>
</ul>
<p><span class="koboSpan" id="kobo.761.1">Guide to testing code deployed on production systems, without accidentally triggering </span><span class="No-Break"><span class="koboSpan" id="kobo.762.1">unintended consequences.</span></span></p>
</div>
</body></html>