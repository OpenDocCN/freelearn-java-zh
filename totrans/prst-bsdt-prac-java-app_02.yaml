- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring the Multiple Database Flavors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a system evolves, especially within a microservices architecture, it becomes
    necessary to implement a polyglot persistence strategy to accommodate the individual
    needs of decoupled and independent services. This involves examining various options
    for storing data, including **Database Management Systems** (**DBMSs**) such as
    relational, NoSQL, and NewSQL databases. It is important to consider the application’s
    use case scenarios for each type of database in order to avoid overengineering
    the architectural design.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will delve into the characteristics and advantages of both
    traditional relational databases and newer non-relational databases. We will also
    take a closer look at NewSQL databases and their place in the market.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before delving into the application details, we’ll start by familiarizing ourselves
    with the multiple storage solutions that we can adopt as the persistence strategy
    of our solutions. The following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: A look back at relational databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A deep dive into non-relational databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NewSQL databases – trying to get the best out of both worlds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A look back at relational databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Relational databases have been a trusted solution for data storage for over
    50 years, with widespread adoption amongst worldwide corporations. One of the
    best advantages users gain from using relational databases is being able to use
    **Structured Query** **Language** (**SQL**).
  prefs: []
  type: TYPE_NORMAL
- en: The fact that SQL is a standard query language supported by multiple vendors
    means SQL code is portable, and the same SQL code works with little or no modification
    on many database systems. This is a way of assuring vendor lock-in. Other than
    that, SQL also helps to reduce the cognitive load of having to learn a new language
    or API, such as Java’s JDBC or JPA.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when referring to the DBMS, in addition to a large variety of tools and
    resources, relational databases also adhere to the **ACID** principles (**atomicity,
    consistency, isolation, and durability**), ensuring the reliability and integrity
    of data transactions. These features make relational databases a reliable choice
    for a large number of use cases. Relational databases have shown extreme maturity,
    bringing several success cases that cover, beyond the basics, other capabilities
    such as providing tools for backup, data visualization, and more. It is a fact
    that when someone who is used to working with SQL databases switches the focus
    and starts working with NoSQL storage solutions, they do miss all the side-tooling
    and thousands of instruments available to support them in their daily tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, we have JDBC, and a language we can learn once and write/apply anywhere.
    The relational database engine is transparent; thus, JDBC and JPA will be the
    same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The essential characteristics of these persistence technologies are the properties
    associated with data transactions: **atomicity, consistency, isolation, and durability**
    (**ACID**). Transactions that comply with ACID properties have the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Atomicity**: A transaction is an atomic unit. Either all database operations
    occur as a unit, or nothing occurs; it is an ‘all or nothing’ operation. This
    results in the prevention of partial data updates and potential data inconsistency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: The database should be in a consistent state when a transaction
    *begins* and *ends*. The transaction should follow every database constraint and
    rule in order to be adequately consistent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolation**: One transaction should not adversely or unexpectedly impact
    another operation. For example, one table insert will generate a table row ID
    that is used by the second operation. However, we don’t want two operations changing
    the same row simultaneously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Durability**: Upon completion of a transaction, once committed, the changes
    will remain permanently. This ensures data consistency even in the case of unexpected
    failures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we will learn in the upcoming chapters, Java applications have multiple different
    strategies to integrate with a database. There are several design patterns related
    to data integration that can be used to design the applications, ranging from
    a lower to higher decoupling from the underlying database. The reason we should
    worry about the capability of abstracting and having a lower effort when switching
    to another data storage solution is that even though relational databases are
    very mature, they are not suitable for every use case. Characteristics such as
    flexibility in data schema, scalability when handling large datasets in the face
    of a high number of read and write operations, performance of queries on large
    datasets, and handling hierarchical and other complex relationships during data
    modeling are examples of points that are usually stronger on NoSQL databases than
    on relational ones. Now, we should get a better understanding of the multiple
    types of NoSQL databases and their characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: A deep dive into non-relational databases (NoSQL)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**NoSQL** databases provide mechanisms for storing and retrieving unstructured
    data (non-relational), in stark contrast to the tabular relations used in relational
    databases. Compared to relational databases, NoSQL databases have better performance
    and high scalability. They are becoming more popular in several industries, such
    as finance and streaming. As a result of this increased usage, the number of users
    and database vendors is growing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast to the relational database ACID principles, in the NoSQL world,
    the key characteristics are **BASE** (**basic availability, soft-state, and eventual
    consistency**). The details of each are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic availability**: A high degree of replication ensures data availability
    even if multiple failures occur.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Soft-state**: There is no requirement to have write consistency and no guarantee
    that the replicated data will be consistent across nodes. Unlike in traditional
    relational databases, changes can occur without direct user input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eventual consistency**: The consistency can be handled lazily when data is
    retrieved (read time). In other words, the data will be eventually consistent
    so that all nodes will have the same data but not necessarily at the same time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many NoSQL database types, each of which is designed to handle a specific
    set of workloads and data modeling needs. In order to best define which NoSQL
    storage type to use, we will now delve into it, getting a clearer view of key-value,
    document, column-family, and graph database types.
  prefs: []
  type: TYPE_NORMAL
- en: After getting a broad understanding of the multiple flavors of NoSQL, you can
    refer to *Figure 2**.5*, presented at the end of this section, to see how concepts
    can be compared between relational databases and some of the NoSQL storage flavors.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL database types – key-value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These are the simplest storage types in the NoSQL world. The data is stored
    as a collection of key-value pairs in a way that is optimized for storing large
    amounts of data and efficiently handling data search by its key. This database
    type has a structure that resembles the `java.util.Map` API where values are mapped
    to keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if using such a paradigm to store information about Greek mythological
    figures and associate them with their characteristics, the data association would
    be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Key-value store database representation](img/B19375_02_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Key-value store database representation
  prefs: []
  type: TYPE_NORMAL
- en: Three Greek mythological figures and the associations between them and their
    characteristics are represented in the preceding figure. In this example, the
    value **Sun** has a key **Apollo**, whereas the key **Aphrodite** can be used
    to refer to both **Love** and **Beauty**.
  prefs: []
  type: TYPE_NORMAL
- en: Currently on the market, some popular implementations of this approach are **Amazon**
    **DynamoDB**, **Hazelcast**, and **Redis** databases, the latter two being open
    source technologies. Each vendor brings its own unique benefits; DynamoDB can
    be used as a fully managed service, meaning that Amazon takes care of all infrastructure
    and maintenance required to run the service. Redis is an in-memory database solution
    that supports pub/sub messaging and caching capabilities. Finally, Hazelcast has
    support for the MapReduce programming model to perform distributed data processing
    tasks, plus cross-language support including not only Java but also .NET and Python.
  prefs: []
  type: TYPE_NORMAL
- en: In this database type, there are new concepts to be aware of such as bucket
    and key-value pair. Although not possible for every single aspect, for those who
    are used to the traditional SQL world, there are correlations between both worlds’
    concepts that can facilitate their understanding.
  prefs: []
  type: TYPE_NORMAL
- en: To wrap up, a key-value NoSQL is a database that can store data as a collection
    of key-value pairs and is optimized for storing large amounts of data and efficiently
    retrieving it by key. It is known for being easy to use and understand, plus for
    its horizontal scalability, which makes it a good choice for applications that
    require high levels of read and write throughput.
  prefs: []
  type: TYPE_NORMAL
- en: Even though there are multiple benefits, key-value databases can be less flexible
    than other types of NoSQL databases when it comes to data modeling and querying.
    They do not support complex queries and do not have a rich data model, and can
    therefore be less suitable for applications that require sophisticated data manipulation.
    Additionally, key-value databases do not support transactions, which can be a
    limitation for some use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s take a look at the document database type and its characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL database types – document
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The NoSQL document storage type is designed to store, retrieve, and manage
    documents with a minimally defined structure, such as the XML and JSON formats.
    A document without a predefined structure, in other words, is a data model that
    may be composed of numerous fields with different kinds of data, including documents
    inside other documents. A data structure would look like JSON, as shown in the
    following code structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding JSON structure shows a document that stores data about a mythological
    persona named Diana. This same structure holds different data types such as strings,
    numbers, lists, and other complex objects. Like other types, this is a flexible
    option to store data in a hierarchical format, *with no need to specify a schema
    upfront*. Specifically, the document NoSQL database option can be easy to use
    and require minimal setup, which makes it a good choice for rapid prototyping
    of quickly developing applications. On the other hand, it generally lacks transaction
    support and doesn’t offer as complex querying capabilities as the complex multi-table
    join capabilities offered by traditional relational databases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon SimpleDB**, **Apache CouchDB**, and **MongoDB** are all popular NoSQL
    document-type storage solutions. The former is a fully managed database service
    offered by Amazon Web Services, while the latter are both open source solutions.
    All three options offer APIs for interacting with the database using Java.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having learned more about key-value and document types, let’s move on to the
    next: the wide-column database.'
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL database types – wide-column/column-family
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The wide-column (also known as column-family) model became popular with the
    BigTable paper by Google for being a distributed storage system for structured
    data, and for being projected with the ability to offer high scalability and large
    storage volume capacity. These databases are optimized for storing large amounts
    of structured, semi-structured, and unstructured data with a flexible schema,
    and for supporting high levels of concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: 'As opposed to other types, data in this type of database is stored in columns
    rather than in rows, allowing a more flexible and scalable data model. The data
    stored in a single column family can be of different types and structures, as
    represented in *Figure 2**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – NoSQL column-family type representation](img/B19375_02_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – NoSQL column-family type representation
  prefs: []
  type: TYPE_NORMAL
- en: When compared to other NoSQL types, these data can be more difficult to query
    as they’re not stored in the traditional row-based format. Also, the increased
    schema flexibility represents an increased complexity of tasks such as data model
    designing and data management.
  prefs: []
  type: TYPE_NORMAL
- en: In regards to engine options, **HBase** and **Cassandra** are both open source,
    distributed, wide-column NoSQL databases, designed with a focus on handling large
    amounts of data. **Scylla** is also a distributed wide-column database but is
    designed as a drop-in replacement for Cassandra and optimized for performance.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, wide-column NoSQL databases are powerful tools for storing and
    managing large amounts of data with a flexible schema, and are very well suited
    for distributed applications that demand high availability and horizontal scaling
    storage. However, they can be more difficult to query compared to other NoSQL
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move forward to the next section, we will discuss the last type of
    NoSQL database, which can be particularly useful to complement wide-column databases
    in certain scenarios: the graph database.'
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL database types – graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The graph NoSQL database type is optimized for storing and querying data with
    complex relationships. In this approach, data is represented as a graph where
    the nodes represent entities and the edges represent the relationships between
    those entities. Observe in *Figure 2**.3* the graph structures being used for
    semantic queries, and the data representation through nodes, edges, and properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – NoSQL graph type representation](img/B19375_02_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – NoSQL graph type representation
  prefs: []
  type: TYPE_NORMAL
- en: 'The key concepts to be aware of when developing applications that will work
    with a graph database are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertex**/**Vertice**: Also known as a **node** in a graph. It stores the
    entity or object data like a table does in traditional relational databases, or
    like a document does in a document-type NoSQL database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edge**: An element to establish the relationship between two vertices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Property**: A key-value pair that holds metadata about an edge or vertex
    element of a graph.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graph**: A collection of vertices and edges representing the relationships
    between entities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a graph, the edge can be either directed or undirected and a direction on
    the relationship between nodes can exist and, in fact, is an essential concept
    in a graph structure. If considering the real world, we could compare it to Hollywood
    stars, for example, where there are people who know an actor but the actor is
    not aware of all their fans. This association’s metadata is stored as part of
    the edge’s direction (relationship) in the graph. In *Figure 2**.4*, notice the
    association direction and type are clearly defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – NoSQL graph type data model direction representation](img/B19375_02_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – NoSQL graph type data model direction representation
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.4* shows a directional association going from the vertex **Poliana**
    to the vertex **Hephaestus**. The association also has its own data, such as **when**
    and **where** in this case. The direction is especially relevant when querying
    the graph, as you can’t query from **Hephaestus** to **Poliana** – only the other
    way around.'
  prefs: []
  type: TYPE_NORMAL
- en: Graph NoSQL database solutions can fit well in scenarios that require fast querying
    of highly interconnected data, such as social networks, recommendation engines,
    and fraud detection systems. Even though they can store and retrieve large amounts
    of data, that is not always true in the case of large amounts of structured and
    unstructured data with flexible schema, where the column-family type would be
    a better fit. Also, complex querying may require traversing the graph in order
    to find a requested piece of data.
  prefs: []
  type: TYPE_NORMAL
- en: There are several graph database engines to choose from, including **Neo4j**,
    **InfoGrid**, **Sones**, and **HyperGraphDB**. Each of these engines offers its
    own unique set of features and capabilities, and the right choice will depend
    on the specific needs of the application.
  prefs: []
  type: TYPE_NORMAL
- en: We have explored relational databases and NoSQL databases, the two main database
    storage paradigms in use today for storing and querying structured data using
    a fixed schema, and for storing and querying large amounts of structured/semi-structured/unstructured
    data with flexible schema, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving to the next section, here’s a final tip to help you correlate
    concepts with which you are already familiar with the ones presented so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – How concepts can be related between different database flavors
    for learning purposes](img/B19375_02_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – How concepts can be related between different database flavors
    for learning purposes
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next and last section of this chapter, we’ll check through a newer category
    of databases: the NewSQL databases.'
  prefs: []
  type: TYPE_NORMAL
- en: NewSQL databases – trying to get the best out of both worlds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NewSQL databases are a hybrid database type that combines the best features
    of both relational and NoSQL worlds, offering the ability to store and query structured
    data with a fixed schema while also providing the scalability and flexibility
    characteristics of NoSQL databases. NewSQL is seen as a way to address the limitations
    of both relational and NoSQL paradigms and provide a more flexible and scalable
    solution for modern applications. NewSQL is a database category that aims to unite
    the best features of both SQL and NoSQL worlds. We have learned two models of
    consistency: ACID, provided by relational databases, and BASE, by NoSQL. NewSQL
    seeks to offer a combination of horizontal scalability while maintaining the guarantees
    of the ACID (atomicity, consistency, isolation, and durability) principles. In
    other words, it tries to deliver on the guarantees of SQL with the high scalability,
    flexibility, and performance of NoSQL. Another positive aspect is the ability
    to use SQL as the querying language.'
  prefs: []
  type: TYPE_NORMAL
- en: NewSQL looks like a promising solution, and we can observe (at the time of writing)
    several relevant companies offering enterprise-grade solutions to the market.
    It’s worth mentioning the involvement of companies that hold immense know-how
    of both developer and operational needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of NewSQL databases are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VoltDB**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ClustrixDB**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CockroachDB**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that the NewSQL technology landscape is anything but homogenous, and
    each solution brings its own advantages and drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: NewSQL uses SQL but usually does not support 100% of it.
  prefs: []
  type: TYPE_NORMAL
- en: Even though this paradigm gives the impression that it may address and solve
    once and for all the problem presented by the CAP theorem, we should warn you,
    it does not. Also, generally, hybrid options bring the best and the *worst* of
    both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Database options come in several flavors, and it is crucial to understand the
    trade-offs with each type. Each data target has specific behaviors, such as SQL
    having a standard, maturity, several tools, and know-how in its favor. Still,
    it is pretty hard to work on horizontal scalability.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL was designed to improve horizontal scalability; however, this came at
    the cost of less consistency than relational databases are known for.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, NewSQL tries to merge both worlds and bring the benefits of both, but
    it lacks in both areas.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll cover more about the architectures and strategies
    of technologies and how to handle them.
  prefs: []
  type: TYPE_NORMAL
