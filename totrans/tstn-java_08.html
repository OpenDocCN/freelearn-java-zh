<html><head></head><body>
		<div id="_idContainer053">
			<h1 id="_idParaDest-157" class="chapter-number"><a id="_idTextAnchor172"/>8</h1>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor173"/>Arrays, Collections, Generics, Functions, and Streams</h1>
			<p>Up until now, we have used variables to represent a single instance of a primitive data type and a reference data type. More frequently encountered in the real world, though, is the need to work with and process multiple data elements. In this chapter, we will look at the various options available for managing multiple elements. In examining the options in Java for this purpose, we will see how we can enhance <span class="No-Break">type safety.</span></p>
			<p>To process multiple elements more efficiently, we will examine streams—a replacement for traditional loops when coupled <span class="No-Break">with functions.</span></p>
			<p>We will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Understanding the array <span class="No-Break">data structure</span></li>
				<li>Understanding the <span class="No-Break">Collections Framework</span></li>
				<li>Using sequential implementations <span class="No-Break">and interfaces</span></li>
				<li>Understanding Generics in the <span class="No-Break">Collections Framework</span></li>
				<li>Using sequential implementations and interfaces <span class="No-Break">with Generics</span></li>
				<li>Understanding Collections Framework <span class="No-Break">map structures</span></li>
				<li>Understanding functions <span class="No-Break">in Java</span></li>
				<li>Using streams <span class="No-Break">in collections</span></li>
			</ul>
			<p>Upon completion of this chapter, you will be able to work with multiple instances of data as an array or collection and apply algorithms available in the <span class="No-Break"><strong class="source-inline">Stream</strong></span><span class="No-Break"> library.</span></p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor174"/>Technical requirements</h1>
			<p>Here are the tools required to run the examples in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Java <span class="No-Break">17 installed</span></li>
				<li><span class="No-Break">Text editor</span></li>
				<li>Maven 3.8.6 or a newer <span class="No-Break">version installed</span></li>
			</ul>
			<p>The sample code for this chapter is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter08"><span class="No-Break">https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter08</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor175"/>Understanding the array data structure</h1>
			<p>As with most<a id="_idIndexMarker571"/> languages, Java has a built-in array data structure and does not require any imports or external libraries. As such, the array behaves as most arrays in other languages. The only difference is that to instantiate an array, you need the <strong class="source-inline">new</strong> keyword. Here are the two ways to declare an array of 10 elements of <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
        int[] quantities01 = new int[10];
        int quantities02[] = new int[10];</pre>
			<p>The difference is where the empty square brackets are placed on the left-hand side. Placing them after the type is considered the Java way. Placing it after the identifier is thought of as the C-language way. Either syntax <span class="No-Break">is fine.</span></p>
			<p>In most programming languages, numbers can be either ordinal or cardinal. The length of the array as declared when we instantiate it is a cardinal—or count—number. In the examples so far, the length has been 10. An ordinal number represents the position in a structure such as in an array. Ordinals begin with zero in most programming languages. When we declare an array of cardinal length 10, the ordinal positions range from 0 to 9 and not 1 <span class="No-Break">to 10.</span></p>
			<p>Arrays are of a fixed length; they cannot be expanded or contracted. Each position in an array is ready for use. You can assign a value to the last position before assigning one to the <span class="No-Break">first position.</span></p>
			<p>You can defer instantiating an array, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
int[] quantities01;
…
quantities01 = new int[10];</pre>
			<p>Arrays store the values of an array in a contiguous block of memory. This tells us that the array will be 10 elements times 4 bytes per <strong class="source-inline">int</strong> to consume 40 bytes plus the necessary overhead for an object in Java. The length of the array is part of <span class="No-Break">this overhead.</span></p>
			<p>An array of objects consists of an array of references. For example, you could create an array of four strings, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
String[] stuff = new String[4];</pre>
			<p>In this case, the array will consume 4 bytes for the reference to each <strong class="source-inline">String</strong> object as well as the usual array object overhead. The strings themselves are stored in memory as the <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>) decides <a id="_idIndexMarker572"/>and are not necessarily contiguous. The value of each reference will be <strong class="source-inline">null</strong> until you assign a valid reference to <span class="No-Break">the array:</span></p>
			<pre class="source-code">
String myThing = "Moose";
stuff[0] = myThing;</pre>
			<p>When using <a id="_idIndexMarker573"/>references in arrays, what we are storing in the data structure is the reference and not the object. Only primitives can be stored directly in <span class="No-Break">an array.</span></p>
			<p>From here, we read and write to the array using the subscript. To get the length of the array, we use the final constant <span class="No-Break">variable, </span><span class="No-Break"><strong class="source-inline">length</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
        System.out.printf("Length: %d%n", stuff.length);</pre>
			<p>To visit every element in an array with a <strong class="source-inline">for</strong> loop, you would use <span class="No-Break">the following:</span></p>
			<pre class="source-code">
        stuff[0] = "Java";
        stuff[1] = "Python";
        stuff[2] = "JavaScript";
        stuff[3] = "C#";
        for (int i = 0; i &lt; stuff.length; ++i) {
            System.out.printf("Stuff %d = %s%n", i, stuff[i]);
        }</pre>
			<p>Java also has an enhanced <strong class="source-inline">for</strong> loop for visiting every element in an array. The subscript value is no <span class="No-Break">longer available:</span></p>
			<pre class="source-code">
for(String s : stuff) {
    System.out.printf("Stuff %s%n", s);
}</pre>
			<p>One last thing to point out: Java has a library for performing a range of operations on an array, called the <strong class="source-inline">Arrays</strong> library. This class contains static methods for sorting and searching as well as creating a list, one of the collections, from an array. We will see an example of turning an array into a list in the later section, <em class="italic">Using streams </em><span class="No-Break"><em class="italic">in collections</em></span><span class="No-Break">.</span></p>
			<p>You should already be comfortable with working with an array. You can read and write to any valid <a id="_idIndexMarker574"/>subscripted element. If you use an invalid subscript that is out of range, Java will throw an <strong class="source-inline">ArrayIndexOutOfBoundsException</strong>. Now, let’s look at the <span class="No-Break">Collections Framewo<a id="_idTextAnchor176"/>rk.</span></p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor177"/>Understanding the Collections Framework</h1>
			<p>Once an array is <a id="_idIndexMarker575"/>instantiated, it cannot have its length increased or decreased. This means that you must know the exact number of elements you will need before you instantiate the array. You can use a variable to declare the array but once created it cannot be resized. Have a look at the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
        int numberOfCats = 6;
        int[] cats = new int[numberOfCats];</pre>
			<p>This is where collections come in. These are dynamic data structures that can increase in size as elements are added. You can also remove elements, although reducing the size is not always available, and if it can be reduced, then you must call an <span class="No-Break">appropriate method.</span></p>
			<p>The Collections Framework is divided into implementations and interfaces. An implementation may support more than one interface. While an implementation can have a large selection of methods, the use of an interface allows you to restrict what you can do with <span class="No-Break">a collection.</span></p>
			<p>The Collections Framework classes fall into two categories. There are sequential collections that preserve the order in which elements are added. Then, there are map collections where elements are stored in pairs of data. The first is typically a field of an object called the key, while the second is a reference to the object itself called the value. These collections organize themselves based on <span class="No-Break">the key.</span></p>
			<p>The default data type that all members of these classes manage is <strong class="source-inline">Object</strong>. This means that you can store any object in a collection as all classes extend <strong class="source-inline">Object</strong>, and polymorphism allows you to use a subclass wherever a superclass is called for. The problem with this approach is that you can conceivably have a collection of apples and oranges. Until the<a id="_idIndexMarker576"/> introduction of Generics to the language, it was the responsibility of the developer to avoid <span class="No-Break">mixing types.</span></p>
			<p>Let’s look more closely at <span class="No-Break">sequential struct<a id="_idTextAnchor178"/>ures.</span></p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor179"/>Using sequential implementations and interfaces</h1>
			<p>Let’s begin with <a id="_idIndexMarker577"/>the implementation. These are classes that manage the data in many ways. They are <strong class="source-inline">ArrayList</strong>, <strong class="source-inline">LinkedList</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">ArrayDeque</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor180"/>ArrayList</h2>
			<p>This is a <a id="_idIndexMarker578"/>dynamic<a id="_idIndexMarker579"/> array-like structure. As a class, you must use methods rather than subscripts to access specific elements. You add elements at the end of the list. Once you add an element, you can read from it, write to it, search for a specific value, and remove elements from a specific position or that match a <span class="No-Break">specific value.</span></p>
			<p>You can instantiate an <strong class="source-inline">ArrayList</strong> class with or without an initial capacity. If you do not specify a capacity, then it will default to a capacity of 10. If you know in advance how many elements you will need, then include that value when you instantiate the <strong class="source-inline">ArrayList</strong> class. The auto-resizing of an <strong class="source-inline">ArrayList</strong> class entails overhead that you can avoid if you know the precise size. In either case, you cannot access elements until you first add an element. As you add elements, the size increases. You can access any element that you add but you cannot access any positions between the last element added and the<a id="_idIndexMarker580"/> unused <a id="_idIndexMarker581"/>capacity that <span class="No-Break">follows it.</span></p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor181"/>LinkedList</h2>
			<p>This structure<a id="_idIndexMarker582"/> stores data in node objects, with each node<a id="_idIndexMarker583"/> knowing what comes before and after it. On the surface, it would seem to be quite efficient as you create nodes as needed. The major drawback to a linked list is that it does not support random access. In <strong class="source-inline">ArrayList</strong>, you can access any element such as an array by using the integer that represents its position using a method rather than square brackets. This access is direct. In a <strong class="source-inline">LinkedList</strong> class, the only elements you can access directly are the first and last elements. To access any other element, you must start at the beginning or end and then follow the forward or backward references to the subsequent nodes. This makes access to elements far slower than <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">ArrayList</strong></span><span class="No-Break">.</span></p>
			<p>I instruct students about linked lists because they make for nice blackboard diagrams. The <strong class="source-inline">Map</strong> structures that we will look at shortly are based on variants of the linked list. Let me end with a tweet from Joshua Bloch concerning the Java <strong class="source-inline">LinkedList</strong> class <span class="No-Break">he wrote:</span></p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/B19088_08_01.jpg" alt="Figure 8.1 – Famous LinkedList tweet"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Famous LinkedList tweet</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor182"/>ArrayDeque</h2>
			<p>The <strong class="source-inline">ArrayDeque</strong> class<a id="_idIndexMarker584"/> is like <strong class="source-inline">ArrayList</strong> in that it is a dynamic<a id="_idIndexMarker585"/> structure that stores elements in an array-like structure. Unlike <strong class="source-inline">ArrayList</strong>, it does not support direct access. Instead, it is optimized for inserting or removing elements at the beginning (<strong class="bold">FIFO</strong>) or at the end of the structure (<strong class="bold">LIFO</strong>). This leads to the data structures defined by the <strong class="source-inline">Deque</strong>, <strong class="source-inline">Queue</strong>, and <strong class="source-inline">Stack</strong> interfaces. Prior to the introduction of the <strong class="source-inline">ArrayDeque</strong> class in Java 1.6, you used a <strong class="source-inline">LinkedList</strong> class as the implementation for these interfaces. The <strong class="source-inline">ArrayDeque</strong> class outperforms the <span class="No-Break"><strong class="source-inline">LinkedList</strong></span><span class="No-Break"> class.</span></p>
			<p>This is not a complete list. For example, there is a <strong class="source-inline">Stack</strong> class, but using the <strong class="source-inline">ArrayDeque</strong> class with a <strong class="source-inline">Deque</strong> interface will outperform the <strong class="source-inline">Stack</strong> class. A second issue relates to thread safety. These three implementations are not thread-safe. There are specialized versions of the implementations in the framework, specifically for when threads must share access to a <span class="No-Break">data structure.</span></p>
			<p>You can implement any of these classes, but it is considered a poor choice. Each of these implementations has numerous methods to support the use of the structure in numerous ways. When you use a Java collections class, you want to use the smallest interface for what<a id="_idIndexMarker586"/> you are trying to accomplish rather than allowing<a id="_idIndexMarker587"/> access to every method in the implementation. Let’s look at <span class="No-Break">these interfaces.</span></p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor183"/>The Collection interface</h2>
			<p>Here is a <a id="_idIndexMarker588"/>diagram <a id="_idIndexMarker589"/>of the most <span class="No-Break">common interfaces:</span></p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/B19088_08_02.jpg" alt="Figure 8.2 – The Collection interfaces"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – The Collection interfaces</p>
			<p>Each of the boxes represents an interface that a collection implementation may or may not support. <strong class="source-inline">Collection</strong> is the super interface. Any class that implements the interfaces below it must also <span class="No-Break">implement </span><span class="No-Break"><strong class="source-inline">Collection</strong></span><span class="No-Break">.</span></p>
			<p>The most common interface is <strong class="source-inline">List</strong>. This is the closest to an array. <strong class="source-inline">Set</strong> and <strong class="source-inline">SortedSet</strong> are interfaces that ensure that an element cannot appear more than once. <strong class="source-inline">Queue</strong> is a FIFO structure. You can only add elements to the end of the structure, and you can only remove them from the front of the structure. <strong class="source-inline">Deque</strong> is a structure that supports LIFO. What is unique about <strong class="source-inline">Deque</strong> is that you add or remove from either end. Neither <strong class="source-inline">Queue</strong> nor <strong class="source-inline">Deque</strong> permit <a id="_idIndexMarker590"/>access <span class="No-Break">by</span><span class="No-Break"><a id="_idIndexMarker591"/></span><span class="No-Break"> subscript.</span></p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor184"/>How to declare a collection</h2>
			<p>As we have already <a id="_idIndexMarker592"/>discussed in <a href="B19088_06.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Methods, Interfaces, Records, and Their Relationships</em>, you use an interface class to define which methods the class must implement. The most widely used interface for sequential collections is the <strong class="source-inline">List</strong>. We can now declare a data structure that can only use the methods shown in the <strong class="source-inline">List</strong> interface and <span class="No-Break">no others:</span></p>
			<pre class="source-code">
 List moreStuff = new ArrayList();</pre>
			<p>Before we look at more interfaces, it is time to look at the concept of Generics and how they relate to the collections interface. We need to look at this now because while the previous line of code is executable, rarely will a Java developer write it <span class="No-Break">this way.</span></p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor185"/>Understanding Generics in the Collections Framework </h1>
			<p>As pointed out, the <a id="_idIndexMarker593"/>default classes in the Collections<a id="_idIndexMarker594"/> framework were designed to manage only references to objects of type <strong class="source-inline">Object</strong>. Polymorphism then permitted the use of any subclass in an implementation of any of these classes. The problem with this approach is that it is not type-safe. Look at this <span class="No-Break">code fragment:</span></p>
			<pre class="source-code">
        int numberOfApples = 9;
        String orange = "Valencia";
        
        List stuff = new ArrayList();
        stuff.add(numberOfApples);
        stuff.add(orange);
        
        System.out.printf("Stuff: %s%n", stuff);</pre>
			<p>This code begins by declaring two variables. The first is an <strong class="source-inline">int</strong> type with the <strong class="source-inline">numberOfApples</strong> identifier. Collections cannot contain primitive data types, so an object of type <strong class="source-inline">Integer</strong> is required if the primitive is an <strong class="source-inline">int</strong> type. Java will perform this conversion from primitive to object for you. The second line creates a <span class="No-Break"><strong class="source-inline">String</strong></span><span class="No-Break"> object.</span></p>
			<p>Next is the instantiation of an object of type <strong class="source-inline">ArrayList</strong> but whose interface is restricted to just what the <strong class="source-inline">List</strong> interface class permits. Now, we can add the <strong class="source-inline">Integer</strong> and the <strong class="source-inline">String</strong> objects to the collection. The last line displays the contents of the <strong class="source-inline">List</strong> as its <strong class="source-inline">toString()</strong> method creates a <strong class="source-inline">String</strong> object of all members. This leads to the expression that you should not mix apples and oranges. Collections must be of a single type. While the default syntax for Collections does not restrict what can be added, the use <a id="_idIndexMarker595"/>of<a id="_idIndexMarker596"/> Generic <span class="No-Break">notation will.</span></p>
			<p>Let’s look at a new variation of the <span class="No-Break">previous code:</span></p>
			<pre class="source-code">
        int numberOfApples = 9;
        String orange1 = "Valencia";
        String orange2 = "Navel";
                
        List&lt;String&gt; stuff = new ArrayList&lt;&gt;();
        stuff.add(orange1);
        stuff.add(orange2);
        stuff.add(numberOfApples);
        
        System.out.printf("Stuff: %s%n", stuff);</pre>
			<p>In this example, we kept our <strong class="source-inline">int</strong> type and then created two strings. The declaration of the <strong class="source-inline">List</strong> now includes angle brackets. Within the brackets is the class type you want to restrict the <strong class="source-inline">List</strong> to contain. In this example, the class is <strong class="source-inline">String</strong>. While we must show the class type on the left-hand side, we can just have empty angle brackets on the right side as there is never a situation where these two class types could <span class="No-Break">be different.</span></p>
			<p>The next lines add the objects to the <strong class="source-inline">List</strong>. The first two will work, but the third, where we are trying to add an object of type <strong class="source-inline">Integer</strong>, will generate <span class="No-Break">an exception:</span></p>
			<pre class="source-code">
<strong class="bold">java.lang.RuntimeException: Uncompilable code - incompatible types: java.lang.Integer cannot be converted to java.lang.String</strong></pre>
			<p>Java will no longer allow you to mix apples and oranges. This test for ensuring all objects added to a collection are the same type only occurs at compile time. This means it is possible to add a different object type if this operation only occurs at runtime. This can occur when<a id="_idIndexMarker597"/> multiple <a id="_idIndexMarker598"/>processes are running in the JVM, and one process calls a method in another process. </p>
			<p>We will now return to the collections and only use Generic syntax from here <span class="No-Break">on in.</span></p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor186"/>Using sequential implementations and interfaces with Generics</h1>
			<p>As we have <a id="_idIndexMarker599"/>just seen, the<a id="_idIndexMarker600"/> best practice for creating a <strong class="source-inline">List</strong> will <span class="No-Break">be this:</span></p>
			<pre class="source-code">
List&lt;String&gt; moreStuff = new ArrayList&lt;&gt;();</pre>
			<p>Any valid class type can be used. Once we have elements in our collection, we can access them with the <strong class="source-inline">get</strong> method and <span class="No-Break">the subscript:</span></p>
			<pre class="source-code">
        String orange1 = "Valencia";
        String orange2 = "Navel";
        
        List&lt;String&gt; stuff = new ArrayList&lt;&gt;();
        stuff.add(orange1);
        stuff.add(orange2);
        
        System.out.printf("Stuff: %s%n", stuff.get(0));
        System.out.printf("Stuff: %s%n", stuff.get(1));</pre>
			<p>In the last two lines, we are referring to specific positions in the list. To change the object stored in a specific position, we use the <span class="No-Break"><strong class="source-inline">set</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
        stuff.set(0, "Blood Orange");</pre>
			<p>The interfaces and the implementation classes all support methods that allow you to determine if a specific object is contained in the collections. For this reason, you must override the <strong class="source-inline">equals</strong> method inherited from <strong class="source-inline">Object</strong>. Certain collection methods require the hash value, so your classes must have a <span class="No-Break"><strong class="source-inline">hashCode</strong></span><span class="No-Break"> method.</span></p>
			<p>You can also sort collections. To do this, the class type of the objects you are storing must implement the <strong class="source-inline">Comparable</strong> interface. This interface requires you to write just one method named <strong class="source-inline">compareTo</strong> that returns a negative number, zero, or a positive number. Here is <a id="_idIndexMarker601"/>a <a id="_idIndexMarker602"/>fragment of a class that <span class="No-Break">implements </span><span class="No-Break"><strong class="source-inline">compareTo</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class ComparableClass implements 
                     Comparable&lt;ComparableClass&gt;{
    private final int value;
    public ComparableClass(int initialValue) {
        value = initialValue;
    }
    @Override
    public int compareTo(ComparableClass o) {
        return value – o.value;        
    }
}</pre>
			<p>This class has only one field that is initialized by the constructor. It implements the <strong class="source-inline">Comparable</strong> interface using Generic notation to indicate that we can only compare this object to an object of the <span class="No-Break">same class.</span></p>
			<p>The <strong class="source-inline">compareTo</strong> method, required because we are implementing the <strong class="source-inline">Comparable</strong> interface, <span class="No-Break">must return:</span></p>
			<ul>
				<li>A positive integer if the value of the current object we are comparing is greater than the value of the object that is being <span class="No-Break">compared to</span></li>
				<li>The value 0 if the value of the current object we are comparing is equal to the value of the object that is being <span class="No-Break">compared to</span></li>
				<li>A negative integer if the value of the current object we are comparing is less than the value of the object that is being <span class="No-Break">compared to</span></li>
			</ul>
			<p>You may wonder how we can access the value of <strong class="source-inline">ComparableClass</strong> that is passed to <strong class="source-inline">compareTo</strong> using dot notation when the field is private. This is possible because Java permits objects of the same class to access private members of another instance of this same class. Here is <a id="_idIndexMarker603"/>the <a id="_idIndexMarker604"/>class that <span class="No-Break">tests this:</span></p>
			<pre class="source-code">
public class ComparableTest {
    private final ComparableClass comparable01;
    private final ComparableClass comparable02;
    
    public ComparableTest(int value1, int value2) {
        comparable01 = new ComparableClass(value1);
        comparable02 = new ComparableClass(value2);
    }
    public void perform() {
        System.out.printf("comparable01 to comparable02 %d%n", 
                comparable01.compareTo(comparable02));
        System.out.printf("comparable02 to comparable01 %d%n", 
                comparable02.compareTo(comparable01));
    }
    public static void main(String[] args) {
        ComparableTest examples = new ComparableTest(12, 2);
        examples.perform();
    }
}</pre>
			<p>In the <strong class="source-inline">perform</strong> method, we are displaying the result of calling the <strong class="source-inline">compareTo</strong> method. Let’s now create a <strong class="source-inline">List</strong> of objects and then sort the list. There is a small modification to <strong class="source-inline">ComparableClass</strong>. A method to return the value stored in the class has <span class="No-Break">been added:</span></p>
			<pre class="source-code">
    public int getValue() {
        return value;
    }</pre>
			<p>Now, we have a class that creates 10 objects of <strong class="source-inline">ComparableClass</strong>, places them in a <strong class="source-inline">List</strong>, and sorts <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">List</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class ComparableSorting {
    private final List&lt;ComparableClass&gt; comparableClasses;</pre>
			<p>Here is the<a id="_idIndexMarker605"/> constructor <a id="_idIndexMarker606"/>that instantiates an object of type <strong class="source-inline">ArrayList</strong> that will be restricted to use only methods from the <span class="No-Break"><strong class="source-inline">List</strong></span><span class="No-Break"> interface:</span></p>
			<pre class="source-code">
    public ComparableSorting() {
        comparableClasses = new ArrayList&lt;&gt;();
    }</pre>
			<p>Note that the angle brackets after <strong class="source-inline">ArrayList</strong> are empty. When we declared <strong class="source-inline">comparableClasses</strong>, we declared the <strong class="source-inline">List</strong> as containing <strong class="source-inline">ComparableClass</strong> objects. There is no need to <span class="No-Break">repeat this.</span></p>
			<p>This next method creates 10 instances of <strong class="source-inline">ComparableClass</strong>, initializing them with a random integer as they are added to the <strong class="source-inline">List</strong>. Each value is also displayed on the console so that we can see the original values as they <span class="No-Break">are assigned:</span></p>
			<pre class="source-code">
    private void fillList() {
        Random rand = new Random();
        int upperBound = 25;
        System.out.printf("Unsorted:%n");
        for(int i = 0; i &lt; 10; ++i) {
            comparableClasses.add(
                new ComparableClass(rand.nextInt(upperBound)));
        }
        System.out.printf("%n");
    }</pre>
			<p>This method displays the values in each object in <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">List</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    private void displayList() {
        for(int i = 0; i &lt; 10; ++i) {
            System.out.printf(
                "%s ", comparableClasses.get(i).getValue());
        }
        System.out.printf("%n");
    }</pre>
			<p>Now, let’s fill the list, display it, sort it, and display <span class="No-Break">it again:</span></p>
			<pre class="source-code">
    public void perform() {
        fillList();
        displayList();</pre>
			<p>The <strong class="source-inline">Collections</strong> class <a id="_idIndexMarker607"/>contains <a id="_idIndexMarker608"/>a family of static methods that can be applied to an object that implements the <strong class="source-inline">Collection</strong> interface. One is the <strong class="source-inline">Collections.sort</strong> method. It alters the input rather than returning a <span class="No-Break">new value:</span></p>
			<pre class="source-code">
        Collections.sort(comparableClasses);
        displayList();
    }    
    public static void main(String[] args) {
        ComparableSorting examples = new ComparableSorting();
        examples.perform();
    }
}</pre>
			<p>What we have<a id="_idIndexMarker609"/> seen <a id="_idIndexMarker610"/>so far is how sequential collections can be used. The need for special interfaces such as <strong class="source-inline">Comparable</strong> was also highlighted. Let’s now look at <span class="No-Break">ordered collections.</span></p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor187"/>Understanding Collections Framework map structures</h1>
			<p>The second family of<a id="_idIndexMarker611"/> collections is the map family. A map is a data structure in which you add elements to a map with a pair of values. The first value is the key. This is a reference to an object that, depending on the type of map, either implements the <strong class="source-inline">Comparable</strong> interface—as we saw in the previous section—or overrides the <strong class="source-inline">hashCode</strong> and <strong class="source-inline">equals</strong> methods. If the key is a primitive, then we declare it as its wrapper class, and Java will manage the necessary conversion to and from the primitive. The second is the value—a reference to the object you are storing in the map. This class does not need to implement the <span class="No-Break"><strong class="source-inline">Comparable</strong></span><span class="No-Break"> interface.</span></p>
			<p>There are three map implementations in Java, which we will <span class="No-Break">now cover.</span></p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor188"/>HashMap</h2>
			<p>Of all the data<a id="_idIndexMarker612"/> types available in Java and most <a id="_idIndexMarker613"/>other languages, the fastest performing is the integer. The size of an integer is the same as the word size of the CPU. The JVM is a 32-bit or 4-word machine. Even 64-bit Java is just modeling a 32-bit machine. This is where the hash code <span class="No-Break">comes in.</span></p>
			<p>As with all map structures, entries are comprised of two components. The first is the key and the second is the value. What makes <strong class="source-inline">HashMap</strong> special is that the hash code of the key value determines where it will store the pair. The underlying structure is an array, and each position in the array is a bucket. Using arithmetic operations such as modulus, the subscript in the array can be determined from the hash code of the key. </p>
			<p>A hash code is not unique. This means that two or more keys may generate the same hash code. In this case, they will also want to use the same subscript, and the bucket becomes a single linked list of buckets. If the number of keys becomes greater than eight, then the linked list is converted into a balance binary tree. When searching for a key in a list, the <strong class="source-inline">equals</strong> method is used to test each bucket to find <span class="No-Break">the value.</span></p>
			<p>Use a hash map when you must collect data that you must be able to retrieve from the structure rapidly. There is no defined order. The first item you put in a hash map could be the seventh element in the array of buckets. This also means that the order of elements put into the structure cannot <span class="No-Break">be determined.</span></p>
			<p>To find a value in a <strong class="source-inline">HashMap</strong> object given a key, you can use the <strong class="source-inline">get</strong> method. This method takes the key as a parameter and returns the value if found or it returns <strong class="source-inline">null</strong> if not<a id="_idIndexMarker614"/> found. Let’s<a id="_idIndexMarker615"/> look at <span class="No-Break">an example.</span></p>
			<p>First, we create a <strong class="source-inline">HashMap</strong> object using the <span class="No-Break"><strong class="source-inline">Map</strong></span><span class="No-Break"> interface:</span></p>
			<pre class="source-code">
        Map&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();</pre>
			<p>Now, we can put data into the <strong class="source-inline">HashMap</strong> object using the <strong class="source-inline">put</strong> method that takes two parameters. These are the key and <span class="No-Break">the value:</span></p>
			<pre class="source-code">
        hashMap.put(6, 6);
        hashMap.put(5, 4);
        hashMap.put(4, 8);
        hashMap.put(3, 10);
        hashMap.put(2, 6);</pre>
			<p>These next two lines will retrieve the value associated with the key if the key exists. Otherwise, <strong class="source-inline">null</strong> <span class="No-Break">is returned:</span></p>
			<pre class="source-code">
        System.out.printf("%s%n",hashMap.get(4));
        System.out.printf("%s%n",hashMap.get(1));</pre>
			<p>There is no entry in the <strong class="source-inline">HashMap</strong> object that uses the integer 1 as a key, so it will print <span class="No-Break">out </span><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break">.</span></p>
			<p>To iterate or work with every element over the entire <strong class="source-inline">HashMap</strong> object, we need to first create a <strong class="source-inline">Set</strong> object from all the entries in the <span class="No-Break">hash map:</span></p>
			<pre class="source-code">
        Set s = hashMap.entrySet();</pre>
			<p>From the <strong class="source-inline">Set</strong> object, we create an <strong class="source-inline">Iterator</strong> object. An iterator allows us to access every element in the set in the order determined by <span class="No-Break">the keys:</span></p>
			<pre class="source-code">
        Iterator it = s.iterator();</pre>
			<p>The <strong class="source-inline">Iterator</strong> object’s <strong class="source-inline">hasNext</strong> method returns <strong class="source-inline">true</strong> if there is another element in the <strong class="source-inline">Set</strong> object; otherwise, it <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
        while (it.hasNext()) {</pre>
			<p>The <strong class="source-inline">Iterator</strong> object’s <strong class="source-inline">next</strong> method returns the <span class="No-Break">key/value pair:</span></p>
			<pre class="source-code">
            System.out.printf("%s%n",it.next());
        }</pre>
			<p>The output <a id="_idIndexMarker616"/>of<a id="_idIndexMarker617"/> this code will <span class="No-Break">be this:</span></p>
			<pre class="source-code">
8
null
2=6
3=10
4=8
5=4
6=6</pre>
			<p>Notice that the order of keys is not the same as the order they were put into the <span class="No-Break">hash map.</span></p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor189"/>LinkedHashMap</h2>
			<p>This structure is a <a id="_idIndexMarker618"/>variant of <strong class="source-inline">HashMap</strong>. Internally <a id="_idIndexMarker619"/>it operates just like <strong class="source-inline">HashMap</strong> but also includes a second data structure. This is a linked list that preserves the order in which data is put into <strong class="source-inline">LinkedHashMap</strong>. If the order of entry is not significant, use a <span class="No-Break"><strong class="source-inline">HashMap</strong></span><span class="No-Break"> structure.</span></p>
			<p>If we used <strong class="source-inline">LinkedHashMap</strong> in the previous example code, the only change we would make would be to use <strong class="source-inline">LinkedHashMap</strong> instead <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">HashMap</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
        Map&lt;Integer, Integer&gt; linkedHashMap = new              LinkedHashMap&lt;&gt;();
        linkedHashMap.put(6, 6);
        linkedHashMap.put(5, 4);
        linkedHashMap.put(4, 8);
        linkedHashMap.put(3, 10);
        linkedHashMap.put(2, 6);
        Set s = linkedHashMap.entrySet();
        Iterator it = s.iterator();
        System.out.printf("key=Value%n");
        while (it.hasNext()) {
            System.out.printf("%s%n",it.next());
        }</pre>
			<p>The <a id="_idIndexMarker620"/>output <a id="_idIndexMarker621"/>of this version will <span class="No-Break">be this:</span></p>
			<pre class="source-code">
<strong class="bold">6=6</strong>
<strong class="bold">5=4</strong>
<strong class="bold">4=8</strong>
<strong class="bold">3=10</strong>
<strong class="bold">2=6</strong></pre>
			<p>This is the same order that the key/value pairs were put into <span class="No-Break">the map.</span></p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor190"/>TreeMap</h2>
			<p>Unlike <strong class="source-inline">HashMap</strong> and <strong class="source-inline">LinkedHashMap</strong>, the underlying structure of <strong class="source-inline">TreeMap</strong> is a red-black<a id="_idIndexMarker622"/> binary <a id="_idIndexMarker623"/>tree. The key value is used as is and must implement the <strong class="source-inline">Comparable</strong> interface. You do not need the <strong class="source-inline">hashCode</strong> and <strong class="source-inline">equals</strong> methods, but it is good practice to include them. Here is the same code <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">TreeMap</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
        Map&lt;Integer, Integer&gt; treeMap = new TreeMap&lt;&gt;();</pre>
			<p>Here, the keys are not in any order. As integers, they do have a natural order that will determine where in the binary tree the key/value pairs <span class="No-Break">are placed:</span></p>
			<pre class="source-code">
        treeMap.put(6, 6);
        treeMap.put(4, 4);
        treeMap.put(3, 8);
        treeMap.put(2, 10);
        treeMap.put(5, 6);</pre>
			<p>When we use the iterator to display all the key/value pairs, they will be in the order based on <span class="No-Break">the key:</span></p>
			<pre class="source-code">
        Set s = treeMap.entrySet();
        Iterator it = s.iterator();
        while (it.hasNext()) {
            System.out.printf("%s%n",it.next());
        }</pre>
			<p>The output will <span class="No-Break">be this:</span></p>
			<pre class="source-code">
<strong class="bold">2=6</strong>
<strong class="bold">3=10</strong>
<strong class="bold">4=8</strong>
<strong class="bold">5=4</strong>
<strong class="bold">6=6</strong></pre>
			<p>While an array is frequently the go-to structure when you need multiple elements, consider that its interface is quite limited. Collections have a rich set of methods that expand what you <a id="_idIndexMarker624"/>can do in your code. Before we <a id="_idIndexMarker625"/>move on to functions, keep in mind the <span class="No-Break">following note.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The Collections shown in this chapter are not thread-safe. There are variants of each collection that <span class="No-Break">are thread-safe.</span></p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor191"/>Understanding functions in Java</h1>
			<p>In Java, we call <a id="_idIndexMarker626"/>units of code in a class a method. In C and C++, we call them functions. In JavaScript, we even use the <strong class="source-inline">keyword</strong> function. What sets Java apart from these other languages is that functions represent a different coding model than classes and their methods. There are functional rather than <strong class="bold">object-oriented</strong> (<strong class="bold">OO</strong>) languages, of<a id="_idIndexMarker627"/> which Haskell is one example. We are briefly examining functions because our next topic, streams, is based on the function rather than the <span class="No-Break">class model.</span></p>
			<p>Let’s look at some code that attached an event handler to a button in JavaFX. We will be looking at JavaFX in <a href="B19088_13.xhtml#_idTextAnchor254"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, <em class="italic">Desktop Graphical User Interface Coding with Swing and JavaFX</em>. Let’s begin by looking at what a functional <strong class="source-inline">EventHandler</strong> <span class="No-Break">interface is:</span></p>
			<pre class="source-code">
@FunctionalInterface
public interface EventHandler&lt;T extends Event&gt; extends     EventListener {
    void handle(T event);
}</pre>
			<p>This is the interface class for <strong class="source-inline">EventHandler</strong> that is part of JavaFX. The <strong class="source-inline">@FunctionalInterface</strong> annotation is optional but adds clarity to the purpose behind this interface. Functional interfaces can only have one abstract method. There is no implementation of this interface in JavaFX. You must supply the code for the <span class="No-Break"><strong class="source-inline">handle</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
        btn.setOnAction(new EventHandler&lt;ActionEvent&gt;() {
            @Override
            public void handle(ActionEvent event) {
                actionTarget.setText(userBean.toString());
            }
        });</pre>
			<p>This code registers an event handler for when a button is pressed. The handler must be an object of type <strong class="source-inline">EventHandler</strong> and must have a method named <strong class="source-inline">handle</strong>. The <strong class="source-inline">handle</strong> method is calling upon the <strong class="source-inline">toString</strong> method from <strong class="source-inline">userBean</strong> to return a string that will be assigned to a <strong class="source-inline">Text</strong> field <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">actionTarget</strong></span><span class="No-Break">.</span></p>
			<p>The first fragment demonstrates an anonymous inner class. It is anonymous because the reference is never assigned to an identifier. It can only be used in the method call. We do this in situations where the action to be performed is unique for just this button press. It cannot<a id="_idIndexMarker628"/> be <span class="No-Break">reused elsewhere:</span></p>
			<pre class="source-code">
        btn.setOnAction((ActionEvent event) -&gt; {
            actionTarget.setText(userBean.toString());
        });</pre>
			<p>This second fragment uses lambda notation. There is only one method, <strong class="source-inline">handle</strong>, in <strong class="source-inline">EventHandler</strong>. Therefore, we do not require additional decorations. <strong class="source-inline">(ActionEvent event)</strong> is the parameter that the <strong class="source-inline">handle</strong> method must receive. Our lambda is providing the code for the <strong class="source-inline">handle</strong> method that will execute when the button is pressed. While there is no limit to the number of lines of code that can be in a lambda, the best practice is no more than three, while just one line is preferred. But what if multiple lines need to be executed? This leads us to the third syntax for using <span class="No-Break">a function:</span></p>
			<pre class="source-code">
        btn.setOnAction(this::signInButtonHandler);</pre>
			<p>Functions in Java can be passed as a parameter to a method and can also be returned by a method. In this fragment, we are stating that the <strong class="source-inline">signInButtonHandler</strong> method will be invoked as if it were the <span class="No-Break"><strong class="source-inline">handle</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
private void signInButtonHandler(ActionEvent e) {
    actionTarget.setText(userBean.toString());
}</pre>
			<p>Here, this method is in the same file. Therefore, we are referring to it with <strong class="source-inline">this</strong> in <strong class="source-inline">setOnAction</strong>. It must have the same return value and parameters as the <span class="No-Break"><strong class="source-inline">handle</strong></span><span class="No-Break"> method.</span></p>
			<p>Functional programming<a id="_idIndexMarker629"/> helps to simplify our code. In any situation where we need a method whose action must be defined where it will be used, then using functions is the <span class="No-Break">best choice.</span></p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor192"/>Using streams in collections</h1>
			<p>Processing all data <a id="_idIndexMarker630"/>elements in a collection is a common action. Maybe <a id="_idIndexMarker631"/>you want to extract a subset of the collection based on a specific requirement. You might want to increase or decrease values or change the case of strings. This is where streams come in. All classes that implement the <strong class="source-inline">Collection</strong> interface have a stream method from which we can chain numerous stream methods. You cannot use streams directly on maps, but if you convert a map into a set, then you can <span class="No-Break">use streams.</span></p>
			<p>One important characteristic of stream methods is that they operate as pure functions. A pure function does not change the state of any fields in the class or any of the parameters passed to it. A stream method always returns a new stream. The original stream has not changed. Let’s see how <span class="No-Break">this works:</span></p>
			<pre class="source-code">
public record Employee(String employeeId, String firstName, 
         String lastName, String department, double salary) { }</pre>
			<p>Here, we have a record that contains fields that represent information on an employee. Now, let’s create a <strong class="source-inline">List</strong> of six employees. This information should come from a database, but for our purposes, we will create the <strong class="source-inline">List</strong> in the constructor of the <span class="No-Break"><strong class="source-inline">StreamsExample.java</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
public class StreamsExample {
    private List&lt;Employee&gt; staffList;
    public StreamsExample() {
        staffList = Arrays.asList(new Employee("A9", "Benson", 
                             "Bill", "Sales", 56000),
                new Employee("A1", "Clarkson", 
                             "Bill", "Sales", 56000),
                new Employee("A2", "Blunt", 
                             "Wesley", "HR", 56000),
                new Employee("A3", "Smith", 
                             "Joan", "Software", 56000),
                new Employee("A4", "Smith", 
                             "John", "Accounting", 56000),
                new Employee("A5", "Lance", 
                             "Gilbert", "Sales", 56000));
    }</pre>
			<p>This code demonstrates that an array, not a collection, can be created by listing the elements separated by commas when declared in a block. There are six <strong class="source-inline">Employee</strong> objects created, and by using the <strong class="source-inline">Arrays</strong> method <strong class="source-inline">asList</strong>, they are converted into a <strong class="source-inline">List</strong>-compatible <a id="_idIndexMarker632"/>structure. This is necessary as streams do not <a id="_idIndexMarker633"/>work on arrays. With our list complete, we can now apply the methods available to streams. Many of the stream methods behave in a similar manner to <span class="No-Break">SQL actions.</span></p>
			<p>With the list in place, let’s use some of the <span class="No-Break">stream methods:</span></p>
			<pre class="source-code">
List&lt;Employee&gt; filteredList = staffList.stream().
    filter( s -&gt; s.firstName().startsWith("J")).
    collect(Collectors.toList());</pre>
			<p>After we call upon <strong class="source-inline">stream()</strong>, we can apply the stream methods. The first one is <strong class="source-inline">filter</strong>. It requires a function that can return <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> depending on the code in the function. The function is expressed as a lambda that will receive a record object of type <strong class="source-inline">Employee</strong>. The code in the lambda retrieves the <strong class="source-inline">firstName</strong> string from the record and applies the <strong class="source-inline">startsWith</strong> string method to find names that begin <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">"J"</strong></span><span class="No-Break">.</span></p>
			<p>The result from <strong class="source-inline">filter</strong> is a new stream with only the objects that match the criteria. A stream must be converted back into a collection, and that is the role of the <strong class="source-inline">collect</strong> method. It takes as its argument the <strong class="source-inline">Collectors.toList()</strong> function from the <strong class="source-inline">Collectors</strong> class that will return a <span class="No-Break"><strong class="source-inline">List</strong></span><span class="No-Break"> object.</span></p>
			<p>One last example, and that is to print out the employee objects in order sorted by the <span class="No-Break"><strong class="source-inline">lastName</strong></span><span class="No-Break"> field:</span></p>
			<pre class="source-code">
staffList.stream().sorted((e1, e2) -&gt;  
    e1.lastName().compareTo(e2.lastName())).
    forEach(System.out::println);</pre>
			<p>This line of code uses the <strong class="source-inline">sorted</strong> stream function. It requires a function that determines the order of two objects based on a field. The field chosen is a <strong class="source-inline">String</strong> object, so it already has a <strong class="source-inline">compareTo</strong> method; otherwise, you will need to write a <strong class="source-inline">compareTo</strong> method. The lambda expression takes two parameters that are defined as <strong class="source-inline">String</strong> objects from the <strong class="source-inline">Record</strong>. This will produce a stream in sorted order that is then used by the <strong class="source-inline">forEach</strong> function. Rather than return a new <strong class="source-inline">List</strong> object, the <strong class="source-inline">forEach</strong> function receives a stream and passes each member of it to the <strong class="source-inline">println</strong> method <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">System.out</strong></span><span class="No-Break">.</span></p>
			<p>Modern Java<a id="_idIndexMarker634"/> programs<a id="_idIndexMarker635"/> rely heavily on streams. The alternative is to use iterators or <strong class="source-inline">for</strong> loops to access all elements. If you need to process all elements in a collection, look at streams before <span class="No-Break">anything else.</span></p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor193"/>Summary</h1>
			<p>While we appear to have covered a lot of topics in this chapter, you should recognize that they are all related. Whether you are retrieving records from a database or receiving user input from the keyboard, as soon as there is more than one item, you will need what has been presented here. We began with a basic array that is like a structure in other languages. From the array, we moved on to the Collections Framework. These are dynamic structures that can grow as needed. From the sequential to the map collections, Java provides us with a rich set <span class="No-Break">of choices.</span></p>
			<p>We looked at Generics next. Unlike an array that is declared as a specific type, raw collections can store any object without regard to what has already been stored. Using generic notation, we can tie a collection to a specific <span class="No-Break">data type.</span></p>
			<p>Starting with Java 8, functions became part of the Java language. While ordinary methods in a class can be used as a function, the use of lambdas allows us to define specific actions for a particular problem. The Stream library, available in sequential collections, simplifies processing the elements of <span class="No-Break">a collection.</span></p>
			<p>Next up, we will examine how we can document our code and record information on the operation of our program <span class="No-Break">in logs.</span></p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor194"/>Further reading</h1>
			<ul>
				<li><em class="italic">Guide to the java.util.Arrays </em><span class="No-Break"><em class="italic">class</em></span><span class="No-Break">: </span><a href="https://www.baeldung.com/java-util-arrays"><span class="No-Break">https://www.baeldung.com/java-util-arrays</span></a></li>
				<li><em class="italic">Collections in </em><span class="No-Break"><em class="italic">Java</em></span><span class="No-Break">: </span><a href="https://www.scaler.com/topics/java/collections-in-java/"><span class="No-Break">https://www.scaler.com/topics/java/collections-in-java/</span></a></li>
				<li><em class="italic">Functional Programming in </em><span class="No-Break"><em class="italic">Java</em></span><span class="No-Break">: </span><a href="https://www.scaler.com/topics/java/functional-programming-in-java/"><span class="No-Break">https://www.scaler.com/topics/java/functional-programming-in-java/</span></a></li>
				<li><em class="italic">Java </em><span class="No-Break"><em class="italic">Stream</em></span><span class="No-Break">: </span><a href="https://zetcode.com/java/stream/"><span class="No-Break">https://zetcode.com/java/stream/</span></a></li>
			</ul>
		</div>
	</body></html>