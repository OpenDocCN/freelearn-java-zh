<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer075">
			</div>
		</div>
		<div class="Content" id="_idContainer076">
			<h1 id="_idParaDest-186"><a id="_idTextAnchor188"/>8. Sockets, Files, and Streams</h1>
		</div>
		<div class="Content" id="_idContainer078">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter will teach you to work with external data storage systems. In the early sections, you will be taken through how to list the contents of directories—the logical first step to learning to create, open, read, and write to external files using Java. From there, you will study different methods, buffered and unbuffered, and how to distinguish between them. You will then learn to identify two main <strong class="bold">application programming interfaces</strong> (<strong class="bold">API</strong>s), <strong class="source-inline">java.io</strong> and <strong class="source-inline">java.nio</strong>, their respective relationship to the aforementioned methods, and when and where to use them. In this chapter's final activity, you will be asked to use all these Java skills and tools in order to communicate between two different programs running on remote computers, in preparation for the chapters to come.</p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor189"/>Introduction</h1>
			<p>On an operating system level, files and directories are kind of similar. They are names representing a link to something in storage, whether it is your hard drive, somewhere in the cloud, or the USB drive in your pocket. However, at a conceptual level, they are inherently different. Files contain information, while directories link to other directories and files.</p>
			<p>There are two main <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>s) that deal with the data: <strong class="source-inline">java.io</strong> and <strong class="source-inline">java.nio</strong>. Both APIs can be used to navigate directories and manipulate files. The information about the location of a file is called a pathname. It contains the full information of the directory in your hard drive in which the file resides, all the way to the file's name and extension. It should have the following form:</p>
			<p class="source-code">/folder_1/folder_2/[...]/folder_n/file.extension</p>
			<p>Different operating systems refer to files and folder structures differently. In Unix systems (such as Linux or macOSX), the <strong class="source-inline">/</strong> symbol represents the separation between folders. Having one at the beginning of the pathname indicates an absolute positioning against the root folder of the system. Not having that symbol will indicate a relative positioning against the <strong class="source-inline">classpath</strong> or the path where our program is being executed from. In Windows computers, the folder separator is \, and the root is determined by a hard drive label. By default, the root folder in Windows is <strong class="source-inline">C:</strong>, but you can also store files in any other drive, such as <strong class="source-inline">D:</strong>.</p>
			<p>The main difference between the two APIs mentioned previously (that is, <strong class="source-inline">java.io</strong> and <strong class="source-inline">java.nio</strong>) is in the way they read and write data. The first one, <strong class="source-inline">java.io</strong>, can work with streams (this is a concept that we will explore later in the chapter) and carries data byte to byte in a blocking manner from one point to another. The second one, <strong class="source-inline">java.nio</strong>, works with buffers. This means that data is read and written in chunks into a part of the memory (a buffer) and not directly from the stream. This allows non-blocking communication, which will, for example, allow your code to continue doing something else without having to wait until all the data is sent—you simply start copying the information into the buffer and move on to doing other things. </p>
			<p>When it comes to files, the big difference is how using one method or the other will translate into faster or slower programs when trying to perform the same task in different ways. We will mainly focus on using <strong class="source-inline">java.nio</strong>, since it is easier to use files with it, and then refer to <strong class="source-inline">java.io</strong> occasionally. The <strong class="source-inline">java.nio.file</strong> (note the difference from <strong class="source-inline">java.io.File</strong>) API defines classes and interfaces for the JVM—which makes use of files, their attributes, and filesystems—is more recent, and offers an easier way to use interfaces. However, this is not true for all cases, as we will see in this chapter.</p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor190"/>Listing Files and Directories</h1>
			<p>We are going to examine how to list files and directories in different ways. These techniques can come in handy when checking whether a certain file exists, which will allow you to give more sensitive information to users when, for example, trying to find a properties file. If you detect that the file you're looking for doesn't exist and, at the same time, you notice that you are not in the right directory, you could make your program locate the actual folder in which the file resides, or you could simply inform the user about this situation.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There are different techniques to list the files and directories at any location on your computer. You must choose wisely depending on the circumstances. While the latest API seems more complex at first sight, as you will see in the following examples, it is a lot more powerful than any of the previous versions.</p>
			<p>Let's start with the old way of listing the contents of a directory. In the next exercise, we will only use <strong class="source-inline">java.io</strong>. It requires making a call to <strong class="source-inline">File(dir).list()</strong>, where <strong class="source-inline">dir</strong> is a string representing the name of the folder you want to access. To ensure the code in this book works with your operating system, we have chosen to check your operating system's temporary folder. Java stores that in a JVM property, which is labeled <strong class="source-inline">java.io.tmpdir</strong>. Therefore, the call to <strong class="source-inline">getProperty()</strong> at the beginning of the method extracts the name of the folder. For example, for any Unix OS, that property points to the <strong class="source-inline">/tmp</strong> folder.</p>
			<p>Your temporary folder is going to be filled up with a lot of files and folders created by the different programs running in your computer. Therefore, we have chosen to display only the first five listed by the OS – the order is determined by the OS. Unless you sort the results of calling <strong class="source-inline">list()</strong>, you will most likely not find any logic in how the output is sorted:</p>
			<p class="source-code">import java.io.*;</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class Example01 {</p>
			<p class="source-code">    public static void main(String[] args) throws IOException {</p>
			<p class="source-code">        String pathString = System.getProperty("java.io.tmpdir");</p>
			<p class="source-code">        String [] fileNames = new File(pathString).list();</p>
			<p class="source-code">        for (int i = 0; i &lt; 5; i++ ) {</p>
			<p class="source-code">            System.out.println(fileNames[i]);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The output of this example will be as follows:</p>
			<p class="source-code">Slack Crashes</p>
			<p class="source-code">+~JF8916325484854780029.tmp</p>
			<p class="source-code">gnome-software-CAXF1Z</p>
			<p class="source-code">.XIM-unix</p>
			<p class="source-code">.X1001-lock</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Since the contents of computers are different for every one of us—even within specific folders—the kind of information you will see as output to the code listings in this chapter will look different from what you will see in your terminal. </p>
			<p>In the previous example, we have been intentionally hiding the part of the APIs that take care of each block of code to simplify the code listing. If you remove the three import statements from the code and follow the instructions from the IDE to add the more granular APIs to handle this code, you will get the following instead:</p>
			<p class="source-code">import java.io.File;</p>
			<p class="source-code">import java.io.IOException;</p>
			<p class="source-code">import java.util.ArrayList;</p>
			<p class="source-code">import java.util.List;</p>
			<p>You have learned about almost all these APIs throughout the book up to now. Even <strong class="source-inline">java.io.File</strong> was briefly presented in the chapter on exceptions to catch <strong class="source-inline">IOException</strong>. In the following examples, we will follow the same principle, just to keep the program headers as short as possible. However, it is better to reduce the lines of code.</p>
			<p>Let's explore another way to list the contents of a directory, but this time using <strong class="source-inline">java.nio</strong>:</p>
			<p class="source-code">import java.io.IOException;</p>
			<p class="source-code">import java.nio.file.*;</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class Example02 {</p>
			<p class="source-code">    public static void main(String[] args) throws IOException {</p>
			<p class="source-code">        String pathString = System.getProperty("java.io.tmpdir");</p>
			<p class="source-code">        List&lt;String&gt; fileNames = new ArrayList&lt;&gt;();</p>
			<p class="source-code">        DirectoryStream&lt;Path&gt; directoryStream;</p>
			<p class="source-code">        directoryStream = Files.newDirectoryStream(Paths.get(pathString));</p>
			<p class="source-code">        for (Path path : directoryStream) {</p>
			<p class="source-code">            fileNames.add(path.toString());</p>
			<p class="source-code">        }</p>
			<p class="source-code">        for (int i = 0; i &lt; 5; i++ ) {</p>
			<p class="source-code">            System.out.println(fileNames.get(i));</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The output of this listing is different from the previous example, as you can see here:</p>
			<p class="source-code">/tmp/Slack Crashes</p>
			<p class="source-code">/tmp/+~JF8916325484854780029.tmp</p>
			<p class="source-code">/tmp/gnome-software-CAXF1Z</p>
			<p class="source-code">/tmp/.XIM-unix</p>
			<p class="source-code">/tmp/.X1001-lock</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>Here, the full path to the directories and files are shown. This has to do with the way <strong class="source-inline">DirectoryStream</strong> captures information from the OS. The <strong class="source-inline">for</strong> loop in this example might look new for you. This has to do with how we work with streams. We haven't explained them yet, and we will not do so until later in this chapter. But you can see what it is doing: it creates a buffer that stores the information about the different directories inside. Then, it is possible to iterate through the buffer using the <strong class="source-inline">for(Path path : directoryStream)</strong> statement if there is data in it. Since we don't know about its size from the start, we will need a list to store the string containing the contents of the directory. However, at this point, we are still not calling the <strong class="source-inline">java.util.stream</strong> API yet, since <strong class="source-inline">DirectoryStream</strong> belongs to the <strong class="source-inline">java.nio</strong> API.</p>
			<p>Another code listing that uses streams properly is shown here. Note that we do not show its output because it's the same as the previous example:</p>
			<p class="source-code">import java.io.IOException;</p>
			<p class="source-code">import java.nio.file.*;</p>
			<p class="source-code">import java.util.stream.Stream;</p>
			<p class="source-code">public class Example03 {</p>
			<p class="source-code">    public static void main(String[] args) throws IOException {</p>
			<p class="source-code">        String pathString = System.getProperty("java.io.tmpdir");</p>
			<p class="source-code">        Path path = Paths.get(pathString);</p>
			<p class="source-code">        Stream&lt;Path&gt; fileNames = Files.list(path);</p>
			<p class="source-code">        fileNames.limit(5).forEach(System.out::println);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor191"/>Separating Directories from Files</h2>
			<p>Imagine that you want to mark files differently from directories when listing a folder's contents. In order to do so, you can use a method from <strong class="source-inline">java.nio</strong> called <strong class="source-inline">isDirectory()</strong>, as shown in the following example:</p>
			<p class="source-code-heading">Example04.java</p>
			<p class="source-code">17         for (int i = 0; i &lt; 5; i++ ) {</p>
			<p class="source-code">18             String filePath = fileNames.get(i);</p>
			<p class="source-code">19             String fileType = Files.isDirectory(Paths.get(filePath)) ? "Dir" :                "Fil";</p>
			<p class="source-code">20            System.out.println(fileType + " " + filePath);</p>
			<p class="source-code">21         }</p>
			<p class="source-code-link"><a href="https://packt.live/2o43Yhe">https://packt.live/2o43Yhe</a></p>
			<p>We have highlighted the part of the code that is new compared with the previous example in which we accessed the directory using the java.nio API. <strong class="source-inline">Files.isDirectory()</strong> requires an object of the <strong class="source-inline">Paths</strong> class. <strong class="source-inline">Paths.get()</strong> transforms the path from a directory item, passed as a string to the actual instance of the Paths class. With that, <strong class="source-inline">Files.isDirectory()</strong> will answer with a Boolean that is <strong class="source-inline">true</strong> if the item is a directory and <strong class="source-inline">false</strong> if not. We used an inline <strong class="source-inline">if</strong> statement to assign the string <strong class="source-inline">Dir</strong> or <strong class="source-inline">Fil</strong>, depending on whether we are dealing with a directory or with a file. The result of this code listing is as follows:</p>
			<p class="source-code">Dir /tmp/Slack Crashes</p>
			<p class="source-code">Fil /tmp/+~JF8916325484854780029.tmp</p>
			<p class="source-code">Dir /tmp/gnome-software-CAXF1Z</p>
			<p class="source-code">Dir /tmp/.XIM-unix</p>
			<p class="source-code">Fil /tmp/.X1001-lock</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>As you can see, in the temporary directory, there are both files and subdirectories. The next question is how to list the content of the subdirectories. We will approach that question as an exercise, but before we do that, try one more example that will list only those items that are directories. This is a more advanced technique, but it will give us an excuse to step back and try to implement our own solution with the knowledge we have gained so far:</p>
			<p class="source-code">import java.io.IOException;</p>
			<p class="source-code">import java.nio.file.*;</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">import java.util.stream.Collectors;</p>
			<p class="source-code">public class Example05 {</p>
			<p class="source-code">    public static void main(String[] args) throws IOException {</p>
			<p class="source-code">        String pathString = System.getProperty("user.home");</p>
			<p class="source-code">        List&lt;Path&gt; subDirectories = Files.walk(Paths.get(pathString), 1)</p>
			<p class="source-code">                    .filter(Files::isDirectory)</p>
			<p class="source-code">                    .collect(Collectors.toList());</p>
			<p class="source-code">        for (int i = 0; i &lt; 5; i++ ) {</p>
			<p class="source-code">            Path filePath = subDirectories.get(i);</p>
			<p class="source-code">            String fileType = Files.isDirectory(filePath) ? "Dir" : "Fil";</p>
			<p class="source-code">            System.out.println(fileType + " " + filePath);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>First, to show that there is the possibility of using other environment variables (that's what we call the system properties as defined for your OS), we changed the folder to user home, which corresponds to your user space, or the directory where you will typically store your files. Please be careful from now on to avoid any kind of accidents with your files.</p>
			<p><strong class="source-inline">Files.walk()</strong> will extract the directory structure up to a certain depth, in our case, one. The depth represents how many levels of subdirectories your code will be digging into. <strong class="source-inline">filter(Files::isDirectory)</strong> is going to exclude anything that is not a directory. We have not seen filters yet, but it is a clear enough concept to not need any further explanation at this point. The final part of the call, <strong class="source-inline">collect(Collectors.toList())</strong>, will be creating a list of the output. This means that the <strong class="source-inline">subDirectories</strong> object will contain a list of paths to directories. That is why in this example, unlike the previous one, we do not have to make a call to <strong class="source-inline">Paths.get(filePath)</strong>. The output of that call will depend on what your OS is and whatever you have in your home folder. The result on my computer, which runs a version of Linux, is as follows:</p>
			<p class="source-code">Dir /home/&lt;userName&gt;</p>
			<p class="source-code">Dir /home/&lt;userName&gt;/.gnome</p>
			<p class="source-code">Dir /home/&lt;userName&gt;/Vídeos</p>
			<p class="source-code">Dir /home/&lt;userName&gt;/.shutter</p>
			<p class="source-code">Dir /home/&lt;userName&gt;/opt</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>Here, <strong class="source-inline">&lt;userName&gt;</strong> corresponds to the user's nickname on the computer. As you can see, this is only representing the contents of the directory initialized at <strong class="source-inline">pathString</strong>. The question is, can we represent the content of the nested subdirectories to the initial <strong class="source-inline">pathString</strong> in our program?</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor192"/>Exercise 1: Listing the Contents of Subdirectories</h2>
			<p>Let's make a program to navigate through subdirectories using the knowledge we have gained so far. It might not be the most optimal way of solving this challenge, but it will work:</p>
			<ol>
				<li>Let's start with the latest example, where we used a call to <strong class="source-inline">Files.walk()</strong> with a depth of 1 and a filter to list the contents—just the directories—of a certain directory, <strong class="source-inline">pathString</strong>. The depth in a directory search determines how many levels of subdirectories our will program navigate into. Level 1 is the same level as where the search is initiated. Level 2 indicates that we should also represent the contents of the directories inside the main directory. In principle, it should be as easy as giving the call a higher value for depth, like this:<p class="source-code">List&lt;Path&gt; subDirectories = Files.walk(Paths.get(pathString), 2)</p><p class="source-code">                .filter(Files::isDirectory)</p><p class="source-code">                .collect(Collectors.toList());</p></li>
				<li>But there is the catch. When running a call like that, it is likely that there are directories or files that your program is not allowed to access. An exception regarding permissions will be fired and your program will stop:<p class="source-code">Exception in thread "main" java.io.UncheckedIOException: java.nio.file.AccessDeniedException: /home/&lt;userName&gt;/.gvfs</p><p class="source-code">      at java.nio.file.FileTreeIterator.fetchNextIfNeeded(FileTreeIterator.java:88)</p><p class="source-code">      at java.nio.file.FileTreeIterator.hasNext(FileTreeIterator.java:104)</p><p class="source-code">[...]</p><p class="source-code">      at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)</p><p class="source-code">      at Example04.main(Example04.java:13)</p><p class="source-code">Caused by: java.nio.file.AccessDeniedException: /home/&lt;userName&gt;/.gvfs</p><p class="source-code">      at sun.nio.fs.UnixException.translateToIOException(UnixException.java:84)</p><p class="source-code">      at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:102)</p><p class="source-code">[...]</p><p class="source-code">      at java.nio.file.FileTreeIterator.fetchNextIfNeeded(FileTreeIterator.java:84)</p><p class="source-code">      ... 9 more</p><p class="source-code">Process finished with exit code 1</p></li>
				<li>Accessing any directory or file that is contained in any of these subdirectories, which are under strict administrative user permissions, will make this program crash. It is of no use to catch this exception because the result will still be a non-functional directory listing. There is a pretty advanced technique to get this to work, but you have not been introduced to everything you need to know in order to do so. Instead, let's focus on the tools you have gained so far to create your own method to dig into subdirectories and extract their contents.</li>
				<li>Let's go back to <em class="italic">Example 03</em> and modify it to just display directories inside user.home:<p class="source-code">String pathString = System.getProperty("user.home");</p><p class="source-code">Path path = Paths.get(pathString);</p><p class="source-code">Stream&lt;Path&gt; fileNames = Files.list(path).filter(Files::isDirectory);</p><p class="source-code">fileNames.limit(5).forEach(System.out::println);</p></li>
				<li>As you can see, we have applied the <strong class="source-inline">filter()</strong> method we saw earlier. We could have also implemented the alternative of checking with <strong class="source-inline">isDirectory()</strong>, as we saw in <em class="italic">Example 04</em>, but this is cleaner, and simplicity is key. </li>
				<li>Based on the idea that <strong class="source-inline">list()</strong> can give you the contents of any folder, let's call it again for each filename. This means we will have to modify the <strong class="source-inline">forEach()</strong> statement we are using so that we can access the second level of nested directories:<p class="source-code">fileNames.limit(5).forEach( (item) -&gt; {</p><p class="source-code">    System.out.println(item.toString());</p><p class="source-code">    try {</p><p class="source-code">        Stream&lt;Path&gt; fileNames2 = Files.list(item).filter(Files::isDirectory);</p><p class="source-code">        fileNames2.forEach(System.out::println);</p><p class="source-code">    } catch (IOException ioe) {}</p><p class="source-code">});</p></li>
				<li>As you can see, the highlighted code is a repetition of the code we had earlier, with the name of the object changed to <strong class="source-inline">fileNames2</strong>. This time, we removed the limit, which means it will print the output of any subdirectories each directory has. The real novelty is how we have gone from calling just <strong class="source-inline">System.out::print</strong> to writing more complex code where we first print out the path we are at, and then we print the paths to the subfolders of that path. We are anticipating something called a lambda expression here. They will be explained in a later chapter. However, the code here is easy enough for you to understand. For each <strong class="source-inline">(item)</strong> in the <strong class="source-inline">fileNames</strong> buffer, we will perform the operations just mentioned. The result looks like this:<p class="source-code">/home/&lt;userName&gt;/.gnome</p><p class="source-code">/home/&lt;userName&gt;/.gnome/apps</p><p class="source-code">/home/&lt;userName&gt;/Vídeos</p><p class="source-code">/home/&lt;userName&gt;/Vídeos/technofeminism</p><p class="source-code">/home/&lt;userName&gt;/Vídeos/Webcam</p><p class="source-code">/home/&lt;userName&gt;/Vídeos/thumbnail</p><p class="source-code">/home/&lt;userName&gt;/.shutter</p><p class="source-code">/home/&lt;userName&gt;/.shutter/profiles</p><p class="source-code">/home/&lt;userName&gt;/opt</p><p class="source-code">/home/&lt;userName&gt;/opt/Python-3.4.4</p><p class="source-code">/home/&lt;userName&gt;/.local</p><p class="source-code">/home/&lt;userName&gt;/.local/share</p><p class="source-code">/home/&lt;userName&gt;/.local/bin</p><p class="source-code">/home/&lt;userName&gt;/.local/lib</p><p class="source-code">Process finished with exit code 0</p></li>
				<li>Also, <strong class="source-inline">IOException</strong> must be caught at the time of generating the list, otherwise the code will not compile. <strong class="source-inline">throw IOException</strong> in the declaration of the <strong class="source-inline">main</strong> method doesn't apply to the <strong class="source-inline">forEach()</strong> expression because it is one level deeper in the program's scope. We are looking at an inline definition of a method in this case. But the question is, how can we get around the idea of having an arbitrary depth in the directory exploration?</li>
				<li>Digging deeper in the <strong class="source-inline">java.nio</strong> API, we find the <strong class="source-inline">walkFileTree()</strong> method, which can browse through directory structures up to a certain depth – two in the following example – and offers the possibility of overriding some of its methods to decide what happens when reaching a directory item and trying to access it. A call to this method could look like this:<p class="source-code">Path path = Paths.get(System.getProperty("user.home"));</p><p class="source-code">Files.walkFileTree(path, Collections.emptySet(), 2, new SimpleFileVisitor&lt;Path&gt;() {</p><p class="source-code">    @Override</p><p class="source-code">    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes       attrs) {</p><p class="source-code">        System.out.println(dir.toString());</p><p class="source-code">        return FileVisitResult.CONTINUE;</p><p class="source-code">    }</p><p class="source-code">});</p></li>
				<li>Here, you can see how the <strong class="source-inline">preVisitDirectory()</strong> method is called at the time of trying to open a directory item in a folder. A program including that line will run until, for example, a permissions-related exception arrives. If there is no exceptional situation, the overridden method will print out all directory names up to two levels of depth. In the case of the home directory we are experimenting with, we know that there is a folder that Java's default user permissions are not enough for our program to gain access to. Therefore, if we run this program, we will see it operate normally until an exception is reached:<p class="source-code">/home/&lt;userName&gt;/.gnome/apps</p><p class="source-code">/home/&lt;userName&gt;/Vídeos/technofeminism</p><p class="source-code">/home/&lt;userName&gt;/Vídeos/Webcam</p><p class="source-code">[...]</p><p class="source-code">/home/&lt;userName&gt;/.local/lib</p><p class="source-code">Exception in thread "main" java.nio.file.AccessDeniedException: /home/&lt;userName&gt;/.gvfs</p><p class="source-code">      at sun.nio.fs.UnixException.translateToIOException(UnixException.        java:84)</p><p class="source-code">      at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.        java:102)</p><p class="source-code">      at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.        java:107)</p><p class="source-code">      at sun.nio.fs.UnixFileSystemProvider.        newDirectoryStream(UnixFileSystemProvider.java:427)</p><p class="source-code">      at java.nio.file.Files.newDirectoryStream(Files.java:457)</p><p class="source-code">      at java.nio.file.FileTreeWalker.visit(FileTreeWalker.java:300)</p><p class="source-code">      at java.nio.file.FileTreeWalker.next(FileTreeWalker.java:372)</p><p class="source-code">      at java.nio.file.Files.walkFileTree(Files.java:2706)</p><p class="source-code">      at Exercise01.main(Exercise01.java:11)</p><p class="source-code">Process finished with exit code 1</p></li>
				<li>The <strong class="source-inline">preVisitDirectory()</strong> method will tell the <strong class="source-inline">walkFileTree</strong> method that it should continue to work through its return. The issue here is that because of the <strong class="source-inline">AccessDeniedException</strong>, our program will not enter <strong class="source-inline">preVisitDirectory()</strong>. We need to override yet another method called <strong class="source-inline">visitFileFailed()</strong> to see how to handle any kind of exception that occurs when trying to access an item in the directory:<p class="source-code">@Override</p><p class="source-code">public FileVisitResult visitFileFailed(Path file, IOException exc)</p><p class="source-code">        throws IOException {</p><p class="source-code">    System.out.println("visitFileFailed: " + file);</p><p class="source-code">    return FileVisitResult.CONTINUE;</p><p class="source-code">}</p><p>The output of this will be the desired result, as follows:</p><p class="source-code">/home/&lt;userName&gt;/.gnome/apps</p><p class="source-code">/home/&lt;userName&gt;/Vídeos/technofeminism</p><p class="source-code">[...]</p><p class="source-code">/home/&lt;userName&gt;/.local/lib</p><p class="source-code">visitFileFailed: /home/&lt;userName&gt;/.gvfs</p><p class="source-code">/home/&lt;userName&gt;/.config/Atom</p><p class="source-code">[...]</p><p class="source-code">/home/&lt;userName&gt;/drive_c/Program Files</p><p class="source-code">/home/&lt;userName&gt;/drive_c/Program Files (x86)</p><p class="source-code">/home/&lt;userName&gt;/drive_c/users</p><p class="source-code">/home/&lt;userName&gt;/drive_c/windows</p><p class="source-code">/home/&lt;userName&gt;/.swt/lib</p><p class="source-code">Process finished with exit code 0</p><p>We can conclude from this process that, even though there are many ways to perform the same task, the way those solutions are implemented will allow us to have control. In this case, the <strong class="source-inline">walk()</strong> method is not enough for us to handle exceptions easily, so we had to explore an alternative that, in the end, turned out to be easier to understand.</p><p>For reference, the final code resulting from this exercise should be as follows:</p></li>
			</ol>
			<p class="source-code-heading">Exercise01.java</p>
			<p class="source-code">1  import java.io.IOException;</p>
			<p class="source-code">2  import java.nio.file.*;</p>
			<p class="source-code">3  import java.nio.file.attribute.BasicFileAttributes;</p>
			<p class="source-code">4  import java.util.Collections;</p>
			<p class="source-code">5  </p>
			<p class="source-code">6  public class Exercise01 {</p>
			<p class="source-code">7      public static void main(String[] args) throws IOException {</p>
			<p class="source-code">8          Path path = Paths.get(System.getProperty("user.home"));</p>
			<p class="source-code">9  </p>
			<p class="source-code">10         Files.walkFileTree(path, Collections.emptySet(), 2, new          SimpleFileVisitor&lt;Path&gt;() {</p>
			<p class="source-code">11 </p>
			<p class="source-code">12              @Override</p>
			<p class="source-code">13              public FileVisitResult preVisitDirectory(Path dir,                 BasicFileAttributes attrs) {</p>
			<p class="source-code">14                 System.out.println(dir.toString());</p>
			<p class="source-code">15                 return FileVisitResult.CONTINUE;</p>
			<p class="source-code">16             }</p>
			<p class="source-code-link"><a href="https://packt.live/35MN9Zd">https://packt.live/35MN9Zd</a></p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor193"/>Creating and Writing to a File</h1>
			<p>Once we are familiar with how to list the contents of directories, the next logical step is to proceed with the creation of files and folders. Let's start by creating and writing data into a file by using <strong class="source-inline">java.nio</strong>. The easiest way to create a file using this API requires calling the following:</p>
			<p class="source-code">Files.createFile(newFilePath);</p>
			<p>At the same time, creating a directory is as simple as this:</p>
			<p class="source-code">Files.createDirectories(newDirPath);</p>
			<p>As a good practice, you should check whether directories and/or files exist prior to creating any with the same name. There is a simple method that will look into any objects of the Path class to see whether any can be found in the folder our program is exploring:</p>
			<p class="source-code">Files.exists(path);</p>
			<p>Let's put all of this together into a single example that will create a folder, and then a file inside the folder:</p>
			<p class="source-code-heading">Example06.java</p>
			<p class="source-code">1  import java.io.IOException;</p>
			<p class="source-code">2  import java.nio.file.Files;</p>
			<p class="source-code">3  import java.nio.file.Path;</p>
			<p class="source-code">4  import java.nio.file.Paths;</p>
			<p class="source-code">5  </p>
			<p class="source-code">6  public class Example06 {</p>
			<p class="source-code">7      public static void main(String[] args) {</p>
			<p class="source-code">8          String pathString = System.getProperty("user.home") + "/javaTemp/";</p>
			<p class="source-code">9          Path pathDirectory = Paths.get(pathString);</p>
			<p class="source-code">10         if(Files.exists(pathDirectory)) {</p>
			<p class="source-code">11             System.out.println("WARNING: directory exists already at: " +                  pathString);</p>
			<p class="source-code">12         } else {</p>
			<p class="source-code">13             try {</p>
			<p class="source-code">14                 // Create the directory</p>
			<p class="source-code">15                 Files.createDirectories(pathDirectory);</p>
			<p class="source-code">16                 System.out.println("New directory created at: " + pathString);</p>
			<p class="source-code">17             } catch (IOException ioe) {</p>
			<p class="source-code">18                 System.out.println("Could not create the directory");</p>
			<p class="source-code">19                 System.out.println("EXCEPTION: " + ioe.getMessage());</p>
			<p class="source-code">20             }</p>
			<p class="source-code">21         }</p>
			<p class="source-code-link"><a href="https://packt.live/2MSEPhX">https://packt.live/2MSEPhX</a></p>
			<p>The result of this code listing, the first time you execute it, should be as follows:</p>
			<p class="source-code">New directory created at: /home/&lt;userName&gt;/javaTemp/</p>
			<p class="source-code">New file created at: /home/&lt;userName&gt;/javaTemp/temp.txt</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>Any subsequent executions should give us the following result:</p>
			<p class="source-code">WARNING: directory exists already at: /home/&lt;userName&gt;/javaTemp/</p>
			<p class="source-code">WARNING: file exists already at: /home/&lt;userName&gt;/javaTemp/temp.txt</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>This created a file that is essentially empty. Making use of the terminal, you could list the size of the file by calling the <strong class="source-inline">ls -lah ~/javaTemp/temp.txt</strong> command, which will throw a result like the following:</p>
			<p class="source-code">-rw-r--r--  1 userName dialout   0 maj 15 13:57 /[...]/temp.txt</p>
			<p>This means that the file takes zero bytes of hard drive space. This means that the file is there, but it is empty. Writing text to the file can easily be done using a method from the <strong class="source-inline">java.nio.file.Files</strong> API: <strong class="source-inline">write()</strong>. The only issue is that it is not trivial passing arguments to this method. In its easiest interface, you must pass two arguments: the <strong class="source-inline">Path</strong> object and a <strong class="source-inline">List</strong> containing a text. On top of that, there is a risk that the file may not exist, which requires handling the classic <strong class="source-inline">IOException</strong>. It could be something like this:</p>
			<p class="source-code">try {</p>
			<p class="source-code">    Files.write(pathFile, Arrays.asList("hola"));</p>
			<p class="source-code">    System.out.println("Text added to the file: " + pathFile);</p>
			<p class="source-code">} catch (IOException ioe) {</p>
			<p class="source-code">    System.out.println("EXCEPTION: " + ioe.getMessage());</p>
			<p class="source-code">}</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When calling <strong class="source-inline">write()</strong> to write text to a file, you don't have to add the end-of-line symbol at the end of the string. It will be added automatically by the method as one would expect when using commands such as println().</p>
			<p>Once you have added the last code snippet to the latest example, the program will give the following result:</p>
			<p class="source-code">WARNING: directory exists already at: /home/&lt;userName&gt;/javaTemp/</p>
			<p class="source-code">WARNING: file exists already at: /home/&lt;userName&gt;/javaTemp/temp.txt</p>
			<p class="source-code">Text added to the file: /home/&lt;userName&gt;/javaTemp/temp.txt</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>The previous example just writes text to the file but also deletes everything that was there before. In order to append text instead, you need to modify the call to the write command:</p>
			<p class="source-code">Files.write(pathFile, Arrays.asList("hola"), StandardOpenOption.APPEND);</p>
			<p>The highlighted part of the call is responsible for determining what text will be added at the end of the file instead of erasing everything and writing everything from scratch. The following example simply appends text to an existing file:</p>
			<p class="source-code-heading">Example07.java</p>
			<p class="source-code">8  public class Example07 {</p>
			<p class="source-code">9      public static void main(String[] args) {</p>
			<p class="source-code">10         String pathString = System.getProperty("user.home") +              "/javaTemp/temp.txt";</p>
			<p class="source-code">11         Path pathFile = Paths.get(pathString);</p>
			<p class="source-code">12         String text = "Hola,\nme da un refresco,\npor favor?";</p>
			<p class="source-code">13 </p>
			<p class="source-code">14         if(Files.exists(pathFile))</p>
			<p class="source-code">15             try {</p>
			<p class="source-code">16                 Files.write(pathFile, Arrays.asList(text),                      StandardOpenOption.APPEND);</p>
			<p class="source-code">17                 System.out.println("Text added to the file: " + pathFile);</p>
			<p class="source-code">18             } catch (IOException ioe) {</p>
			<p class="source-code">19                 System.out.println("EXCEPTION: " + ioe.getMessage());</p>
			<p class="source-code">20             }</p>
			<p class="source-code">21     }</p>
			<p class="source-code-link"><a href="https://packt.live/2MrBV4B">https://packt.live/2MrBV4B</a></p>
			<p>This program appended a whole sentence to the example text file. The final content of the file will read is as follows:</p>
			<p class="source-code">hola</p>
			<p class="source-code">Hola,</p>
			<p class="source-code">me da un refresco,</p>
			<p class="source-code">por favor?</p>
			<p>This is asking for a soda in Spanish. In the next section, let's examine how to read the file we just created.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor194"/>Activity 1: Writing the Directory Structure to a File</h2>
			<p>The goal of this activity is to program an application that will read the directory structure, starting from a directory that is stored in a variable. The results will be written to a text file so that, for each nesting level, you will include either a tab space or four white spaces to indent nested folders visually from their respective parents. Also, you will have to show only the name of the folder and not the full path to it. In other words, the content of the file should correspond to the following structure:</p>
			<p class="source-code">Directory structure for folder: /folderA/folderB/.../folderN</p>
			<p class="source-code">folderN</p>
			<p class="source-code">    folderN1</p>
			<p class="source-code">        folderN11</p>
			<p class="source-code">        folderN12</p>
			<p class="source-code">        ...</p>
			<p class="source-code">    folderN2</p>
			<p class="source-code">        folderN21</p>
			<p class="source-code">        folderN22</p>
			<p class="source-code">        ...</p>
			<p class="source-code">    folderN3</p>
			<p class="source-code">        folderN31</p>
			<p class="source-code">        folderN32</p>
			<p class="source-code">        ...</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    folderNN</p>
			<ol>
				<li value="1">The program that you will have to create will need to have a certain depth of directories as a parameter, but we recommend you don't go too deep with this—a maximum of 10 is fine:<p class="source-code">Files.walkFileTree(path, Collections.emptySet(), 10, new SimpleFileVisitor&lt;Path&gt;() ...</p></li>
				<li>When working with the obtained paths to the directories, you need to split the resulting string using the / symbol as a separator and then take the last item. Additionally, you will have to print the number of indents based on the depth, which will require having some code that can estimate the current depth given the initial path. A trick for solving those problems could be by making the content of <strong class="source-inline">preVisitDirectory()</strong> like the following:<p class="source-code">// get the path to the init directory</p><p class="source-code">String [] pathArray = path.toString().split("/");</p><p class="source-code">int depthInit = pathArray.length;</p><p class="source-code">// get the path to the current folder</p><p class="source-code">String [] fileArray = dir.toString().split("/");</p><p class="source-code">int depthCurrent = fileArray.length;</p><p class="source-code">// write the indents</p><p class="source-code">for (int i = depthInit; i &lt; depthCurrent; i++) {</p><p class="source-code">    System.out.print("    ");</p><p class="source-code">    // HINT: copy to list or write to file here</p><p class="source-code">}</p><p class="source-code">// write the directory name</p><p class="source-code">System.out.println(fileArray[fileArray.length – 1]);</p><p class="source-code">// HINT: copy to list or write to file here</p><p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 552.</p></li>
			</ol>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor195"/>Reading an Existing File</h1>
			<p>Reading a file can be done in a simple way. The question is about where you will store the data once you have it. We will work with lists, iterate through the lists, and then print out the results to <strong class="source-inline">System.out</strong>. The next example uses <strong class="source-inline">readAllLines()</strong> to open the existing file and reads the contents into the computer's memory, putting them into the <strong class="source-inline">fileContent</strong> list. After that, we use an iterator to go through each line and send them to the Terminal:</p>
			<p class="source-code">import java.io.IOException;</p>
			<p class="source-code">import java.nio.file.*;</p>
			<p class="source-code">import java.util.List;</p>
			<p class="source-code">public class Example08 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        String pathString = System.getProperty("user.home") + "/javaTemp/temp.txt";</p>
			<p class="source-code">        Path pathFile = Paths.get(pathString);</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            List&lt;String&gt; fileContent = Files.readAllLines(pathFile);</p>
			<p class="source-code">            // this will go through the buffer containing the whole file</p>
			<p class="source-code">            // and print it line by one to System.out</p>
			<p class="source-code">            for (String content:fileContent){</p>
			<p class="source-code">                System.out.println(content);</p>
			<p class="source-code">            }</p>
			<p class="source-code">        } catch (IOException ioe) {</p>
			<p class="source-code">            System.out.println("WARNING: there was an issue with the file");</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">temp.txt</strong> file is the one where we saved a message earlier; therefore, the result will be as follows:</p>
			<p class="source-code">hola</p>
			<p class="source-code">Hola,</p>
			<p class="source-code">me da un refresco,</p>
			<p class="source-code">por favor?</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>If the file wasn't there (you may have deleted it after the previous exercise), you would instead get the following:</p>
			<p class="source-code">WARNING: there was an issue with the file</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>A different approach that gets the same result, but avoids Lists and uses Streams instead, is as follows:</p>
			<p class="source-code">import java.io.IOException;</p>
			<p class="source-code">import java.nio.file.*;</p>
			<p class="source-code">public class Example09 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        String pathString = System.getProperty("user.home") + "/javaTemp/temp.txt";</p>
			<p class="source-code">        Path pathFile = Paths.get(pathString);</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            Files.lines(pathFile).forEach(System.out::println);</p>
			<p class="source-code">        } catch (IOException ioe) {</p>
			<p class="source-code">            System.out.println("WARNING: there was an issue with the file");</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor196"/>Reading a Properties File</h1>
			<p>Property files store key-value (also called key-map) pairs in a standard format. An example of the content of such a file is:</p>
			<p class="source-code">#user information</p>
			<p class="source-code">name=Ramiro</p>
			<p class="source-code">familyName=Rodriguez</p>
			<p class="source-code">userName=ramiroz</p>
			<p class="source-code">age=37</p>
			<p class="source-code">bgColor=#000000</p>
			<p>This is a made-up example of the properties file for an imaginary user. Note how the comment is marked using a hashtag symbol, #. You will use properties files to store the configurable parameters of applications or even for localization strings.</p>
			<p>Let's try reading a properties file. You can create a text file in the same temporary folder that we created in the user's space earlier in the chapter. Name it <strong class="source-inline">user.properties</strong> and write to it the contents of the preceding example. This follows an example of a program using <strong class="source-inline">java.io</strong> to read and print out the contents of a properties file. Given the way Java works, there is no better alternative to performing this task than using <strong class="source-inline">java.nio</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Reading the contents of a properties file consists not just in getting each line of the file, but also parsing the key-value pairs and being able to extract data from them. </p>
			<p>The first thing you will notice is that reading the properties file requires opening a file as a stream – again, a concept we will explore later in the chapter – using <strong class="source-inline">FileInputStream</strong>. From there, the <strong class="source-inline">Properties</strong> class contains a method called <strong class="source-inline">load()</strong> that can extract the key-value pairs from the data stream. To clean up the code listing, we have separated the loading and printing aspects of the code from the ones handling the opening of the file. Additionally, we have made sure that all exceptions are handled in the main class, just to have a single point where we can manage them, which makes for more readable code.</p>
			<p class="source-code-heading">Example10.java</p>
			<p class="source-code">17     public static void main(String[] args) throws IOException {</p>
			<p class="source-code">18         String pathString = System.getProperty("user.home") +              "/javaTemp/user.properties";</p>
			<p class="source-code">19 </p>
			<p class="source-code">20         FileInputStream fileStream = null;</p>
			<p class="source-code">21         try {</p>
			<p class="source-code">22             fileStream = new FileInputStream(pathString);</p>
			<p class="source-code">23             PrintOutProperties(fileStream);</p>
			<p class="source-code">24         } catch (FileNotFoundException fnfe) {</p>
			<p class="source-code">25             System.out.println("WARNING: could not find the properties file");</p>
			<p class="source-code">26         } catch (IOException ioe) {</p>
			<p class="source-code">27             System.out.println("WARNING: problem processing the properties                  file");</p>
			<p class="source-code">28         } finally {</p>
			<p class="source-code">29             if (fileStream != null) {</p>
			<p class="source-code">30                 fileStream.close();</p>
			<p class="source-code">31             }</p>
			<p class="source-code">32         }</p>
			<p class="source-code">33     }</p>
			<p class="source-code-link"><a href="https://packt.live/2Bry4OK">https://packt.live/2Bry4OK</a></p>
			<p>There is also an aspect that we have not yet discussed in this chapter. Streams must be closed once you are done working with them. This means that they will be unavailable for further data handling after you close them. This step is important for avoiding any kind of JVM memory issues during runtime. Therefore, the example code calls <strong class="source-inline">fileStream.close()</strong> once we are done loading the properties file. If you remember the <em class="italic">Good Practices</em> section in <em class="italic">Chapter 5</em>, <em class="italic">Exceptions</em>, it was mentioned that you should close streams inside the <strong class="source-inline">finally</strong> statement. This is also the reason why this program must throw <strong class="source-inline">IOException</strong> in the main method. If you wanted to handle this in a clean way (by avoiding nested try-catch statements or using <strong class="source-inline">throws IOException</strong> in the main method), you can wrap the whole <strong class="source-inline">try</strong> block in a method that you would, in turn, call from the main method where you could catch the <strong class="source-inline">IOException</strong>. Look at the forthcoming exercise to see how this is done.</p>
			<p>The output of the previous example is as follows:</p>
			<p class="source-code">name: Ramiro</p>
			<p class="source-code">family name: Rodriguez</p>
			<p class="source-code">nick: ramiroz</p>
			<p class="source-code">age: 37</p>
			<p class="source-code">background color: #000000</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>There are interesting methods within the <strong class="source-inline">Properties</strong> class for you to explore. For example, <strong class="source-inline">properties.keys()</strong> will return an enumeration of all the keys in the file, in our case name, familyName, userName, and so on. This specific method is inherited by <strong class="source-inline">Properties</strong> because of its relation to the <strong class="source-inline">Hashtable</strong> class. It is recommended that you read through the API's documentation for this class to discover the other interesting methods you can make use of.</p>
			<p>When it comes to the properties files location, they could be stored inside the classpath, sometimes even inside the actual JAR file, which provides a very compact way to distribute applications with properties files inside. </p>
			<p>The next aspect to explore is how to programmatically make your own properties files. Let's look into this topic through a step-by-step exercise.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor197"/>Exercise 2: Creating a Properties File from the CLI</h2>
			<p>In this exercise, you will be making an application capable of creating a properties file (or modifying an existing one) from input on the CLI. You will pass the properties file's name and key-value pairs as arguments to your program. This will allow you to create any kind of properties file easily. An example of the expected call to the application will be as follows:</p>
			<p class="source-code">usr@localhost:~/[...]/Exercise02$ java Exercise02 myProperties.properties name=Petra</p>
			<p>The process of operations in such a program is simple. First, you need to check whether the file exists. If so, load the properties. Then, add the new properties or modify the existing ones with the data handed over as an argument. Later, write the information to the file and give feedback to the user on the final content sent to the file. In that way, the user will be able to see that the modifications they made are working without having to open the file. </p>
			<p>Let's see how to make such a program step by step:</p>
			<ol>
				<li value="1">Open IntelliJ and create a new Java CLI project called <strong class="source-inline">Exercise02</strong>.</li>
				<li>First, we need to check whether the properties file we are defining in the CLI already exists. The program we are going to implement will check whether the file exists. If that is the case, it will open it and load the existing properties. The rest of the arguments in the CLI will be used to either modify existing key-value pairs or add new ones. To see whether a properties file exists and load it, we will need to execute the following:<p class="source-code">if (Files.exists(pathFile)) {</p><p class="source-code">    properties = LoadProperties(pathString);</p><p class="source-code">}</p></li>
				<li>Loading the properties is done reusing the code from <em class="italic">Example 10</em>, but wrapping it into the <strong class="source-inline">LoadPoperties()</strong> method that we called in the previous step. Let's implement it to return an object of the <strong class="source-inline">Properties</strong> class (note what we did to implement the <strong class="source-inline">finally</strong> statement to make sure that the stream is closed after a possible exception. We had to initialize the stream as null):<p class="source-code">public static Properties LoadProperties (String pathString)   throws IOException {</p><p class="source-code">    Properties properties = new Properties();</p><p class="source-code">    FileInputStream fileInputStream = null;</p><p class="source-code">    try {</p><p class="source-code">        fileInputStream = new FileInputStream(pathString);</p><p class="source-code">        properties.load(fileInputStream);</p><p class="source-code">    } catch (FileNotFoundException fnfe) {</p><p class="source-code">        System.out.println("WARNING: could not find the properties file");</p><p class="source-code">    } catch (IOException ioe) {</p><p class="source-code">        System.out.println("WARNING: problem processing the properties           file");</p><p class="source-code">    } finally {</p><p class="source-code">        if (fileInputStream != null) {</p><p class="source-code">            fileInputStream.close();</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    return properties;</p><p class="source-code">}</p></li>
				<li>If the file doesn't exist, it will be created when calling the <strong class="source-inline">store()</strong> method later—there is no need to create an empty file at this point.</li>
				<li>Next, we need to read the remaining arguments at the CLI from the <strong class="source-inline">arg[]</strong> array and push them, one by one, into the properties object. The properties object inherits its behavior from the <strong class="source-inline">Hashtable</strong> class, which handles key-value pairs. The <strong class="source-inline">setProperty()</strong> method will be used to either modify an existing property or to write a new one. Since the arguments are expressed as a string formatted as key=value, we can use <strong class="source-inline">split()</strong> to separate the arguments we need to pass to <strong class="source-inline">setProperty()</strong>:<p class="source-code">for (int i = 1; i &lt; args.length; i++) {</p><p class="source-code">    String [] keyValue = args[i].split("=");</p><p class="source-code">    properties.setProperty(keyValue[0], keyValue[1]);</p><p class="source-code">}</p></li>
				<li>We are going to be writing to a file, but instead of using a stream that will be inputting data, we will use one that will be outputting data. Its name is simple to infer, <strong class="source-inline">FileOutputStream</strong>. The declaration of a variable of that class will be as follows:<p class="source-code">FileOutputStream fileOutputStream = new FileOutputStream(pathString);</p></li>
				<li>To add some comments to the properties file, we simply need to add a parameter to the <strong class="source-inline">store()</strong> method. In this case, just to add some contextual information, let's add a timestamp by calling the following:<p class="source-code">java.time.LocalDate.now()</p></li>
				<li>We call the <strong class="source-inline">store()</strong> method, which will send the properties into the file. We will be overwriting whatever existed in it before. This call uses, as an argument, the output <strong class="source-inline">Stream</strong> and whatever comment we have chosen:<p class="source-code">properties.store(fileOutputStream, "# modified on: " + java.time.LocalDate.now());</p></li>
				<li>To improve the program's usability, make a method that will iterate through the whole properties set and print it out. In that way, the user can see whether they wrote things properly:<p class="source-code"><a id="_idTextAnchor198"/>public static void PrintOutProperties(Properties properties) {</p><p class="source-code">    Enumeration keys = properties.keys();</p><p class="source-code">    for (int i = 0; i &lt; properties.size(); i++) {</p><p class="source-code">        String key = keys.nextElement().toString();</p><p class="source-code">        System.out.println( key + ": " + properties.getProperty(key) );</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Run the code with, for example, the following call in the CLI. In this case, we are intentionally modifying the file we have been working with throughout the chapter. The program will print out the modified set. Please note that there is no clear order to the key-value pairs:<p class="source-code">[...]/Exercise02$ java Exercise02 user.properties name=Pedro</p><p class="source-code">age: 37</p><p class="source-code">familyName: Rodriguez</p><p class="source-code">name: Pedro</p><p class="source-code">bgColor: #000000</p><p class="source-code">userName: ramiroz</p></li>
				<li>Open the resulting file in a text editor and see whether your changes took effect or not. Also note that the comments, as well as the <strong class="source-inline">\</strong> sign added by the <strong class="source-inline">store()</strong> method to avoid the color parameter (which is expressed in HEX format using the hashtag symbol) being misunderstood as a comment.</li>
				<li>You could now consider making other modifications to the program so it can clear up an existing file, append several files, and more. You could do that using different commands as arguments. The code for the full exercise is available on GitHub: <a href="https://packt.live/2JjUHZL">https://packt.live/2JjUHZL</a></li>
			</ol>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor199"/>What are Streams?</h2>
			<p>Streams in Java are sequences of bytes and eventually, by extension, also objects. You can understand a stream as a flow of data between two places. Creating a variable of the stream type is like opening a peephole to look into a pipe carrying water between two containers and seeing the water passing through. What we are trying to say is that data inside a stream is always changing. </p>
			<p>As we have seen before, we have two different ways of looking at things in this chapter: one through the lens of the <strong class="source-inline">java.io</strong> API and one through the <strong class="source-inline">java.nio</strong> API. While the second one works at a more abstract and therefore easier level, the first one is extremely powerful and low-level. Continuing with the water analogy, <strong class="source-inline">java.io</strong> would allow you to see the drops, while <strong class="source-inline">java.nio</strong> would let you play only with 1-liter bottles at a time. Each one of them has its advantages.</p>
			<p>Streams in <strong class="source-inline">java.io</strong> can be as granular as going down to the level of the byte. If we were, for example, to look at a stream of sound data coming from the computer's microphone input, we would see the different bytes representing the sound, one by one. The other API, <strong class="source-inline">java.nio</strong> is buffer-oriented, and not so much stream-oriented. While this is true, there is a way to work with streams in <strong class="source-inline">java.nio</strong>. Because of its simplicity, in this section, we will see an example relating to <strong class="source-inline">java.nio</strong>, while in the following section, we will deal with streams using the API that is best prepared is to handle them: <strong class="source-inline">java.io</strong>.</p>
			<p>Streams in <strong class="source-inline">java.nio</strong> are sequences of objects (not arbitrary unsorted data). Since those objects belong to specific classes, streams offer the possibility of applying the objects' corresponding methods to the stream directly. The result of applying a method to a stream is yet another stream, which means that methods can, therefore, be pipelined.</p>
			<p>We have seen different streams in this chapter, mainly because streams play such a big role in Java that it is almost impossible to do any kind of file-related example without using them. Now you will see how they work in more depth. This will help you understand some of the aspects that may not have been so clear to you so far.</p>
			<p>The nature of streams is typically hard to grasp in the first place. As mentioned, they are not plain data structures. Information is arranged in the form of objects. Input is taken from <strong class="source-inline">Arrays</strong>, I/O channels in the program, or <strong class="source-inline">Collections</strong>. The kinds of operation we can perform on streams are as follows:</p>
			<ul>
				<li><strong class="source-inline">map</strong> (intermediate): This will let you map objects following a predicate that you can give as an argument.</li>
				<li><strong class="source-inline">filter</strong> (intermediate): This is used to exclude some elements from the whole stream.</li>
				<li><strong class="source-inline">sorted</strong> (intermediate): This will sort the stream.</li>
				<li><strong class="source-inline">collect</strong> (terminal): This will put the results of the different operations into an object a form, for example, a list.</li>
				<li><strong class="source-inline">forEach</strong> (terminal): This will iterate through all of the objects in the stream.</li>
				<li><strong class="source-inline">reduce</strong> (terminal): This operates the stream to answer a single value.</li>
			</ul>
			<p>We have marked each one of the operations with either intermediate or terminal. The former means that the operation that will be performed will give another stream as a result, and therefore it should be possible to chain another operation onto it afterward. The latter means that there cannot be further operations performed after that one has finished. </p>
			<p>Until now, you have seen some of those operations in action in this chapter. You can go back to the examples where those operations showed up and revisit them. It will make it a lot clearer what <strong class="source-inline">filter()</strong>, <strong class="source-inline">collect()</strong>, and <strong class="source-inline">forEach()</strong> are doing. Let's see the other three operations in action:</p>
			<p class="source-code">import java.io.IOException;</p>
			<p class="source-code">import java.nio.file.*;</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class Example11 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        String pathString = System.getProperty("user.home") + "/javaTemp/numbers.txt";</p>
			<p class="source-code">        Path pathFile = Paths.get(pathString);</p>
			<p class="source-code">        // if the numbers file doesn't exist, create a file with 10 random numbers</p>
			<p class="source-code">        // between 0 and 10, so that we can make something with them</p>
			<p class="source-code">        if (Files.notExists(pathFile)) {</p>
			<p class="source-code">            int [] numbers = new int[10];</p>
			<p class="source-code">            for (int i = 0; i &lt; 10; i++) {</p>
			<p class="source-code">                numbers[i] = (int) (Math.random() * 10);</p>
			<p class="source-code">            }</p>
			<p>The complete code of <strong class="source-inline">Example11.java</strong> is available at <strong class="source-inline">Chapter 1/Code.java</strong>.</p>
			<p>This example is divided into two parts. The first half of the program checks whether a file called <strong class="source-inline">numbers.txt</strong> exists in the <strong class="source-inline">javaTemp</strong> folder that we have been using throughout the chapter. If this file doesn't exist, the program creates it with <strong class="source-inline">Files.createFile(pathFile)</strong> and then populates it with 10 random numbers previously stored in an array of <strong class="source-inline">int</strong> called <strong class="source-inline">numbers</strong>. The call to <strong class="source-inline">Files.write(pathFile, Arrays.asList("" + n), StandardOpenOption.APPEND)</strong> is responsible for adding each number in the array as separate lines in the file. The resulting file will look like this:</p>
			<p class="source-code">&lt;contents of javaTemp/numbers.txt&gt;</p>
			<p class="source-code">5</p>
			<p class="source-code">3</p>
			<p class="source-code">1</p>
			<p class="source-code">3</p>
			<p class="source-code">6</p>
			<p class="source-code">2</p>
			<p class="source-code">6</p>
			<p class="source-code">2</p>
			<p class="source-code">7</p>
			<p class="source-code">8</p>
			<p>The idea of having one number per line is that we can then read the file as a list, transform the list into a stream, and then start making different operations. The simplest operation consists of calling <strong class="source-inline">fileContent.forEach(System.out::print)</strong>, which will print the raw data as the output:</p>
			<p class="source-code">Raw data</p>
			<p class="source-code">5313626278</p>
			<p>Before applying other operations, such as <strong class="source-inline">sorted()</strong>, we need to transform the data into a stream, something that is done with the <strong class="source-inline">stream()</strong> method. This is done using the following:</p>
			<p class="source-code">fileContent.stream().sorted().forEach(System.out::print) </p>
			<p>The result of this operation will be sorted. Equal values will show up side by side, repeated:</p>
			<p class="source-code">Sorted data</p>
			<p class="source-code">1223356678</p>
			<p>With <strong class="source-inline">map()</strong>, we will be able to handle the data and perform different operations on it. For example, here, we multiply it by 2 and print it to the terminal: </p>
			<p class="source-code">fileContent.stream().map( x -&gt; Integer.parseInt(x)*2).forEach(System.out::print):</p>
			<p>The result is as follows:</p>
			<p class="source-code">Mapped data</p>
			<p class="source-code">106261241241416</p>
			<p>Finally, there are different terminations that can be used. To do this, we will use lambda expressions, which are not introduced until a much later chapter. However, the following is easy enough to not need any further explanation. To perform the sum of all the numbers, we need to do the following operation:</p>
			<p class="source-code">System.out.println(</p>
			<p class="source-code">                    fileContent</p>
			<p class="source-code">                            .stream()</p>
			<p class="source-code">                            .map(x -&gt; Integer.parseInt(x))</p>
			<p class="source-code">                            .reduce(Integer::sum));</p>
			<p>The following is the result:</p>
			<p class="source-code">Sum of data</p>
			<p class="source-code">Optional[43]</p>
			<p>Note that, when reading the file, we have read it as a <strong class="source-inline">List</strong> of <strong class="source-inline">String</strong>, and therefore, the numbers are stored as strings. This means that, in order to operate them as numbers, we need to cast them back into integers, which is done through the call to <strong class="source-inline">Integer.parseInt(x)</strong>.</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor200"/>The Different Streams of the Java Language</h2>
			<p>To discuss types of streams, we need to take one step back and move away from <strong class="source-inline">java.nio</strong> and into <strong class="source-inline">java.io</strong>. This API is the one that has the best support for streams. Depending on the situation, streams can either go into the program or out from the program. This gives us two main interfaces for streams: <strong class="source-inline">InputStream</strong> and <strong class="source-inline">OutputStream</strong>. </p>
			<p>Within each of those two main categories, there are four ways to look at streams from the perspective of the type of data they are dealing with: <strong class="source-inline">File</strong>, <strong class="source-inline">ByteArray</strong>, <strong class="source-inline">Filter</strong>, or <strong class="source-inline">Object</strong>. In other words, there is a <strong class="source-inline">FileInputStream</strong> class, a <strong class="source-inline">FileOutputStream</strong> class, a <strong class="source-inline">ByteArrayInputStream</strong> class, and more.</p>
			<p>According to Javadocs, it is important to understand that there is a hierarchy of streams. All streams are built on top of byte streams. But we should try, as much as possible, to use the kind of stream type that is the closest in the hierarchy to the kind of data we are using. For example, if we were to deal with a series of images coming from the internet, we should avoid working at a low level with byte streams to store the images, and we should use object streams instead.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Read more about streams in the official Java documentation at <a href="https://docs.oracle.com/javase/tutorial/essential/io/bytestreams.html">https://docs.oracle.com/javase/tutorial/essential/io/bytestreams.html</a>.</p>
			<p>How would it then open and print out a file using java.io and <strong class="source-inline">FileInputStream</strong>? We saw a bit of this when dealing with the properties files. Let's do the lowest-level example possible that will read a file and print out its contents byte by byte:</p>
			<p class="source-code">import java.io.FileInputStream;</p>
			<p class="source-code">import java.io.IOException;</p>
			<p class="source-code">public class Example12 {</p>
			<p class="source-code">    public static void main(String[] args) throws IOException {</p>
			<p class="source-code">        FileInputStream inStream = null;</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            inStream = new FileInputStream(</p>
			<p class="source-code">                     System.getProperty("user.home") + "/javaTemp/temp.txt");</p>
			<p class="source-code">            int c;</p>
			<p class="source-code">            while ((c = inStream.read()) != -1) {</p>
			<p class="source-code">                System.out.print(c);</p>
			<p class="source-code">            }</p>
			<p class="source-code">        } finally {</p>
			<p class="source-code">            if (inStream != null) {</p>
			<p class="source-code">                inStream.close();</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This example opens the temp.txt file we created earlier in the chapter and prints out its contents. Remember that it contained some plain text in the lines of <strong class="source-inline">hola\nHola,\nme da un ...</strong>. When looking at the terminal, what you will read will be something like this:</p>
			<p class="source-code">1041111089710721111089744101091013210097321171103211410110211410111599111441011211111432102971181111146310</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>You might be wondering – what happened to the text? As you know, every symbol of the English alphabet is represented by a standard called ASCII. This standard represents each symbol with a number. It differentiates uppercase from lowercase, different symbols such as exclamation marks or hashtags, numbers, and more. An excerpt of the ASCII table representing the lowercase symbols is as follows:</p>
			<p class="source-code">97    a    107    k    117    u</p>
			<p class="source-code">98    b    108    l    118    v</p>
			<p class="source-code">99    c    109    m    119    w</p>
			<p class="source-code">100    d    110    n    120    x</p>
			<p class="source-code">101    e    111    o    121    y</p>
			<p class="source-code">102    f    112    p    122    z</p>
			<p class="source-code">103    g    113    q</p>
			<p class="source-code">104    h    114    r</p>
			<p class="source-code">105    I    115    s</p>
			<p class="source-code">106    j    116    t</p>
			<p>If you start taking the stream of numbers you get and parse it using the table for the ASCII symbols, you will see that <strong class="source-inline">104</strong> corresponds to <strong class="source-inline">h</strong>, <strong class="source-inline">111</strong> to <strong class="source-inline">o</strong>, <strong class="source-inline">108</strong> to <strong class="source-inline">l</strong>, and <strong class="source-inline">97</strong> to <strong class="source-inline">a</strong>. If you had a full ASCII table (including capitals, symbols, and numbers) you would be able to decode the whole message. We did get the content of the file, but we didn't interpret the data we got in our program, which rendered the output unreadable. This is the reason why you should try to use a higher-level kind of stream, which will stop you having to decode the information at such a low level, which for characters – as in this example – is not such a big deal. But data transfers between software entities can get complex very quickly.</p>
			<p>Let's examine another way of performing the same operation of opening the file, but with a different type of stream. In this case, we will use <strong class="source-inline">FileReader</strong>, which is a different type of stream, on top of <strong class="source-inline">FileInputStream</strong>. To get the stream in the form of characters and pass it over to <strong class="source-inline">BufferedReader</strong>, which is a stream class that includes the possibility of reading full lines of a text. Since we know that our file contains text arranged in lines, this will probably be the best way to see the contents of the file in a neat way:</p>
			<p class="source-code-heading">Example13.java</p>
			<p class="source-code">5  public class Example13 {</p>
			<p class="source-code">6      public static void main(String[] args) throws IOException {</p>
			<p class="source-code">7          BufferedReader inStream = null;</p>
			<p class="source-code">8  </p>
			<p class="source-code">9          try {</p>
			<p class="source-code">10             FileReader fileReader = new FileReader(</p>
			<p class="source-code">11                     System.getProperty("user.home") + "/javaTemp/temp.txt");</p>
			<p class="source-code">12             inStream = new BufferedReader(fileReader);</p>
			<p class="source-code">13             String line;</p>
			<p class="source-code">14             while ((line = inStream.readLine()) != null) {</p>
			<p class="source-code">15                 System.out.println(line);</p>
			<p class="source-code">16             }</p>
			<p class="source-code-link"><a href="https://packt.live/2BsKIgh">https://packt.live/2BsKIgh</a></p>
			<p>The output of this example will be what we expected to see in the first place:</p>
			<p class="source-code">hola</p>
			<p class="source-code">Hola,</p>
			<p class="source-code">me da un refresco,</p>
			<p class="source-code">por favor?</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>In a nutshell, the information is the same, but it matters how we look at it. Using a higher-level class from the stream family will offer us better methods to handle the same information in a different yet more usable way.</p>
			<p>There is another concept that we haven't introduced yet, and that is the difference between buffered streams and unbuffered streams. When working at a low level with java.io, you will be most likely working in an unbuffered way. This means that you will be addressing the OS directly from your code. Those exchanges are computationally hungry, especially in comparison with loading any information into a buffer inside the JVM and operating directly there instead (it doesn't mean that it will not be accessing the OS directly — it will, but it will optimize its use. </p>
			<p>This example is clearly using <strong class="source-inline">BufferedReader</strong>, which differs from the previous one. We mentioned earlier in the chapter how <strong class="source-inline">java.nio</strong> works with buffers – this means that, unlike <strong class="source-inline">java.io</strong>, it doesn't offer the possibility of doing those direct calls to the OS. In a way, it is better because it is less prone to errors. If you have a properly constructed API with all the methods needed to perform whatever you want to do, you should avoid using other less optimal tools.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor201"/>What are Sockets?</h2>
			<p>A socket is the endpoint of a bidirectional communication channel between two programs operating over a network. It is as if a virtual cable was connecting those two programs, offering the possibility of sending data back and forth. Java's APIs have classes to easily construct programs at both ends of the communication. The exchanges on, for example, the internet happen over a TCP/IP network, where we distinguish between the roles of those that participate in the communication. There are servers and clients. The former can be implemented using the ServerSocket class, while the latter can use the socket class.</p>
			<p>The way the communication process works involves both parties. The client will send a request to the server asking for a connection. This is done through one of the available TCP/IP ports on your computer. If the connection is accepted, the socket is opened at both ends. The endpoints at the server and the client will be uniquely identifiable. This means that you will be able to use that port for multiple connections.</p>
			<p>Knowing how to deal with sockets, together with streams, will allow you to work with information coming directly from the internet, which will bring your programs to the next level. In the following sections, we are going to see how to implement a client and a server to prototype this communication.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">While working with these examples, make sure your computer's security system (firewalls and the like) allow communicating over whatever port you decide to use. It wouldn't be the first time someone has wasted several hours thinking their code is wrong when the issue is somewhere else.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor202"/>Creating a SocketServer</h2>
			<p>Trying to read data from sockets requires a little involvement from existing networked resources. If you want to have a program that connects to a server, you will require a known server before you can even try the connection. On the internet, there are servers offering the possibility of connecting, opening a socket, sending data, and receiving it back. These servers are called EchoServers—a name that leaves little doubt about what they do.</p>
			<p>On the other hand, you can implement your own server and play it safe. Oracle offers a simple example of an EchoServer for you to test. This is going to be a new kind of challenge because you are going to need to run two programs on your computer at once: the EchoServer and whatever client you will implement.</p>
			<p>Let's start by implementing the EchoServer that you can get from <a href="https://packt.live/33LmH0k">https://packt.live/33LmH0k</a>. The code for you to analyze is included in the next example. Note that we have removed the opening disclaimer and code comments to keep it short:</p>
			<p class="source-code-heading">Example14.java</p>
			<p class="source-code">14         try (</p>
			<p class="source-code">15             ServerSocket serverSocket =</p>
			<p class="source-code">16                 new ServerSocket(Integer.parseInt(args[0]));</p>
			<p class="source-code">17             Socket clientSocket = serverSocket.accept();     </p>
			<p class="source-code">18             PrintWriter out =</p>
			<p class="source-code">19                 new PrintWriter(clientSocket.getOutputStream(),                      true);                   </p>
			<p class="source-code">20             BufferedReader in = new BufferedReader(</p>
			<p class="source-code">21                 new InputStreamReader(clientSocket.getInputStream()));</p>
			<p class="source-code">22         ) {</p>
			<p class="source-code">23             String inputLine;</p>
			<p class="source-code">24             while ((inputLine = in.readLine()) != null) {</p>
			<p class="source-code">25                 out.println(inputLine);</p>
			<p class="source-code">26             }</p>
			<p class="source-code">27         } catch (IOException e) {</p>
			<p class="source-code">28             System.out.println("Exception caught when trying to listen on port "</p>
			<p class="source-code">29                 + portNumber + " or listening for a connection");</p>
			<p class="source-code">30             System.out.println(e.getMessage());</p>
			<p class="source-code">31         }</p>
			<p class="source-code-link"><a href="https://packt.live/2oLURSR">https://packt.live/2oLURSR</a></p>
			<p>The first part of the code checks that you have selected a port for your server to be listening to. This port number is given as an argument on the CLI:</p>
			<p class="source-code">if (args.length != 1) {</p>
			<p class="source-code">    System.err.println("Usage: java EchoServer &lt;port number&gt;");</p>
			<p class="source-code">    System.exit(1);</p>
			<p class="source-code">}</p>
			<p>If no port was chosen, this program will simply exit. Remember, as we mentioned earlier, to make sure that whatever port you use, it is not blocked by your computer's firewall.</p>
			<p>The call to <strong class="source-inline">ServerSocket(Integer.parseInt(args[0]))</strong> will start the object of the <strong class="source-inline">ServerSocket</strong> class, configuring the port defined in the arguments to call the program as the one to listen to. Later, <strong class="source-inline">serverSocket.accept()</strong> will block the server and make it wait until a connection arrives. Once it arrives, it will be automatically accepted. </p>
			<p>In the beginning code in this example, there are two different streams: <strong class="source-inline">BufferReader in</strong> for the input, and <strong class="source-inline">PrinterWriter out</strong> for the output. As soon as a connection is established, <strong class="source-inline">in</strong> will get the data, and <strong class="source-inline">out</strong> will send it – without any further processing—back to the socket. The server program will run until forcing an exit when pressing <em class="italic">Ctrl</em>+<em class="italic">C</em> on the terminal.</p>
			<p>To get the server started, you will need to compile it using the build icon (the hammer) and call it from the terminal using a specific port name. Try port 8080, because that is typically used for experiments like the one, we are going to do now:</p>
			<p class="source-code">usr@localhost:~/IdeaProjects/[...]/Example14$ java Example14 8080</p>
			<p>If everything goes as planned, the program will start running and will not print any messages. It is there just waiting for a connection to be made.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Remember that, by default, your own computer always has the IP number 127.0.0.1, which allows you to figure out the IP number of your computer in the network. We will use this for the connection with the client.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor203"/>Writing Data on and Reading Data from a Socket</h2>
			<p>While our server runs in the background, we will need to produce a simple program that will open a socket and send something to the server. To do this, you need to create a new project in the IDE but in a separate window. Remember that your server is currently running!</p>
			<p>The simplest client that you can produce is Oracle's companion to the <em class="italic">EchoServer</em>. For obvious reasons, it is called <em class="italic">EchoClient</em>, and you can find it at <a href="https://packt.live/2PbLNBx">https://packt.live/2PbLNBx</a>.</p>
			<p class="source-code-heading">Example15.java </p>
			<p class="source-code">15         try (</p>
			<p class="source-code">16                 Socket echoSocket = new Socket(hostName, portNumber);</p>
			<p class="source-code">17                 PrintWriter out =18                   new PrintWriter(echoSocket.getOutputStream(), true);</p>
			<p class="source-code">19                 BufferedReader in =20                   new BufferedReader(</p>
			<p class="source-code">21                      new InputStreamReader(echoSocket.getInputStream()));</p>
			<p class="source-code">22                 BufferedReader stdIn =23                   new BufferedReader(</p>
			<p class="source-code">24                      new InputStreamReader(System.in))</p>
			<p class="source-code">25         ) {</p>
			<p class="source-code">26             String userInput;</p>
			<p class="source-code">27             while ((userInput = stdIn.readLine()) != null) {</p>
			<p class="source-code">28                 out.println(userInput);</p>
			<p class="source-code">29                 System.out.println("echo: " + in.readLine());</p>
			<p class="source-code">30             }</p>
			<p class="source-code-link"><a href="https://packt.live/33OrP3t">https://packt.live/33OrP3t</a></p>
			<p>Note that, in this case, instead of creating a <strong class="source-inline">SocketServer</strong> object, we create a <strong class="source-inline">Socket</strong> object. This second program introduces the idea of using one of the system streams to capture data and send it to the socket: <strong class="source-inline">System.in</strong>. This program will run for as long as the input in <strong class="source-inline">System.in</strong> is <strong class="source-inline">not null</strong>. This is something that cannot really be achieved through direct interaction with System.in, because we will be just pressing keys on the keyboard. Therefore, you will need to call <em class="italic">Ctrl</em> + <em class="italic">C</em> to stop the client, just as was the case with the server.</p>
			<p>Note how sending data to the server is done with <strong class="source-inline">out.println()</strong>, where out is a <strong class="source-inline">PrinterWriter</strong> object, a stream, that is constructed on top of the <strong class="source-inline">Socket</strong>. On the other hand, to read the incoming <strong class="source-inline">Socket</strong>, we have implemented a <strong class="source-inline">BufferedReader</strong> object called <strong class="source-inline">in</strong>. Since it is buffered, we can poll the object whenever we want. The call to <strong class="source-inline">out.readLine()</strong> and <strong class="source-inline">in.readLine()</strong> is blocking. It will not stop reading from <strong class="source-inline">System.in</strong> or from the socket until the end of the line has been reached. </p>
			<p>This makes this reader synchronous because it waits for the user to type, sends the data, and, finally, waits until getting an answer from the socket.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Every operating system makes three different system streams available to the JVM: System.in, System.out, and System.err. As they are streams, you can use the full power of the Stream classes to read data from them, put them into buffers, parse them, and so on.</p>
			<p>To get the client started, you will need to compile it using the build icon (the hammer) and call it from the terminal using a specific IP and port name. Try the IP 127.0.0.1 and port 8080. Remember that you need to start the server before you start the client:</p>
			<p class="source-code">usr@localhost:~/IdeaProjects/[...]/Example14$ java Example15 127.0.0.1 8080</p>
			<p>From that moment on, and until you issue the Ctrl + C command, for as long as the server is connected, you will be able to type whatever you want on the terminal, and when you press Enter, it will be sent to and from the server. Upon arrival, the client will write it to the terminal by adding the message echo before it. We highlight the response coming from the server by making the typeface bold:</p>
			<p class="source-code">Hello</p>
			<p class="source-code">echo: Hello</p>
			<p>Also, when forcing an exit on the client, it will force an exit on the server.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor204"/>Activity 2: Improving the EchoServer and EchoClient Programs</h2>
			<p>In this activity, you will have to make improvements to the programs in the last two sections. First, you will have to add some text to the data relayed on the server. This will make it easier for the user to understand that the data was sent back from the server. Let's make it a counter that will act as a sort of unique ID for the exchange. In this way, the answer from the server will be shown with a number added to the message:</p>
			<p class="source-code">Hello</p>
			<p class="source-code">echo: 37-Hello</p>
			<p>On the other hand, you should add a command in the client that will send a termination signal to the server. This command will exit the server, and then exit the client. To terminate any of the programs, you can call <strong class="source-inline">System.exit()</strong> after sending a message to the terminal informing the user that the program is ending. As a termination command, you could make something simple, such as a message that contains the word 'bye'. </p>
			<ol>
				<li value="1">The expected results will require you to modify both the server and the client in a very similar way. On the client-side, you will have to do something like the following:<p class="source-code">while ((userInput = stdIn.readLine()) != null) {</p><p class="source-code">    out.println(userInput);</p><p class="source-code">    if (userInput.substring(0,3).equals("bye")) {</p><p class="source-code">        System.out.println("Bye bye!");</p><p class="source-code">        System.exit(0);</p><p class="source-code">    }</p><p class="source-code">    System.out.println("echo: " + in.readLine());</p><p class="source-code">}</p></li>
				<li>On the server, the modifications should look like the following:<p class="source-code">int contID = 0;</p><p class="source-code">while ((inputLine = in.readLine()) != null) {</p><p class="source-code">    contID++;</p><p class="source-code">    out.println(contID + "-" + inputLine);</p><p class="source-code">    if (inputLine.substring(0,3).equals("bye")) {</p><p class="source-code">        System.out.println("Bye bye!");</p><p class="source-code">        System.exit(0);</p><p class="source-code">    }</p><p class="source-code">}</p><p>The expected interaction between the server and the client should be as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer077">
					<img alt="Figure 8.1: The interaction between the client and the server. &#13;&#10;" src="image/C13927_08_01.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1: The interaction between the client and the server. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 555.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor205"/>Blocking and Non-Blocking Calls</h2>
			<p>This is a topic we have been covering in this chapter, but we have not addressed it directly. The <strong class="source-inline">java.io</strong> read and write operations are blocking. This means that the program will wait until the data is fully read or until the data has been fully written. However, working with buffered streams as implemented in <strong class="source-inline">java.nio</strong> allows you to check whether the data is ready to be read. When writing data, <strong class="source-inline">java.nio</strong> will copy the data to the buffer and let the API write the data to the channel by itself. This allows an entirely different programming style where we don't need to wait for the operations to happen. At the same time, this means that we will not have low-level control of the communication. A different part of the JVM performs that action for us.</p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor206"/>Summary</h1>
			<p>In this chapter, you have been introduced to two main APIs in the Java language: java.io and java.nio. They have some overlapping functions, and they are needed to deal with streams and files. On top of that, you have seen how to work with sockets, a natural source of data that can only be handled with streams.</p>
			<p>There have been a series of examples looking at how to capture data from the terminal, which in the end happened to be <strong class="source-inline">stream (System.in)</strong>. You then explored how to process it using streams with all sorts of high-level functions, such as filter, map, sorted, foreach, reduce, and collect. You have seen how to open files and properties files, and how java.nio is very capable with the former, but not with the latter.</p>
			<p>From a more practical perspective, this chapter has introduced one important technique that was only explained in theory in an earlier chapter: how to use <strong class="source-inline">finally</strong> to close streams, and avoid potential memory issues during runtime. You have seen that, in order to handle exceptions cleanly, you may have to move blocks of code into methods. In this way, you can avoid throwing exceptions and can always process them with try-catch statements.</p>
			<p>In order to play around with sockets, you have experimented with building an EchoServer and an EchoClient. You had two different programs interacting with one another and sending data over the internet. You saw how to run both the server and the client on your own computer, and it is now time to try those two programs running on different computers.  </p>
			<p>Finally, the two activities in this chapter introduced you to creating or modifying properties files on the fly by typing key-value pairs as arguments to a program, and remotely controlling another program via commands over the internet.</p>
			<p>In the next chapter, you'll learn about HTTP and how to create a program that connects to a specific web server and downloads data.</p>
		</div>
	</body></html>