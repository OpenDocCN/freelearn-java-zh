- en: Flow Control and Backpressure
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流控制和背压
- en: In previous chapters, we have discussed how Reactor offers effective controls
    to check the production rate. This mechanism is often called backpressure. However,
    there are instances where backpressure is not an efficient strategy. In such cases,
    Reactor offers a number of flow control optimizations that can be used without
    backpressure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了Reactor如何提供有效的控制来检查生产率。这种机制通常被称为背压。然而，在某些情况下，背压并不是一个有效的策略。在这种情况下，Reactor提供了一系列无需背压即可使用的流控制优化。
- en: 'In this chapter, we will cover the following topics regarding flow control
    and backpressure:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍有关流控制和背压的以下主题：
- en: GroupBy
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分组
- en: Buffer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区
- en: Window
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口
- en: Sample
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例
- en: Backpressure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背压
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Java Standard Edition, JDK 8 or above
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java标准版，JDK 8或更高版本
- en: IntelliJ IDEA IDE 2018.1 or above
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ IDEA IDE 2018.1或更高版本
- en: The GitHub link for this chapter is [https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter07).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的GitHub链接为[https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter07)。
- en: Flow control
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流控制
- en: Flow control is all about managing the rate of events so that a producer does
    not overwhelm its subscribers when raising a large number of events. A fast producer
    will push many events to its subscribers. Each of the subscribers will process
    these events as it receives them, one at a time. This sequential process can be
    quite inefficient, as each event is delivered over a wire.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 流控制全部关于管理事件速率，以确保在引发大量事件时，生产者不会压倒其订阅者。快速生产者会将许多事件推送到其订阅者。每个订阅者将按接收顺序逐个处理这些事件。这种顺序处理过程可能相当低效，因为每个事件都是通过电线传输的。
- en: In order to improve the efficiency, there are operators in Reactor that allow
    the producer to raise events in chunks. Each chunk of events is delivered to the
    subscriber, allowing them to work on many events simultaneously.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高效率，Reactor中有一些运算符允许生产者在块中引发事件。每个事件块都发送给订阅者，使他们能够同时处理多个事件。
- en: The groupBy operator
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`groupBy`运算符'
- en: 'The `groupBy()` operator converts the `Flux<T>` into batches. The operator
    associates a key with each element of the `Flux<T>`. It then groups elements that
    have the same key. These groups are then emitted by the operator. This is depicted
    in the following diagram:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupBy()`运算符将`Flux<T>`转换为批次。该运算符将每个元素与`Flux<T>`中的一个键相关联。然后它将具有相同键的元素分组。然后，该运算符发出这些组。这在上面的图中有所描述：'
- en: '![](img/77b226df-de1b-4a9f-9634-4fcfb7001657.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/77b226df-de1b-4a9f-9634-4fcfb7001657.png)'
- en: 'It is important to note that elements may lose their original sequence order
    once they are grouped. The order is enforced by the logic of the key generation.
    Since each element is only associated with one key, the generated groups are not
    empty. All the generated groups are disjointed by nature. Let''s try to generate
    some groups for our Fibonacci series:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，一旦元素被分组，它们可能会失去其原始的顺序。顺序是由键生成逻辑强制执行的。由于每个元素只与一个键相关联，因此生成的组不为空。所有生成的组在本质上都是不相交的。让我们尝试为我们的斐波那契数列生成一些组：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, we have carried out the following steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们执行了以下步骤：
- en: We partitioned the original dataset into groups of `Divisible by 2`, `Divisible
    by 3`, `Divisible by 5`, `Divisible by 7`, and so on.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将原始数据集划分为`能被2整除`、`能被3整除`、`能被5整除`、`能被7整除`等组的集合。
- en: '`groupBy` is emitted these partitioned datasets as a key-value pair. The key
    is a string and the value is `List<Long>`.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`groupBy`运算符将这些分区数据集作为键值对发出。键是一个字符串，值是`List<Long>`。'
- en: The datasets were combined using the `concatMap` operator. We also printed the
    key using the operator.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`concatMap`运算符合并了数据集。我们还使用该运算符打印了键。
- en: Finally, we printed the `List` in the `Subscribe` function.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在`Subscribe`函数中打印了`List`。
- en: 'Let''s run our test case to confirm the output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的测试用例以确认输出：
- en: '![](img/81d4fbc3-974f-430a-bc7a-f09efef88a45.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/81d4fbc3-974f-430a-bc7a-f09efef88a45.png)'
- en: The buffer operator
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲区运算符
- en: 'The `buffer()` operator gathers all `Flux<T>` elements and emits them as a
    `List<T>`. Unlike groups generated by the `groupBy()` operator, all the elements
    in the `List<T>` buffer are in their original order. Alternatively, we could provide
    a `batchSize` to the operator. The operator will then generate *N* lists, each
    of which will have a specified number of elements. Let''s try to use the buffer
    operator on our Fibonacci series:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffer()` 操作符收集所有 `Flux<T>` 元素并将它们作为 `List<T>` 发出。与由 `groupBy()` 操作符生成的组不同，`List<T>`
    缓冲区中的所有元素都保持其原始顺序。或者，我们也可以向操作符提供一个 `batchSize`。然后，操作符将生成 *N* 个列表，每个列表将包含指定数量的元素。让我们尝试在我们的斐波那契数列上使用缓冲操作符：'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding code, we have done the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: We partitioned the original dataset into buffer lists of 10 elements each
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将原始数据集划分为每个包含10个元素的缓冲列表
- en: We then printed the list using the `subscribe` function
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们然后使用 `subscribe` 函数打印了列表
- en: 'Let''s run our test case to confirm the output. We can see that the Fibonacci
    elements are emitted in a single `List<Long>`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的测试用例以确认输出。我们可以看到斐波那契元素以单个 `List<Long>` 的形式发出：
- en: '![](img/a10c997e-0377-45cf-8c58-7c139903bc8d.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a10c997e-0377-45cf-8c58-7c139903bc8d.png)'
- en: There are many variants of the `buffer()` operator. Let's look at a few of them.
    Each of these generates multiple list buffers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffer()` 操作符有许多变体。让我们看看其中的一些。这些都会生成多个列表缓冲区。'
- en: 'The `buffer(maxSize, skipSize)` operator takes two arguments. The first argument
    is the max size of each buffer. The second argument is the number of elements
    that must be skipped before starting a new buffer. The buffer lists generated
    by the operator have the following characteristics:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffer(maxSize, skipSize)` 操作符接受两个参数。第一个参数是每个缓冲区的最大大小。第二个参数是在开始新缓冲区之前必须跳过的元素数量。由操作符生成的缓冲区列表具有以下特征：'
- en: If the `maxSize` is larger than the `skipSize`, the buffers are overlapping
    in nature. The next buffer starts from the element at the position specified by
    the `skipSize` of the previous buffer. This means that elements are duplicated
    across all buffers.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `maxSize` 大于 `skipSize`，则缓冲区在本质上是有重叠的。下一个缓冲区从上一个缓冲区的 `skipSize` 位置指定的元素开始。这意味着元素在所有缓冲区中都是重复的。
- en: If the `maxSize` is smaller than the `skipSize`, the buffers are disjointed
    in nature. The generated lists miss elements from the original `Flux<T>`.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `maxSize` 小于 `skipSize`，则缓冲区在本质上是不相交的。生成的列表会缺少原始 `Flux<T>` 中的元素。
- en: 'If the `skipSize` is `0`, then all lists are disjointed in nature. They do
    not miss any elements from the original `Flux<T>`. Consider the following code:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `skipSize` 为 `0`，则所有列表在本质上是不相交的。它们不会缺少原始 `Flux<T>` 中的任何元素。考虑以下代码：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code, we have done the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: We partitioned the original dataset into buffers of two elements each
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将原始数据集划分为每个包含两个元素的缓冲区
- en: Each of the buffer lists started at the fifth element, therefore dropping three
    elements
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个缓冲列表从第五个元素开始，因此丢弃了三个元素
- en: We printed the list in the `subscribe` function
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 `subscribe` 函数中打印了列表
- en: 'Let''s run the code to confirm the output. We can see that the Fibonacci elements
    are emitted in a single `List<Long>`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行代码以确认输出。我们可以看到斐波那契元素以单个 `List<Long>` 的形式发出：
- en: '![](img/0129c0fb-4fde-4600-91ea-b886d147ff03.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0129c0fb-4fde-4600-91ea-b886d147ff03.png)'
- en: 'The `bufferUntil` and `bufferWhile` variants take a predicate condition and
    aggregate elements until the condition is true. The `bufferWhile` operator generates
    a single buffer that contains all elements that match the condition. On the other
    hand, the `bufferUntil` operator buffers non-matching elements to a list. When
    it finds a matching element, it adds it to the current buffer. It then starts
    a new buffer to add the next incoming element. This process is shown in the following
    diagram:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`bufferUntil` 和 `bufferWhile` 变体接受一个谓词条件，并聚合元素直到条件为真。`bufferWhile` 操作符生成一个包含所有匹配条件的元素的单一缓冲区。另一方面，`bufferUntil`
    操作符将不匹配的元素缓冲到一个列表中。当它找到一个匹配的元素时，它将该元素添加到当前缓冲区。然后它开始一个新的缓冲区以添加下一个传入的元素。这个过程在以下图中展示：'
- en: '![](img/0fa957a0-164d-4277-984e-d1536c2fcbf4.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0fa957a0-164d-4277-984e-d1536c2fcbf4.png)'
- en: 'Another overloaded `buffer()` method enables us to generate buffer lists based
    on the time period. The operator accepts a duration and aggregates all elements
    during that period. It can therefore collect all events that happened during the
    first `Duration`, the second `Duration`, and so on, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重载的 `buffer()` 方法允许我们根据时间段生成缓冲区列表。操作符接受一个持续时间，并聚合该时间段内的所有元素。因此，它可以收集在第一个
    `Duration`、第二个 `Duration` 等期间发生的所有事件，如下所示：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, we have done the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: We partitioned the original data based on a 10-nanosecond time slice
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们根据10纳秒的时间切片将原始数据划分为分块
- en: Each of the buffer lists contained elements emitted during the time period
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个缓冲区列表都包含了在该时间段内发出的元素
- en: Finally, we printed the lists using the `subscribe` function
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用 `subscribe` 函数打印了列表
- en: 'Let''s run this code to confirm the output. We can see that Fibonacci elements
    are emitted as multiple `List<Long>`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这段代码以确认输出。我们可以看到斐波那契元素作为多个 `List<Long>` 发出：
- en: '![](img/f58603a7-ea36-435b-a1b3-4fb4b9c3eb7c.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f58603a7-ea36-435b-a1b3-4fb4b9c3eb7c.png)'
- en: 'The `buffer` operator offers a number of variants of the methods discussed
    here. All `buffer` methods provide a list, but only one of the overloaded methods
    allow us to convert a buffer into a collection dataset. We need to provide a supplier
    function to the overloaded `buffer` operator. This function is responsible for
    creating a collection instance. Let''s look at the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffer` 操作符提供了这里讨论的方法的多种变体。所有 `buffer` 方法都提供了一个列表，但只有重载方法之一允许我们将缓冲区转换为集合数据集。我们需要向重载的
    `buffer` 操作符提供一个供应商函数。这个函数负责创建集合实例。让我们看看以下代码：'
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we have done the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们做了以下操作：
- en: We partitioned the original dataset into buffers of a maximum of five elements
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将原始数据集划分为最多包含五个元素的分块
- en: Each of the buffers was emitted as a `HashSet`, which means that it contains
    only distinct elements
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个缓冲区都作为 `HashSet` 发出，这意味着它只包含不同的元素
- en: Finally, we printed the lists using the `subscribe` function
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用 `subscribe` 函数打印了列表
- en: 'Since we used a `HashSet`, we can see that it does not contain duplicate elements
    of the Fibonacci series:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了 `HashSet`，我们可以看到它不包含斐波那契数列的重复元素：
- en: '![](img/b95bb99a-69b9-4ac9-9fb7-01220a758f3d.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b95bb99a-69b9-4ac9-9fb7-01220a758f3d.png)'
- en: The window operator
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 窗口操作符
- en: The `window()` operator is similar to the `buffer()` operator. It also slices
    the original dataset, but emits each dataset as a processor, rather than as a
    new collection. Each processor serves as a publisher and emits items after subscribing
    to them. The `window` operator allows us to have a fixed window size, a time-based
    window, or a predicate-based window. Unlike the `buffer` operator, which allows
    us to build a single buffer for all published elements, the `window` operator
    does not allow you to publish elements in a single window.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`window()` 操作符与 `buffer()` 操作符类似。它也会切割原始数据集，但将每个数据集作为处理器发出，而不是作为新的集合。每个处理器在订阅项目后发出项目。`window`
    操作符允许我们有一个固定大小的窗口、基于时间的窗口或基于谓词的窗口。与允许我们为所有发布的元素构建单个缓冲区的 `buffer` 操作符不同，`window`
    操作符不允许你在单个窗口中发布元素。'
- en: 'The `window()` operator offers better memory utilization, as the items are
    emitted immediately rather than first being cached to a collection and then emitted
    once the correct collection size is achieved. The `window` operator also offers
    better memory usage than the buffer operator. This is depicted with the following
    code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`window()` 操作符提供了更好的内存利用率，因为项目会立即发出，而不是首先被缓存到一个集合中，然后在达到正确的集合大小时再发出。`window`
    操作符也比缓冲操作符提供了更好的内存使用。以下代码展示了这一点：'
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code, we have done the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: We partitioned the original data into windows with a maximum of 10 elements
    each
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将原始数据划分为每个最多包含10个元素的分块
- en: Each window is a type of `UnicastProcesser`, so it needed to be combined with
    the other generated windows using either `ConcatMap` or `flatMap`
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个窗口都是 `UnicastProcesser` 类型的一种，因此需要使用 `ConcatMap` 或 `flatMap` 将其他生成的窗口与之结合
- en: Finally, we printed the lists using the subscribe function
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用 `subscribe` 函数打印了列表
- en: 'Let''s run this code to confirm the output. We can see that the Fibonacci elements
    are emitted as multiple batches and then combined as one:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这段代码以确认输出。我们可以看到斐波那契元素作为多个批次发出，然后合并为一个：
- en: '![](img/a893f73a-7e23-4e4d-b0f2-3f68924f49e3.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a893f73a-7e23-4e4d-b0f2-3f68924f49e3.png)'
- en: 'The `WindowUntil` and the `WindowWhile` variants take a predicate condition
    and build a window batch until the condition is true. The `WindowWhile` operator
    generates a single window containing all the elements that match the condition.
    The `WindowUntil` operator, on the other hand, aggregates non-matching elements
    to a window. When it finds a matching element, it adds it to the current window.
    It then starts a new window to add the next incoming element. Consider the following
    code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`WindowUntil` 和 `WindowWhile` 变体接受一个谓词条件，并构建一个窗口批次，直到条件为真。`WindowWhile` 操作符生成一个包含所有匹配条件的单个窗口。另一方面，`WindowUntil`
    操作符将不匹配的元素聚合到一个窗口中。当它找到一个匹配的元素时，它将其添加到当前窗口。然后它开始一个新的窗口以添加下一个传入的元素。考虑以下代码：'
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding code, we have done the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: We partitioned the original data based on the condition that `x < 500`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们根据条件 `x < 500` 对原始数据进行分区。
- en: All elements that matched the criteria were published in a single window.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有符合标准的数据元素都在一个窗口中发布。
- en: The window elements were emitted as `WindowFlux`. They were combined using `concatMap`
    or `flatMap`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 窗口元素作为 `WindowFlux` 发射。它们使用 `concatMap` 或 `flatMap` 进行组合。
- en: Finally, we printed the elements with the subscribe function.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用 `subscribe` 函数打印元素。
- en: 'Let''s run our code to confirm the output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行代码以确认输出：
- en: '![](img/d1932e7e-bbd3-4cd0-9094-ffe58371f4d6.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d1932e7e-bbd3-4cd0-9094-ffe58371f4d6.png)'
- en: The sample operator
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样本操作符
- en: The `groupBy()`, `buffer()`, and `window()` operators aggregate inputs and consolidate
    them into chunks, based on their size, time period, or condition. They are not
    aimed at skipping events. At times, you may be required to skip events and listen
    to a particular event during a given time interval. This is often required for
    fast, non-changing events, such as user clicks. In such a situation, we need to
    throttle the flow and pick data selectively.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupBy()`, `buffer()`, 和 `window()` 操作符将输入聚合并基于其大小、时间周期或条件将它们合并成块。它们的目标不是跳过事件。有时，你可能需要跳过事件并监听给定时间间隔内的特定事件。这通常适用于快速、不变化的事件，例如用户点击。在这种情况下，我们需要调节流量并选择性地获取数据。'
- en: 'The `sample()` operator allows us to accomplish this throttling. It takes a
    time period and listens to events published during that time period. It then publishes
    the last event that happened during the time period. This is depicted in the following
    diagram:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`sample()` 操作符允许我们完成这种调节。它接受一个时间周期并监听该时间周期内发布的事件。然后它发布该时间周期内发生的最后一个事件。这在上面的图中有所展示：'
- en: '![](img/b170198e-5194-4446-84f1-d1bb2c4a3437.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b170198e-5194-4446-84f1-d1bb2c4a3437.png)'
- en: 'Let''s try to add a delay to our Fibonacci series and then throttle it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试给我们的斐波那契数列添加延迟，然后进行调节：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, we have done the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: We added the `delayElements()` operator. This operator is responsible for delaying
    each event by the supplied time period. In this case, we have delayed each element
    by 100 milliseconds.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了 `delayElements()` 操作符。这个操作符负责将每个事件延迟指定的周期。在这种情况下，我们将每个元素延迟了100毫秒。
- en: Next, we added the `sample()` operator with a time interval of one second.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加了时间间隔为一秒的 `sample()` 操作符。
- en: We then printed the elements using the `Subscribe` function.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用 `Subscribe` 函数打印元素。
- en: We also added a `CountDownLatch` to wait for the test execution for completion/error
    events.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还添加了一个 `CountDownLatch` 来等待测试执行的完成/错误事件。
- en: 'Let''s run the code to confirm the output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行代码以确认输出：
- en: '![](img/a043362b-520e-48ef-ab4b-c6b8a1843a5f.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a043362b-520e-48ef-ab4b-c6b8a1843a5f.png)'
- en: The `samplefirst()` operator is similar to the `sample()`operator. This operator
    publishes the first element that was received during the specified time period,
    rather than selecting the last element.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`samplefirst()` 操作符与 `sample()` 操作符类似。这个操作符在指定的时间周期内发布接收到的第一个元素，而不是选择最后一个元素。'
- en: Backpressure
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反压
- en: 'Backpressure is an integral part of Reactor. We have discussed it multiple
    times in previous chapters, but we will have a detailed look at the topic here.
    Let''s recap the out-of-the-box support for backpressure that is available with
    Reactor. Each of the subscribers requests the number of events that it can process
    using the subscription object. The publisher must respect this limit and publish
    events that are less than or equal to the requested limit. This is depicted in
    the following diagram:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 反压是Reactor的一个基本组成部分。我们在前面的章节中多次讨论了它，但我们将在这里详细探讨这个主题。让我们回顾Reactor提供的开箱即用的反压支持。每个订阅者都使用订阅对象请求它可以处理的事件数量。发布者必须尊重这个限制，并发布小于或等于请求限制的事件。这在上面的图中表示：
- en: '![](img/252589c2-c331-4308-8982-084df0f7bb90.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/252589c2-c331-4308-8982-084df0f7bb90.png)'
- en: Invoking a request with `Long.MAX_VALUE` means requesting an unbounded number
    of events. The publisher can push as many events as it can. It is no longer bound
    by the subscriber limit.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Long.MAX_VALUE`调用请求意味着请求无界数量的事件。发布者可以推送尽可能多的事件。它不再受订阅者限制的约束。
- en: 'As each subscriber is processing the received events, it can request additional
    events using the subscription handle. If the publisher is raising events rapidly,
    it must come up with a strategy to handle the non-requested events. Take a look
    at the following test code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个订阅者处理接收到的事件时，它可以使用订阅句柄请求额外的事件。如果发布者快速发布事件，它必须制定一个策略来处理未请求的事件。看看以下测试代码：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, the following occurred:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，发生了以下情况：
- en: We created a publisher using the `Flux.create` API
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`Flux.create` API创建了一个发布者
- en: The publisher printed the requested number to the console and emitted 100 events
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布者将请求的数量打印到控制台，并发布了100个事件
- en: The subscriber requested a single event in the subscribe hook
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅者在`subscribe`钩子中请求了一个事件
- en: The subscriber printed the received event to the console
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅者将接收的事件打印到控制台
- en: There is a `CountDownLatch` to pause the code for 1 second
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一个`CountDownLatch`用于暂停代码1秒钟
- en: 'To sum up, the subscriber requested one event, but the publisher emitted 100\.
    Let''s run the test to see the result on the console:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，订阅者请求了一个事件，但发布者发布了100个。让我们运行测试，看看控制台上的结果：
- en: '![](img/ae5b1ad5-8591-4955-a36d-7143921a313e.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ae5b1ad5-8591-4955-a36d-7143921a313e.png)'
- en: 'The preceding test failed to complete successfully. Our subscriber asked for
    one event and it received only one. The publisher, however, pushed 100 data events
    followed by the complete event. Reactor did some work behind the scenes to hold
    the events in a queue. It offers a few overflow strategies to handle events produced
    by a fast publisher:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试未能成功完成。我们的订阅者请求了一个事件，但它只收到了一个。然而，发布者推送了100个数据事件，然后是完整的事件。Reactor在幕后做了一些工作，将事件保持在队列中。它提供了一些溢出策略来处理快速发布者产生的事件：
- en: '| **Strategy** | **Description** |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **策略** | **描述** |'
- en: '| `IGNORE` | This strategy ignores the limits of the subscriber for backpressure
    and keeps delivering the next event to the subscriber. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `IGNORE` | 此策略忽略订阅者的反压限制，并继续向订阅者发送下一个事件。|'
- en: '| `BUFFER` | This strategy combines the undelivered events in a buffer. Events
    from the buffer are delivered when the subscriber requests the next events. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `BUFFER` | 此策略将未发送的事件组合在缓冲区中。当订阅者请求下一个事件时，缓冲区中的事件被发送。|'
- en: '| `DROP` | This strategy silently drops undelivered events that are produced.
    The subscriber will only get a newly produced event when the next request is raised.
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `DROP` | 此策略静默丢弃产生的未发送事件。只有当下一次请求被提出时，订阅者才会得到新产生的事件。|'
- en: '| `LATEST` | This strategy keeps the latest event raised in the buffer. The
    subscriber will only get the latest produced event when the next request is raised.
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `LATEST` | 此策略保留缓冲区中提出的最新事件。只有当下一次请求被提出时，订阅者才会得到最新产生的事件。|'
- en: '| `ERROR` | This strategy raises an `OverFlowException` if the producer raises
    more than the events requested by the subscriber. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `ERROR` | 如果生产者发布的比订阅者请求的事件多，此策略将引发`OverFlowException`。|'
- en: 'The API created by default uses the `Overflow.Buffer` strategy. We could override
    this by passing the one we want in the overloaded `create` method. Let''s test
    the preceding code with the `Overflow.Error` strategy:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 默认创建的API使用`Overflow.Buffer`策略。我们可以通过在重载的`create`方法中传递我们想要的策略来覆盖它。让我们用`Overflow.Error`策略测试前面的代码：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The test case now fails with the following error:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例现在失败，以下错误：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: OnBackpressure
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OnBackpressure
- en: Reactor also provides operators to alter the overflow strategy configured with
    the publisher. There are various `OnBackpressureXXX()` operators that cater to
    each of the strategies available with Reactor. These are quite useful in scenarios
    in which none of the preceding strategies can be applied to the publisher.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor还提供了操作符来更改与发布者配置的溢出策略。有各种`OnBackpressureXXX()`操作符，它们针对Reactor中可用的每种策略。这些在无法将前面的策略应用于发布者的场景中非常有用。
- en: A publisher is sometimes configured with an `IGNORE` strategy. In such cases,
    backpressure is configured using operators while subscribing to the publisher.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者有时被配置为使用`IGNORE`策略。在这种情况下，在订阅发布者时使用操作符来配置背压。
- en: 'Let''s work with our test case and apply backpressure operators to it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们的测试用例并对其应用背压操作符：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code, we have done the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: We configured `Flux<Integer>` with `OverflowStrategy.BUFFER`, the default configuration
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`Flux<Integer>`配置为使用默认配置`OverflowStrategy.BUFFER`
- en: While subscribing to `Flux<Integer>`, we altered the strategy to use `OverflowStrategy.DROP`
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在订阅`Flux<Integer>`时，我们更改了策略以使用`OverflowStrategy.DROP`
- en: Additionally, we passed a lambda to the operator to print the dropped value
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还向操作符传递了一个lambda表达式来打印丢弃的值
- en: 'Let''s run the code and validate the output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行代码并验证输出：
- en: '![](img/8d1e9929-30cb-47a9-a4ea-2912ce8ddf29.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d1e9929-30cb-47a9-a4ea-2912ce8ddf29.png)'
- en: 'Additionally, there are the `onBackpressureLatest()`, `onBackpressureError()`,
    and `onBackpressureBuffer()` operators, which are similar to the `onBackpressureDrop()`
    operator. The `onBackpressureBuffer()` operator has a couple of overloaded variants.
    As a basic configuration, it allows us to specify the buffer size. We could also
    specify one of the following strategies to handle the overflow beyond the specified
    buffer:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有`onBackpressureLatest()`、`onBackpressureError()`和`onBackpressureBuffer()`操作符，它们与`onBackpressureDrop()`操作符类似。`onBackpressureBuffer()`操作符有几个重载变体。作为一个基本配置，它允许我们指定缓冲区大小。我们还可以指定以下策略之一来处理超出指定缓冲区的溢出：
- en: '| **Buffer overflow** | **Description** |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **缓冲区溢出** | **描述** |'
- en: '| `DROP_LATEST` | All generated events are buffered first and then the new
    events are dropped. This would keep the oldest events in the buffer. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `DROP_LATEST` | 所有生成的事件首先被缓冲，然后丢弃新的事件。这将保持缓冲区中最老的事件。|'
- en: '| `DROP_OLDEST` | All generated events are buffered. Events that are currently
    in the buffer are then replaced with new events. This would keep the latest events
    in the buffer. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `DROP_OLDEST` | 所有生成的事件都被缓冲。然后，当前在缓冲区中的事件被新的事件替换。这将保持缓冲区中最新的事件。|'
- en: '| `ERROR` | This raises an `OverFlowException` for events that are beyond the
    buffer. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `ERROR` | 这会对超出缓冲区的事件抛出`OverFlowException`。|'
- en: 'Let''s look at how this works with an example. We can also pass a consumer
    lambda to be invoked for the overflow events:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来看看它是如何工作的。我们还可以传递一个消费者lambda表达式来处理溢出事件：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code, we have done the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: We configured `Flux<Integer>` with `OverflowStrategy.BUFFER`, the default configuration
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`Flux<Integer>`配置为使用默认配置`OverflowStrategy.BUFFER`
- en: While subscribing to `Flux<Integer>`, we altered the buffer size to two elements
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在订阅`Flux<Integer>`时，我们将缓冲区大小更改为两个元素
- en: We configured the `DROP_LATEST` strategy for events beyond the buffer
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为超出缓冲区的事件配置了`DROP_LATEST`策略
- en: We also passed a lambda to the operator to print the dropped value
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还向操作符传递了一个lambda表达式来打印丢弃的值
- en: 'Let''s run the code and validate the output:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行代码并验证输出：
- en: '![](img/e35094bb-b847-4a8e-8c50-4372e6e3d4e8.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e35094bb-b847-4a8e-8c50-4372e6e3d4e8.png)'
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the flow control operators that are available
    in Reactor in detail. We looked at the different overload options that are available
    in the `groupBy`, `buffer`, and `window` operators. We then considered how we
    can throttle events using the sample operator, which allows only a single event
    to be delivered in the specified time interval. After that, we recapped the support
    for backpressure that is available in Reactor and studied the different overflow
    strategies that it provides. We also learned that Reactor uses the `Overflow.Buffer`
    strategy by default, which can be provided as part of the `Flux.create` API. Finally,
    we discussed the backpressure operators that can be used to alter the strategy
    of the producer. To sum up, we discussed the complete list of operators available
    for flow control and backpressure. In the next chapter we will look at handling
    and recovering errors.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细讨论了 Reactor 中可用的流控制操作符。我们探讨了 `groupBy`、`buffer` 和 `window` 操作符中可用的不同重载选项。然后，我们考虑了如何使用样本操作符来节流事件，该操作符允许在指定的时间间隔内只传递一个事件。之后，我们回顾了
    Reactor 中可用的背压支持，并研究了它提供的不同溢出策略。我们还了解到，Reactor 默认使用 `Overflow.Buffer` 策略，这可以作为
    `Flux.create` API 的一部分提供。最后，我们讨论了可以用来改变生产者策略的背压操作符。总之，我们讨论了可用于流控制和背压的完整操作符列表。在下一章中，我们将探讨错误处理和恢复。
- en: Questions
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why do we need the `groupBy` operator?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们需要 `groupBy` 操作符？
- en: What is the difference between the `groupBy` and `buffer` operators?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`groupBy` 和 `buffer` 操作符之间的区别是什么？'
- en: How can we throttle an event in Reactor?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 Reactor 中节流一个事件？
- en: What is the difference between the `Overflow.Ignore` and `OverFlow.Latest` strategies?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Overflow.Ignore` 和 `Overflow.Latest` 策略之间的区别是什么？'
- en: Which operators are available to change the backpressure strategy of a producer?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些操作符可以改变生产者的背压策略？
