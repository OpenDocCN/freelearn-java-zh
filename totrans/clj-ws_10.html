<html><head></head><body>
		<div>
			<div id="_idContainer167" class="Content">
			</div>
		</div>
		<div id="_idContainer168" class="Content">
			<h1 id="_idParaDest-225"><a id="_idTextAnchor270"/>10. Testing</h1>
		</div>
		<div id="_idContainer225" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, we look at testing in Clojure. We start by learning about different types of tests. We then explore the most common unit testing libraries in order to test our Clojure functions. We see how to do test-driven development. We dive into property-based testing that helps us to generate a vast amount of testing data. We then learn how to integrate testing with Clojure and ClojureScript projects.</p>
			<p class="callout">By the end of this chapter, you will be able to test programs in Clojure and ClojureScript using their respective standard test libraries.</p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor271"/>Introduction</h1>
			<p>In the previous chapter, we learned about host platform interoperability (inter-op) in Clojure. We explored how to use Java code in Clojure and JavaScript in ClojureScript. During our inter-op adventure, we created a coffee-ordering application. The application has various features, such as displaying a menu with coffee choices and ordering a coffee. We ran the code and we saw the application working. It is now time to learn about testing in Clojure.</p>
			<p>Clojure was designed from the beginning to be a very practical language. Getting things done means interacting with the outside world, building projects, using libraries, and deploying your work. We need to be confident that the code that we write does what it is supposed to do. As a developer, you will need to test your applications. In this chapter, we will see what types of tests can be used. We will look at unit tests as they are the most common type of test written by developers.</p>
			<p>Consider a situation where we have an air-ticket ordering application. This application allows users to search for flights and book flights. One of its features is searching for flights. A user should be able to enter search dates. The end date should be after the start date – it does not make much sense to fly back before we have even flown out. Testing allows us to ensure that the code handling start and end dates are in order. </p>
			<p>Similarly, we would want to make sure that when many customers enter our site, it does not slow down. User experience elements such as website speed are also tested in software.</p>
			<p>The first step is to understand why testing is important and what types of tests can be done in Clojure and ClojureScript. Then, we will look at testing libraries in Clojure and ClojureScript. Finally, we will look at a special type of testing called <strong class="bold">generative testing</strong> and how it helps developers to write tests.</p>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor272"/>Why Testing Is Important</h1>
			<p>At the beginning of this chapter, we saw that software testing is important. Why? In order to answer that, we will need to understand what software testing is. It can be defined as a process that ensures that a particular piece of software is bug-free. A software bug is a problem that causes a program to crash or produce invalid output. In <em class="italic">Chapter 9</em>, <em class="italic">Host Platform Interoperability with Java and JavaScript</em>, we learned about errors in Clojure and ClojureScript. Testing is a step-by-step process that ensures that software passes expected standards of performance, set by customers or the industry. These steps can also help to identify errors, gaps, or missing requirements. Bugs, errors, and defects are synonyms. They all mean problems with our software.</p>
			<p>The benefits of software testing are as follows:</p>
			<ul>
				<li>Providing a high-quality product with low maintenance costs</li>
				<li>Assuring the accuracy and consistency of the product</li>
				<li>Discovering errors that are not recognized during the developmental phase</li>
				<li>Checking whether the application produces the expected output</li>
				<li>Providing us with knowledge of customers' satisfaction with the product</li>
			</ul>
			<p>There are a number of software testing methodologies, depending on the angle from which we look at the software. The most common distinction is between functional testing and non-functional testing. We will now discuss what makes tests functional or non-functional, and when it is appropriate to use one type or the other.</p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor273"/>Functional Testing</h2>
			<p><strong class="bold">Functional tests</strong> try to capture the functional requirements of the software being tested. The requirements are taken from the specifications of the software.</p>
			<p>Consider the air-ticket ordering application, which allows users to buy airline tickets. As mentioned, one of its features is searching for flights. Users would want to search using different criteria. One criterion could be searching for direct flights. Functional tests would ensure that when a user searches for a direct flight, they do not see connecting flights.</p>
			<p>Typically, functional testing involves the following steps:</p>
			<ol>
				<li>Identifying what functions and features a software component has, based on the requirements specification document</li>
				<li>Creating input data based on the requirements</li>
				<li>Determining the expected output</li>
				<li>Executing the tests</li>
				<li>Comparing the expected results with the actual output</li>
			</ol>
			<p>While functional testing has advantages, there are some testing areas that are not covered by functional tests. In such cases, so-called non-functional tests are performed.</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor274"/>Non-Functional Testing</h2>
			<p><strong class="bold">Non-functional tests</strong> check things that are not directly related to the functional requirements. To put it another way, non-functional tests are concerned with the way that software operates as a whole, rather than with the specific behaviors of the software or its components.</p>
			<p>With non-functional tests, we are concerned with areas such as security, how a system behaves under various load conditions, whether it is user-friendly, and whether it provides localization to run in different countries.</p>
			<p>Consider the air-ticket ordering application again. This application allows users to buy airline tickets. Users should be able to pay with their credit cards. The application should handle payments securely. This means that transactions should be encrypted. Encryption is the process of encoding a message or information in such a way that only authorized parties can access it and those who are not authorized cannot. Someone who is not authorized should not be able to see transaction details. </p>
			<p>Another non-functional test for the air-ticket ordering application would be load testing. With load testing, we would test that our application can handle a very high page load. During the festive period, many customers will enter our website. We need to make sure that thousands of users can use the application at the same time. The application should be responsive and not slow down when many customers use it.</p>
			<p>Functional tests ensure that our applications are secure. While we have discussed functional and non-functional testing separately, they should not be seen as opposing testing methodologies, but rather, complementary approaches. They are often performed together to provide assurance that software has a high standard of quality and can operate under various conditions.</p>
			<p>Testing and catching bugs in software are not free. It requires time and resources from developers and testers. Having said that, fixing bugs late in development is more expensive than catching them early in the development phase. Unit testing allows us to catch many bugs early on, while not requiring too many resources from developers.</p>
			<p>In the next topic, we will examine what unit testing is, and the most popular unit testing frameworks in Clojure.</p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor275"/>Clojure Unit Testing</h2>
			<p><strong class="bold">Unit testing</strong> is the testing of an individual software component or module. In Clojure, a function is a good candidate for unit testing. A function is intended to perform one task at a time. Otherwise, a change in logic in one job would influence a second job. When a function has one responsibility, we can reason about the function much more easily than if it performed more than one thing. Clojure provides a number of testing frameworks for unit testing. When we use testing libraries, we often call them frameworks. A framework is a structure that supports and encloses testing. With testing frameworks, we support testing our code. Our code is enclosed in a number of tests written for our code.</p>
			<p>There are a number of concepts in testing, two of which are as follows:</p>
			<ul>
				<li><strong class="bold">Assertion</strong>: A Boolean (true or false) expression. An assertion is a statement about a specific part of our program, which will be true or false. For example, we can state that a function in our program will throw an error when we pass a string instead of a number as a parameter. The assertion will be: Does this function throw an error? The answer is either yes (true) or no (false).</li>
				<li><strong class="bold">Stub</strong>: A temporary replacement for a part of a code or a concept. A stub simulates the behavior of the replaced software component. In the flight-ticket ordering application, we could have a payment component that takes card details and contacts the bank to withdraw money for the plane ticket. After taking payment through the bank, we would display ticket details. A stub would simulate contacting the bank without actually contacting the bank. When we use a stub, we can focus on testing displaying ticket details without handling contacting the bank and all card transactions. This keeps the test focused on a single task, in this case, displaying a ticket after taking payment via a bank.</li>
			</ul>
			<p>The <strong class="source-inline">clojure.test</strong> framework is the default Clojure unit testing framework that comes with the Clojure standard library. The purpose of <strong class="source-inline">clojure.test</strong> is to provide developers with a number of testing functions. In our first exercise, we will write unit tests for the coffee app from the previous chapter using the clojure.test library.</p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor276"/>Exercise 10.01: Unit Testing with the clojure.test Library</h2>
			<p>The aim of this exercise is to learn how to perform unit testing with the <strong class="source-inline">clojure.test</strong> library. This is the default testing library in Clojure. It is included in Clojure so we do not need to import this library as an external dependency. In the previous chapter, we created a coffee-ordering application that allowed us to display a coffee menu and order coffees. In this exercise, we will write unit tests for the functions created in the coffee-ordering application.</p>
			<p>First, we will create the application, then we will write tests:</p>
			<ol>
				<li value="1">Create the coffee-ordering application:<p class="source-code">lein new app coffee-app</p><p>Leiningen created the project for us. By default, we have one source file called <strong class="source-inline">core.clj</strong>. Inside this file, we will add the code responsible for displaying the menu options and processing them.</p></li>
				<li><a id="_idTextAnchor277"/>Import the <strong class="source-inline">java.util.Scanner</strong> class in the <strong class="source-inline">core</strong> namespace:<p class="source-code">(ns coffee-app.core</p><p class="source-code">    (:require [coffee-app.utils :as utils])</p><p class="source-code">    (:import [java.util Scanner])</p><p class="source-code">    (:gen-class))</p><p><a id="_idTextAnchor278"/>We have imported the <strong class="source-inline">Scanner</strong> class. This class allows us to get input from a keyboard. In order to use methods from Scanner, we need to create an instance of this class.</p></li>
				<li><a id="_idTextAnchor279"/>Create an instance of the <strong class="source-inline">Scanner</strong> class.<p><a id="_idTextAnchor280"/>We will call methods on this class instance when we want to get input from a user. The <strong class="source-inline">Scanner</strong> class needs to know what the source of the input is. In our case, we use the default <strong class="source-inline">in</strong> source of the <strong class="source-inline">System</strong> class – the keyboard.</p><p class="source-code">(def input (Scanner. System/in))</p><p>When a user runs the application, they should see a menu with options. The options are displaying and ordering coffees, listing orders, and exiting the application.</p><div id="_idContainer169" class="IMG---Figure"><img src="image/B14502_10_01.jpg" alt="Figure 10.1: Menu of the application showing all the options&#13;&#10;"/></div><p><a id="_idTextAnchor281"/></p><p class="figure-caption">Figure 10.1: Menu of the application showing all the options</p></li>
				<li>Add the code for displaying the menu and handling user choices:<p class="source-code">(defn- start-app []</p><p class="source-code">       "Displaying main menu and processing user choices."</p><p class="source-code">       (let [run-application (ref true)]</p><p class="source-code">            (while (deref run-application)</p><p class="source-code">                   (println "\n|     Coffee app |")</p><p class="source-code">                   (println "| 1-Menu 2-Orders 3-Exit |\n")</p><p class="source-code">                   (let [choice (.nextInt input)]</p><p class="source-code">                        (case choice</p><p class="source-code">                              1 (show-menu)</p><p class="source-code">                              2 (show-orders)</p><p class="source-code">                              3 (dosync (ref-set run-application false)))))))</p></li>
				<li>In the <strong class="source-inline">start-app</strong> function, we set the application to running by default:<p class="source-code">run-application (ref true)</p><p class="source-code">(while (deref run-application)</p><p>In order to get the values stored in <strong class="source-inline">run-application</strong>, we use the <strong class="source-inline">deref</strong> function.</p></li>
				<li>Inside the <strong class="source-inline">while</strong> block, the application runs until the user chooses the exit option. In such cases, we will update the value of <strong class="source-inline">ref</strong>:<p class="source-code">(dosync (ref-set run-application false))</p></li>
				<li>A<a id="_idTextAnchor282"/>fter updating, <strong class="source-inline">ref</strong> is no longer true but false. The <strong class="source-inline">while</strong> block will stop when the value of <strong class="source-inline">ref</strong> is false and our application will exit. <a id="_idTextAnchor283"/>When our application runs, the user can choose options from the menu:<p class="source-code">(println "| 1-Menu 2-Orders 3-Exit |\n")</p><p>This will display the following menu:</p><div id="_idContainer170" class="IMG---Figure"><img src="image/B14502_10_02.jpg" alt="Figure 10.2: Menu of the coffee ordering application&#13;&#10;"/></div><p class="figure-caption">Figure 10.2: Menu of the coffee ordering application</p><p>We are able to display the initial menu. We can work on handling user choices from the menu.</p></li>
				<li>In<a id="_idTextAnchor284"/> order to get the user response, we call the <strong class="source-inline">nextInt</strong> method from the <strong class="source-inline">Scanner</strong> instance:<p class="source-code">ch<a id="_idTextAnchor285"/>oice (.nextInt input)</p><p>Fi<a id="_idTextAnchor286"/>nally, once we get the user input, we check which option from the menu should be executed:</p><p class="source-code">(c<a id="_idTextAnchor287"/>ase choice</p><p class="source-code">  1 (show-menu)</p><p class="source-code">    2 (show-orders))</p><p>We<a id="_idTextAnchor288"/> now know about the logic in the main application menu when we start the app. It is time to dig deeper and look at the code for the <strong class="source-inline">show-menu</strong> function.</p></li>
				<li>Di<a id="_idTextAnchor289"/>splay the menu for the available coffees:<p class="source-code">(d<a id="_idTextAnchor290"/>efn- show-menu []</p><p class="source-code">       (println "| Available coffees |")</p><p class="source-code">       (println "|1. Latte   2.Mocha |")</p><p class="source-code">       (let [choice (.nextInt input)]</p><p class="source-code">            (case choice</p><p class="source-code">                  1 (buy-coffee :latte)</p><p class="source-code">                  2 (buy-coffee :mocha))))</p><p>In<a id="_idTextAnchor291"/> the <strong class="source-inline">show-menu</strong> function, we let the user know about two available coffees – <strong class="source-inline">Latte</strong> and <strong class="source-inline">Mocha</strong>:</p><p class="source-code">(p<a id="_idTextAnchor292"/>rintln "| Available coffees |")</p><p class="source-code">(println "|1. Latte   2.Mocha |")</p><p>This will display the coffee menu:</p><div id="_idContainer171" class="IMG---Figure"><img src="image/B14502_10_03.jpg" alt="Figure 10.3: Coffee menu display&#13;&#10;"/></div><p class="figure-caption">Figure 10.3: Coffee menu display</p><p>The user can choose numbers <strong class="source-inline">1</strong> or <strong class="source-inline">2</strong>. We need to respond to the user's coffee choice now.</p></li>
				<li>We use the <strong class="source-inline">Scanner</strong> instance to get the user input:<p class="source-code">cho<a id="_idTextAnchor293"/>ice (.nextInt input)</p></li>
				<li>Fin<a id="_idTextAnchor294"/>ally, we proceed to buy the coffee that the user chose:<p class="source-code">(ca<a id="_idTextAnchor295"/>se choice</p><p class="source-code">       1 (buy-coffee :latte)</p><p class="source-code">       2 (buy-coffee :mocha))</p><p>The<a id="_idTextAnchor296"/> <strong class="source-inline">show-menu</strong> function is not long. Its purpose is to display the available coffees and get the user input. Once the user has chosen their coffee, we call the <strong class="source-inline">buy-coffee</strong> function to handle buying the selected coffee.</p></li>
				<li>Ask<a id="_idTextAnchor297"/> the user how many coffees they'd like to buy:<p class="source-code">(de<a id="_idTextAnchor298"/>fn- buy-coffee [type]</p><p class="source-code">       (println "How many coffees do you want to buy?")</p><p class="source-code">       (let [choice (.nextInt input)</p><p class="source-code">             price (utils/calculate-coffee-price price-menu type choice)]</p><p class="source-code">            (utils/display-bought-coffee-message type choice price)))</p><p>The<a id="_idTextAnchor299"/> <strong class="source-inline">buy-coffee</strong> function asks how many coffees the user wants to buy. Again, we use an instance of the <strong class="source-inline">Scanner</strong> class – <strong class="source-inline">input</strong> – to get the user's choice. Next, the function calls two utility functions to process the purchase. The functions are responsible for calculating the coffee price and displaying the feedback message to the user.</p><p>All the functions will be placed in the <strong class="source-inline">utils.clj</strong> file. Instead of having all functions in one big file, it is good practice to split functions into various namespaces. A common namespace name is <strong class="source-inline">utils</strong>. We can keep any useful functions that operate on data there.</p></li>
				<li>Cre<a id="_idTextAnchor300"/>ate a <strong class="source-inline">utils</strong> namespace:<p class="source-code">(ns<a id="_idTextAnchor301"/> coffee-app.utils</p></li>
				<li>Cal<a id="_idTextAnchor302"/>culate the coffee price:<p class="source-code">(de<a id="_idTextAnchor303"/>fn calculate-coffee-price [coffees coffee-type number]</p><p class="source-code">      (-&gt;</p><p class="source-code">        (get coffees coffee-type)</p><p class="source-code">        (* number)</p><p class="source-code">        float))</p><p>Our first utility function calculates the coffee price. It uses the <strong class="source-inline">get</strong> function to check the <strong class="source-inline">coffees</strong> hash for the passed-in coffee type. The hash is defined in the core namespace:</p><p class="source-code">(ns coffee-app.core</p><p class="source-code">    (:require [coffee-app.utils :as utils])</p><p class="source-code">    (:import [java.util Scanner])</p><p class="source-code">    (:gen-class))</p><p class="source-code">(def ^:const price-menu {:latte 0.5 :mocha 0.4})</p><p>The value obtained from the hash is then multiplied by the number of coffee cups that the user ordered. Finally, we coerce the number to float. This allows us to convert a number such as 1.2000000000000002 to 1.2.</p><p>The last utility function used when we handle buying coffee is the <strong class="source-inline">display-bought-coffee-message</strong> function.</p></li>
				<li>Display the message to the user after buying the coffee:<p class="source-code">(ns coffee-app.utils)</p><p class="source-code">(defn display-bought-coffee-message [type number total]</p><p class="source-code">      (println "Buying" number (name type) "coffees for total:€" total))</p><p>The <strong class="source-inline">display-bought-coffee-message</strong> function takes the order map and constructs a string message for the user based on the data from the map. The user is informed that they bought a certain amount of cups of coffee for the specified price.</p><p>With this function, we can control the information passed back to the user after completing their order:</p><div id="_idContainer172" class="IMG---Figure"><img src="image/B14502_10_04.jpg" alt="Figure 10.4: Displaying the message for the coffee bought&#13;&#10;"/></div><p class="figure-caption">Figure 10.4: Displaying the message for the coffee bought</p><p>The second option from the main menu allows us to see the placed orders:</p><div id="_idContainer173" class="IMG---Figure"><img src="image/B14502_10_05.jpg" alt="Figure 10.5: Orders allows the user to see their orders&#13;&#10;"/></div><p class="figure-caption">Figure 10.5: Orders allows the user to see their orders</p><p>The function responsible for displaying orders is <strong class="source-inline">show-orders</strong> from the <strong class="source-inline">coffee-app.core</strong> namespace.</p></li>
				<li>Display the placed orders:<p class="source-code">(ns coffee-app.core)</p><p class="source-code">(defn- show-orders []</p><p class="source-code">       (println "\n")</p><p class="source-code">       (println "Display orders here"))</p><p>This function will display the coffee orders made. In this exercise, we informed the user that orders will be displayed here. In the following exercise, we will implement saving and displaying orders:</p><p class="source-code">Display orders here</p><p>When we run the application and buy two cups of latte, we will see the following output:</p><div id="_idContainer174" class="IMG---Figure"><img src="image/B14502_10_06.jpg" alt="Figure 10.6: Output when the user buys two cups of coffee&#13;&#10;"/></div><p class="figure-caption">Figure 10.6: Output when the user buys two cups of coffee</p></li>
				<li>Add the main function as follows:<p class="source-code">(defn -main</p><p class="source-code">      "Main function calling app."</p><p class="source-code">      [&amp; args]</p><p class="source-code">      (start-app))</p></li>
				<li>In order to run the application, we will use the following:<p class="source-code">lein run</p><p>Once we run the application, we can see the available coffees and order them, similar to what we saw in <em class="italic">Figure 10.6</em>.</p><p>We have our application running successfully. We will create tests for our application now.</p></li>
				<li>Check the testing directory. We use the <strong class="source-inline">tree</strong> command to display a list of folders and files within the test directory:<p class="source-code">tree test</p><p>When we created the application, Leiningen created the <strong class="source-inline">test</strong> directory for us. There are a number of ways to check the project's structure. We check the project structure using the preceding <strong class="source-inline">tree</strong> command.</p><div id="_idContainer175" class="IMG---Figure"><img src="image/B14502_10_07.jpg" alt="Figure 10.7: Project structure&#13;&#10;"/></div><p class="figure-caption">Figure 10.7: Project structure</p><p>We have one test file, <strong class="source-inline">core.clj</strong>. Inside this file, there is a sample test created by Leiningen: </p><p class="source-code">(ns coffee-app.core-test</p><p class="source-code">  (:require [clojure.test :refer :all]</p><p class="source-code">                [coffee-app.core :refer :all]))</p><p>This file imports the Clojure testing namespace, as well as the core file from the source directory. The file contains one test method. This method is called <strong class="source-inline">a-test</strong>. Because we have autogenerated the <strong class="source-inline">a-test</strong> test function, we can run tests after creating a Leiningen project:</p><p class="source-code">(deftest a-test</p><p class="source-code">  (testing "FIXME, I fail."</p><p class="source-code">    (is (= 0 1))))</p><p>When we create a new project with Leiningen, it will create one test function. This function is called <strong class="source-inline">a-test</strong> and is inside the <strong class="source-inline">core_test.clj</strong> file.</p></li>
				<li>In order to run tests, we need to call Leiningen's <strong class="source-inline">test</strong> task. The <strong class="source-inline">test</strong> task is a task that will run the tests within the test directory:<p class="source-code">lein test</p><p>The output is as follows:</p><div id="_idContainer176" class="IMG---Figure"><img src="image/B14502_10_08.jpg" alt="Figure 10.8: Running the test task&#13;&#10;"/></div><p class="figure-caption">Figure 10.8: Running the test task</p><p>The <strong class="source-inline">a-test</strong> test fails, as we have not yet implemented the <strong class="source-inline">a-test</strong> test from the <strong class="source-inline">core_test.clj</strong> file. Leiningen informed us that it tested the <strong class="source-inline">coffee-app.core-test</strong> namespace. We have information that the test failed, including which line in the test file (line 7) caused the test to fail.</p><p>Leiningen even provided us with information about what the test expected and what the actual result was. In this case, the default test tried to compare the numbers one and zero. In order to make the test pass, let's change the <strong class="source-inline">a-test</strong> function.</p></li>
				<li>To fix the default <strong class="source-inline">test</strong> function from the Leiningen project, we will change the implementation of the default <strong class="source-inline">a-test</strong> function that we have just seen:<p class="source-code">(deftest a-test</p><p class="source-code">  (testing "FIXME, I fail."</p><p class="source-code">    (is (= 1 1))))</p><p>We changed the test to state that 1 is equal to 1. This will make our <strong class="source-inline">a-test</strong> pass.</p></li>
				<li>We run the test using the following:<p class="source-code">lein test</p><p>We can run the tests again:</p><div id="_idContainer177" class="IMG---Figure"><img src="image/B14502_10_09.jpg" alt="Figure 10.9: Running the test after fixing the default a-test function&#13;&#10;"/></div><p class="figure-caption">Figure 10.9: Running the test after fixing the default a-test function</p><p>This time, Leiningen informs us that it ran one test with one assertion (test condition). There were zero failures and zero errors. We now know how to run tests. It is time to write tests for the <strong class="source-inline">utils</strong> namespace. We will create a testing file for the <strong class="source-inline">utils</strong> namespace.</p></li>
				<li>Create a test file for the <strong class="source-inline">utils</strong> namespace. Inside the file, we will write code to test functions in the <strong class="source-inline">utils</strong> namespace:<p class="source-code">touch test/coffee_app/utils_test.clj</p><p>After creating <strong class="source-inline">utils_test.clj</strong>, we will have two test files:</p><div id="_idContainer178" class="IMG---Figure"><img src="image/B14502_10_10.jpg" alt="Figure 10.10: We now have two test files after creating utils_test.clj&#13;&#10;"/></div><p class="figure-caption">Figure 10.10: We now have two test files after creating utils_test.clj</p><p>In <strong class="source-inline">utils_test.clj</strong>, we want to test functions from the <strong class="source-inline">utils</strong> namespace. We will add the necessary dependencies to the testing namespace. Inside <strong class="source-inline">core_test.clj</strong>, we will keep tests for functions that are defined in the <strong class="source-inline">core.clj</strong> file. The <strong class="source-inline">utils_test.clj</strong> file will contain tests for functions defined in the <strong class="source-inline">utils.clj</strong> file.</p></li>
				<li>We will import the <strong class="source-inline">clojure.test</strong> library and namespaces from the source directory that we will test:<p class="source-code">(ns coffee-app.utils-test</p><p class="source-code">    (:require [clojure.test :refer [are is deftest testing]]</p><p class="source-code">                   [coffee-app.core :refer [price-menu]]</p><p class="source-code">                   [coffee-app.utils :refer :all]))</p><p>The <strong class="source-inline">clojure.test</strong> namespace has a number of testing functions. We import them using the <strong class="source-inline">:refer</strong> keyword, which we learned about in <em class="italic">Chapter 8</em>, <em class="italic">Namespaces, Libraries, and Leiningen</em>. We import four functions:</p><p><strong class="source-inline">are</strong>: Allows you to test multiple testing scenarios</p><p><strong class="source-inline">is</strong>: Allows you to test a single testing scenario</p><p><strong class="source-inline">deftest</strong>: Defines a Clojure test</p><p><strong class="source-inline">testing</strong>: Defines an expression that will be tested</p><p>We import the <strong class="source-inline">coffee-app.core</strong> and <strong class="source-inline">coffee-app.utils</strong> namespaces from the source directory. From the <strong class="source-inline">core</strong> namespace, we import <strong class="source-inline">price-menu</strong>, which contains a list of available coffees and the price for each coffee. Finally, we import the <strong class="source-inline">utils</strong> namespace, which contains the functions that we want to test.</p></li>
				<li>The <strong class="source-inline">clojure.test</strong> object provides the <strong class="source-inline">is</strong> macro for testing. We will learn about macros in <em class="italic">Chapter 11</em>, <em class="italic">Macros</em>. For the purpose of this exercise, you can think of macros as special functions. Macros are used in the same way as we have used functions.  <p>The <strong class="source-inline">is</strong> macro takes a test and an optional assertion message.  Add the following code to <strong class="source-inline">utils_test.clj</strong>:</p><p class="source-code">(deftest calculate-coffee-price-test-with-single-is</p><p class="source-code">  (testing "Single test with is macro."</p><p class="source-code">    (is (= (calculate-coffee-price price-menu :latte 1)</p><p class="source-code">             0.5))))</p><p>The <strong class="source-inline">deftest</strong> macro allows us to define tests. Each test is defined using the <strong class="source-inline">testing</strong> macro. The <strong class="source-inline">testing</strong> macro can be supplied with a string to provide a testing context. Here, we inform you that this is a single test using the <strong class="source-inline">is</strong> macro. In this test, we call the <strong class="source-inline">calculate-coffee-price</strong> function, passing <strong class="source-inline">price-menu</strong>, which contains information about the available coffees. </p><p>The second argument that we pass is the number of cups of coffee that we want to buy. In our case, we want to buy one cup. For the test, the result of calling the <strong class="source-inline">calculate-coffee-price</strong> function for one latte should be 0.5. </p><p>We will run the test now:</p><p class="source-code">lein test</p><p>The output is as follows:</p><div id="_idContainer179" class="IMG---Figure"><img src="image/B14502_10_11.jpg" alt="Figure 10.11: Running the test after using the is macro&#13;&#10;"/></div><p class="figure-caption">Figure 10.11: Running the test after using the is macro</p><p>We can see that the newly added test passes.</p></li>
				<li>While we can write tests with the <strong class="source-inline">is</strong> macro, testing multiple times with the <strong class="source-inline">is</strong> macro results in the unnecessary duplication of code. Consider the next test, where we run through three scenarios:<p>Buying one coffee – a user decides to buy one cup of coffee</p><p>Buying two coffees – a user decides to buy two cups of coffee</p><p>Buying three coffees – a user decides to buy three cups of coffee</p><p class="source-code">(deftest calculate-coffee-price-test-with-multiple-is</p><p class="source-code">  (testing "Multiple tests with is macro."</p><p class="source-code">    (is (= (calculate-coffee-price price-menu :latte 1) 0.5))</p><p class="source-code">    (is (= (calculate-coffee-price price-menu :latte 2) 1.0))</p><p class="source-code">    (is (= (calculate-coffee-price price-menu :latte 3) 1.5))))</p><p>Inside the <strong class="source-inline">calculate-coffee-price-test-with-multiple-is</strong> test, we have three single tests using the <strong class="source-inline">is</strong> macro. We test three different scenarios: buying one coffee, buying two coffees, and buying three coffees.</p></li>
				<li>Run multiple <strong class="source-inline">is</strong> tests. We run the tests for the <strong class="source-inline">calculate-coffee-price-test-with-multiple-is</strong> test:<p class="source-code">lein test</p><p>The output is as follows:</p><div id="_idContainer180" class="IMG---Figure"><img src="image/B14502_10_12.jpg" alt="Figure 10.12: Running multiple is tests&#13;&#10;"/></div><p class="figure-caption">Figure 10.12: Running multiple is tests</p><p>The new test has been run and passes. In the preceding code, we see that we duplicate a lot of calls to the <strong class="source-inline">calculate-coffee-price</strong> function. There should be a more efficient way to write tests for multiple scenarios.</p></li>
				<li>The <strong class="source-inline">are</strong> macro is a convenience macro when we plan to write multiple tests using the <strong class="source-inline">is</strong> macro. The <strong class="source-inline">are</strong> macro is a test macro used for testing multiple testing scenarios. It differs from the <strong class="source-inline">is</strong> macro in a number of scenarios that we can test.<p>The <strong class="source-inline">is</strong> macro allows us to test one scenario. It is singular. The <strong class="source-inline">are</strong> macro allows us to test more than one scenario. It is plural. We use the <strong class="source-inline">is</strong> macro when we want to test a single scenario and the <strong class="source-inline">are</strong> macro when we want to test more than one scenario. The previous test with multiple <strong class="source-inline">is</strong> macro calls can be rewritten as:</p><p class="source-code">(deftest calculate-coffee-price-test-with-are</p><p class="source-code">  (testing "Multiple tests with are macro"</p><p class="source-code">    (are [coffees-hash coffee-type number-of-cups result]</p><p class="source-code">            (= (calculate-coffee-price coffees-hash coffee-type number-of-cups) result)</p><p class="source-code">            price-menu :latte 1 0.5</p><p class="source-code">            price-menu :latte 2 1.0</p><p class="source-code">            price-menu :latte 3 1.5)))</p><p>The <strong class="source-inline">are</strong> macro checks multiple tests against the assertion written by us.</p><p>In the preceding test, we wrote an assertion:</p><p class="source-code">(= (calculate-coffee-price coffees-hash coffee-type number-of-cups) result)</p><p>The result of calling <strong class="source-inline">calculate-coffee-price</strong> with <strong class="source-inline">coffees-hash coffee-type number-of-cups</strong> should be equal to the result.</p><p>Inside the vector, we specify four arguments that we need to run our test:</p><p class="source-code">price-menu :latte 1 0.5</p><p>The arguments include coffee-hash with information about coffees, coffee-type, number-of-cups, and result – the result of calculating the coffee price.</p><p>Again, we use the <strong class="source-inline">equals</strong> (<strong class="source-inline">=</strong>) function to check the result of calling the <strong class="source-inline">calculate-coffee-price</strong> function against the result that we expect.</p></li>
				<li>When we run the tests again, we get the following:<p class="source-code">lein test</p><p>The output is as follows:</p><div id="_idContainer181" class="IMG---Figure"><img src="image/B14502_10_13.jpg" alt="Figure 10.13: Output for tests run after using the are macro&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.13: Output for tests run after using the are macro</p>
			<p>Our new test passes. We used the <strong class="source-inline">are</strong> macro to simplify writing multiple test assertions. Whenever we need to write multiple tests with the <strong class="source-inline">is</strong> macro, using the <strong class="source-inline">are</strong> macro will make our code shorter and more readable.</p>
			<p>In this exercise, we have seen how to write tests using the <strong class="source-inline">clojure.test</strong> library. In the next exercise, we will look at another Clojure library for testing.</p>
			<h1 id="_idParaDest-232"><a id="_idTextAnchor304"/>Using the Expectations Testing Library</h1>
			<p>The main philosophy in the <strong class="source-inline">Expectations</strong> library revolves around an expectation. The <strong class="source-inline">expectation</strong> object is built with the idea that unit tests should contain one assertion per test. A result of this design choice is that expectations have very minimal syntax, and reduce the amount of code needed to perform tests.</p>
			<p>Minimal syntax helps to maintain the code as it is easier to read and reason about code that is short and focused on testing one feature. Another benefit relates to testing failing code. When a test fails, it is easy to check which test failed and why because the test is focused on one feature and not multiple features.</p>
			<p>The <strong class="source-inline">Expectations</strong> library allows us to test things like the following:</p>
			<ul>
				<li>Errors thrown by the code: We can test whether a part of our code throws an error. Imagine a function that calculates a discount. This function takes numbers as input and multiplies them. If we pass a string such as "<strong class="source-inline">text</strong>" and a number <strong class="source-inline">5</strong>, we will get an error because Clojure cannot multiply a number and a string. We can write tests to check whether an error is thrown in this scenario.</li>
				<li>The function's return value: We can test whether a function returns the expected value. Imagine a function that calculates a discount. This function takes numbers as input and multiplies them. After the multiplication, it should return a number. We can write tests to check that our function returns a number instead of a collection or a string.</li>
				<li>Elements in a collection: We can write tests to check whether a collection contains expected elements. Imagine a function checking a list of users for children. This function takes a list of users as input. We can write tests checking the age of users. </li>
			</ul>
			<p>In order to use <strong class="source-inline">Expectations</strong>, we need to import it into a Leiningen project:</p>
			<ul>
				<li>We add a dependency for the <strong class="source-inline">expectations</strong> library [<strong class="source-inline">expectations "2.1.10"</strong>].</li>
				<li> <strong class="source-inline">lein-expectations</strong> is a Leiningen plugin that runs expectations tests from the command line <strong class="source-inline">[lein-expectations "0.0.8"]</strong>.</li>
			</ul>
			<p>We will write tests for the <strong class="source-inline">calculate-coffee-price</strong> function. This will allow us to compare how we compose tests in the <strong class="source-inline">Expectations</strong> library against tests written using the <strong class="source-inline">clojure.test</strong> library.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor305"/>Exercise 10.02: Testing the Coffee Application with Expectations</h2>
			<p>The aim of this exercise is to learn how to write unit testing in Clojure using the <strong class="source-inline">Expectations</strong> library. We will write tests for the <strong class="source-inline">calculate-coffee-price</strong> function: </p>
			<ol>
				<li value="1">Add <strong class="source-inline">expectations</strong> to the <strong class="source-inline">project.clj</strong> file. After adding the <strong class="source-inline">Expectations</strong> library to <strong class="source-inline">project.clj</strong>, the file should look as follows:<p class="source-code">(defproject coffee-app "0.1.0-SNAPSHOT"</p><p class="source-code">  ;;; code omitted</p><p class="source-code">  :dependencies [[org.clojure/clojure "1.10.0"]</p><p class="source-code">                           [expectations<a id="_idTextAnchor306"/> "2.1.10"]]</p><p class="source-code">  :plugins [[le<a id="_idTextAnchor307"/>in-expectations "0.0.8"]]</p><p class="source-code">  ;;; code omitted</p><p class="source-code">)</p></li>
				<li>Create a file for the <strong class="source-inline">utils</strong> tests.<p>In order to use the Expectations library, we need to import functions first. The <strong class="source-inline">utils</strong> namespace should look like the following:</p><p class="source-code">(ns coffee-app.utils-test</p><p class="source-code">    (:require [coffee-app.core :refer [price-menu]]</p><p class="source-code">                  [coffee-app.utils :refer :all]</p><p class="source-code">             <a id="_idTextAnchor308"/>     [expectations :refer [expect in]]))</p></li>
				<li>Test the <strong class="source-inline">calculate-coffee-price</strong> function. Buying three cups of latte should cost us 1.5. The following test will check this condition:<p class="source-code">(expect 1.5 (calculate-coffee-price price-menu :latte 3))</p><p>We are ready to run the test.</p></li>
				<li>Run the <strong class="source-inline">expectations</strong> test with the Leiningen task. In order to run tests on the command line, we need to use the Leiningen task from the <strong class="source-inline">lein-expectations</strong> plugin:<p class="source-code">lein expectations</p><p>This task will execute the <strong class="source-inline">expectations</strong> tests.</p><div id="_idContainer182" class="IMG---Figure"><img src="image/B14502_10_14.jpg" alt="Figure 10.14: Output after running the expectations test&#13;&#10;"/></div><p class="figure-caption">Figure 10.14: Output after running the expectations test</p><p>As we expected, for three lattes, we need to pay 1.5. What will happen if we pass a string instead of a number for a number of cups? We would expect an error. With <strong class="source-inline">expectations</strong>, we can test for errors.</p></li>
				<li>The <strong class="source-inline">expectations</strong> library allows us to test whether a function throws an error. The <strong class="source-inline">calculate-coffee-price</strong> function requires a number. Passing a string should result in an error:<p class="source-code">(expect ClassCastException (calculate-coffee-price price-menu :latte "1"))</p><p>The output is as follows:</p><div id="_idContainer183" class="IMG---Figure"><img src="image/B14502_10_15.jpg" alt="Figure 10.15: Testing the calculate-coffee-price function using the Expectations library&#13;&#10;"/></div><p class="figure-caption">Figure 10.15: Testing the calculate-coffee-price function using the Expectations library</p><p>After running the test, we see that all tests pass. Tests do not always pass. With <strong class="source-inline">expectations</strong>, we are informed when tests fail.</p></li>
				<li>When we run a test that fails, <strong class="source-inline">Expectations</strong> will let us know. Testing for an error when the error is not thrown will fail the test:<p class="source-code">(expect ClassCastException (calculate-coffee-price price-menu :latte 2))</p><p>The output is as follows:</p><div id="_idContainer184" class="IMG---Figure"><img src="image/B14502_10_16.jpg" alt="Figure 10.16: Running a test that fails using the Expectations library&#13;&#10;"/></div><p class="figure-caption">Figure 10.16: Running a test that fails using the Expectations library</p><p>The Expectations library informed us that one test failed. We also know in which namespace we have a failing test and which line of code caused the test to fail. This allows us to quickly find the failing test.</p><p>We know that passing a string to <strong class="source-inline">calculate-coffee-price</strong> will result in an error. With Expectations, we can also check what the return type from the function is.</p></li>
				<li>In Clojure code, we often compose functions. One function operates on the result of running other functions. It is common to check that functions that we call return the types of values that we expect. With <strong class="source-inline">Expectations</strong>, we can check the return type from a function:<p class="source-code">(expect Number (calculate-coffee-price price-menu :latte 2))</p><p>We expect that <strong class="source-inline">calculate-coffee-price</strong> will return a number:</p><div id="_idContainer185" class="IMG---Figure"><img src="image/B14502_10_17.jpg" alt="Figure 10.17: Using Expectations&#13;&#10;"/></div><p class="figure-caption">Figure 10.17: Using Expectations</p><p>Running the tests confirms that the number is the correct return type of the <strong class="source-inline">calculate-coffee-price</strong> function. With <strong class="source-inline">Expectations</strong>, we also can test whether a collection contains requested elements.</p></li>
				<li>The <strong class="source-inline">price-menu</strong> hash contains information about the available coffees, such as type and price. With <strong class="source-inline">Expectations</strong>, we can test whether elements belong to a collection:<p class="source-code">(expect {:latte 0.5} (in price-menu))</p><p>We expect that, on the menu, we have latte and that its price is <strong class="source-inline">0.5</strong>.</p><div id="_idContainer186" class="IMG---Figure"><img src="image/B14502_10_18.jpg" alt="Figure 10.18: Testing whether latte belongs to the menu&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.18: Testing whether latte belongs to the menu</p>
			<p>As expected, on our menu, we have a latte. We now know two testing libraries in Clojure: <strong class="source-inline">clojure.test</strong> and Expectations. The third testing library that we will learn about is <strong class="source-inline">Midje</strong>.</p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor309"/>Unit Testing with the Midje Library </h2>
			<p><strong class="source-inline">Midje</strong> is a testing library in Clojure that encourages writing readable tests. <strong class="source-inline">Midje</strong> builds on top of the bottom-up testing provided by <strong class="source-inline">clojure.test</strong> and adds support for top-down testing. Bottom-up testing means that we write tests for a single function first. If this function is used by some other function, we write tests after finishing the implementation for the other function. </p>
			<p>In the coffee-ordering application, we have the <strong class="source-inline">load-orders</strong> function:</p>
			<p class="source-code">(defn load-orders</p>
			<p class="source-code">      "Reads a sequence of orders in file at path."</p>
			<p class="source-code">      [file]</p>
			<p class="source-code">      (if (file-exists? file)</p>
			<p class="source-code">        (with-open [r (PushbackReader. (io/reader file))]</p>
			<p class="source-code">                   (binding [*read-eval* false]</p>
			<p class="source-code">                            (doall (take-while #(not= ::EOF %) (repeatedly #(read-one-order r))))))</p>
			<p class="source-code">        []))</p>
			<p>The <strong class="source-inline">load-orders</strong> function uses the <strong class="source-inline">file-exists?</strong> function. Functions in Clojure should not perform many things. It is good practice to have small functions focusing on single tasks. The <strong class="source-inline">file-exist</strong> function checks a file. The <strong class="source-inline">load-orders</strong> function loads orders. Because we cannot load orders from a file that does not exist, we need to use the <strong class="source-inline">file-exist</strong> function to check for a file with saved orders:</p>
			<p class="source-code">(defn file-exists? [location]</p>
			<p class="source-code">      (.exists (io/as-file location)))</p>
			<p>With bottom-up testing, we have to write the implementation for <strong class="source-inline">file-exists</strong> first. After we have a working implementation of <strong class="source-inline">file-exist</strong>, then we can write the implementation for <strong class="source-inline">load-orders</strong>. This way of writing tests forces us to think about implementation details for all functions instead of focusing on a feature that we want to implement. Our original goal was to load data from a file but we are focusing now on checking whether a file exists.</p>
			<p>With a top-down approach, we can write working tests for the main tested function without implementing functions that are used by the tested function. We state that we want to test the <strong class="source-inline">load-orders</strong> function and that it uses the file-exist function but we do not need to have a full implement of file-exist. We merely need to say that we will use this function. This allows us to focus on a feature that we want to test without worrying about implementing all sub-steps.</p>
			<p>In order to use <strong class="source-inline">Midje</strong>, add it as a dependency (<strong class="source-inline">[midje "1.9.4"] to project.clj</strong>) to the <strong class="source-inline">project.clj</strong> file.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor310"/>Exercise 10.03: Testing the Coffee Application with Midje</h2>
			<p>The aim of this exercise is to learn how to use the <strong class="source-inline">Midje</strong> library and write top-down tests. We will write tests for <strong class="source-inline">calculate-coffee-price</strong>. We will use a top-down approach to write tests for the load-orders function:</p>
			<ol>
				<li value="1">We will import the <strong class="source-inline">Midje</strong> namespace to the <strong class="source-inline">utils</strong> namespace:<p class="source-code">(ns coffee-app.utils-test</p><p class="source-code">    (:require [coffee-app.core :refer [price-menu]]</p><p class="source-code">              [coffee-app.utils :refer :all]</p><p class="source-code">              [midje.sweet :refer [=&gt; fact provided unfinished]]))</p><p>After importing the <strong class="source-inline">Midje</strong> namespace, we are ready to use the <strong class="source-inline">fact</strong> macro from the <strong class="source-inline">Midje</strong> namespace.</p></li>
				<li><strong class="source-inline">Midje</strong> uses the <strong class="source-inline">fact</strong> macro, which states certain facts about a future version of our test. The macro takes a single argument on both sides of the <strong class="source-inline">=&gt;</strong> symbol. The <strong class="source-inline">fact</strong> macro states that the result from the left-hand side is to be expected on the right-hand side of the symbol:<p class="source-code">(fact (calculate-coffee-price price-menu :latte 3) =&gt; 3)</p><p>We wrote a test where we expect that the price for three cups of latte is <strong class="source-inline">3</strong>.</p><p><strong class="source-inline">Midje</strong> supports autotesting in the REPL. </p></li>
				<li>With autotesting, we do not need to run tests every time we make changes. The autotester will run the tests anytime it detects changes. In order to use autotesting in <strong class="source-inline">Midje</strong>, we enable autotesting in the REPL:<p class="source-code">lein repl</p></li>
				<li>After starting the REPL, we import the <strong class="source-inline">Midje</strong> namespace and enable the autotester:<p class="source-code">user=&gt; (use 'midje.repl)</p><p class="source-code">user=&gt; (autotest)</p><p>After starting the REPL, we imported the <strong class="source-inline">Midje</strong> namespace.</p><p>The second step was calling the <strong class="source-inline">autotest</strong> function. This function will run the tests automatically when our code changes.</p><p>After enabling autotesting, our tests are run thanks to the <strong class="source-inline">autotest</strong> function that we used in the REPL:</p><div id="_idContainer187" class="IMG---Figure"><img src="image/B14502_10_19.jpg" alt="Figure 10.19: Executing the tests&#13;&#10;"/></div><p class="figure-caption">Figure 10.19: Executing the tests</p></li>
				<li><strong class="source-inline">Midje</strong> informs us that our tests failed. The price for three cups of latte is not <strong class="source-inline">3</strong> but <strong class="source-inline">1.5</strong>. When we change the implementation of the test, the autotest runs again:<p class="source-code">(fact (calculate-coffee-price price-menu :latte 3) =&gt; 1.5)</p><p>The autotest runs as follows:</p><div id="_idContainer188" class="IMG---Figure"><img src="image/B14502_10_20.jpg" alt="Figure 10.20: Running autotest after changing the implementation&#13;&#10;"/></div><p class="figure-caption">Figure 10.20: Running autotest after changing the implementation</p><p>This time, we are informed that our tests pass. We know now how to run autotests and how to write tests using <strong class="source-inline">Midje</strong>. It is time now to explore top-down testing in <strong class="source-inline">Midje</strong>.</p></li>
				<li>In the <strong class="source-inline">utils</strong> namespace, we have the <strong class="source-inline">display-bought-coffee-message</strong> function, which displays a message about the number of coffee types bought. This function has a hardcoded currency symbol:<p class="source-code">(defn display-bought-coffee-message [type number total]</p><p class="source-code">      (str "Buying" number (name type) "coffees for total:€" total))</p><p>It would be nice to obtain the currency code from a utility function and not hardcode it. As some countries use the same currency, just as the euro is used in many European countries, it is a good idea to encapsulate the logic of getting the currency into a function. </p></li>
				<li>We will keep the information about the currencies in a hash. Remember from <em class="italic">Chapter 1</em>, <em class="italic">Hello REPL!</em>, that a hash is a Clojure collection where we store data using keys and values:<p class="source-code">(def ^:const currencies {:euro {:countries #{"France" "Spain"} :symbol "€"}</p><p class="source-code">                                        :dollar {:countries #{"USA"} :symbol "$"}})</p><p>This allows us to check the currencies that different countries use and currency symbols.</p></li>
				<li>As we do not plan to write the implementation for the functions of currencies, we will provide a stub (substitution) for it.<p>We saw an explanation of a stub at the beginning of this chapter:</p><p class="source-code">(unfinished get-currency)</p></li>
				<li>This tells <strong class="source-inline">Midje</strong> that we plan to use the <strong class="source-inline">get-currency</strong> function but we have not implemented it yet. We will test against the euro, so we will add the <strong class="source-inline">helper</strong> var:<p class="source-code">(def test-currency :euro)</p></li>
				<li>The function for displaying information about bought coffees will initially look like this:<p class="source-code">(defn get-bought-coffee-message-with-currency [type number total currency]</p><p class="source-code">      (format "Buying %d %s coffees for total: %s%s" number (name type) "€" total))</p></li>
				<li>The test for the <strong class="source-inline">get-bought-coffee-message-with-currency</strong> function looks as follows:<p class="source-code">(fact "Message about number of bought coffees should include currency symbol"</p><p class="source-code">      (get-bought-coffee-message-with-currency :latte 3 1.5 :euro) =&gt; "Buying 3 latte coffees for total: €1.5"</p><p class="source-code">      (provided</p><p class="source-code">        (get-currency test-currency) =&gt; "€"))</p><p>In the test, we use the <strong class="source-inline">Midje =&gt;</strong> symbol. We expect the result of calling <strong class="source-inline">get-bought-coffee-message-with-currency</strong> to equal the string message.</p><p>We use the provided function from <strong class="source-inline">Midje</strong> to stub call to the <strong class="source-inline">get-currency</strong> function. When the <strong class="source-inline">Midje</strong> test calls this function, it should return the euro symbol, €.</p><p>If we check autorun in the REPL, we will see the following:</p><div id="_idContainer189" class="IMG---Figure"><img src="image/B14502_10_21.jpg" alt="Figure 10.21: Testing the get-bought-coffee-message-with-currency function using Midje&#13;&#10;"/></div><p class="figure-caption">Figure 10.21: Testing the get-bought-coffee-message-with-currency function using Midje</p></li>
				<li><strong class="source-inline">Midje</strong> informs us that one test failed. The <strong class="source-inline">get-currency</strong> function should have been called but was not called at all. We just wrote a test that compiled and ran. We did not get a compilation error. We focused on the logic for displaying a message and this part was a success. Once we have a test for <strong class="source-inline">get-bought-coffee-message-with-currency</strong>, it is time now to think about using <strong class="source-inline">get-currency</strong> to display messages:<p class="source-code">(defn get-bought-coffee-message-with-currency [type number total currency]</p><p class="source-code">      (format "Buying %d %s coffees for total: %s%s" number (name type) (get-currency test-currency) total))</p><p>This implementation of the <strong class="source-inline">get-bought-coffee-message-with-currency</strong> function uses the <strong class="source-inline">get-currency</strong> function:</p><div id="_idContainer190" class="IMG---Figure"><img src="image/B14502_10_22.jpg" alt="Figure 10.22: Testing again after using the get-currency function&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.22: Testing again after using the get-currency function</p>
			<p>When we check the autotest in the REPL, we see that all tests pass now.</p>
			<p>In this exercise, we were able to write tests using the <strong class="source-inline">Midje</strong> library. This library allows us to write tests using a top-down approach where we think about testing the main function and any other functions called by it are stubbed first. This helps us to focus on the behavior of the main function under test without worrying about implementing all of the used functions.</p>
			<p>While we wrote tests using various libraries, all tests are limited. When we tested <strong class="source-inline">calculate-coffee-price</strong>, we tested it a few times. If we could test it more times, we could be more confident that the <strong class="source-inline">calculate-coffee-price</strong> function is performing as expected. Writing a few tests can be quick but writing 100 or 200 tests takes time. Luckily, with property-based testing, we can generate lots of test scenarios very quickly.</p>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor311"/>Property-Based Testing</h1>
			<p><strong class="bold">Property-based testing</strong>, also known as generative testing, describes properties that should be true for all valid test scenarios. A property-based test consists of a method for generating valid inputs (also known as a generator), and a function that takes a generated input. This function combines a generator with the function under test to decide whether the property holds for that particular input. With property-based testing, we automatically generate data across a wide search space to find unexpected problems.</p>
			<p>Imagine a room-booking application. We should allow users to search for rooms suitable for families. Such rooms should have at least two beds. We could have a function that returns only those rooms that have at least two beds. With unit testing, we would need to write scenarios for the following:</p>
			<ul>
				<li>Zero beds</li>
				<li>One bed</li>
				<li>Two beds</li>
				<li>Three beds</li>
				<li>Four beds</li>
				<li>Five beds</li>
				<li>And other scenarios</li>
			</ul>
			<p>If we wanted to test rooms with 20 beds, it would mean creating over 20 tests that are very similar. We would only change the number of beds. We can generalize such tests by describing what a family room is in general terms. As we said, a family room would have at least two beds. Property-based testing allows us to generalize inputs and generate them for us. Because inputs are generated automatically, we are not limited to manually typing tests and we could create 1,000 test scenarios easily. For our family room example, the input is a number of rooms. Testing would involve specifying that a room number is a number. With property-based tests, integer inputs would be automatically generated for us. </p>
			<p>Clojure provides the <strong class="source-inline">test.check</strong> library for property-based testing. Property-based testing has two key concepts:</p>
			<ul>
				<li><strong class="bold">Generators</strong>: A generator knows how to generate random values for a specific type. One generator could create strings, another generator could create numbers. The <strong class="source-inline">test.check.generators</strong> namespace has many built-in generators, as well as combinator functions for creating your own new generators from the built-in generators.</li>
				<li><strong class="bold">Properties</strong>: Properties are characteristics of inputs. An input to any function can be described in general terms. In our family room example, the input is a number of rooms. So, the property is a number.</li>
			</ul>
			<p>In the next exercise, we will write property-based tests for the coffee-ordering application.</p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor312"/>Exercise 10.04: Using Property-Based Testing in the Coffee-Ordering Application</h2>
			<p>The aim of this exercise is to learn how to create tests using property-based testing. We will describe inputs for the <strong class="source-inline">calculate-coffee-price</strong> function and this will allow us to generate tests automatically. </p>
			<p>In order to use the <strong class="source-inline">test.check</strong> library, we need to add <strong class="source-inline">[org.clojure/test.check "0.10.0"]</strong> as a dependency in the <strong class="source-inline">project.clj</strong> file:</p>
			<ol>
				<li value="1">Before we can use <strong class="source-inline">test.check</strong> in the utils namespace, we need to import the necessary namespaces:<p class="source-code">(ns coffee-app.utils-test</p><p class="source-code">    (:require     [clojure.test.check :as tc]</p><p class="source-code">                  [clojure.test.check.generators :as gen]</p><p class="source-code">                  [clojure.test.check.properties :as prop]</p><p class="source-code">                  [clojure.test.check.clojure-test :refer [defspec]]</p><p class="source-code">                  [coffee-app.core :refer [price-menu]]</p><p class="source-code">                  [coffee-app.utils :refer :all]))</p><p>We import three <strong class="source-inline">test.check</strong> namespaces:</p><p><strong class="source-inline">clojure.test.check.generators</strong>: Will generate inputs</p><p><strong class="source-inline">clojure.test.check.properties</strong>: Will allow us to describe inputs in a general form</p><p><strong class="source-inline">clojure.test.check.clojure-test</strong>: Will allow us to integrate with clojure.test</p><p>If we wanted to import these namespaces in the REPL, we would do the following:</p><p class="source-code">(require '[clojure.test.check :as tc]</p><p class="source-code">              '[clojure.test.check.generators :as gen]</p><p class="source-code">              '[clojur<a id="_idTextAnchor313"/>e.test.check.properties :as prop])</p><p>Once we have the necessary namespaces imported, we can look at how to generate inputs.</p></li>
				<li>In order to generate inputs for tests, we will use generators. The <strong class="source-inline">calculate-coffee-price</strong> function takes a number of cups as an argument. A generator creating numbers such as <strong class="source-inline">small-integer</strong> is what we need:<p class="source-code">(gen/sample gen/small-integer)</p><p>The <strong class="source-inline">small-integer</strong> function from the generators' namespace returns an integer between <strong class="source-inline">-32768</strong> and <strong class="source-inline">32767</strong>. The <strong class="source-inline">sample</strong> function returns a sample collection of the specified type. In the preceding example, we have a sample collection of small integers:</p><div id="_idContainer191" class="IMG---Figure"><img src="image/B14502_10_23.jpg" alt="Figure 10.23: Creating a sample of small integers&#13;&#10;"/></div><p class="figure-caption">Figure 10.23: Creating a sample of small integers</p></li>
				<li>With generator combinators, we can obtain new generators. The <strong class="source-inline">fmap</strong> generator allows us to create a new generator by applying a function to the values created by another generator. The <strong class="source-inline">fmap</strong> generator works like the <strong class="source-inline">map</strong> function, which we know about from the first chapter. It allows us to map a function to a value created by the following generator. In this example, each integer created by the <strong class="source-inline">small-integer</strong> generator is incremented using the <strong class="source-inline">inc</strong> function:<p class="source-code">(gen/sample (gen/fmap inc gen/small-integer))</p><p>This will return the following:</p><p class="source-code">(1 2 1 -1 -3 4 -5 -1 7 -6)</p><p>We were able to increase the numbers generated by the <strong class="source-inline">small-integer</strong> generator by applying the <strong class="source-inline">inc</strong> function using the <strong class="source-inline">fmap</strong> combinator.</p><p>We now know how to create inputs using generators. It is time to learn how to describe the properties of inputs.</p></li>
				<li>A property is an actual test — it combines a generator with a function you want to test, and checks that the function behaves as expected given the generated values.<p>Properties are created using the <strong class="source-inline">for-all</strong> macro from the <strong class="source-inline">clojure.test.check.properties</strong> namespace: </p><p class="source-code">(defspec coffee-price-test-check 1000</p><p class="source-code">         (prop/for-all [int gen/small-integer]</p><p class="source-code">                       <a id="_idTextAnchor314"/>(= (float (* int (:latte price-menu))) (calculate-coffee-price price-menu :latte int))))</p><p>The <strong class="source-inline">defspec</strong> macro allows you to run <strong class="source-inline">test.check</strong> tests like standard <strong class="source-inline">clojure.test</strong> tests. This allows us to extend test suits to include property-based testing together with standard unit tests. In the <strong class="source-inline">for-all</strong> macro, we use a small-integer generator to create a number of small integers. Our test passes when the number of coffee cups value created by the generator is multiplied by the price of the coffee. The result of this calculation should equal the result of running the <strong class="source-inline">calculate-coffee-price</strong> function. We intend to run the test 1,000 times. This is amazing that with three lines of code we were able to create 1,000 tests.</p></li>
				<li>We can run <strong class="source-inline">test.check</strong> tests using Leiningen:<p class="source-code">lein test</p><p>The output is as follows:</p><div id="_idContainer192" class="IMG---Figure"><img src="image/B14502_10_24.jpg" alt="Figure 10.24:Testing test.check using Leiningen&#13;&#10;"/></div><p class="figure-caption">Figure 10.24:Testing test.check using Leiningen</p><p>After running tests with <strong class="source-inline">lein test</strong>, we will quickly get a result similar to the following:</p><p class="source-code">{:num-tests 5,</p><p class="source-code"> :seed 1528580863556,</p><p class="source-code"> :fail [[-2]],</p><p class="source-code"> :failed-after-ms 1,</p><p class="source-code"> :result false,</p><p class="source-code"> :result-data nil,</p><p class="source-code"> :failing-size 4,</p><p class="source-code"> :pass? false,</p><p class="source-code"> :shrunk</p><p class="source-code"> {:total-nodes-visited 5,</p><p class="source-code">  :depth 1,</p><p class="source-code">  :pass? false,</p><p class="source-code">  :result false,</p><p class="source-code">  :result-data nil,</p><p class="source-code">  :time-shrinking-ms 1,</p><p class="source-code">  :smallest [[-1]]}}</p><p>Our test failed. The original failing example <strong class="source-inline">[-2]</strong> (given at the <strong class="source-inline">:fail</strong> key) has been shrunk to <strong class="source-inline">[-1]</strong> (under <strong class="source-inline">[:shrunk :smallest]</strong>). The test failed because in the implementation of <strong class="source-inline">calculate-coffee-price</strong>,  we return only absolute, non-negative values. The current implementation of <strong class="source-inline">calculate-coffee-price</strong> is as follows:</p><p class="source-code">(defn calculate-coffee-price [coffees coffee-type number]</p><p class="source-code">      (-&gt;</p><p class="source-code">        (get coffees coffee-type)</p><p class="source-code">        (* number)</p><p class="source-code">        float</p><p class="source-code">        Math/abs))</p><p>In the last line, we have the <strong class="source-inline">Math/abs</strong> function call. <strong class="source-inline">calculate-coffee-price</strong> should return only absolute numbers. Yet in our tests we allowed negative numbers to be generated. We need to use a different generator to match the expected result from the <strong class="source-inline">calculate-coffee-price</strong> function.</p></li>
				<li><strong class="source-inline">test.check</strong> provides a <strong class="source-inline">nat</strong> generator that can create natural numbers (non-negative integers).<p>The test for <strong class="source-inline">calculate-coffee-price</strong> should be updated to the following:</p><p class="source-code">(defspec coffee-price-test-check 1000</p><p class="source-code">         (prop/for-all [int gen/nat]</p><p class="source-code">                       (= (float (* int (:latte price-menu))) (calculate-coffee-price price-menu :latte int))))</p><p>When we run tests with this generator, the tests pass:</p><p class="source-code">lein test</p><p>The output is as follows:</p><div id="_idContainer193" class="IMG---Figure"><img src="image/B14502_10_25.jpg" alt="Figure 10.25: Using nat to create non-negative integers and running tests&#13;&#10;"/></div><p class="figure-caption">Figure 10.25: Using nat to create non-negative integers and running tests</p><p>We were able to test the <strong class="source-inline">calculate-coffee-price</strong> function 1,000 times. We generated an integer each time and used the integer as a number of cups. With <strong class="source-inline">test.check</strong>, we can truly check parameters against generated inputs. We have tested only the number of cups parameter. It is time to write generators and test all of the parameters. </p></li>
				<li>In order to generate all of the remaining parameters for the <strong class="source-inline">calculate-coffee-price</strong> function, we will use some new generators. The code for creating all parameters is as follows:<p class="source-code">(defspec coffee-price-test-check-all-params 1000</p><p class="source-code">  (prop/for-all [int (gen/fmap inc gen/nat)</p><p class="source-code">                      price-hash (gen/map gen/keyword </p><p class="source-code">                                                (gen/double* {:min 0.1 :max 999 :infinite? false :NaN? false}) </p><p class="source-code">                                       {:min-elements 2})]  </p><p class="source-code">                       (let [coffee-tuple (first price-hash)]</p><p class="source-code">                            (= (float (* int (second coffee-tuple)))</p><p class="source-code">                                 (calculate-coffee-price price-hash (first coffee-tuple) int)))))</p><p>The coffee hash that stores the coffee menu contains information about the coffee type as a key and its value as a double:</p><p class="source-code">{:latte 0.5 :mocha 0.4}</p><p>The <strong class="source-inline">gen/map</strong> generator allows us to create a hash. In the hash, we want to generate a keyword as a key and a double for a value. We limit the value to be between 0.1 and 999. We are only interested in numbers. We do not want to get an infinite value. With generators, we could create an infinite value if we wanted. We also do not want a NaN (not a number) to be generated. Lastly, our hash should have at least two elements – two tuples to be precise. Each tuple is a pair of a key and a value.</p><p>In the <strong class="source-inline">let</strong> block, we take the first tuple and assign it to <strong class="source-inline">coffee-tuple</strong>. This will help us to test and pass appropriate arguments to the <strong class="source-inline">calculate-coffee-price</strong> function.</p><p>We will run the tests again:</p><p class="source-code">lein test</p><p>The output is as follows:</p><div id="_idContainer194" class="IMG---Figure"><img src="image/B14502_10_26.jpg" alt="Figure 10.26: Running the tests after generating all parameters for the calculate-coffee-price function&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.26: Running the tests after generating all parameters for the calculate-coffee-price function</p>
			<p>We see that both <strong class="source-inline">test.check</strong> tests pass. With a few lines of code, we were able to test 2,000 scenarios. This is amazing.</p>
			<p>So far, we have tested the <strong class="source-inline">calculate-coffee-price</strong> function. In the following activity, you will write tests for other functions from the coffee-ordering application.</p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor315"/>Activity 10.01: Writing Tests for the Coffee-Ordering Application</h2>
			<p>In this activity, we will apply knowledge about unit testing to write a test suite. Many applications running in production are very complex. They have lots of features. Developers write unit tests in order to increase their trust in the application. The features coded should fulfill business needs. A well written and maintained test suite gives confidence to developers and people using such applications that the applications' features perform as expected.</p>
			<p>The coffee-ordering application that we wrote in the previous chapter allowed us to display the coffee menu and order some coffees. In this chapter, we have learned about unit testing libraries in Clojure by testing the <strong class="source-inline">calculate-coffee-price</strong> function. In the coffee-ordering application, there are still functions that have not been tested.</p>
			<p>In this activity, we will write unit tests for the following functions:</p>
			<ul>
				<li><strong class="source-inline">display-order</strong>: Displays information about the order</li>
				<li><strong class="source-inline">file-exist</strong>: Checks whether a given file exists</li>
				<li><strong class="source-inline">save-coffee-order</strong>: Saves the coffee order to a file</li>
				<li><strong class="source-inline">load-orders</strong>: Loads coffee orders from a file</li>
			</ul>
			<p>These steps will help you complete the activity:</p>
			<ol>
				<li value="1">Import the testing namespace.</li>
				<li>Create tests using the <strong class="source-inline">clojure.test</strong> library to display orders messages:<p>Tests using <strong class="source-inline">is</strong> macro</p><p>Tests using <strong class="source-inline">are</strong> macro</p></li>
				<li>Create tests using the <strong class="source-inline">clojure.test</strong> library to test if the file exists or if the file does not exist</li>
				<li>Create tests using the <strong class="source-inline">clojure.test</strong> library to save orders, load empty orders, load coffee orders.</li>
				<li>Create tests using the <strong class="source-inline">expectations</strong> library to save data to file, save coffee orders, save coffee data, and load orders</li>
				<li>Create tests using the <strong class="source-inline">expectations</strong> library to check whether the file exists.</li>
				<li>Create tests using the <strong class="source-inline">expectations</strong> library to save and load orders.</li>
				<li>Create tests using the <strong class="source-inline">Midje</strong> library to display the orders messages.</li>
				<li>Create tests using the <strong class="source-inline">Midje</strong> library to check whether the file exists.</li>
				<li>Create tests using the <strong class="source-inline">Midje</strong> library to load orders.</li>
				<li>Create tests using <strong class="source-inline">test.check</strong> to display the orders messages:<p>Import the <strong class="source-inline">test.check</strong> namespace</p><p>Test the displayed orders</p></li>
				<li>Create tests using <strong class="source-inline">test.check</strong> to check whether the file exists.</li>
				<li>Create tests using <strong class="source-inline">test.check</strong> to load orders.</li>
			</ol>
			<p>The output of the <strong class="source-inline">clojure.test</strong> and <strong class="source-inline">test.check</strong> tests will look as follows:</p>
			<div>
				<div id="_idContainer195" class="IMG---Figure">
					<img src="image/B14502_10_27.jpg" alt="Figure 10.27: Expected output for the clojure.test and test.check tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.27: Expected output for the clojure.test and test.check tests</p>
			<p>The output of the <strong class="source-inline">expectations</strong> tests will look as follows:</p>
			<div>
				<div id="_idContainer196" class="IMG---Figure">
					<img src="image/B14502_10_28.jpg" alt="Figure 10.28: Expected output for the expectations test&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.28: Expected output for the expectations test</p>
			<p>The output of the <strong class="source-inline">Midje</strong> tests will look as follows:</p>
			<div>
				<div id="_idContainer197" class="IMG---Figure">
					<img src="image/B14502_10_29.jpg" alt="Figure 10.29: Output for the Midje tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.29: Output for the Midje tests</p>
			<p>The output of the <strong class="source-inline">test.check</strong> tests will look as follows:</p>
			<div>
				<div id="_idContainer198" class="IMG---Figure">
					<img src="image/B14502_10_30.jpg" alt="Figure 10.30: Output for the test.check tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.30: Output for the test.check tests</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 723.</p>
			<p>We now know how to write unit tests in Clojure using four libraries. In the next section, we will look at testing in ClojureScript.</p>
			<h1 id="_idParaDest-239"><a id="_idTextAnchor316"/>Testing in ClojureScript</h1>
			<p>In Clojure, we used the <strong class="source-inline">clojure.test</strong> library for testing. In ClojureScript, we have a port of <strong class="source-inline">clojure.test</strong> in the form of <strong class="source-inline">cljs.test</strong>. In <strong class="source-inline">cljs.test</strong>, we have functionality that we used when we wrote tests using the <strong class="source-inline">clojure.test</strong> library. We can use the <strong class="source-inline">is</strong> and <strong class="source-inline">are</strong> macros to write our tests. <strong class="source-inline">cljs.test</strong> provides facilities for asynchronous testing. Asynchronous testing is a type of testing that tests asynchronous code. We will see shortly why it is important that <strong class="source-inline">cljs.test</strong> allows us to test asynchronous code.</p>
			<p>Synchronous code is what developers write most of the time, even without realizing this. In synchronous code, code is executed line by line. For example, the code defined in line 10 needs to finish executing before the code on line 11 can start executing. This is step-by-step execution. Asynchronous coding is a more advanced concept. </p>
			<p>In asynchronous programming, executing code and completing the execution of code cannot happen in a line-by-line fashion. For example, we could schedule downloading a song on line 10 and then on line 11 we could have code to let the user know that downloading has finished. In synchronous code, we would have to wait for the download to finish before we can show information to the user or perform some other actions. This is not what we would really want. We would like to inform the user about the progress as we download the song. In asynchronous code, we would schedule downloading a song and start showing the progress bar before the song is downloaded.</p>
			<p>In Java and Clojure, we would use threads to write asynchronous code. A thread is a process on a JVM that consumes little computer resources. One thread would handle downloading a song and the other would display the progress bar.</p>
			<p>As we learned in <em class="italic">Chapter 1</em>, <em class="italic">Hello REPL</em>, ClojureScript runs on top of JavaScript. JavaScript provides a single-thread environment. This is in contrast to Java, which allows creating many threads. Writing code for one thread is simpler as we do not need to coordinate resource-sharing between many threads. ClojureScript applications requiring asynchronous code need to use some other facilities than threads.</p>
			<p>JavaScript provides callbacks to manage writing asynchronous code. Callbacks are functions that we define to be run once certain conditions are met. In our downloading example, a callback would let us know when downloading is finished so we can inform the user.</p>
			<p>ClojureScript provides the <strong class="source-inline">core.async</strong> library for working with asynchronous code. The <strong class="source-inline">core.async</strong> library has a number of functions and macros:</p>
			<ul>
				<li><strong class="source-inline">go</strong>: Creates a block that marks the code as asynchronous. The result from the block is put on a channel.</li>
				<li><strong class="source-inline">&lt;!</strong>: Takes a value from a channel.</li>
			</ul>
			<p>Why do we need a go block and channels?</p>
			<p>Asynchronous code is by definition asynchronous. We do not know when we will get a return value from an asynchronous call. When we use channels for asynchronous calls, our code becomes simpler. This happens because return values are put on a channel. We do not need to manage this channel. <strong class="source-inline">core.async</strong> does this management for us. When we are ready, we just take value from this channel. Without explicit channel management, our code is shorter as the code can focus on simpler tasks that we program.</p>
			<p>In the following exercise, we will see how to set up and use testing libraries in ClojureScript. </p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor317"/>Exercise 10.05: Setting Up Testing in ClojureScript</h2>
			<p>The aim of this exercise is to learn how to set up testing libraries in ClojureScript and how to use those libraries. We will use <strong class="source-inline">cljs.test</strong> for testing.</p>
			<p>In this exercise, we will create a number of folders and files. There are many ways to create folders and files. Readers are welcome to use any methods they are most comfortable with. The following steps will use the command line.</p>
			<div>
				<div id="_idContainer199" class="IMG---Figure">
					<img src="image/B14502_10_31.jpg" alt="Figure 10.31: Command and it's description&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.31: Command and it's description</p>
			<ol>
				<li value="1">Create a project named <strong class="source-inline">hello-test</strong>, as follows:<p class="source-code">mkdir hello-test</p><p>This will create a project where we will keep our code. Once we finish setting up, the project structure should look like the following screenshot. We can see the project structure using the <strong class="source-inline">tree</strong> command or your preferred way to check directories:</p><p class="source-code">tree</p><p>The output is as follows: </p><div id="_idContainer200" class="IMG---Figure"><img src="image/B14502_10_32.jpg" alt="Figure 10.32: Project structure&#13;&#10;"/></div><p class="figure-caption">Figure 10.32: Project structure</p></li>
				<li>Inside the source folder, we will keep our code:<p class="source-code">mkdir -p src/hello_test</p><p>Executing this command will create the <strong class="source-inline">src</strong> and <strong class="source-inline">hello_test</strong> folders.</p></li>
				<li>Create a source file. In the source file, we will keep our code:<p class="source-code">touch src/hello_test/core.cljs</p><p>This command creates an empty core file.</p></li>
				<li>Create a core namespace. Inside the <strong class="source-inline">core.cljs</strong> file, add a namespace:<p class="source-code">(ns hello-test.core)</p></li>
				<li>Inside the <strong class="source-inline">core.cljs</strong> file, put a function for adding numbers:<p class="source-code">(defn adder [x y ]</p><p class="source-code">      (+ x y))</p></li>
				<li>Create a testing folder.<p>We will create a folder for our testing files:</p><p class="source-code">mkdir -p test/hello_test</p><p>This command will create the <strong class="source-inline">test</strong> and <strong class="source-inline">hello_test</strong> folders.</p></li>
				<li>Create the configuration. <p>We will keep the project configuration in the <strong class="source-inline">project.clj</strong> file. The file should look like the following:</p><p class="source-code">(defproject hello-test "0.1.0-SNAPSHOT"</p><p class="source-code">            :description "Testing in ClojureScript"</p><p class="source-code">            :dependencies [[org.clojure/clojure "1.10.0"]</p><p class="source-code">                           [org.clojure/clojurescript "1.10.520"]</p><p class="source-code">                           [cljs-http "0.1.46"]</p><p class="source-code">                           [org.clojure/test.check "0.10.0"]</p><p class="source-code">                           [funcool/cuerdas "2.2.0"]])</p><p>This is a standard <strong class="source-inline">project.clj</strong> file like we created in <em class="italic">Chapter 8</em>, <em class="italic">Namespaces, Libraries and Leiningen</em>. Inside the project.clj file, we have the <strong class="source-inline">:dependencies</strong> key where we put the libraries that we need for testing.</p><p>The <strong class="source-inline">cljs-http</strong> library will allow us to make HTTP calls. We will use <strong class="source-inline">GET</strong> requests to make asynchronous calls that will be tested.</p><p>The <strong class="source-inline">cuerdas</strong> library has many string utility functions. Some of the functions are as follows:</p><p><strong class="source-inline">capital</strong>: Uppercases the first character of a string. The string "john" becomes "John".</p><p><strong class="source-inline">Clean</strong>: Trims and replaces multiple spaces with a single space. The string "   a    b    " becomes "a b."</p><p><strong class="source-inline">Human</strong>: Converts a string or keyword into a human-friendly string (lowercase and spaces). The string "DifficultToRead" becomes "difficult to read."</p><p><strong class="source-inline">Reverse</strong>: Returns a reverted string. The string "<strong class="source-inline">john</strong>" becomes "<strong class="source-inline">nhoj</strong>."</p><p>We will write unit tests manipulating strings.</p></li>
				<li>Add a test plugin dependency. We will use the <strong class="source-inline">lein-doo</strong> plugin to run ClojureScript tests. Add the following line in <strong class="source-inline">project.clj</strong>:<p class="source-code">:plugins [[lein-doo "0.1.11"]]</p><p>The <strong class="source-inline">lein-doo</strong> plugin will be used to run ClojureScript tests. This plugin will autorun tests and display test results. We will run <strong class="source-inline">lein-doo</strong> against a web browser environment. <strong class="source-inline">lein-doo</strong> relies on the JavaScript <strong class="source-inline">Karma</strong> library to run tests in a JavaScript environment. Karma is a JavaScript tool that helps to run JavaScript tests. We need to install the necessary dependencies for <strong class="source-inline">Karma</strong>.</p></li>
				<li>Install Karma. Karma is distributed using <strong class="bold">Node Package Manager</strong> (<strong class="bold">NPM</strong>). <strong class="source-inline">npm</strong> is an equivalent of Maven that we learned about in <em class="italic">Chapter 8</em>, <em class="italic">Namespaces, Libraries, and Leiningen</em>. Basically, it is a repository of projects. While Maven hosts Java projects, npm hosts JavaScript projects.<p>We will use npm to install Karma:</p><p class="source-code">npm install karma karma-cljs-test –save-dev</p><p>With the <strong class="source-inline">-save-dev</strong> flag, we install the <strong class="source-inline">karma</strong> packages in the current directory. The purpose of using the <strong class="source-inline">-save-dev</strong> flag is to allow us to separate different test configurations between projects. One legacy project could still rely on an old version of Karma while a new project could use a newer version of Karma.</p></li>
				<li>We will install the Chrome Karama launcher. Our tests will be run (launched) in the Chrome browser: <p class="source-code">npm install karma-chrome-launcher –save-dev</p><p>The preceding command searches <strong class="source-inline">npm</strong> for <strong class="source-inline">karma-chrome-launcher</strong> projects. When <strong class="source-inline">npm</strong> finds this project, it will download the Chrome launcher and install it. With the -<strong class="source-inline">save-dev</strong> flag, we install the karma-chrome-launcher in the current directory.</p></li>
				<li>Install the Karma command-line tool.<p>The final step to install the Karma libraries is to install command-line tools that allow executing Karma commands:</p><p class="source-code">npm install -g karma-cli</p><p>We install Karma command-line tools globally as the ClojureScript plugin running the tests needs to access Karma commands.</p></li>
				<li>We need to set the build configuration for the test task in the <strong class="source-inline">project.clj </strong>file:<p class="source-code">:cljsbuild {:builds</p><p class="source-code">                    {:test {:source-paths ["src" "test"]</p><p class="source-code">                                             :compiler {:output-to "out/tests.js"</p><p class="source-code">                                                              :output-dir "out"</p><p class="source-code">                                                              :main hello-test.runner</p><p class="source-code">                                                              :optimizations :none}}}}</p><p>ClojureScript build configurations are set under the <strong class="source-inline">:cljsbuild </strong>key in the project.clj file. We specify one <strong class="source-inline">:browser-test</strong> build. This build will access files from the <strong class="source-inline">src</strong> and <strong class="source-inline">test</strong> directories. The code will be compiled to the <strong class="source-inline">out</strong> directory to the <strong class="source-inline">tests.js</strong> file. The <strong class="source-inline">:main</strong> entry point for tests is the <strong class="source-inline">hello-test.runner</strong> namespace. For testing, we do not need any optimizations for compilation so we set the optimizations parameter to <strong class="source-inline">:none</strong>.</p></li>
				<li>Create a core test file:<p class="source-code">touch test/hello_test/core_test.cljs</p><p>This command creates the <strong class="source-inline">core_test.cljs</strong> file.</p></li>
				<li>Import the testing namespaces.<p>The <strong class="source-inline">core_test.cljs</strong> file will contain the tests. We need to import the necessary namespaces:</p><p class="source-code">(<a id="_idTextAnchor318"/>ns hello-test.core-test</p><p class="source-code">  (:require [cljs.test :refer-macros [are async deftest is testing]]</p><p class="source-code">                [clojure.test.check.generators :as gen]</p><p class="source-code">                [clojure.test.check.properties :refer-macros [for-all]]</p><p class="source-code">                [clojure.test.check.clojure-test :refer-macros [defspec]]</p><p class="source-code">                [cuerdas.core :as str]</p><p class="source-code">                [hello-test.core :refer [adder]]))</p><p>We import the testing macros from the <strong class="source-inline">cljs.test</strong> namespace. We will use them for testing our code. We also import the namespace from the <strong class="source-inline">test.check</strong> namespace. We will write property-based tests for our functions. The <strong class="source-inline">cuerdas</strong> namespace will be used to manipulate strings. Finally, we import test functions from the <strong class="source-inline">hello-test.core</strong> namespace.</p></li>
				<li>Create a test runner. <p>A test runner is a file that runs all the tests. We will test our code using the browser engine from Karma:</p><p class="source-code">touch test/hello_test/runner.cljs</p></li>
				<li>Import the namespaces for the test runner.<p>Inside <strong class="source-inline">hello_test.runnerfile</strong>, we import the core testing namespace and the <strong class="source-inline">lein-doo</strong> namespace: </p><p class="source-code">(ns hello-test.runner</p><p class="source-code">  (:require [doo.runner :refer-macros [doo-tests]]</p><p class="source-code"> <a id="_idTextAnchor319"/>               [hello-test.core-test]))</p><p class="source-code">(d<a id="_idTextAnchor320"/>oo-tests 'hello-test.core-test)</p><p>We let <strong class="source-inline">lein-doo</strong> know that it needs to run tests from the <strong class="source-inline">hello-test.core-test</strong> namespace.</p></li>
				<li>Once we install Karma and create all the files, the project structure should look like this:<p class="source-code">tree</p><p>The output is as follows:</p><div id="_idContainer201" class="IMG---Figure"><img src="image/B14502_10_33.jpg" alt="Figure 10.33: Project structure after installing Karma and creating all the files&#13;&#10;"/></div><p class="figure-caption">Figure 10.33: Project structure after installing Karma and creating all the files</p><p>We are ready to launch the test runner.</p></li>
				<li>Launch the test runner:<p class="source-code">lein doo chrome test</p><p>We call the <strong class="source-inline">lein doo</strong> plugin to run tests using the Chrome browser. Remember that JavaScript is a language that runs in browsers.</p><div id="_idContainer202" class="IMG---Figure"><img src="image/B14502_10_34.jpg" alt="Figure 10.34: Launching the test runners&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.34: Launching the test runners</p>
			<p>The <strong class="source-inline">lein doo</strong> plugin launched a Karma server for us. The server is watching the source and test directories for us. When we make changes in our ClojureScript files, the tests will run against our code.</p>
			<p>In this exercise, we learned how to set up testing in ClojureScript. In the next exercise, we will learn how to write ClojureScript tests.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor321"/>Exercise 10.06: Testing ClojureScript Code</h2>
			<p>In the previous exercise, we configured a project for ClojureScript testing. In this exercise, we will write ClojureScript tests. We will use functions from the <strong class="source-inline">cuerdas</strong> library that allow us to manipulate strings. We will also test the asynchronous ClojureScript code.</p>
			<p>We will implement and test three functions:</p>
			<ul>
				<li><strong class="source-inline">profanity-filter</strong>: It is common to filter certain words in chat applications or web forums. A profanity filter will remove words that we consider inappropriate.</li>
				<li><strong class="source-inline">prefix-remover</strong>: This function will use string functions and will remove prefixes from words.</li>
				<li><strong class="source-inline">http-caller</strong>: This function will make a HTTP call to a web address. This will help us test asynchronous code.</li>
			</ul>
			<ol>
				<li value="1">Import namespaces for the core file.<p>Inside the <strong class="source-inline">core.cljs</strong> file, add the necessary namespaces:</p><p class="source-code">(ns hello-test.core</p><p class="source-code">  (:require [cuerdas.core :as str]))</p><p>We import the <strong class="source-inline">cuerdas</strong> namespace for string manipulation.</p></li>
				<li>Create a profanity filter. The first function that we will write in the <strong class="source-inline">hello_test.core.cljs</strong> file is a profanity filter: <p class="source-code">(defn profanity-filter [string]</p><p class="source-code">      (if (str/includes? string "bad")</p><p class="source-code">        (str/replace string "bad" "great")</p><p class="source-code">        string))</p><p>In this function, we test whether a passed string contains the word <strong class="source-inline">bad</strong>. If it does, we replace it with the word <strong class="source-inline">great</strong>.</p></li>
				<li>Import the test namespaces.<p>Inside the <strong class="source-inline">hello_test.core_test.cljs</strong> file, import the necessary test namespaces:</p><p class="source-code">(ns hello-test.core-test</p><p class="source-code">  (:require [cljs.test :refer-macros [are async deftest is testing]]</p><p class="source-code">            [cuerdas.core :as str]</p><p class="source-code">            [hello-test.core :refer [profanity-filter]]))</p></li>
				<li>Write a test for the <strong class="source-inline">profanity-filter</strong> functions.<p>Inside the <strong class="source-inline">hello_test.core_test.cljs</strong> file, add a test for the profanity filter function:</p><p class="source-code">(deftest profanity-filter-test</p><p class="source-code">         (testing "Filter replaced bad word"</p><p class="source-code">                  (is (= "Clojure is great" (profanity-filter "Clojure is bad"))))</p><p class="source-code">         (testing "Filter does not replace good words"</p><p class="source-code">                  (are [string result] (= result (profanity-filter string))</p><p class="source-code">                       "Clojure is great" "Clojure is great"</p><p class="source-code">                       "Clojure is brilliant" "Clojure is brilliant")))</p><p>The tests look similar to the ones we wrote using the <strong class="source-inline">clojure.test</strong> library. We use <strong class="source-inline">is</strong> and <strong class="source-inline">are</strong> macros to set testing scenarios. We are ready to run the tests.</p></li>
				<li>In order to run the tests, we call the <strong class="source-inline">lein doo</strong> task from the command line. If you have a <strong class="source-inline">lein doo</strong> running from the previous exercise, it will watch file changes and run the tests for us:<div id="_idContainer203" class="IMG---Figure"><img src="image/B14502_10_35.jpg" alt="Figure 10.35: Calling the lein doo task from the command line&#13;&#10;"/></div><p class="figure-caption">Figure 10.35: Calling the lein doo task from the command line</p><p>The profanity filter test was run. The output informs us that one test was successful.</p></li>
				<li>If you do not have <strong class="source-inline">lein doo</strong> running, you need to start <strong class="source-inline">lein doo</strong>:<p class="source-code">lein doo chrome test</p><p>Starting the <strong class="source-inline">lein doo</strong> task will start watching our ClojureScript files for changes:</p><div id="_idContainer204" class="IMG---Figure"><img src="image/B14502_10_36.jpg" alt="Figure 10.36: Starting the lein doo task&#13;&#10;"/></div><p class="figure-caption">Figure 10.36: Starting the lein doo task</p><p>Once the <strong class="source-inline">lein doo</strong> is watching the changes in our file, we are ready. We are informed that the <strong class="source-inline">karma</strong> server has been started. The autorunner is watching for changes in the <strong class="source-inline">src</strong> and <strong class="source-inline">test</strong> directories. Any changes in these directories will result in <strong class="source-inline">lein doo</strong> running the tests again. </p><p>Go to <strong class="source-inline">hello_test.core_test.cljs</strong>, save the file, and watch the tests being executed:</p><div id="_idContainer205" class="IMG---Figure"><img src="image/B14502_10_37.jpg" alt="Figure 10.37: Executing the tests &#13;&#10;"/></div><p class="figure-caption">Figure 10.37: Executing the tests </p><p>We are informed that one test has been successfully executed.</p></li>
				<li>The autorunner will let us know if our tests fail. If we add the following test, the autorunner informs us that one test failed:<p class="source-code">(deftest capitalize-test-is</p><p class="source-code">         (testing "Test capitalize? function using is macro"</p><p class="source-code">                  (is (= "katy" (str/capitalize "katy")))</p><p class="source-code">                  (is (= "John" (str/capital "john")))</p><p class="source-code">                  (is (= "Mike" (str/capitalize "mike")))))</p><p>The test fails as follows:</p><div id="_idContainer206" class="IMG---Figure"><img src="image/B14502_10_38.jpg" alt="Figure 10.38: The autorunner informs us when a test fails&#13;&#10;"/></div><p class="figure-caption">Figure 10.38: The autorunner informs us when a test fails</p><p>We see that we expected lowercase <strong class="source-inline">katy</strong> but the <strong class="source-inline">capitalize</strong> function returned <strong class="source-inline">Katy</strong> instead.</p><p>We will fix the test as follows:</p><p class="source-code">(is (= "Katy" (str/capitalize "katy")))</p><p>In the test, we pass the lowercase string "<strong class="source-inline">katy</strong>" to the capitalize function from the <strong class="source-inline">cuerdas</strong> library. The <strong class="source-inline">capitalize</strong> function will uppercase the first letter, "k," and return a new string, "<strong class="source-inline">Katy</strong>". This new string is compared to the string <strong class="source-inline">Katy</strong> in a test.</p><p>As both strings, <strong class="source-inline">Katy</strong> and <strong class="source-inline">Katy</strong>, are equal, the tests will pass.</p><p>The autorunner tells us that all of the tests passed now:</p><div id="_idContainer207" class="IMG---Figure"><img src="image/B14502_10_39.jpg" alt="Figure 10.39: All of the tests passed after we fixed the string case&#13;&#10;"/></div><p class="figure-caption">Figure 10.39: All of the tests passed after we fixed the string case</p></li>
				<li>We can check for errors being thrown by our code:<p class="source-code">(deftest error-thrown-test</p><p class="source-code">         (testing "Catching errors in ClojureScript"</p><p class="source-code">                  (is (thrown? js/Error (assoc ["dog" "cat" "parrot"] 4 "apple")))))</p><p>In the preceding code, we wanted to insert an apple in the fourth index, which does not exist as we have only three elements. Remember that, in Clojure, the first index is zero so the third element in a list has an index of two. Trying to add an element at index 4 generates an error in ClojureScript. In our test, we caught this error:</p><div id="_idContainer208" class="IMG---Figure"><img src="image/B14502_10_40.jpg" alt="Figure 10.40: The third test passes because we caught the error in our code&#13;&#10;"/></div><p class="figure-caption">Figure 10.40: The third test passes because we caught the error in our code</p><p>The autorunner tests our code and the third test passed.</p></li>
				<li>In ClojureScript, we can make requests to websites. These requests are asynchronous. We will import ClojureScript namespaces that help us to make asynchronous calls:<p class="source-code">(ns hello-test.core</p><p class="source-code">  (:require-macros [cljs.core.async.macros :refer [go]])</p><p class="source-code">  (:require [cljs.core.async :refer [&lt;!]]</p><p class="source-code">            [cljs-http.client :as http]))</p><p>The <strong class="source-inline">cljs-http.client</strong> namespace will allow us to make HTTP calls. Functions from the <strong class="source-inline">core.async</strong> namespace will manage asynchronous calls for us.</p></li>
				<li>Our HTTP function will take three arguments, a website address, HTTP parameters, and a callback function to call after we finish sending the request to the website address:<p class="source-code">(defn http-get [url params callback]</p><p class="source-code">      (go (let [response (&lt;! (http/get url params))]</p><p class="source-code">               (callback response))))</p></li>
				<li>We have our function making asynchronous calls. We need to import this function:<p class="source-code">(ns hello-test.core-test</p><p class="source-code">  (:require [hello-test.core :refer [http-get]))</p></li>
				<li>HTTP calls happen asynchronously in ClojureScript. A <strong class="source-inline">GET</strong> request will run a callback function when the request finishes. This is ideal for testing asynchronous code:<p class="source-code">(deftest http-get-test</p><p class="source-code">         (async done</p><p class="source-code">                (http-get "https://api.github.com/users" {:with-credentials? false</p><p class="source-code">                                                          :query-params      {"since" 135}}</p><p class="source-code">                          (fn [response]</p><p class="source-code">                              (is (= 200 (:status response)))</p><p class="source-code">                              (done)))))</p><p>The <strong class="source-inline">async</strong> macro allows us to write an asynchronous block of code for testing. In our block, we make a GET request to GitHub API to access the list of current public users. The <strong class="source-inline">http-get</strong> function takes a callback function as the last parameter. In the callback, we check the response. A successful response will have the status <strong class="source-inline">200</strong>.</p><p>The final function call in the callback is <strong class="source-inline">done</strong>. <strong class="source-inline">done</strong> is a function that is invoked when we are ready to relinquish control and allow the next test to run: </p><div id="_idContainer209" class="IMG---Figure"><img src="image/B14502_10_41.jpg" alt="Figure 10.41: The fourth test is passed&#13;&#10;"/></div><p class="figure-caption">Figure 10.41: The fourth test is passed</p><p>Our request was successful and the fourth test passed.</p></li>
				<li>Import the namespaces for property-based testing. ClojureScript allows us to use property-based testing to check our functions:<p class="source-code">(ns hello-test.core-test</p><p class="source-code">  (:require [clojure.test.check.generators :as gen]</p><p class="source-code">                [clojure.test.check.properties :refer-macros [for-all]]</p><p class="source-code">                [clojure.test.check.clojure-test :refer-macros [defspec]]))</p><p>We already know about generators and the properties used for property-based testing. With generators, we can create various types of function inputs such as numbers or strings. Properties allow us to describe the characteristics of the inputs.</p><p>The <strong class="source-inline">defspec</strong> macro allows us to write tests that can be run with the <strong class="source-inline">clsj.test</strong> library.</p></li>
				<li>With property-based tests, we can check 1,000 scenarios against our profanity filter. The structure of property-based tests in ClojureScript is the same as in Clojure: <p class="source-code">(defspec simple-test-check 1000</p><p class="source-code">         (for-all [some-string gen/string-ascii]</p><p class="source-code">                   (= (str/replace some-string "bad" "great") (profanity-filter some-string))))</p><p>With the <strong class="source-inline">for-all</strong> macro, we specify what properties our function parameters should have. For the profanity filter, we generate ASCII strings. ASCII, abbreviated from American Standard Code for Information Interchange, is a character encoding standard for electronic communication:</p><div id="_idContainer210" class="IMG---Figure"><img src="image/B14502_10_42.jpg" alt="Figure 10.42: The fifth test is passed&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.42: The fifth test is passed</p>
			<p>Our fifth test passed. Furthermore, the <strong class="source-inline">test.check</strong> informed us that 1,000 test scenarios were executed.</p>
			<p>In this exercise, we have seen how to set up testing in ClojureScript. We wrote functions and tested them using the <strong class="source-inline">cljs.test</strong> and <strong class="source-inline">test.check</strong> libraries. In the next section, we will see how to integrate tests with existing projects.</p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor322"/>Testing ClojureScript Applications with Figwheel</h2>
			<p>In <em class="italic">Chapter 9</em>, <em class="italic">Host Platform Interoperability with Java and JavaScript</em>, we learned about Figwheel. Figwheel allows us to create ClojureScript applications. Most developers use Figwheel because it provides hot-code reloading. It means that any changes in our code are recompiled and the application running in the web browser is updated.</p>
			<p>In the previous exercise, we learned how to add testing to a ClojureScript project. Figwheel comes with a testing configuration. Any Figwheel application is ready to add tests to after creating the application. Because the testing configuration is included in each project, developers save time. Developers do not need to install external tools or create the configuration; they can start writing tests straight away.</p>
			<p>In <em class="italic">Chapter 9</em>, <em class="italic">Host Platform Interoperability with Java and JavaScript</em>, we talked about Figwheel projects in detail. As a reminder, in Figwheel, we use two concepts:</p>
			<ul>
				<li>Reactive components</li>
				<li>Application state management</li>
			</ul>
			<p>For reactive components – HTML elements that react to user actions – we will use the Rum library. The state of the application will be kept inside an atom. Concurrency is a topic covered in <em class="italic">Chapter 12</em>, <em class="italic">Concurrency</em>. For our purposes, an atom is a data structure like a collection. We learned about collections in <em class="italic">Chapter 1</em>, <em class="italic">Hello REPL!</em>. The main difference between collections and atoms is that we can alter the value of an atom, while collections are immutable.</p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor323"/>Exercise 10.07: Tests in Figwheel Applications</h2>
			<p>In the previous section, we learned that Figwheel supports testing ClojureScript applications. We revised the benefits of using Figwheel to create ClojureScript applications. We also reminded ourselves about important concepts in Figwheel applications, such as reactive components and application state management.</p>
			<p>In this exercise, we will investigate how Figwheel configures projects to support testing in ClojureScript. Figwheel aims to support developers creating applications. Figwheel sets up default testing configuration for us. In <em class="italic">Exercise 10.5</em>, <em class="italic">Setting Up Testing in ClojureScript</em>, we saw how much setup is needed to configure testing in ClojureScript. With Figwheel, we do not need to write this configuration; we can focus on writing our code.</p>
			<p>In order to write tests in Figwheel, we need to understand how Figwheel sets up the default testing configuration:</p>
			<ol>
				<li value="1">Create a Figwheel application:<p class="source-code">lein new figwheel-main test-app -- --rum</p><p>We created a new Figwheel project using Rum. </p></li>
				<li>Test the configuration in the project.clj file.<p>Figwheel puts some testing configuration in the <strong class="source-inline">project.clj</strong> file: </p><p class="source-code">:aliases {"fig:test"  ["run" "-m" "figwheel.main" "-co" "test.cljs.edn" "-m" "test-app.test-runner"]}</p><p>Inside the <strong class="source-inline">project.clj</strong> file, Figwheel defines aliases to help run tasks on the command line. An alias is a shortcut for commands that we use often. Using aliases saves developers typing. Figwheel defines the <strong class="source-inline">fig:test</strong> task.</p><p>This task runs on a command line with a number of parameters:</p><p><strong class="source-inline">-m</strong>: Search a file for the main function. Remember from <em class="italic">Chapter 8</em>, <em class="italic">Namespaces, Libraries, and Leiningen</em>, that the main function in Leiningen projects is an entry point in an application. We start applications in main functions.</p><p><strong class="source-inline">-co</strong>: Load options from a given file. </p></li>
				<li>Test the configuration in the <strong class="source-inline">test.cljs.edn</strong> file. Inside the <strong class="source-inline">test.cljs.edn</strong> file, we have the testing configuration:<p class="source-code">{</p><p class="source-code">  ;; use an alternative landing page for the tests so that we don't launch the application</p><p class="source-code">  :open-url "http://[[server-hostname]]:[[server-port]]/test.html"</p><p class="source-code">  }</p><p class="source-code">{:main test-app.test-runner}</p><p>When the Figwheel application is run, it launches a web page. Figwheel provides two web pages. There is one web page for the actual application that we are developing. Also, there is a different web page for testing.</p><p>Figwheel also provides a main method inside the <strong class="source-inline">test-app.test-runner</strong> namespace. </p></li>
				<li>Test the runner namespace. Inside the <strong class="source-inline">test/test_app/test_runner.cljs</strong> file, we have code for running ClojureScript tests:<p class="source-code">(ns test-app.test-runner</p><p class="source-code">  (:require</p><p class="source-code">    ;; require all the namespaces that you want to test</p><p class="source-code">    [test-app.core-test]</p><p class="source-code">    [figwheel.main.testing :refer [run-tests-async]]))</p><p class="source-code">(defn -main [&amp; args]</p><p class="source-code">  (run-tests-async 5000))</p><p>First, in the file, we require the namespaces that we want to test. Initially, the only namespace to test is a <strong class="source-inline">test-app.core-test</strong> namespace created by default by Leiningen. If we add more files for testing, we need to import namespaces in those files. The second namespace that is required is a Figwheel namespace with a utility function.</p><p>Second, we have the <strong class="source-inline">-main</strong> function. This function is called by Leiningen to run tests. Figwheel provides a <strong class="source-inline">run-tests-async</strong> function. This means that tests are run in an asynchronous manner. This allows the tests to run faster than if run in a synchronous manner. They run faster because the tests do not need to wait for other tests to finish before they can be started.</p></li>
				<li>Inside the <strong class="source-inline">test/test_app/core_test.cljs</strong> file, we have autogenerated tests by Figwheel:<p class="source-code">(ns test-app.core-test</p><p class="source-code">    (:require</p><p class="source-code">     [cljs.test :refer-macros [deftest is testing]]</p><p class="source-code">     [test-app.core :refer [multiply]]))</p><p>Figwheel first requires the <strong class="source-inline">cljs.test</strong> namespace with macros that we are familiar with. The tests will use macros such as <strong class="source-inline">deftest</strong>, <strong class="source-inline">is</strong>, and <strong class="source-inline">testing</strong>.</p><p>The second namespace required is the <strong class="source-inline">test-app.core</strong> namespace. This namespace, from the source directory, contains the implementation for a <strong class="source-inline">multiply</strong> function.</p></li>
				<li>Inside the <strong class="source-inline">core_test.cljs</strong> file, we have two autogenerated tests:<p class="source-code">(deftest multiply-test</p><p class="source-code">  (is (= (* 1 2) (multiply 1 2))))</p><p class="source-code">(deftest multiply-test-2</p><p class="source-code">  (is (= (* 75 10) (multiply 10 75))))</p><p>Both tests use the familiar <strong class="source-inline">is</strong> macro. With the <strong class="source-inline">is</strong> macro, we test whether calling the <strong class="source-inline">multiply</strong> function is equal to the expected output. Multiplying 1 by 2 should equal calling the <strong class="source-inline">multiply</strong> function with two arguments: 1 and 2.</p></li>
				<li>Run the default tests. When we create a new application based on Figwheel, the application has some default tests. Straight after creating the application, we can run the default tests:<p class="source-code">lein fig:test</p><p>The output is as follows:</p><div id="_idContainer211" class="IMG---Figure"><img src="image/B14502_10_43.jpg" alt="Figure 10.43 Using the fig:test command to run tests&#13;&#10;"/></div><p class="figure-caption">Figure 10.43 Using the fig:test command to run tests</p><p>We use Leiningen to launch Figwheel. In order to run tests, we use the <strong class="source-inline">fig:test</strong> command-line task. This task will read the Figwheel configuration from the <strong class="source-inline">project.clj</strong> file and run tests according to the configuration.</p><p>We saw two default tests in the previous steps. Both tests pass and we are informed about the tests passing.</p></li>
				<li>The selling point of Figwheel is hot-code reloading. In order to get an interactive development environment, run the following:<p class="source-code">lein fig:build</p><p>This will launch Figwheel, which autocompiles code for us:</p><div id="_idContainer212" class="IMG---Figure"><img src="image/B14502_10_44.jpg" alt="Figure 10.44: Figwheel validates the configuration on the figwheel-main.edn file&#13;&#10;"/></div><p class="figure-caption">Figure 10.44: Figwheel validates the configuration on the figwheel-main.edn file</p><p>Figwheel reads and validates the configuration on the <strong class="source-inline">figwheel-main.edn</strong> file. Then, <strong class="source-inline">if</strong> compiles our source code to the <strong class="source-inline">dev-main.js</strong> file. The test code is compiled to the <strong class="source-inline">dev-auto-testing.js</strong> file.</p></li>
				<li>With Figwheel, we can see a summary of our tests in a browser. Go to <strong class="source-inline">http://localhost:9500/figwheel-extra-main/auto-testing</strong>:<div id="_idContainer213" class="IMG---Figure"><img src="image/B14502_10_45.jpg" alt="Figure 10.45: All tests passed&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.45: All tests passed</p>
			<p>Figwheel informs us that all tests have passed. We have a summary displaying which tests were run. </p>
			<p>In this exercise, we learned how Figwheel supports testing in ClojureScript. We saw the default testing configuration provided by Figwheel. In the next exercise, we will see how to add tests to a Figwheel application.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor324"/>Exercise 10.08: Testing a ClojureScript Application</h2>
			<p>The aim of this exercise is to learn how to test ClojureScript applications. Often, front-end code is complex. The state of an application in the browser changes. User interactions result in many unpredictable scenarios. Having ClojureScript tests for frontend applications helps us to catch bugs early.</p>
			<p>In the previous chapter, we learned about the Figwheel application template. It is a very common template for writing frontend applications in ClojureScript. We will create an application that will react to user actions. When a user clicks on the action button, we will increment a counter.</p>
			<p>Initially, the count will be zero:</p>
			<div>
				<div id="_idContainer214" class="IMG---Figure">
					<img src="image/B14502_10_46.jpg" alt="Figure 10.46: The initial number of clicks is zero&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.46: The initial number of clicks is zero</p>
			<p>After six clicks the count will change:</p>
			<div>
				<div id="_idContainer215" class="IMG---Figure">
					<img src="image/B14502_10_47.jpg" alt="Figure 10.47: The count changes to six&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.47: The count changes to six</p>
			<p>We know what our application will do. We are ready to implement the functionality now.</p>
			<ol>
				<li value="1">Create a Figwheel application:<p class="source-code">lein new figwhee<a id="_idTextAnchor325"/>l-main test-app -- --rum</p><p>We created a new Figwheel project using Rum. </p></li>
				<li>In the previous section, we learned that Figwheel supports testing. After creating a project, we are already set to run tests:<p class="source-code">lein fig:test</p><p>The output is as follows:</p><div id="_idContainer216" class="IMG---Figure"><img src="image/B14502_10_48.jpg" alt="Figure 10.48: Two tests containing two assertions are passed&#13;&#10;"/></div><p class="figure-caption">Figure 10.48: Two tests containing two assertions are passed</p><p>Figwheel compiles our code and runs the tests. We test the tet-app.core-test namespace. The two tests pass.</p></li>
				<li>We will implement a function to handle user clicks inside the <strong class="source-inline">src/test_app/core.cljs</strong> file:<p class="source-code">(ns test-app.core)</p><p class="source-code">(defn handle-click [state]</p><p class="source-code">      (swap! state update-in [:counter] inc))</p><p>The <strong class="source-inline">handle-click</strong> function has one parameter. The parameter is the current application state. We increment the value stored in the atom under the <strong class="source-inline">:counter</strong> key.</p></li>
				<li>We will store the state application in an atom in the <strong class="source-inline">core.cljs</strong> file:<p class="source-code">(ns test-app.core)</p><p class="source-code">(defonce state (atom {:counter 0}))</p><p>The atom is a hash with the <strong class="source-inline">:counter</strong> key. The initial value of the key is zero.</p></li>
				<li>Create the counter component.<p>We create a Rum component that will display the number of mouse clicks:</p><p class="source-code">(rum/defc counter [number]</p><p class="source-code">          [:div {:on-click #(handle-click state)}</p><p class="source-code">           (str "Click times: " number)])</p><p>The component displays the number of clicks, which is passed as an argument. Inside the component, we use the <strong class="source-inline">handle-click</strong> function to respond to <strong class="source-inline">:on-click</strong> actions. Whenever a user clicks on the component, the <strong class="source-inline">handle-click</strong> function is called.</p></li>
				<li>Create a page component. We will put the <strong class="source-inline">counter</strong> component inside the <strong class="source-inline">page-content</strong> component. It is good practice to have a main component on the page where we will put all our components. In our example, we have one component:<p class="source-code">(rum/defc page-content &lt; rum/reactive []</p><p class="source-code">          [:div {}</p><p class="source-code">           (counter (:counter (rum/react state)))])</p><p>The container uses Rum's <strong class="source-inline">reactive</strong> directive. This directive instructs Rum to handle the component in a special manner. Reactive components will <strong class="source-inline">react</strong> to changes to the application state. Whenever there is a change to the application state, the component will be updated and redisplayed in the browser using the new application state. We learned about reactive components in <em class="italic">Chapter 9</em>, <em class="italic">Host Platform Interoperability with Java and JavaScript</em>, and refreshed our memory in the section preceding this exercise.</p></li>
				<li>Finally, we need to attach our <strong class="source-inline">page-component</strong> to a web page. As we did in <em class="italic">Chapter 9</em>, <em class="italic">Host Platform Interoperability with Java and JavaScript</em>, we use the <strong class="source-inline">mount</strong> method from Rum:<p class="source-code">(defn mount [el]</p><p class="source-code">  (rum/mount (page-content) el))</p><p>The <strong class="source-inline">page-content</strong> component is mounted to the web page.</p></li>
				<li>Run the application.<p>We will run our Figwheel application:</p><p class="source-code">lein fig:build</p><p>This command will launch Figwheel for us:</p><div id="_idContainer217" class="IMG---Figure"><img src="image/B14502_10_49.jpg" alt="Figure 10.49: Launching the Figwheel&#13;&#10;"/></div><p class="figure-caption">Figure 10.49: Launching the Figwheel</p><p>Figwheel successfully launches our application. We can see the page in the browser. It will look as follows:</p><div id="_idContainer218" class="IMG---Figure"><img src="image/B14502_10_50.jpg" alt="Figure 10.50: The number of clicks at the start of the application&#13;&#10;"/></div><p class="figure-caption">Figure 10.50: The number of clicks at the start of the application</p><p>When the application starts, the number of clicks is zero. After six clicks, the state is updated and a new value is displayed on the page:</p><div id="_idContainer219" class="IMG---Figure"><img src="image/B14502_10_51.jpg" alt="Figure 10.51: The updated number of clicks&#13;&#10;"/></div><p class="figure-caption">Figure 10.51: The updated number of clicks</p><p>We see that the component on the page reacts to our actions. It is time to write tests for the <strong class="source-inline">handle-click</strong> function.</p></li>
				<li>We will create fixtures for our tests. A test fixture is a fixed state of a set of objects used as a baseline for running tests. The purpose of a test fixture is to ensure that there is a well-known and fixed environment in which tests are run so that results are repeatable.<p>Because we will manipulate the state of an application, we want the state to be the same every time we run our tests. We do not want previous tests to influence subsequent tests.</p><p>The <strong class="source-inline">handle-click</strong> function takes a state atom as an argument. In order to test the handle-click function, we need a state atom. <strong class="source-inline">cljs.test</strong> provides the <strong class="source-inline">use-fixtures</strong> macro, which allows us to preset tests to the required state before tests are run. This is a good place to create a state atom for further manipulation.</p><p>We will put our tests inside the <strong class="source-inline">core_test.cljs</strong> file:</p><p class="source-code">(ns test-app.core-test</p><p class="source-code">    (:require</p><p class="source-code">     [cljs.test :refer-macros [are deftest is testing use-fixtures]]</p><p class="source-code">     [test-app.core :refer [handle-click multiply]]))</p><p class="source-code">(use-fixtures :each {:before (fn [] (def app-state (atom {:counter 0})))</p><p class="source-code">                    <a id="_idTextAnchor326"/>             :after (fn [] (reset! app-state nil))})</p><p>With the <strong class="source-inline">:each</strong> keyword, we specify that we want the fixtures to be run for each test. This way, we can set the state for each test. An alternative would be to use the <strong class="source-inline">:only</strong> keyword, which would set up fixtures only once per test.</p><p>In the fixtures, we have two keys:</p><p><strong class="source-inline">:before</strong>: Runs a function before the test is executed</p><p><strong class="source-inline">:after</strong>: Runs a function after the test is executed</p><p>In <strong class="source-inline">:before</strong> and <strong class="source-inline">:after</strong>, we set the state of the application's atom. Before each test, we set <strong class="source-inline">:counter</strong> to zero. After each test, we reset the application state to <strong class="source-inline">nil</strong>. Setting the counter to zero resets it. This way, every time we run a new test, the counter is started from zero. Previous tests will not influence subsequent tests.</p><p>After setting up fixtures, we are ready to launch the test runner.</p></li>
				<li>Test the <strong class="source-inline">handle-click</strong> function.<p>We will test handling multiple clicks:</p><p class="source-code">(deftest handle-click-test-multiple</p><p class="source-code">         (testing "Handle multiple clicks"</p><p class="source-code">                  (are [result] (= result (handle-click app-state))</p><p class="source-code">                       {:counter 1}</p><p class="source-code">                       {:counter 2}</p><p class="source-code">                    <a id="_idTextAnchor327"/>   {:counter 3})))</p><p>We use the <strong class="source-inline">are</strong> macro to simplify testing. We compare the expected result to the return value of calling the <strong class="source-inline">handle-click</strong> function. Calling <strong class="source-inline">handle-click</strong> three times should increase the counter to three.</p></li>
				<li>We will run the tests now:<p class="source-code"> lein fig:test</p><p>The output is as follows:</p><div id="_idContainer220" class="IMG---Figure"><img src="image/B14502_10_52.jpg" alt="Figure 10.52: Running the tests&#13;&#10;"/></div><p class="figure-caption">Figure 10.52: Running the tests</p><p>As we see in the summary, the tests pass. The <strong class="source-inline">handle-click</strong> test used <strong class="source-inline">app-state</strong>, which we set up using the <strong class="source-inline">use-fixtures</strong> macro. Before each test, the fixtures created an application state. After each test, the fixtures should reset the state to zero. We will write a new test to check whether the application state is reset.</p></li>
				<li>In the following test, we will test a single click:<p class="source-code">(deftest handle-click-test-one</p><p class="source-code">         (testing "Handle one click"</p><p class="source-code">                  (is<a id="_idTextAnchor328"/> (= {:counter 1} (handle-click app-state)))))</p><p>In this test, we use the <strong class="source-inline">is</strong> macro to test a single click.</p></li>
				<li>We will run the tests again:<p class="source-code">lein fig:test</p><p>The output is as follows:</p><div id="_idContainer221" class="IMG---Figure"><img src="image/B14502_10_53.jpg" alt="Figure 10.53: Running the tests again&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.53: Runn<a id="_idTextAnchor329"/>ing the tests again</p>
			<p>Running the new test tells us that the state has been reset. We see that our test passed as the application state has been reset successfully.</p>
			<p>In this exercise, we learned how to integrate testing into ClojureScript applications. We created a project using the Figwheel template. This template allowed us to create a web application. In the application, we added user interaction. The application counted the number of clicks. We wrote tests to make sure that our functions perform as expected.</p>
			<p>You are ready to start writing web applications and adding tests to them. In the following activity, you will put your new knowledge to use.</p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor330"/>Activity 10.02: Support Desk Application with Tests</h2>
			<p>The aim of this activity is to add a testing suite to a web application. Many applications require complex functionality and many features. While manual testing can catch many bugs, it is time-consuming and requires many testers. With automated testing, checking applications are faster and more features can be tested. ClojureScript provides tools to help with unit testing.</p>
			<p>In the previous chapter, we wrote a support desk application that allowed us to manage issues raised with the help desk (<a href="https://packt.live/2NTTJpn">https://packt.live/2NTTJpn</a>). The application allows you to sort issues and resolve them when they are done. By sorting the issues, we can raise the priority of the issue. In this activity, we will add unit tests using <strong class="source-inline">clsj.test</strong> and <strong class="source-inline">test.check</strong> for property-based testing.</p>
			<p>You will write tests for the following:</p>
			<ul>
				<li>A function displaying the sort message status</li>
				<li>A function filtering the list of issues by priority</li>
				<li>A function sorting the list of issues</li>
				<li>A function deleting an item from the issues list</li>
			</ul>
			<p>These steps will help you complete the activity:</p>
			<ol>
				<li value="1">Add the testing dependencies to the <strong class="source-inline">project.clj</strong> file.</li>
				<li>Import the namespaces to the <strong class="source-inline">core_test.cljs</strong> file.</li>
				<li>Create fixtures with issues in the application state.</li>
				<li>Write tests for the sort message function, <strong class="source-inline">cljs.test</strong>.</li>
				<li>Write tests for the sort message function using <strong class="source-inline">test.check</strong>.</li>
				<li>Write tests to filter issues by priority function using <strong class="source-inline">cljs.test</strong>.</li>
				<li>Write tests to sort the issues list using <strong class="source-inline">cljs.test</strong>.</li>
				<li>Write tests to delete issues from the list using <strong class="source-inline">cljs.test</strong>.</li>
				<li>Write tests to handle the sort function using <strong class="source-inline">cljs.test</strong>.</li>
			</ol>
			<p>The initial issues list will look as follows:</p>
			<div>
				<div id="_idContainer222" class="IMG---Figure">
					<img src="image/B14502_10_54.jpg" alt="Figure 10.54: List of initial issues&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.54: List of initial issues</p>
			<p>The issues list after sorting will look as follows:</p>
			<div>
				<div id="_idContainer223" class="IMG---Figure">
					<img src="image/B14502_10_55.jpg" alt="Figure 10.55: List after sorting&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.55: List after sorting</p>
			<p>When the tests are run, the output should look like the following:</p>
			<div>
				<div id="_idContainer224" class="IMG---Figure">
					<img src="image/B14502_10_56.jpg" alt="Figure 10.56: Output after running the tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.56: Output after running the tests</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 730</p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor331"/>Summary</h1>
			<p>In this chapter, we learned about testing in Clojure. First, we explored why testing is important. We looked at some of the benefits, such as reduced maintenance costs and bug fixing. We also learned what testing methodologies are available. We focused on unit testing as this is the most common type of test written by developers.</p>
			<p>Next, we explored four testing libraries available in Clojure. We started with the standard clojure.test library, which provides a rich set of testing features. The second library we learned about was Expectations. It allows us to write concise tests as it focuses on readability.</p>
			<p>The <strong class="source-inline">Midje</strong> library allowed us to explore top-down test-driven development (TDD). We created a test for the main function and stubs for functions that would be implemented in the future. TDD allows us to focus on testing functions' features without worrying about implementing all of the subfunctions used.</p>
			<p>The last library used was <strong class="source-inline">test.check</strong>, which introduced us to property-based testing. With property-based tests, we describe the properties of function arguments in a general form. This allows tests to generate input based on such properties. With this type of test, we can run thousands of test scenarios with a few lines of code. There's no need to enumerate every single test case.</p>
			<p>In the second part of this chapter, we learned about testing in ClojureScript. We saw that the cljs.test library provides us with features comparable to the <strong class="source-inline">clojure.test</strong> library. With <strong class="source-inline">clsj.test</strong>, we were able to test ClojureScript code. We also looked at macros, allowing us to test asynchronous ClojureScript code. We also set up an autorunner to run ClojureScript tests automatically when our code changes.</p>
			<p>Finally, we worked through two activities that allowed us to use our testing knowledge in projects. We wrote tests using libraries we learned about for applications developed in previous chapters. </p>
			<p>In the next chapter, we will learn about macros. Macros are a powerful feature that allows us to influence the Clojure language.</p>
		</div>
		<div>
			<div id="_idContainer226" class="Basic-Text-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer227" class="Content">
			</div>
		</div>
	</body></html>