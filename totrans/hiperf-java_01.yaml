- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Peeking Inside the Java Virtual Machine
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探秘Java虚拟机
- en: I would like to introduce you to a remarkable piece of technology that helped
    revolutionize the software industry. Meet the **Java Virtual Machine** (**JVM**).
    Okay, so you are likely already familiar with the JVM, and it is important to
    understand and appreciate the tremendous value it has as the middleware between
    compiled Java bytecode and a virtually limitless number of hardware platforms.
    The ingenious design of Java and the JVM is a testament to its wild popularity
    and value to users and developers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向您介绍一项革命性的技术，它帮助改变了软件行业。认识一下**Java虚拟机**（**JVM**）。好吧，你可能已经对JVM很熟悉了，了解并欣赏它在编译Java字节码和几乎无限数量的硬件平台之间的中间件所具有的巨大价值是非常重要的。Java和JVM的巧妙设计是它广受欢迎和用户、开发者价值的证明。
- en: Since the first release of Java in the 1990s, the JVM has been the true success
    factor for the Java programming language. With Java and the JVM, the concept of
    “write once, run anywhere” was born. Java developers can write their programs
    once and allow the JVM to ensure the code runs on devices the JVM is installed
    on. The JVM also makes Java a platform-independent language. The primary objective
    of this chapter is to provide greater insights into the unsung hero of Java, the
    JVM.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 自从20世纪90年代Java的第一个版本发布以来，JVM一直是Java编程语言真正的成功因素。有了Java和JVM，“一次编写，到处运行”的概念应运而生。Java开发者可以编写一次程序，并允许JVM确保代码在安装了JVM的设备上运行。JVM还使Java成为一种平台无关的语言。本章的主要目标是更深入地了解Java的默默无闻的英雄——JVM。
- en: In this chapter, we will take an extensive look at the JVM so that we can learn
    to get the most out of it in an effort to increase the performance of our Java
    applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨JVM，以便我们能够学会如何充分利用它，从而提高我们的Java应用程序的性能。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How the JVM works
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM的工作原理
- en: Garbage collection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: '**Just-in-Time** (**JIT**) compiler optimizations'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**即时编译器**（**JIT**）优化'
- en: By the end of this chapter, you should understand how to get the most out of
    the JVM to improve the performance of your Java applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您应该了解如何充分利用JVM来提高您的Java应用程序的性能。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the instructions in this chapter, you will need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的说明，您需要以下内容：
- en: A computer with either Windows, macOS, or Linux installed
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了Windows、macOS或Linux的计算机
- en: The current version of the Java SDK
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前版本的Java SDK
- en: Preferably, a code editor or **integrated development environment** (**IDE**)
    (such as Visual Studio Code, NetBeans, Eclipse, or IntelliJ IDEA)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议使用代码编辑器或**集成开发环境**（**IDE**）（如Visual Studio Code、NetBeans、Eclipse或IntelliJ
    IDEA）
- en: 'The finished code for this chapter can be found here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter01](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter01).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可以在以下位置找到：[https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter01](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter01)。
- en: Important note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This book is based on Java 21 and the **Java Development Kit** (**JDK**) 21.0.1\.
    It also uses the IntelliJ IDEA Community Edition IDE, running on macOS.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本书基于Java 21和**Java开发工具包**（**JDK**）21.0.1。它还使用了在macOS上运行的IntelliJ IDEA Community
    Edition IDE。
- en: This chapter contains code examples that you can use to follow along with and
    experiment with. So, you will want to ensure your system is properly prepared.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含您可以用来跟随和实验的代码示例。因此，您需要确保您的系统已经正确准备。
- en: 'Start by downloading and installing your IDE of choice. Here are a couple of
    options:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，下载并安装您选择的IDE。这里有一些选项：
- en: Visual Studio Code ([https://code.visualstudio.com/download](https://code.visualstudio.com/download))
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code ([https://code.visualstudio.com/download](https://code.visualstudio.com/download))
- en: NetBeans ([https://netbeans.apache.org/download/](https://netbeans.apache.org/download/))
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NetBeans ([https://netbeans.apache.org/download/](https://netbeans.apache.org/download/))
- en: Eclipse ([https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/))
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse ([https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/))
- en: IntelliJ IDEA Community Edition ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ IDEA Community Edition ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))
- en: 'After your IDE is set up, you need to ensure it is configured for Java development.
    Most modern IDEs are capable of downloading and installing the Java SDK for you.
    If this is not the case for you, the Java SDK can be obtained here: [https://www.oracle.com/java/technologies/downloads/](https://www.oracle.com/java/technologies/downloads/).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的IDE设置完成后，你需要确保它已配置为Java开发。大多数现代IDE都具备为你下载和安装Java SDK的功能。如果你不是这种情况，Java SDK可以从这里获取：[https://www.oracle.com/java/technologies/downloads/](https://www.oracle.com/java/technologies/downloads/).
- en: 'Ensuring that your IDE is Java-ready is important. Here are some IDE-specific
    links in case you need some help:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的IDE已准备好Java开发非常重要。以下是一些IDE特定的链接，以防你需要一些帮助：
- en: Java in Visual Studio Code ([https://code.visualstudio.com/docs/languages/java](https://code.visualstudio.com/docs/languages/java))
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code中的Java ([https://code.visualstudio.com/docs/languages/java](https://code.visualstudio.com/docs/languages/java))
- en: Java quick start tutorial for NetBeans ([https://netbeans.apache.org/tutorial/main/kb/docs/java/quickstart/](https://netbeans.apache.org/tutorial/main/kb/docs/java/quickstart/))
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NetBeans的Java快速入门教程 ([https://netbeans.apache.org/tutorial/main/kb/docs/java/quickstart/](https://netbeans.apache.org/tutorial/main/kb/docs/java/quickstart/))
- en: Preparing Eclipse ([https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2FgettingStarted%2Fqs-3.htm](https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2FgettingStarted%2Fqs-3.htm))
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备Eclipse ([https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2FgettingStarted%2Fqs-3.htm](https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2FgettingStarted%2Fqs-3.htm))
- en: Creating your first Java application with IntelliJ IDEA Community Edition ([https://www.jetbrains.com/help/idea/creating-and-running-your-first-java-application.html](https://www.jetbrains.com/help/idea/creating-and-running-your-first-java-application.html))
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用IntelliJ IDEA Community Edition创建你的第一个Java应用程序 ([https://www.jetbrains.com/help/idea/creating-and-running-your-first-java-application.html](https://www.jetbrains.com/help/idea/creating-and-running-your-first-java-application.html))
- en: Once you have your IDE and the Java SDK installed and configured on your computer,
    you are ready to move to the next section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在电脑上安装并配置了IDE和Java SDK，你就可以进入下一部分了。
- en: How the JVM works
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM的工作原理
- en: 'At the core, the JVM sits between your Java bytecode and your computer. As
    illustrated next, we develop our Java source code in an IDE, and our work is saved
    as `.java` files. We use the Java compiler to convert our Java source code to
    bytecode; the resulting files are `.class` files. We then use the JVM to run our
    bytecode on our computer:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在核心上，JVM位于你的Java字节码和电脑之间。如图所示，我们在IDE中开发Java源代码，我们的工作以`.java`文件保存。我们使用Java编译器将Java源代码转换为字节码；生成的文件是`.class`文件。然后我们使用JVM在我们的电脑上运行字节码：
- en: '![](img/B21942_01_1.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21942_01_1.jpg)'
- en: Figure 1.1 – Java application workflow
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – Java应用程序工作流程
- en: It is important to realize that Java is different from typical compile-and-execute
    languages where source code is fed into a compiler, which then produces a `.exe`
    file (for Windows), a `.app` file (for (macOS), or `ELF` files (for Linux). This
    impressive process is much more complex than it seems.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到Java与典型的编译和执行语言不同，在这些语言中，源代码被输入到编译器中，然后产生一个`.exe`文件（Windows），一个`.app`文件（macOS），或者`ELF`文件（Linux）。这个过程比看起来要复杂得多。
- en: 'Let’s take a closer look at what is going on with regard to the JVM, using
    a basic example. In the following code, we implement a simple loop that prints
    to the console. It is presented so that we can see how the JVM handles Java code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个基本示例来更详细地看看JVM的工作原理。在下面的代码中，我们实现了一个简单的循环，它会打印到控制台。这样呈现是为了让我们看到JVM是如何处理Java代码的：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can use the Java compiler to compile our code into a `.class` file, which
    will be formatted as bytecode. Let’s open a terminal window, navigate to our project’s
    `src` folder as shown next, and use the `ls` command to reveal our `.``java` file:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Java编译器将我们的代码编译成`.class`文件，这些文件将以字节码格式排列。让我们打开一个终端窗口，导航到我们的项目`src`文件夹，如以下所示，并使用`ls`命令来显示我们的`.java`文件：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we are in the proper folder, we can use `javac` to convert our source
    code to bytecode. As you can see next, this created a `.``class` file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经进入了正确的文件夹，我们可以使用`javac`将我们的源代码转换为字节码。正如你接下来可以看到的，这创建了一个`.class`文件：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we can use the `javap`) to print a decompiled version of our bytecode.
    As you can see next, we can use the `javap` command without any parameters:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用`javap`来打印我们的字节码的反编译版本。正如你接下来可以看到的，我们可以使用`javap`命令而不带任何参数：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, our use of the `javap` command simplified the printing of the
    decompiled bytecode. Now, let’s use the `-c` parameter to reveal the bytecode:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用`javap`命令简化了反编译字节码的打印。现在，让我们使用`-c`参数来揭示字节码：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is the output from running the `javap` command with the `-c` parameter,
    using our example code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用`-c`参数运行`javap`命令并使用我们的示例代码的输出：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You should now have a better appreciation of the miraculous work the JVM does.
    We are just getting started!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该对JVM所做奇迹般的工作有了更好的认识。我们才刚刚开始！
- en: More options with javap
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用javap的更多选项
- en: 'So far, we have used the `javap` command in two forms: without parameters and
    with the `-c` parameter. There are some other parameters we can use to further
    our understanding of our bytecode. To review these parameters, we will use an
    abbreviated example, shown next:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经以两种形式使用了`javap`命令：不带参数和带`-c`参数。还有一些其他参数我们可以使用，以进一步了解我们的字节码。为了回顾这些参数，我们将使用一个简化的示例，如下所示：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can now compile the class first using `javac` and then run it. Let’s use
    the `-sysinfo` parameter to output system information. As you can see next, the
    file path, file size, date, and a `SHA-256` hash are printed:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以先使用`javac`编译类，然后运行它。让我们使用`-sysinfo`参数输出系统信息。如您所见，打印了文件路径、文件大小、日期和`SHA-256`哈希值：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is the output from using the `-``sysinfo` parameter:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用`-sysinfo`参数的输出：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s look at one more example of the `javap` command, this time using the
    `-verbose` parameter. Here is how to use that parameter via a terminal command
    line:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个`javap`命令的例子，这次使用`-verbose`参数。以下是使用终端命令行使用该参数的方法：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output from using the `-verbose` parameter is shown next. As you can see,
    there is a lot of additional information provided:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-verbose`参数的输出如下。如您所见，提供了大量附加信息：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The remainder of the output can be obtained here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter01/java-output](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter01/java-output).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的输出可以在此处获得：[https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter01/java-output](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter01/java-output)。
- en: 'We can use the `javap` command to thoroughly examine our bytecode. Here are
    some common parameters that are available to us, in addition to `-c`, -`sysinfo`,
    and `-verbose`, which we have already used:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`javap`命令彻底检查我们的字节码。以下是一些常见的参数，除了我们已使用的`-c`、`-sysinfo`和`-verbose`之外：
- en: '| **javap Parameter** | **What** **is Printed** |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **javap参数** | **打印内容** |'
- en: '| `-``constants` | Constants (static final) |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `-constants` | 常量（静态final）|'
- en: '| `-help (``or -?)` | Help |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `-help (或 -?)` | 帮助 |'
- en: '| `-l` | Line variables and local variables |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `-l` | 行变量和局部变量 |'
- en: '| `-private (``or -p)` | All classes |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `-private (或 -p)` | 所有类 |'
- en: '| `-``protected` | Protected and public classes (not private) |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `-protected` | 受保护和公共类（非私有）|'
- en: '| `-``public` | Public classes (does not print private classes) |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `-public` | 公共类（不打印私有类）|'
- en: '| `-s` | Internal signature types |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `-s` | 内部签名类型 |'
- en: '| `-``version` | Java release version |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `-sysinfo` | Java发布版本 |'
- en: Table 1.1 – javap parameters
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.1 – javap参数
- en: Now that you have seen the inside workings of the JVM, let’s take a look at
    the phenomenal job it does with garbage collection.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了JVM的内部工作原理，让我们看看它在垃圾收集方面所做的不凡工作。
- en: Garbage collection
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾收集
- en: Java developers have long enjoyed the JVM’s ability to manage memory, including
    allocation and deallocation. The allocation component of memory management is
    straightforward and not wrought with inherent problems. The area that is most
    important is freeing previously allocated memory that is no longer needed by the
    application. This is referred to as deallocation or garbage collection. While
    not unique to Java programming language, its JVM does a wonderful job with garbage
    collection. This section takes a detailed look at JVM’s garbage collection.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Java开发者长期以来一直享受JVM管理内存的能力，包括分配和释放。内存管理的分配部分很简单，没有固有的问题。最重要的领域是释放不再由应用程序需要的先前分配的内存。这被称为释放或垃圾收集。虽然并非Java编程语言独有，但其JVM在垃圾收集方面做得非常出色。本节将详细探讨JVM的垃圾收集。
- en: The garbage collection process
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垃圾收集过程
- en: 'The following example is the creation of two objects, making them reference
    each other, and then nullifying them both. Once they are nullified, they are no
    longer reachable, despite that they reference each other. This makes them eligible
    for garbage collection:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是创建两个对象，使它们相互引用，然后使它们都为null。一旦它们被置为null，尽管它们相互引用，但它们就不再可达。这使得它们有资格进行垃圾收集：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding example, we could make an explicit call to the garbage collector.
    This is not generally advisable as the JVM does a great job of this already, and
    extra calls could impact performance. If you do want to make that explicit call,
    this is how you would do it:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以显式地调用垃圾收集器。这通常不建议这样做，因为JVM已经在这方面做得很好，额外的调用可能会影响性能。如果您确实想进行显式调用，以下是这样做的方法：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note on the finalize() method
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`finalize()`方法的说明
- en: The JVM only calls the `finalize()` method if it has been enabled. When enabled,
    it is possible that it will be called by the garbage collector, after an unspecified
    time delay. The method has been deprecated and should only be used for testing,
    not in production systems.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: JVM仅在启用的情况下才会调用`finalize()`方法。启用后，它可能会在不确定的时间延迟后由垃圾收集器调用。该方法已被弃用，并且仅应用于测试，而不应在生产系统中使用。
- en: 'If you want to conduct additional testing, you can add code that attempts to
    reach unreachable objects. Here is how you would do that:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进行额外的测试，你可以添加尝试访问不可达对象的代码。以下是这样做的方法：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding `try`-`catch` block has a call to `object1`. Since that is unreachable,
    it will throw a `NullPointerException` exception.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`try`-`catch`块调用了`object1`。由于该对象不可达，它将抛出`NullPointerException`异常。
- en: Garbage collection algorithms
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垃圾收集算法
- en: 'The JVM has several garbage collection algorithms at its disposal, and which
    one is used depends upon the version of Java and the specific use case. There
    are a few garbage collection algorithms worth mentioning:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: JVM有几种垃圾收集算法可供选择，具体使用哪种算法取决于Java的版本和特定的使用场景。以下是一些值得注意的垃圾收集算法：
- en: '**Serial Collector**'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**串行收集器**'
- en: '**Parallel Collector**'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行收集器**'
- en: '**Concurrent Mark-Sweep** **Collector** (**CMS**)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发标记清除** **收集器**（**CMS**）'
- en: '**Garbage-First** (**G1**) **Collector**'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垃圾-第一**（**G1**）**收集器**'
- en: '**Z Garbage** **Collector** (**ZGC**)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Z垃圾** **收集器**（**ZGC**）'
- en: Each of these garbage collection algorithms is described next so that you can
    gain a better appreciation for the heavy lifting the JVM does to deallocate memory
    for us.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将逐一介绍这些垃圾收集算法，以便您更好地理解JVM为我们分配内存所做的大量工作。
- en: '**Serial Collector**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**串行收集器**'
- en: The serial garbage collector is the JVM’s most basic algorithm. It is used for
    small heaps and single-threaded applications. This type of application can be
    characterized as sequential execution, not concurrent execution. Since there is
    only one thread to consider, memory management is much easier. Another characterizing
    feature is that single-threaded applications often only use a portion of the host’s
    CPU capabilities. Finally, since the execution is sequential, predicting the need
    for garbage collection is uncomplicated.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 串行垃圾收集器是JVM最基础的算法。它用于小型堆和单线程应用程序。这类应用程序的特征是顺序执行，而不是并发执行。由于只有一个线程需要考虑，内存管理要容易得多。另一个特征是，单线程应用程序通常只使用主机CPU能力的一部分。最后，由于执行是顺序的，预测垃圾收集的需要很简单。
- en: '**Parallel Collector**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**并行收集器**'
- en: The parallel garbage collector, also referred to as the throughput garbage collector,
    was the default for early Java releases through Java 8\. Its capabilities exceed
    that of the serial collector in that it was designed for medium- to large-sized
    heaps and multithreaded applications.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 并行垃圾收集器，也称为吞吐量垃圾收集器，在Java 8之前的早期Java版本中是默认的。它的能力超过了串行收集器，因为它是为中等到大型堆和多线程应用程序设计的。
- en: '**CMS**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**CMS**'
- en: The CMS garbage collector was deprecated in Java 9 and removed from the Java
    platform in Java 14\. Its purpose was to minimize the amount of time an application
    was paused for garbage collection. The reasons for deprecation and removal included
    high resource consumption, failures due to lag, difficulty in maintaining the
    code base, and that there were better alternatives.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: CMS垃圾收集器在Java 9中被弃用，并在Java 14中从Java平台中移除。其目的是最小化应用程序因垃圾收集而暂停的时间。弃用和移除的原因包括资源消耗高、由于延迟导致的失败、维护代码库困难，以及有更好的替代方案。
- en: '**G1 Collector**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**G1收集器**'
- en: The G1 Collector became the default garbage collector in Java 9, dethroning
    the parallel collector. G1 was designed to provide faster and more predictable
    response times and extremely high throughput. The G1 Collector can be considered
    the primary and default garbage collector.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: G1 收集器在 Java 9 中成为默认的垃圾收集器，取代了并行收集器。G1 是为了提供更快、更可预测的响应时间和极高的吞吐量而设计的。G1 收集器可以被认为是主要的和默认的垃圾收集器。
- en: '**ZGC**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**ZGC**'
- en: Java 11 was released with the ZGC garbage collector as an experimental feature.
    ZGC’s aim was to provide a low-latency garbage collector that was scalable. The
    intention was for ZGC to handle a wide range of heap sizes, from very small to
    very large (for example, terabytes). ZGC delivered on these goals without sacrificing
    pause times. This success led to ZGC being released as a Java 15 feature.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Java 11 发布时，ZGC 垃圾收集器作为一个实验性功能。ZGC 的目标是提供一个低延迟、可扩展的垃圾收集器。目标是让 ZGC 能够处理从非常小到非常大的各种堆大小（例如，太字节）。ZGC
    实现了这些目标，而没有牺牲暂停时间。这一成功导致 ZGC 作为 Java 15 的一个功能被发布。
- en: Garbage collection optimizations
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垃圾收集优化
- en: 'Discerning Java developers are laser-focused on getting the most performance
    out of the JVM for their applications. To this end, several things can be done
    with respect to garbage collection to help improve the performance of Java applications:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 精明的 Java 开发者专注于为他们的应用程序从 JVM 中获取最佳性能。为此，可以通过垃圾收集来采取一些措施，以帮助提高 Java 应用程序的性能：
- en: Select the most appropriate garbage collection algorithm based on your use case,
    heap size, and thread count.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据你的用例、堆大小和线程数选择最合适的垃圾收集算法。
- en: Initialize, monitor, and manage your heap sizes. They should not be larger than
    absolutely needed.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化、监控和管理你的堆大小。它们不应超过绝对需要的大小。
- en: Limit object creation. We will discuss alternatives to this in [*Chapter 6*](B21942_06.xhtml#_idTextAnchor105).
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制对象创建。我们将在[*第 6 章*](B21942_06.xhtml#_idTextAnchor105)中讨论这个问题的替代方案。
- en: Use appropriate data structures for your applications. This is the subject of
    [*Chapter 2*](B21942_02.xhtml#_idTextAnchor028).
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的应用程序使用适当的数据结构。这是[*第 2 章*](B21942_02.xhtml#_idTextAnchor028)的主题。
- en: As indicated earlier in this chapter, avoid, or at least significantly limit,
    calls to the `finalize` method to reduce garbage collection delays and processing
    overhead.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如本章前面所述，为了避免或至少显著限制对 `finalize` 方法的调用，以减少垃圾收集延迟和处理开销。
- en: Optimize your use of strings, with a special focus on minimizing duplicate strings.
    We will cover this in greater depth in [*Chapter 7*](B21942_07.xhtml#_idTextAnchor127).
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 优化字符串的使用，特别关注最小化重复字符串。我们将在[*第 7 章*](B21942_07.xhtml#_idTextAnchor127)中更深入地探讨这个问题。
- en: Be mindful of allocating memory outside of the JVM’s garbage collection reach
    (for example, native code).
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意不要在 JVM 的垃圾收集范围之外分配内存（例如，本地代码）。
- en: Lastly, employ tools to help you monitor garbage collection in real time. We
    will review some of these tools in [*Chapter 14*](B21942_14.xhtml#_idTextAnchor250).
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用工具来帮助你在实时监控垃圾收集。我们将在[*第 14 章*](B21942_14.xhtml#_idTextAnchor250)中回顾一些这些工具。
- en: Hopefully, you have a newfound appreciation of JVM’s garbage collection and
    optimization methods. We will now take a look at specific compiler optimizations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你已经对 JVM 的垃圾收集和优化方法有了新的认识。现在，我们将探讨具体的编译器优化。
- en: JIT compiler optimizations
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JIT 编译器优化
- en: 'There are three key components of the JVM: a class loader that initializes
    and links classes and interfaces; runtime data, which includes memory allocation;
    and the execution engine. This latter component, the execution engine, is the
    focus of this section.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 有三个关键组件：一个初始化和链接类和接口的类加载器；运行时数据，包括内存分配；以及执行引擎。本节的重点是这个执行引擎组件。
- en: 'The core responsibility of the execution engine is to convert bytecode so that
    it can be executed on the host **central processing unit** (**CPU**). There are
    three primary implementations of this process:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 执行引擎的核心责任是将字节码转换为可以在主机 **中央处理单元**（**CPU**）上执行的形式。这个过程有三个主要实现：
- en: Interpretation
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释
- en: '**Ahead-of-Time** (**AOT**) compilation'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提前编译**（**AOT**）'
- en: JIT compilation
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JIT 编译
- en: We will take a cursory look at interpretation and AOT compilation before diving
    into JIT compilation optimizations.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究 JIT 编译优化之前，我们将简要地看看解释和 AOT 编译。
- en: Interpretation
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释
- en: 'Interpretation is a technique that the JVM can use to read and execute bytecode
    without converting it into machine code native to the host CPU. We can invoke
    this mode by using the `java` command in a terminal window. Here is an example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 解释是JVM可以用来读取和执行字节码而不将其转换为宿主CPU的本地机器码的技术。我们可以通过在终端窗口中使用`java`命令来调用此模式。以下是一个示例：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The only real advantage of using the interpretation mode is to save time by
    avoiding the compilation process. This can be useful for testing and is not recommended
    for production systems. Performance is a typical problem when using interpretation
    as compared to AOT and JIT, both described next.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用解释模式的唯一真正优势是通过避免编译过程来节省时间。这对于测试可能是有用的，但不建议用于生产系统。与AOT和JIT（接下来将描述）相比，使用解释通常会出现性能问题。
- en: AOT compilation
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AOT编译
- en: 'We can compile our bytecode into native machine code in advance of application
    execution. This approach is called AOT and can be used for performance enhancements.
    Specific advantages to this approach include the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在应用程序执行之前将我们的字节码编译成本地机器码。这种方法称为AOT，可以用于性能提升。这种方法的具体优势包括以下内容：
- en: You can avoid normal application startup delays associated with the traditional
    JIT compilation process
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以避免与传统的JIT编译过程相关的正常应用程序启动延迟
- en: The startup execution speed is consistent
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动执行速度保持一致
- en: Startup CPU load is typically reduced
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动时的CPU负载通常较低
- en: Mitigate security risks by avoiding other compilation approaches
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过避免其他编译方法来减轻安全风险
- en: You can build optimization into your startup code
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在启动代码中构建优化
- en: 'There are also a few disadvantages to using the AOT compilation approach:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AOT编译方法也有一些缺点：
- en: When you compile ahead of time, you lose the ability to deploy on any device
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你在编译时，你将失去在任何设备上部署的能力
- en: It is possible that your application will be bloated, increasing storage and
    related costs
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能你的应用程序会变得臃肿，增加存储和相关成本
- en: Your application will not be able to take advantage of JVM optimizations that
    are associated with JIT compilation
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的应用程序将无法利用与JIT编译关联的JVM优化
- en: The complexity of code maintenance increases
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码维护的复杂性增加
- en: Understanding the benefits and disadvantages can help you decide when to, and
    when not to, use the AOT compilation process.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 了解其优势和劣势可以帮助你决定何时以及何时不使用AOT编译过程。
- en: JIT compilation
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JIT编译
- en: The JIT compilation process is likely the one we are most familiar with. We
    invoke the JVM and have it convert our bytecode into machine code specific to
    the current host machine. This machine code is referred to as native machine code
    because it is native to the local CPU. This compilation occurs just in time, or
    just before execution. This means the entirety of the bytecode is not compiled
    at once.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: JIT编译过程可能是我们最熟悉的。我们调用JVM，并让它将我们的字节码转换为针对当前主机机器的特定机器码。这种机器码被称为本地机器码，因为它对本地CPU来说是本地的。这种编译是在即时发生的，或者是在执行之前。这意味着不是所有的字节码都会一次性编译。
- en: The advantages of JIT compilation are increased performance over the interpretation
    approach, the ability to deploy your application on any device (platform agnostic),
    and the ability to optimize. The JIT compiler process is capable of optimizing
    the code (for example, removing dead code, loop unrolling, and more. The disadvantages
    are the overhead required at the initial startup and the use of memory caused
    by the need to store native machine code translations.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: JIT编译的优点是相对于解释方法，性能提高，能够在任何设备（平台无关）上部署你的应用程序，以及能够进行优化。JIT编译器过程能够优化代码（例如，删除死代码、循环展开等）。缺点是初始启动时的开销以及由于需要存储本地机器码翻译而导致的内存使用。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: By now, you should have an appreciation of the complexities of the JVM and how
    it works. This chapter’s coverage included the `javac` and `javap` command-line
    tools to create and analyze bytecode. The JVM’s garbage collection function was
    also examined through the lens of application performance. Lastly, the optimization
    of JIT compilation was covered.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经对JVM的复杂性和其工作原理有了认识。本章涵盖了`javac`和`javap`命令行工具，用于创建和分析字节码。JVM的垃圾回收功能也通过应用程序性能的角度进行了考察。最后，还介绍了JIT编译的优化。
- en: The JVM is 29 years old, as of this book’s publication date, and it has come
    a long way since its initial release. In addition to continual improvements and
    optimizations, the JVM can even support additional languages (for example, Kotlin
    and Scala). Java developers interested in continual performance improvement of
    their Java applications should stay abreast of JVM updates.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到本书出版之日，JVM 已经有 29 年的历史，自从它的首次发布以来已经取得了长足的进步。除了持续的改进和优化之外，JVM 还能支持额外的语言（例如 Kotlin
    和 Scala）。对持续提高其 Java 应用性能感兴趣的 Java 开发者应该关注 JVM 的更新。
- en: With a solid understanding of the JVM, we turn our focus to data structures
    in the next chapter. Our focus will be on using data structures optimally as part
    of our high-performance strategy.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 JVM 的扎实理解，我们在下一章将关注数据结构。我们的重点将放在如何最优地使用数据结构作为我们高性能策略的一部分。
