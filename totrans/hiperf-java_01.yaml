- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Peeking Inside the Java Virtual Machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I would like to introduce you to a remarkable piece of technology that helped
    revolutionize the software industry. Meet the **Java Virtual Machine** (**JVM**).
    Okay, so you are likely already familiar with the JVM, and it is important to
    understand and appreciate the tremendous value it has as the middleware between
    compiled Java bytecode and a virtually limitless number of hardware platforms.
    The ingenious design of Java and the JVM is a testament to its wild popularity
    and value to users and developers.
  prefs: []
  type: TYPE_NORMAL
- en: Since the first release of Java in the 1990s, the JVM has been the true success
    factor for the Java programming language. With Java and the JVM, the concept of
    “write once, run anywhere” was born. Java developers can write their programs
    once and allow the JVM to ensure the code runs on devices the JVM is installed
    on. The JVM also makes Java a platform-independent language. The primary objective
    of this chapter is to provide greater insights into the unsung hero of Java, the
    JVM.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take an extensive look at the JVM so that we can learn
    to get the most out of it in an effort to increase the performance of our Java
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How the JVM works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Just-in-Time** (**JIT**) compiler optimizations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should understand how to get the most out of
    the JVM to improve the performance of your Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the instructions in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A computer with either Windows, macOS, or Linux installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current version of the Java SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preferably, a code editor or **integrated development environment** (**IDE**)
    (such as Visual Studio Code, NetBeans, Eclipse, or IntelliJ IDEA)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The finished code for this chapter can be found here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter01](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter01).'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: This book is based on Java 21 and the **Java Development Kit** (**JDK**) 21.0.1\.
    It also uses the IntelliJ IDEA Community Edition IDE, running on macOS.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter contains code examples that you can use to follow along with and
    experiment with. So, you will want to ensure your system is properly prepared.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by downloading and installing your IDE of choice. Here are a couple of
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code ([https://code.visualstudio.com/download](https://code.visualstudio.com/download))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NetBeans ([https://netbeans.apache.org/download/](https://netbeans.apache.org/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eclipse ([https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IntelliJ IDEA Community Edition ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After your IDE is set up, you need to ensure it is configured for Java development.
    Most modern IDEs are capable of downloading and installing the Java SDK for you.
    If this is not the case for you, the Java SDK can be obtained here: [https://www.oracle.com/java/technologies/downloads/](https://www.oracle.com/java/technologies/downloads/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensuring that your IDE is Java-ready is important. Here are some IDE-specific
    links in case you need some help:'
  prefs: []
  type: TYPE_NORMAL
- en: Java in Visual Studio Code ([https://code.visualstudio.com/docs/languages/java](https://code.visualstudio.com/docs/languages/java))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java quick start tutorial for NetBeans ([https://netbeans.apache.org/tutorial/main/kb/docs/java/quickstart/](https://netbeans.apache.org/tutorial/main/kb/docs/java/quickstart/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing Eclipse ([https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2FgettingStarted%2Fqs-3.htm](https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2FgettingStarted%2Fqs-3.htm))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first Java application with IntelliJ IDEA Community Edition ([https://www.jetbrains.com/help/idea/creating-and-running-your-first-java-application.html](https://www.jetbrains.com/help/idea/creating-and-running-your-first-java-application.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have your IDE and the Java SDK installed and configured on your computer,
    you are ready to move to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How the JVM works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the core, the JVM sits between your Java bytecode and your computer. As
    illustrated next, we develop our Java source code in an IDE, and our work is saved
    as `.java` files. We use the Java compiler to convert our Java source code to
    bytecode; the resulting files are `.class` files. We then use the JVM to run our
    bytecode on our computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21942_01_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Java application workflow
  prefs: []
  type: TYPE_NORMAL
- en: It is important to realize that Java is different from typical compile-and-execute
    languages where source code is fed into a compiler, which then produces a `.exe`
    file (for Windows), a `.app` file (for (macOS), or `ELF` files (for Linux). This
    impressive process is much more complex than it seems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at what is going on with regard to the JVM, using
    a basic example. In the following code, we implement a simple loop that prints
    to the console. It is presented so that we can see how the JVM handles Java code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the Java compiler to compile our code into a `.class` file, which
    will be formatted as bytecode. Let’s open a terminal window, navigate to our project’s
    `src` folder as shown next, and use the `ls` command to reveal our `.``java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we are in the proper folder, we can use `javac` to convert our source
    code to bytecode. As you can see next, this created a `.``class` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can use the `javap`) to print a decompiled version of our bytecode.
    As you can see next, we can use the `javap` command without any parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, our use of the `javap` command simplified the printing of the
    decompiled bytecode. Now, let’s use the `-c` parameter to reveal the bytecode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output from running the `javap` command with the `-c` parameter,
    using our example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You should now have a better appreciation of the miraculous work the JVM does.
    We are just getting started!
  prefs: []
  type: TYPE_NORMAL
- en: More options with javap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have used the `javap` command in two forms: without parameters and
    with the `-c` parameter. There are some other parameters we can use to further
    our understanding of our bytecode. To review these parameters, we will use an
    abbreviated example, shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now compile the class first using `javac` and then run it. Let’s use
    the `-sysinfo` parameter to output system information. As you can see next, the
    file path, file size, date, and a `SHA-256` hash are printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output from using the `-``sysinfo` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at one more example of the `javap` command, this time using the
    `-verbose` parameter. Here is how to use that parameter via a terminal command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from using the `-verbose` parameter is shown next. As you can see,
    there is a lot of additional information provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The remainder of the output can be obtained here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter01/java-output](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter01/java-output).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `javap` command to thoroughly examine our bytecode. Here are
    some common parameters that are available to us, in addition to `-c`, -`sysinfo`,
    and `-verbose`, which we have already used:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **javap Parameter** | **What** **is Printed** |'
  prefs: []
  type: TYPE_TB
- en: '| `-``constants` | Constants (static final) |'
  prefs: []
  type: TYPE_TB
- en: '| `-help (``or -?)` | Help |'
  prefs: []
  type: TYPE_TB
- en: '| `-l` | Line variables and local variables |'
  prefs: []
  type: TYPE_TB
- en: '| `-private (``or -p)` | All classes |'
  prefs: []
  type: TYPE_TB
- en: '| `-``protected` | Protected and public classes (not private) |'
  prefs: []
  type: TYPE_TB
- en: '| `-``public` | Public classes (does not print private classes) |'
  prefs: []
  type: TYPE_TB
- en: '| `-s` | Internal signature types |'
  prefs: []
  type: TYPE_TB
- en: '| `-``version` | Java release version |'
  prefs: []
  type: TYPE_TB
- en: Table 1.1 – javap parameters
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have seen the inside workings of the JVM, let’s take a look at
    the phenomenal job it does with garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java developers have long enjoyed the JVM’s ability to manage memory, including
    allocation and deallocation. The allocation component of memory management is
    straightforward and not wrought with inherent problems. The area that is most
    important is freeing previously allocated memory that is no longer needed by the
    application. This is referred to as deallocation or garbage collection. While
    not unique to Java programming language, its JVM does a wonderful job with garbage
    collection. This section takes a detailed look at JVM’s garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: The garbage collection process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example is the creation of two objects, making them reference
    each other, and then nullifying them both. Once they are nullified, they are no
    longer reachable, despite that they reference each other. This makes them eligible
    for garbage collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we could make an explicit call to the garbage collector.
    This is not generally advisable as the JVM does a great job of this already, and
    extra calls could impact performance. If you do want to make that explicit call,
    this is how you would do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note on the finalize() method
  prefs: []
  type: TYPE_NORMAL
- en: The JVM only calls the `finalize()` method if it has been enabled. When enabled,
    it is possible that it will be called by the garbage collector, after an unspecified
    time delay. The method has been deprecated and should only be used for testing,
    not in production systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to conduct additional testing, you can add code that attempts to
    reach unreachable objects. Here is how you would do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `try`-`catch` block has a call to `object1`. Since that is unreachable,
    it will throw a `NullPointerException` exception.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JVM has several garbage collection algorithms at its disposal, and which
    one is used depends upon the version of Java and the specific use case. There
    are a few garbage collection algorithms worth mentioning:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Serial Collector**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parallel Collector**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrent Mark-Sweep** **Collector** (**CMS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Garbage-First** (**G1**) **Collector**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Z Garbage** **Collector** (**ZGC**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these garbage collection algorithms is described next so that you can
    gain a better appreciation for the heavy lifting the JVM does to deallocate memory
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: '**Serial Collector**'
  prefs: []
  type: TYPE_NORMAL
- en: The serial garbage collector is the JVM’s most basic algorithm. It is used for
    small heaps and single-threaded applications. This type of application can be
    characterized as sequential execution, not concurrent execution. Since there is
    only one thread to consider, memory management is much easier. Another characterizing
    feature is that single-threaded applications often only use a portion of the host’s
    CPU capabilities. Finally, since the execution is sequential, predicting the need
    for garbage collection is uncomplicated.
  prefs: []
  type: TYPE_NORMAL
- en: '**Parallel Collector**'
  prefs: []
  type: TYPE_NORMAL
- en: The parallel garbage collector, also referred to as the throughput garbage collector,
    was the default for early Java releases through Java 8\. Its capabilities exceed
    that of the serial collector in that it was designed for medium- to large-sized
    heaps and multithreaded applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**CMS**'
  prefs: []
  type: TYPE_NORMAL
- en: The CMS garbage collector was deprecated in Java 9 and removed from the Java
    platform in Java 14\. Its purpose was to minimize the amount of time an application
    was paused for garbage collection. The reasons for deprecation and removal included
    high resource consumption, failures due to lag, difficulty in maintaining the
    code base, and that there were better alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: '**G1 Collector**'
  prefs: []
  type: TYPE_NORMAL
- en: The G1 Collector became the default garbage collector in Java 9, dethroning
    the parallel collector. G1 was designed to provide faster and more predictable
    response times and extremely high throughput. The G1 Collector can be considered
    the primary and default garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: '**ZGC**'
  prefs: []
  type: TYPE_NORMAL
- en: Java 11 was released with the ZGC garbage collector as an experimental feature.
    ZGC’s aim was to provide a low-latency garbage collector that was scalable. The
    intention was for ZGC to handle a wide range of heap sizes, from very small to
    very large (for example, terabytes). ZGC delivered on these goals without sacrificing
    pause times. This success led to ZGC being released as a Java 15 feature.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection optimizations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Discerning Java developers are laser-focused on getting the most performance
    out of the JVM for their applications. To this end, several things can be done
    with respect to garbage collection to help improve the performance of Java applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the most appropriate garbage collection algorithm based on your use case,
    heap size, and thread count.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize, monitor, and manage your heap sizes. They should not be larger than
    absolutely needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Limit object creation. We will discuss alternatives to this in [*Chapter 6*](B21942_06.xhtml#_idTextAnchor105).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use appropriate data structures for your applications. This is the subject of
    [*Chapter 2*](B21942_02.xhtml#_idTextAnchor028).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As indicated earlier in this chapter, avoid, or at least significantly limit,
    calls to the `finalize` method to reduce garbage collection delays and processing
    overhead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optimize your use of strings, with a special focus on minimizing duplicate strings.
    We will cover this in greater depth in [*Chapter 7*](B21942_07.xhtml#_idTextAnchor127).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be mindful of allocating memory outside of the JVM’s garbage collection reach
    (for example, native code).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, employ tools to help you monitor garbage collection in real time. We
    will review some of these tools in [*Chapter 14*](B21942_14.xhtml#_idTextAnchor250).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hopefully, you have a newfound appreciation of JVM’s garbage collection and
    optimization methods. We will now take a look at specific compiler optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: JIT compiler optimizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three key components of the JVM: a class loader that initializes
    and links classes and interfaces; runtime data, which includes memory allocation;
    and the execution engine. This latter component, the execution engine, is the
    focus of this section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The core responsibility of the execution engine is to convert bytecode so that
    it can be executed on the host **central processing unit** (**CPU**). There are
    three primary implementations of this process:'
  prefs: []
  type: TYPE_NORMAL
- en: Interpretation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ahead-of-Time** (**AOT**) compilation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JIT compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will take a cursory look at interpretation and AOT compilation before diving
    into JIT compilation optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Interpretation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Interpretation is a technique that the JVM can use to read and execute bytecode
    without converting it into machine code native to the host CPU. We can invoke
    this mode by using the `java` command in a terminal window. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The only real advantage of using the interpretation mode is to save time by
    avoiding the compilation process. This can be useful for testing and is not recommended
    for production systems. Performance is a typical problem when using interpretation
    as compared to AOT and JIT, both described next.
  prefs: []
  type: TYPE_NORMAL
- en: AOT compilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can compile our bytecode into native machine code in advance of application
    execution. This approach is called AOT and can be used for performance enhancements.
    Specific advantages to this approach include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You can avoid normal application startup delays associated with the traditional
    JIT compilation process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The startup execution speed is consistent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Startup CPU load is typically reduced
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mitigate security risks by avoiding other compilation approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can build optimization into your startup code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also a few disadvantages to using the AOT compilation approach:'
  prefs: []
  type: TYPE_NORMAL
- en: When you compile ahead of time, you lose the ability to deploy on any device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible that your application will be bloated, increasing storage and
    related costs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your application will not be able to take advantage of JVM optimizations that
    are associated with JIT compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complexity of code maintenance increases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the benefits and disadvantages can help you decide when to, and
    when not to, use the AOT compilation process.
  prefs: []
  type: TYPE_NORMAL
- en: JIT compilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JIT compilation process is likely the one we are most familiar with. We
    invoke the JVM and have it convert our bytecode into machine code specific to
    the current host machine. This machine code is referred to as native machine code
    because it is native to the local CPU. This compilation occurs just in time, or
    just before execution. This means the entirety of the bytecode is not compiled
    at once.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of JIT compilation are increased performance over the interpretation
    approach, the ability to deploy your application on any device (platform agnostic),
    and the ability to optimize. The JIT compiler process is capable of optimizing
    the code (for example, removing dead code, loop unrolling, and more. The disadvantages
    are the overhead required at the initial startup and the use of memory caused
    by the need to store native machine code translations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you should have an appreciation of the complexities of the JVM and how
    it works. This chapter’s coverage included the `javac` and `javap` command-line
    tools to create and analyze bytecode. The JVM’s garbage collection function was
    also examined through the lens of application performance. Lastly, the optimization
    of JIT compilation was covered.
  prefs: []
  type: TYPE_NORMAL
- en: The JVM is 29 years old, as of this book’s publication date, and it has come
    a long way since its initial release. In addition to continual improvements and
    optimizations, the JVM can even support additional languages (for example, Kotlin
    and Scala). Java developers interested in continual performance improvement of
    their Java applications should stay abreast of JVM updates.
  prefs: []
  type: TYPE_NORMAL
- en: With a solid understanding of the JVM, we turn our focus to data structures
    in the next chapter. Our focus will be on using data structures optimally as part
    of our high-performance strategy.
  prefs: []
  type: TYPE_NORMAL
