<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Appendix</h1>
                </header>
            
            <article>
                
<p>This appendix will walk you through lambda expressions, functional types, mixing object-oriented and reactive programming, and how schedulers work.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing lambda expressions</h1>
                </header>
            
            <article>
                
<p>Java officially supported lambda expressions when Java 8 was released in 2014. <em>Lambda expressions</em> are shorthand implementations for <strong>single abstract method</strong> (<strong>SAM</strong>) classes. In other words, they are quick ways to pass functional arguments instead of anonymous classes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making a Runnable a lambda</h1>
                </header>
            
            <article>
                
<p>Prior to Java 8, you might have leveraged anonymous classes to implement interfaces, such as <kbd>Runnable</kbd>, on the fly as shown in the following code snippet:</p>
<pre style="padding-left: 60px"><span>public class </span><span>Launcher </span><span>{<br/><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Runnable </span><span>runnable </span><span>= </span><span>new </span><span>Runnable</span><span>() {<br/></span><span>            </span><span>@Override<br/></span><span>            </span><span>public void </span><span>run</span><span>() {<br/></span><span>                </span><span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"run() was called!"</span><span>);<br/></span><span>            }<br/></span><span>        };<br/></span><span><br/></span><span>        </span><span>runnable</span><span>.</span><span>run</span><span>();<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px"><span>run</span><span>() </span>was called<span>!</span></pre>
<p>To implement <kbd>Runnable</kbd> without declaring an explicit class, you had to implement its <kbd>run()</kbd> abstract method in a block immediately after the constructor. This created a lot of boilerplate and became a major pain point with Java development, and was a barrier to using Java for functional programming. Thankfully, Java 8 officially brought lambdas to the Java language. With lambda expressions, you can express this in a much more concise way:</p>
<pre style="padding-left: 60px"><span>public class </span><span>Launcher </span><span>{<br/><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Runnable </span><span>runnable </span><span>= </span><span>() </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"run() was<br/>        called!"</span><span>);<br/></span><span><br/></span><span>        </span><span>runnable</span><span>.</span><span>run</span><span>();<br/></span><span>    }<br/></span><span>}</span></pre>
<p>Awesome, right? That is a lot less code and boilerplate noise, and we will dive into how this works. Lambda expressions can target any interface or abstract class with one abstract method, which is called <em>single abstract method</em> types. In the preceding code, the <kbd>Runnable</kbd> interface has a single abstract method called <kbd>run()</kbd>. If you pass a lambda that matches the arguments and return type for that abstract method, the compiler will use that lambda for the implementation of that method.</p>
<p>Everything to the left of the <kbd>-&gt;</kbd> arrow is an argument. The <kbd>run()</kbd> method of <kbd>Runnable</kbd> does not take any arguments, so the lambda provides no arguments with the empty parenthesis <kbd>()</kbd>. The right side of the arrow <kbd>-&gt;</kbd> is the action to be executed. In this example, we are calling a single statement and printing a simple message with <kbd>System.out.println("run() was called!");</kbd>.</p>
<p>Java 8 lambdas can support multiple statements in the body. Say we have this <kbd>Runnable</kbd> anonymous inner class with multiple statements in its <kbd>run()</kbd> implementation, as shown in the following code snippet:</p>
<pre style="padding-left: 60px"><span>public class </span><span>Launcher </span><span>{<br/></span><span>    <br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Runnable </span><span>runnable </span><span>= </span><span>new </span><span>Runnable</span><span>() {<br/></span><span>            </span><span>@Override<br/></span><span>            </span><span>public void </span><span>run</span><span>() {<br/></span><span>                </span><span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Message 1"</span><span>);<br/></span><span>                </span><span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Message 2"</span><span>);<br/></span><span>            }<br/></span><span>        };<br/></span><span><br/></span><span>        </span><span>runnable</span><span>.</span><span>run</span><span>();<br/></span><span>    }<br/></span><span>}</span></pre>
<p>You can move both <kbd>System.out.println()</kbd> statements to a lambda by wrapping them in a multiline <kbd>{ }</kbd> block to the right of the arrow <kbd>-&gt;</kbd>. Note that you need to use semicolons to terminate each line within the lambda, shown <span>in the following code snippet</span>:</p>
<pre style="padding-left: 60px"><span>public class </span><span>Launcher </span><span>{<br/></span><span>    <br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Runnable </span><span>runnable </span><span>= </span><span>() </span>-&gt; <span>{<br/></span><span>            </span><span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Message 1"</span><span>);<br/></span><span>            </span><span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Message 2"</span><span>);<br/></span><span>        };<br/></span><span><br/></span><span>        </span><span>runnable</span><span>.</span><span>run</span><span>();<br/></span><span>    }<br/></span><span>}</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making a Supplier a lambda</h1>
                </header>
            
            <article>
                
<p>Lambdas can also implement methods that return items. For instance, the <kbd>Supplier</kbd> class introduced in Java 8 (and originally introduced in Google Guava) has an abstract <kbd>get()</kbd> method that returns a <kbd>T</kbd> item for a given <kbd>Supplier&lt;T&gt;</kbd>. If we have a <kbd>Supplier&lt;List&lt;String&gt;&gt;</kbd> whose <kbd>get()</kbd> returns <kbd>List&lt;String&gt;</kbd>, we can implement it using an old-fashioned anonymous class:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>java.util.ArrayList</span><span>;<br/></span><span>import </span><span>java.util.</span><span>List</span><span>;<br/></span><span>import </span><span>java.util.function.</span><span>Supplier</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Supplier</span><span>&lt;</span><span>List</span><span>&lt;</span><span>String</span><span>&gt;&gt; </span><span>listGenerator </span><span>= </span><span>new<br/></span><span>Supplier</span><span>&lt;</span><span>List</span><span>&lt;</span><span>String</span><span>&gt;&gt;</span><span>() {<br/></span><span>            </span><span>@Override<br/></span><span>            </span><span>public </span><span>List</span><span>&lt;</span><span>String</span><span>&gt; </span><span>get</span><span>() {<br/></span><span>                </span><span>return new </span><span>ArrayList</span><span>&lt;&gt;</span><span>();<br/></span><span>            }<br/></span><span>        };<br/></span><span>        <br/></span><span>        </span><span>List</span><span>&lt;</span><span>String</span><span>&gt; </span><span>myList </span><span>= </span><span>listGenerator</span><span>.</span><span>get</span><span>();<br/></span><span>    }<br/></span><span>}</span></pre>
<p>But we can also use a lambda, which can implement <kbd>get()</kbd> much more succinctly and yield <kbd>List&lt;String&gt;</kbd>, shown as follows:</p>
<pre style="padding-left: 60px"><span>import </span><span>java.util.</span><span>ArrayList</span><span>;<br/></span><span>import </span><span>java.util.</span><span>List</span><span>;<br/></span><span>import </span><span>java.util.function.</span><span>Supplier</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Supplier</span><span>&lt;</span><span>List</span><span>&lt;</span><span>String</span><span>&gt;&gt; </span><span>listGenerator </span><span>= </span><span>() </span>-&gt; <span>new </span><span>ArrayList</span><span>&lt;&gt;<br/></span><span>        ();<br/></span><span><br/></span><span>        </span><span>List</span><span>&lt;</span><span>String</span><span>&gt; </span><span>myList </span><span>= </span><span>listGenerator</span><span>.</span><span>get</span><span>();<br/></span><span>    }<br/></span><span>}</span></pre>
<p>When your lambda is simplify invoking a constructor on a type using the <kbd>new</kbd> keyword, you can use a double colon <kbd>::</kbd> lambda syntax to invoke the constructor on that class. This way, you can leave out the symbols <kbd>()</kbd> and <kbd>-&gt;</kbd>, shown as follows:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>java.util.ArrayList</span><span>;<br/></span><span>import </span><span>java.util.</span><span>List</span><span>;<br/></span><span>import </span><span>java.util.function.</span><span>Supplier</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Supplier</span><span>&lt;</span><span>List</span><span>&lt;</span><span>String</span><span>&gt;&gt; </span><span>listGenerator </span><span>= </span><span>ArrayList</span>::<span>new</span><span>;<br/></span><span><br/></span><span>        </span><span>List</span><span>&lt;</span><span>String</span><span>&gt; </span><span>myList </span><span>= </span><span>listGenerator</span><span>.</span><span>get</span><span>();<br/></span><span>    }<br/></span><span>}</span></pre>
<div class="packt_tip">RxJava does not have Java 8's Supplier but rather a Callable, which accomplishes the same purpose. </div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making a Consumer a lambda</h1>
                </header>
            
            <article>
                
<p><kbd>Consumer&lt;T&gt;</kbd> accepts a <kbd>T</kbd> argument and performs an action with it but does not return any value. Using an anonymous class, we can create a <kbd>Consumer&lt;String&gt;</kbd> that simply prints the string as shown <span>in the following code snippet</span>: <br/>
<br/></p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>java.util.function.</span><span>Consumer</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Consumer</span><span>&lt;</span><span>String</span><span>&gt; </span><span>printConsumer </span><span>= </span><span>new </span><span>Consumer</span><span>&lt;</span><span>String</span><span>&gt;</span><span>() {<br/></span><span>            </span><span>@Override<br/></span><span>            </span><span>public void </span><span>accept</span><span>(</span><span>String </span><span>s</span><span>) {<br/></span><span>                </span><span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>s</span><span>);<br/></span><span>            }<br/></span><span>        };<br/></span><span><br/></span><span>        </span><span>printConsumer</span><span>.</span><span>accept</span><span>(</span><span>"Hello World"</span><span>);<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">Hello World</pre>
<p>You can implement this as a lambda. We can choose to call the <kbd>String</kbd> parameter <kbd>s</kbd> on the left-hand side of the lambda arrow <kbd>-&gt;</kbd> and print it on the right-hand side: </p>
<p> </p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>java.util.function.</span><span>Consumer</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Consumer</span><span>&lt;</span><span>String</span><span>&gt; </span><span>printConsumer </span><span>= (String s)</span><span> </span>-&gt;<br/><span>        System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>s</span><span>);<br/></span><span><br/></span><span>        </span><span>printConsumer</span><span>.</span><span>accept</span><span>(</span><span>"Hello World"</span><span>);<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The compiler can actually infer that <kbd>s</kbd> is a <kbd>String</kbd> type based on the <kbd>Consumer&lt;String&gt;</kbd> you are targeting. So you can leave that explicit type declaration out, as shown in the following code:<br/>
<br/></p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>java.util.function.</span><span>Consumer</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Consumer</span><span>&lt;</span><span>String</span><span>&gt; </span><span>printConsumer </span><span>= </span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>s</span><span>);<br/></span><span><br/></span><span>        </span><span>printConsumer</span><span>.</span><span>accept</span><span>(</span><span>"Hello World"</span><span>);<br/></span><span>    }<br/></span><span>}</span></pre>
<p>For a simple single method invocation, you can actually use another syntax to declare the lambda using a double colon <kbd>::</kbd>. Declare the type you are targeting on the left-hand side of the double-colon and invoke its method on the right-hand side of the double colon. The compiler will be smart enough to figure out you are trying to pass the <kbd>String</kbd> argument to <kbd>System.out::println</kbd>:<br/>
<br/></p>
<pre style="padding-left: 60px"><span>import </span><span>java.util.function.</span><span>Consumer</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Consumer</span><span>&lt;</span><span>String</span><span>&gt; </span><span>printConsumer </span><span>= </span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>;<br/></span><span><br/></span><span>        </span><span>printConsumer</span><span>.</span><span>accept</span><span>(</span><span>"Hello World"</span><span>);<br/></span><span>    }<br/></span><span>}
</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making a Function a lambda</h1>
                </header>
            
            <article>
                
<p>Lambdas can also implement single abstract methods that accept arguments and return an item. For instance, RxJava 2.0 (as well as Java 8) has a <kbd>Function&lt;T,R&gt;</kbd> type that accepts a <kbd>T</kbd> type and returns an <kbd>R</kbd> type. For instance, you can declare a <kbd>Function&lt;String,Integer&gt;</kbd>, whose <kbd>apply()</kbd> method will accept a <kbd>String</kbd>  and return an <kbd>Integer</kbd>. Here, we implement <kbd>apply()</kbd> by returning the string's length in an anonymous class, as shown here:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>java.util.function.</span><span>Function</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Function</span><span>&lt;</span><span>String</span><span>,</span><span>Integer</span><span>&gt; </span><span>lengthMapper </span><span>= </span><span>new </span><span>Function</span><span>&lt;</span><span>String</span><span>,<br/></span><span>Integer</span><span>&gt;</span><span>() {<br/></span><span>            </span><span>@Override<br/></span><span>            </span><span>public </span><span>Integer </span><span>apply</span><span>(</span><span>String </span><span>s</span><span>) {<br/></span><span>                </span><span>return </span><span>s</span><span>.</span><span>length</span><span>();<br/></span><span>            }<br/></span><span>        };<br/></span><span><br/></span><span>        </span><span>Integer </span><span>length </span><span>= </span><span>lengthMapper</span><span>.</span><span>apply</span><span>(</span><span>"Alpha"</span><span>);<br/></span><span><br/></span><span>        </span><span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>length</span><span>);<br/></span><span>    }<br/></span><span>}</span></pre>
<p>You can make this even more concise by implementing <kbd>Function&lt;String,Integer&gt;</kbd> with a lambda, as shown here:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>java.util.function.</span><span>Function</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Function</span><span>&lt;</span><span>String</span><span>,</span><span>Integer</span><span>&gt; </span><span>lengthMapper </span><span>= </span><span>(</span><span>String </span><span>s</span><span>) </span>-&gt;<br/><span>s</span><span>.</span><span>length</span><span>();<br/></span><span><br/></span><span>        </span><span>Integer </span><span>length </span><span>= </span><span>lengthMapper</span><span>.</span><span>apply</span><span>(</span><span>"Alpha"</span><span>);<br/></span><span><br/></span><span>        </span><span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>length</span><span>);<br/></span><span>    }<br/></span><span>}</span></pre>
<p>We have a couple of syntaxes we can alternatively use to implement <kbd>Function&lt;String,Integer&gt;</kbd>.</p>
<p>Java 8's compiler is smart enough to see that our parameter <kbd>s</kbd> is a <kbd>String</kbd> based on the <kbd>Function&lt;String,Integer&gt;</kbd> type we are assigning it to. Therefore, we do not need to explicitly declare <kbd>s</kbd> as a <kbd>String</kbd> because it can infer it:</p>
<pre style="padding-left: 30px"><span>   </span><span>Function</span><span>&lt;</span><span>String</span><span>,</span><span>Integer</span><span>&gt; </span><span>lengthMapper </span><span>= </span><span>(</span><span>s</span><span>) </span>-&gt; <span>s</span><span>.</span><span>length</span><span>();</span></pre>
<p>We do not need to wrap our <kbd>s</kbd> in parentheses <kbd>(s)</kbd> either, as those are not needed for a single argument (but are needed for multiple arguments, as we will see later):</p>
<pre style="padding-left: 30px"><span>   </span><span>Function</span><span>&lt;</span><span>String</span><span>,</span><span>Integer</span><span>&gt; </span><span>lengthMapper </span><span>= </span><span>s </span>-&gt; <span>s</span><span>.</span><span>length</span><span>();</span></pre>
<p>If we are simply calling a method or property on the incoming item, we can use the double colon <kbd>::</kbd> syntax to call the method on that type:</p>
<pre style="padding-left: 30px"><span>   </span><span>Function</span><span>&lt;</span><span>String</span><span>,</span><span>Integer</span><span>&gt; </span><span>lengthMapper </span><span>= </span><span>String</span>::<span>length</span><span>;<br/></span></pre>
<p><kbd>Function&lt;T,R&gt;</kbd> is heavily used in RxJava as <kbd>Observable</kbd> operators often to transform emissions. The most common example is the <kbd>map()</kbd> operator, which turns each <kbd>T</kbd> emission into an <kbd>R</kbd> emission and derives an <kbd>Observable&lt;R&gt;</kbd> from an <kbd>Observable&lt;T&gt;</kbd>.:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{</span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {</span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>,</span><span>"Beta"</span><span>,</span><span>"Gamma"</span><span>)<br/></span><span>                .</span><span>map</span><span>(</span><span>String</span>::<span>length</span><span>) //accepts a Function&lt;T,R&gt;<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>s -&gt; System.out.println(s))</span><span>;<br/></span><span>    }<br/></span><span>}</span></pre>
<p>Note that there are other flavors of <kbd>Function</kbd>, such as <kbd>Predicate</kbd> and <kbd>BiFunction</kbd>,  which  accept two arguments, not one. The <kbd>reduce()</kbd> operator accepts a <kbd>BiFunction&lt;T,T,T&gt;</kbd> where the first <kbd>T</kbd> argument is the rolling aggregation, the second <kbd>T</kbd> is the next item to put into the aggregation, and the third <kbd>T</kbd> is the result of merging the two. In this case, we use <kbd>reduce()</kbd> to add all the items using a rolling total:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{</span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {</span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>,</span><span>"Beta"</span><span>,</span><span>"Gamma"</span><span>)<br/></span><span>                .</span><span>map</span><span>(</span><span>String</span>::<span>length</span><span>)<br/></span><span>                .</span><span>reduce</span><span>((</span><span>total</span><span>,</span><span>next</span><span>) </span>-&gt; <span>total </span><span>+ </span><span>next</span><span>) </span><span>//accepts a<br/>                 BiFunction&lt;T,T,T&gt;<br/></span><span>                </span><span>.</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>s</span><span>));<br/></span><span>    }<br/></span><span>}</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functional types</h1>
                </header>
            
            <article>
                
<p>Here are all the functional types available in RxJava 2.0 at the time of writing this, and you can find them in the <kbd>io.reactivex.functions</kbd> package. You may recognize many of these functional types as being almost identical to those in Java 8 (in <kbd>java.util.function</kbd>) or Google Guava. However, they were somewhat copied in RxJava 2.0 to make them available for use in Java 6 and 7. A subtle difference is that RxJava's implementations throw checked exceptions. This eliminates a pain point from RxJava 1.0 where checked exceptions had to be handled in lambdas that yielded them.</p>
<p>The RxJava 1.0 equivalents are listed as well, but note that the single abstract method (SAM) column corresponds to the RxJava 2.0 type. RxJava 1.0 functions implement <kbd>call()</kbd> and do not support primitives. RxJava 2.0 implemented a few functional types with primitives to reduce boxing overhead where reasonably possible:</p>
<table>
<tbody>
<tr>
<td><strong>RxJava 2.0</strong></td>
<td><strong>RxJava 1.0</strong></td>
<td><strong>SAM</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td><kbd>Action</kbd></td>
<td><kbd>Action0</kbd></td>
<td><kbd>run()</kbd></td>
<td>Executes an action, much like <kbd>Runnable</kbd></td>
</tr>
<tr>
<td><kbd>Callable&lt;T&gt;</kbd></td>
<td><kbd>Func0&lt;T&gt;</kbd></td>
<td><kbd>get()</kbd></td>
<td>Returns a single item of type <kbd>T</kbd></td>
</tr>
<tr>
<td><kbd>Consumer&lt;T&gt;</kbd></td>
<td><kbd>Action1&lt;T&gt;</kbd></td>
<td><kbd>accept()</kbd></td>
<td>Performs an action on a given <kbd>T</kbd> item but returns nothing</td>
</tr>
<tr>
<td><kbd>Function&lt;T,R&gt;</kbd></td>
<td><kbd>Func1&lt;T,R&gt;</kbd></td>
<td><kbd>apply()</kbd></td>
<td>Accepts a type <kbd>T</kbd> and returns a type <kbd>R</kbd></td>
</tr>
<tr>
<td><kbd>Predicate&lt;T&gt;</kbd></td>
<td><kbd>Func1&lt;T,Boolean&gt;</kbd></td>
<td><kbd>test()</kbd></td>
<td>Accepts a <kbd>T</kbd> item and returns a primitive <kbd>boolean</kbd></td>
</tr>
<tr>
<td><kbd>BiConsumer&lt;T1,T2&gt;</kbd></td>
<td><kbd>Action2&lt;T1,T2&gt;</kbd></td>
<td><kbd>accept()</kbd></td>
<td>Performs an action on a <kbd>T1</kbd> and <kbd>T2</kbd> item but returns nothing</td>
</tr>
<tr>
<td><kbd>BiFunction&lt;T1,T2,R&gt;</kbd></td>
<td><kbd>Func2&lt;T1,T2,R&gt;</kbd></td>
<td><kbd>apply()</kbd></td>
<td>Accepts a <kbd>T1</kbd> and <kbd>T2</kbd> and returns a type <kbd>R</kbd></td>
</tr>
<tr>
<td><kbd>BiPredicate&lt;T1,T2&gt;</kbd></td>
<td><kbd>Func2&lt;T1,T2,Boolean&gt;</kbd></td>
<td><kbd>test()</kbd></td>
<td>Accepts a <kbd>T1</kbd> and <kbd>T2</kbd> and returns a primitive <kbd>boolean</kbd></td>
</tr>
<tr>
<td><kbd>Function3&lt;T1,T2,T3,R&gt;</kbd></td>
<td><kbd>Func3&lt;T1,T2,T3,R&gt;</kbd></td>
<td><kbd>apply()</kbd></td>
<td>Accepts three arguments and returns an <kbd>R</kbd></td>
</tr>
<tr>
<td><kbd>BooleanSupplier</kbd></td>
<td><kbd>Func0&lt;Boolean&gt;</kbd></td>
<td><kbd>getAsBoolean()</kbd></td>
<td>Returns a single primitive <kbd>boolean</kbd> value</td>
</tr>
<tr>
<td><kbd>LongConsumer</kbd></td>
<td><kbd>Action1&lt;Long&gt;</kbd></td>
<td><kbd>accept()</kbd></td>
<td>Performs an action on a given <kbd>Long</kbd> but returns nothing</td>
</tr>
<tr>
<td><kbd>IntFunction</kbd></td>
<td><kbd>Func1&lt;T&gt;</kbd></td>
<td><kbd>apply()</kbd></td>
<td>Accepts a primitive <kbd>int</kbd> and returns an item of type <kbd>T</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p>Not every primitive equivalent for a functional type has been implemented in RxJava 2.0. For example, currently, there is no <kbd>IntSupplier</kbd> like there is in Java 8's standard library. This is because RxJava 2.0 does not need it to implement any of its operators.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mixing object-oriented and reactive programming</h1>
                </header>
            
            <article>
                
<p>As you start applying your RxJava knowledge to real-world problems, something that may not immediately be clear is how to mix it with object-oriented programming. Leveraging multiple paradigms such as object-oriented and functional programming is becoming increasingly common. Reactive programming and object-oriented programming, especially in a Java environment, can definitely work together for the greater good.</p>
<p>Obviously, you can emit any type <kbd>T</kbd> from an <kbd>Observable</kbd> or any of the other reactive types. Emitting objects built off your own classes is one way object-oriented and reactive programming work together. We have seen a number of examples in this book. For instance, Java 8's <kbd>LocalDate</kbd> is a complex object-oriented type, but you can push it through an <kbd>Observable&lt;LocalDate&gt;</kbd>, as shown in the following code:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.time.LocalDate</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>       </span><span>Observable</span><span>&lt;</span><span>LocalDate</span><span>&gt; </span><span>dates </span><span>= </span><span>Observable</span><span>.</span><span>just</span><span>(<br/></span><span>               </span><span>LocalDate</span><span>.</span><span>of</span><span>(</span><span>2017</span><span>,</span><span>11</span><span>,</span><span>3</span><span>),<br/></span><span>               </span><span>LocalDate</span><span>.</span><span>of</span><span>(</span><span>2017</span><span>,</span><span>10</span><span>,</span><span>4</span><span>),<br/></span><span>               </span><span>LocalDate</span><span>.</span><span>of</span><span>(</span><span>2017</span><span>,</span><span>7</span><span>,</span><span>5</span><span>),<br/></span><span>               </span><span>LocalDate</span><span>.</span><span>of</span><span>(</span><span>2017</span><span>,</span><span>10</span><span>,</span><span>3</span><span>)<br/></span><span>       );<br/><br/></span><span>       // get distinct months<br/></span><span>       </span><span>dates</span><span>.</span><span>map</span><span>(</span><span>LocalDate</span>::<span>getMonth</span><span>)<br/></span><span>       .</span><span>distinct</span><span>()<br/></span><span>       .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">NOVEMBER<br/>OCTOBER<br/>JULY</pre>
<p>As we have seen in several examples throughout the book, a number of RxJava operators provide adapters to take a stateful, object-oriented item and turn it into a reactive stream. For instance, there is the <kbd>generate()</kbd> factory for <kbd>Flowable</kbd> and <kbd>Observable</kbd> to build a series of emissions off a mutable object that is updated incrementally. In the following code, we emit an infinite, consecutive sequence of Java 8 LocalDates but take only the first 60 emissions. Since <kbd>LocalDate</kbd> is immutable, we wrap the seed <kbd>LocalDate</kbd> of <kbd>2017-1-1</kbd> in an <kbd>AtomicReference</kbd> so it can be mutably replaced with each increment:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Emitter</span><span>;<br/></span><span>import </span><span>io.reactivex.</span><span>Flowable</span><span>;<br/></span><span>import </span><span>java.time.LocalDate</span><span>;<br/></span><span>import </span><span>java.util.concurrent.atomic.AtomicReference</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>       </span><span>Flowable</span><span>&lt;</span><span>LocalDate</span><span>&gt; </span><span>dates </span><span>=<br/></span><span>               </span><span>Flowable</span><span>.</span><span>generate</span><span>(() </span>-&gt; <span>new </span><span>AtomicReference</span><span>&lt;&gt;<br/></span><span>(</span><span>LocalDate</span><span>.</span><span>of</span><span>(</span><span>2017</span><span>,</span><span>1</span><span>,</span><span>1</span><span>)),<br/></span><span>               (</span><span>AtomicReference</span><span>&lt;</span><span>LocalDate</span><span>&gt; </span><span>next</span><span>, </span><span>Emitter</span><span>&lt;</span><span>LocalDate</span><span>&gt;<br/></span><span>emitter</span><span>) </span>-&gt;<br/><span>               emitter</span><span>.</span><span>onNext</span><span>(</span><span>next</span><span>.</span><span>getAndUpdate</span><span>(</span><span>dt </span>-&gt; <br/><span>dt</span><span>.</span><span>plusDays</span><span>(</span><span>1</span><span>)))<br/></span><span>                       );<br/></span><span>        <br/></span><span>       </span><span>dates</span><span>.</span><span>take</span><span>(</span><span>60</span><span>)<br/></span><span>               .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span>    }<br/></span><span>}</span></pre>
<p><span>The output is as follows:</span></p>
<p> </p>
<pre style="padding-left: 60px">2017-01-01<br/>2017-01-02<br/>2017-01-03<br/>2017-01-04<br/>2017-01-05<br/>2017-01-06<br/>...</pre>
<p>So again, RxJava has many factories and tools to adapt your object-oriented, imperative operations and make them reactive. Many of them are covered throughout this book.</p>
<p>But are there cases for a class to return an <kbd>Observable</kbd>, <kbd>Flowable</kbd>, <kbd>Single</kbd>, or <kbd>Maybe</kbd> from a property or method? Certainly! When your object has properties or methods whose results are dynamic and change over time and represent an event(s) or a sizable sequence of data, they are candidates to be returned as a reactive type.</p>
<p>Here is an abstract example: say, you have a <kbd>DroneBot</kbd> type that represents a flying drone. You could have a property called <kbd>getLocation()</kbd> that returns an <kbd>Observable&lt;Point&gt;</kbd> instead of <kbd>Point</kbd>. This way, you can get a live feed that pushes a new <kbd>Point</kbd> emission every time the drone's location changes:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span>        </span><span>DroneBot </span><span>droneBot </span><span>= </span><span>null</span><span>; </span><span>// create DroneBot<br/></span><span><br/></span><span>        </span><span>droneBot</span><span>.</span><span>getLocation</span><span>()<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>loc </span>-&gt;<br/><span>          System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Drone moved to " </span><span>+ </span><span>loc</span><span>.</span><span>x </span><span>+ </span><span>"," </span><span>+<br/></span><span>loc</span><span>.</span><span>y</span><span>));<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>interface </span><span>DroneBot </span><span>{<br/></span><span>        </span><span>int </span><span>getId</span><span>();<br/></span><span>        </span><span>String </span><span>getModel</span><span>();<br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Location</span><span>&gt; </span><span>getLocation</span><span>();<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>static final class </span><span>Location </span><span>{<br/></span><span>        </span><span>private final double </span><span>x</span><span>;<br/></span><span>        </span><span>private final double </span><span>y</span><span>;<br/></span><span>        <br/></span><span>        </span><span>Location</span><span>(</span><span>double </span><span>x</span><span>, </span><span>double </span><span>y</span><span>) {<br/></span><span>            </span><span>this</span><span>.</span><span>x </span><span>= </span><span>x</span><span>;<br/></span><span>            </span><span>this</span><span>.</span><span>y </span><span>= </span><span>y</span><span>;<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p>This <kbd>DroneBot</kbd> example shows another way in which you can mix object-oriented and reactive programming effectively. You can easily get a live feed of that drone's movements by returning an <kbd>Observable</kbd>. There are many use cases for this pattern: stock feeds, vehicle locations, weather station feeds, social networks, and so on. However, be careful if the properties are infinite. If you wanted to manage the location feeds of 100 drones, flat mapping all their infinite location feeds together into a single stream is likely not going to produce anything meaningful, apart from a noisy sequence of locations with no context. You will likely subscribe to each one separately, in a UI that populates a <kbd>Location</kbd> field in a table displaying all the drones, or you will use <kbd>Observable.combineLatest()</kbd> to emit a snapshot of the latest locations for all drones. The latter can be helpful in displaying points on a geographic map live.</p>
<p>Having reactive class properties is useful when they are finite as well. Say you have a list of warehouses, and you want to count the total inventory across all of them. Each <kbd>Warehouse</kbd> contains an <kbd>Observable&lt;ProductStock&gt;</kbd>, which returns a finite sequence of the product stocks currently available. The <kbd>getQuantity()</kbd> operator of <kbd>ProductStock</kbd> returns the quantity of that product available. We can use <kbd>reduce()</kbd> on the <kbd>getQuantity()</kbd> values to get a sum of all the available inventory, as shown here:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.util.</span><span>List</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span>        </span><span>List</span><span>&lt;</span><span>Warehouse</span><span>&gt; </span><span>warehouses </span><span>= </span><span>null</span><span>; </span><span>// get warehouses<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>fromIterable</span><span>(</span><span>warehouses</span><span>)<br/></span><span>            .</span><span>flatMap</span><span>(</span><span>Warehouse</span>::<span>getProducts</span><span>)<br/></span><span>            .</span><span>map</span><span>(</span><span>ProductStock</span>::<span>getQuantity)<br/></span><span>            .</span><span>reduce</span><span>(</span><span>0</span><span>,(</span><span>total</span><span>,</span><span>next</span><span>) </span>-&gt; <span>total </span><span>+ </span><span>next</span><span>)<br/></span><span>            .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"There are " </span><span>+ </span><span>i </span><span>+ </span><span>"<br/>            units in inventory"</span><span>));<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>interface </span><span>Warehouse </span><span>{<br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>ProductStock</span><span>&gt; </span><span>getProducts</span><span>();<br/></span><span>    }<br/></span><span>    </span><span>interface </span><span>ProductStock </span><span>{<br/></span><span>        </span><span>int </span><span>getId</span><span>();<br/></span><span>        </span><span>String </span><span>getDescription</span><span>();<br/></span><span>        </span><span>int </span><span>getQuantity();<br/></span><span>    }<br/></span><span>}</span></pre>
<p>So, finite Observables like the ones returned from <kbd>getProducts()</kbd> on <kbd>Warehouse</kbd> can be helpful too and are especially helpful for analytical tasks. But note that this particular business case decided that <kbd>getProducts()</kbd> would return the products available at that moment, not an infinite feed that broadcasts the inventory every time it changes. This was a design decision, and sometimes, representing snapshot data in a cold manner is better than a hot infinite feed. An infinite feed would have required <kbd>Observable&lt;List&lt;ProductStock&gt;&gt;</kbd> (or <kbd>Observable&lt;Observable&lt;ProductStock&gt;&gt;</kbd>) to be returned so logical snapshots are emitted. You can always add a separate <kbd>Observable</kbd> that emits notifications of changes and then uses <kbd>flatMap()</kbd> on your <kbd>getProducts()</kbd> to create a hot feed of inventory changes. This way, you create basic building blocks in your code model and then compose them together reactively to accomplish more complex tasks.</p>
<p>Note that you can have methods that return reactive types accept arguments. This is a powerful way to create an <kbd>Observable</kbd> or <kbd>Flowable</kbd> catered to a specific task. For instance, we could add a <kbd>getProductsOnDate()</kbd> method to our <kbd>warehouse</kbd> that returns an <kbd>Observable</kbd> emitting product stock from a given date, as shown in the following code:</p>
<pre style="padding-left: 60px"><span>interface </span><span>Warehouse </span><span>{<br/></span><span>    </span><span>Observable</span><span>&lt;</span><span>ProductStock</span><span>&gt; </span><span>getProducts</span><span>();<br/></span><span>    </span><span>Observable</span><span>&lt;</span><span>ProductStock</span><span>&gt; </span><span>getProductsOnDate</span><span>(</span><span>LocalDate </span><span>date</span><span>);<br/></span><span>}</span></pre>
<p>In summary, mixing reactive and object-oriented programming is not only beneficial, but also necessary. When you design your domain classes, think carefully what properties and methods should be made reactive and whether they should be cold, hot, and/or infinite. Imagine how you will be using your class and whether your candidate design will be easy or difficult to work with. Be sure to not make every property and method reactive for the sake of being reactive either. Only make it reactive when there is usability or performance benefit. For example, you should not make a <kbd>getId()</kbd> property for your domain type reactive. This ID on that class instance is unlikely to change, and it is just a single value, not a sequence of values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Materializing and Dematerializing</h1>
                </header>
            
            <article>
                
<p>Two interesting operators we did not cover are <kbd>materialize()</kbd> and <kbd>dematerialize()</kbd>. We did not cover them in <a href="de58a40c-f55f-442f-b12e-7c022e08644e.xhtml">Chapter 3</a>, <em>Basic Operators</em>, with all the other operators because it might have been confusing at that point in your learning curve. But hopefully, the point at which you are reading this, you understand the <kbd>onNext()</kbd>, <kbd>onComplete()</kbd>, and <kbd>onError()</kbd> events well enough to use an operator that abstractly packages them in a different way.</p>
<p>The <kbd>materialize()</kbd> operator will take these three events, <kbd>onNext()</kbd>, <kbd>onComplete()</kbd>, and <kbd>onError()</kbd>, and turn all of them into emissions wrapped in a <kbd>Notification&lt;T&gt;</kbd>. So if your source emits five emissions, you will get six emissions where the last one will be <kbd>onComplete()</kbd> or <kbd>onError()</kbd>. In the following code, we materialize an <kbd>Observable</kbd> emitting five strings, which are turned into six <kbd>Notification</kbd> emissions:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>,<br/></span><span>"Epsilon"</span><span>);<br/></span><span><br/></span><span>        </span><span>source</span><span>.</span><span>materialize</span><span>()<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span><br/></span><span>    }<br/></span><span>}</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">OnNextNotification[Alpha]<br/>OnNextNotification[Beta]<br/>OnNextNotification[Gamma]<br/>OnNextNotification[Delta]<br/>OnNextNotification[Epsilon]<br/>OnCompleteNotification</pre>
<p>Each <kbd>Notification</kbd> has three methods, <kbd>isOnNext()</kbd>, <kbd>isOnComplete()</kbd>, and <kbd>isOnError()</kbd>, to determine what type of event <kbd>Notification</kbd> is. There is also <kbd>getValue()</kbd>, which will return the emission value for <kbd>onNext()</kbd> but will be null for <kbd>onComplete()</kbd> or <kbd>onError()</kbd>. We leverage these methods on <kbd>Notification</kbd>, as shown in the following code, to filter out the three events to three separate Observers:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.Notification</span><span>;<br/></span><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Notification</span><span>&lt;</span><span>String</span><span>&gt;&gt; </span><span>source </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>,<br/></span><span>"Epsilon"</span><span>)<br/></span><span>                        .</span><span>materialize</span><span>()<br/></span><span>                        .</span><span>publish</span><span>()<br/></span><span>                        .</span><span>autoConnect</span><span>(</span><span>3</span><span>);<br/></span><span><br/></span><span>        </span><span>source</span><span>.</span><span>filter</span><span>(</span><span>Notification</span>::<span>isOnNext</span><span>)<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>n </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"onNext=" </span><span>+<br/></span><span>n</span><span>.</span><span>getValue</span><span>()));<br/></span><span><br/></span><span>        </span><span>source</span><span>.</span><span>filter</span><span>(</span><span>Notification</span>::<span>isOnComplete</span><span>)<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>n </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"onComplete"</span><span>));<br/></span><span><br/></span><span>        </span><span>source</span><span>.</span><span>filter</span><span>(</span><span>Notification</span>::<span>isOnError</span><span>)<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>n </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"onError"</span><span>));<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">onNext=Alpha<br/>onNext=Beta<br/>onNext=Gamma<br/>onNext=Delta<br/>onNext=Epsilon<br/>onComplete</pre>
<p>You can also use <kbd>dematerialize()</kbd> to turn an <kbd>Observable</kbd> or <kbd>Flowable</kbd> emitting notifications back into a normal <kbd>Observable</kbd> or <kbd>Flowable</kbd>. It will produce an error if any emissions are not <kbd>Notification</kbd>. Unfortunately, at compile time, Java cannot enforce operators being applied to Observables/Flowables emitting specific types such as Kotlin:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>,<br/></span><span>"Epsilon"</span><span>)<br/></span><span>                .</span><span>materialize</span><span>()<br/></span><span>                .</span><span>doOnNext</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>)<br/></span><span>                .</span><span>dematerialize</span><span>()<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">OnNextNotification[Alpha]<br/>Alpha<br/>OnNextNotification[Beta]<br/>Beta<br/>OnNextNotification[Gamma]<br/>Gamma<br/>OnNextNotification[Delta]<br/>Delta<br/>OnNextNotification[Epsilon]<br/>Epsilon<br/>OnCompleteNotification</pre>
<p>So what exactly would you use <kbd>materialize()</kbd> and <kbd>dematerialize()</kbd> for? You may not use them often, which is another reason why they are covered here in the appendix. But they can be handy in composing more complex operators with transformers and stretching transformers to do more without creating low-level operators from scratch. For instance, RxJava2-Extras uses <kbd>materialize()</kbd> for a number of its operators, including <kbd>collectWhile()</kbd>. By treating <kbd>onComplete()</kbd> an emission itself, <kbd>collectWhile()</kbd> can map it to push the collection buffer downstream and start the next buffer.</p>
<p>Otherwise, you will likely not use it often. But it is good to be aware that it exists if you need it to build more complex transformers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding Schedulers</h1>
                </header>
            
            <article>
                
<p>You will likely not use schedulers like this in isolation as we are about to do in this section. You are more likely to use them with <kbd>observeOn()</kbd> and <kbd>subscribeOn()</kbd>. But here is how they work in isolation outside of an Rx context.</p>
<p>A Scheduler is RxJava's abstraction for pooling threads and scheduling tasks to be executed by them. These tasks may be executed immediately, delayed, or repeated periodically depending on which of its execution methods are called. These execution methods are <kbd>scheduleDirect()</kbd> and <kbd>schedulePeriodicallyDirect()</kbd>, which have a few overloads. Below, we use the computation Scheduler to execute an immediate task, a delayed task, and a repeated task as shown below:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Scheduler</span><span>;<br/></span><span>import </span><span>io.reactivex.schedulers.Schedulers</span><span>;<br/></span><span><br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Scheduler</span> <span>scheduler </span><span>= </span><span>Schedulers</span><span>.</span><span>computation</span><span>();<br/></span><span><br/></span><span>        </span><span>//run task now<br/></span><span>        </span><span>scheduler</span><span>.</span><span>scheduleDirect</span><span>(() </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Now!"</span><span>));<br/></span><span><br/></span><span>        </span><span>//delay task by 1 second<br/></span><span>        </span><span>scheduler</span><span>.</span><span>scheduleDirect</span><span>(() </span>-&gt; <br/><span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Delayed!"</span><span>), </span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>);<br/></span><span><br/></span><span>        </span><span>//repeat task every second<br/></span><span>        </span><span>scheduler</span><span>.</span><span>schedulePeriodicallyDirect</span><span>(() </span>-&gt; <br/><span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Repeat!"</span><span>), </span><span>0</span><span>, </span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>);<br/></span><span><br/></span><span>        </span><span>//keep alive for 5 seconds<br/></span><span>        </span><span>sleep</span><span>(</span><span>5000</span><span>);<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p>Your output will likely be the following:</p>
<pre style="padding-left: 60px">Now!<br/>Repeat!<br/>Delayed!<br/>Repeat!<br/>Repeat!<br/>Repeat!<br/>Repeat!<br/>Repeat!</pre>
<p>The <kbd>scheduleDirect()</kbd> will only execute a one-time task, and accepts optional overloads to specify a time delay. <kbd>schedulePeriodicallyDirect()</kbd> will repeat infinitely. Interestingly, all of these methods return a <kbd>Disposable</kbd> to allow cancellation of the task it is executing or waiting to execute.</p>
<p>These three methods will automatically pass tasks to a <kbd>Worker</kbd>, which is an abstraction that wraps around a single thread that sequentially does work given to it. You can actually call the Scheduler's <kbd>createWorker()</kbd> method to explicitly get a Worker and delegate tasks to it directly. Its <kbd>schedule()</kbd> and <kbd>schedulePeriodically()</kbd> methods operate just like Scheduler's <kbd>scheduleDirect()</kbd> and <kbd>schedulePeriodicallyDirect()</kbd> respectively (and also return disposables), but they are executed by the specified worker. When you are done with a worker, you should dispose it so it can be discarded or returned to the <kbd>Scheduler</kbd>. Here is an equivalent of our earlier example using a <kbd>Worker</kbd>:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Scheduler</span><span>;<br/></span><span>import </span><span>io.reactivex.schedulers.Schedulers</span><span>;<br/></span><span><br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Scheduler</span> <span>scheduler </span><span>= </span><span>Schedulers</span><span>.</span><span>computation</span><span>();<br/></span><span>        </span><span>Scheduler</span><span>.</span><span>Worker </span><span>worker </span><span>= </span><span>scheduler</span><span>.</span><span>createWorker</span><span>();<br/></span><span><br/></span><span>        </span><span>//run task now<br/></span><span>        </span><span>worker</span><span>.</span><span>schedule</span><span>(() </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Now!"</span><span>));<br/></span><span><br/></span><span>        </span><span>//delay task by 1 second<br/></span><span>        </span><span>worker</span><span>.</span><span>schedule</span><span>(() </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Delayed!"</span><span>), </span><span>1</span><span>,<br/></span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>);<br/></span><span><br/></span><span>        </span><span>//repeat task every second<br/></span><span>        </span><span>worker</span><span>.</span><span>schedulePeriodically</span><span>(() </span>-&gt;<br/><span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Repeat!"</span><span>), </span><span>0</span><span>, </span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>);<br/></span><span><br/></span><span>        </span><span>//keep alive for 5 seconds, then dispose Worker<br/></span><span>        </span><span>sleep</span><span>(</span><span>5000</span><span>);<br/></span><span>        </span><span>worker</span><span>.</span><span>dispose</span><span>();<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p>This is the output you may get:</p>
<pre style="padding-left: 60px">Now!<br/>Repeat!<br/>Repeat!<br/>Delayed!<br/>Repeat!<br/>Repeat!<br/>Repeat!<br/>Repeat!</pre>
<p>Of course, every Scheduler is implemented differently . A Scheduler may use one thread or several threads. It may cache and reuse threads, or not reuse them at all. It may use an Android thread or a JavaFX thread (as we have seen with RxAndroid and RxJavaFX in this book). But that is essentially how schedulers work, and you can perhaps see why they are useful in implemeting RxJava operators.</p>
<p> </p>
<p> </p>
<p> </p>


            </article>

            
        </section>
    </body></html>