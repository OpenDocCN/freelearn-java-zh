- en: Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to profile Java applications in order
    to troubleshoot performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to develop JEE microservices using Eclipse.
    We will also learn how to deploy microservices in Docker containers. We will develop
    simple microservices for our *Course Management* use case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to microservices and Eclipse MicroProfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing JEE microservices using the WildFly Swarm and Spring Boot frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Docker and Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying microservices in Docker containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a microservice?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A microservice is a small application designed to perform a specific business
    task well. Microservices are typically implemented as RESTful web services. The
    following are some of the characteristics of a microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: Smaller in size (compared to monolithic applications), and focuses on a single
    business task/module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has its own database, in contrast to a monolithic application that has one database
    for all business functionalities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is typically a standalone application, with a web container bundled into it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A large business application can be built by assembling smaller microservices.
    Compared to a large monolithic application, a microservice architecture provides
    the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: They are easy to deploy. In a monolithic application, deployment can be quite
    cumbersome because of the complexity of the application. Microservices are small
    and can be easily deployed on servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices are loosely coupled, so changes in one can be isolated from other
    services in an application. Also, having a separate database for each service
    can further insulate the main application and other services from changes made
    in the schema of the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand the contrast between monolithic application architecture and
    microservice architecture, let’s see an example. Throughout this book, we have
    been following the *Course Management* example. Let’s say this module is part
    of a larger **University Management System**, which has many more modules. A monolithic
    architecture for this application can be viewed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00224.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1: Monolithic application architecture
  prefs: []
  type: TYPE_NORMAL
- en: We have one large application, the **University Management System**, with multiple
    modules and a single database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same application can be architected using microservices as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00225.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: Microservice application architecture'
  prefs: []
  type: TYPE_NORMAL
- en: In the microservice architecture, the **University Management System** is composed
    of many microservices, each with its own database.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse MicroProfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices can be built with the current JEE specification (JEE 8). However,
    there are certain specifications within JEE that are more important for developing
    microservices, such as JAX-RS (for RESTful Web Services) and JSON-P (for processing
    JSON data). So, a group of organizations has come together to create specifications
    for developing and running microservices, which are categorized as MicroProfile.
    Many of the specifications under MicroProfile are already part of the JEE specification
    (such as JAX-RS and JSON-P), but some are new specifications, such as for configuring
    and monitoring microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The group has come up with two profiles so far. Each MicroProfile-compliant
    implementation is expected to implement each specification in the supported profile.
    This ensures that a microservice created with a particular profile runs on all
    Microprofile implementations supporting that profile. At the time of writing this
    chapter, the group has come up with two profiles. Here is the list of MicroProfiles
    and specifications that they include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'MicroProfile 1.0 (released in Sep 2016):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CDI 1.2
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON-P 1.0
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: JAX-RS 2.0
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MicroProfile 1.1 (released in August 2017):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Config 1.0
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: CDI 1.2
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON-P 1.0
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: JAX-RS 2.0
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: MicroProfile 2.0 is expected to be released in June 2018, and it will include
    updates to some of the specifications as per JEE 8\. Some of the implementations
    of MicroProfiles are WildFly Swarm ([http://wildfly-swarm.io/](http://wildfly-swarm.io/)),
    WebSphere Liberty ([https://developer.ibm.com/wasdev/websphere-liberty/](https://developer.ibm.com/wasdev/websphere-liberty/)),
    Payara ([http://www.payara.fish/](http://www.payara.fish/)), and Apache TomEE
    ([http://tomee.apache.org/](http://tomee.apache.org/)). Visit the official website
    for MicroProfiles at [https://microprofile.io/](https://microprofile.io/) for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we will see how to implement a microservice for our *Course
    Management* use case using two solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a MicroProfile implementation (WildFly Swarm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Spring Boot, which is not part of MicroProfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Later, we will see how to deploy microservices in Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: To follow the code examples in this chapter, you need to be familiar with JPA
    and REST APIs. Refer to [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*, for JPA concepts and [Chapter 9](part0176.html#57R300-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating Web Services*, for RESTful web services.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a database for a microservice project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to implement a microservice to get a list of courses.  We will
    use the same MySQL database, `course_management`, that we have been using in this
    book. Refer to *Installing MySQL* in [Chapter 1](part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Introducing JEE and Eclipse*, if you need information on how to install and set
    up MySQL. If you haven’t already created the `course_management` schema, then
    refer to the *Creating database schema* section in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*. At this point, we will assume that the MySQL
    database is running and the `course_management` schema with the `Course`, `Course_Student`,
    `Student`, and `Teacher` tables exists.
  prefs: []
  type: TYPE_NORMAL
- en: We will use JPA to access this database. See the *Creating a database application
    using JPA* section in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*, if you are not familiar with JPA. We are
    going to use EclipseLink as the JPA provider.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing microservices using WildFly Swarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WildFly Swarm ( [http://wildfly-swarm.io/](http://wildfly-swarm.io/) ) is a
    MicroProfile implementation from Red Hat. It allows you to assemble an application
    container for running microservices with just the specifications you need.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a WildFly Swarm project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s use WildFly Swarm Project Generator at [http://wildfly-swarm.io/generator/](http://wildfly-swarm.io/generator/)
    to select the specifications we want to include in our application and to create
    the starter project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00226.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: WildFly Swarm Project Generator'
  prefs: []
  type: TYPE_NORMAL
- en: Enter Group ID and Artifact ID as shown in the previous screenshot. In the Dependencies
    textbox, start typing features such as JPA or JAX-RS and then select them from the
    auto-suggested options. Make sure JPA EclipseLink , JAX-RS, and CDI are selected
    as dependencies. If you want to see all available dependencies and select from
    that list, then click the View all available dependencies link.
  prefs: []
  type: TYPE_NORMAL
- en: Click the Generate Project button to create the project and download the ZIP
    file. This is a Maven project. Unzip the file in a folder and import the project
    as a Maven project in Eclipse (by selecting the menu option File | Import and
    then selecting Existing Maven Projects in the Maven category).
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the Eclipse Project Explorer and select Run As | Maven Build.
    In the configuration window, type `wildfly-swarm:run` in the Goals field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00227.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: Maven Build Configuration to create a WildFly Swarm application'
  prefs: []
  type: TYPE_NORMAL
- en: Click Run. Maven will download and install the dependencies and then run the
    application (you will see a Wildfly Swarm is Ready message in the console when
    the application is ready). Open `http://localhost:8080/hello` to test the default
    endpoint created by the application generator. You should see the `hello` message.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look into the target folder of the project, you will see `demo-swarm.jar`
    and `demo.war`. When we executed the wildfly-swarm:run goal, Maven starts a JBoss
    container and deploys the WAR file. The microservice can also be run by executing
    the single JAR file, `demo-swarm.jar`. This JAR contains all the packages, including
    the application server to run the microservice. Simply run this from the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To change the name of the output file from demo to, say, `coursemanagement`,
    change the name in `pom.xml` in `<filename>` under the `<build>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let’s add a dependency for MySQL in the project. Refer to *Figure 4.11*
    in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    JEE Database Applications*, for adding a Maven dependency for the MySQL JDBC driver,
    or simply add the following dependency to `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert the project to a JPA project so that we can use the JPA tooling provided
    by Eclipse. Right-click on the project in the Project Explorer and select the
    Configure | Convert to JPA Project option. Make sure the following Project Facets
    are selected, along with the default facets:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Web Module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JAX-RS (RESTful web services)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click the Next button (refer to *Figure 4.20* <q class="calibre207">Add JPA
    facet to the project</q> of [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*) and configure the JPA facet as shown in
    <q class="calibre207">Figure 4.21</q>. Click Finish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now configure the JDBC connection in `persistence.xml`. Follow steps
    7 through 9 in the *Converting project into a JPA project* section in [Chapter
    4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating JEE Database
    Applications*. Your `persistence.xml` should now have the following persistence
    unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the previous XML file, we are specifying the `org.eclipse.persistence.jpa.PersistenceProvider`
    class as our JPA provider and then setting properties for connecting to the MySQL
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Next, create folders named `resources/META-INF` under `src/main` and copy `persistence.xml`
    into the `src/main/resources` folder. If Eclipse displays errors in JPA configuration,
    right-click on the project name in Project Explorer and select Maven | Update
    Project. The reason for doing this is that Maven expects files that you want to
    copy to the `classes` folder to be in the `src/main/resources` folder. We need
    to have `META-INF/persistence.xml` in the `classes` folder so that the JPA provider
    can load it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a course entity bean and a JPA factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are not familiar with JPA, refer to the *JPA concepts* section in [Chapter
    4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating JEE Database
    Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now create `Course.java` in the `packt.book.jeeeclipse.wildflyswarm.coursemanagement.rest`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple JPA entity class with appropriate annotations. We need to tell
    JPA that this is a managed bean. To do this, open `persistence.xml` and in the
    General tab of the editor, click the Add button in the Managed Classes section.
    Add the `Course` entity class to the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a JPA `EntityManagerFactory` class called `CourseManagementJPAFactory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this class, we are creating an instance of `EntityManager` from `EntityManagerFactory`.
    Note that name passed to the `Persistence.createEntityManagerFactory` method is the
    same as the name we specified in `persistence.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will create the main class, called `CourseManagementEndpoint`,
    and also the REST endpoint function to handle the `/course_management/courses`
    URL path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If the application is not already running, right-click on the project in Project
    Explorer and select Run As | Maven build. Open `http://localhost:8080/course_managment/courses` in
    the browser and you should see a JSON list of courses in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the default server port from `8080` to any other port number, say
    `8000`, set the `swarm.http.port=8000` environment variable. You can set this
    in the run configuration for the project (select Run | Run Configurations from
    the main menu and look for the configuration for your project in the Maven Build
    section):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00228.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.5: Set the environment variable in the run configuration'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Environment tab and add the environment variable and its value.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing microservices using Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A microservice can be implemented in many ways; in the previous section, we
    saw one way to implement it, using WildFly Swarm, which is a MicroProfile implementation.
    In this section, we will see how to implement a microservice using Spring Boot,
    which is not a MicroProfile implementation but is a popular framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Boot ([https://spring.io/projects/spring-boot/](http://spring.io/projects/spring-boot))
    is a framework to create standalone Spring applications. Refer to [Chapter 8](part0154.html#4IRMK0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    Web Applications with Spring MVC*, for more information on Spring and specific
    information on the Spring MVC framework. Similar to the WildFly Swarm Project
    Generator, Spring Boot also has a web page for creating a starter application
    for Spring Boot, where you can select the features/specifications of JEE that
    you want to be included in the application. Go to [https://start.spring.io/](https://start.spring.io/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00229.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.6: Spring Boot project generator'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the Web, JPA, and Jersey(JAX-RS) dependencies. Download the starter
    project and unzip it in a folder. We won’t be able to run the application yet.
    Since we have selected JPA as one of the dependencies of the application, Spring
    Boot expects us to configure database connection properties in the application.properties
    file, located in `src/main/resources`. Add the following properties to `application.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can run the server now, but we haven’t defined any REST endpoints yet. So,
    let’s do that. We will use the `Course` entity bean that we created for the WildFly
    Swarm project in the previous section. So, copy the same file to this project,
    in the `packt.book.jeeeclipse.springboot.coursemanagementspring` package. See the
    *Create course entity bean and JPA factory* section for listings of the `Course`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring provides a utility interface named `CrudRepository` that tells the framework
    to create CRUD boilerplate code for the given entity/class. We will create a repository
    interface that extends `CrudRepository` and create a CRUD implementation for the
    `Course` class. See [https://docs.spring.io/spring-data/data-commons/docs/1.6.1.RELEASE/reference/html/repositories.html](https://docs.spring.io/spring-data/data-commons/docs/1.6.1.RELEASE/reference/html/repositories.html)
    for more information on `CrudRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is just a marker interface to tell Spring Framework to create CRUD code
    for the `Course` class/entity that has the primary key of type `Long`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Spring, a REST endpoint is created by creating a controller, actually annotating
    the class with `@RestController`. See [https://spring.io/guides/gs/rest-service/](https://spring.io/guides/gs/rest-service/) for
    information on creating RESTful web services using Spring. So, let’s create the
    `CourseController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this class, we are mapping the GET HTTP request to the `/course_management/courses` URL
    to the `getCourses` method.
  prefs: []
  type: TYPE_NORMAL
- en: An instance of `CourseRepository` is auto injected into this class using the
    `@Autowired` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to run the application. Create a run configuration for this
    application by right-clicking on the project in Project Explorer and selecting
    Run As **|** Maven Build. Then, type `spring-boot:run` in the Goals field ( see
    *Figure 12.4* for reference) and click the Run button. Once the server is ready,
    browse to `http://localhost:8080/course_management/courses` and you should see
    JSON output (for `Courses`).
  prefs: []
  type: TYPE_NORMAL
- en: To change the default server port from `8080` to any other port number, say
    `8000`, set the environment variable `server.port=8000`. See *Figure 12.5* for
    reference.
  prefs: []
  type: TYPE_NORMAL
- en: See [https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/)
    for a complete reference to Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying microservices in a Docker container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to deploy a microservice in a Docker container,
    but let’s first understand what Docker is.
  prefs: []
  type: TYPE_NORMAL
- en: What is Docker?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is container management software. In general, software containers allow
    you to package your application with all dependencies, including the OS, in one
    package. Your application runs in isolation in the container in which it is packaged.
    This reduces discrepancies in environments when developing, testing, and deploying.
    Since all the dependencies for your application are already resolved and packaged
    with it, you generally do not run into situations where your application ran fine
    in a dev/test environment, but failed in production—maybe because some of the
    dependencies were not met. For example, even if you have developed and tested
    in the same OS version, in production some of the dependencies may fail because
    of OS updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker is the most popular container management technology currently. Docker
    makes it easy to package and run your application in a container. It is often
    compared with virtual machines. The following diagram shows the difference between
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00230.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.7: Difference between Virtual Machines Technology and Docker Container
    Technology'
  prefs: []
  type: TYPE_NORMAL
- en: VMs are guest operating systems in *Figure 12.7*, running on top of hypervisor
    software (a hypervisor isolates the guest OS from the host OS and manages them).
    Docker containers run on top of Docker Engine and a shared OS kernel (for example,
    Linux or Windows). Docker containers are not full-fledged OSes; they are processes
    with isolated resources such as filesystems and networks.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to VMs, Docker containers are easy to package and deploy, and they
    start much more quickly (because they are just processes and not complete OSes).
    Docker containers also take up a lot fewer resources than VMs. So, you can run
    more Docker containers in the same environment than VMs.
  prefs: []
  type: TYPE_NORMAL
- en: See this official Docker link, [https://www.docker.com/what-docker](https://www.docker.com/what-docker),
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: How to get Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Download Docker for Mac from here: [https://docs.docker.com/docker-for-mac/install/](https://docs.docker.com/docker-for-mac/install/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download Docker for Windows from here: [https://docs.docker.com/docker-for-windows/install/](https://docs.docker.com/docker-for-windows/install/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download Docker for Linux: [https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/)'
  prefs: []
  type: TYPE_NORMAL
- en: How to use Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will briefly see how to use Docker. To create a new container,
    you typically create a Dockerfile. In this file, you need to specify the base
    image to extend your container from, for example, the base image for Ubuntu or
    Debian. You can think of Docker images as templates, and containers as running
    instances of those templates. Docker Hub, [https://hub.docker.com/](https://hub.docker.com/),
    is a repository of Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You create a Dockerfile to create an image for your own container. You can
    specify the base image for your container, commands to execute when setting up
    the container, ports to expose, files to copy to the container, and the entry
    point (the program to run when the container starts). Here are some of the frequently
    used instructions in a Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM`: Specify the base image for your Docker container, for example, `FROM
    Ubuntu`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADD`: Add file(s) from the host machine to the Docker container. For example,
    to copy the `setup.sh` file from the directory from where Docker commands are
    run to a container. For example, `ADD ./setup.sh /setup.sh`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN`: Runs a command in the container. For example, to make the `setup.sh`
    file executable after copying to a container. Example, `RUN chmod +x /setup.sh`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENTRYPOINT`: Docker containers are meant to have one main application, and
    when it stops running, the container stops. That main program is specified using the
    `ENTRYPOINT` directive. For example, to run the Apache server after it is installed
    (possibly using the `RUN` command) `ENTRYPOINT apachectl start`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMD`**:** A command to execute. In the absence of `ENTRYPOINT`, `CMD` specifies
    the main application in the container. If specified along with `ENTRYPOINT`, then the
    value of `CMD` is passed as arguments to the application specified in `ENTRYPOINT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPOSE`:  Tells Docker that the container listens on specified port(s) at
    runtime. For example, if the Apache server is listening on port `80` in a container, then
    you would specify `EXPOSE 80`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENV`: Sets environment variable(s) in a container. An example is `ENV PATH=/some/path:$PATH`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VOLUME`: Creates a mountable point for a volume. A volume is just like a folder
    or virtual folder. From within the container, it can be accessed as any other
    folder. Volumes can be used to share folders across different running containers.
    One container can also import volumes from another container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a list of commonly used Docker instructions in a Dockerfile. See the
    Dockerfile reference at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
    for all instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Docker commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a short list of Docker commands for operations such as start, stop,
    and delete:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Command** |'
  prefs: []
  type: TYPE_TB
- en: '| Run a container from an image | The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to run a container from an Ubuntu image, open a Terminal and execute
    the bash shell with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Create an image from a Dockerfile | The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to create `my_image` from a Dockerfile in the current folder,
    run the following Docker command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| List currently running containers |'
  prefs: []
  type: TYPE_TB
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| List all containers, including stopped containers |'
  prefs: []
  type: TYPE_TB
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Start (a stopped) container | The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `-i` option keeps `stdin` (standard input) open and allows you to run commands
    in the container. To identify the container, you can either use the container
    name or ID. |
  prefs: []
  type: TYPE_NORMAL
- en: '| Remove a container |'
  prefs: []
  type: TYPE_TB
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Execute command in running container | The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to open a bash shell in a running container called `my_container`,
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Listing all images |'
  prefs: []
  type: TYPE_TB
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Deleting images | Image IDs are space separated in this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Get information about running container |'
  prefs: []
  type: TYPE_TB
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: See [https://docs.docker.com/engine/reference/commandline/docker/](https://docs.docker.com/engine/reference/commandline/docker/)
    for the complete reference.
  prefs: []
  type: TYPE_NORMAL
- en: That was a short introduction to Docker. There are many more details of Docker
    that are out of the scope of this book. Please refer to the links provided and
    also the Docker website ([https://www.docker.com/](https://www.docker.com/)) for
    more information. We will now focus on Eclipse tooling for Docker and deploying
    microservices in Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Docker Tooling in Eclipse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a Docker plugin for Eclipse, using which you can perform many of the
    mentioned Docker tasks from within Eclipse. To install the plugin in Eclipse,
    from the menu, select Help | Eclipse Marketplace.... Search for `Eclipse Docker
    Tooling` and install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00231.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.8: Install Eclipse Docker Tooling from Eclipse Marketplace'
  prefs: []
  type: TYPE_NORMAL
- en: Switch to the Docker Tooling perspective (either click on the Open Perspective
    toolbar button at the top-right of the editor window, or select from the Window
    | Perspective | Open Perspective | Other menu).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now add a Docker connection in Eclipse (make sure the Docker daemon
    is running):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00232.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.9: Add Docker connection'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Add Connection toolbar button in Docker Explorer and create a
    connection, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00233.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.10: Add connection dialog box'
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, you need to select TCP Connection and specify the URI where Docker
    daemon is listening. You can find the URI in Docker settings, in General tab.
    Make sure Expose daemon on... option is selected. Copy the TCP URI from this option
    and paste it in TCP Connection | URI textbox in the dialog box shown in *Fig.
    12.10*.
  prefs: []
  type: TYPE_NORMAL
- en: Once the connection is added successfully, you will see lists of existing containers
    and images, if any, on your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Docker network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to deploy two servers in two separate Docker containers in the
    same machine: a MySQL DB server and an application server to run our microservice.
    The application server will need to know about the DB server to access it. The
    recommended way to allow two Docker containers to access each other is by deploying
    them in the same Docker network. A complete discussion of Docker networks is out
    of scope of this book, so readers are encouraged to read about Docker networks
    at [https://docs.docker.com/engine/userguide/networking](https://docs.docker.com/engine/userguide/networking).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing that the two containers we are going to create shortly need to run
    in the same Docker network, let’s create a Docker network by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this command, `coursemanagment` is the name of the network we are creating.
  prefs: []
  type: TYPE_NORMAL
- en: Creating MySQL container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been using a MySQL server installed on the host machine so far in this
    book. We will now see how to create a Docker container with MySQL. If you are
    running an instance of MySQL on your host OS (the OS in which Docker is running),
    then stop the instance or configure MySQL to run on a different port than `3306`
    in the Docker container (we will see how to do this shortly).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the official MySQL Docker image; see [https://hub.docker.com/_/mysql/](https://hub.docker.com/_/mysql/).
    Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace `your_password` with the root password you want to set. This command
    will install the latest version of MySQL. The `-d` option runs the container in
    detached/background mode. Also note that the container is created in the `coursemanagement`
    network that we created in the previous section. If you want to use a specific
    version of MySQL, then tag that version; for example, to install MySQL Version
    5.5.58, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`MySQL` will run on port `3306` in the container, and the container exposes
    the service at the same port on the host machine. To expose this service at a
    different port on the host machine, say port `3305`, use the `–p` or `--publish`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `-p` option in this command maps port `3306` in the Docker container to
    port `3305` on the host machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the command is executed successfully, you can verify that the container
    is running by executing the `docker ps` command. The container will also be visible
    in Docker Explorer in Eclipse. Switch to the Docker Tooling perspective in Eclipse
    and expand the Containers group under the Local connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00234.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.11: Docker Explorer listing containers and images'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the container name to show menu options for different actions
    on the container, such as Start, Stop, and Restart.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Execute Shell option is very useful for opening a shell in the container
    and executing commands. For example, to execute MySQL commands from within the
    container, select the Execute Shell option and execute the `mysql -u root –p`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00235.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.12: The Execute Shell in a Docker container'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming you have mapped port `3306` from the container to the same port on
    the host machine, you can connect to the instance of MySQL in the container from
    the host machine as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you specify the `-h` or `--host` option, or it will try to connect
    using the local `.sock` file and that will fail. You can also connect to this
    MySQL instance from MySQL Workbench.
  prefs: []
  type: TYPE_NORMAL
- en: Next, create the `course_management` schema in the database. See the *Setting
    up Database* section of this chapter for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not want to type long Docker commands and remember options, you can
    use Docker Explorer’s user interface to create containers. We used the `run` command
    of Docker to run a MySQL container using the `mysql` image. The command first
    checks whether the required image is already downloaded on the local machine,
    and if not, it downloads it. Docker images can also be downloaded explicitly using the `docker
    pull` command. For example, we could have first downloaded the `mysql` image by
    executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the image is downloaded, it will be displayed in Docker Explorer. Right-click
    the image and select Run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00236.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.13: Create Docker container from image in Docker Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: Follow the wizard to create a container. You can use this option to create multiple
    instances from the same image, for example, to run multiple MySQL containers.
  prefs: []
  type: TYPE_NORMAL
- en: The last page in this wizard lets you specify a network for the container.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying microservices in a Docker container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now deploy the `CourseManagement` microservice that we created earlier
    in this chapter (the one using WildFly Swarm) in a Docker container. You can either
    copy the project and paste it in Eclipse Project Explorer with a different name,
    or use the same project. The example code has a project called `coursemanagement-docker`
    for this section.
  prefs: []
  type: TYPE_NORMAL
- en: We need to make one change in `persistence.xml`. Recall that in our earlier
    example, the JDBC URL in this file referred to `127.0.0.1` or localhost. This
    worked then because both the application and the database were running in the
    same environment. But now our database and application are going to run in separate
    Docker containers, with isolated runtime environments. Therefore, we can no longer
    access the database using the localhost URL in the microservice. So, how do we
    access a database running in a separate container? The answer is using the container
    name, if both containers are running in the same Docker network mode. We configured
    the container for the DB to run in the `coursemanagment` network, and later in
    this section we are going to do the same for the microservice container. So, we
    will need to change the JDBC URL in `persistence.xml` to refer to name of the
    container running our database server, which is `course-management-mysql`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `persistence.xml` and replace IP `127.0.0.1` in the JDBC URL with `course-management-mysql`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a file named Dockerfile in root of the project with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be using this Dockerfile to create the image for our microservice container.
    Let’s understand each of the instructions in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM openjdk:8`: The base image for this container is OpenJDK, Version 8.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENV swarm.http.port 8080`: We are setting the `swarm.http.port` environment
    variable in the container. This is really not necessary for this example, because
    the WildFly Swarm server runs on port `8080` by default. Change the port number
    if you want to run the server on a different port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN mkdir microservices`: We are creating a folder named `microservices` in
    the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COPY ./target/coursemanagement-swarm.jar ./microservices`: We are `copying
    coursemanagement-swarm.jar` from the target folder in our project to the `microservices`
    folder in the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPOSE 8080`:  We ask Docker Engine to expose port `8080` from the container.
    Our application server listens for requests on port `8080` in the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENTRYPOINT java -jar -Djava.net.preferIPv4Stack=true ./microservices/coursemanagement-swarm.jar`: Finally,
    we specify the main application to execute in the container, which is running
    the standalone microservice application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to build the application to create a single JAR file that we will run
    in the Docker container. If you try to build the application by running the Maven
    goal `wildfly-swarm:run` (we did that to run the application earlier), it is going
    to fail because it will also try to run the application. This is not going to
    work because we modified the JDBC URL in `persistence.xml` with the name of the
    DB container. So, run the Maven goal to only package the application, without
    running tests. Right-click on the project in Project Explorer and select Run As
    | Maven Build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00237.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.14: Eclipse run configuration to package the Docker-microservice
    project'
  prefs: []
  type: TYPE_NORMAL
- en: Enter `package` in the Goals field. Select the Skip Tests option and click Run
    to create the application JAR file in the target folder.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now create the Docker image from the Dockerfile we created. Right-click
    on the file in Project Explorer and select the Run As | Docker Image Build menu
    option.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00238.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.15: Building a Docker image from a Dockerfile'
  prefs: []
  type: TYPE_NORMAL
- en: This will create a Docker image named coursemanagement-microservice and tag
    it as the 1.0 version. Switch to the Docker Tooling perspective in Eclipse and
    you should see this image listed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create an instance of this image, that is, create a container
    from this image that will actually run our microservice. Right-click on the image
    and select Run...:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00239.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.16: Creating a container from an image'
  prefs: []
  type: TYPE_NORMAL
- en: 'This opens a wizard to configure the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00240.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.17: Configuring a Docker container'
  prefs: []
  type: TYPE_NORMAL
- en: Specify a name for the container in the first page of the wizard. Leave Endpoint
    and Command empty; the image is already created with the `ENTRYPOINT` that we
    specified in the Dockerfile. You can override that in this page, but we are not
    going to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the Publish all exposed ports to random ports on the host interfaces
    option is unchecked. We want to publish port `8080` from the container as the
    same port number to the host. Click Next. Leave the default options on the second
    page and click Next again.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00241.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.18: Setting network mode for a Docker container'
  prefs: []
  type: TYPE_NORMAL
- en: The last page (see *Figure 12.18*) allows you to specify a network for the container.
    Here, we are going to specify the network we created earlier, `coursemanagement`.
    Recall that we also created a MySQL container with the same network, so that microservice
    container can access the MySQL container with the container name.
  prefs: []
  type: TYPE_NORMAL
- en: Once the application starts in the microservice container, browse to `http://localhost:8080/course_management/courses`
    and you should see list of courses in the database.
  prefs: []
  type: TYPE_NORMAL
- en: The process to deploy the microservice we created using Spring Boot earlier
    is also similar to the one we saw in this section. One main difference is that
    in the Spring Boot project, you need to update the JDBC URL in `application.properties`,
    instead of the `persistence.xml` that we modified in this section. For your reference,
    the sample code has a project named `coursemanagementspring-docker`.
  prefs: []
  type: TYPE_NORMAL
- en: Running containers using Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen in the preceding sections how to create Docker containers separately
    by running command-line Docker commands (or from Eclipse plugins). If you want
    to run multiple containers on a host machine, you should consider using Docker
    Compose. It allows you to configure multiple Docker containers in one file and
    also specify dependencies between them. A `docker-compose` command reads configuration/instructions
    from `docker-compose.yml`, and creates and runs containers. The `.yml` file requires
    the version number of `docker-compose` at the top, followed by a services section,
    which lists container definitions—specifying image or Dockerfile location, environment
    variables to be set in the container, ports to be exposed and mapped to the host
    OS, and many other configurations. See [https://docs.docker.com/compose/overview/](https://docs.docker.com/compose/overview/)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will use `docker-compose` to run MySQL and our webservice
    containers together. In the later chapter on deploying JEE applications in the
    cloud, we will use this configuration for deployment. First, install `docker-compose`
    from [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/).
  prefs: []
  type: TYPE_NORMAL
- en: Create a new General Eclipse project (File | New | Project and then General
    | Project) and name it `coursemanagement-docker-compose`. We don’t need a JEE
    project for this section because we are going to take the single JAR file that
    we created in the last section for our microservice and deploy it in a Docker
    container. So, copy `coursemanagementspring-docker/coursemanagementspring-0.0.1-SNAPSHOT.jar`
    to the project folder.
  prefs: []
  type: TYPE_NORMAL
- en: We need to create and initialize a MySQL database in the container. We are going
    to use a SQL script with **data definition language** (**DDL** for example, `CREATE`)
    statements to create database schema and tables. The source code project for this
    section, `coursemanagement-docker-compose`, has a file, `course-management-db.sql`,
    containing DDL statements. This script creates empty tables with no data.
  prefs: []
  type: TYPE_NORMAL
- en: If you want also to export data from your existing database, then you can create
    the script from MySQL Workbench. From MySQL Workbench, select Server | Data Export.
    Select the schema to export, `course_management`. From the drop-down options,
    select Dump Structure and Data. In Export Options, select Export to Self-Contained
    File and specify the path of the file, for example, `<your_project_path>/course-management-db.sql`.
    Then, click the Start Export button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create two Dockerfiles in the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`course-management-db.dockerfile` for the MySQL container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`course-management-service.dockerfile` for the microservice container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create `course-management-db.dockerfile` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With the `COPY` statement in this file, we are copying `course-management-db.sql`
    from the project folder to the `docker-entrypoint-initdb.d` folder in the container.
    Any SQL script in this file will be executed by the base MySQL image to initialize
    the database. See the *Initializing a fresh instance* section at [https://hub.docker.com/_/mysql/](https://hub.docker.com/_/mysql/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `course-management-service.dockerfile` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this Dockerfile, we are creating the container from the `openjdk:8` base
    image. Then, we are creating a folder, `microservices`, in the container and then
    copying `coursemanagementspring-0.0.1-SNAPSHOT.jar` from the project folder to the
    `microservices` folder in the container. We then set the `ENTRYPOINT` for the
    container with the command to execute the copied JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, create `docker-compose.yml` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We are creating two services in this file: `course-managemnt-db` for the DB
    container and `course-management-service` for the microservice container. Both
    are built from separate Dockerfiles. The context field specifies the path of the
    folder containing the Dockerfile; in this case it is the present folder (which
    is the project folder). Note that we have specified the dependency of `course-management-service`
    container on `course-managemnt-db`. This results in the DB container getting started
    before the microservice container.'
  prefs: []
  type: TYPE_NORMAL
- en: We are mapping port `8080` from the microservice container to port `80` on the
    host. The reason is that we are going to deploy these services later in the cloud
    with the default web server on port `80`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning** The deployment of JEE container in this chapter is meant for the
    purpose of development and testing only. It is not meant for production and does
    not follow best practices for a production environment. That falls under the realm
    of DevOps, which is not within the scope of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Since both the services are in the same `docker-compose.yml`, `docker-compose`
    creates a network and adds both containers to the network. So, the `course-management-service`
    container can access the `course-management-mysql` container by its name. We do
    not need to create a separate network as we did in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: See the `docker-compose` file reference at [https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/)
    for more configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start all the containers configured in `docker-compose.yml` together, run the
    following command from the Command Prompt (make sure port `80` is not taken by
    another process, because we have mapped microservice container port `8080` to
    port `80` on the host):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Once the containers have started successfully, browse to `http://localhost/course_management/courses`
    and you should see a list of courses, or an empty list if there are no courses
    in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run containers in detached/background mode, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To stop containers started with `docker-compose`, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If you make any changes to Dockerfiles or to `docker-compose.yml`, then you
    need to rebuild the images. Run the following command to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Refer to [https://docs.docker.com/compose/reference/overview/](https://docs.docker.com/compose/reference/overview/)
    for details on `docker-compose` command-line options.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A microservice is a small application serving a single use case. Microservices
    are typically REST services and can be deployed quickly. Docker containers are
    ideally suited to deploying microservices because they allow applications to run
    in isolation, with little or no difference in development, testing, and production
    environments. Docker containers can also be deployed very quickly and can scale
    well.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we saw how to develop microservices using WildFly Swarm and
    Spring Boot. We created a simple microservice to list courses for our *Course
    Management* application. The concepts we learned can be extended to create microservices
    using other frameworks. We also learned how to deploy these services in Docker
    containers using the Eclipse plugin for Docker Tooling.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to deploy a JEE application in the cloud.
  prefs: []
  type: TYPE_NORMAL
