<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Switch Expressions</h1>
                </header>
            
            <article>
                
<p>With <kbd>switch</kbd> expressions, Java 12 is enhancing one of its basic language constructs—<kbd>switch</kbd>—to improve the everyday coding experience of developers. The benefits of this are manifold. As compared to <strong>traditional</strong> <kbd>switch</kbd> constructs, <kbd>switch</kbd> expressions (<strong>JDK Enhancement Proposal</strong> (<strong>JEP</strong>) 325—<a href="http://openjdk.java.net/jeps/325">http://openjdk.java.net/jeps/325</a>) can return a value. The ability to define multiple constants with a <kbd>switch</kbd> branch, and improve code semantics, make it concise. By removing default fall through of control across <kbd>switch</kbd> branches, you are less likely to introduce a logical error in a <kbd>switch</kbd> expression.</p>
<p>In this chapter, you'll cover the following topics:</p>
<ul>
<li>Issues with existing <kbd>switch</kbd> statements</li>
<li>The <kbd>switch</kbd> expression syntax</li>
<li>Defining local variables in <kbd>switch</kbd> branches</li>
<li>The extended <kbd>break</kbd> statement</li>
<li>Comparing <kbd>break</kbd> with <kbd>break &lt;return value&gt;</kbd></li>
<li>Exhaustive cases </li>
<li>A preview language feature</li>
<li>Using <kbd>return</kbd> and <kbd>continue</kbd> in <kbd>switch</kbd> expressions</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To compile and execute the code included in this chapter, install JDK 12 on your system. All code in this chapter can be accessed using the following <span class="MsoHyperlink">URL: <a href="https://github.com/PacktPublishing/Java-11-and-12-New-Features">https://github.com/PacktPublishing/Java-11-and-12-New-Features</a>.</span></p>
<p>Let's get started by covering the issues with existing <kbd>switch</kbd> statements.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Issues with traditional switch constructs</h1>
                </header>
            
            <article>
                
<p>At present, the syntax of <kbd>switch</kbd> statements is highly constrained. It is not as powerful as the <kbd>if-else</kbd> construct. With <kbd>if-else</kbd> constructs, you can define and match complex patterns; but not with the <kbd>switch</kbd> construct. Also, the syntax of <kbd>switch</kbd> is verbose, which makes it visually annoying. This can lead to error-prone code that can be difficult to debug.</p>
<p>Let's work with an example to show all of these issues. The following example defines an enum, <kbd>Size</kbd>. The <kbd>Shirt</kbd> class defines a <kbd>setSize()</kbd> method, which accepts <kbd>Size</kbd> and accordingly assigns an integer value to the instance variable, <kbd>length</kbd>:</p>
<pre>enum Size {XS, S, M, L, XL, XXL};          
class Shirt { 
    private int length; 
    public void setSize(Size size) { 
        switch(size) { 
            case XS :   length = 10; 
                        System.out.println(length); 
                        break; 
            case S  :   length = 12; 
                        System.out.println(length); 
                        break; 
            case M  :   length = 14; 
                        System.out.println(length); 
            case L  :   length = 16; 
                        break; 
            case XL :   length = 18; 
                        System.out.println(length); 
                        break; 
            case XXL:   length = 20; 
                        System.out.println(length); 
                        break; 
        } 
    } 
} </pre>
<p>Here's how you can call the preceding method:</p>
<pre>Shirt s = new Shirt(); 
s.setSize(Size.XXL); 
System.out.println(s.length);</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The preceding code outputs the following expected results:</p>
<pre><strong>20 
20</strong> </pre>
<p>However, let's see what happens when you try executing the following code:</p>
<pre>Shirt s = new Shirt(); 
s.setSize(Size.M); 
System.out.println(s.length); </pre>
<p>The preceding code outputs an unexpected mismatch in the values:</p>
<pre><strong>14 
16</strong> </pre>
<p>What do you think is the reason for these mismatching values? To answer this question, here's a quick recap—the <kbd>switch</kbd> branches (that is, the <kbd>case</kbd> labels) in existing <kbd>switch</kbd> constructs must include a <kbd>break</kbd> statement to prevent the fall through of the control. This essentially means that, when the control finds a matching <kbd>case</kbd> value, it will execute the statements until it finds a <kbd>break</kbd> statement or it reaches the end of the <kbd>switch</kbd> construct.</p>
<p>On closer inspection, you'll realize that the branch corresponding to the <kbd>M</kbd> value doesn't define a <kbd>break</kbd> statement. The branch corresponding to the next case, that is, <kbd>L</kbd>, misses the <kbd>System.out.println</kbd> value statement. So, when you call <kbd>s.setSize(Size.M)</kbd>, the following happens:</p>
<ol>
<li><kbd>14</kbd> is assigned to the <kbd>length</kbd> <span>instance variable</span></li>
<li><kbd>System.out.println()</kbd> outputs <kbd>14</kbd></li>
<li>Control falls through the arm corresponding to the <kbd>L</kbd> <span>value</span></li>
<li><kbd>16</kbd> is assigned to the <kbd>length</kbd> <span>instance variable</span></li>
</ol>
<div class="packt_infobox">The traditional <kbd>switch</kbd> construct has a <strong>default</strong> fall through of control across the <kbd>case</kbd> labels, in the absence of a <kbd>break</kbd> statement; this leads to unexpected bugs.</div>
<p>The <kbd>switch</kbd> construct works as a block. However, if you revisit the example code in the preceding section, you'll agree that the language construct takes the focus away from the business logic and introduces complexity.</p>
<p>This is shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b7cccce7-c482-4cd1-bab5-9851cbbb0b41.png"/></p>
<p>The new <kbd>switch</kbd> expressions are here to bring the spotlight back to the business logic.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using switch expressions</h1>
                </header>
            
            <article>
                
<p>Here's an example of a traditional <kbd>switch</kbd> construct that is modifying a variable based on an enum value passed to a method:</p>
<pre>enum SingleUsePlastic {STRAW, BAG, SPOON, FORK, KNIFE, PLATE, BOTTLE}; 
 
class Planet { 
    private static long damage; 
    public void use(SingleUsePlastic plastic) { 
        switch(plastic) { 
            case STRAW :    damage += 10; 
                            break; 
            case BAG   :    damage += 11; 
                            break; 
            case SPOON :    damage += 7; 
                            break; 
            case FORK  :    damage += 7; 
                            break; 
            case KNIFE :    damage += 7; 
                            break; 
            case PLATE :    damage += 15; 
                            break; 
            case BOTTLE:    damage = 20; 
                            break; 
        } 
    } 
} </pre>
<p>Let's see how the preceding code changes if we use <kbd>switch</kbd> expressions:</p>
<pre>damage += switch(plastic) { 
                case STRAW -&gt; 10; 
                case BAG -&gt; 11; 
                case SPOON, FORK, KNIFE -&gt; 7; 
                case PLATE -&gt; 15; 
                case BOTTLE -&gt; 20; 
          }; </pre>
<p>Let's compare the new <kbd>switch</kbd> expressions with traditional <kbd>switch</kbd> statements. The code in the preceding block, which uses <kbd>switch</kbd> expressions, is a lot more concise. You define what to execute on the right of the arrow (<kbd><span>-&gt;</span></kbd>). Also, you no longer need <kbd>break</kbd> statements in each <kbd>switch</kbd> branch. There's less boilerplate and less likelihood of accidental errors from missing <kbd>break</kbd> statements.</p>
<p>The following diagram highlights the changes:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/472b3507-f596-4955-ba13-988f009112fd.png" style="width:40.58em;height:20.83em;"/></p>
<div class="packt_infobox">These <kbd>switch</kbd> expressions are in addition to traditional <kbd>switch</kbd> constructs. They are not here to replace existing <kbd>switch</kbd> constructs.</div>
<p class="mce-root">A <kbd>switch</kbd> expression offers multiple benefits and features:</p>
<ul>
<li>Unlike a <kbd>switch</kbd> statement, a <kbd>switch</kbd> expression can return a value</li>
<li>The return value for a <kbd>switch</kbd> branch is defined to the right of <kbd>-&gt;</kbd></li>
<li>The same <kbd>switch</kbd> branch can define multiple labels that are separated using <kbd>,</kbd></li>
<li>There isn't any default fall through of the control across <kbd>switch</kbd> branches</li>
<li>The code is less verbose</li>
</ul>
<p class="mce-root"><span>Let's work with the finer details of <kbd>switch</kbd> expressions.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining local variables in a switch branch</h1>
                </header>
            
            <article>
                
<p>It is possible to define variables that are local to a <kbd>switch</kbd> branch. To do so, a <kbd>switch</kbd> branch can define a block of code to execute for a matching <kbd>case</kbd> label. To return the value from the branch, it can include a <kbd>break</kbd> statement specifying the value to return. </p>
<p>Let's modify the code in the preceding example to define a code block, as follows:</p>
<pre>class Planet { 
    private static long damage; 
    public void use(SingleUsePlastic plastic) { 
        damage += switch(plastic) { 
            case STRAW -&gt; 10; 
            case BAG -&gt; 11; 
            case SPOON, FORK, KNIFE -&gt; 7; 
            case PLATE -&gt; { 
                                int radius = 20;  // Local variable           <br/>                                                    
                                break (radius &lt; 10 ? 15 : 20); // Using <br/>                                                    // break to return <br/>                                                    // a value 
                          } 
            case BOTTLE -&gt; 20; 
        }; 
    } 
} </pre>
<p>The scope and accessibility of the local variable, <kbd>radius</kbd>, are limited to the <kbd>switch</kbd> branch, in which it is defined.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Another syntax for switch expressions</h1>
                </header>
            
            <article>
                
<p>Apart from using <kbd>-&gt;</kbd> to specify the return value, a <kbd>switch</kbd> expression can also use a colon (<kbd>:</kbd>) to mark the beginning of the code to execute and a <kbd>break</kbd> statement to return a value. Here's an example:</p>
<pre>class Planet { 
    private static long damage; 
    public void use(SingleUsePlastic plastic) { 
        damage += switch(plastic) { 
            case STRAW : break 10;      // Use colon (:) to start code,  <br/>                                        // Use break to return val 
            case BAG   : break 11; 
            case SPOON, FORK, KNIFE : break 7; 
            case PLATE : int radius = 6;         // no need <br/>                                                // of using curly brace
                         break (radius &lt; 10 ? 15 : 20); // Using <br/>                                                       // break to  
                                                      // return a value 
            case BOTTLE : break 20; 
        }; 
    } 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Comparing break with break &lt;return value&gt;</h1>
                </header>
            
            <article>
                
<p><span>A <kbd>break</kbd> statement of the</span> <kbd>break &lt;return value&gt;</kbd> <span>form</span><span> </span><span>is referred to as an </span><strong>extended break statement</strong>.</p>
<p>A traditional <kbd>switch</kbd> construct uses a <kbd>break</kbd> statement without any return values in its <kbd>switch</kbd> branches, to take control out of a <kbd>switch</kbd> construct. This also &lt;indexentry content="break:comparing, with break "&gt;prevents fall through the control &lt;indexentry content="break :comparing, with break"&gt;across multiple <kbd>switch</kbd> branches. A <kbd>switch</kbd> expression uses a <kbd>break</kbd> statement with a return value and breaks out of <kbd>switch</kbd> expressions.</p>
<p class="mce-root"/>
<p>Let's compare the <kbd>break</kbd> statement with the <kbd>return</kbd> statement, which can be used with or without a value. In a method, you can use a <kbd>return</kbd> statement to return a value and exit a method or just exit a method without returning a value. Here's a quick example:</p>
<pre>int sum(int x, int y) {                   // return type of method is <br/>                                         // int 
    int result = x + y; 
    return result;                        // returns int value 
}</pre>
<pre><span>void </span><span>output</span>(List&lt;Integer&gt; list) {         // return type of method is <br/>                                         // void<br/>    <span>if </span>(list == <span>null</span>)<br/>        <span>return;                           // exit method without <br/>                                          // returning a value<br/></span><span>    else </span>{<br/>        <span>for </span>(Integer i : list)<br/>            System.<span>out</span>.println(i)<span>;<br/></span><span>    </span>}<br/>    System.<span>out</span>.println(<span>"End of method"</span>)<span>;  // this doesn't execute if <br/>                                         // list is null<br/></span>}</pre>
<div class="packt_infobox"> A <kbd>switch</kbd> expression uses <kbd>break</kbd> to return a value. A traditional <kbd>switch</kbd> construct uses a <kbd>break</kbd> statement to prevent the fall through of control across its <kbd>case</kbd> labels.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A preview language feature</h1>
                </header>
            
            <article>
                
<p>A <kbd>switch</kbd> expression is a preview language feature (JEP 12). This essentially means that, even though it is complete, it has a possibility of not being confirmed as a permanent feature in a future Java release. This happens for a reason.</p>
<p class="mce-root">Java runs on billions of devices and is used by millions of developers. The risks are high for any mistake in a new Java language feature. Before permanently adding a language feature to Java, the architects of Java evaluate what the developers have to say about it—that is, how good or bad it is. Depending on the feedback, a preview language feature might be refined before it's added to Java SE or dropped completely. So, if you have any feedback on <kbd>switch</kbd> expressions, please share it with <kbd>amber-dev</kbd> (<a href="https://mail.openjdk.java.net/mailman/listinfo/amber-dev">https://mail.openjdk.java.net/mailman/listinfo/amber-dev</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exhaustive cases</h1>
                </header>
            
            <article>
                
<p>A <kbd>switch</kbd> expression can be used to return a value or just execute a set of statements, like the traditional <kbd>switch</kbd> statement.</p>
<p>When you are using a <kbd>switch</kbd> expression to return a value that is used to assign a value to a variable, its cases must be exhaustive. This essentially means that, whatever value you pass to the <kbd>switch</kbd> argument, it must be able to find an appropriate branch to execute. A <kbd>switch</kbd> expression can accept arguments of the <kbd>byte</kbd>, <kbd>short</kbd>, <kbd>int</kbd>, <kbd>Byte</kbd>, <kbd>Short</kbd>, <kbd>Integer</kbd>, or <kbd>String</kbd> types or enums. Of these, only an enum has exhaustive values.</p>
<p>In the following example, a <kbd>switch</kbd> expression is being used to assign a value to the <kbd>damage</kbd> variable. Since there is no matching branch to execute for the <kbd>PLATE</kbd> value, this code won't compile:</p>
<pre>class Planet { 
    private static long damage; 
    public void use(SingleUsePlastic plastic) { 
        damage += switch(plastic) { 
            case SPOON, FORK, KNIFE -&gt; 7; 
        }; 
    } 
} </pre>
<p>To compile the preceding code, you can either add the <kbd>switch</kbd> branch with the <kbd>case</kbd> label, <kbd>PLATE</kbd>, or add a <kbd>default</kbd> branch, as follows:</p>
<pre>class Planet { 
    private static long damage; 
    public void use(SingleUsePlastic plastic) { 
        damage += switch(plastic) { 
            case SPOON, FORK, KNIFE -&gt; 7; <br/>            // Adding (1) or (2), or both will enable the code to <br/>            // compile<br/>            case PLATE -&gt; 10;     // line number (1)<br/>            default -&gt; 100;       // line number (2)
        }; 
    } 
}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>For <kbd>switch</kbd> arguments such as primitive types, wrapper classes, or <kbd>String</kbd> classes, which don't have an exhaustive list of values, you must define a default <kbd>case</kbd> label (if you are returning a value from <kbd>switch</kbd> expressions), as follows:</p>
<pre>String getBook(String name) {<br/>    String bookName = switch(name) { 
        case "Shreya" -&gt; "Harry Potter";<br/>        case "Paul" -&gt; "Management tips";<br/>        case "Harry" -&gt; "Life of Pi";<br/>        default -&gt; "Design Patters - everyone needs this";   
    };<br/>    return bookName;<br/>} </pre>
<p>Let's work with the second situation where you are <em>not</em> using <kbd>switch</kbd> expressions to return a value. The following code modifies the <kbd>getBook()</kbd> method from the preceding code. Though <kbd>switch</kbd> expressions use the new syntax (using <kbd>-&gt;</kbd> to define the code to execute), it is <em>not</em> returning a value. In such a case, the cases of a <kbd>switch</kbd> expression need <em>not</em> be exhaustive:</p>
<pre> String getBook(String name) {<br/>    String bookName = null;<br/>    switch(name) {                                    // NOT returning <br/>                                                     // a value<br/>        case "Shreya" -&gt; bookName = "Harry Potter";<br/>        case "Paul" -&gt; bookName = "Management tips";<br/>        case "Harry" -&gt; bookName = "Life of Pi";      // default case <br/>                                                    // not included<br/>    }<br/>    return bookName;<br/>}</pre>
<div class="packt_infobox">When you use <kbd>switch</kbd> expressions to return a value, its cases must be exhaustive, otherwise, your code won't compile. When you are using <kbd>switch</kbd> expressions to execute a set of statements without returning a value, it's cases might not be exhaustive.</div>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What can a switch branch execute other than returning a value?</h1>
                </header>
            
            <article>
                
<p>In a <kbd>switch</kbd> expression, when a <kbd>switch</kbd> branch isn't returning a value, it can execute a single statement, a block of statements, or even throw an exception. In the following example, the <kbd>switch</kbd> statement is not returning a value. It executes a single statement (prints out a value) for the <kbd>case</kbd> label, <kbd>Sun</kbd>; executes a block of code for the <kbd>case</kbd> labels, <kbd>Mon</kbd> and <kbd>Tue</kbd>; and throws an exception for its default case:</p>
<pre>String day = // assign a value here    <br/>switch(day) {                                    <br/>    case "Sun" -&gt; System.out.println("OSS-Jav");<br/>    case "Mon", "Tue" -&gt; {<br/>        // some simple/complex code<br/>    }<br/>    default -&gt; throw new RuntimeException("Running out of projects");<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How not to use labels and continue in switch expressions</h1>
                </header>
            
            <article>
                
<p>You can use labels and a <kbd>continue</kbd> statement within <kbd>switch</kbd> expressions. However, you can't jump through <kbd>switch</kbd> expressions by using them as follows. Here's an example:</p>
<pre>class Planet { 
    private static long damage; 
    public void use(SingleUsePlastic plastic) { 
        myLabel:                                           // Label  
            for (...) { 
                damage += switch(plastic) { 
                    case SPOON, FORK, KNIFE : break 7;    
                    case PLATE : continue myLabel;         // NOT <br/>                                                           // allowed 
                                                           // illegal                                                            <br/>                                                           // jump 
                                                           // through                                                             <br/>                                                           // switch 
                                                          // expression 
                }; 
            } 
    } 
}</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you saw how <kbd>switch</kbd> expressions have enhanced the traditional <kbd>switch</kbd> statement. You can use <kbd>switch</kbd> expressions to return a value that can be used to initialize variables or reassign values to them. It also makes your code less verbose. By removing default fall through of the control across <kbd>switch</kbd> branches, you are less likely to introduce logical errors with <kbd>switch</kbd> expressions. </p>
<p>In the next chapter, we'll cover multiple improvements and additions in JDK 12.</p>


            </article>

            
        </section>
    </body></html>