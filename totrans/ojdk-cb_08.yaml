- en: Chapter 8. Hacking OpenJDK
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 破解OpenJDK
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Setting up the development environment with NetBeans
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NetBeans设置开发环境
- en: Working with Mercurial forests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Mercurial森林协同工作
- en: Understanding OpenJDK 6 and 7 incremental builds
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解OpenJDK 6和7增量构建
- en: Debugging Java code using NetBeans
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NetBeans调试Java代码
- en: Debugging C++ code using NetBeans
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NetBeans调试C++代码
- en: Using NetBeans to compile HotSpot
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NetBeans编译HotSpot
- en: Using HotSpot dev parameters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HotSpot开发参数
- en: Adding new intrinsic to HotSpot
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向HotSpot添加新的内建函数
- en: Building VisualVM from the source code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从源代码构建VisualVM
- en: Creating a plugin for VisualVM
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为VisualVM创建插件
- en: Getting benefits from the AdoptOpenJDK project
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从AdoptOpenJDK项目中获得收益
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The real beauty of OpenJDK is its open nature, which means that developers can
    not only use it to run an application, but also change it to their needs or contribute
    to its development. The availability of the source code and ease of access to
    it opens huge opportunities to individuals who have special requirements, or just
    want to learn more about the way JVM works internally and want to adapt it for
    any special requirements. This chapter will help you to get into it and provide
    some recipes to make the process of setting up the required development environment
    as easy as possible.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: OpenJDK真正的美在于其开放性，这意味着开发者不仅可以使用它来运行应用程序，还可以根据需要对其进行更改或为其开发做出贡献。源代码的可用性和易于访问为有特殊要求的人或只是想了解更多关于JVM内部工作方式的人提供了巨大的机会，他们希望将其适应任何特殊要求。本章将帮助您进入这一领域，并提供一些食谱，使设置所需开发环境的过程尽可能简单。
- en: At first, it will cover how to set up the development environment and which
    tools are required to get started. It will cover the IDE setup, and some tweaks
    required to launch JVM and start debugging. The next step is to make changes and
    rebuild the code, and the latter is going to be slightly different from the normal
    build described in [Chapter 5](ch05.html "Chapter 5. Building IcedTea"), *Building
    IcedTea*, [Chapter 6](ch06.html "Chapter 6. Building IcedTea with Other VM Implementations"),
    *Building IcedTea with Other VM Implementations*, and [Chapter 7](ch07.html "Chapter 7. Working
    with WebStart and the Browser Plugin"), *Working with WebStart and the Browser
    Plugin*. The rest of that section dedicated to will be useful techniques which
    can be used to debug changes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它将涵盖如何设置开发环境以及启动所需的工具。它将涵盖IDE设置，以及启动JVM和开始调试所需的调整。下一步是更改代码并重新构建，后者将略不同于第5章中描述的正常构建，即[第5章](ch05.html
    "第5章. 构建 IcedTea")，*构建IcedTea*，[第6章](ch06.html "第6章. 使用其他虚拟机实现构建IcedTea")，*使用其他虚拟机实现构建IcedTea*，和[第7章](ch07.html
    "第7章. 使用WebStart和浏览器插件")，*使用WebStart和浏览器插件*。该部分剩余的内容将包含一些有用的技术，可用于调试更改。
- en: This chapter assumes that the reader has a reasonable knowledge of C++ and Java.
    Any knowledge of JVM is ideal, as the reader should know what JIT is and how it
    works.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设读者对C++和Java有合理的了解。对JVM的了解是理想的，因为读者应该知道JIT是什么以及它是如何工作的。
- en: Most of the recipes in the JIT section are independent and can be executed separately,
    so the reader just can pick what he/she needs and proceed with it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: JIT部分的大多数食谱都是独立的，可以单独执行，因此读者只需选择他们需要的部分并继续即可。
- en: Setting up the development environment with NetBeans
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NetBeans设置开发环境
- en: This recipe will cover the steps required to install, run, and set up the project
    in NetBeans IDE. NetBeans is an open source IDE for developing, primarily in Java.
    It also has rich support for C++ and that makes it a good tool for OpenJDK development
    which uses both languages. This recipe uses NetBeans IDE v.7.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将涵盖在NetBeans IDE中安装、运行和设置项目的步骤。NetBeans是一个开源IDE，主要用于Java开发。它还提供了对C++的丰富支持，这使得它成为OpenJDK开发的良好工具，因为OpenJDK使用这两种语言。本食谱使用NetBeans
    IDE v.7。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Download the latest version of the NetBeans `All` bundle for your platform from
    [http://www.netbeans.org/downloads](http://www.netbeans.org/downloads). The `All`
    bundle must have C/C++ and Java support in the same IDE. It is also necessary
    to have the OpenJDK code checked out and available on the machine.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从[http://www.netbeans.org/downloads](http://www.netbeans.org/downloads)下载适用于您平台的最新NetBeans
    `All`捆绑包。`All`捆绑包必须在同一IDE中具有C/C++和Java支持。还必须在机器上检出并可用OpenJDK代码。
- en: Make sure that everything is set up for the OpenJDK build and it can be executed
    without errors. How to do that is described in [Chapter 2](ch02.html "Chapter 2. Building
    OpenJDK 6"), *Building OpenJDK 6*, [Chapter 3](ch03.html "Chapter 3. Building
    OpenJDK 7"), *Building OpenJDK 7*, and [Chapter 4](ch04.html "Chapter 4. Building
    OpenJDK 8"), *Building OpenJDK 8*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will install and configure the NetBeans IDE that is used in the OpenJDK project
    as the standard one.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: First we need to install the NetBeans IDE. This is a very simple process which
    consists of a few simple steps. Run the downloaded executable and at the bottom
    of the first screen, select the **Customize** button. This will show following
    window:![How to do it...](img/8405OT_08_01.jpg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that **Base IDE**, **Java SE**, **C/C++**, and **Features on Demand**
    are selected. The rest are optional and not required to run and debug OpenJDK,
    but there is no harm in installing that functionality.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After the setup, all plugins you should update to the latest version. Updates
    are available via the **Help/Check for updates** menu item.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When NetBeans is set up, it is required to make a slight change to its configuration.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'OpenJDK is a big project and its memory requirements are bigger than the ones
    defined in the default settings. To increase the memory available for IDE:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Go to the `$HOME/.netbeans/NETBEANS_VERSION/etc` folder (on Windows `$HOME`
    is `%HOMEPATH%`).
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the folder doesn't exist, create it.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, if that folder doesn't have the `netbeans.conf` file, copy it from the
    Netbeans installation directory, which is located in the `etc` folder.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the file with any text editor and locate the `netbeans_default_options`
    parameter which it should look similar to this:'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When the parameter is located, add `-J-Xmx2g`, or, if that option is already
    present, update it to a value not less than `2G` (2 gigabytes). This will increase
    the memory available to JDK to `2G`. Restart your IDE if it was running before
    in order to apply that change.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: It is worth adding that, because of the large memory requirement of Netbeans
    IDE, It's recommended to run it on a system that is capable of providing nothing
    less than 2 GB of memory to the process. Basically, it means that it should be
    a machine with a 64-bit OS and about 4 to 6 GB of RAM.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now Netbeans IDE is ready for the project to be set up. Run it and go to **File**
    | **New Project** on the dialog box and select **C/C++ Project with Existing Sources**:![How
    to do it...](img/8405OT_08_02.jpg)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then press **Next** and, on the following dialog box, select the folder with
    the root of OpenJDK sources:![How to do it...](img/8405OT_08_03.jpg)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can always obtain your OpenJDK code by typing `hg clone http://hg.openjdk.java.net/jdk6/jdk6
    && ./get_source.sh`
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press **Finish** and Netbeans will attempt to clean and build the project. Clean,
    most probably, will execute without problems, but build will not work because
    it requires some environment setup, which we will do later on.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After trying to build the project, Netbeans will spend a fair bit of time (minutes)
    scanning sources and building indexes. This would be a good time to have some
    coffee.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to configure Netbeans to build the project. As already mentioned,
    the build script requires some environment setup. The following is a simple bash
    script which can be used to create an appropriate environment:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the root folder of the OpenJDK source tree, create a file `build.sh` and
    save this script in that folder.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then navigate to the **Run** | **Set project configuration** | **Customize**
    menu item and, in the tree on the left-hand side, select **Build** | **Make**.
    There you will see the following dialog:![How to do it...](img/8405OT_08_04.jpg)
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As shown in the screenshot, set the **Build Command** and **Clean Command**
    variables to execute your `./build.sh` with the `debug_build` and `clean` commands,
    respectively.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `product` version of OpenJDK is required, then just create another configuration
    with `product_build` and the parameter for `build.sh`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Netbeans is not the only available IDE which supports both Java and C++. There
    are other IDEs which are similarly capable. One example is the Eclipse IDE which
    is also a powerful multiplatform IDE written in Java, and has similar functionality.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Working with Mercurial forest
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mercurial is a cross-platform version control system. It was designed to work
    with big projects and large amounts of code, which undoubtedly are present in
    the OpenJDK project. The OpenJDK official repository is a Mercurial.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The Forest plugin is the one used for various OpenJDK subprojects to merge and
    coexist. It works with nested Mercurial repositories, which normally are regarded
    as isolated. The main idea is to propagate changes from the root repository to
    the nested ones.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The main purpose of it is to allow a developer to work with the code, which
    is a minor part of a full OpenJDK project repository, without needing to make
    any changes to the whole repository (change a revision number, for example).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, we will need to install Mercurial itself. On Windows it can be
    done by going to the official Mercurial site and downloading it from [http://mercurial.selenic.com/wiki/Download](http://mercurial.selenic.com/wiki/Download).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: For Linux distributions, there are, usually, Mercurial versions in their official
    repositories.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, on Debian and Debian-inherited distributions, Mercurial installs
    as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you have any problems with a Mercurial installation, refer to the official
    site or to your Linux distribution resources.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's explain it with a simple, non Java-related example. We will assume that
    a Mercurial instance already exists in the OS. Since Mercurial has a command line
    tool, we will use a command line for everything.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create two repositories:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will need to locate the `.hgrc` file:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's copy the `forest.py` file from [https://bitbucket.org/gxti/hgforest/src](https://bitbucket.org/gxti/hgforest/src).
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then let''s edit your `.hgrc` file:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We now have a brand new `fclone` command in our repository.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s copy the first repository into the second one:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `repo-two` repository isn't an integral part of `repo-one`, it only lays
    inside it.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s clone a `repo-two` repository and attach `repo-one to it`, using the
    `fclone` command:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We've just copied `repo-two`, including `repo-two/one`.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s make some changes to `repo-two/hello.txt` and `repo-two/one/hello.txt`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will commit each change using a separate command:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s push a result back to `repo-two`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will have two changed files in repo-one.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s push one of them further to `repo-two`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, the changes from `repo-two/one` are propagated to `repo-one`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mercurial is a relatively simple control system. It is vastly extendable with
    different plugins, which are configured through the `.hgrc` file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The Mercurial `forest` plugin propagates changes in nested repositories to the
    root ones, and synchronizes the parent repository content with a nested one.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Understanding OpenJDK 6 and 7 incremental builds
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of OpenJDK compilation is very time consuming. It is very boring,
    especially when one is developing a small part of the whole project, which needs
    full recompilation for testing purposes. To do it in a simple way and to compile
    only the necessary parts, there are incremental builds.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to download the OpenJDK (6 or 7) source code. You may need `libmotif`
    installed. Windows users may need to install Cygwin.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will see how OpenJDK is built incrementally, avoiding adding any nasty bugs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s build OpenJDK for the first time:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will take some time, so have a cup of tea.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we will build it for the second time:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can see from the input that nothing was actually built.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, let's insignificantly change some source file (for example, `cardTableModRefBS.cpp`).
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s `make` OpenJDK again, but this time we will `grep` the output:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We see that, in the output, only two files are actually compiled, `hotspot/src/share/vm/memory/cardTableModRefBS.cpp`
    and `hotspot/src/share/vm/runtime/vm_version.cpp`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The build program checks the files that were updated and compiles only those
    which were updated after the last compiler run. However, if any `.hpp` files are
    modified, the build will be performed in clean mode, for example, no optimization
    will be performed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Weird things tend to happen while using incremental builds. The probability
    of such things is increased proportionally with build times.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'There are, basically, two ways to perform a clean build:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'One cleans all files, and compilation from scratch becomes necessary:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The second is to specify parameters, which will force the clean mode of the
    build.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging Java code using NetBeans
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Obviously, when someone is writing any code, some debugging is required. It
    is no surprise that NetBeans, as a high-standard IDE, provides some tools to do
    that. This recipe will show how to debug the Java code using NetBeans.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to install NetBeans and set up a development environment, as described
    previously in the chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use NetBeans to debug our own OpenJDK Java code. We will need to rebuild
    OpenJDK with debug symbols, and configure NetBeans to make debugging possible:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s make our OpenJDK instance with debug symbols:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s ensure that a debuggable version is built:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now we have a debuggable OpenJDK. Let's set it as the default for NetBeans.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's open the `etc/netbeans.conf` file in your NetBeans installation path.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will change one line:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After that, we will launch NetBeans and ensure that our JDK is loaded correctly.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will select **Tools** | **Java Platforms**, and the following screen will
    appear:![How to do it...](img/8405OT_08_05.jpg)
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's try to debug the `java.lang.String` class. We will set our breakpoints
    to an unavoidable part of this class—to one of the constructors, as shown in the
    following screenshot:![How to do it...](img/8405OT_08_06.jpg)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This set of breakpoints is sufficient to hook up virtually every Java executable
    ever launched. But, if we decide to push things forward and attach a debugger,
    we will get an error message:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To avoid this, we need to specify our Java sources directly to NetBeans. Our
    project is a C++ project, and it tends to ignore the Java files.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result for the `String` class will be as shown in the following screenshot:![How
    to do it...](img/8405OT_08_07.jpg)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, just launch some Java executable, that uses strings:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Attach the Java debugger, as shown:![How to do it...](img/8405OT_08_08.jpg)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enjoy, you can now see OpenJDK from the inside, in motion:![How to do it...](img/8405OT_08_09.jpg)
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's just a debugger with a few simple nuances.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some Linux distributions, you can install debug versions of OpenJDK with
    sources provided in a ZIP file. These sources are automatically picked up by NetBeans.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Debugging C++ code using NetBeans
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you plan to make changes to HotSpot or any other C++ part of OpenJDK, then
    it is certain that you will need to do some step-by-step debugging of the code.
    This recipe will explain how to set up NetBeans IDE for that purpose.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, there are only a few things required—downloaded Open JDK sources
    and installed NetBeans IDE. It is assumed that the OpenJDK project is already
    set up and can build sources.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is to set up an executable that will run. Go to **Run** | **Set
    project configuration** / **Customize** and then **Build** | **Make**, and set
    **build/linux-amd64-debug/hotspot/outputdir/linux_amd64_compiler2/jvmg/gamma**
    as the build result, as shown in the following screenshot:![How to do it...](img/8405OT_08_10.jpg)
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then select the **Run** option on the tree on the left had side and set **Run
    Command** as **"${OUTPUT_PATH}" –version**:![How to do it...](img/8405OT_08_11.jpg)
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `–version` flag here is just the simplest thing you can run—get the Java
    version. You can later change it to whatever you want, for example, to run a Java
    program.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to set up some environment variables required for Java to run.
    This can be done by setting them up in the **Environment** section as shown in
    the following dialog. Set `LD_LIBRARY_PATH` to `build/linux-amd64-debug/hotspot/outputdir/linux_amd64_compiler2/jvmg`
    and `JAVA_HOME` to `build/linux-amd64-debug/j2sdk-server-image`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now it's all ready to debug. To check that it works, set a breakpoint in `hotspot/src/share/tools/launcher/java.c`
    somewhere at the beginning of the `main` function and go to **Debug** | **Debug
    Main Project** or use the shortcut *Ctrl* + *F5*.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Careful readers may have noticed that **Debug** used `gamma` JVM launcher, instead
    of `java`, which is used when you run Java normally. This is to simplify things;
    `gamma` is the lightweight version of `java`, it doesn't perform checks which
    are not necessary for debugging purposes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Using NetBeans to compile HotSpot
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When doing HotSpot development, it is very annoying to wait for a complete OpenJDK
    build to be executed. So, it makes sense to exclude other parts and compile just
    what we are interested in, that is, the HotSpot part. This recipe will explain
    how to do that.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The only prerequisite for this recipe is the availability of source code on
    the machine, and Netbeans installed, with an OpenJDK project created.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a very simple recipe to follow. If you have already completed *Setting
    up development environment with NetBeans*, the only thing which is required to
    be done is to change the argument `hotspot_build` and add another argument `DEBUG_NAME=debug`,
    the whole build command line should look like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The **Build/Make** screen of the **Project Properties** dialog in that case
    will look like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/8405OT_08_12.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: How it works…
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Luckily, there are targets created in the `make` configuration which only built
    the HotSpot bit. These targets can be located in the `./make/hotspot-rules.gmk`
    file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The `debug` command which creates the non-optimized version or the HotSpot,
    is not the only option for the `DEBUG_NAME` variable. The `fastdebug` command
    is the other option in which build will create an optimized version with assertions.
    When `DEBUG_NAME` is not set, the product version of HotSpot is built.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Using HotSpot dev parameters
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HotSpot has other options, which may significantly change its behavior. Here
    we will make use of some of these options, which are used only on the dev versions
    of OpenJDK.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will need to compile a dev OpenJDK version, in order to use the dev options.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use parameters that are available in the developer version of OpenJDK.
    In the production builds, they are disabled or set as constant values.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'To make use of these parameters, we will run Java as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here is a list of some usable dev options:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '`InlineUnsafeOps`: This option will, if enabled, inline native memory operations
    from `sun.misc.Unsafe`. It may offer some performance improvements in some cases.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DieOnSafepointTimeout`: This option will kill the process if the safepoint
    is not reached, but the timeout is exceeded. It is disabled by default.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZapResourceArea`: This option will zap freed resource / arena space with `0xABABABAB`.
    It is true in debug mode, but is deselected in production VMs. It may be used
    for really paranoid security reasons, though it has some performance impact.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZapJNIHandleArea`: This option will zap freed JNI handle space with `0xFEFEFEFE`.
    It only has a debug value.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZapUnusedHeapArea`: This option will zap unused heap space with `0xBAADBABE`.
    It may be used for security reasons.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Verbose`: This option prints additional debugging information from other modes.
    It is the main logging option of the dev HotSpot.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UsePrivilegedStack`: This option enables the security JVM functions. It is
    `true` by default, but in dev mode, you still have the opportunity to run HotSpot
    with disabled security.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MemProfiling`: This option writes memory usage profiling to logfile. It is
    `false` by default, and can be run for some memory profiling issues.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VerifyParallelOldWithMarkSweep`: This option will use the `MarkSweep` GC code
    to verify phases of the parallel old. It may be used for debugging purposes when
    changing the JVM memory handling mechanism.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScavengeWithObjectsInToSpace`: This option is really interesting. Java uses
    two-space GC, where survivor space is concerned, and this options allows scavenges
    to occur when `to_space` contains objects. Also, when doing so, it clears an unused
    area, if `ZapUnusedHeapArea` is enabled.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FullGCALot`: This option forces full GC at every *Nth* exit from the runtime
    system (`N=FullGCALotInterval`). It may be a very expensive operation, but some
    developers may build it into JDKs for desktop use. It may be cheaper than to use
    swap space to absorb endless megabytes from the overgrown heap.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AdaptiveSizePolicyReadyThreshold`: This option is the number of collections
    before adaptive sizing is started. The default is `5`, but it may make sense to
    make it `1` on desktop systems since the biggest bottleneck of those is the swap
    space, especially if several Java programs are running simultaneously on one machine.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EagerInitialization`: This option eagerly initializes classes if possible.
    It is `false` by default, so maybe it is unsafe to turn it on. But the idea seems
    good, especially on server machines.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GuaranteedSafepointInterval`: This option guarantees a safepoint (at least)
    every few milliseconds (`0` means none). The default is `1000`. It may be used
    to tweak the stop-the-world state problem. The bigger the option value, the longer
    these stops will be; and if we make the value too small, we will have too many
    unnecessary stops.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MaxTrivialSize`: This option is the maximum bytecode size of a trivial method
    to be inline. It is `6` by default. It is similar to the C++ compiler inline options,
    but for the bytecode compiler.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MinInliningThreshold`: This option is the minimal invocation count a method
    needs to have to be inline. It is `250` by default.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SharedOptimizeColdStartPolicy`: This option is the reordering policy for `SharedOptimizeColdStart`.
    The `0` value favors the classload-time locality, `1` uses a balanced policy,
    and `2` favors runtime locality.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default is `2` and it is rarely necessary to change it, but in some cases
    it will make sense to make it `1` if your application has too many classes that
    may load after the application starts.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Adding new intrinsic to HotSpot
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Intrinsic is a function whose implementation is handled specially by a compiler.
    Typically, it means that the function call is replaced by automatically generated
    instructions. This is very similar to the inline functions, but the compiler knows
    more about intrinsics as they are part of the compiler itself, so it can use them
    more wisely.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Intrinsics are usually more performance-oriented than native functions because
    there is no JNI overhead.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, all we need is an installed NetBeans IDE for code editing and
    OpenJDK sources. The user should be able to read C++ code and a little knowledge
    of assembly would be beneficial.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: It would be worth checking that SSE4.2 (an extended instruction set with six
    new commands, mostly for character searching and comparison) is supported by the
    CPU (the `CRC32` command used in our example is from that command set). It was
    introduced with Core i7 Intel chips back in 2009, so if you are using an Intel
    CPU, it should be present. The first time it was introduced for AMD was as Bulldozer
    chips back in 2011, so you should have relatively recent chips to support it.
    If your CPU is not compatible with that command, do not worry. The recipe is applicable
    to any intrinsics you may want to introduce; there is no difference, apart from
    the actual implementation of the code you want to intrinsify.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding new intrinsics is not a simple process. Follow these instructions carefully.
    Ensure you compile the code after every step; doing so may save some time.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The instruction which we are going to intrinsify is the CRC32 calculation, which
    is implemented by `java.util.zip.CRC32`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let''s make a small amendment to the Java class that is responsible
    for the CRC32 calculation. We are going to add a method which will be intrinsified
    by HotSpot. Open the `jdk/src/share/classes/java/util/zip/CRC32.java` file and
    add a new method `doUpdateBytes`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That implementation just makes a call to the currently used `updateBytes` native
    method. That's the only change in Java. The rest is going to be the C++ internals
    of the HotSpot.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `hotspot/src/share/vm/precompiled/precompiled.hpp` file and add the
    following line into it:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `smmintrin.h` file contains GCC intrinsics, which are going to be used by
    our implementation of the CRC32 function.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, as we are using SSE4.2 instructions, we need to inform the compiler.
    To do so, open the `hotspot/make/linux/makefiles/gcc.make` file (assuming you
    are making the build on Linux), and locate the line consisting of `CFLAGS += -fno-rtti`.
    Just after that line, add the `-msse4.2` flag, so it will look like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we are ready to implement our CRC32 function in C++. In the `hotspot/src/cpu/x86/vm/`
    folder, create the `CRC32Calc` class and the `static_calcCrc32` static method.
    Here is the `CRC32Calc.hpp` file with the class declaration:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `CRC32Calc.cpp` file with its implementation is as shown:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The following instructs HotSpot how to intrinsify our method.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate `hotspot/src/share/vm/classfile/vmSymbols.hpp`. That is the file which
    contains the declaration of all intrinsics and add the following definition to
    it:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is the declaration of intrinsics which maps the Java method with the code
    which will replace it in the runtime. Be careful when adding it. It is based on
    macros, which means, if there is a typo or any other mistake, it will be very
    hard to figure out where the problem is.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to define which code we are going to generate for the intrinsic.
    We are not going to be very smart here, as this is just an exercise to see how
    the functionality works. So all our assembler is going to do is generate a call
    to the C function. Add the following into `hotspot/src/cpu/x86/vm/stubGenerator_x86_64.cpp`
    and `hotspot/src/cpu/x86/vm/stubGenerator_x86_32.cpp`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now it''s a bit tricky and requires some low-level code. We are going to tell
    HotSpot how to generate the assembly for our method. To do so, add the `generator`
    method into the `StubGenerator` class which is declared in both `hotspot/src/cpu/x86/vm/stubGenerator_x86_64.cpp`
    and `hotspot/src/cpu/x86/vm/stubGenerator_x86_32.cpp` for x86_64 and x86 architectures
    respectively. The code for the method is as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we need a variable which will contain the address of the generated method.
    To do so, add the following static member declaration to `hotspot/src/share/vm/runtime/stubRoutines.hpp`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To the same file, add the following method, which just returns the value of
    the declared variable:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, in `hotspot/src/share/vm/runtime/stubRoutines.cpp`, assign a default
    value to `_crc32_doUpdateBytes`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, in both `hotspot/src/cpu/x86/vm/stubGenerator_x86_64.cpp` and `hotspot/src/cpu/x86/vm/stubGenerator_x86_32.cpp`,
    locate the `generate_all` method and assign the following value to the variable
    `_crc32_doUpdateBytes`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The next step is to add the method which creates a descriptor. The descriptor
    is the definition of our function—how many arguments it takes, which types of
    arguments it accepts, and so on. The first step is to add the method declaration
    into the `OptoRuntime` class in the `hotspot/src/share/vm/opto/runtime.hpp` file:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will be the function which creates the type information for our method
    call—it describes the arguments and returns the parameters. After implementation
    it creates an array of types of input parameters and the type of the return value.
    Place it in the `hotspot/src/share/vm/opto/runtime.cpp` file:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we will implement the method that will inline the code in the runtime.
    In the `hotspot/src/share/vm/opto/library_call.cpp` file, locate the definition
    of the `LibraryCallKit` class, and add the following method declaration:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Also, in the same file, add the implementation:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finally tell HotSpot that we indeed want to intrinsify our method call and make
    a call to the inlining method `inline_crc32`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'To tell HotSpot that we want to intrinsify the method, `Compile::make_vm_intrinsic`
    method in the file `hotspot/src/share/vm/opto/library_call.cpp` has to return
    a non-null pointer to `CallGenerator`. To do so, add the following line into the
    `switch(id)` switch statement in that method:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It is not strictly required to have that case and break, the default works just
    well; but it makes it more explicit that we are using intrinsics for the CRC32
    calculation method.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to make a call to the inlining method, in the same `hotspot/src/share/vm/opto/library_call.cpp`
    file, locate `LibraryCallKit::try_to_inline`, find `switch (intrinsic_id())`,
    and add the following line of code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works…
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To check whether the method was intrinsified, use the `-XX:+PrintCompilation`
    and `-XX:+PrintInlining` Java arguments. To see what the intrinsics are compiled
    into, use `-XX:+PrintAssembly` (this should be prepended by `-XX:+UnlockDiagnosticsVMOptions`
    when running on the product build).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see if SSE4.2 is supported, just compile and run the following code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'There are lots of intrinsic methods. See `library_call.cpp` and `vmSymbols.hpp`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.getClass` gives one or two instructions.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Class.isInstance` and `Class.isAssignableFrom` are as cheap as instances of
    bytecodes when the operands are constants, and otherwise no more expensive than
    aastore type checks.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most single-bit class queries are cheap and even constant-foldable.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflective array creation is about as cheap as the `newarray` or `anewarray`
    instructions.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.clone` is cheap and shares code with `Arrays.copyOf` (after Java6).'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java is not the only language which uses intrinsics they are also widely used
    in C++ for SSE operations.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, `_mm_crc32_u32` and `_mm_crc32_u8` are intrinsics themselves,
    known by the GCC or MS compiler, which are directly replaced by assembly instructions
    in the compiled code.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Building VisualVM from the source code
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: VisualVM is an open source project which is not a part of OpenJDK. It is a powerful
    tool which is helpful to anyone who uses applications based on JDK. It allows
    us to monitor parameters of the system, browse heap dumps, create thread dumps,
    and so on. As the tool is open source, it is possible to get the source code and
    customize it as required, or simply just to see how it works. This recipe will
    go through the steps which are required to download the source code and build
    VisualVM from it.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires a machine with Subversion and Ant installed. Also, as VisualVM
    is a graphical application, a graphical environment is required to run it. It
    is possible to perform a build without launching the application.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is to get the source code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder for the sources, for example, `/home/user/visualvm`.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the newly created folder and, assuming you need sources from the `trunk`,
    run the following command:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This will create the `trunk` folder with sources in the current directory.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To start, we need to download the NetBeans Platform binaries. The version needed
    depends on the version of VisualVM we are going to build. In this example, we
    will use `trunk`, the current development version which requires NetBeans Platform
    v.8; but as that may change, it is recommended to consult the page for the appropriate
    version using the link [http://visualvm.java.net/build.html](http://visualvm.java.net/build.html).
    These binaries are available directly from the VisualVM website, not from the
    NetBeans website. For this example, the URL is [https://java.net/projects/visualvm/downloads/download/dev/nb80_visualvm_27062014.zip](https://java.net/projects/visualvm/downloads/download/dev/nb80_visualvm_27062014.zip).
    When the file is downloaded, unpack it into the `trunk/visualvm` folder, as shown:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Now, execute Ant to run the build.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When the build is complete, we should see something similar to the following
    output in the command prompt:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This indicates that the build was successful. This step is not required if we
    just need to run VisualVM, as Ant will also run the build target; but if there
    is no need to run, and just build is required, this step can be useful.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To run VisualVM, run the following command:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If the application is not built yet, then Ant will build it first and then run
    it. As VisualVM is a GUI application, we will see the following screen:![How to
    do it...](img/8405OT_08_13.jpg)
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the landing screen of VisualVM. The fact that we can see it means that
    the application is built and works properly. The zipped archive file with the
    distribution can be found in the `visualvm/dist` folder.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More information about VisualVM build is available on the home page [http://visualvm.java.net/build.html](http://visualvm.java.net/build.html).
    Each version has a different page, as build instructions vary from version to
    version. For example, each build may require a slightly different version of the
    Netbeans platform.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a plugin for VisualVM
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: VisualVM is just an application which has a predefined and limited set of features.
    It is a framework, which means that it is possible to extend it. The way in which
    VisualVM provides for extension is via the plugin API which allows us to create
    new plugins which are then available through the application. Such plugins can
    do various things, but are mostly used to provide new ways of monitoring or controlling
    the JVM applications.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The current (at the time of writing) trunk version of VisualVM requires the
    NetBeans platform and IDE v.8\. So we need to ensure that the current version
    of the platform is available on the machine. If there is any doubt, check the
    page with VisualVM trunk build instructions at [http://visualvm.java.net/build/build.html](http://visualvm.java.net/build/build.html).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with what we are going to monitor. It seems like the simplest
    thing we can do is to build a component which will tick the data that we can read.
    For example, look at the following class:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This code sleeps for 100 ms and measures how long it actually slept. The value
    is not going to be exact, but will be about `100`. It publishes the last measurement
    of the sleep time via the `lastSleepSample` variable which is available via the
    `SleepProbeMBean` interface:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This class and interface should be put into a separate project, so you can
    run them independently of the VirtualVM plugin project:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: To start, we need to create a plugin project in IDE. Launch the IDE, go to **File**
    | **New Project** and select **NetBeans Platform Application** from the project
    type:![How to do it...](img/8405OT_08_14.jpg)
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, select **VisualVM** as the **NetBeans Platform** (if it
    is not available, see further instructions), the project name, and the location,
    as shown:![How to do it...](img/8405OT_08_15.jpg)
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If **VisualVM** is not available in the list of platforms, then click on the
    Manage icon and, in the displayed dialog, add a new platform by pointing it to
    the folder with the VisualVM distribution, as shown in the following screenshot:![How
    to do it...](img/8405OT_08_16.jpg)
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this example, the distribution was built from source (see the *Building VisualVM
    from the source code* recipe). Press **Next** and then **Finish**.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now just complete the wizard and you will have a new empty project with some
    properties and build script.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that there is a known bug in some versions of NetBeans ([https://netbeans.org/bugzilla/show_bug.cgi?id=242564](https://netbeans.org/bugzilla/show_bug.cgi?id=242564)),
    which is causing problem with dependencies and which will not allow us to add
    the required dependencies later. To work around this, right click on the project
    and then click on **Properties**. On the **Project Properties** dialog, select
    **Libraries**:![How to do it...](img/8405OT_08_17.jpg)
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck **JavaFX wrapper** under the platform component. Ensure that all the
    other checkboxes are checked, including **profiles** and **visualvm** nodes.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to create a module for our plugin. Right click on the **Modules**
    item in the project tree and select **Add New…**:![How to do it...](img/8405OT_08_18.jpg)
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it as `SamplingModule` and press **Next**. On the next screen, put `net.cookbook.openjdk`
    as `Code Name Base` and press on **Finish**. This will create an empty module
    where we will need to add some components.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to add the dependencies to the module. Right click on the module
    and select **Properties**, then go to **Libraries** | **Module Dependencies**,
    and click on **Add Dependency**. On the **Add Module Dependency** dialog, put
    `VisualVM` into the **Filter** field as shown:![How to do it...](img/8405OT_08_19.jpg)
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **VisualVM-Application**, **VisualVM-Core**, and **VisualVM-Tools** (not
    visible on the screenshot), then click on **OK**.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to add the installer and some source code. To do so, right
    click on the newly created module and go to **New** | **Other**. This will show
    the dialog with the option to select the file type. Click on **Installer/Activator**
    and click on **Next**, as shown:![How to do it...](img/8405OT_08_20.jpg)
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then just complete the wizard by clicking on **Finish**. This will create a
    class with the name `Installer` in the package `net.cookbook.openjdk`. For now,
    leave that class as it is, we will update it later in the recipe.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to create a component which will draw a graph for us. To do
    so, we will create a simple panel which will refresh itself every half a second
    with a new sample from the sampler `MBean`. In the `net.cookbook.openjdk` package,
    create a new class and name it as `SamplingGraphPanel`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This class will read a value from the `MBean` implements on the first step of
    this receipt every 500ms, and add the value to the list with samples. Then it
    refreshes the graph, which gets repainted. Fundamentally, that code is just a
    Java Swing code, which can be run in any application. The only VisualVM-specific
    bit here is some helper classes used to get `MBean` from the `Application` object.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, in `SamplingModule`, create a class which will be responsible for showing
    the data. Name it `SamplingView` and put it into the `net.cookbook.openjdk` package,
    as shown below:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It is important that the file referenced by `IMAGE_PATH` actually exists, otherwise
    the plugin will not start and will fail with an exception. The simplest way you
    can do this is to download any of available free icons from the Internet, for
    example at [https://www.iconfinder.com/icons/131715/download/png/32](https://www.iconfinder.com/icons/131715/download/png/32)
    and put it into the same package folder as the `SamplingView` class.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to create a provider which will create the view instance and
    identify that the application we are connected to is supported by the plugin.
    In the `net.cookbook.openjdk` package, create a class with the name `SamplingProvider`
    and with the following implementation:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The main methods of this class are `supportsViewFor` and `createView`. The `createView`
    method is small and easy, it just creates a view instance and passes through the
    application so that the view can get data out of it. The `supportsViewFor` class
    is slightly bigger, but it doesn't really match. It connects to the given application
    via JMX and tries to get the instance of `MBean` which our plugin is interested
    in. If `MBean` is not there, it means that the application is not supported and
    the method returns `false`.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now it is time to see how the plugin works. To do this, first start the application
    created on the first step of this receipt. Then right-click on **SamplingModule**
    and select **Run**. This will start VisualVM with our plugin. From the list of
    processes in VisualVM, select our process and click on the **Sampling Application**
    tab. There you will see our graph showing slight changes in the sleep time as
    shown in the following screenshot:![How to do it...](img/8405OT_08_21.jpg)
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After following these steps, it should not be a problem for the reader to extend
    this example and use it for any kind of monitoring applications that he/she wants
    in VisualVM.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is some documentation available on the VisualVM website, which helps with
    creating the plugin for VisualVM and which covers, in more detail, some classes
    which are used in this receipt, at [http://visualvm.java.net/api-quickstart.html](http://visualvm.java.net/api-quickstart.html).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth having a look at existing plugins source code and some samples
    available. These can be found in `<code_root>/plugins` and `<code_root>/samples`
    respectively. For instructions on how to download the source code, please see
    the *Building VisualVM from the source code* recipe.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Getting benefits from the AdoptOpenJDK project
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AdoptOpenJDK is a program, initially developed by a small group of enthusiasts,
    but which became part of an official OpenJDK community. Some of the purposes are
    to clarify and simplify OpenJDK building, installation, and usage, but there is
    still more. It provides build automation, a report generator, build testing, and
    more. We will cover some basic features that will be useful for everyone.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To follow this recipe, we will need an OpenJDK instance installed, and an Internet
    connection established.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AdoptOpenJDK is a very helpful and a very sophisticated project set with quite
    a few different subprojects. Many of them concern testing and evangelism, so we
    could not include them here as recipes.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing JIT logs
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is a project named Jitwatch in AdoptOpenJDK. Its purpose is to visualize
    JIT compiler logs. It helps to find some of our project''s performance deficiencies
    and inspect a native assembly output, as it''s just fun after all. Have a look
    at the following points:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: First, let's download an executable jar [http://www.chrisnewland.com/images/jitwatch.jar](http://www.chrisnewland.com/images/jitwatch.jar).
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to analyze an executable, we will need to run it with the following
    switches:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `UnlockDiagnosticVMOptions` parameter gives access to other diagnostic options,
    such as `SharedOptimizeColdStart`, `PauseAtStartup`, and so on.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `LogCompilation` logs compilation activity in detail to `hotspot.log` or
    `LogFile`, which is yet another VM option.
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `TraceClassLoading` parameter lets JVM ensure that all loaded classes are
    visible, even the ones without any JIT-compiled code related to them.
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `PrintAssembly` parameter lets us see the assembler output of the JIT compilation.
    It uses `hsdis`, a HotSpot disassembler, which is a part of OpenJDK.
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the analyzer:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You will see the following screen:'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Visualizing JIT logs](img/8405OT_08_22.jpg)'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Open your `hotspot.log` and, then press **Start**.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enjoy the experience.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Securing your javadocs
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will try to eliminate a javadoc vulnerability (CVE-2013-1571) that seems
    to exist in Java releases before 7u22.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To do that, we will need to clone a repository, such as:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Build the project
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We will try to scan a directory for potential vulnerabilities. We will run
    the following command from the directory in which the `JavadocPatchTool.jar` file
    is located:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If the tool finds any applicable HTML files, it will print out a list of such
    files.
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To fix a single applicable file, we will run the following command:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: java -jar JavadocPatchTool.jar <path>
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, `<path>` is the path to the directory which contains the applicable file.
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To fix all the applicable files in the tree, run the following command:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Tip
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn about more benefits from the AdoptOpenJDK project, visit the appropriate
    page at [https://java.net/projects/adoptopenjdk/pages/Benefits](https://java.net/projects/adoptopenjdk/pages/Benefits).
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JIT log visualizer is no more than a tool to process logs generated by OpenJDK.
    But it is a very useful tool that may significantly improve performance.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Java is used in various projects that need security, so the vulnerability in
    javadocs has an impact on those who still use Java 6 and are unable to change
    it to Java 7\. So the tool that fixes it with no transitions in the technology
    is really invaluable.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many more projects in AdoptOpenJDK. Most of them are evangelist or
    testing ones; thus, they are slightly beyond the scope of this book.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: However, you can always find them on various AdoptOpenJDK sites. There is no
    need to mention all of them in this book, they are tightly linked. In order to
    find them, it is sufficient to just look around.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
