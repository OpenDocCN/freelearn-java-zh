- en: Chapter 8. Hacking OpenJDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the development environment with NetBeans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Mercurial forests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding OpenJDK 6 and 7 incremental builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging Java code using NetBeans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging C++ code using NetBeans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using NetBeans to compile HotSpot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using HotSpot dev parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding new intrinsic to HotSpot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building VisualVM from the source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a plugin for VisualVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting benefits from the AdoptOpenJDK project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The real beauty of OpenJDK is its open nature, which means that developers can
    not only use it to run an application, but also change it to their needs or contribute
    to its development. The availability of the source code and ease of access to
    it opens huge opportunities to individuals who have special requirements, or just
    want to learn more about the way JVM works internally and want to adapt it for
    any special requirements. This chapter will help you to get into it and provide
    some recipes to make the process of setting up the required development environment
    as easy as possible.
  prefs: []
  type: TYPE_NORMAL
- en: At first, it will cover how to set up the development environment and which
    tools are required to get started. It will cover the IDE setup, and some tweaks
    required to launch JVM and start debugging. The next step is to make changes and
    rebuild the code, and the latter is going to be slightly different from the normal
    build described in [Chapter 5](ch05.html "Chapter 5. Building IcedTea"), *Building
    IcedTea*, [Chapter 6](ch06.html "Chapter 6. Building IcedTea with Other VM Implementations"),
    *Building IcedTea with Other VM Implementations*, and [Chapter 7](ch07.html "Chapter 7. Working
    with WebStart and the Browser Plugin"), *Working with WebStart and the Browser
    Plugin*. The rest of that section dedicated to will be useful techniques which
    can be used to debug changes.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter assumes that the reader has a reasonable knowledge of C++ and Java.
    Any knowledge of JVM is ideal, as the reader should know what JIT is and how it
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the recipes in the JIT section are independent and can be executed separately,
    so the reader just can pick what he/she needs and proceed with it.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the development environment with NetBeans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will cover the steps required to install, run, and set up the project
    in NetBeans IDE. NetBeans is an open source IDE for developing, primarily in Java.
    It also has rich support for C++ and that makes it a good tool for OpenJDK development
    which uses both languages. This recipe uses NetBeans IDE v.7.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Download the latest version of the NetBeans `All` bundle for your platform from
    [http://www.netbeans.org/downloads](http://www.netbeans.org/downloads). The `All`
    bundle must have C/C++ and Java support in the same IDE. It is also necessary
    to have the OpenJDK code checked out and available on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that everything is set up for the OpenJDK build and it can be executed
    without errors. How to do that is described in [Chapter 2](ch02.html "Chapter 2. Building
    OpenJDK 6"), *Building OpenJDK 6*, [Chapter 3](ch03.html "Chapter 3. Building
    OpenJDK 7"), *Building OpenJDK 7*, and [Chapter 4](ch04.html "Chapter 4. Building
    OpenJDK 8"), *Building OpenJDK 8*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will install and configure the NetBeans IDE that is used in the OpenJDK project
    as the standard one.
  prefs: []
  type: TYPE_NORMAL
- en: First we need to install the NetBeans IDE. This is a very simple process which
    consists of a few simple steps. Run the downloaded executable and at the bottom
    of the first screen, select the **Customize** button. This will show following
    window:![How to do it...](img/8405OT_08_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that **Base IDE**, **Java SE**, **C/C++**, and **Features on Demand**
    are selected. The rest are optional and not required to run and debug OpenJDK,
    but there is no harm in installing that functionality.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After the setup, all plugins you should update to the latest version. Updates
    are available via the **Help/Check for updates** menu item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When NetBeans is set up, it is required to make a slight change to its configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'OpenJDK is a big project and its memory requirements are bigger than the ones
    defined in the default settings. To increase the memory available for IDE:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Go to the `$HOME/.netbeans/NETBEANS_VERSION/etc` folder (on Windows `$HOME`
    is `%HOMEPATH%`).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the folder doesn't exist, create it.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, if that folder doesn't have the `netbeans.conf` file, copy it from the
    Netbeans installation directory, which is located in the `etc` folder.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the file with any text editor and locate the `netbeans_default_options`
    parameter which it should look similar to this:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: When the parameter is located, add `-J-Xmx2g`, or, if that option is already
    present, update it to a value not less than `2G` (2 gigabytes). This will increase
    the memory available to JDK to `2G`. Restart your IDE if it was running before
    in order to apply that change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: It is worth adding that, because of the large memory requirement of Netbeans
    IDE, It's recommended to run it on a system that is capable of providing nothing
    less than 2 GB of memory to the process. Basically, it means that it should be
    a machine with a 64-bit OS and about 4 to 6 GB of RAM.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now Netbeans IDE is ready for the project to be set up. Run it and go to **File**
    | **New Project** on the dialog box and select **C/C++ Project with Existing Sources**:![How
    to do it...](img/8405OT_08_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then press **Next** and, on the following dialog box, select the folder with
    the root of OpenJDK sources:![How to do it...](img/8405OT_08_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can always obtain your OpenJDK code by typing `hg clone http://hg.openjdk.java.net/jdk6/jdk6
    && ./get_source.sh`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press **Finish** and Netbeans will attempt to clean and build the project. Clean,
    most probably, will execute without problems, but build will not work because
    it requires some environment setup, which we will do later on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After trying to build the project, Netbeans will spend a fair bit of time (minutes)
    scanning sources and building indexes. This would be a good time to have some
    coffee.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to configure Netbeans to build the project. As already mentioned,
    the build script requires some environment setup. The following is a simple bash
    script which can be used to create an appropriate environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the root folder of the OpenJDK source tree, create a file `build.sh` and
    save this script in that folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then navigate to the **Run** | **Set project configuration** | **Customize**
    menu item and, in the tree on the left-hand side, select **Build** | **Make**.
    There you will see the following dialog:![How to do it...](img/8405OT_08_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As shown in the screenshot, set the **Build Command** and **Clean Command**
    variables to execute your `./build.sh` with the `debug_build` and `clean` commands,
    respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `product` version of OpenJDK is required, then just create another configuration
    with `product_build` and the parameter for `build.sh`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Netbeans is not the only available IDE which supports both Java and C++. There
    are other IDEs which are similarly capable. One example is the Eclipse IDE which
    is also a powerful multiplatform IDE written in Java, and has similar functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Mercurial forest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mercurial is a cross-platform version control system. It was designed to work
    with big projects and large amounts of code, which undoubtedly are present in
    the OpenJDK project. The OpenJDK official repository is a Mercurial.
  prefs: []
  type: TYPE_NORMAL
- en: The Forest plugin is the one used for various OpenJDK subprojects to merge and
    coexist. It works with nested Mercurial repositories, which normally are regarded
    as isolated. The main idea is to propagate changes from the root repository to
    the nested ones.
  prefs: []
  type: TYPE_NORMAL
- en: The main purpose of it is to allow a developer to work with the code, which
    is a minor part of a full OpenJDK project repository, without needing to make
    any changes to the whole repository (change a revision number, for example).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, we will need to install Mercurial itself. On Windows it can be
    done by going to the official Mercurial site and downloading it from [http://mercurial.selenic.com/wiki/Download](http://mercurial.selenic.com/wiki/Download).
  prefs: []
  type: TYPE_NORMAL
- en: For Linux distributions, there are, usually, Mercurial versions in their official
    repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, on Debian and Debian-inherited distributions, Mercurial installs
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you have any problems with a Mercurial installation, refer to the official
    site or to your Linux distribution resources.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's explain it with a simple, non Java-related example. We will assume that
    a Mercurial instance already exists in the OS. Since Mercurial has a command line
    tool, we will use a command line for everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create two repositories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will need to locate the `.hgrc` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's copy the `forest.py` file from [https://bitbucket.org/gxti/hgforest/src](https://bitbucket.org/gxti/hgforest/src).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then let''s edit your `.hgrc` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now have a brand new `fclone` command in our repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s copy the first repository into the second one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `repo-two` repository isn't an integral part of `repo-one`, it only lays
    inside it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s clone a `repo-two` repository and attach `repo-one to it`, using the
    `fclone` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We've just copied `repo-two`, including `repo-two/one`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s make some changes to `repo-two/hello.txt` and `repo-two/one/hello.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will commit each change using a separate command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s push a result back to `repo-two`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will have two changed files in repo-one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s push one of them further to `repo-two`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, the changes from `repo-two/one` are propagated to `repo-one`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mercurial is a relatively simple control system. It is vastly extendable with
    different plugins, which are configured through the `.hgrc` file.
  prefs: []
  type: TYPE_NORMAL
- en: The Mercurial `forest` plugin propagates changes in nested repositories to the
    root ones, and synchronizes the parent repository content with a nested one.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding OpenJDK 6 and 7 incremental builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of OpenJDK compilation is very time consuming. It is very boring,
    especially when one is developing a small part of the whole project, which needs
    full recompilation for testing purposes. To do it in a simple way and to compile
    only the necessary parts, there are incremental builds.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to download the OpenJDK (6 or 7) source code. You may need `libmotif`
    installed. Windows users may need to install Cygwin.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will see how OpenJDK is built incrementally, avoiding adding any nasty bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s build OpenJDK for the first time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will take some time, so have a cup of tea.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we will build it for the second time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can see from the input that nothing was actually built.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, let's insignificantly change some source file (for example, `cardTableModRefBS.cpp`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s `make` OpenJDK again, but this time we will `grep` the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We see that, in the output, only two files are actually compiled, `hotspot/src/share/vm/memory/cardTableModRefBS.cpp`
    and `hotspot/src/share/vm/runtime/vm_version.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The build program checks the files that were updated and compiles only those
    which were updated after the last compiler run. However, if any `.hpp` files are
    modified, the build will be performed in clean mode, for example, no optimization
    will be performed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Weird things tend to happen while using incremental builds. The probability
    of such things is increased proportionally with build times.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are, basically, two ways to perform a clean build:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One cleans all files, and compilation from scratch becomes necessary:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The second is to specify parameters, which will force the clean mode of the
    build.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging Java code using NetBeans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Obviously, when someone is writing any code, some debugging is required. It
    is no surprise that NetBeans, as a high-standard IDE, provides some tools to do
    that. This recipe will show how to debug the Java code using NetBeans.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to install NetBeans and set up a development environment, as described
    previously in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use NetBeans to debug our own OpenJDK Java code. We will need to rebuild
    OpenJDK with debug symbols, and configure NetBeans to make debugging possible:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s make our OpenJDK instance with debug symbols:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s ensure that a debuggable version is built:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we have a debuggable OpenJDK. Let's set it as the default for NetBeans.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's open the `etc/netbeans.conf` file in your NetBeans installation path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will change one line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After that, we will launch NetBeans and ensure that our JDK is loaded correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will select **Tools** | **Java Platforms**, and the following screen will
    appear:![How to do it...](img/8405OT_08_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's try to debug the `java.lang.String` class. We will set our breakpoints
    to an unavoidable part of this class—to one of the constructors, as shown in the
    following screenshot:![How to do it...](img/8405OT_08_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This set of breakpoints is sufficient to hook up virtually every Java executable
    ever launched. But, if we decide to push things forward and attach a debugger,
    we will get an error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To avoid this, we need to specify our Java sources directly to NetBeans. Our
    project is a C++ project, and it tends to ignore the Java files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result for the `String` class will be as shown in the following screenshot:![How
    to do it...](img/8405OT_08_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, just launch some Java executable, that uses strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Attach the Java debugger, as shown:![How to do it...](img/8405OT_08_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enjoy, you can now see OpenJDK from the inside, in motion:![How to do it...](img/8405OT_08_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's just a debugger with a few simple nuances.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some Linux distributions, you can install debug versions of OpenJDK with
    sources provided in a ZIP file. These sources are automatically picked up by NetBeans.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging C++ code using NetBeans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you plan to make changes to HotSpot or any other C++ part of OpenJDK, then
    it is certain that you will need to do some step-by-step debugging of the code.
    This recipe will explain how to set up NetBeans IDE for that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, there are only a few things required—downloaded Open JDK sources
    and installed NetBeans IDE. It is assumed that the OpenJDK project is already
    set up and can build sources.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is to set up an executable that will run. Go to **Run** | **Set
    project configuration** / **Customize** and then **Build** | **Make**, and set
    **build/linux-amd64-debug/hotspot/outputdir/linux_amd64_compiler2/jvmg/gamma**
    as the build result, as shown in the following screenshot:![How to do it...](img/8405OT_08_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then select the **Run** option on the tree on the left had side and set **Run
    Command** as **"${OUTPUT_PATH}" –version**:![How to do it...](img/8405OT_08_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `–version` flag here is just the simplest thing you can run—get the Java
    version. You can later change it to whatever you want, for example, to run a Java
    program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to set up some environment variables required for Java to run.
    This can be done by setting them up in the **Environment** section as shown in
    the following dialog. Set `LD_LIBRARY_PATH` to `build/linux-amd64-debug/hotspot/outputdir/linux_amd64_compiler2/jvmg`
    and `JAVA_HOME` to `build/linux-amd64-debug/j2sdk-server-image`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now it's all ready to debug. To check that it works, set a breakpoint in `hotspot/src/share/tools/launcher/java.c`
    somewhere at the beginning of the `main` function and go to **Debug** | **Debug
    Main Project** or use the shortcut *Ctrl* + *F5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Careful readers may have noticed that **Debug** used `gamma` JVM launcher, instead
    of `java`, which is used when you run Java normally. This is to simplify things;
    `gamma` is the lightweight version of `java`, it doesn't perform checks which
    are not necessary for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Using NetBeans to compile HotSpot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When doing HotSpot development, it is very annoying to wait for a complete OpenJDK
    build to be executed. So, it makes sense to exclude other parts and compile just
    what we are interested in, that is, the HotSpot part. This recipe will explain
    how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The only prerequisite for this recipe is the availability of source code on
    the machine, and Netbeans installed, with an OpenJDK project created.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a very simple recipe to follow. If you have already completed *Setting
    up development environment with NetBeans*, the only thing which is required to
    be done is to change the argument `hotspot_build` and add another argument `DEBUG_NAME=debug`,
    the whole build command line should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The **Build/Make** screen of the **Project Properties** dialog in that case
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/8405OT_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Luckily, there are targets created in the `make` configuration which only built
    the HotSpot bit. These targets can be located in the `./make/hotspot-rules.gmk`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The `debug` command which creates the non-optimized version or the HotSpot,
    is not the only option for the `DEBUG_NAME` variable. The `fastdebug` command
    is the other option in which build will create an optimized version with assertions.
    When `DEBUG_NAME` is not set, the product version of HotSpot is built.
  prefs: []
  type: TYPE_NORMAL
- en: Using HotSpot dev parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HotSpot has other options, which may significantly change its behavior. Here
    we will make use of some of these options, which are used only on the dev versions
    of OpenJDK.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will need to compile a dev OpenJDK version, in order to use the dev options.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use parameters that are available in the developer version of OpenJDK.
    In the production builds, they are disabled or set as constant values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make use of these parameters, we will run Java as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a list of some usable dev options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`InlineUnsafeOps`: This option will, if enabled, inline native memory operations
    from `sun.misc.Unsafe`. It may offer some performance improvements in some cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DieOnSafepointTimeout`: This option will kill the process if the safepoint
    is not reached, but the timeout is exceeded. It is disabled by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZapResourceArea`: This option will zap freed resource / arena space with `0xABABABAB`.
    It is true in debug mode, but is deselected in production VMs. It may be used
    for really paranoid security reasons, though it has some performance impact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZapJNIHandleArea`: This option will zap freed JNI handle space with `0xFEFEFEFE`.
    It only has a debug value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZapUnusedHeapArea`: This option will zap unused heap space with `0xBAADBABE`.
    It may be used for security reasons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Verbose`: This option prints additional debugging information from other modes.
    It is the main logging option of the dev HotSpot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UsePrivilegedStack`: This option enables the security JVM functions. It is
    `true` by default, but in dev mode, you still have the opportunity to run HotSpot
    with disabled security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MemProfiling`: This option writes memory usage profiling to logfile. It is
    `false` by default, and can be run for some memory profiling issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VerifyParallelOldWithMarkSweep`: This option will use the `MarkSweep` GC code
    to verify phases of the parallel old. It may be used for debugging purposes when
    changing the JVM memory handling mechanism.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScavengeWithObjectsInToSpace`: This option is really interesting. Java uses
    two-space GC, where survivor space is concerned, and this options allows scavenges
    to occur when `to_space` contains objects. Also, when doing so, it clears an unused
    area, if `ZapUnusedHeapArea` is enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FullGCALot`: This option forces full GC at every *Nth* exit from the runtime
    system (`N=FullGCALotInterval`). It may be a very expensive operation, but some
    developers may build it into JDKs for desktop use. It may be cheaper than to use
    swap space to absorb endless megabytes from the overgrown heap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AdaptiveSizePolicyReadyThreshold`: This option is the number of collections
    before adaptive sizing is started. The default is `5`, but it may make sense to
    make it `1` on desktop systems since the biggest bottleneck of those is the swap
    space, especially if several Java programs are running simultaneously on one machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EagerInitialization`: This option eagerly initializes classes if possible.
    It is `false` by default, so maybe it is unsafe to turn it on. But the idea seems
    good, especially on server machines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GuaranteedSafepointInterval`: This option guarantees a safepoint (at least)
    every few milliseconds (`0` means none). The default is `1000`. It may be used
    to tweak the stop-the-world state problem. The bigger the option value, the longer
    these stops will be; and if we make the value too small, we will have too many
    unnecessary stops.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MaxTrivialSize`: This option is the maximum bytecode size of a trivial method
    to be inline. It is `6` by default. It is similar to the C++ compiler inline options,
    but for the bytecode compiler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MinInliningThreshold`: This option is the minimal invocation count a method
    needs to have to be inline. It is `250` by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SharedOptimizeColdStartPolicy`: This option is the reordering policy for `SharedOptimizeColdStart`.
    The `0` value favors the classload-time locality, `1` uses a balanced policy,
    and `2` favors runtime locality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default is `2` and it is rarely necessary to change it, but in some cases
    it will make sense to make it `1` if your application has too many classes that
    may load after the application starts.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new intrinsic to HotSpot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Intrinsic is a function whose implementation is handled specially by a compiler.
    Typically, it means that the function call is replaced by automatically generated
    instructions. This is very similar to the inline functions, but the compiler knows
    more about intrinsics as they are part of the compiler itself, so it can use them
    more wisely.
  prefs: []
  type: TYPE_NORMAL
- en: Intrinsics are usually more performance-oriented than native functions because
    there is no JNI overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, all we need is an installed NetBeans IDE for code editing and
    OpenJDK sources. The user should be able to read C++ code and a little knowledge
    of assembly would be beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: It would be worth checking that SSE4.2 (an extended instruction set with six
    new commands, mostly for character searching and comparison) is supported by the
    CPU (the `CRC32` command used in our example is from that command set). It was
    introduced with Core i7 Intel chips back in 2009, so if you are using an Intel
    CPU, it should be present. The first time it was introduced for AMD was as Bulldozer
    chips back in 2011, so you should have relatively recent chips to support it.
    If your CPU is not compatible with that command, do not worry. The recipe is applicable
    to any intrinsics you may want to introduce; there is no difference, apart from
    the actual implementation of the code you want to intrinsify.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding new intrinsics is not a simple process. Follow these instructions carefully.
    Ensure you compile the code after every step; doing so may save some time.
  prefs: []
  type: TYPE_NORMAL
- en: The instruction which we are going to intrinsify is the CRC32 calculation, which
    is implemented by `java.util.zip.CRC32`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let''s make a small amendment to the Java class that is responsible
    for the CRC32 calculation. We are going to add a method which will be intrinsified
    by HotSpot. Open the `jdk/src/share/classes/java/util/zip/CRC32.java` file and
    add a new method `doUpdateBytes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: That implementation just makes a call to the currently used `updateBytes` native
    method. That's the only change in Java. The rest is going to be the C++ internals
    of the HotSpot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `hotspot/src/share/vm/precompiled/precompiled.hpp` file and add the
    following line into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `smmintrin.h` file contains GCC intrinsics, which are going to be used by
    our implementation of the CRC32 function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, as we are using SSE4.2 instructions, we need to inform the compiler.
    To do so, open the `hotspot/make/linux/makefiles/gcc.make` file (assuming you
    are making the build on Linux), and locate the line consisting of `CFLAGS += -fno-rtti`.
    Just after that line, add the `-msse4.2` flag, so it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to implement our CRC32 function in C++. In the `hotspot/src/cpu/x86/vm/`
    folder, create the `CRC32Calc` class and the `static_calcCrc32` static method.
    Here is the `CRC32Calc.hpp` file with the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CRC32Calc.cpp` file with its implementation is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The following instructs HotSpot how to intrinsify our method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate `hotspot/src/share/vm/classfile/vmSymbols.hpp`. That is the file which
    contains the declaration of all intrinsics and add the following definition to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is the declaration of intrinsics which maps the Java method with the code
    which will replace it in the runtime. Be careful when adding it. It is based on
    macros, which means, if there is a typo or any other mistake, it will be very
    hard to figure out where the problem is.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to define which code we are going to generate for the intrinsic.
    We are not going to be very smart here, as this is just an exercise to see how
    the functionality works. So all our assembler is going to do is generate a call
    to the C function. Add the following into `hotspot/src/cpu/x86/vm/stubGenerator_x86_64.cpp`
    and `hotspot/src/cpu/x86/vm/stubGenerator_x86_32.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s a bit tricky and requires some low-level code. We are going to tell
    HotSpot how to generate the assembly for our method. To do so, add the `generator`
    method into the `StubGenerator` class which is declared in both `hotspot/src/cpu/x86/vm/stubGenerator_x86_64.cpp`
    and `hotspot/src/cpu/x86/vm/stubGenerator_x86_32.cpp` for x86_64 and x86 architectures
    respectively. The code for the method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need a variable which will contain the address of the generated method.
    To do so, add the following static member declaration to `hotspot/src/share/vm/runtime/stubRoutines.hpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To the same file, add the following method, which just returns the value of
    the declared variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `hotspot/src/share/vm/runtime/stubRoutines.cpp`, assign a default
    value to `_crc32_doUpdateBytes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in both `hotspot/src/cpu/x86/vm/stubGenerator_x86_64.cpp` and `hotspot/src/cpu/x86/vm/stubGenerator_x86_32.cpp`,
    locate the `generate_all` method and assign the following value to the variable
    `_crc32_doUpdateBytes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to add the method which creates a descriptor. The descriptor
    is the definition of our function—how many arguments it takes, which types of
    arguments it accepts, and so on. The first step is to add the method declaration
    into the `OptoRuntime` class in the `hotspot/src/share/vm/opto/runtime.hpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be the function which creates the type information for our method
    call—it describes the arguments and returns the parameters. After implementation
    it creates an array of types of input parameters and the type of the return value.
    Place it in the `hotspot/src/share/vm/opto/runtime.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will implement the method that will inline the code in the runtime.
    In the `hotspot/src/share/vm/opto/library_call.cpp` file, locate the definition
    of the `LibraryCallKit` class, and add the following method declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, in the same file, add the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Finally tell HotSpot that we indeed want to intrinsify our method call and make
    a call to the inlining method `inline_crc32`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To tell HotSpot that we want to intrinsify the method, `Compile::make_vm_intrinsic`
    method in the file `hotspot/src/share/vm/opto/library_call.cpp` has to return
    a non-null pointer to `CallGenerator`. To do so, add the following line into the
    `switch(id)` switch statement in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It is not strictly required to have that case and break, the default works just
    well; but it makes it more explicit that we are using intrinsics for the CRC32
    calculation method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to make a call to the inlining method, in the same `hotspot/src/share/vm/opto/library_call.cpp`
    file, locate `LibraryCallKit::try_to_inline`, find `switch (intrinsic_id())`,
    and add the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To check whether the method was intrinsified, use the `-XX:+PrintCompilation`
    and `-XX:+PrintInlining` Java arguments. To see what the intrinsics are compiled
    into, use `-XX:+PrintAssembly` (this should be prepended by `-XX:+UnlockDiagnosticsVMOptions`
    when running on the product build).
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see if SSE4.2 is supported, just compile and run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'There are lots of intrinsic methods. See `library_call.cpp` and `vmSymbols.hpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.getClass` gives one or two instructions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Class.isInstance` and `Class.isAssignableFrom` are as cheap as instances of
    bytecodes when the operands are constants, and otherwise no more expensive than
    aastore type checks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most single-bit class queries are cheap and even constant-foldable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflective array creation is about as cheap as the `newarray` or `anewarray`
    instructions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.clone` is cheap and shares code with `Arrays.copyOf` (after Java6).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java is not the only language which uses intrinsics they are also widely used
    in C++ for SSE operations.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, `_mm_crc32_u32` and `_mm_crc32_u8` are intrinsics themselves,
    known by the GCC or MS compiler, which are directly replaced by assembly instructions
    in the compiled code.
  prefs: []
  type: TYPE_NORMAL
- en: Building VisualVM from the source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: VisualVM is an open source project which is not a part of OpenJDK. It is a powerful
    tool which is helpful to anyone who uses applications based on JDK. It allows
    us to monitor parameters of the system, browse heap dumps, create thread dumps,
    and so on. As the tool is open source, it is possible to get the source code and
    customize it as required, or simply just to see how it works. This recipe will
    go through the steps which are required to download the source code and build
    VisualVM from it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires a machine with Subversion and Ant installed. Also, as VisualVM
    is a graphical application, a graphical environment is required to run it. It
    is possible to perform a build without launching the application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is to get the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder for the sources, for example, `/home/user/visualvm`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the newly created folder and, assuming you need sources from the `trunk`,
    run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will create the `trunk` folder with sources in the current directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To start, we need to download the NetBeans Platform binaries. The version needed
    depends on the version of VisualVM we are going to build. In this example, we
    will use `trunk`, the current development version which requires NetBeans Platform
    v.8; but as that may change, it is recommended to consult the page for the appropriate
    version using the link [http://visualvm.java.net/build.html](http://visualvm.java.net/build.html).
    These binaries are available directly from the VisualVM website, not from the
    NetBeans website. For this example, the URL is [https://java.net/projects/visualvm/downloads/download/dev/nb80_visualvm_27062014.zip](https://java.net/projects/visualvm/downloads/download/dev/nb80_visualvm_27062014.zip).
    When the file is downloaded, unpack it into the `trunk/visualvm` folder, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: Now, execute Ant to run the build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the build is complete, we should see something similar to the following
    output in the command prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This indicates that the build was successful. This step is not required if we
    just need to run VisualVM, as Ant will also run the build target; but if there
    is no need to run, and just build is required, this step can be useful.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To run VisualVM, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the application is not built yet, then Ant will build it first and then run
    it. As VisualVM is a GUI application, we will see the following screen:![How to
    do it...](img/8405OT_08_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the landing screen of VisualVM. The fact that we can see it means that
    the application is built and works properly. The zipped archive file with the
    distribution can be found in the `visualvm/dist` folder.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More information about VisualVM build is available on the home page [http://visualvm.java.net/build.html](http://visualvm.java.net/build.html).
    Each version has a different page, as build instructions vary from version to
    version. For example, each build may require a slightly different version of the
    Netbeans platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a plugin for VisualVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: VisualVM is just an application which has a predefined and limited set of features.
    It is a framework, which means that it is possible to extend it. The way in which
    VisualVM provides for extension is via the plugin API which allows us to create
    new plugins which are then available through the application. Such plugins can
    do various things, but are mostly used to provide new ways of monitoring or controlling
    the JVM applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The current (at the time of writing) trunk version of VisualVM requires the
    NetBeans platform and IDE v.8\. So we need to ensure that the current version
    of the platform is available on the machine. If there is any doubt, check the
    page with VisualVM trunk build instructions at [http://visualvm.java.net/build/build.html](http://visualvm.java.net/build/build.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with what we are going to monitor. It seems like the simplest
    thing we can do is to build a component which will tick the data that we can read.
    For example, look at the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This code sleeps for 100 ms and measures how long it actually slept. The value
    is not going to be exact, but will be about `100`. It publishes the last measurement
    of the sleep time via the `lastSleepSample` variable which is available via the
    `SleepProbeMBean` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This class and interface should be put into a separate project, so you can
    run them independently of the VirtualVM plugin project:'
  prefs: []
  type: TYPE_NORMAL
- en: To start, we need to create a plugin project in IDE. Launch the IDE, go to **File**
    | **New Project** and select **NetBeans Platform Application** from the project
    type:![How to do it...](img/8405OT_08_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, select **VisualVM** as the **NetBeans Platform** (if it
    is not available, see further instructions), the project name, and the location,
    as shown:![How to do it...](img/8405OT_08_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If **VisualVM** is not available in the list of platforms, then click on the
    Manage icon and, in the displayed dialog, add a new platform by pointing it to
    the folder with the VisualVM distribution, as shown in the following screenshot:![How
    to do it...](img/8405OT_08_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this example, the distribution was built from source (see the *Building VisualVM
    from the source code* recipe). Press **Next** and then **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now just complete the wizard and you will have a new empty project with some
    properties and build script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that there is a known bug in some versions of NetBeans ([https://netbeans.org/bugzilla/show_bug.cgi?id=242564](https://netbeans.org/bugzilla/show_bug.cgi?id=242564)),
    which is causing problem with dependencies and which will not allow us to add
    the required dependencies later. To work around this, right click on the project
    and then click on **Properties**. On the **Project Properties** dialog, select
    **Libraries**:![How to do it...](img/8405OT_08_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck **JavaFX wrapper** under the platform component. Ensure that all the
    other checkboxes are checked, including **profiles** and **visualvm** nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to create a module for our plugin. Right click on the **Modules**
    item in the project tree and select **Add New…**:![How to do it...](img/8405OT_08_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it as `SamplingModule` and press **Next**. On the next screen, put `net.cookbook.openjdk`
    as `Code Name Base` and press on **Finish**. This will create an empty module
    where we will need to add some components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to add the dependencies to the module. Right click on the module
    and select **Properties**, then go to **Libraries** | **Module Dependencies**,
    and click on **Add Dependency**. On the **Add Module Dependency** dialog, put
    `VisualVM` into the **Filter** field as shown:![How to do it...](img/8405OT_08_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **VisualVM-Application**, **VisualVM-Core**, and **VisualVM-Tools** (not
    visible on the screenshot), then click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to add the installer and some source code. To do so, right
    click on the newly created module and go to **New** | **Other**. This will show
    the dialog with the option to select the file type. Click on **Installer/Activator**
    and click on **Next**, as shown:![How to do it...](img/8405OT_08_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then just complete the wizard by clicking on **Finish**. This will create a
    class with the name `Installer` in the package `net.cookbook.openjdk`. For now,
    leave that class as it is, we will update it later in the recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to create a component which will draw a graph for us. To do
    so, we will create a simple panel which will refresh itself every half a second
    with a new sample from the sampler `MBean`. In the `net.cookbook.openjdk` package,
    create a new class and name it as `SamplingGraphPanel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class will read a value from the `MBean` implements on the first step of
    this receipt every 500ms, and add the value to the list with samples. Then it
    refreshes the graph, which gets repainted. Fundamentally, that code is just a
    Java Swing code, which can be run in any application. The only VisualVM-specific
    bit here is some helper classes used to get `MBean` from the `Application` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, in `SamplingModule`, create a class which will be responsible for showing
    the data. Name it `SamplingView` and put it into the `net.cookbook.openjdk` package,
    as shown below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is important that the file referenced by `IMAGE_PATH` actually exists, otherwise
    the plugin will not start and will fail with an exception. The simplest way you
    can do this is to download any of available free icons from the Internet, for
    example at [https://www.iconfinder.com/icons/131715/download/png/32](https://www.iconfinder.com/icons/131715/download/png/32)
    and put it into the same package folder as the `SamplingView` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to create a provider which will create the view instance and
    identify that the application we are connected to is supported by the plugin.
    In the `net.cookbook.openjdk` package, create a class with the name `SamplingProvider`
    and with the following implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The main methods of this class are `supportsViewFor` and `createView`. The `createView`
    method is small and easy, it just creates a view instance and passes through the
    application so that the view can get data out of it. The `supportsViewFor` class
    is slightly bigger, but it doesn't really match. It connects to the given application
    via JMX and tries to get the instance of `MBean` which our plugin is interested
    in. If `MBean` is not there, it means that the application is not supported and
    the method returns `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now it is time to see how the plugin works. To do this, first start the application
    created on the first step of this receipt. Then right-click on **SamplingModule**
    and select **Run**. This will start VisualVM with our plugin. From the list of
    processes in VisualVM, select our process and click on the **Sampling Application**
    tab. There you will see our graph showing slight changes in the sleep time as
    shown in the following screenshot:![How to do it...](img/8405OT_08_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After following these steps, it should not be a problem for the reader to extend
    this example and use it for any kind of monitoring applications that he/she wants
    in VisualVM.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is some documentation available on the VisualVM website, which helps with
    creating the plugin for VisualVM and which covers, in more detail, some classes
    which are used in this receipt, at [http://visualvm.java.net/api-quickstart.html](http://visualvm.java.net/api-quickstart.html).
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth having a look at existing plugins source code and some samples
    available. These can be found in `<code_root>/plugins` and `<code_root>/samples`
    respectively. For instructions on how to download the source code, please see
    the *Building VisualVM from the source code* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting benefits from the AdoptOpenJDK project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AdoptOpenJDK is a program, initially developed by a small group of enthusiasts,
    but which became part of an official OpenJDK community. Some of the purposes are
    to clarify and simplify OpenJDK building, installation, and usage, but there is
    still more. It provides build automation, a report generator, build testing, and
    more. We will cover some basic features that will be useful for everyone.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To follow this recipe, we will need an OpenJDK instance installed, and an Internet
    connection established.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AdoptOpenJDK is a very helpful and a very sophisticated project set with quite
    a few different subprojects. Many of them concern testing and evangelism, so we
    could not include them here as recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing JIT logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is a project named Jitwatch in AdoptOpenJDK. Its purpose is to visualize
    JIT compiler logs. It helps to find some of our project''s performance deficiencies
    and inspect a native assembly output, as it''s just fun after all. Have a look
    at the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's download an executable jar [http://www.chrisnewland.com/images/jitwatch.jar](http://www.chrisnewland.com/images/jitwatch.jar).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to analyze an executable, we will need to run it with the following
    switches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `UnlockDiagnosticVMOptions` parameter gives access to other diagnostic options,
    such as `SharedOptimizeColdStart`, `PauseAtStartup`, and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `LogCompilation` logs compilation activity in detail to `hotspot.log` or
    `LogFile`, which is yet another VM option.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `TraceClassLoading` parameter lets JVM ensure that all loaded classes are
    visible, even the ones without any JIT-compiled code related to them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `PrintAssembly` parameter lets us see the assembler output of the JIT compilation.
    It uses `hsdis`, a HotSpot disassembler, which is a part of OpenJDK.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the analyzer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following screen:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Visualizing JIT logs](img/8405OT_08_22.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Open your `hotspot.log` and, then press **Start**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enjoy the experience.
  prefs: []
  type: TYPE_NORMAL
- en: Securing your javadocs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will try to eliminate a javadoc vulnerability (CVE-2013-1571) that seems
    to exist in Java releases before 7u22.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To do that, we will need to clone a repository, such as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the project
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will try to scan a directory for potential vulnerabilities. We will run
    the following command from the directory in which the `JavadocPatchTool.jar` file
    is located:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the tool finds any applicable HTML files, it will print out a list of such
    files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To fix a single applicable file, we will run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: java -jar JavadocPatchTool.jar <path>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, `<path>` is the path to the directory which contains the applicable file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To fix all the applicable files in the tree, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn about more benefits from the AdoptOpenJDK project, visit the appropriate
    page at [https://java.net/projects/adoptopenjdk/pages/Benefits](https://java.net/projects/adoptopenjdk/pages/Benefits).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JIT log visualizer is no more than a tool to process logs generated by OpenJDK.
    But it is a very useful tool that may significantly improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: Java is used in various projects that need security, so the vulnerability in
    javadocs has an impact on those who still use Java 6 and are unable to change
    it to Java 7\. So the tool that fixes it with no transitions in the technology
    is really invaluable.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many more projects in AdoptOpenJDK. Most of them are evangelist or
    testing ones; thus, they are slightly beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: However, you can always find them on various AdoptOpenJDK sites. There is no
    need to mention all of them in this book, they are tightly linked. In order to
    find them, it is sufficient to just look around.
  prefs: []
  type: TYPE_NORMAL
