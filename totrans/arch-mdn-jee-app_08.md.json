["```java\n{\n    \"identifier\": \"<car-identifier>\",\n    \"engine-type\": \"<engine-type>\",\n    \"color\": \"<chassis-color>\"\n}\n```", "```java\npublic abstract class MealEvent {\n\n    private final Instant instant;\n\n    protected MealEvent() {\n        instant = Instant.now();\n    }\n\n    protected MealEvent(Instant instant) {\n        Objects.requireNonNull(instant);\n        this.instant = instant;\n    }\n\n    ...\n}\n\npublic class OrderPlaced extends MealEvent {\n\n    private final OrderInfo orderInfo;\n\n    public OrderPlaced(OrderInfo orderInfo) {\n        this.orderInfo = orderInfo;\n    }\n\n    public OrderPlaced(OrderInfo orderInfo, Instant instant) {\n        super(instant);\n        this.orderInfo = orderInfo;\n    }\n\n    ...\n}\n```", "```java\n@Singleton\npublic class OrderEventHandler {\n\n    @Inject\n    MealPreparationService mealService;\n\n    public void handle(@Observes OrderPlaced event) {\n        mealService.prepareMeal(event.getOrderInfo());\n    }\n}\n```", "```java\npublic class MealPreparationService {\n\n    @Inject\n    EventProducer eventProducer;\n\n    @Inject\n    IngredientStore ingredientStore;\n\n    public void prepareMeal(OrderInfo orderInfo) {\n\n        // use ingredientStore to check availability\n\n        if (...)\n            eventProducer.publish(new OrderFailedInsufficientIngredients());\n        else\n            eventProducer.publish(new MealPreparationStarted(orderInfo));\n    }\n}\n```", "```java\n@Stateless\npublic class MealOrders {\n\n    @PersistenceContext\n    EntityManager entityManager;\n\n    public MealOrder get(UUID orderId) {\n        return entityManager.find(MealOrder.class, orderId.toString());\n    }\n\n    public void apply(@Observes OrderPlaced event) {\n        MealOrder order = new MealOrder(event.getOrderInfo());\n        entityManager.persist(order);\n    }\n\n    public void apply(@Observes OrderStarted event) {\n        apply(event.getOrderId(), MealOrder::start);\n    }\n\n    public void apply(@Observes MealDelivered event) {\n        apply(event.getOrderId(), MealOrder::deliver);\n    }\n\n    private void apply(UUID orderId, Consumer<MealOrder> consumer) {\n        MealOrder order = entityManager.find(MealOrder.class, orderId.toString());\n        if (order != null)\n            consumer.accept(order);\n    }\n}\n```", "```java\n@Entity\n@Table(\"meal_orders\")\npublic class MealOrder {\n\n    @Id\n    private String orderId;\n\n    @Embedded\n    private MealSpecification specification;\n\n    @Enumerated(EnumType.STRING)\n    private OrderState state;\n\n    private MealOrder() {\n        // required for JPA\n    }\n\n    public MealOrder(OrderInfo orderInfo) {\n        orderId = orderInfo.getOrderId().toString();\n        state = OrderState.PLACED;\n\n        // define specifications\n    }\n\n    public void start() {\n        state = OrderState.STARTED;\n    }\n\n    public void deliver() {\n        state = OrderState.DELIVERED;\n    }\n\n    ...\n}\n```", "```java\n@Startup\n@Singleton\npublic class OrderUpdateConsumer {\n\n    private EventConsumer eventConsumer;\n\n    @Resource\n    ManagedExecutorService mes;\n\n    @Inject\n    Properties kafkaProperties;\n\n    @Inject\n    Event<MealEvent> events;\n\n    @PostConstruct\n    private void init() {\n        String orders = kafkaProperties.getProperty(\"topic.orders\");\n\n        eventConsumer = new EventConsumer(kafkaProperties,\n                ev -> events.fire(ev), orders);\n\n        mes.execute(eventConsumer);\n    }\n\n    @PreDestroy\n    public void close() {\n        eventConsumer.stop();\n    }\n}\n```", "```java\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport java.util.function.Consumer;\nimport static java.util.Arrays.asList;\n\npublic class EventConsumer implements Runnable {\n\n    private final KafkaConsumer<String, MealEvent> consumer;\n    private final Consumer<MealEvent> eventConsumer;\n    private final AtomicBoolean closed = new AtomicBoolean();\n\n    public EventConsumer(Properties kafkaProperties,\n            Consumer<MealEvent> eventConsumer, String... topics) {\n        this.eventConsumer = eventConsumer;\n        consumer = new KafkaConsumer<>(kafkaProperties);\n        consumer.subscribe(asList(topics));\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!closed.get()) {\n                consume();\n            }\n        } catch (WakeupException e) {\n            // will wakeup for closing\n        } finally {\n            consumer.close();\n        }\n    }\n\n    private void consume() {\n        ConsumerRecords<String, MealEvent> records =\n                consumer.poll(Long.MAX_VALUE);\n        for (ConsumerRecord<String, MealEvent> record : records) {\n            eventConsumer.accept(record.value());\n        }\n        consumer.commitSync();\n    }\n\n    public void stop() {\n        closed.set(true);\n        consumer.wakeup();\n    }\n}\n```", "```java\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\n\n@ApplicationScoped\npublic class EventProducer {\n\n    private Producer<String, MealEvent> producer;\n    private String topic;\n\n    @Inject\n    Properties kafkaProperties;\n\n    @PostConstruct\n    private void init() {\n        producer = new KafkaProducer<>(kafkaProperties);\n        topic = kafkaProperties.getProperty(\"topics.order\");\n        producer.initTransactions();\n    }\n\n    public void publish(MealEvent event) {\n        ProducerRecord<String, MealEvent> record = new ProducerRecord<>(topic, event);\n        try {\n            producer.beginTransaction();\n            producer.send(record);\n            producer.commitTransaction();\n        } catch (ProducerFencedException e) {\n            producer.close();\n        } catch (KafkaException e) {\n            producer.abortTransaction();\n        }\n    }\n\n    @PreDestroy\n    public void close() {\n        producer.close();\n    }\n}\n```", "```java\npublic class OrderService {\n\n    @Inject\n    EventProducer eventProducer;\n\n    public void orderMeal(OrderInfo orderInfo) {\n        eventProducer.publish(new OrderPlaced(orderInfo));\n    }\n\n    void cancelOrder(UUID orderId, String reason) {\n        eventProducer.publish(new OrderCancelled(orderId, reason));\n    }\n\n    void startOrder(UUID orderId) {\n        eventProducer.publish(new OrderStarted(orderId));\n    }\n\n    void deliverMeal(UUID orderId) {\n        eventProducer.publish(new MealDelivered(orderId));\n    }\n}\n```", "```java\n@Path(\"orders\")\npublic class OrdersResource {\n\n    @Inject\n    OrderService orderService;\n\n    @Context\n    UriInfo uriInfo;\n\n    @POST\n    public Response orderMeal(JsonObject order) {\n        OrderInfo orderInfo = createOrderInfo(order);\n        orderService.orderMeal(orderInfo);\n\n        URI uri = uriInfo...\n\n        return Response.accepted().header(HttpHeaders.LOCATION, uri).build();\n    }\n\n    ...\n}\n```", "```java\n@Path(\"orders\")\npublic class OrdersResource {\n\n    @Inject\n    MealOrders mealOrders;\n\n    @GET\n    @Path(\"{id}\")\n    public JsonObject getOrder(@PathParam(\"id\") UUID orderId) {\n        MealOrder order = mealOrders.get(orderId);\n\n        if (order == null)\n            throw new NotFoundException();\n\n        // create JSON response\n        return Json.createObjectBuilder()...\n    }\n}\n```", "```java\n@Interceptor\npublic class CircuitBreaker {\n\n    ...\n\n    @AroundInvoke\n    public Object aroundInvoke(InvocationContext context) {\n\n        // close circuit after recovery time\n\n        if (circuit.isOpen())\n            return null;\n\n        try {\n            return context.proceed();\n        } catch (Exception e) {\n\n            // record exception\n            // increase failure counter\n            // open circuit if failure exceeds threshold\n\n            return null;\n        }\n    }\n}\n```", "```java\nimport com.airhacks.porcupine.execution.boundary.Dedicated;\nimport java.util.concurrent.ExecutorService;\n\n@Path(\"users\")\n@Produces(MediaType.APPLICATION_JSON)\npublic class UsersResource {\n\n    @Inject\n    @Dedicated(\"custom-name\")\n    ExecutorService executor;\n\n    @GET\n    public CompletionStage<Response> get() {\n        return CompletableFuture\n                .supplyAsync(this::getUsers, executor)\n                .thenApply(s -> Response.ok(s).build());\n    }\n\n    ...\n}\n```", "```java\nimport com.airhacks.porcupine.configuration.control.ExecutorConfigurator;\nimport com.airhacks.porcupine.execution.control.ExecutorConfiguration;\n\n@Specializes\npublic class CustomExecutorConfigurator extends ExecutorConfigurator {\n\n    @Override\n    public ExecutorConfiguration defaultConfigurator() {\n        return super.defaultConfigurator();\n    }\n\n    @Override\n    public ExecutorConfiguration forPipeline(String name) {\n        if (\"custom-name\".equals(name)) {\n            return new ExecutorConfiguration.Builder().\n                    abortPolicy().\n                    build();\n        }\n        return super.forPipeline(name);\n    }\n}\n```", "```java\nimport java.util.concurrent.RejectedExecutionException; @Provider\npublic class RejectedExecutionHandler\n implements ExceptionMapper<RejectedExecutionException> {\n\n    @Override\n    public Response toResponse(RejectedExecutionException exception) {\n        return Response.status(Response.Status.SERVICE_UNAVAILABLE)\n                .build();\n    }\n}\n```"]