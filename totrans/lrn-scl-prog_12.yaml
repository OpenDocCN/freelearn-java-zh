- en: Building Reactive Applications with Akka Typed
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Akka Typed构建反应式应用
- en: This chapter reveals another way to build reactive applications with Akka. We
    will introduce Akka Typed, an Akka module which implements the actor model in
    a slightly different way compared to untyped Akka. We will contrast *classical* and
    typed approaches and show how the latter reduces the developer's choices but increases
    type safety and simplifies reasoning about actor-based programs during the maintenance
    phase.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章揭示了使用Akka构建反应式应用的另一种方式。我们将介绍Akka Typed，这是一个Akka模块，它以一种与无类型Akka略有不同的方式实现了演员模型。我们将对比*经典*和类型化方法，并展示后者如何减少开发者的选择，但增加类型安全性，并在维护阶段简化基于演员的程序推理。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Differences between typed and untyped approaches
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型化和无类型方法之间的差异
- en: Creating, stopping, and discovering actors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、停止和发现演员
- en: The life cycle of an actor and supervision
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员的生命周期和监督
- en: Schedulers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度器
- en: Stashing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Combining behaviors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合行为
- en: Testing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we begin, make sure you have the following installed:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请确保你已经安装了以下内容：
- en: Java 1.8+
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 1.8+
- en: SBT 1.2+
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SBT 1.2+
- en: 'The source code for this chapter is available on our GitHub repository at:
    [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter12](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter12)[.](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter02)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在我们的GitHub仓库中找到：[https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter12](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter12)[.](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter02)
- en: The code snippets in this chapter have been simplified a bit to omit unnecessary
    technical details. Please refer to the GitHub repository for fully functioning
    examples.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码片段已经简化了一些，省略了不必要的技术细节。请参考GitHub仓库以获取完全功能性的示例。
- en: Introduction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml), *An Introduction
    to the Akka and Actor Models*, we discovered the actor model and how Akka implements
    it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](87c2e446-3730-49ae-b86b-fc8269678399.xhtml)《Akka和演员模型简介》中，我们发现了演员模型以及Akka是如何实现它的。
- en: 'The original actor paper states three possible actions that actors can perform
    as computational units:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的演员论文提出了演员作为计算单元可以执行的三种可能的行为：
- en: They can send messages to other known actors
  id: totrans-19
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们可以向其他已知的演员发送消息
- en: They can create new actors
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们可以创建新的演员
- en: They can designate behavior for future message processing
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们可以为未来的消息处理指定行为
- en: Because of the universality of this model, the specifics of how these points
    are to be implemented depends on the hardware, operating system, programming language,
    existing libraries, and ultimately on the design choices of the implementer. Akka
    Typed offers a slightly different programming model compared to untyped Akka.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该模型的通用性，这些点的具体实现方式取决于硬件、操作系统、编程语言、现有库，以及最终取决于实现者的设计选择。Akka Typed与无类型Akka相比提供了一个略微不同的编程模型。
- en: Furthermore, in this chapter, we'll refer to normal Akka as Akka untyped to
    be specific about which library is being mentioned, even though *untyped* Akka
    was always named just *Akka* in the previous chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在本章中，我们将提到正常的Akka为Akka无类型，以明确指出正在讨论哪个库，尽管在前一章中*无类型*的Akka总是被称为*Akka*。
- en: Let's take a closer look at the differences and similarities between the two
    implementations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这两种实现之间的差异和相似之处。
- en: The typed approach and the differences between Akka untyped
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型化方法和无类型Akka之间的差异
- en: Compared to the untyped version, Akka Typed takes a slightly different approach
    to define what an actor is.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与无类型版本相比，Akka Typed在定义演员是什么方面采取了一种略微不同的方法。
- en: 'In Akka untyped, an actor is any object that is a subclass of an abstract `Actor`
    and overrides a `def receive: PartialFunction[Any, Unit]` method. This allows
    the developer to do anything in the implementation except return a meaningful
    result, which makes it hard to reason about the code and impossible to combine
    actor logic.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '在Akka无类型中，演员是任何继承自抽象`Actor`类并重写`def receive: PartialFunction[Any, Unit]`方法的对象。这允许开发者在其实现中做任何事情，除了返回一个有意义的成果，这使得推理代码变得困难，并且无法组合演员逻辑。'
- en: Akka Typed declares that any well-defined behavior is a computation entity and
    thus can be declared to be an actor. The *well-defined* in terms of Akka Typed
    means anything that defines a statically typed `Behavior`. The type of `Behavior`
    limits actors to receiving messages of this specific type only. The return type
    of the actor's behavior is required to be the next `Behavior` of the same type
    with respect to inheritance. This way, it is possible to ensure at compile time
    that the actor will receive only messages of the type it declares to handle.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Akka Typed声明任何定义良好的行为都是一个计算实体，因此可以声明为actor。在Akka Typed中，“定义良好”的意思是任何定义了静态类型`Behavior`的东西。`Behavior`的类型限制了actor只能接收特定类型的消息。actor行为的返回类型需要是同一类型的下一个`Behavior`，相对于继承。这样，就可以在编译时确保actor只会接收它声明的要处理的类型的消息。
- en: In order to achieve this, actor addresses also need to be typed, and the type
    of address needs to be known at compile time. Hence, features of untyped Akka
    such as implicit access to the sender of the present message and general actor
    lookup are not available in typed Akka. By contrast, actor's addresses need to
    be defined as part of the protocol or need to be managed by an external (to the
    actor) facility.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，演员地址也需要进行类型化，并且地址的类型需要在编译时已知。因此，无类型Akka的一些功能，如对当前消息发送者的隐式访问和通用actor查找，在类型化Akka中不可用。相比之下，演员的地址需要作为协议的一部分进行定义，或者需要由外部（相对于演员）的设施进行管理。
- en: Another notable change is the introduction of `Signal` message types, which
    represent events in the life cycle of an actor and replace dedicated callback
    methods that were exposed by the `Actor` class in untyped Akka. Although this
    is not a very big spot in a whole picture of changes, it is a good move to make
    the implementation of Akka's actor model closer to the abstract actor model.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的改动是引入了`Signal`消息类型，它代表了演员生命周期中的事件，并取代了在无类型Akka中由`Actor`类公开的专用回调方法。尽管这在整个变化图中不是一个非常大的亮点，但这是一个很好的举措，可以使Akka的actor模型实现更接近抽象actor模型。
- en: In short, Akka Typed restricts actor communication and behavior to the model,
    which can then be type checked at compile time. This limits the developer's choices
    and possibilities for the implementation, but at the same time makes the result
    easier to reason about and test. The unavailability of some untyped features makes
    it impossible to write code in a way that represents an Akka anti-pattern and
    leads to solutions resembling what are considered to be the best practices in
    *normal* Akka.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Akka Typed将actor的通信和行为限制在模型中，然后可以在编译时进行类型检查。这限制了开发者在实现方面的选择和可能性，但同时也使得结果更容易推理和测试。某些无类型功能的不可用使得无法以表示Akka反模式的方式编写代码，并导致解决方案类似于在*正常*
    Akka中被认为是最佳实践的解决方案。
- en: This module is currently marked as **may change** ([https://doc.akka.io/docs/akka/2.5/common/may-change.html](https://doc.akka.io/docs/akka/2.5/common/may-change.html)). This
    reflects the fact that the topic itself is the subject of active research and
    there might be some changes in the API. However, the current implementation is
    solid and changes in the API are minimal among recent version updates. Therefore,
    the Akka team considers Akka Typed to be production-ready.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块目前标记为**可能更改** ([https://doc.akka.io/docs/akka/2.5/common/may-change.html](https://doc.akka.io/docs/akka/2.5/common/may-change.html))。这反映了该主题本身是活跃研究的主题，API可能会有一些变化。然而，当前的实现是稳定的，并且与最近版本更新相比，API的变化很小。因此，Akka团队认为Akka
    Typed已经准备好投入生产。
- en: Let's take a look at what these differences look like in practice.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些差异在实际中是如何体现的。
- en: Example actor system
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例演员系统
- en: To illustrate features of Akka Typed, we'll reimplement an example we built
    in [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml), *An Introduction
    to the Akka and Actor Models*, but this time with typed actors.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明Akka Typed的特性，我们将重新实现第11章中构建的示例，*Akka和Actor模型简介*，但这次使用类型化演员。
- en: For those readers who are familiar with the content of the previous chapter,
    this approach will allow you to compare two different styles. For those who just
    joined, let's quickly recap the structure of this example.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉上一章内容的读者，这种方法将允许您比较两种不同的风格。对于新加入的读者，让我们快速回顾一下这个示例的结构。
- en: 'We''re building a small cookie bakery which is populated by a number of actors,
    each with their own set of responsibilities:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建一个小型饼干烘焙坊，其中包含许多演员，每个演员都有自己的责任集：
- en: The `Manager` drives the process and passes over materials from one worker to
    another.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Manager` 驱动整个过程，并将材料从一个工人传递到另一个工人。'
- en: The `Boy` takes a `ShoppingList` and returns to the `Manager` the respective
    `Groceries` from the `Store`.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boy` 拿取 `ShoppingList` 并将 `Store` 中的相应 `Groceries` 返回给 `Manager`。'
- en: The `Chef` takes the `Groceries` and makes them into `Dough`. It does so by
    using a number of `Mixers` with the exact mixer count depending on the amount
    of stuff to mix.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chef` 拿取 `Groceries` 并将其制作成 `Dough`。它通过使用多个 `Mixers` 来完成，具体的 `Mixers` 数量取决于需要混合的物品数量。'
- en: The `Cook` takes `Dough` and makes `RawCookies`.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cook` 拿取 `Dough` 并制作 `RawCookies`。'
- en: The `Baker` bakes the `RawCookies` in batches using a single `Oven` of a limited
    capacity.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Baker` 使用单个有限容量的 `Oven` 批量烘焙 `RawCookies`。'
- en: 'The structure of the actor system we''re going to build is represented in the
    following diagram:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的 actor 系统的结构在以下图中表示：
- en: '![](img/59a948d7-2089-4789-a569-df739e16b199.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/59a948d7-2089-4789-a569-df739e16b199.png)'
- en: Let's start with an implementation of the simplest actor in our system – the
    **Oven**. Here and later on in this chapter, we'll refer to the previous implementation,
    meaning the implementation we came up with in regards to untyped actors in [Chapter
    11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml), *An Introduction to the Akka
    and Actor Models*. The differences are very illustrative, so we advise the reader
    to refer to the code in the previous chapter, even if you haven't read it because
    you are already familiar with untyped Akka.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现我们系统中最简单的 actor —— **Oven** 开始。在这里以及本章后面的内容中，我们将参考之前的实现，即我们在第 11 章 `[An
    Introduction to the Akka and Actor Models](87c2e446-3730-49ae-b86b-fc8269678399.xhtml)`
    中关于无类型 actor 的实现。这些差异非常具有说明性，因此我们建议读者即使已经熟悉无类型 Akka，也请参考前一章的代码。
- en: 'To be able to use Akka `Typed` in our code, we need to put the following dependency
    in `build.sbt`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要能在我们的代码中使用 Akka `Typed`，我们需要在 `build.sbt` 中添加以下依赖项：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Defining `akkaVersion` separately as a `val` has the advantage that it can be
    reused for other modules and changed in a single place at the moment a new version
    becomes available.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `akkaVersion` 分别定义为 `val` 有一个优点，即它可以被其他模块重用，并在新版本可用时在单个位置进行更改。
- en: 'To keep our examples clean and short, we''ll assume that the following inputs
    are present in every code snippet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的示例保持简洁和简短，我们假设以下输入在每个代码片段中都是现成的：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first input brings lower level actor system abstractions into scope, and
    the second allows us to use higher level DSL for an actor's behavior definition.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个输入将较低级别的 actor 系统抽象引入作用域，第二个允许我们使用更高层次的 DSL 来定义 actor 的行为。
- en: First example
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个示例
- en: First, we need to define the protocol that our `Oven` will speak. In contrast
    to the untyped implementation, we can't reuse messages that are defined by another
    actor. The reason for this is that the `Oven` (and other actors at later stages)
    defines the type of messages it is supposed to handle. This type should not be
    too general in order to avoid making the whole implementation less typed than
    desirable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义我们的 `Oven` 将要使用的协议。与无类型实现相比，我们不能重用由另一个 actor 定义的消息。这是因为 `Oven`（以及后续阶段的其他
    actor）定义了它应该处理的消息类型。这种类型不应该过于通用，以避免使整个实现比期望的更少类型化。
- en: 'The domain model is common for all actors, so we''ll define it on the `Bakery`
    app level:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型对所有 actor 都是通用的，因此我们将在 `Bakery` 应用程序级别定义它：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And this is the small language our `Oven` speaks:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们 `Oven` 使用的简短语言：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Oven` can return `ReadyCookies` (a cookie is considered to be ready as
    soon as it has been put into the oven) and `RawCookies` in the case where there
    are more cookies in the `Put` command than can fit inside the oven. The `Command`
    is a type of behavior for our actor. We can see that it includes the `sender`
    field so that the oven knows who is the receiver of the extracted cookies.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Put` 命令中的饼干数量多于烤箱容量时，`Oven` 可以返回 `ReadyCookies`（一旦饼干被放入烤箱，就被认为是准备好了）和 `RawCookies`。`Command`
    是我们 actor 的一种行为类型。我们可以看到它包括 `sender` 字段，这样烤箱就知道提取的饼干的接收者是谁。
- en: 'Now, we need to define the actor''s behavior. If you followed the previous
    chapter, you will remember that we used the internal mutable field to store the
    contents of the oven in the current moment. By using this field, we can differentiate
    its reaction on incoming messages. Akka Typed urges us to exercise a different
    approach and use separate behaviors for different states of the actor. First,
    we define what should happen in the case that there is nothing inside:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义actor的行为。如果你跟随了上一章，你会记得我们使用内部可变字段来存储烤箱在当前时刻的内容。通过使用这个字段，我们可以区分其对传入消息的反应。Akka
    Typed鼓励我们采取不同的方法，并为actor的不同状态使用不同的行为。首先，我们定义在没有任何内容的情况下的行为：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we define a behavior of the empty `Oven` using the `Behaviors` factory.
    In our case, this is a `receiveMessage` method with a type parameter called `Command`.
    This designates the type of messages our actor can handle.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用`Behaviors`工厂定义了一个空`Oven`的行为。在我们的例子中，这是一个带有类型参数`Command`的`receiveMessage`方法。这指定了我们的actor可以处理的消息类型。
- en: Next, we define a course of action in the case of the incoming `Put` command.
    The `insert` method returns a number of cookies that we can put inside the `Oven`
    and an optional overflow. In this case, if there is an overflow, we return it
    to the sender by using the `tell` method of its `ActorRef[Cookies]`. The type
    of reference allows us to send `RawCookies` back. Because of the type-safe nature
    of the actor definition, this binds the behavior of the `Baker` actor (that we'll
    implement soon) to be `Behaviors.Receive[Cookies]`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义在接收到`Put`命令的情况下的行动方案。`insert`方法返回我们可以放入`Oven`中的饼干数量以及可选的溢出。在这种情况下，如果有溢出，我们使用其`ActorRef[Cookies]`的`tell`方法将其返回给发送者。引用类型允许我们发送`RawCookies`。由于actor定义的类型安全特性，这将`Baker`actor（我们很快将实现）的行为绑定到`Behaviors.Receive[Cookies]`。
- en: 'Now, we need to define what should happen in the case that the `Oven` is not
    empty:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义当`Oven`不为空时应该发生什么：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This `Behavior` is even simpler, but still has the same type—`Behaviors.Receive[Command]`.
    We just return all of the cookies that were inside to the sender and change the
    future behavior to the `empty` behavior we defined earlier.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`行为`甚至更简单，但仍然具有相同的类型—`Behaviors.Receive[Command]`。我们只需将所有内部的饼干返回给发送者，并将未来的行为更改为我们之前定义的`empty`行为。
- en: 'Now, if we compile this implementation, we''ll get complaints from the compiler:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们编译这个实现，编译器会提出投诉：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The compiler has helped us to identify our first two bugs already! The reason
    it is unhappy with the current implementation is that we forgot to define a reaction
    to the messages that are *inappropriate* in specific states. This will be an attempt
    to extract cookies from the empty oven and to put something into the full one.
    From the type perspective, this is possible, and the compiler informed us of this.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器已经帮助我们识别出前两个错误！它对当前实现不满意的原因是我们忘记定义对特定状态下不合适的消息的反应。这将尝试从空烤箱中提取饼干并将某些东西放入满的烤箱中。从类型角度来看，这是可能的，编译器已经通知了我们这一点。
- en: 'Let''s fix this by implementing our states properly:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过正确实现我们的状态来解决这个问题：
- en: 'This is the augmented definition of an `empty` state:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`empty`状态的扩展定义：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The sender will be sent zero cookies, and we keep current behavior by using
    `Behavior.same`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 发送者将收到零个饼干，我们通过使用`Behavior.same`来保持当前行为。
- en: 'The principle stays the same for the `full` case:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`full`情况，原则保持不变：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Again, we just returned to the sender everything we've got and kept the current
    behavior exactly like we did in the empty case.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们只是将我们拥有的所有东西都返回给发送者，并保持当前行为与空情况完全一样。
- en: Akka Typed basics
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Akka Typed基础知识
- en: Now that we've made the compiler happy and got our first impression about how
    typed actors tick, let's take a more principled approach and look in detail at
    how they can be created, discovered, and stopped, and what possibilities there
    are to change an actor's behavior.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们让编译器满意，并且对我们如何使用类型化actor有了初步的了解，让我们采取更原则性的方法，详细看看它们是如何被创建、发现和停止的，以及有哪些可能性可以改变actor的行为。
- en: Creating an actor
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个actor
- en: In accordance to the actor model definition, there is exactly one way that an
    actor can be created—it can be spawned by another actor. Akka gives you two slightly
    different possibilities to do this by using `ActorContext`. Both methods are not
    thread safe and should only be used directly within the actor's thread.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 根据演员模型定义，创建演员的方式只有一种——它可以由另一个演员生成。Akka通过使用`ActorContext`提供了两种稍微不同的可能性来完成这个任务。这两种方法都不是线程安全的，并且应该仅在演员的线程中直接使用。
- en: 'The first variant allows you to instantiate an anonymous actor from a behavior
    and returns an `ActorRef[T]`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种变体允许您从行为中实例化一个匿名演员，并返回一个`ActorRef[T]`：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This implementation provides a default empty value for the props parameter so
    that the actual call can be reduced to `spawnAnonymous(behavior)`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现为props参数提供了一个默认的空值，以便实际的调用可以简化为`spawnAnonymous(behavior)`。
- en: Not naming actors might be useful in specific situations, but it is considered
    to be a bad practice in general. This is because it makes debugging harder and
    looking up children by name impossible without relying on the current implementation
    details of the library.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定情况下不命名演员可能是有用的，但通常被认为是一种不好的做法。这是因为它使得调试更加困难，并且在没有依赖库当前实现细节的情况下，通过名称查找子演员变得不可能。
- en: 'Thus, another realization should be preferred whenever it makes sense to use
    one:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在合理使用的情况下，应该优先考虑另一种实现：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we're required to provide a behavior and a name for an actor, which is
    about to be instantiated.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们需要提供一个行为和一个即将实例化的演员的名称。
- en: Both `spawn` and `spawnAnonymous` accept a `props` parameter, which can be used
    to further configure an actor instance. As of now, it is only possible to configure
    an actor's dispatcher.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`spawn`和`spawnAnonymous`都接受一个`props`参数，可以用来进一步配置演员实例。目前，只能配置演员的调度器。'
- en: Dispatchers make up the machinery that runs behaviors. Dispatchers use `ExecutorServices`
    to assign threads to actors and can be configured as described in [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml),
    *An Introduction to the Akka and Actor Models*. Currently, Akka Typed only supports
    the dispatchers definition from the configuration. Properties of the default dispatcher
    can be changed by overriding the settings under `akka.actor.default-dispatcher` .
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器构成了运行行为的机制。调度器使用`ExecutorServices`将线程分配给演员，并且可以按照[第11章](87c2e446-3730-49ae-b86b-fc8269678399.xhtml)，*Akka和演员模型简介*中描述的方式进行配置。目前，Akka
    Typed仅支持从配置中定义调度器。可以通过覆盖`akka.actor.default-dispatcher`下的设置来更改默认调度器的属性。
- en: In our example system, the `Chef` actor should instantiate `Mixers` as being
    required to work with big chunks of work in parallel. In addition, mixers use
    blocking code because of the limitations of hardware and therefore need separate
    dispatchers in order to avoid thread starvation for the rest of the system. Let's
    look at how this behavior can be implemented.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例系统中，`Chef`演员应该实例化`Mixers`，因为它们需要并行处理大量工作。此外，由于硬件的限制，mixers使用阻塞代码，因此需要单独的调度器以避免系统其他部分的线程饥饿。让我们看看如何实现这种行为。
- en: 'First, by using `application.conf`, we configure a dispatcher that will be
    used for blocking mixers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过使用`application.conf`，我们配置了一个用于阻塞mixers的调度器：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we instantiate the required number of child actors:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实例化所需数量的子演员：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Chef` actor has its own hierarchy of commands which we, for now, limit
    to `Mix`. We need a separate `Mixer` for each egg, so we instantiate them by using
    `spawn`. `spawn` returns an actor reference and we collect them in the `mixers`
    `val`. Finally, we return the next actor's `Behavior`, which for now is `unhandled`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chef`演员有自己的命令层次结构，我们目前将其限制为`Mix`。我们需要为每个鸡蛋提供一个单独的`Mixer`，所以我们通过`spawn`来实例化它们。`spawn`返回一个演员引用，我们将它们收集在`mixers`
    `val`中。最后，我们返回下一个演员的`Behavior`，目前是`unhandled`。'
- en: 'OK, so it''s possible to create new actors from an actor''s context. This brings
    us to a **Zeno''s paradox** kind of situation with Achilles and the tortoise. Naturally,
    to create a new actor, we need to have an actor already. Akka solves this paradox
    by requiring the developer to provide a definition of a root actor at the moment
    an actor system is created:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以从演员的上下文中创建新的演员是可能的。这把我们带到了阿基里斯和乌龟的**芝诺悖论**一样的情境。自然地，要创建一个新的演员，我们需要已经有一个演员。Akka通过要求开发者在创建演员系统时提供一个根演员的定义来解决这个悖论。
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This leaves the developer with no choice but to design a proper actor hierarchy
    top-down. Following this typed approach automatically leads to avoidance of the
    *flat actor hierarchy* anti-pattern!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得开发者别无选择，只能从上到下设计合适的演员层次结构。遵循这种类型化的方法可以自动避免*扁平演员层次结构*的反模式！
- en: There is another possibility for instantiating an actor. This can be done by
    using the `ActorSystem`'s `systemActorOf` method, which creates an actor in the
    `/system` space. It is arguable that this feature shouldn't normally be used,
    and therefore it is not covered here.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化演员的另一种可能性是通过使用`ActorSystem`的`systemActorOf`方法，该方法在`/system`空间中创建一个演员。这可以是有争议的，因为这个特性通常不应该被使用，因此这里没有涵盖。
- en: Now, since our `Chef` spawned enough `Mixers` to do the job, we need a way to
    get rid of them after our work is complete.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们的`Chef`已经产生了足够的`Mixers`来完成工作，我们需要一种方法在任务完成后将它们移除。
- en: Stopping an actor
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止一个演员
- en: 'An actor can be stopped in one of the following ways:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 演员可以通过以下方式之一停止：
- en: By designating its next behavior to be `Behaviors.stopped`.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指定其下一个行为为`Behaviors.stopped`。
- en: By applying the `stop` method of the `ActorContext` to the immediate child.
    The child will finish processing the current message but leave other messages
    that are still in the mailbox unprocessed.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将`ActorContext`的`stop`方法应用于直接子演员。子演员将完成当前消息的处理，但将其他仍处于邮箱中的消息留待处理。
- en: By the actor system as it stops its ancestor. The actual shutdown happens recursively,
    bottom-up, following the hierarchy.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过演员系统在停止其祖先时。实际的关闭是递归的，从下到上，遵循层次结构。
- en: 'The most natural approach in our mixers example would be to pick the first
    option. We implement it in the following example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的混合器示例中，最自然的方法是选择第一个选项。我们将在以下示例中实现它：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Mixer` behavior is very simple, so we don't need to define an ADT for that
    and use the single `Mix` command directly. The `Chef` actor expects `Collect(Dough)` back.
    This obliges us to define it as a type parameter for the sender reference. The
    behavior itself simulates the hardware delay for the mixing to be finished, sends
    the prepared dough to the `Chef`, and returns `Behaviors.stopped` as the next
    behavior. This leads to the graceful termination of the `Mixer` actor.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mixer`行为非常简单，所以我们不需要为它定义ADT并直接使用单个`Mix`命令。`Chef`演员期望返回`Collect(Dough)`。这迫使我们将其定义为发送者引用的类型参数。行为本身模拟混合完成所需的硬件延迟，将准备好的面团发送给`Chef`，并返回`Behaviors.stopped`作为下一个行为。这导致`Mixer`演员的优雅终止。'
- en: Now that we've sent the dough back to the `Chef`, let's see how it is supposed
    to be handled. The `Chef` needs to collect the results from all of the mixers
    it has created. To do so, we could pass references to the child actors we've created
    in the idle state to the mixing behavior, but let's imagine we lost the references
    we collected for some reason. In this case, `Chef` could look up its children.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将面团送回`Chef`，让我们看看它应该如何处理。`Chef`需要收集它创建的所有混合器的结果。为此，我们可以将我们在空闲状态下创建的子演员的引用传递给混合行为，但让我们假设我们由于某种原因丢失了收集到的引用。在这种情况下，`Chef`可以查找其子演员。
- en: Discovering an actor
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现一个演员
- en: Actor discovery is an alternative way to obtain an actor reference. The preferred
    way is still to incorporate actor references into the message protocol.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 演员发现是获取演员引用的另一种替代方法。首选的方法仍然是将演员引用纳入消息协议中。
- en: 'Akka provides the possibility to look up a single child actor by name (only
    exact match) with the following method:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Akka提供了通过以下方法按名称（仅精确匹配）查找单个子演员的可能性：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This returns a reference to a child actor if a child with such a name exists
    and is alive. Please note that because of the return type of this method, the
    result needs to be coerced to the proper type by the use of the `narrow` method
    of `ActorRef`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在一个具有该名称且处于存活状态的子演员，则此操作返回对该子演员的引用。请注意，由于此方法的返回类型，需要使用`ActorRef`的`narrow`方法将结果强制转换为正确的类型。
- en: 'Another method that allows us to look up all of the children of an actor that
    are alive is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种允许我们查找一个演员所有存活子演员的方法如下：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The type of result is, again, a collection of `ActorRefs` with no particular
    type.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的类型再次是一个没有特定类型的`ActorRefs`集合。
- en: It is arguable that the lookup methods we have described here are of little
    use because of their basically untyped nature. Akka Typed offers a better alternative
    in the form of the `receptionist`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有争议的是，我们在这里描述的查找方法由于其基本无类型性质而用处不大。Akka Typed提供了一个更好的替代方案，即`receptionist`。
- en: 'The `receptionist` is a (cluster) singleton actor that is available on the
    actor system level and can be obtained from the `ActorContext` using the following
    call chain:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`receptionist`是一个（集群）单例演员，在演员系统级别可用，可以通过以下调用链从`ActorContext`获取：'
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `receptionist` is just an actor of type `[Receptionist.Command]`, so let's
    investigate the `Receptionist.Command` type to understand what it is capable of.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`receptionist`只是一个类型为`[Receptionist.Command]`的演员，因此让我们研究一下`Receptionist.Command`类型，以了解它能够做什么。'
- en: 'There are three concrete implementations of the abstract `Command` class: `Register`, `Find`,
    and `Subscribe.`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象`Command`类有三个具体实现：`Register`、`Find`和`Subscribe`。
- en: '`Register` is used for associating the given `ActorRef` with the provided `ServiceKey`.
    It is possible to register multiple references for the same key. The registration
    is automatically removed from the receptionist if the registered actor is stopped.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Register`用于将给定的`ActorRef`与提供的`ServiceKey`关联。对于同一个键，可以注册多个引用。如果注册的演员停止，注册会自动从接待员那里移除。'
- en: By providing an optional reference, it is possible to provide another actor,
    who should be notified if the service was successfully registered.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供一个可选的引用，可以提供另一个演员，如果服务成功注册，该演员应该被通知。
- en: '`Find` is a mechanism for asking the receptionist about all currently known
    registered actors for the given `ServiceKey`. The receptionist responds with a
    `Set` of known actor references (which are called **services**) that are registered
    to the given key, and a key itself wrapped in a `Listing`. `Find` can be used
    to implement one-time queries to the receptionist.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Find`是一种询问接待员关于给定`ServiceKey`所知所有已注册演员的机制。接待员会以一个包含已知演员引用（称为**服务**）的`Set`以及一个包裹在`Listing`中的键本身作为响应，这些演员引用已注册到给定的键。`Find`可以用来实现一次性查询接待员。'
- en: '`Subscribe` is a way to implement push behavior for the receptionist. An actor
    can use subscribe to receive notifications about all added or removed services
    for some predefined key.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subscribe`是一种实现接待员推送行为的途径。一个演员可以使用`subscribe`来接收有关某些预定义键中添加或删除的所有服务的通知。'
- en: In our example, the `Manager` actor is used to provide a `Boy` with a reference
    to the `seller` actor. The `Boy` is supposed to communicate with the provided
    reference. In the previous chapter, we used untyped Akka's remote lookup to get
    this reference. In the typed environment, we will utilize the receptionist for
    this purpose.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`Manager`演员被用来向`Boy`提供一个`seller`演员的引用。`Boy`应该与提供的引用进行通信。在前一章中，我们使用了无类型的Akka远程查找来获取这个引用。在类型化环境中，我们将利用接待员来完成这个目的。
- en: This is how it is done.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的实现方式。
- en: 'First, the `seller` behavior needs to register itself with the receptionist
    at the moment it is initialized:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`seller`行为需要在初始化时向接待员注册自己：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Shop` defines the `SellerKey` that will be used by the actor to register
    as a service and by the service clients to look up the seller's reference.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shop`定义了`SellerKey`，该键将由演员用来注册为服务，并由服务客户端用来查找卖家的引用。'
- en: 'Next, we introduce a new type of behavior constructor—`Behaviors.setup`. `setup`
    is a behavior factory. It takes the behavior constructor as a by-name parameter
    and creates the behavior at the moment the actor is started (as opposed to the
    moment the behavior is constructed). We need to use this factory for two reasons:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍一种新的行为构造函数类型—`Behaviors.setup`。`setup`是一个行为工厂。它接受行为构造函数作为按名参数，并在演员启动时创建行为（与行为构造时不同）。我们需要使用这个工厂有两个原因：
- en: We need our actor to be instantiated so that we can access its context
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要我们的演员被实例化，这样我们才能访问其上下文
- en: We want our `Seller` to register itself exactly once
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望我们的`Seller`正好注册一次
- en: After registering the `Seller` with the receptionist, the real behavior is constructed.
    The behavior itself is just accepting the `SellByList` messages and responding
    with the `Groceries` that are to be provided to the `toWhom` reference.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`Seller`注册到接待员之后，实际的行为被构造。行为本身只是接受`SellByList`消息，并针对`toWhom`引用响应提供的`Groceries`。
- en: 'On the opposite side of the receptionist, the `Manager` actor needs to look
    up the `Seller` and use its reference to guide the `Boy`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在接待员的另一边，`Manager`演员需要查找`Seller`并使用其引用来引导`Boy`：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There is quite a bit going on here. Once again, we're using `setup` to define
    the behavior.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多事情在进行。再次使用`setup`来定义行为。
- en: Looking up actors is an asynchronous operation, and in this case, we utilize
    the `ask` pattern to keep the code concise. Ask needs to know how long it is allowed
    to wait for the answer, so, in the second line, we define a `lookupTimeout`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 查找演员是一个异步操作，在这种情况下，我们利用`ask`模式来使代码简洁。Ask需要知道它允许等待答案多长时间，因此，在第二行，我们定义了一个`lookupTimeout`。
- en: Then, we call the `ask` method that's available in the actor context and provide
    a reference of a `receptionist` as an actor to be asked. The second parameter
    is the receptionist's `Find` command, which is given a seller key. Normally, the
    `Find` command takes a second parameter that defines a receiver for the response,
    but as it is used quite often together with `ask`, there is a special constructor
    that allows for the nice syntax we are using in this snippet.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在演员上下文中调用可用的`ask`方法，并提供一个`receptionist`作为演员的引用来询问。第二个参数是接待员的`Find`命令，它被赋予了一个卖家键。通常，`Find`命令接受一个第二个参数，该参数定义了响应的接收者，但因为它经常与`ask`一起使用，所以有一个特殊的构造函数允许我们使用在这个片段中使用的良好语法。
- en: The case literal, which comes next, defines a transformation that must be applied
    to the response before actually sending it back to the asking actor. It deconstructs
    and converts the receptionist's response so that it is either a `NoSeller` or
    just one `OneSeller`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的情况字面量定义了一个在实际上将响应发送回询问演员之前必须应用到响应上的转换。它解构并转换接待员的响应，使其成为`NoSeller`或只是一个`OneSeller`。
- en: 'Next, we have to deal with the converted response by defining a behavior which
    is returned as a result of this lengthy factory method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须通过定义一个行为来处理转换后的响应，这个行为是这个漫长的工厂方法的结果：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the current manager's behavior, we only expect a small subset of all of the
    possible messages to arrive. We're using `receiveMessagePartial` to avoid compiler
    warnings for unhandled message types.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前的管理员行为中，我们只期望收到所有可能消息的小子集。我们使用`receiveMessagePartial`来避免未处理消息类型的编译器警告。
- en: In this case, if there is no seller, we can use the `log` that's available in
    the actor's `context` to report this condition and return the current behavior.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果没有卖家，我们可以使用演员的`context`中可用的`log`来报告这种状态并返回当前的行为。
- en: 'In this case, if there is a `Seller` available, we instantiate a `Boy` and
    use it to transfer a `shoppingList` to this seller. Note how we used `context.self`
    as a second parameter for the `GoShopping` message. By doing this, we''re making
    it possible to use the provided manager''s reference to persuade the `Seller`
    to send groceries directly to the `Manager`, and then the `Boy` can immediately
    stop itself after sending the message:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果有`Seller`可用，我们实例化一个`Boy`并使用它将`shoppingList`传递给这个卖家。注意我们如何使用`context.self`作为`GoShopping`消息的第二个参数。通过这样做，我们使提供的管理员引用能够说服`Seller`直接将杂货发送给`Manager`，然后`Boy`在发送消息后可以立即停止自己：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we have seen how the `GoShopping` command prohibits us from interchanging
    actor references for the seller and manager, as this could easily happen in the
    case of untyped Akka.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了`GoShopping`命令如何禁止我们交换卖家和经理的演员引用，因为在无类型的Akka中这种情况很容易发生。
- en: Akka Typed – beyond the basics
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Akka Typed – 超越基础
- en: We've defined the behavior of the `Chef` actor to distribute work across mixers
    but left the waiting part uncovered, so let's look at that now.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了`Chef`演员的行为，以便在混合器之间分配工作，但留下了等待部分未覆盖，所以现在让我们看看这一点。
- en: 'We left the `Chef` definition for the `mixing` behavior as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Chef`的`mixing`行为的定义留给了以下内容：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Actually, the `Chef` needs to know about the mixers that were created by its
    `idle` behavior. Though technically it is possible to do a children lookup, as
    described earlier, doing so will introduce an implicit assumption that, at the
    moment, we'll get the listing stating that all of the mixers are still processing
    jobs. This assumption might be wrong in a highly concurrent environment or in
    the case of failed mixers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`Chef`需要了解由其`idle`行为创建的混合器。虽然从技术上讲，我们可以执行子查找，如前所述，这样做将引入一个隐含的假设，即在这个时刻，我们会得到一个列表，表明所有的混合器仍在处理工作。这个假设在高度并发的环境中或混合器失败的情况下可能是错误的。
- en: 'Therefore, we need to refactor the behavior constructor a bit:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要对行为构造函数进行一点重构：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we have a builder that captures all of the parts of the Chef''s state. Let''s
    see how these parts are used in the definition of its behavior:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个构建器，它捕获了`Chef`状态的所有部分。让我们看看这些部分如何在它的行为定义中使用：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We're already familiar with the constructor. In the behavior itself, we count
    every `Dough` message received from the mixer and recreate the behavior with the
    new state. In this case, if all of the mixers have delivered their parts, we return
    the result to the manager and go to the `idle` state.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了构造函数。在行为本身中，我们计算从混合器接收到的每个`Dough`消息，并使用新状态重新创建行为。在这种情况下，如果所有混合器都已交付他们的部分，我们将结果返回给经理，并进入`idle`状态。
- en: Life cycle of an actor
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演员的生命周期
- en: Our implementation of the `Mixer` is quite naive and does not take into account
    that hardware occasionally breaks.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`Mixer`的实现相当简单，没有考虑到硬件偶尔会出故障。
- en: Conventionally, in Akka, we distinguish between expected and unexpected failures.
    An expected failure of some operation, for example, a validation error is usually
    represented on the protocol level with the appropriate message types. Exceptional
    conditions of an unexpected nature such as hardware errors, are communicated by
    throwing exceptions. This allows you to separate handler definitions for successful
    and erroneous paths, which leads to the separation of business logic from the
    technical details of the underlying platform. Thus, having a rich set of exceptions
    is a prerequisite for proper error-handling definitions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在Akka中，传统上我们区分预期和意外的故障。例如，验证错误通常在协议级别上用适当的消息类型表示。意外性质的异常条件，如硬件错误，通过抛出异常进行通信。这允许你为成功路径和错误路径分别定义处理程序，从而将业务逻辑与底层平台的技术细节分离。因此，拥有丰富的异常集是正确错误处理定义的前提条件。
- en: 'Let''s take this aspect into account. We''ll represent unreliable hardware
    by defining a set of exceptions, one for every possible failure. We''ll do this
    the same way as we did in [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml),
    *An Introduction to the Actor Model and Akka*:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑这个方面。我们将通过定义一组异常来表示不可靠的硬件，每个可能的故障一个。我们将以与[第11章](87c2e446-3730-49ae-b86b-fc8269678399.xhtml)《演员模型与Akka简介》相同的方式进行：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, in order to simulate the hardware failure, we''ll add some code with the
    purpose of throwing defined exceptions to the logic of the `Mixer`. To keep the
    example simple, let''s just throw one of them:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了模拟硬件故障，我们将添加一些代码，目的是向`Mixer`的逻辑抛出定义的异常。为了使示例简单，我们只需抛出其中之一：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It looks like it is very warm in our bakery. The mixer motors are overheating
    roughly every second time the `Chef` tries to mix the `Groceries`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们的面包店非常热。每当`Chef`试图混合`Groceries`时，混合器电机大约每两次就会过热。
- en: Actors can watch themselves by calling the `receiveSignal` method on the actor's
    context and providing a `PartialFunction[(ActorContext[T], Signal), Behavior[T]]`
    as a parameter. The provided partial function will be called, with a life cycle
    message as a parameter, if the actor terminates or restarts.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 演员可以通过在演员的上下文中调用`receiveSignal`方法，并提供一个`PartialFunction[(ActorContext[T], Signal),
    Behavior[T]]`作为参数来自我监视。如果演员终止或重启，将调用提供的部分函数，参数为生命周期消息。
- en: 'This possibility for self-watching can be useful to change the behavior of
    the actor in appropriate cases. The following code snippet shows how mixers can
    monitor themselves:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自我监视的可能性在适当的情况下可以用来改变演员的行为。以下代码片段显示了混合器如何自我监控：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In our case, mixers just write into the log what kind of life-changing event
    had happened and keep the same behavior. To take a look at the situations in which
    `PostStop`, `PreRestart`, and `Terminated` events happen, we first need to become
    familiar with the concept of supervision.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，混合器只是将发生的生活变化事件写入日志，并保持相同的行为。为了查看`PostStop`、`PreRestart`和`Terminated`事件发生的情况，我们首先需要熟悉监督的概念。
- en: Supervision
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监督
- en: 'In essence, supervision in Akka Typed refers to the fact that all exceptions
    thrown from a behavior are caught and acted upon. An action can have one of three
    forms: resume, restart, and stop.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，Akka Typed中的监督指的是所有从行为抛出的异常都被捕获并采取行动。一个动作可以有以下三种形式之一：恢复、重启和停止。
- en: Let's see how supervision can be defined and which effect it has.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何定义监督以及它会产生什么影响。
- en: 'First, let''s run our system as it is and observe its output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们以当前状态运行我们的系统，并观察其输出：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can see how our actors start processing messages up to the point where an
    exception is thrown by the `Mixer`. This exception is handled using the default
    supervision strategy that is stopping the actor. The mixer logs the `PostStop`
    event via the monitoring function we defined earlier and attaches it to the actor''s
    behavior, like so:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的演员是如何开始处理消息，直到`Mixer`抛出异常。这个异常使用默认的监督策略处理，该策略停止了演员。混合器通过我们之前定义的监控函数记录了`PostStop`事件，并将其附加到演员的行为上，如下所示：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s see what will happen if we override the default supervision strategy.
    To change the behavior, we just wrap it into the supervising behavior by using
    the standard constructor. Let''s restart the mixer instead of stopping it in the
    case of the motor overheating:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们覆盖默认的监督策略会发生什么。为了改变行为，我们只需使用标准构造函数将其包装到监督行为中。在电机过热的情况下，让我们重启混合器而不是停止它：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we use this behavior by using the `Chef` actor to create mixers, running
    the app will produce a slightly different output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`Chef`演员来创建混合器，运行应用程序将产生略微不同的输出：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, the exception has been reported by the supervisor and the mixers have been
    restarted, as we can conclude by observing the `PreRestart` events that have been
    logged by the mixers. There is no `PostStop` event here.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，异常已经被监督者报告，混合器已经被重启，我们可以通过观察混合器记录的`PreRestart`事件来得出结论。这里没有`PostStop`事件。
- en: 'There is still one more supervision strategy to look at, so let''s check it
    out:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种监督策略需要查看，让我们来看看：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With this strategy, we''ll still see a log output from the supervisor, but
    actors won''t log any life cycle events:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种策略，我们仍然会看到来自监督者的日志输出，但演员不会记录任何生命周期事件：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It is possible to define different supervision strategies for different types
    of exceptions that are thrown by the same behavior by nesting supervisor constructors:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过嵌套监督构造函数来为同一行为抛出的不同类型的异常定义不同的监督策略：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The definition is obviously a bit verbose.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 定义显然有点冗长。
- en: The supervision strategies are sticky. They are recursively applied to new behaviors
    that are returned by the supervised behavior.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 监督策略是粘性的。它们递归地应用于由监督行为返回的新行为。
- en: 'Sometimes, it might be useful to try and restart an actor a few times, and
    if the situation is not improving, then finally stop it. A special constructor
    is available for this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，尝试重启一个演员几次可能是有用的，如果情况没有改善，那么最终停止它。为此，有一个特殊的构造函数可用：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In an unlucky case, the mixer actor would throw an exception from the `Behavior.setup`
    constructor every time it was constructed, and we would see the following output:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在不幸的情况下，混合器演员每次构建时都会从`Behavior.setup`构造函数抛出异常，我们会看到以下输出：
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The supervisor tried to restart the actor four times, but then gave up and stopped
    it. Because of the fact that the failure happened in the setup block, the actor
    was able to receive neither the `Mix` command nor life cycle event notifications.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 监督者尝试重启演员四次，但最终放弃并停止了它。由于失败发生在设置块中，演员无法接收`Mix`命令或生命周期事件通知。
- en: Watching an actor
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察一个演员
- en: If we look back to the `Chef` actor's implementation, we'll be able to see that
    our system is now stuck. This happened because, if mixers fail, they are stopped
    by an external supervising force. However, the `Chef` actor is still waiting for
    this mixer's part to work. It turns out that we need a way to inform the `Chef`
    about terminated mixers.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下`Chef`演员的实现，我们会发现我们的系统现在卡住了。这是因为，如果混合器失败，它们会被外部监督力量停止。然而，`Chef`演员仍在等待这个混合器的部分工作。结果是，我们需要一种方式来通知`Chef`有关已终止的混合器。
- en: 'Akka Typed offers a watching mechanism for this. To watch for mixers that were
    stopped, we''ll add the following code to the `Chef`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Akka Typed为此提供了一个监控机制。为了监控被停止的混合器，我们将以下代码添加到`Chef`中：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, for each spawned `Mixer`, we''re calling `context.watchWith`. The first
    parameter is an actor to watch and the second parameter is a message adapter.
    The need for the message adapter comes from the fact that the *proper* message
    type for the terminated actor would be `akka.actor.typed.Terminated`. We could
    use a watch, taking just a single actor reference, to subscribe to this message
    type—`def watch[T](other: ActorRef[T]): Unit`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，对于每个生成的`Mixer`，我们调用`context.watchWith`。第一个参数是要观察的演员，第二个参数是消息适配器。需要消息适配器的原因是，已终止演员的*正确*消息类型将是`akka.actor.typed.Terminated`。我们可以使用一个观察者，仅接受单个演员引用，来订阅此消息类型——`def
    watch[T](other: ActorRef[T]): Unit`。'
- en: 'But, the fact is that our `Chef` can''t handle this message type because it
    does not belong to its `Command` type. Therefore, we would need to define a separate
    actor type to watch for mixer terminations. Instead, we need to use the *extended*
    version of the watch method, which takes a message to be sent as a second parameter.
    The `BrokenMixer` message is defined and handled as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 但，事实上我们的`Chef`无法处理这种消息类型，因为它不属于它的`Command`类型。因此，我们需要定义一个单独的演员类型来观察混合器的终止。相反，我们需要使用*扩展*版本的观察方法，它将一个要发送的消息作为第二个参数。`BrokenMixer`消息被定义和处理如下：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this case, if we detect a terminated child actor, the `Chef` writes a log
    entry and sends itself a message to compensate for the lost part of the work.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果我们检测到一个已终止的子演员，`Chef`将写入一条日志条目并给自己发送一条消息来补偿丢失的工作部分。
- en: Now, we have the `Dough` ready and need a `Cook` to form cookies and a `Baker`
    to bake them in the `Oven`. The implementation of the `Cook` is trivial—it just
    converts `Dough` into a number of `RawCookies` and sends them back to the manager.
    Please refer to the code in the GitHub repository if you're interested in the
    implementation details.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有`Dough`准备好了，需要一个`Cook`来形成饼干，一个`Baker`来在`Oven`中烘烤它们。`Cook`的实现很简单——它只是将`Dough`转换成一定数量的`RawCookies`并将它们发送回管理员。如果您对实现细节感兴趣，请参阅GitHub仓库中的代码。
- en: Timers
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定时器
- en: 'The `Baker` is more interesting. First of all, it needs a single `Oven`. We''ll
    implement this by using a special behavior that we''ll execute only once:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`Baker`更有趣。首先，它需要一个单独的`Oven`。我们将通过使用一个特殊的行为来实现这一点，我们只执行一次：'
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, let''s define the `idle` behavior that''s just waiting for work:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个`idle`行为，它只是在等待工作：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we expect a message from the manager telling us to bake cookies. Then,
    we use a new behavior constructor, `withTimers`, which gives us access to the `TimerScheduler`.
    With the scheduler, it is possible to define periodic and single timers that have
    been identified by some key. The definition of a new timer with the same key cancels
    the previously defined timer and also removes messages that have been sent by
    it, if they are still in the message box of the actor.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们期待来自管理员的消息，告诉我们烘烤饼干。然后，我们使用一个新的行为构造函数`withTimers`，它为我们提供了访问`TimerScheduler`的权限。使用调度器，可以定义由某些键标识的周期性和单次定时器。使用相同键定义新定时器将取消之前定义的定时器，并删除它发送的消息，如果它们仍然在演员的消息框中。
- en: Here, we're using the timer as a kitchen clock to set up a single reminder to
    check the `Oven` after baking time passes.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用定时器作为厨房时钟，在烘焙时间过后设置一个单次提醒来检查`Oven`。
- en: Stashing
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储
- en: Another challenge is that the `Baker` needs to accept `RawCookies` from the
    `Manager` as required, but needs to bake them in batches because of the oven's
    limited capacity. Basically, it needs to manage a queue of the `RawCookies`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个挑战是，`Baker`需要根据需要从`Manager`接受`RawCookies`，但由于烤箱的容量有限，需要批量烘烤它们。基本上，它需要管理一个`RawCookies`的队列。
- en: We'll implement this by using a stash. By using stashing, our actor will buffer
    messages that cannot be handled by the current behavior and replay them before
    switching to the alternative behavior in which buffered messages are supposed
    to be handled.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用一个存储区来实现这一点。通过使用存储，我们的演员将缓冲当前行为无法处理的消息，并在切换到应该处理缓冲消息的替代行为之前重新播放它们。
- en: 'Let''s see how this approach is reflected in the baking behavior of the actor:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这种方法如何在演员的烘焙行为中体现出来：
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: First, we define a buffer that will contain our stashed messages.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个将包含我们的存储消息的缓冲区。
- en: The stash is keeping messages in memory. By stashing too many messages, it is
    possible to crash the system with an `OutOfMemory` error. The capacity parameter
    helps to avoid this situation. But, in the case that the specified capacity is
    too low, the `StashOverflowException` will be thrown after an attempt to stash
    a message into the full buffer.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存正在内存中保存消息。通过存储过多的消息，可能会导致系统因`OutOfMemory`错误而崩溃。容量参数有助于避免这种情况。但是，如果指定的容量过低，在尝试将消息存入已满的缓冲区后，将抛出`StashOverflowException`异常。
- en: Then, we handle four types of messages. `CheckOven` is a reminder that is sent
    to the `Baker` by the timer so that it does not forget to extract cookies from
    the `Oven`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们处理四种类型的消息。`CheckOven`是定时器发送给`Baker`的提醒，以免忘记从`Oven`中取出饼干。
- en: In the case of `TooManyCookies` (which is a message from the `Oven` returning
    cookies that did not fit into it) or `BakeCookies` being received from the manager,
    the `Baker` stashes them until it becomes idle again and is able to process baking
    work.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TooManyCookies`（这是一个来自`Oven`的消息，表示没有适合放入其中的饼干）或从管理者那里收到`BakeCookies`的情况下，`Baker`将它们存储起来，直到再次空闲并能够处理烘焙工作。
- en: '`CookiesReady` indicates that the `Oven` is now empty, so we forward the cookies
    to the `Manager`, unstash all of the messages, and go to the `idle` state.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`CookiesReady`表示`Oven`现在为空，因此我们将饼干转发给`Manager`，取消存储所有消息，并进入`idle`状态。'
- en: Combining behaviors
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合行为
- en: 'Now that we have defined every worker in the bakery, it is time to finally get us
    a `Manager`. In [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml), *An
    Introduction to the Akka and Actor Models*, we implemented a `Manager` using the
    FSM library. In Akka Typed, we can achieve the same effect without any libraries
    just by defining atomic behaviors for each state and then returning the appropriate
    behavior as required:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了面包店的每个工人，是时候最终获得一个`Manager`了。在[第11章](87c2e446-3730-49ae-b86b-fc8269678399.xhtml)，《Akka和Actor模型简介》中，我们使用FSM库实现了`Manager`。在Akka
    Typed中，我们可以通过定义每个状态的原子行为，然后根据需要返回适当的行为来实现相同的效果：
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we have defined two behaviors, and each of them expects a specific message
    type, performs the required message passing to the managed actors, and returns
    the next behavior in the chain. This way, it is possible to model the serial behavior
    we implemented with untyped Akka.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了两种行为，每种行为都期望接收特定的消息类型，执行必要的消息传递给受管理的演员，并返回链中的下一个行为。这样，我们可以使用无类型的Akka实现我们实现的串行行为。
- en: 'However, we can do better. Akka Typed allows us to combine behaviors so that
    we can implement a parallel version of the `Manager` by chaining behaviors together
    and returning the combined behavior from every atomic behavior we define:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以做得更好。Akka Typed允许我们组合行为，这样我们可以通过将行为链接在一起并从我们定义的每个原子行为中返回组合行为来实现`Manager`的并行版本：
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, the `manage` constructor is used to define atomic behaviors for each message
    type the `Manager` is supposed to be able to handle. Then, the existing behaviors
    are combined into one. This makes our `Manager` capable of processing every message
    in any processing state.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`manage`构造函数用于为`Manager`应该能够处理的每种消息类型定义原子行为。然后，将现有的行为组合成一个。这使得我们的`Manager`能够处理任何处理状态中的每条消息。
- en: Cluster
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群
- en: The `Bakery` is now in place, but we would still like the grocery store to run
    as a separate actor system, just like we had it in the previous chapter. With
    untyped Akka, we implemented this communication with the help of remoting, but
    remoting is not available in the typed setup. With Akka Typed, we can achieve
    this with the help of clustering.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Bakery`已经到位，但我们仍然希望杂货店作为一个独立的actor系统运行，就像我们在上一章中做的那样。使用无类型的Akka，我们通过远程通信实现了这种通信，但在类型化的设置中远程通信不可用。使用Akka
    Typed，我们可以通过集群来实现这一点：
- en: Akka clustering is a group of Akka systems working as a dynamic whole. This
    is the main difference from Akka remote, on top of which clustering is built.
    A single system represents one node from the cluster. An actor can exist anywhere
    in the cluster. Some of the features of clustering include load balancing (routing
    messages to specific nodes in the cluster), node partitioning (assigning specific
    roles to nodes), and cluster management (fault-tolerant node membership), to name
    a few. In our example, we don't use any advanced clustering features, and instead
    just throw it in an order so that we have the possibility to communicate with
    a remote actor system.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Akka 集群是一组作为动态整体工作的 Akka 系统。这是与 Akka 远程的主要区别，集群是在其之上构建的。单个系统代表集群中的一个节点。一个演员可以存在于集群的任何位置。集群的一些功能包括负载均衡（将消息路由到集群中的特定节点）、节点分区（将特定角色分配给节点）和集群管理（容错节点成员资格），仅举几例。在我们的示例中，我们没有使用任何高级集群功能，而是按顺序抛出，以便我们有与远程演员系统通信的可能性。
- en: 'To be able to use clustering in our project, we need to add the following dependency
    to `build.sbt`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在我们的项目中使用集群，我们需要在 `build.sbt` 中添加以下依赖项：
- en: '[PRE44]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Clustering also requires that a few configuration parameters are defined. We
    can provide them by putting the following additional lines into `application.conf`. This
    will be the default configuration used by the `Bakery`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 集群还需要定义一些配置参数。我们可以通过在 `application.conf` 中添加以下附加行来提供它们。这将作为 `Bakery` 的默认配置使用：
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The configuration for the `Store` is defined by importing the default configuration
    and overriding the port definition:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`Store` 的配置是通过导入默认配置并覆盖端口定义来定义的：'
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we need to instantiate an actor system for `Store`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为 `Store` 实例化一个演员系统：
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And we need another one for the `Bakery` itself:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为 `Bakery` 本身添加一个：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Both of these defined actor systems can now be started and will simulate baking
    cookies by acquiring the required resources from the remote system via clustering.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个定义的演员系统现在都可以启动，并将通过集群从远程系统获取所需资源来模拟烘焙饼干。
- en: We just demonstrated Akka's location transparency by turning a local actor system
    into clustered one just by changing the configuration.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚通过只更改配置就将本地演员系统转变为集群演员系统，展示了 Akka 的位置透明性。
- en: Testing
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Currently, we have a working `Bakery` implementation, but we cannot be sure
    that our actors are doing what we expect them to do. Let's fix this by testing
    their behavior.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有一个工作的 `Bakery` 实现，但我们不能确定我们的演员是否在执行我们期望他们执行的操作。让我们通过测试他们的行为来解决这个问题。
- en: Testing actors is notoriously difficult because of their concurrent nature and
    message orientation. Luckily, in Akka Typed, an actor's behavior is just a function
    and thus can generally be tested in isolation. There are cases where we might
    want to test the interaction between actors, and in this case, it is inevitable
    to resort to asynchronous testing.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 由于演员的并发性和消息导向，测试演员是出了名的困难。幸运的是，在 Akka Typed 中，演员的行为只是一个函数，因此通常可以独立进行测试。有些情况下，我们可能想要测试演员之间的交互，在这种情况下，不可避免地要诉诸于异步测试。
- en: In synchronous setup, we create a behavior under test, send events that it should
    be able to react on, and verify that the behavior produces the expected effects
    (for example, spawning or stopping child actors) and sends further required messages.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步设置中，我们创建一个待测试的行为，发送它应该能够反应的事件，并验证该行为产生了预期的效果（例如，产生或停止子演员）并发送进一步所需的消息。
- en: The asynchronous scenario brings this approach into the context of a test actor
    system, which is close to a real one. We will see how this is done in practice
    in a moment.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 异步场景将这种方法引入了测试演员系统的上下文中，这接近于真实环境。我们将在稍后看到这是如何在实际中完成的。
- en: Dependencies and setup
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖和设置
- en: 'To automate repetitive tasks such as setting up testing environments for actors,
    Akka Typed provides a test kit in the same way Akka untyped does. We need the
    following dependencies to be present in `build.sbt` so that we can use it within
    our project:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动化重复性任务，例如为演员设置测试环境，Akka Typed 提供了一个测试套件，就像 Akka 无类型一样。我们需要在 `build.sbt`
    中存在以下依赖项，以便我们可以在项目中使用它：
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Having both of them in scope will allow us to create `ScalaTest` specifications
    and use the Akka Typed test kit functionality.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个都纳入范围将允许我们创建 `ScalaTest` 规范，并使用 Akka Typed 测试套件功能。
- en: 'As mentioned previously, in regards to synchronous actor testing, we do not
    need to have an `ActorSystem`. The only dependency, in this case, is an actor
    context. Akka provides a factory for building special testing actor contexts in
    the form of the `BehaviorTestKit`. A skeleton of the `ScalaTest` specification,
    in this case, could look as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，关于同步演员测试，我们不需要有`ActorSystem`。在这种情况下，唯一的依赖是一个演员上下文。Akka提供了一个工厂，用于以`BehaviorTestKit`的形式构建特殊的测试演员上下文。在这种情况下，`ScalaTest`规范的骨架可能如下所示：
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the case of asynchronous testing, we have to extend the `ActorTestKit` to
    have a test actor system in the scope of the specification. This actor system
    needs to be shut down after all tests are finished running in order to prevent
    resource leakage. Because of this, the minimal specification in the case of asynchronous
    testing will look a bit more involved:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步测试的情况下，我们必须扩展`ActorTestKit`，以便在规范范围内有一个测试演员系统。这个演员系统需要在所有测试完成后关闭，以防止资源泄漏。因此，在异步测试的情况下，最小的规范将看起来更复杂一些：
- en: '[PRE51]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, it is time to look at the different features Akka `TestKit` has to offer
    to simplify checking the correctness of the actor-based system.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候看看Akka `TestKit`提供了哪些不同的功能，以简化检查基于演员的系统是否正确。
- en: Synchronous testing
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步测试
- en: 'The `BehaviorTestKit` provides the possibility to verify the reaction of an
    actor behavior to specific messages. The reaction can be in the form of an `Effect`
    (different ways of spawning and stopping children actors), sending and receiving
    messages, and changes in behavior. Let''s illustrate this testing process with
    an example:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`BehaviorTestKit`提供了验证演员行为对特定消息反应的可能性。反应可以表现为`Effect`（以不同方式创建和停止子演员的方式）、发送和接收消息以及行为的变化。让我们用一个例子来说明这个测试过程：'
- en: '[PRE52]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we have wrapped a `goShopping` behavior into the `BehaviorTestKit` so
    that we can test it synchronously. The two `TestInbox` references represent actors
    that the `Boy` is supposed to communicate with. They are basically `ActorRefs`,
    but they allow us to express expectations regarding incoming messages. To trigger
    the test, we can create a message and run the `testKit` using this message as
    an input.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`goShopping`行为封装到了`BehaviorTestKit`中，以便我们可以同步测试它。两个`TestInbox`引用代表`Boy`应该与之通信的演员。它们基本上是`ActorRefs`，但它们允许我们表达对传入消息的期望。为了触发测试，我们可以创建一个消息，并使用这个消息作为输入运行`testKit`。
- en: In the next line, we expect the `seller` actor to receive the same message,
    with the `manager` reference being propagated as a sender. This is how our boy's
    logic is supposed to work. Then, we verify that the `Boy` stopped itself by checking
    that it is not alive. Finally, we don't expect any effects on children as the
    `Boy` actor is not supposed to have or create any children.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们期望`seller`演员接收到相同的消息，其中`manager`引用作为发送者被传播。这正是我们男孩逻辑应该工作的方式。然后，我们通过检查它是否不再存活来验证`Boy`已经停止了自己。最后，由于`Boy`演员不应该拥有或创建任何子演员，我们不应该期望对子演员有任何影响。
- en: 'In the same way that we tested that the `Boy` has no effects on children, we
    can test that the `Chef` has such effects:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们测试`Boy`对子演员没有影响的方式相同，我们可以测试`Chef`有这样的影响：
- en: '[PRE53]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this test, we create a behavior under test in the same way we just did with
    the `Boy` actor. We create a message and run it with the testing behavior wrapper.
    As a result, we expect a `chef` to have the effect of spawning a single `Mixer`
    actor with an appropriate name and dispatcher. Finally, we're looking up the mailbox
    of the spawned child actor by using the `childInbox` method and expect it to have
    a message that's been sent by the `chef` to be present in it.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们以与刚才对`Boy`演员所做的方式创建一个待测试的行为。我们创建一个消息，并用测试行为包装器运行它。结果，我们期望一个`chef`会以适当的名字和调度器创建一个单独的`Mixer`演员。最后，我们通过使用`childInbox`方法查找已创建的子演员的邮箱，并期望其中包含由`chef`发送的消息。
- en: Unfortunately, at the time of writing this book, the Akka `TestKist` still has
    some rough edges that require us, in this specific case, to refactor our `Chef`
    behavior to accept the mixer factory as a parameter. The reason for this is that
    behaviors are compared by reference, which requires us to have the same instance
    of the behavior for the test to pass.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在撰写这本书的时候，Akka的`TestKist`还有一些粗糙的边缘，这要求我们在这种特定情况下重构我们的`Chef`行为，以接受混合器工厂作为参数。这是因为行为是通过引用比较的，这要求我们为测试通过而拥有相同的行为实例。
- en: 'Another limitation of the `BehaviorTestKit` is its lack of support for extensions
    like cluster, cluster singleton, distributed data, and receptionist. This makes
    it impossible to test the `Seller` actor in a synchronous setup because this actor
    registers itself with the `receptionist`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`BehaviorTestKit`的另一个限制是其不支持扩展，如集群、集群单例、分布式数据和接待员。这使得在同步设置中测试`Seller`演员变得不可能，因为该演员会将自己注册到`receptionist`：'
- en: '[PRE54]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We could use the synchronous approach or we could refactor the seller to take
    a constructor function for the receptionist and provide a mock receptionist in
    the test. This is an example of how this can be done in the code of the `Seller`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用同步方法，或者我们可以重构卖家以接受一个用于接待员的构造函数，并在测试中提供一个模拟接待员。这是在`Seller`代码中如何做到这一点的示例：
- en: '[PRE55]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The factory is just a function from `ActorContext` to the `ActorRef` with the
    appropriate types.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂只是从`ActorContext`到`ActorRef`的函数，具有适当的类型。
- en: 'With this change, we can implement our test, as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个改变，我们可以实现我们的测试，如下所示：
- en: '[PRE56]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We provide a mock receptionist which is just a `TestInbox[Receptionist.Command]`
    and use it as the result of the factory, ignoring the actual actor context. Then,
    we execute the test as we did previously and expect the messages to be sent to
    the `manager` and `receptionist` appropriately.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个模拟接待员，它只是一个`TestInbox[Receptionist.Command]`，并将其作为工厂的结果使用，忽略了实际的演员上下文。然后，我们像之前一样执行测试，并期望消息被适当地发送到`manager`和`receptionist`。
- en: Asynchronous testing
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步测试
- en: Synchronous testing is a good and deterministic way to test actor logic, but
    sometimes it is just not enough, for example, when testing specific aspects of
    communication between actors. Another example is having asynchronous code in the
    actor's behavior, for example, `Feature` or scheduler, which needs to be finished
    before test assertions can be executed.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 同步测试是测试演员逻辑的好方法，但有时它并不足够，例如，当测试演员之间通信的特定方面时。另一个例子是在演员的行为中存在异步代码，例如`Feature`或调度器，它需要在测试断言可以执行之前完成。
- en: One example of such a situation is the `Baker` actor. We expect it to check
    the `Oven` after some predefined time interval. Unfortunately, this interval is
    hardcoded, so there is no possibility of being able to override it in the test
    and we need to wait for the timer to trigger.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的一个例子是`Baker`演员。我们期望它在预定义的时间间隔后检查`Oven`。不幸的是，这个间隔是硬编码的，所以在测试中无法覆盖它，我们需要等待计时器触发。
- en: As part of the asynchronous testing toolkit, Akka provides a `ManualTimer`,
    which can be used to advance time in tests in a flexible manner. We'll use it
    to reliably test our `Baker` actor.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 作为异步测试工具包的一部分，Akka提供了一个`ManualTimer`，可以在测试中以灵活的方式推进时间。我们将使用它来可靠地测试我们的`Baker`演员。
- en: 'First, we need to provide an appropriate configuration for the manual timer.
    We do this by overriding the `config` method of the actor system which is represented
    by the `ActorTestKit` and define an instance of the time we''ll use in our test:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为手动计时器提供一个适当的配置。我们通过覆盖演员系统的`config`方法（由`ActorTestKit`表示）并定义我们将在测试中使用的计时器实例来完成此操作：
- en: '[PRE57]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, we can specify the testing logic:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以指定测试逻辑：
- en: '[PRE58]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this scenario,  we create an `oven` and a `manager` using `TestProbe` (as
    opposed to the `TestInbox` we used before) and also a `baker` behavior using the
    `spawn` method of the `ActorTestKit`. We send a request to the `baker` and expect
    it to react appropriately by putting a single cookie into the oven.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们使用`TestProbe`（与之前使用的`TestInbox`相反）创建了一个`oven`和一个`manager`，还使用`ActorTestKit`的`spawn`方法创建了一个`baker`行为。我们向`baker`发送一个请求，并期望它通过将单个饼干放入烤箱来适当地做出反应。
- en: Next, we can see that the `baker` waits for the cookies to be ready by checking
    that no messages are sent during this period of time. We're using the annual time
    here, and because of this, the check itself is done instantly. Finally, we manually
    advance the timer so that the `baker` needs to extract the cookies from the oven
    and verify that this has indeed happened, and that the `oven` received the `Extract`
    message as expected.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以看到`baker`通过检查在这个时间段内没有发送任何消息来等待饼干准备好。我们在这里使用的是年度时间，因此检查本身是瞬间完成的。最后，我们手动推进计时器，以便`baker`需要从烤箱中取出饼干并验证这确实发生了，并且`oven`如预期那样接收到了`Extract`消息。
- en: The application has been successfully tested; let's wait no more and run it!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序已经成功测试；让我们不再等待，运行它吧！
- en: Running the application
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: Please refer to [Appendix A](bc164888-625c-460a-9b0b-e6c45c9eb074.xhtml), *Preparing
    the Environment and Running Code Samples*, if you don't have Java and SBT installed
    yet.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有安装Java和SBT，请参阅[附录A](bc164888-625c-460a-9b0b-e6c45c9eb074.xhtml)，*准备环境和运行代码示例*。
- en: 'We will run our application in the Terminal in the same way as we did in the
    previous chapter by using two separate terminal sessions for `Store` and `Bakery`.
    It is possible to run both in interactive mode, or by issuing one of the two following
    commands in the corresponding shell:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像上一章一样在终端中运行我们的应用程序，使用两个独立的终端会话为`Store`和`Bakery`。它们可以在交互模式下运行，或者在相应的shell中发出以下两个命令之一：
- en: '[PRE59]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Because we''re using clustering instead of remoting for our example, we don''t
    need to start them in a particular order as we had to in the previous chapter.
    The following screenshot shows two Terminal windows ready to run the application
    with the aforementioned commands typed in:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在示例中使用的是集群而不是远程通信，因此我们不需要按照上一章中必须的顺序启动它们。以下截图显示了两个准备运行应用程序的终端窗口，已输入上述命令：
- en: '![](img/5e6f8daa-7acc-4b5f-b97b-5634362a35d8.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5e6f8daa-7acc-4b5f-b97b-5634362a35d8.png)'
- en: 'As both parts of the application start, they will establish a connection and
    start to work together to produce cookies. The following screenshot shows us that
    the bakery part of the application is already running and waiting for the store
    to start on the right-hand side of the screen:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序的两个部分同时启动时，它们将建立连接并开始协同工作以生成饼干。以下截图显示应用程序的面包店部分已经运行并等待屏幕右侧的商店启动：
- en: '![](img/983c3c61-8573-4c06-849d-dac0e4829373.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/983c3c61-8573-4c06-849d-dac0e4829373.png)'
- en: If you'd like to start the demo in interactive mode from the SBT shell, please
    refer to [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml), *An Introduction
    to the Akka and Actor Models*, where we explained how to do this in detail.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想从SBT shell以交互模式启动演示，请参阅[第11章](87c2e446-3730-49ae-b86b-fc8269678399.xhtml)，*Akka和Actor模型简介*，其中我们详细解释了如何进行此操作。
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Akka Typed allows you to implement an actor system in a type-safe way. It represents
    actor logic as a well-typed behavior with the types of both input and output channels
    determined at compile time. Behaviors can be combined together, allowing for a
    higher degree of code reuse.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Akka Typed允许您以类型安全的方式实现actor系统。它将actor逻辑表示为具有编译时确定的输入和输出通道类型的良好类型化行为。行为可以组合在一起，从而允许更高的代码重用程度。
- en: Typed actors are not only supposed to receive and send messages but are also
    required to explicitly define a new behavior after processing every message. Interactions
    with other actors are limited to creating, stopping, looking up, and watching
    children, and getting typed references to explicitly registered services.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 类型化的Actor不仅应该接收和发送消息，而且在处理完每条消息后还必须显式定义新的行为。与其他Actor的交互仅限于创建、停止、查找和监视子Actor，以及获取显式注册服务的类型引用。
- en: Actor context provides useful functionality, such as timers and stashing.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Actor上下文提供了有用的功能，例如计时器和存储。
- en: Typed supervision is defined directly on behavior, and the failure propagation
    to the parent actor must be implemented explicitly if needed. The Akka team took
    a holistic approach by promoting an actor's life cycle hooks, from methods to
    events.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 类型化监督直接定义在行为上，如果需要，必须显式实现向父actor的故障传播。Akka团队通过推广actor的生命周期钩子，从方法到事件，采取了一种整体的方法。
- en: Actors in typed Akka are basically just functions. Because of this, testing
    is not limited to asynchronous communication as it was before. This can be done
    synchronously, thus allowing for deterministic and stable test code that executes
    quickly.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型化的Akka中，Actor基本上只是函数。正因为如此，测试不再仅限于之前的异步通信。这可以同步进行，从而允许执行快速、确定性和稳定的测试代码。
- en: Akka Typed offers a set of useful extensions like cluster, cluster singleton,
    persistence, and distributed data. We touched briefly upon how the cluster module
    allows us to utilize the existing code in a distributed scenario by solely changing
    the configuration of the system. Please refer to the Akka Typed official documentation
    online ([https://doc.akka.io/docs/akka/current/typed/index.html](https://doc.akka.io/docs/akka/current/typed/index.html)) 
    to explore further capabilities provided by the typed actor's toolkit.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Akka Typed 提供了一系列有用的扩展，如集群、集群单例、持久化和分布式数据。我们简要介绍了集群模块如何通过仅更改系统配置，使我们能够在分布式场景中利用现有代码。请参考
    Akka Typed 的官方在线文档（[https://doc.akka.io/docs/akka/current/typed/index.html](https://doc.akka.io/docs/akka/current/typed/index.html)）以进一步探索类型化演员工具包提供的功能。
- en: In the next chapter, we're going to implement the bakery once again, this time
    using yet another Akka library—Akka Streams.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将再次实现面包店，这次将使用另一个 Akka 库——Akka Streams。
