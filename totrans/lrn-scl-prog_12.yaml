- en: Building Reactive Applications with Akka Typed
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Akka Typed构建反应式应用
- en: This chapter reveals another way to build reactive applications with Akka. We
    will introduce Akka Typed, an Akka module which implements the actor model in
    a slightly different way compared to untyped Akka. We will contrast *classical* and
    typed approaches and show how the latter reduces the developer's choices but increases
    type safety and simplifies reasoning about actor-based programs during the maintenance
    phase.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章揭示了使用Akka构建反应式应用的另一种方式。我们将介绍Akka Typed，这是一个Akka模块，它以一种与无类型Akka略有不同的方式实现了演员模型。我们将对比*经典*和类型化方法，并展示后者如何减少开发者的选择，但增加类型安全性，并在维护阶段简化基于演员的程序推理。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Differences between typed and untyped approaches
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型化和无类型方法之间的差异
- en: Creating, stopping, and discovering actors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、停止和发现演员
- en: The life cycle of an actor and supervision
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员的生命周期和监督
- en: Schedulers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度器
- en: Stashing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Combining behaviors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合行为
- en: Testing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we begin, make sure you have the following installed:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请确保你已经安装了以下内容：
- en: Java 1.8+
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 1.8+
- en: SBT 1.2+
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SBT 1.2+
- en: 'The source code for this chapter is available on our GitHub repository at:
    [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter12](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter12)[.](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter02)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在我们的GitHub仓库中找到：[https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter12](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter12)[.](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter02)
- en: The code snippets in this chapter have been simplified a bit to omit unnecessary
    technical details. Please refer to the GitHub repository for fully functioning
    examples.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码片段已经简化了一些，省略了不必要的技术细节。请参考GitHub仓库以获取完全功能性的示例。
- en: Introduction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml), *An Introduction
    to the Akka and Actor Models*, we discovered the actor model and how Akka implements
    it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](87c2e446-3730-49ae-b86b-fc8269678399.xhtml)《Akka和演员模型简介》中，我们发现了演员模型以及Akka是如何实现它的。
- en: 'The original actor paper states three possible actions that actors can perform
    as computational units:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的演员论文提出了演员作为计算单元可以执行的三种可能的行为：
- en: They can send messages to other known actors
  id: totrans-19
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们可以向其他已知的演员发送消息
- en: They can create new actors
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们可以创建新的演员
- en: They can designate behavior for future message processing
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们可以为未来的消息处理指定行为
- en: Because of the universality of this model, the specifics of how these points
    are to be implemented depends on the hardware, operating system, programming language,
    existing libraries, and ultimately on the design choices of the implementer. Akka
    Typed offers a slightly different programming model compared to untyped Akka.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该模型的通用性，这些点的具体实现方式取决于硬件、操作系统、编程语言、现有库，以及最终取决于实现者的设计选择。Akka Typed与无类型Akka相比提供了一个略微不同的编程模型。
- en: Furthermore, in this chapter, we'll refer to normal Akka as Akka untyped to
    be specific about which library is being mentioned, even though *untyped* Akka
    was always named just *Akka* in the previous chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在本章中，我们将提到正常的Akka为Akka无类型，以明确指出正在讨论哪个库，尽管在前一章中*无类型*的Akka总是被称为*Akka*。
- en: Let's take a closer look at the differences and similarities between the two
    implementations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这两种实现之间的差异和相似之处。
- en: The typed approach and the differences between Akka untyped
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型化方法和无类型Akka之间的差异
- en: Compared to the untyped version, Akka Typed takes a slightly different approach
    to define what an actor is.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与无类型版本相比，Akka Typed在定义演员是什么方面采取了一种略微不同的方法。
- en: 'In Akka untyped, an actor is any object that is a subclass of an abstract `Actor`
    and overrides a `def receive: PartialFunction[Any, Unit]` method. This allows
    the developer to do anything in the implementation except return a meaningful
    result, which makes it hard to reason about the code and impossible to combine
    actor logic.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '在Akka无类型中，演员是任何继承自抽象`Actor`类并重写`def receive: PartialFunction[Any, Unit]`方法的对象。这允许开发者在其实现中做任何事情，除了返回一个有意义的成果，这使得推理代码变得困难，并且无法组合演员逻辑。'
- en: Akka Typed declares that any well-defined behavior is a computation entity and
    thus can be declared to be an actor. The *well-defined* in terms of Akka Typed
    means anything that defines a statically typed `Behavior`. The type of `Behavior`
    limits actors to receiving messages of this specific type only. The return type
    of the actor's behavior is required to be the next `Behavior` of the same type
    with respect to inheritance. This way, it is possible to ensure at compile time
    that the actor will receive only messages of the type it declares to handle.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Akka Typed声明任何定义良好的行为都是一个计算实体，因此可以声明为actor。在Akka Typed中，“定义良好”的意思是任何定义了静态类型`Behavior`的东西。`Behavior`的类型限制了actor只能接收特定类型的消息。actor行为的返回类型需要是同一类型的下一个`Behavior`，相对于继承。这样，就可以在编译时确保actor只会接收它声明的要处理的类型的消息。
- en: In order to achieve this, actor addresses also need to be typed, and the type
    of address needs to be known at compile time. Hence, features of untyped Akka
    such as implicit access to the sender of the present message and general actor
    lookup are not available in typed Akka. By contrast, actor's addresses need to
    be defined as part of the protocol or need to be managed by an external (to the
    actor) facility.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，演员地址也需要进行类型化，并且地址的类型需要在编译时已知。因此，无类型Akka的一些功能，如对当前消息发送者的隐式访问和通用actor查找，在类型化Akka中不可用。相比之下，演员的地址需要作为协议的一部分进行定义，或者需要由外部（相对于演员）的设施进行管理。
- en: Another notable change is the introduction of `Signal` message types, which
    represent events in the life cycle of an actor and replace dedicated callback
    methods that were exposed by the `Actor` class in untyped Akka. Although this
    is not a very big spot in a whole picture of changes, it is a good move to make
    the implementation of Akka's actor model closer to the abstract actor model.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的改动是引入了`Signal`消息类型，它代表了演员生命周期中的事件，并取代了在无类型Akka中由`Actor`类公开的专用回调方法。尽管这在整个变化图中不是一个非常大的亮点，但这是一个很好的举措，可以使Akka的actor模型实现更接近抽象actor模型。
- en: In short, Akka Typed restricts actor communication and behavior to the model,
    which can then be type checked at compile time. This limits the developer's choices
    and possibilities for the implementation, but at the same time makes the result
    easier to reason about and test. The unavailability of some untyped features makes
    it impossible to write code in a way that represents an Akka anti-pattern and
    leads to solutions resembling what are considered to be the best practices in
    *normal* Akka.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Akka Typed将actor的通信和行为限制在模型中，然后可以在编译时进行类型检查。这限制了开发者在实现方面的选择和可能性，但同时也使得结果更容易推理和测试。某些无类型功能的不可用使得无法以表示Akka反模式的方式编写代码，并导致解决方案类似于在*正常*
    Akka中被认为是最佳实践的解决方案。
- en: This module is currently marked as **may change** ([https://doc.akka.io/docs/akka/2.5/common/may-change.html](https://doc.akka.io/docs/akka/2.5/common/may-change.html)). This
    reflects the fact that the topic itself is the subject of active research and
    there might be some changes in the API. However, the current implementation is
    solid and changes in the API are minimal among recent version updates. Therefore,
    the Akka team considers Akka Typed to be production-ready.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块目前标记为**可能更改** ([https://doc.akka.io/docs/akka/2.5/common/may-change.html](https://doc.akka.io/docs/akka/2.5/common/may-change.html))。这反映了该主题本身是活跃研究的主题，API可能会有一些变化。然而，当前的实现是稳定的，并且与最近版本更新相比，API的变化很小。因此，Akka团队认为Akka
    Typed已经准备好投入生产。
- en: Let's take a look at what these differences look like in practice.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些差异在实际中是如何体现的。
- en: Example actor system
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例演员系统
- en: To illustrate features of Akka Typed, we'll reimplement an example we built
    in [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml), *An Introduction
    to the Akka and Actor Models*, but this time with typed actors.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明Akka Typed的特性，我们将重新实现第11章中构建的示例，*Akka和Actor模型简介*，但这次使用类型化演员。
- en: For those readers who are familiar with the content of the previous chapter,
    this approach will allow you to compare two different styles. For those who just
    joined, let's quickly recap the structure of this example.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉上一章内容的读者，这种方法将允许您比较两种不同的风格。对于新加入的读者，让我们快速回顾一下这个示例的结构。
- en: 'We''re building a small cookie bakery which is populated by a number of actors,
    each with their own set of responsibilities:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建一个小型饼干烘焙坊，其中包含许多演员，每个演员都有自己的责任集：
- en: The `Manager` drives the process and passes over materials from one worker to
    another.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Manager` 驱动整个过程，并将材料从一个工人传递到另一个工人。'
- en: The `Boy` takes a `ShoppingList` and returns to the `Manager` the respective
    `Groceries` from the `Store`.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boy` 拿取 `ShoppingList` 并将 `Store` 中的相应 `Groceries` 返回给 `Manager`。'
- en: The `Chef` takes the `Groceries` and makes them into `Dough`. It does so by
    using a number of `Mixers` with the exact mixer count depending on the amount
    of stuff to mix.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chef` 拿取 `Groceries` 并将其制作成 `Dough`。它通过使用多个 `Mixers` 来完成，具体的 `Mixers` 数量取决于需要混合的物品数量。'
- en: The `Cook` takes `Dough` and makes `RawCookies`.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cook` 拿取 `Dough` 并制作 `RawCookies`。'
- en: The `Baker` bakes the `RawCookies` in batches using a single `Oven` of a limited
    capacity.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Baker` 使用单个有限容量的 `Oven` 批量烘焙 `RawCookies`。'
- en: 'The structure of the actor system we''re going to build is represented in the
    following diagram:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的 actor 系统的结构在以下图中表示：
- en: '![](img/59a948d7-2089-4789-a569-df739e16b199.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/59a948d7-2089-4789-a569-df739e16b199.png)'
- en: Let's start with an implementation of the simplest actor in our system – the
    **Oven**. Here and later on in this chapter, we'll refer to the previous implementation,
    meaning the implementation we came up with in regards to untyped actors in [Chapter
    11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml), *An Introduction to the Akka
    and Actor Models*. The differences are very illustrative, so we advise the reader
    to refer to the code in the previous chapter, even if you haven't read it because
    you are already familiar with untyped Akka.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现我们系统中最简单的 actor —— **Oven** 开始。在这里以及本章后面的内容中，我们将参考之前的实现，即我们在第 11 章 `[An
    Introduction to the Akka and Actor Models](87c2e446-3730-49ae-b86b-fc8269678399.xhtml)`
    中关于无类型 actor 的实现。这些差异非常具有说明性，因此我们建议读者即使已经熟悉无类型 Akka，也请参考前一章的代码。
- en: 'To be able to use Akka `Typed` in our code, we need to put the following dependency
    in `build.sbt`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要能在我们的代码中使用 Akka `Typed`，我们需要在 `build.sbt` 中添加以下依赖项：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Defining `akkaVersion` separately as a `val` has the advantage that it can be
    reused for other modules and changed in a single place at the moment a new version
    becomes available.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `akkaVersion` 分别定义为 `val` 有一个优点，即它可以被其他模块重用，并在新版本可用时在单个位置进行更改。
- en: 'To keep our examples clean and short, we''ll assume that the following inputs
    are present in every code snippet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的示例保持简洁和简短，我们假设以下输入在每个代码片段中都是现成的：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first input brings lower level actor system abstractions into scope, and
    the second allows us to use higher level DSL for an actor's behavior definition.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个输入将较低级别的 actor 系统抽象引入作用域，第二个允许我们使用更高层次的 DSL 来定义 actor 的行为。
- en: First example
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个示例
- en: First, we need to define the protocol that our `Oven` will speak. In contrast
    to the untyped implementation, we can't reuse messages that are defined by another
    actor. The reason for this is that the `Oven` (and other actors at later stages)
    defines the type of messages it is supposed to handle. This type should not be
    too general in order to avoid making the whole implementation less typed than
    desirable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义我们的 `Oven` 将要使用的协议。与无类型实现相比，我们不能重用由另一个 actor 定义的消息。这是因为 `Oven`（以及后续阶段的其他
    actor）定义了它应该处理的消息类型。这种类型不应该过于通用，以避免使整个实现比期望的更少类型化。
- en: 'The domain model is common for all actors, so we''ll define it on the `Bakery`
    app level:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型对所有 actor 都是通用的，因此我们将在 `Bakery` 应用程序级别定义它：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And this is the small language our `Oven` speaks:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们 `Oven` 使用的简短语言：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Oven` can return `ReadyCookies` (a cookie is considered to be ready as
    soon as it has been put into the oven) and `RawCookies` in the case where there
    are more cookies in the `Put` command than can fit inside the oven. The `Command`
    is a type of behavior for our actor. We can see that it includes the `sender`
    field so that the oven knows who is the receiver of the extracted cookies.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Put` 命令中的饼干数量多于烤箱容量时，`Oven` 可以返回 `ReadyCookies`（一旦饼干被放入烤箱，就被认为是准备好了）和 `RawCookies`。`Command`
    是我们 actor 的一种行为类型。我们可以看到它包括 `sender` 字段，这样烤箱就知道提取的饼干的接收者是谁。
- en: 'Now, we need to define the actor''s behavior. If you followed the previous
    chapter, you will remember that we used the internal mutable field to store the
    contents of the oven in the current moment. By using this field, we can differentiate
    its reaction on incoming messages. Akka Typed urges us to exercise a different
    approach and use separate behaviors for different states of the actor. First,
    we define what should happen in the case that there is nothing inside:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义actor的行为。如果你跟随了上一章，你会记得我们使用内部可变字段来存储烤箱在当前时刻的内容。通过使用这个字段，我们可以区分其对传入消息的反应。Akka
    Typed鼓励我们采取不同的方法，并为actor的不同状态使用不同的行为。首先，我们定义在没有任何内容的情况下的行为：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we define a behavior of the empty `Oven` using the `Behaviors` factory.
    In our case, this is a `receiveMessage` method with a type parameter called `Command`.
    This designates the type of messages our actor can handle.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用`Behaviors`工厂定义了一个空`Oven`的行为。在我们的例子中，这是一个带有类型参数`Command`的`receiveMessage`方法。这指定了我们的actor可以处理的消息类型。
- en: Next, we define a course of action in the case of the incoming `Put` command.
    The `insert` method returns a number of cookies that we can put inside the `Oven`
    and an optional overflow. In this case, if there is an overflow, we return it
    to the sender by using the `tell` method of its `ActorRef[Cookies]`. The type
    of reference allows us to send `RawCookies` back. Because of the type-safe nature
    of the actor definition, this binds the behavior of the `Baker` actor (that we'll
    implement soon) to be `Behaviors.Receive[Cookies]`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义在接收到`Put`命令的情况下的行动方案。`insert`方法返回我们可以放入`Oven`中的饼干数量以及可选的溢出。在这种情况下，如果有溢出，我们使用其`ActorRef[Cookies]`的`tell`方法将其返回给发送者。引用类型允许我们发送`RawCookies`。由于actor定义的类型安全特性，这将`Baker`actor（我们很快将实现）的行为绑定到`Behaviors.Receive[Cookies]`。
- en: 'Now, we need to define what should happen in the case that the `Oven` is not
    empty:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义当`Oven`不为空时应该发生什么：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This `Behavior` is even simpler, but still has the same type—`Behaviors.Receive[Command]`.
    We just return all of the cookies that were inside to the sender and change the
    future behavior to the `empty` behavior we defined earlier.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`行为`甚至更简单，但仍然具有相同的类型—`Behaviors.Receive[Command]`。我们只需将所有内部的饼干返回给发送者，并将未来的行为更改为我们之前定义的`empty`行为。
- en: 'Now, if we compile this implementation, we''ll get complaints from the compiler:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们编译这个实现，编译器会提出投诉：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The compiler has helped us to identify our first two bugs already! The reason
    it is unhappy with the current implementation is that we forgot to define a reaction
    to the messages that are *inappropriate* in specific states. This will be an attempt
    to extract cookies from the empty oven and to put something into the full one.
    From the type perspective, this is possible, and the compiler informed us of this.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器已经帮助我们识别出前两个错误！它对当前实现不满意的原因是我们忘记定义对特定状态下不合适的消息的反应。这将尝试从空烤箱中提取饼干并将某些东西放入满的烤箱中。从类型角度来看，这是可能的，编译器已经通知了我们这一点。
- en: 'Let''s fix this by implementing our states properly:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过正确实现我们的状态来解决这个问题：
- en: 'This is the augmented definition of an `empty` state:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`empty`状态的扩展定义：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The sender will be sent zero cookies, and we keep current behavior by using
    `Behavior.same`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 发送者将收到零个饼干，我们通过使用`Behavior.same`来保持当前行为。
- en: 'The principle stays the same for the `full` case:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`full`情况，原则保持不变：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Again, we just returned to the sender everything we've got and kept the current
    behavior exactly like we did in the empty case.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们只是将我们拥有的所有东西都返回给发送者，并保持当前行为与空情况完全一样。
- en: Akka Typed basics
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Akka Typed基础知识
- en: Now that we've made the compiler happy and got our first impression about how
    typed actors tick, let's take a more principled approach and look in detail at
    how they can be created, discovered, and stopped, and what possibilities there
    are to change an actor's behavior.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们让编译器满意，并且对我们如何使用类型化actor有了初步的了解，让我们采取更原则性的方法，详细看看它们是如何被创建、发现和停止的，以及有哪些可能性可以改变actor的行为。
- en: Creating an actor
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个actor
- en: In accordance to the actor model definition, there is exactly one way that an
    actor can be created—it can be spawned by another actor. Akka gives you two slightly
    different possibilities to do this by using `ActorContext`. Both methods are not
    thread safe and should only be used directly within the actor's thread.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'The first variant allows you to instantiate an anonymous actor from a behavior
    and returns an `ActorRef[T]`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This implementation provides a default empty value for the props parameter so
    that the actual call can be reduced to `spawnAnonymous(behavior)`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Not naming actors might be useful in specific situations, but it is considered
    to be a bad practice in general. This is because it makes debugging harder and
    looking up children by name impossible without relying on the current implementation
    details of the library.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, another realization should be preferred whenever it makes sense to use
    one:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we're required to provide a behavior and a name for an actor, which is
    about to be instantiated.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Both `spawn` and `spawnAnonymous` accept a `props` parameter, which can be used
    to further configure an actor instance. As of now, it is only possible to configure
    an actor's dispatcher.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Dispatchers make up the machinery that runs behaviors. Dispatchers use `ExecutorServices`
    to assign threads to actors and can be configured as described in [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml),
    *An Introduction to the Akka and Actor Models*. Currently, Akka Typed only supports
    the dispatchers definition from the configuration. Properties of the default dispatcher
    can be changed by overriding the settings under `akka.actor.default-dispatcher` .
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: In our example system, the `Chef` actor should instantiate `Mixers` as being
    required to work with big chunks of work in parallel. In addition, mixers use
    blocking code because of the limitations of hardware and therefore need separate
    dispatchers in order to avoid thread starvation for the rest of the system. Let's
    look at how this behavior can be implemented.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'First, by using `application.conf`, we configure a dispatcher that will be
    used for blocking mixers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we instantiate the required number of child actors:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Chef` actor has its own hierarchy of commands which we, for now, limit
    to `Mix`. We need a separate `Mixer` for each egg, so we instantiate them by using
    `spawn`. `spawn` returns an actor reference and we collect them in the `mixers`
    `val`. Finally, we return the next actor's `Behavior`, which for now is `unhandled`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so it''s possible to create new actors from an actor''s context. This brings
    us to a **Zeno''s paradox** kind of situation with Achilles and the tortoise. Naturally,
    to create a new actor, we need to have an actor already. Akka solves this paradox
    by requiring the developer to provide a definition of a root actor at the moment
    an actor system is created:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This leaves the developer with no choice but to design a proper actor hierarchy
    top-down. Following this typed approach automatically leads to avoidance of the
    *flat actor hierarchy* anti-pattern!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得开发者别无选择，只能从上到下设计合适的演员层次结构。遵循这种类型化的方法可以自动避免*扁平演员层次结构*的反模式！
- en: There is another possibility for instantiating an actor. This can be done by
    using the `ActorSystem`'s `systemActorOf` method, which creates an actor in the
    `/system` space. It is arguable that this feature shouldn't normally be used,
    and therefore it is not covered here.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化演员的另一种可能性是通过使用`ActorSystem`的`systemActorOf`方法，该方法在`/system`空间中创建一个演员。这可以是有争议的，因为这个特性通常不应该被使用，因此这里没有涵盖。
- en: Now, since our `Chef` spawned enough `Mixers` to do the job, we need a way to
    get rid of them after our work is complete.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们的`Chef`已经产生了足够的`Mixers`来完成工作，我们需要一种方法在任务完成后将它们移除。
- en: Stopping an actor
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止一个演员
- en: 'An actor can be stopped in one of the following ways:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 演员可以通过以下方式之一停止：
- en: By designating its next behavior to be `Behaviors.stopped`.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指定其下一个行为为`Behaviors.stopped`。
- en: By applying the `stop` method of the `ActorContext` to the immediate child.
    The child will finish processing the current message but leave other messages
    that are still in the mailbox unprocessed.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将`ActorContext`的`stop`方法应用于直接子演员。子演员将完成当前消息的处理，但将其他仍处于邮箱中的消息留待处理。
- en: By the actor system as it stops its ancestor. The actual shutdown happens recursively,
    bottom-up, following the hierarchy.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过演员系统在停止其祖先时。实际的关闭是递归的，从下到上，遵循层次结构。
- en: 'The most natural approach in our mixers example would be to pick the first
    option. We implement it in the following example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的混合器示例中，最自然的方法是选择第一个选项。我们将在以下示例中实现它：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Mixer` behavior is very simple, so we don't need to define an ADT for that
    and use the single `Mix` command directly. The `Chef` actor expects `Collect(Dough)` back.
    This obliges us to define it as a type parameter for the sender reference. The
    behavior itself simulates the hardware delay for the mixing to be finished, sends
    the prepared dough to the `Chef`, and returns `Behaviors.stopped` as the next
    behavior. This leads to the graceful termination of the `Mixer` actor.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mixer`行为非常简单，所以我们不需要为它定义ADT并直接使用单个`Mix`命令。`Chef`演员期望返回`Collect(Dough)`。这迫使我们将其定义为发送者引用的类型参数。行为本身模拟混合完成所需的硬件延迟，将准备好的面团发送给`Chef`，并返回`Behaviors.stopped`作为下一个行为。这导致`Mixer`演员的优雅终止。'
- en: Now that we've sent the dough back to the `Chef`, let's see how it is supposed
    to be handled. The `Chef` needs to collect the results from all of the mixers
    it has created. To do so, we could pass references to the child actors we've created
    in the idle state to the mixing behavior, but let's imagine we lost the references
    we collected for some reason. In this case, `Chef` could look up its children.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将面团送回`Chef`，让我们看看它应该如何处理。`Chef`需要收集它创建的所有混合器的结果。为此，我们可以将我们在空闲状态下创建的子演员的引用传递给混合行为，但让我们假设我们由于某种原因丢失了收集到的引用。在这种情况下，`Chef`可以查找其子演员。
- en: Discovering an actor
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现一个演员
- en: Actor discovery is an alternative way to obtain an actor reference. The preferred
    way is still to incorporate actor references into the message protocol.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 演员发现是获取演员引用的另一种替代方法。首选的方法仍然是将演员引用纳入消息协议中。
- en: 'Akka provides the possibility to look up a single child actor by name (only
    exact match) with the following method:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Akka提供了通过以下方法按名称（仅精确匹配）查找单个子演员的可能性：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This returns a reference to a child actor if a child with such a name exists
    and is alive. Please note that because of the return type of this method, the
    result needs to be coerced to the proper type by the use of the `narrow` method
    of `ActorRef`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在一个具有该名称且处于存活状态的子演员，则此操作返回对该子演员的引用。请注意，由于此方法的返回类型，需要使用`ActorRef`的`narrow`方法将结果强制转换为正确的类型。
- en: 'Another method that allows us to look up all of the children of an actor that
    are alive is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种允许我们查找一个演员所有存活子演员的方法如下：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The type of result is, again, a collection of `ActorRefs` with no particular
    type.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的类型再次是一个没有特定类型的`ActorRefs`集合。
- en: It is arguable that the lookup methods we have described here are of little
    use because of their basically untyped nature. Akka Typed offers a better alternative
    in the form of the `receptionist`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有争议的是，我们在这里描述的查找方法由于其基本无类型性质而用处不大。Akka Typed提供了一个更好的替代方案，即`receptionist`。
- en: 'The `receptionist` is a (cluster) singleton actor that is available on the
    actor system level and can be obtained from the `ActorContext` using the following
    call chain:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`receptionist`是一个（集群）单例演员，在演员系统级别可用，可以通过以下调用链从`ActorContext`获取：'
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `receptionist` is just an actor of type `[Receptionist.Command]`, so let's
    investigate the `Receptionist.Command` type to understand what it is capable of.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`receptionist`只是一个类型为`[Receptionist.Command]`的演员，因此让我们研究一下`Receptionist.Command`类型，以了解它能够做什么。'
- en: 'There are three concrete implementations of the abstract `Command` class: `Register`, `Find`,
    and `Subscribe.`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象`Command`类有三个具体实现：`Register`、`Find`和`Subscribe`。
- en: '`Register` is used for associating the given `ActorRef` with the provided `ServiceKey`.
    It is possible to register multiple references for the same key. The registration
    is automatically removed from the receptionist if the registered actor is stopped.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Register`用于将给定的`ActorRef`与提供的`ServiceKey`关联。对于同一个键，可以注册多个引用。如果注册的演员停止，注册会自动从接待员那里移除。'
- en: By providing an optional reference, it is possible to provide another actor,
    who should be notified if the service was successfully registered.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供一个可选的引用，可以提供另一个演员，如果服务成功注册，该演员应该被通知。
- en: '`Find` is a mechanism for asking the receptionist about all currently known
    registered actors for the given `ServiceKey`. The receptionist responds with a
    `Set` of known actor references (which are called **services**) that are registered
    to the given key, and a key itself wrapped in a `Listing`. `Find` can be used
    to implement one-time queries to the receptionist.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Find`是一种询问接待员关于给定`ServiceKey`所知所有已注册演员的机制。接待员会以一个包含已知演员引用（称为**服务**）的`Set`以及一个包裹在`Listing`中的键本身作为响应，这些演员引用已注册到给定的键。`Find`可以用来实现一次性查询接待员。'
- en: '`Subscribe` is a way to implement push behavior for the receptionist. An actor
    can use subscribe to receive notifications about all added or removed services
    for some predefined key.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subscribe`是一种实现接待员推送行为的途径。一个演员可以使用`subscribe`来接收有关某些预定义键中添加或删除的所有服务的通知。'
- en: In our example, the `Manager` actor is used to provide a `Boy` with a reference
    to the `seller` actor. The `Boy` is supposed to communicate with the provided
    reference. In the previous chapter, we used untyped Akka's remote lookup to get
    this reference. In the typed environment, we will utilize the receptionist for
    this purpose.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`Manager`演员被用来向`Boy`提供一个`seller`演员的引用。`Boy`应该与提供的引用进行通信。在前一章中，我们使用了无类型的Akka远程查找来获取这个引用。在类型化环境中，我们将利用接待员来完成这个目的。
- en: This is how it is done.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的实现方式。
- en: 'First, the `seller` behavior needs to register itself with the receptionist
    at the moment it is initialized:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`seller`行为需要在初始化时向接待员注册自己：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Shop` defines the `SellerKey` that will be used by the actor to register
    as a service and by the service clients to look up the seller's reference.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shop`定义了`SellerKey`，该键将由演员用来注册为服务，并由服务客户端用来查找卖家的引用。'
- en: 'Next, we introduce a new type of behavior constructor—`Behaviors.setup`. `setup`
    is a behavior factory. It takes the behavior constructor as a by-name parameter
    and creates the behavior at the moment the actor is started (as opposed to the
    moment the behavior is constructed). We need to use this factory for two reasons:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍一种新的行为构造函数类型—`Behaviors.setup`。`setup`是一个行为工厂。它接受行为构造函数作为按名参数，并在演员启动时创建行为（与行为构造时不同）。我们需要使用这个工厂有两个原因：
- en: We need our actor to be instantiated so that we can access its context
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要我们的演员被实例化，这样我们才能访问其上下文
- en: We want our `Seller` to register itself exactly once
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望我们的`Seller`正好注册一次
- en: After registering the `Seller` with the receptionist, the real behavior is constructed.
    The behavior itself is just accepting the `SellByList` messages and responding
    with the `Groceries` that are to be provided to the `toWhom` reference.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`Seller`注册到接待员之后，实际的行为被构造。行为本身只是接受`SellByList`消息，并针对`toWhom`引用响应提供的`Groceries`。
- en: 'On the opposite side of the receptionist, the `Manager` actor needs to look
    up the `Seller` and use its reference to guide the `Boy`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在接待员的另一边，`Manager`演员需要查找`Seller`并使用其引用来引导`Boy`：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There is quite a bit going on here. Once again, we're using `setup` to define
    the behavior.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多事情在进行。再次使用`setup`来定义行为。
- en: Looking up actors is an asynchronous operation, and in this case, we utilize
    the `ask` pattern to keep the code concise. Ask needs to know how long it is allowed
    to wait for the answer, so, in the second line, we define a `lookupTimeout`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 查找演员是一个异步操作，在这种情况下，我们利用`ask`模式来使代码简洁。Ask需要知道它允许等待答案多长时间，因此，在第二行，我们定义了一个`lookupTimeout`。
- en: Then, we call the `ask` method that's available in the actor context and provide
    a reference of a `receptionist` as an actor to be asked. The second parameter
    is the receptionist's `Find` command, which is given a seller key. Normally, the
    `Find` command takes a second parameter that defines a receiver for the response,
    but as it is used quite often together with `ask`, there is a special constructor
    that allows for the nice syntax we are using in this snippet.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在演员上下文中调用可用的`ask`方法，并提供一个`receptionist`作为演员的引用来询问。第二个参数是接待员的`Find`命令，它被赋予了一个卖家键。通常，`Find`命令接受一个第二个参数，该参数定义了响应的接收者，但因为它经常与`ask`一起使用，所以有一个特殊的构造函数允许我们使用在这个片段中使用的良好语法。
- en: The case literal, which comes next, defines a transformation that must be applied
    to the response before actually sending it back to the asking actor. It deconstructs
    and converts the receptionist's response so that it is either a `NoSeller` or
    just one `OneSeller`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的情况字面量定义了一个在实际上将响应发送回询问演员之前必须应用到响应上的转换。它解构并转换接待员的响应，使其成为`NoSeller`或只是一个`OneSeller`。
- en: 'Next, we have to deal with the converted response by defining a behavior which
    is returned as a result of this lengthy factory method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须通过定义一个行为来处理转换后的响应，这个行为是这个漫长的工厂方法的结果：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the current manager's behavior, we only expect a small subset of all of the
    possible messages to arrive. We're using `receiveMessagePartial` to avoid compiler
    warnings for unhandled message types.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前的管理员行为中，我们只期望收到所有可能消息的小子集。我们使用`receiveMessagePartial`来避免未处理消息类型的编译器警告。
- en: In this case, if there is no seller, we can use the `log` that's available in
    the actor's `context` to report this condition and return the current behavior.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果没有卖家，我们可以使用演员的`context`中可用的`log`来报告这种状态并返回当前的行为。
- en: 'In this case, if there is a `Seller` available, we instantiate a `Boy` and
    use it to transfer a `shoppingList` to this seller. Note how we used `context.self`
    as a second parameter for the `GoShopping` message. By doing this, we''re making
    it possible to use the provided manager''s reference to persuade the `Seller`
    to send groceries directly to the `Manager`, and then the `Boy` can immediately
    stop itself after sending the message:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果有`Seller`可用，我们实例化一个`Boy`并使用它将`shoppingList`传递给这个卖家。注意我们如何使用`context.self`作为`GoShopping`消息的第二个参数。通过这样做，我们使提供的管理员引用能够说服`Seller`直接将杂货发送给`Manager`，然后`Boy`在发送消息后可以立即停止自己：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we have seen how the `GoShopping` command prohibits us from interchanging
    actor references for the seller and manager, as this could easily happen in the
    case of untyped Akka.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了`GoShopping`命令如何禁止我们交换卖家和经理的演员引用，因为在无类型的Akka中这种情况很容易发生。
- en: Akka Typed – beyond the basics
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Akka Typed – 超越基础
- en: We've defined the behavior of the `Chef` actor to distribute work across mixers
    but left the waiting part uncovered, so let's look at that now.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了`Chef`演员的行为，以便在混合器之间分配工作，但留下了等待部分未覆盖，所以现在让我们看看这一点。
- en: 'We left the `Chef` definition for the `mixing` behavior as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Chef`的`mixing`行为的定义留给了以下内容：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Actually, the `Chef` needs to know about the mixers that were created by its
    `idle` behavior. Though technically it is possible to do a children lookup, as
    described earlier, doing so will introduce an implicit assumption that, at the
    moment, we'll get the listing stating that all of the mixers are still processing
    jobs. This assumption might be wrong in a highly concurrent environment or in
    the case of failed mixers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`Chef`需要了解由其`idle`行为创建的混合器。虽然从技术上讲，我们可以执行子查找，如前所述，这样做将引入一个隐含的假设，即在这个时刻，我们会得到一个列表，表明所有的混合器仍在处理工作。这个假设在高度并发的环境中或混合器失败的情况下可能是错误的。
- en: 'Therefore, we need to refactor the behavior constructor a bit:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要对行为构造函数进行一点重构：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we have a builder that captures all of the parts of the Chef''s state. Let''s
    see how these parts are used in the definition of its behavior:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个构建器，它捕获了`Chef`状态的所有部分。让我们看看这些部分如何在它的行为定义中使用：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We're already familiar with the constructor. In the behavior itself, we count
    every `Dough` message received from the mixer and recreate the behavior with the
    new state. In this case, if all of the mixers have delivered their parts, we return
    the result to the manager and go to the `idle` state.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Life cycle of an actor
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our implementation of the `Mixer` is quite naive and does not take into account
    that hardware occasionally breaks.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Conventionally, in Akka, we distinguish between expected and unexpected failures.
    An expected failure of some operation, for example, a validation error is usually
    represented on the protocol level with the appropriate message types. Exceptional
    conditions of an unexpected nature such as hardware errors, are communicated by
    throwing exceptions. This allows you to separate handler definitions for successful
    and erroneous paths, which leads to the separation of business logic from the
    technical details of the underlying platform. Thus, having a rich set of exceptions
    is a prerequisite for proper error-handling definitions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take this aspect into account. We''ll represent unreliable hardware
    by defining a set of exceptions, one for every possible failure. We''ll do this
    the same way as we did in [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml),
    *An Introduction to the Actor Model and Akka*:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, in order to simulate the hardware failure, we''ll add some code with the
    purpose of throwing defined exceptions to the logic of the `Mixer`. To keep the
    example simple, let''s just throw one of them:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It looks like it is very warm in our bakery. The mixer motors are overheating
    roughly every second time the `Chef` tries to mix the `Groceries`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Actors can watch themselves by calling the `receiveSignal` method on the actor's
    context and providing a `PartialFunction[(ActorContext[T], Signal), Behavior[T]]`
    as a parameter. The provided partial function will be called, with a life cycle
    message as a parameter, if the actor terminates or restarts.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'This possibility for self-watching can be useful to change the behavior of
    the actor in appropriate cases. The following code snippet shows how mixers can
    monitor themselves:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In our case, mixers just write into the log what kind of life-changing event
    had happened and keep the same behavior. To take a look at the situations in which
    `PostStop`, `PreRestart`, and `Terminated` events happen, we first need to become
    familiar with the concept of supervision.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Supervision
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In essence, supervision in Akka Typed refers to the fact that all exceptions
    thrown from a behavior are caught and acted upon. An action can have one of three
    forms: resume, restart, and stop.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how supervision can be defined and which effect it has.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s run our system as it is and observe its output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can see how our actors start processing messages up to the point where an
    exception is thrown by the `Mixer`. This exception is handled using the default
    supervision strategy that is stopping the actor. The mixer logs the `PostStop`
    event via the monitoring function we defined earlier and attaches it to the actor''s
    behavior, like so:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s see what will happen if we override the default supervision strategy.
    To change the behavior, we just wrap it into the supervising behavior by using
    the standard constructor. Let''s restart the mixer instead of stopping it in the
    case of the motor overheating:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we use this behavior by using the `Chef` actor to create mixers, running
    the app will produce a slightly different output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, the exception has been reported by the supervisor and the mixers have been
    restarted, as we can conclude by observing the `PreRestart` events that have been
    logged by the mixers. There is no `PostStop` event here.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'There is still one more supervision strategy to look at, so let''s check it
    out:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With this strategy, we''ll still see a log output from the supervisor, but
    actors won''t log any life cycle events:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It is possible to define different supervision strategies for different types
    of exceptions that are thrown by the same behavior by nesting supervisor constructors:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The definition is obviously a bit verbose.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The supervision strategies are sticky. They are recursively applied to new behaviors
    that are returned by the supervised behavior.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, it might be useful to try and restart an actor a few times, and
    if the situation is not improving, then finally stop it. A special constructor
    is available for this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In an unlucky case, the mixer actor would throw an exception from the `Behavior.setup`
    constructor every time it was constructed, and we would see the following output:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The supervisor tried to restart the actor four times, but then gave up and stopped
    it. Because of the fact that the failure happened in the setup block, the actor
    was able to receive neither the `Mix` command nor life cycle event notifications.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Watching an actor
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we look back to the `Chef` actor's implementation, we'll be able to see that
    our system is now stuck. This happened because, if mixers fail, they are stopped
    by an external supervising force. However, the `Chef` actor is still waiting for
    this mixer's part to work. It turns out that we need a way to inform the `Chef`
    about terminated mixers.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Akka Typed offers a watching mechanism for this. To watch for mixers that were
    stopped, we''ll add the following code to the `Chef`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, for each spawned `Mixer`, we''re calling `context.watchWith`. The first
    parameter is an actor to watch and the second parameter is a message adapter.
    The need for the message adapter comes from the fact that the *proper* message
    type for the terminated actor would be `akka.actor.typed.Terminated`. We could
    use a watch, taking just a single actor reference, to subscribe to this message
    type—`def watch[T](other: ActorRef[T]): Unit`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'But, the fact is that our `Chef` can''t handle this message type because it
    does not belong to its `Command` type. Therefore, we would need to define a separate
    actor type to watch for mixer terminations. Instead, we need to use the *extended*
    version of the watch method, which takes a message to be sent as a second parameter.
    The `BrokenMixer` message is defined and handled as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this case, if we detect a terminated child actor, the `Chef` writes a log
    entry and sends itself a message to compensate for the lost part of the work.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have the `Dough` ready and need a `Cook` to form cookies and a `Baker`
    to bake them in the `Oven`. The implementation of the `Cook` is trivial—it just
    converts `Dough` into a number of `RawCookies` and sends them back to the manager.
    Please refer to the code in the GitHub repository if you're interested in the
    implementation details.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Timers
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Baker` is more interesting. First of all, it needs a single `Oven`. We''ll
    implement this by using a special behavior that we''ll execute only once:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, let''s define the `idle` behavior that''s just waiting for work:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we expect a message from the manager telling us to bake cookies. Then,
    we use a new behavior constructor, `withTimers`, which gives us access to the `TimerScheduler`.
    With the scheduler, it is possible to define periodic and single timers that have
    been identified by some key. The definition of a new timer with the same key cancels
    the previously defined timer and also removes messages that have been sent by
    it, if they are still in the message box of the actor.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Here, we're using the timer as a kitchen clock to set up a single reminder to
    check the `Oven` after baking time passes.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Stashing
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another challenge is that the `Baker` needs to accept `RawCookies` from the
    `Manager` as required, but needs to bake them in batches because of the oven's
    limited capacity. Basically, it needs to manage a queue of the `RawCookies`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: We'll implement this by using a stash. By using stashing, our actor will buffer
    messages that cannot be handled by the current behavior and replay them before
    switching to the alternative behavior in which buffered messages are supposed
    to be handled.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this approach is reflected in the baking behavior of the actor:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: First, we define a buffer that will contain our stashed messages.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The stash is keeping messages in memory. By stashing too many messages, it is
    possible to crash the system with an `OutOfMemory` error. The capacity parameter
    helps to avoid this situation. But, in the case that the specified capacity is
    too low, the `StashOverflowException` will be thrown after an attempt to stash
    a message into the full buffer.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Then, we handle four types of messages. `CheckOven` is a reminder that is sent
    to the `Baker` by the timer so that it does not forget to extract cookies from
    the `Oven`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `TooManyCookies` (which is a message from the `Oven` returning
    cookies that did not fit into it) or `BakeCookies` being received from the manager,
    the `Baker` stashes them until it becomes idle again and is able to process baking
    work.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '`CookiesReady` indicates that the `Oven` is now empty, so we forward the cookies
    to the `Manager`, unstash all of the messages, and go to the `idle` state.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Combining behaviors
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have defined every worker in the bakery, it is time to finally get us
    a `Manager`. In [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml), *An
    Introduction to the Akka and Actor Models*, we implemented a `Manager` using the
    FSM library. In Akka Typed, we can achieve the same effect without any libraries
    just by defining atomic behaviors for each state and then returning the appropriate
    behavior as required:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we have defined two behaviors, and each of them expects a specific message
    type, performs the required message passing to the managed actors, and returns
    the next behavior in the chain. This way, it is possible to model the serial behavior
    we implemented with untyped Akka.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can do better. Akka Typed allows us to combine behaviors so that
    we can implement a parallel version of the `Manager` by chaining behaviors together
    and returning the combined behavior from every atomic behavior we define:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, the `manage` constructor is used to define atomic behaviors for each message
    type the `Manager` is supposed to be able to handle. Then, the existing behaviors
    are combined into one. This makes our `Manager` capable of processing every message
    in any processing state.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Cluster
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Bakery` is now in place, but we would still like the grocery store to run
    as a separate actor system, just like we had it in the previous chapter. With
    untyped Akka, we implemented this communication with the help of remoting, but
    remoting is not available in the typed setup. With Akka Typed, we can achieve
    this with the help of clustering.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Akka clustering is a group of Akka systems working as a dynamic whole. This
    is the main difference from Akka remote, on top of which clustering is built.
    A single system represents one node from the cluster. An actor can exist anywhere
    in the cluster. Some of the features of clustering include load balancing (routing
    messages to specific nodes in the cluster), node partitioning (assigning specific
    roles to nodes), and cluster management (fault-tolerant node membership), to name
    a few. In our example, we don't use any advanced clustering features, and instead
    just throw it in an order so that we have the possibility to communicate with
    a remote actor system.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to use clustering in our project, we need to add the following dependency
    to `build.sbt`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Clustering also requires that a few configuration parameters are defined. We
    can provide them by putting the following additional lines into `application.conf`. This
    will be the default configuration used by the `Bakery`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The configuration for the `Store` is defined by importing the default configuration
    and overriding the port definition:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we need to instantiate an actor system for `Store`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And we need another one for the `Bakery` itself:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Both of these defined actor systems can now be started and will simulate baking
    cookies by acquiring the required resources from the remote system via clustering.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: We just demonstrated Akka's location transparency by turning a local actor system
    into clustered one just by changing the configuration.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, we have a working `Bakery` implementation, but we cannot be sure
    that our actors are doing what we expect them to do. Let's fix this by testing
    their behavior.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Testing actors is notoriously difficult because of their concurrent nature and
    message orientation. Luckily, in Akka Typed, an actor's behavior is just a function
    and thus can generally be tested in isolation. There are cases where we might
    want to test the interaction between actors, and in this case, it is inevitable
    to resort to asynchronous testing.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: In synchronous setup, we create a behavior under test, send events that it should
    be able to react on, and verify that the behavior produces the expected effects
    (for example, spawning or stopping child actors) and sends further required messages.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous scenario brings this approach into the context of a test actor
    system, which is close to a real one. We will see how this is done in practice
    in a moment.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies and setup
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To automate repetitive tasks such as setting up testing environments for actors,
    Akka Typed provides a test kit in the same way Akka untyped does. We need the
    following dependencies to be present in `build.sbt` so that we can use it within
    our project:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Having both of them in scope will allow us to create `ScalaTest` specifications
    and use the Akka Typed test kit functionality.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, in regards to synchronous actor testing, we do not
    need to have an `ActorSystem`. The only dependency, in this case, is an actor
    context. Akka provides a factory for building special testing actor contexts in
    the form of the `BehaviorTestKit`. A skeleton of the `ScalaTest` specification,
    in this case, could look as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the case of asynchronous testing, we have to extend the `ActorTestKit` to
    have a test actor system in the scope of the specification. This actor system
    needs to be shut down after all tests are finished running in order to prevent
    resource leakage. Because of this, the minimal specification in the case of asynchronous
    testing will look a bit more involved:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, it is time to look at the different features Akka `TestKit` has to offer
    to simplify checking the correctness of the actor-based system.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous testing
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `BehaviorTestKit` provides the possibility to verify the reaction of an
    actor behavior to specific messages. The reaction can be in the form of an `Effect`
    (different ways of spawning and stopping children actors), sending and receiving
    messages, and changes in behavior. Let''s illustrate this testing process with
    an example:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we have wrapped a `goShopping` behavior into the `BehaviorTestKit` so
    that we can test it synchronously. The two `TestInbox` references represent actors
    that the `Boy` is supposed to communicate with. They are basically `ActorRefs`,
    but they allow us to express expectations regarding incoming messages. To trigger
    the test, we can create a message and run the `testKit` using this message as
    an input.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: In the next line, we expect the `seller` actor to receive the same message,
    with the `manager` reference being propagated as a sender. This is how our boy's
    logic is supposed to work. Then, we verify that the `Boy` stopped itself by checking
    that it is not alive. Finally, we don't expect any effects on children as the
    `Boy` actor is not supposed to have or create any children.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way that we tested that the `Boy` has no effects on children, we
    can test that the `Chef` has such effects:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this test, we create a behavior under test in the same way we just did with
    the `Boy` actor. We create a message and run it with the testing behavior wrapper.
    As a result, we expect a `chef` to have the effect of spawning a single `Mixer`
    actor with an appropriate name and dispatcher. Finally, we're looking up the mailbox
    of the spawned child actor by using the `childInbox` method and expect it to have
    a message that's been sent by the `chef` to be present in it.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, at the time of writing this book, the Akka `TestKist` still has
    some rough edges that require us, in this specific case, to refactor our `Chef`
    behavior to accept the mixer factory as a parameter. The reason for this is that
    behaviors are compared by reference, which requires us to have the same instance
    of the behavior for the test to pass.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Another limitation of the `BehaviorTestKit` is its lack of support for extensions
    like cluster, cluster singleton, distributed data, and receptionist. This makes
    it impossible to test the `Seller` actor in a synchronous setup because this actor
    registers itself with the `receptionist`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We could use the synchronous approach or we could refactor the seller to take
    a constructor function for the receptionist and provide a mock receptionist in
    the test. This is an example of how this can be done in the code of the `Seller`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The factory is just a function from `ActorContext` to the `ActorRef` with the
    appropriate types.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'With this change, we can implement our test, as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We provide a mock receptionist which is just a `TestInbox[Receptionist.Command]`
    and use it as the result of the factory, ignoring the actual actor context. Then,
    we execute the test as we did previously and expect the messages to be sent to
    the `manager` and `receptionist` appropriately.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous testing
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Synchronous testing is a good and deterministic way to test actor logic, but
    sometimes it is just not enough, for example, when testing specific aspects of
    communication between actors. Another example is having asynchronous code in the
    actor's behavior, for example, `Feature` or scheduler, which needs to be finished
    before test assertions can be executed.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: One example of such a situation is the `Baker` actor. We expect it to check
    the `Oven` after some predefined time interval. Unfortunately, this interval is
    hardcoded, so there is no possibility of being able to override it in the test
    and we need to wait for the timer to trigger.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: As part of the asynchronous testing toolkit, Akka provides a `ManualTimer`,
    which can be used to advance time in tests in a flexible manner. We'll use it
    to reliably test our `Baker` actor.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to provide an appropriate configuration for the manual timer.
    We do this by overriding the `config` method of the actor system which is represented
    by the `ActorTestKit` and define an instance of the time we''ll use in our test:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, we can specify the testing logic:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this scenario,  we create an `oven` and a `manager` using `TestProbe` (as
    opposed to the `TestInbox` we used before) and also a `baker` behavior using the
    `spawn` method of the `ActorTestKit`. We send a request to the `baker` and expect
    it to react appropriately by putting a single cookie into the oven.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can see that the `baker` waits for the cookies to be ready by checking
    that no messages are sent during this period of time. We're using the annual time
    here, and because of this, the check itself is done instantly. Finally, we manually
    advance the timer so that the `baker` needs to extract the cookies from the oven
    and verify that this has indeed happened, and that the `oven` received the `Extract`
    message as expected.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: The application has been successfully tested; let's wait no more and run it!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please refer to [Appendix A](bc164888-625c-460a-9b0b-e6c45c9eb074.xhtml), *Preparing
    the Environment and Running Code Samples*, if you don't have Java and SBT installed
    yet.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'We will run our application in the Terminal in the same way as we did in the
    previous chapter by using two separate terminal sessions for `Store` and `Bakery`.
    It is possible to run both in interactive mode, or by issuing one of the two following
    commands in the corresponding shell:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Because we''re using clustering instead of remoting for our example, we don''t
    need to start them in a particular order as we had to in the previous chapter.
    The following screenshot shows two Terminal windows ready to run the application
    with the aforementioned commands typed in:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e6f8daa-7acc-4b5f-b97b-5634362a35d8.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
- en: 'As both parts of the application start, they will establish a connection and
    start to work together to produce cookies. The following screenshot shows us that
    the bakery part of the application is already running and waiting for the store
    to start on the right-hand side of the screen:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/983c3c61-8573-4c06-849d-dac0e4829373.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
- en: If you'd like to start the demo in interactive mode from the SBT shell, please
    refer to [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml), *An Introduction
    to the Akka and Actor Models*, where we explained how to do this in detail.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Akka Typed allows you to implement an actor system in a type-safe way. It represents
    actor logic as a well-typed behavior with the types of both input and output channels
    determined at compile time. Behaviors can be combined together, allowing for a
    higher degree of code reuse.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Typed actors are not only supposed to receive and send messages but are also
    required to explicitly define a new behavior after processing every message. Interactions
    with other actors are limited to creating, stopping, looking up, and watching
    children, and getting typed references to explicitly registered services.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Actor context provides useful functionality, such as timers and stashing.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Typed supervision is defined directly on behavior, and the failure propagation
    to the parent actor must be implemented explicitly if needed. The Akka team took
    a holistic approach by promoting an actor's life cycle hooks, from methods to
    events.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Actors in typed Akka are basically just functions. Because of this, testing
    is not limited to asynchronous communication as it was before. This can be done
    synchronously, thus allowing for deterministic and stable test code that executes
    quickly.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Akka Typed offers a set of useful extensions like cluster, cluster singleton,
    persistence, and distributed data. We touched briefly upon how the cluster module
    allows us to utilize the existing code in a distributed scenario by solely changing
    the configuration of the system. Please refer to the Akka Typed official documentation
    online ([https://doc.akka.io/docs/akka/current/typed/index.html](https://doc.akka.io/docs/akka/current/typed/index.html)) 
    to explore further capabilities provided by the typed actor's toolkit.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to implement the bakery once again, this time
    using yet another Akka library—Akka Streams.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
