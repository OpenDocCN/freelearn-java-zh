- en: Building Reactive Applications with Akka Typed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter reveals another way to build reactive applications with Akka. We
    will introduce Akka Typed, an Akka module which implements the actor model in
    a slightly different way compared to untyped Akka. We will contrast *classical* and
    typed approaches and show how the latter reduces the developer's choices but increases
    type safety and simplifies reasoning about actor-based programs during the maintenance
    phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Differences between typed and untyped approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating, stopping, and discovering actors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The life cycle of an actor and supervision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schedulers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stashing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining behaviors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we begin, make sure you have the following installed:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 1.8+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SBT 1.2+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available on our GitHub repository at:
    [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter12](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter12)[.](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter02)'
  prefs: []
  type: TYPE_NORMAL
- en: The code snippets in this chapter have been simplified a bit to omit unnecessary
    technical details. Please refer to the GitHub repository for fully functioning
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml), *An Introduction
    to the Akka and Actor Models*, we discovered the actor model and how Akka implements
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original actor paper states three possible actions that actors can perform
    as computational units:'
  prefs: []
  type: TYPE_NORMAL
- en: They can send messages to other known actors
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: They can create new actors
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They can designate behavior for future message processing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of the universality of this model, the specifics of how these points
    are to be implemented depends on the hardware, operating system, programming language,
    existing libraries, and ultimately on the design choices of the implementer. Akka
    Typed offers a slightly different programming model compared to untyped Akka.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, in this chapter, we'll refer to normal Akka as Akka untyped to
    be specific about which library is being mentioned, even though *untyped* Akka
    was always named just *Akka* in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a closer look at the differences and similarities between the two
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: The typed approach and the differences between Akka untyped
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compared to the untyped version, Akka Typed takes a slightly different approach
    to define what an actor is.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Akka untyped, an actor is any object that is a subclass of an abstract `Actor`
    and overrides a `def receive: PartialFunction[Any, Unit]` method. This allows
    the developer to do anything in the implementation except return a meaningful
    result, which makes it hard to reason about the code and impossible to combine
    actor logic.'
  prefs: []
  type: TYPE_NORMAL
- en: Akka Typed declares that any well-defined behavior is a computation entity and
    thus can be declared to be an actor. The *well-defined* in terms of Akka Typed
    means anything that defines a statically typed `Behavior`. The type of `Behavior`
    limits actors to receiving messages of this specific type only. The return type
    of the actor's behavior is required to be the next `Behavior` of the same type
    with respect to inheritance. This way, it is possible to ensure at compile time
    that the actor will receive only messages of the type it declares to handle.
  prefs: []
  type: TYPE_NORMAL
- en: In order to achieve this, actor addresses also need to be typed, and the type
    of address needs to be known at compile time. Hence, features of untyped Akka
    such as implicit access to the sender of the present message and general actor
    lookup are not available in typed Akka. By contrast, actor's addresses need to
    be defined as part of the protocol or need to be managed by an external (to the
    actor) facility.
  prefs: []
  type: TYPE_NORMAL
- en: Another notable change is the introduction of `Signal` message types, which
    represent events in the life cycle of an actor and replace dedicated callback
    methods that were exposed by the `Actor` class in untyped Akka. Although this
    is not a very big spot in a whole picture of changes, it is a good move to make
    the implementation of Akka's actor model closer to the abstract actor model.
  prefs: []
  type: TYPE_NORMAL
- en: In short, Akka Typed restricts actor communication and behavior to the model,
    which can then be type checked at compile time. This limits the developer's choices
    and possibilities for the implementation, but at the same time makes the result
    easier to reason about and test. The unavailability of some untyped features makes
    it impossible to write code in a way that represents an Akka anti-pattern and
    leads to solutions resembling what are considered to be the best practices in
    *normal* Akka.
  prefs: []
  type: TYPE_NORMAL
- en: This module is currently marked as **may change** ([https://doc.akka.io/docs/akka/2.5/common/may-change.html](https://doc.akka.io/docs/akka/2.5/common/may-change.html)). This
    reflects the fact that the topic itself is the subject of active research and
    there might be some changes in the API. However, the current implementation is
    solid and changes in the API are minimal among recent version updates. Therefore,
    the Akka team considers Akka Typed to be production-ready.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at what these differences look like in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Example actor system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To illustrate features of Akka Typed, we'll reimplement an example we built
    in [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml), *An Introduction
    to the Akka and Actor Models*, but this time with typed actors.
  prefs: []
  type: TYPE_NORMAL
- en: For those readers who are familiar with the content of the previous chapter,
    this approach will allow you to compare two different styles. For those who just
    joined, let's quickly recap the structure of this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re building a small cookie bakery which is populated by a number of actors,
    each with their own set of responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Manager` drives the process and passes over materials from one worker to
    another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Boy` takes a `ShoppingList` and returns to the `Manager` the respective
    `Groceries` from the `Store`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Chef` takes the `Groceries` and makes them into `Dough`. It does so by
    using a number of `Mixers` with the exact mixer count depending on the amount
    of stuff to mix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Cook` takes `Dough` and makes `RawCookies`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Baker` bakes the `RawCookies` in batches using a single `Oven` of a limited
    capacity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The structure of the actor system we''re going to build is represented in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59a948d7-2089-4789-a569-df739e16b199.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's start with an implementation of the simplest actor in our system – the
    **Oven**. Here and later on in this chapter, we'll refer to the previous implementation,
    meaning the implementation we came up with in regards to untyped actors in [Chapter
    11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml), *An Introduction to the Akka
    and Actor Models*. The differences are very illustrative, so we advise the reader
    to refer to the code in the previous chapter, even if you haven't read it because
    you are already familiar with untyped Akka.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to use Akka `Typed` in our code, we need to put the following dependency
    in `build.sbt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Defining `akkaVersion` separately as a `val` has the advantage that it can be
    reused for other modules and changed in a single place at the moment a new version
    becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep our examples clean and short, we''ll assume that the following inputs
    are present in every code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first input brings lower level actor system abstractions into scope, and
    the second allows us to use higher level DSL for an actor's behavior definition.
  prefs: []
  type: TYPE_NORMAL
- en: First example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we need to define the protocol that our `Oven` will speak. In contrast
    to the untyped implementation, we can't reuse messages that are defined by another
    actor. The reason for this is that the `Oven` (and other actors at later stages)
    defines the type of messages it is supposed to handle. This type should not be
    too general in order to avoid making the whole implementation less typed than
    desirable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The domain model is common for all actors, so we''ll define it on the `Bakery`
    app level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is the small language our `Oven` speaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Oven` can return `ReadyCookies` (a cookie is considered to be ready as
    soon as it has been put into the oven) and `RawCookies` in the case where there
    are more cookies in the `Put` command than can fit inside the oven. The `Command`
    is a type of behavior for our actor. We can see that it includes the `sender`
    field so that the oven knows who is the receiver of the extracted cookies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to define the actor''s behavior. If you followed the previous
    chapter, you will remember that we used the internal mutable field to store the
    contents of the oven in the current moment. By using this field, we can differentiate
    its reaction on incoming messages. Akka Typed urges us to exercise a different
    approach and use separate behaviors for different states of the actor. First,
    we define what should happen in the case that there is nothing inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a behavior of the empty `Oven` using the `Behaviors` factory.
    In our case, this is a `receiveMessage` method with a type parameter called `Command`.
    This designates the type of messages our actor can handle.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define a course of action in the case of the incoming `Put` command.
    The `insert` method returns a number of cookies that we can put inside the `Oven`
    and an optional overflow. In this case, if there is an overflow, we return it
    to the sender by using the `tell` method of its `ActorRef[Cookies]`. The type
    of reference allows us to send `RawCookies` back. Because of the type-safe nature
    of the actor definition, this binds the behavior of the `Baker` actor (that we'll
    implement soon) to be `Behaviors.Receive[Cookies]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to define what should happen in the case that the `Oven` is not
    empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This `Behavior` is even simpler, but still has the same type—`Behaviors.Receive[Command]`.
    We just return all of the cookies that were inside to the sender and change the
    future behavior to the `empty` behavior we defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we compile this implementation, we''ll get complaints from the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The compiler has helped us to identify our first two bugs already! The reason
    it is unhappy with the current implementation is that we forgot to define a reaction
    to the messages that are *inappropriate* in specific states. This will be an attempt
    to extract cookies from the empty oven and to put something into the full one.
    From the type perspective, this is possible, and the compiler informed us of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fix this by implementing our states properly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the augmented definition of an `empty` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The sender will be sent zero cookies, and we keep current behavior by using
    `Behavior.same`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The principle stays the same for the `full` case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Again, we just returned to the sender everything we've got and kept the current
    behavior exactly like we did in the empty case.
  prefs: []
  type: TYPE_NORMAL
- en: Akka Typed basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've made the compiler happy and got our first impression about how
    typed actors tick, let's take a more principled approach and look in detail at
    how they can be created, discovered, and stopped, and what possibilities there
    are to change an actor's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an actor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In accordance to the actor model definition, there is exactly one way that an
    actor can be created—it can be spawned by another actor. Akka gives you two slightly
    different possibilities to do this by using `ActorContext`. Both methods are not
    thread safe and should only be used directly within the actor's thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first variant allows you to instantiate an anonymous actor from a behavior
    and returns an `ActorRef[T]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This implementation provides a default empty value for the props parameter so
    that the actual call can be reduced to `spawnAnonymous(behavior)`.
  prefs: []
  type: TYPE_NORMAL
- en: Not naming actors might be useful in specific situations, but it is considered
    to be a bad practice in general. This is because it makes debugging harder and
    looking up children by name impossible without relying on the current implementation
    details of the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, another realization should be preferred whenever it makes sense to use
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're required to provide a behavior and a name for an actor, which is
    about to be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: Both `spawn` and `spawnAnonymous` accept a `props` parameter, which can be used
    to further configure an actor instance. As of now, it is only possible to configure
    an actor's dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: Dispatchers make up the machinery that runs behaviors. Dispatchers use `ExecutorServices`
    to assign threads to actors and can be configured as described in [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml),
    *An Introduction to the Akka and Actor Models*. Currently, Akka Typed only supports
    the dispatchers definition from the configuration. Properties of the default dispatcher
    can be changed by overriding the settings under `akka.actor.default-dispatcher` .
  prefs: []
  type: TYPE_NORMAL
- en: In our example system, the `Chef` actor should instantiate `Mixers` as being
    required to work with big chunks of work in parallel. In addition, mixers use
    blocking code because of the limitations of hardware and therefore need separate
    dispatchers in order to avoid thread starvation for the rest of the system. Let's
    look at how this behavior can be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, by using `application.conf`, we configure a dispatcher that will be
    used for blocking mixers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we instantiate the required number of child actors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `Chef` actor has its own hierarchy of commands which we, for now, limit
    to `Mix`. We need a separate `Mixer` for each egg, so we instantiate them by using
    `spawn`. `spawn` returns an actor reference and we collect them in the `mixers`
    `val`. Finally, we return the next actor's `Behavior`, which for now is `unhandled`.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so it''s possible to create new actors from an actor''s context. This brings
    us to a **Zeno''s paradox** kind of situation with Achilles and the tortoise. Naturally,
    to create a new actor, we need to have an actor already. Akka solves this paradox
    by requiring the developer to provide a definition of a root actor at the moment
    an actor system is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This leaves the developer with no choice but to design a proper actor hierarchy
    top-down. Following this typed approach automatically leads to avoidance of the
    *flat actor hierarchy* anti-pattern!
  prefs: []
  type: TYPE_NORMAL
- en: There is another possibility for instantiating an actor. This can be done by
    using the `ActorSystem`'s `systemActorOf` method, which creates an actor in the
    `/system` space. It is arguable that this feature shouldn't normally be used,
    and therefore it is not covered here.
  prefs: []
  type: TYPE_NORMAL
- en: Now, since our `Chef` spawned enough `Mixers` to do the job, we need a way to
    get rid of them after our work is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping an actor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An actor can be stopped in one of the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: By designating its next behavior to be `Behaviors.stopped`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By applying the `stop` method of the `ActorContext` to the immediate child.
    The child will finish processing the current message but leave other messages
    that are still in the mailbox unprocessed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the actor system as it stops its ancestor. The actual shutdown happens recursively,
    bottom-up, following the hierarchy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most natural approach in our mixers example would be to pick the first
    option. We implement it in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `Mixer` behavior is very simple, so we don't need to define an ADT for that
    and use the single `Mix` command directly. The `Chef` actor expects `Collect(Dough)` back.
    This obliges us to define it as a type parameter for the sender reference. The
    behavior itself simulates the hardware delay for the mixing to be finished, sends
    the prepared dough to the `Chef`, and returns `Behaviors.stopped` as the next
    behavior. This leads to the graceful termination of the `Mixer` actor.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've sent the dough back to the `Chef`, let's see how it is supposed
    to be handled. The `Chef` needs to collect the results from all of the mixers
    it has created. To do so, we could pass references to the child actors we've created
    in the idle state to the mixing behavior, but let's imagine we lost the references
    we collected for some reason. In this case, `Chef` could look up its children.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering an actor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Actor discovery is an alternative way to obtain an actor reference. The preferred
    way is still to incorporate actor references into the message protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Akka provides the possibility to look up a single child actor by name (only
    exact match) with the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This returns a reference to a child actor if a child with such a name exists
    and is alive. Please note that because of the return type of this method, the
    result needs to be coerced to the proper type by the use of the `narrow` method
    of `ActorRef`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another method that allows us to look up all of the children of an actor that
    are alive is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The type of result is, again, a collection of `ActorRefs` with no particular
    type.
  prefs: []
  type: TYPE_NORMAL
- en: It is arguable that the lookup methods we have described here are of little
    use because of their basically untyped nature. Akka Typed offers a better alternative
    in the form of the `receptionist`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `receptionist` is a (cluster) singleton actor that is available on the
    actor system level and can be obtained from the `ActorContext` using the following
    call chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `receptionist` is just an actor of type `[Receptionist.Command]`, so let's
    investigate the `Receptionist.Command` type to understand what it is capable of.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three concrete implementations of the abstract `Command` class: `Register`, `Find`,
    and `Subscribe.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Register` is used for associating the given `ActorRef` with the provided `ServiceKey`.
    It is possible to register multiple references for the same key. The registration
    is automatically removed from the receptionist if the registered actor is stopped.'
  prefs: []
  type: TYPE_NORMAL
- en: By providing an optional reference, it is possible to provide another actor,
    who should be notified if the service was successfully registered.
  prefs: []
  type: TYPE_NORMAL
- en: '`Find` is a mechanism for asking the receptionist about all currently known
    registered actors for the given `ServiceKey`. The receptionist responds with a
    `Set` of known actor references (which are called **services**) that are registered
    to the given key, and a key itself wrapped in a `Listing`. `Find` can be used
    to implement one-time queries to the receptionist.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Subscribe` is a way to implement push behavior for the receptionist. An actor
    can use subscribe to receive notifications about all added or removed services
    for some predefined key.'
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the `Manager` actor is used to provide a `Boy` with a reference
    to the `seller` actor. The `Boy` is supposed to communicate with the provided
    reference. In the previous chapter, we used untyped Akka's remote lookup to get
    this reference. In the typed environment, we will utilize the receptionist for
    this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: This is how it is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the `seller` behavior needs to register itself with the receptionist
    at the moment it is initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `Shop` defines the `SellerKey` that will be used by the actor to register
    as a service and by the service clients to look up the seller's reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we introduce a new type of behavior constructor—`Behaviors.setup`. `setup`
    is a behavior factory. It takes the behavior constructor as a by-name parameter
    and creates the behavior at the moment the actor is started (as opposed to the
    moment the behavior is constructed). We need to use this factory for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: We need our actor to be instantiated so that we can access its context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want our `Seller` to register itself exactly once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After registering the `Seller` with the receptionist, the real behavior is constructed.
    The behavior itself is just accepting the `SellByList` messages and responding
    with the `Groceries` that are to be provided to the `toWhom` reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the opposite side of the receptionist, the `Manager` actor needs to look
    up the `Seller` and use its reference to guide the `Boy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There is quite a bit going on here. Once again, we're using `setup` to define
    the behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Looking up actors is an asynchronous operation, and in this case, we utilize
    the `ask` pattern to keep the code concise. Ask needs to know how long it is allowed
    to wait for the answer, so, in the second line, we define a `lookupTimeout`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we call the `ask` method that's available in the actor context and provide
    a reference of a `receptionist` as an actor to be asked. The second parameter
    is the receptionist's `Find` command, which is given a seller key. Normally, the
    `Find` command takes a second parameter that defines a receiver for the response,
    but as it is used quite often together with `ask`, there is a special constructor
    that allows for the nice syntax we are using in this snippet.
  prefs: []
  type: TYPE_NORMAL
- en: The case literal, which comes next, defines a transformation that must be applied
    to the response before actually sending it back to the asking actor. It deconstructs
    and converts the receptionist's response so that it is either a `NoSeller` or
    just one `OneSeller`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have to deal with the converted response by defining a behavior which
    is returned as a result of this lengthy factory method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the current manager's behavior, we only expect a small subset of all of the
    possible messages to arrive. We're using `receiveMessagePartial` to avoid compiler
    warnings for unhandled message types.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, if there is no seller, we can use the `log` that's available in
    the actor's `context` to report this condition and return the current behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, if there is a `Seller` available, we instantiate a `Boy` and
    use it to transfer a `shoppingList` to this seller. Note how we used `context.self`
    as a second parameter for the `GoShopping` message. By doing this, we''re making
    it possible to use the provided manager''s reference to persuade the `Seller`
    to send groceries directly to the `Manager`, and then the `Boy` can immediately
    stop itself after sending the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have seen how the `GoShopping` command prohibits us from interchanging
    actor references for the seller and manager, as this could easily happen in the
    case of untyped Akka.
  prefs: []
  type: TYPE_NORMAL
- en: Akka Typed – beyond the basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've defined the behavior of the `Chef` actor to distribute work across mixers
    but left the waiting part uncovered, so let's look at that now.
  prefs: []
  type: TYPE_NORMAL
- en: 'We left the `Chef` definition for the `mixing` behavior as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Actually, the `Chef` needs to know about the mixers that were created by its
    `idle` behavior. Though technically it is possible to do a children lookup, as
    described earlier, doing so will introduce an implicit assumption that, at the
    moment, we'll get the listing stating that all of the mixers are still processing
    jobs. This assumption might be wrong in a highly concurrent environment or in
    the case of failed mixers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we need to refactor the behavior constructor a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a builder that captures all of the parts of the Chef''s state. Let''s
    see how these parts are used in the definition of its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We're already familiar with the constructor. In the behavior itself, we count
    every `Dough` message received from the mixer and recreate the behavior with the
    new state. In this case, if all of the mixers have delivered their parts, we return
    the result to the manager and go to the `idle` state.
  prefs: []
  type: TYPE_NORMAL
- en: Life cycle of an actor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our implementation of the `Mixer` is quite naive and does not take into account
    that hardware occasionally breaks.
  prefs: []
  type: TYPE_NORMAL
- en: Conventionally, in Akka, we distinguish between expected and unexpected failures.
    An expected failure of some operation, for example, a validation error is usually
    represented on the protocol level with the appropriate message types. Exceptional
    conditions of an unexpected nature such as hardware errors, are communicated by
    throwing exceptions. This allows you to separate handler definitions for successful
    and erroneous paths, which leads to the separation of business logic from the
    technical details of the underlying platform. Thus, having a rich set of exceptions
    is a prerequisite for proper error-handling definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take this aspect into account. We''ll represent unreliable hardware
    by defining a set of exceptions, one for every possible failure. We''ll do this
    the same way as we did in [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml),
    *An Introduction to the Actor Model and Akka*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in order to simulate the hardware failure, we''ll add some code with the
    purpose of throwing defined exceptions to the logic of the `Mixer`. To keep the
    example simple, let''s just throw one of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It looks like it is very warm in our bakery. The mixer motors are overheating
    roughly every second time the `Chef` tries to mix the `Groceries`.
  prefs: []
  type: TYPE_NORMAL
- en: Actors can watch themselves by calling the `receiveSignal` method on the actor's
    context and providing a `PartialFunction[(ActorContext[T], Signal), Behavior[T]]`
    as a parameter. The provided partial function will be called, with a life cycle
    message as a parameter, if the actor terminates or restarts.
  prefs: []
  type: TYPE_NORMAL
- en: 'This possibility for self-watching can be useful to change the behavior of
    the actor in appropriate cases. The following code snippet shows how mixers can
    monitor themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In our case, mixers just write into the log what kind of life-changing event
    had happened and keep the same behavior. To take a look at the situations in which
    `PostStop`, `PreRestart`, and `Terminated` events happen, we first need to become
    familiar with the concept of supervision.
  prefs: []
  type: TYPE_NORMAL
- en: Supervision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In essence, supervision in Akka Typed refers to the fact that all exceptions
    thrown from a behavior are caught and acted upon. An action can have one of three
    forms: resume, restart, and stop.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how supervision can be defined and which effect it has.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s run our system as it is and observe its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see how our actors start processing messages up to the point where an
    exception is thrown by the `Mixer`. This exception is handled using the default
    supervision strategy that is stopping the actor. The mixer logs the `PostStop`
    event via the monitoring function we defined earlier and attaches it to the actor''s
    behavior, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what will happen if we override the default supervision strategy.
    To change the behavior, we just wrap it into the supervising behavior by using
    the standard constructor. Let''s restart the mixer instead of stopping it in the
    case of the motor overheating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use this behavior by using the `Chef` actor to create mixers, running
    the app will produce a slightly different output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, the exception has been reported by the supervisor and the mixers have been
    restarted, as we can conclude by observing the `PreRestart` events that have been
    logged by the mixers. There is no `PostStop` event here.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is still one more supervision strategy to look at, so let''s check it
    out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'With this strategy, we''ll still see a log output from the supervisor, but
    actors won''t log any life cycle events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to define different supervision strategies for different types
    of exceptions that are thrown by the same behavior by nesting supervisor constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The definition is obviously a bit verbose.
  prefs: []
  type: TYPE_NORMAL
- en: The supervision strategies are sticky. They are recursively applied to new behaviors
    that are returned by the supervised behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, it might be useful to try and restart an actor a few times, and
    if the situation is not improving, then finally stop it. A special constructor
    is available for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In an unlucky case, the mixer actor would throw an exception from the `Behavior.setup`
    constructor every time it was constructed, and we would see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The supervisor tried to restart the actor four times, but then gave up and stopped
    it. Because of the fact that the failure happened in the setup block, the actor
    was able to receive neither the `Mix` command nor life cycle event notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Watching an actor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we look back to the `Chef` actor's implementation, we'll be able to see that
    our system is now stuck. This happened because, if mixers fail, they are stopped
    by an external supervising force. However, the `Chef` actor is still waiting for
    this mixer's part to work. It turns out that we need a way to inform the `Chef`
    about terminated mixers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Akka Typed offers a watching mechanism for this. To watch for mixers that were
    stopped, we''ll add the following code to the `Chef`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, for each spawned `Mixer`, we''re calling `context.watchWith`. The first
    parameter is an actor to watch and the second parameter is a message adapter.
    The need for the message adapter comes from the fact that the *proper* message
    type for the terminated actor would be `akka.actor.typed.Terminated`. We could
    use a watch, taking just a single actor reference, to subscribe to this message
    type—`def watch[T](other: ActorRef[T]): Unit`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But, the fact is that our `Chef` can''t handle this message type because it
    does not belong to its `Command` type. Therefore, we would need to define a separate
    actor type to watch for mixer terminations. Instead, we need to use the *extended*
    version of the watch method, which takes a message to be sent as a second parameter.
    The `BrokenMixer` message is defined and handled as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this case, if we detect a terminated child actor, the `Chef` writes a log
    entry and sends itself a message to compensate for the lost part of the work.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have the `Dough` ready and need a `Cook` to form cookies and a `Baker`
    to bake them in the `Oven`. The implementation of the `Cook` is trivial—it just
    converts `Dough` into a number of `RawCookies` and sends them back to the manager.
    Please refer to the code in the GitHub repository if you're interested in the
    implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: Timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Baker` is more interesting. First of all, it needs a single `Oven`. We''ll
    implement this by using a special behavior that we''ll execute only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define the `idle` behavior that''s just waiting for work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, we expect a message from the manager telling us to bake cookies. Then,
    we use a new behavior constructor, `withTimers`, which gives us access to the `TimerScheduler`.
    With the scheduler, it is possible to define periodic and single timers that have
    been identified by some key. The definition of a new timer with the same key cancels
    the previously defined timer and also removes messages that have been sent by
    it, if they are still in the message box of the actor.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we're using the timer as a kitchen clock to set up a single reminder to
    check the `Oven` after baking time passes.
  prefs: []
  type: TYPE_NORMAL
- en: Stashing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another challenge is that the `Baker` needs to accept `RawCookies` from the
    `Manager` as required, but needs to bake them in batches because of the oven's
    limited capacity. Basically, it needs to manage a queue of the `RawCookies`.
  prefs: []
  type: TYPE_NORMAL
- en: We'll implement this by using a stash. By using stashing, our actor will buffer
    messages that cannot be handled by the current behavior and replay them before
    switching to the alternative behavior in which buffered messages are supposed
    to be handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this approach is reflected in the baking behavior of the actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: First, we define a buffer that will contain our stashed messages.
  prefs: []
  type: TYPE_NORMAL
- en: The stash is keeping messages in memory. By stashing too many messages, it is
    possible to crash the system with an `OutOfMemory` error. The capacity parameter
    helps to avoid this situation. But, in the case that the specified capacity is
    too low, the `StashOverflowException` will be thrown after an attempt to stash
    a message into the full buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we handle four types of messages. `CheckOven` is a reminder that is sent
    to the `Baker` by the timer so that it does not forget to extract cookies from
    the `Oven`.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `TooManyCookies` (which is a message from the `Oven` returning
    cookies that did not fit into it) or `BakeCookies` being received from the manager,
    the `Baker` stashes them until it becomes idle again and is able to process baking
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '`CookiesReady` indicates that the `Oven` is now empty, so we forward the cookies
    to the `Manager`, unstash all of the messages, and go to the `idle` state.'
  prefs: []
  type: TYPE_NORMAL
- en: Combining behaviors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have defined every worker in the bakery, it is time to finally get us
    a `Manager`. In [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml), *An
    Introduction to the Akka and Actor Models*, we implemented a `Manager` using the
    FSM library. In Akka Typed, we can achieve the same effect without any libraries
    just by defining atomic behaviors for each state and then returning the appropriate
    behavior as required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined two behaviors, and each of them expects a specific message
    type, performs the required message passing to the managed actors, and returns
    the next behavior in the chain. This way, it is possible to model the serial behavior
    we implemented with untyped Akka.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can do better. Akka Typed allows us to combine behaviors so that
    we can implement a parallel version of the `Manager` by chaining behaviors together
    and returning the combined behavior from every atomic behavior we define:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `manage` constructor is used to define atomic behaviors for each message
    type the `Manager` is supposed to be able to handle. Then, the existing behaviors
    are combined into one. This makes our `Manager` capable of processing every message
    in any processing state.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Bakery` is now in place, but we would still like the grocery store to run
    as a separate actor system, just like we had it in the previous chapter. With
    untyped Akka, we implemented this communication with the help of remoting, but
    remoting is not available in the typed setup. With Akka Typed, we can achieve
    this with the help of clustering.
  prefs: []
  type: TYPE_NORMAL
- en: Akka clustering is a group of Akka systems working as a dynamic whole. This
    is the main difference from Akka remote, on top of which clustering is built.
    A single system represents one node from the cluster. An actor can exist anywhere
    in the cluster. Some of the features of clustering include load balancing (routing
    messages to specific nodes in the cluster), node partitioning (assigning specific
    roles to nodes), and cluster management (fault-tolerant node membership), to name
    a few. In our example, we don't use any advanced clustering features, and instead
    just throw it in an order so that we have the possibility to communicate with
    a remote actor system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to use clustering in our project, we need to add the following dependency
    to `build.sbt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Clustering also requires that a few configuration parameters are defined. We
    can provide them by putting the following additional lines into `application.conf`. This
    will be the default configuration used by the `Bakery`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration for the `Store` is defined by importing the default configuration
    and overriding the port definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to instantiate an actor system for `Store`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And we need another one for the `Bakery` itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Both of these defined actor systems can now be started and will simulate baking
    cookies by acquiring the required resources from the remote system via clustering.
  prefs: []
  type: TYPE_NORMAL
- en: We just demonstrated Akka's location transparency by turning a local actor system
    into clustered one just by changing the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, we have a working `Bakery` implementation, but we cannot be sure
    that our actors are doing what we expect them to do. Let's fix this by testing
    their behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Testing actors is notoriously difficult because of their concurrent nature and
    message orientation. Luckily, in Akka Typed, an actor's behavior is just a function
    and thus can generally be tested in isolation. There are cases where we might
    want to test the interaction between actors, and in this case, it is inevitable
    to resort to asynchronous testing.
  prefs: []
  type: TYPE_NORMAL
- en: In synchronous setup, we create a behavior under test, send events that it should
    be able to react on, and verify that the behavior produces the expected effects
    (for example, spawning or stopping child actors) and sends further required messages.
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous scenario brings this approach into the context of a test actor
    system, which is close to a real one. We will see how this is done in practice
    in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies and setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To automate repetitive tasks such as setting up testing environments for actors,
    Akka Typed provides a test kit in the same way Akka untyped does. We need the
    following dependencies to be present in `build.sbt` so that we can use it within
    our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Having both of them in scope will allow us to create `ScalaTest` specifications
    and use the Akka Typed test kit functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, in regards to synchronous actor testing, we do not
    need to have an `ActorSystem`. The only dependency, in this case, is an actor
    context. Akka provides a factory for building special testing actor contexts in
    the form of the `BehaviorTestKit`. A skeleton of the `ScalaTest` specification,
    in this case, could look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of asynchronous testing, we have to extend the `ActorTestKit` to
    have a test actor system in the scope of the specification. This actor system
    needs to be shut down after all tests are finished running in order to prevent
    resource leakage. Because of this, the minimal specification in the case of asynchronous
    testing will look a bit more involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now, it is time to look at the different features Akka `TestKit` has to offer
    to simplify checking the correctness of the actor-based system.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `BehaviorTestKit` provides the possibility to verify the reaction of an
    actor behavior to specific messages. The reaction can be in the form of an `Effect`
    (different ways of spawning and stopping children actors), sending and receiving
    messages, and changes in behavior. Let''s illustrate this testing process with
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have wrapped a `goShopping` behavior into the `BehaviorTestKit` so
    that we can test it synchronously. The two `TestInbox` references represent actors
    that the `Boy` is supposed to communicate with. They are basically `ActorRefs`,
    but they allow us to express expectations regarding incoming messages. To trigger
    the test, we can create a message and run the `testKit` using this message as
    an input.
  prefs: []
  type: TYPE_NORMAL
- en: In the next line, we expect the `seller` actor to receive the same message,
    with the `manager` reference being propagated as a sender. This is how our boy's
    logic is supposed to work. Then, we verify that the `Boy` stopped itself by checking
    that it is not alive. Finally, we don't expect any effects on children as the
    `Boy` actor is not supposed to have or create any children.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way that we tested that the `Boy` has no effects on children, we
    can test that the `Chef` has such effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we create a behavior under test in the same way we just did with
    the `Boy` actor. We create a message and run it with the testing behavior wrapper.
    As a result, we expect a `chef` to have the effect of spawning a single `Mixer`
    actor with an appropriate name and dispatcher. Finally, we're looking up the mailbox
    of the spawned child actor by using the `childInbox` method and expect it to have
    a message that's been sent by the `chef` to be present in it.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, at the time of writing this book, the Akka `TestKist` still has
    some rough edges that require us, in this specific case, to refactor our `Chef`
    behavior to accept the mixer factory as a parameter. The reason for this is that
    behaviors are compared by reference, which requires us to have the same instance
    of the behavior for the test to pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another limitation of the `BehaviorTestKit` is its lack of support for extensions
    like cluster, cluster singleton, distributed data, and receptionist. This makes
    it impossible to test the `Seller` actor in a synchronous setup because this actor
    registers itself with the `receptionist`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We could use the synchronous approach or we could refactor the seller to take
    a constructor function for the receptionist and provide a mock receptionist in
    the test. This is an example of how this can be done in the code of the `Seller`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The factory is just a function from `ActorContext` to the `ActorRef` with the
    appropriate types.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this change, we can implement our test, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We provide a mock receptionist which is just a `TestInbox[Receptionist.Command]`
    and use it as the result of the factory, ignoring the actual actor context. Then,
    we execute the test as we did previously and expect the messages to be sent to
    the `manager` and `receptionist` appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Synchronous testing is a good and deterministic way to test actor logic, but
    sometimes it is just not enough, for example, when testing specific aspects of
    communication between actors. Another example is having asynchronous code in the
    actor's behavior, for example, `Feature` or scheduler, which needs to be finished
    before test assertions can be executed.
  prefs: []
  type: TYPE_NORMAL
- en: One example of such a situation is the `Baker` actor. We expect it to check
    the `Oven` after some predefined time interval. Unfortunately, this interval is
    hardcoded, so there is no possibility of being able to override it in the test
    and we need to wait for the timer to trigger.
  prefs: []
  type: TYPE_NORMAL
- en: As part of the asynchronous testing toolkit, Akka provides a `ManualTimer`,
    which can be used to advance time in tests in a flexible manner. We'll use it
    to reliably test our `Baker` actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to provide an appropriate configuration for the manual timer.
    We do this by overriding the `config` method of the actor system which is represented
    by the `ActorTestKit` and define an instance of the time we''ll use in our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can specify the testing logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In this scenario,  we create an `oven` and a `manager` using `TestProbe` (as
    opposed to the `TestInbox` we used before) and also a `baker` behavior using the
    `spawn` method of the `ActorTestKit`. We send a request to the `baker` and expect
    it to react appropriately by putting a single cookie into the oven.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can see that the `baker` waits for the cookies to be ready by checking
    that no messages are sent during this period of time. We're using the annual time
    here, and because of this, the check itself is done instantly. Finally, we manually
    advance the timer so that the `baker` needs to extract the cookies from the oven
    and verify that this has indeed happened, and that the `oven` received the `Extract`
    message as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The application has been successfully tested; let's wait no more and run it!
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please refer to [Appendix A](bc164888-625c-460a-9b0b-e6c45c9eb074.xhtml), *Preparing
    the Environment and Running Code Samples*, if you don't have Java and SBT installed
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will run our application in the Terminal in the same way as we did in the
    previous chapter by using two separate terminal sessions for `Store` and `Bakery`.
    It is possible to run both in interactive mode, or by issuing one of the two following
    commands in the corresponding shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we''re using clustering instead of remoting for our example, we don''t
    need to start them in a particular order as we had to in the previous chapter.
    The following screenshot shows two Terminal windows ready to run the application
    with the aforementioned commands typed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e6f8daa-7acc-4b5f-b97b-5634362a35d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As both parts of the application start, they will establish a connection and
    start to work together to produce cookies. The following screenshot shows us that
    the bakery part of the application is already running and waiting for the store
    to start on the right-hand side of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/983c3c61-8573-4c06-849d-dac0e4829373.png)'
  prefs: []
  type: TYPE_IMG
- en: If you'd like to start the demo in interactive mode from the SBT shell, please
    refer to [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml), *An Introduction
    to the Akka and Actor Models*, where we explained how to do this in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Akka Typed allows you to implement an actor system in a type-safe way. It represents
    actor logic as a well-typed behavior with the types of both input and output channels
    determined at compile time. Behaviors can be combined together, allowing for a
    higher degree of code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Typed actors are not only supposed to receive and send messages but are also
    required to explicitly define a new behavior after processing every message. Interactions
    with other actors are limited to creating, stopping, looking up, and watching
    children, and getting typed references to explicitly registered services.
  prefs: []
  type: TYPE_NORMAL
- en: Actor context provides useful functionality, such as timers and stashing.
  prefs: []
  type: TYPE_NORMAL
- en: Typed supervision is defined directly on behavior, and the failure propagation
    to the parent actor must be implemented explicitly if needed. The Akka team took
    a holistic approach by promoting an actor's life cycle hooks, from methods to
    events.
  prefs: []
  type: TYPE_NORMAL
- en: Actors in typed Akka are basically just functions. Because of this, testing
    is not limited to asynchronous communication as it was before. This can be done
    synchronously, thus allowing for deterministic and stable test code that executes
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Akka Typed offers a set of useful extensions like cluster, cluster singleton,
    persistence, and distributed data. We touched briefly upon how the cluster module
    allows us to utilize the existing code in a distributed scenario by solely changing
    the configuration of the system. Please refer to the Akka Typed official documentation
    online ([https://doc.akka.io/docs/akka/current/typed/index.html](https://doc.akka.io/docs/akka/current/typed/index.html)) 
    to explore further capabilities provided by the typed actor's toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to implement the bakery once again, this time
    using yet another Akka library—Akka Streams.
  prefs: []
  type: TYPE_NORMAL
