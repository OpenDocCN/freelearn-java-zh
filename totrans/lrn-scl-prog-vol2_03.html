<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Giving Meaning to Programs with Functions</h1>
                
            
            <article>
                
<div class="packt_quote">"Object-oriented programming makes code understandable by encapsulating moving parts; functional programming makes code understandable by minimizing moving parts."</div>
<div class="packt_quote1">- Michael Feathers</div>
<p class="calibre2">Scala, as a mixed paradigm language, motivates you to reuse the code that you write and, at the same time, expects you to follow the motive behind functional programming. That motive is that your program should be decomposed into smaller abstractions to complete a well-defined task. This can be achieved using functions. A function is nothing but a logical construct that performs a certain task and can be reused as needed.</p>
<p class="calibre2">There are certain ways these functions can be introduced and applied into our programs. There are many reasons why functions can be used in our programs. Functions, well-written with the exact number of needed arguments, with well-defined scope and privacy make your code look good. Moreover, these functions give meaning to your program. There are specific evaluation strategies based on our needs that can be incorporated using some syntactical changes. For example, evaluation of a function if, and only if, it is needed, or lazy evaluation, means expressions are going to be evaluated when they are first accessed. Let's get ready to be introduced to functions in Scala. In this chapter, we'll become familiar with:</p>
<ul class="calibre7">
<li class="calibre8">Function syntax</li>
<li class="calibre8">Calling a function</li>
<li class="calibre8">Function literals/anonymous functions</li>
<li class="calibre8">Evaluation strategies</li>
<li class="calibre8">Partial functions</li>
</ul>
<p class="calibre2">So let's start our discussion with what it takes to write a function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Function syntax</h1>
                
            
            <article>
                
<p class="calibre2">Functions in Scala can be written using the <kbd class="calibre11">def</kbd> keyword, followed by the name of the function, with some arguments supplied as inputs to the function. Let's take a look at the generic syntax for a function:</p>
<pre class="calibre19">modifiers... <br class="title-page-name"/>def function_name(arg1: arg1_type, arg2: arg2_type,...): return_type = ???</pre>
<p class="calibre2">The preceding syntax shows the generic function signature in Scala. First, we give modifiers for the function. Modifiers can be understood as properties defined for the function. Modifiers come in different forms. A few of them are as follows:</p>
<ul class="calibre7">
<li class="calibre8">Annotations</li>
<li class="calibre8">Override modifier</li>
<li class="calibre8">Access modifiers (<kbd class="calibre11">private</kbd>, and so on)</li>
<li class="calibre8">The <kbd class="calibre11">final</kbd> keyword</li>
</ul>
<p class="calibre2">It's recommended practice to use the preceding modifiers on an as-needed basis and in the given order. After specifying modifiers, we use the <kbd class="calibre11">def</kbd> keyword to denote a function followed by the name of the function. After giving the function name, we specify the parameters. The parameters are specified in parenthesis: first, the name of the parameter and then its type. This is a bit different from Java. In Java, this order is the exact opposite. Finally, we specify the return type of our function. We can also omit the return type, as Scala can infer it. Apart from some exceptional cases, it'll work fine. For good readability of our programs, we can make it a practice to have the return type be a part of your function signature. After declaring the function, we can give the definition body. Let's take a look at some concrete examples:</p>
<pre class="calibre19">def compareIntegers(value1: Int, value2: Int): Int = if (value1 == value2) 0 else if (value1 &gt; value2) 1 else -1</pre>
<p class="calibre2">The preceding example simply defines a function that expects two integer values, compares them, and returns an integer response. The definition is also simple where we are checking equality for inputs provided. If the values are equal, then <kbd class="calibre11">0</kbd> is returned; if the first value is greater than the second one we return <kbd class="calibre11">1</kbd>, otherwise we return <kbd class="calibre11">-1</kbd>. Here, we've not used any modifiers for our function. By default, Scala treats its functions as <kbd class="calibre11">public</kbd>, which means you can access them from any other class and override them.</p>
<p class="calibre2">If you take a closer look at the function body, it's inline. We defined the function directly, and there are two reasons for this:</p>
<ul class="calibre7">
<li class="calibre8">To make our code simple and readable</li>
<li class="calibre8">The definition was small enough to define on one line</li>
</ul>
<p class="calibre2">A recommended practice to define your function definition inline is when your function signature, along with the definition, is 30 characters or so. If it's more but still concise, we can start the definition on the next line, as follows:</p>
<pre class="calibre19">def compareIntegersV1(value1: Int, value2: Int): Int = 
  if (value1 == value2) 0 else if (value1 &gt; value2) 1 else -1 </pre>
<p class="calibre2">So the choice is yours; to make your code more readable, you may choose to define functions inline. If there are multiple lines in a function body, you may choose to encapsulate them within a pair of curly braces:</p>
<pre class="calibre19">def compareIntegersV2(value1: Int, value2: Int): Int = { 
  println(s" Executing V2") 
  if (value1 == value2) 0 else if (value1 &gt; value2) 1 else -1 
} </pre>
<p class="calibre2">Here, we have two statements in the function definition. The first is printing and the latter is evaluating the comparison. Hence, we encapsulated them using a pair of curly braces. Let's take a look at the whole program:</p>
<pre class="calibre19">object FunctionSyntax extends App{ 
 /* 
  * Function compare two Integer numbers 
  * @param value1 Int 
  * @param value2 Int 
  * return Int 
  * 1  if value1 &gt; value2 
  * 0  if value1 = value2 
  * -1 if value1 &lt; value2 
  */ 
  def compareIntegers(value1: Int, value2: Int): Int = if (value1 == value2) 0 else if (value1 &gt; value2) 1 else -1 
 
  def compareIntegersV1(value1: Int, value2: Int): Int = {
    if (value1 == value2) 0 else if (value1 &gt; value2) 1 else -1 
   }<br class="title-page-name"/><br class="title-page-name"/>  def compareIntegersV2(value1: Int, value2: Int): Int =
    if (value1 == value2) 0 else if (value1 &gt; value2) 1 else -1 
 
  println(compareIntegers(1, 2)) 
  println(compareIntegersV1(2, 1)) 
  println(compareIntegersV2(2, 2)) 
 
} </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">-1
1 
0 </pre>
<p class="calibre2">When we define a function's body, the very last expression works as the return type for the function. In our case, the evaluation of <kbd class="calibre11">if else</kbd> expression, that is, an integer, will be the return type for the <kbd class="calibre11">compareIntegers</kbd> function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Nesting of functions</h1>
                
            
            <article>
                
<p class="calibre2">Wherever we have the possibility of wrapping our logic, we transform the snippet into a function. If we do so a number of times, we may pollute our code. Also, when we decompose our functions into smaller helper units, we tend to give almost similar names. Let's take an example:</p>
<pre class="calibre19">object FunctionSyntaxOne extends App { 
 
  def compareIntegersV4(value1: Int, value2: Int): String = { 
 println("Executing V4") 
    val result = if (value1 == value2) 0 else if (value1 &gt; value2) 1 else -1 
    giveAMeaningFullResult(result, value1, value2) 
  } 
 
  private def giveAMeaningFullResult(result: Int, value1: Int, value2: Int) = result match { 
    case 0 =&gt; "Values are equal" 
    case -1 =&gt; s"$value1 is smaller than $value2" 
    case 1 =&gt; s"$value1 is greater than $value2" 
    case _ =&gt; "Could not perform the operation" 
  } 
 
  println(compareIntegersV4(2,1)) 
} </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">Executing V4 
2 is greater than 1 </pre>
<p class="calibre2">In the preceding program, we defined the <kbd class="calibre11">compareIntegersV4</kbd> function, in which, after the evaluation of a comparison between two integers, we called a helper function named <kbd class="calibre11">giveAMeaningFullResult</kbd><em class="calibre18">, </em>passing a result and two values. This function responds back with a meaningful string based on the result. The code works fine, but if you take a closer look and think about it, you may find that this private method is only meaningful to <kbd class="calibre11">compareIntegersV4</kbd><em class="calibre18">,</em> hence it's better if the definition of <kbd class="calibre11">giveAMeaningFullResult</kbd> can be defined inside the function itself. Let's refactor our code to define the helper function in a nested manner inside <kbd class="calibre11">compareIntegersV5</kbd><em class="calibre18">:</em></p>
<pre class="calibre19">object FunctionSyntaxTwo extends App { 
 
  def compareIntegersV5(value1: Int, value2: Int): String = { 
 println("Executing V5") 
 
    def giveAMeaningFullResult(result: Int) = result match { 
      case 0 =&gt; "Values are equal" 
      case -1 =&gt; s"$value1 is smaller than $value2" 
      case 1 =&gt; s"$value1 is greater than $value2" 
      case _ =&gt; "Could not perform the operation" 
    } 
 
    val result = if (value1 == value2) 0 else if (value1 &gt; value2) 1 else -1 
    giveAMeaningFullResult(result) 
  } 
 
  println(compareIntegersV5(2,1)) 
} </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">Executing V5 
2 is greater than 1 </pre>
<p class="calibre2">As you can see in the preceding code, we defined the nested function as <kbd class="calibre11">giveAMeaningFullResult</kbd><em class="calibre18">,</em> which has also been changed a bit. Now it's expecting only one parameter of integer type that responds back with a meaningful string. We're allowed to access all the variables of the enclosing function; that's why we omitted passing <kbd class="calibre11">value1</kbd> and <kbd class="calibre11">value2</kbd> to our nested helper function<em class="calibre18">.</em> This has made our code look cleaner. We were able to make a call to our function directly passing arguments, in our case <kbd class="calibre11">2</kbd> and <kbd class="calibre11">1</kbd>. There are a variety of ways we can make a function call; why don't we go ahead and take a look at them?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Calling a function</h1>
                
            
            <article>
                
<p class="calibre2">We can call a function to perform the task we defined for it. While calling, we pass the arguments that the function takes as input parameters. This can be achieved in a variety of ways: we can specify a variable number of arguments, we can specify the name of the argument, or we can specify a default value to consider in case the argument is not passed while calling the function. Let's take a scenario where we are not sure about the number of arguments to be passed to a function for evaluation but we are sure about the type of it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Passing a variable number of arguments</h1>
                
            
            <article>
                
<p class="calibre2">If you remember, we've already seen an example for functions that take a variable number of arguments and perform operations on them in the previous chapter:</p>
<pre class="calibre19"> /* 
  * Prints pages with given Indexes for doc 
  */ 
  def printPages(doc: Document, indexes: Int*) = for(index &lt;- indexes if index &lt;= doc.numOfPages) print(index) </pre>
<p class="calibre2">Our method takes index numbers and prints those pages from the document passed as the first parameter. Here, the parameter <kbd class="calibre11">indexes</kbd> is called a <strong class="calibre1">vararg</strong><em class="calibre18">.</em> This indicates that we can pass any number of arguments of the type specified; in this case, we specified <kbd class="calibre11">Int</kbd><em class="calibre18">.</em> While calling this function, we can pass any number of arguments of type <kbd class="calibre11">Int</kbd><em class="calibre18">.</em> We've already tried that. Now, let's think of a mathematical function that expects a number of integers and responds back with the average of all the numbers. How should it look?</p>
<p class="calibre2">It may be a signature with the <kbd class="calibre11">def</kbd> keyword, with a name and parameters, or just one <em class="calibre18">vararg</em>:</p>
<pre class="calibre19">def average(numbers: Int*): Double = ??? </pre>
<p class="calibre2">The preceding code is the signature for our <kbd class="calibre11">average</kbd> function. The body for the function is yet to be defined:</p>
<pre class="calibre19">object FunctionCalls extends App { 
 
  def average(numbers: Int*) : Double = numbers.foldLeft(0)((a, c) =&gt; a + c) / numbers.length 
 
 
  def averageV1(numbers: Int*) : Double = numbers.sum / numbers.length 
 
  println(average(2,2)) 
  println(average(1,2,3)) 
  println(averageV1(1,2,3)) 
 
} </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">2.0 
2.0 
2.0 </pre>
<p class="calibre2">Let's look at the first <kbd class="calibre11">average</kbd> function; it expects a variable argument of type <kbd class="calibre11">Int</kbd><em class="calibre18">.</em> It has been called with arguments <kbd class="calibre11">2</kbd> and <kbd class="calibre11">2</kbd>. Here the number of arguments was 2. We're allowed to provide any number of arguments to perform the operation. The definition of our function uses the <kbd class="calibre11">fold</kbd> operation to perform summing of all the numbers passed. We'll see the details of how <kbd class="calibre11">fold</kbd> works in the next chapter, when we discuss the functions for our collections. For now, just understand that it traverses through each element of a collection and performs operations with a supplied argument, that is, <kbd class="calibre11">0</kbd> in our case. We called the function with a different number of arguments. In the same way, we can define our function to support a variable number of arguments of any type. We can call the function accordingly. The only requirement is that the <em class="calibre18">vararg</em> parameter should come last in the function signature's parameters list:</p>
<pre class="calibre19">def averageV1(numbers: Int*, wrongArgument: Int): Double = numbers.sum / numbers.length </pre>
<p class="calibre2">This means that <kbd class="calibre11">numbers</kbd><em class="calibre18">,</em> that is, a variable parameter, should be declared last and declaring <kbd class="calibre11">wrongArgument</kbd> after that will give a <em class="calibre18">compile time error.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Calling a function with a default parameter value</h1>
                
            
            <article>
                
<p class="calibre2">We're allowed to give default parameter values at the time of declaring a function. If we do so, we can avoid passing an argument for that parameter while calling the function. Let's see how this works with an example. We've already seen this example, where we're going to compare two integers. Let's give the second parameter a default value of <kbd class="calibre11">10</kbd>:</p>
<pre class="calibre19">def compareIntegersV6(value1: Int, value2: Int = 10): String = { 
 println("Executing V6") 
 
  def giveAMeaningFullResult(result: Int) = result match { 
    case 0 =&gt; "Values are equal" 
    case -1 =&gt; s"$value1 is smaller than $value2" 
    case 1 =&gt; s"$value1 is greater than $value2" 
    case _ =&gt; "Could not perform the operation" 
  } 
 
  val result = if (value1 == value2) 0 else if (value1 &gt; value2) 1 else -1 
  giveAMeaningFullResult(result) 
} 
 
println(compareIntegersV6(12)) </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">Executing V6 
12 is greater than 10 </pre>
<p class="calibre2">Here, while declaring the <kbd class="calibre11">compareIntegersV6</kbd> function, we gave a default value of <kbd class="calibre11">10</kbd> to parameter <kbd class="calibre11">value2</kbd><em class="calibre18">.</em> At the end while calling the function, we passed only one argument:</p>
<pre class="calibre19">compareIntegersV6(12) </pre>
<p class="calibre2">While calling the function, we passed only one argument, <kbd class="calibre11">12</kbd>, which is the value for <kbd class="calibre11">value1</kbd><em class="calibre18">.</em> In these situations the Scala compiler looks for a value bound to the other argument. In our case, the compiler was able to infer that for the other parameter there's already a value of 10 by default, so the function application will evaluate based on these two values. Giving default values and using them works only if the Scala compiler can infer the values. In cases of ambiguity, it does not allow you to call a function. Let's take an example:</p>
<pre class="calibre19">def compareIntegersV6(value1: Int = 10, value2: Int) = ??? </pre>
<p class="calibre2">For this function, let's try to call using the following function call:</p>
<pre class="calibre19">println(compareIntegersV6(12)) // Compiler won't allow </pre>
<p class="calibre2">The Scala compiler will throw an error if we try to call a function in this way, because the compiler was not able to bind the value <kbd class="calibre11">12</kbd> to <kbd class="calibre11">value2</kbd><em class="calibre18">,</em> because of the ordering of the argument. If somehow we can tell the compiler that the argument that we passed is bound to the parameter named <kbd class="calibre11">value2</kbd>, our function will work. To achieve this, we call the function passing the argument by name.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Calling a function while passing named arguments</h1>
                
            
            <article>
                
<p class="calibre2">Yes, while calling a function, we can directly name the arguments. This ensures freedom from the correct ordering of arguments passed. Let's call our function:</p>
<pre class="calibre19">def compareIntegersV6(value1: Int = 10, value2: Int): String = { 
 println("Executing V6") 
 
  def giveAMeaningFullResult(result: Int) = result match { 
    case 0 =&gt; "Values are equal" 
    case -1 =&gt; s"$value1 is smaller than $value2" 
    case 1 =&gt; s"$value1 is greater than $value2" 
    case _ =&gt; "Could not perform the operation" 
  } 
 
  val result = if (value1 == value2) 0 else if (value1 &gt; value2) 1 else -1 
  giveAMeaningFullResult(result) 
} 
 
println(compareIntegersV6(value2 = 12)) </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">Executing V6 
10 is smaller than 12 </pre>
<p class="calibre2">The reason behind this is simple: the only thing to ensure is that the Scala compiler is able to infer. This can also allow you to pass arguments regardless of the order in which they appear in the function signature. So it's possible to call our function like this:</p>
<pre class="calibre19">println(compareIntegersV6(value2 = 12, value1 = 10)) </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">Executing V6 
10 is smaller than 12 </pre>
<p class="calibre2">This gives us more than one way to define and call our functions. The good news is that you can also pass functions into a function in the form of literals; we call them function literals. Let's go through what function literals look like.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Function literals</h1>
                
            
            <article>
                
<p class="calibre2">We can pass a function in the form of a literal to another function, to work for us. Let's take the same <kbd class="calibre11">compareIntegers</kbd> function example:</p>
<pre class="calibre19">def compareIntegersV6(value1: Int = 10, value2: Int): Int = ??? </pre>
<p class="calibre2">We know what our function is supposed to do: take two integer numbers as input and return an integer response telling us the result of our comparison. If we take a look at the abstract form of our function, it will look like this:</p>
<pre class="calibre19">(value1: Int, value2: Int) =&gt; Int     </pre>
<p class="calibre2">This means that the function is expecting two integers, and returning an integer response; our need is the same. It's an abstract form that indicates that elements on the left are inputs and elements on the right are the response type for our function. We can say that this is in its literal form, also called <strong class="calibre1">function literals</strong><em class="calibre18">.</em> Hence, it's also possible to assign this literal to any variable:</p>
<pre class="calibre19">val compareFuncLiteral = (value1: Int, value2: Int) =&gt; if (value1 == value2) 0 else if (value1 &gt; value2) 1 else -1 </pre>
<p class="calibre2">Remember in <kbd class="calibre11">PagePrinter</kbd> from the last chapter, we had a <kbd class="calibre11">print</kbd> function that took an index and printed that page:</p>
<pre class="calibre19">private def print(index: Int) = println(s"Printing Page $index.") </pre>
<p class="calibre2">If we look at the form our function takes, it takes an integer and prints pages. So the form will look as follows:</p>
<pre class="calibre19">(index: Int) =&gt; Unit </pre>
<p class="calibre2">The <kbd class="calibre11">Unit</kbd> keyword here represents that our literal does not respond back with any value. Now let's take a scenario where the requirement is to tell the printer to print a page in color or simple. We'll refactor our code to support using function literals:</p>
<pre class="calibre19">object ColorPrinter extends App { 
 
  def printPages(doc: Document, lastIndex: Int, print: (Int) =&gt; Unit) = if(lastIndex &lt;= doc.numOfPages) for(i &lt;- 1 to lastIndex) print(i) 
 
  val colorPrint = (index: Int) =&gt; println(s"Printing Color Page $index.") 
   
  val simplePrint = (index: Int) =&gt; println(s"Printing Simple Page $index.") 
 
  println("---------Method V1-----------") 
  printPages(Document(15, "DOCX"), 5, colorPrint) 
 
   println("---------Method V2-----------") 
   printPages(Document(15, "DOCX"), 2, simplePrint) 
} 
 
case class Document(numOfPages: Int, typeOfDoc: String) </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">---------Method V1----------- 
Printing Color Page 1. 
Printing Color Page 2. 
Printing Color Page 3. 
Printing Color Page 4. 
Printing Color Page 5. 
---------Method V2----------- 
Printing Simple Page 1. 
Printing Simple Page 2. </pre>
<p class="calibre2">We refactored our <kbd class="calibre11">printPages</kbd> <span>method </span>and now it takes a <em class="calibre18">function literal.</em> The function literal represents our <kbd class="calibre11">print</kbd> function's form. We represented two forms of our <kbd class="calibre11">print</kbd> function, the first one prints <em class="calibre18">colored</em> pages and the latter prints <em class="calibre18">simple</em> pages. This made it simple to call the same function of <kbd class="calibre11">printPages</kbd> and pass a <em class="calibre18">function literal</em> as needed. All we had to do was tell the function this form of function can be passed and, while calling the function, we can pass a <em class="calibre18">function literal</em> of the same form.</p>
<p class="calibre2">Scala also uses <em class="calibre18">function literals</em> in default constructs. One example is the <kbd class="calibre11">filter</kbd> function for collections. The <kbd class="calibre11">filter</kbd> <span>function </span>expects a predicate that checks for a condition and responds with a Boolean response, based on which we filter out elements in a list or collection:</p>
<pre class="calibre19">scala&gt; val names = List("Alice","Allen","Bob","Catherine","Alex") 
names: List[String] = List(Alice, Allen, Bob, Catherine, Alex) 
 
scala&gt; val nameStartsWithA = names.filter((name) =&gt; name.startsWith("A")) 
nameStartsWithA: List[String] = List(Alice, Allen, Alex) </pre>
<p class="calibre2">The part where we checked if the name starts with <kbd class="calibre11">A</kbd> is an example of a <em class="calibre18">function </em><em class="calibre18">literal:</em></p>
<pre class="calibre19"> (name) =&gt; name.startsWith("A") </pre>
<p class="calibre2">The Scala compiler only requires extra information where it is needed to infer type information; with this, it allows us to omit the parts that are just extra syntax, hence it's possible to write the proceeding syntax as:</p>
<pre class="calibre19">scala&gt; val nameStartsWithA = names.filter(_.startsWith("A")) 
nameStartsWithA: List[String] = List(Alice, Allen, Alex) </pre>
<p class="calibre2">In the proceeding snippet, we omitted the name of the parameter and used a <kbd class="calibre11">placeholder</kbd> syntax instead. What if we pass a function literal as an argument and want it to be evaluated only when it's needed, for example, a predicate that gets evaluated only if a certain functionality is active? In that case, we can pass the parameter as a named parameter. Scala does provide this functionality in the form of <em class="calibre18">call by name</em> parameters. These parameters get evaluated lazily whenever needed or first called. Let's take a look at some evaluation strategies provided by Scala.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Evaluation strategies</h1>
                
            
            <article>
                
<p class="calibre2">When functions have some parameters defined in them, those function calls expect us to pass arguments while calling. And as we know, we can pass a <em class="calibre18">function literal</em> that gets evaluated at the time of the call or at the time when it is used. Scala supports <em class="calibre18">call by value</em> and <em class="calibre18">call by name</em> for functions. Let's discuss them in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Call by name</h1>
                
            
            <article>
                
<p class="calibre2">Call by name is an evaluation strategy where we substitute the literal at the place from where we call our function. The literal gets evaluated when it first appears and gets called. We can understand this with a simple example. First, let's take our <kbd class="calibre11">ColorPrinter</kbd> application and pass a Boolean function literal that checks if the printer is switched on. For that we can refactor our function:</p>
<pre class="calibre19">def printPages(doc: Document, lastIndex: Int, print: (Int) =&gt; Unit, isPrinterOn: () =&gt; Boolean) = { 
 
  if(lastIndex &lt;= doc.numOfPages &amp;&amp; isPrinterOn()) for(i &lt;- 1 to lastIndex) print(i) 
 
} </pre>
<p class="calibre2">To call this function, we can use:</p>
<pre class="calibre19">printPages(Document(15, "DOCX"), 16, colorPrint, () =&gt; !printerSwitch) </pre>
<p class="calibre2">There are two problems with this kind of approach. First, it looks odd; using a <kbd class="calibre11">() =&gt; expression</kbd> here, when we already know that it's going to be a Boolean function literal. Second, we may not want our expression to get evaluated until it's used. For that, we'll make a small change in our <kbd class="calibre11">printPages</kbd> function signature:</p>
<pre class="calibre19">object ColorPrinter extends App { 
 
  val printerSwitch = false 
 
  def printPages(doc: Document, lastIndex: Int, print: (Int) =&gt; Unit, isPrinterOn: =&gt; Boolean) = { 
 
    if(lastIndex &lt;= doc.numOfPages &amp;&amp; isPrinterOn) for(i &lt;- 1 to lastIndex) print(i) 
 
  } 
 
  val colorPrint = (index: Int) =&gt; { 
    println(s"Printing Color Page $index.") 
  } 
 
  println("---------Method V1-----------") 
  printPages(Document(15, "DOCX"), 2, colorPrint, !printerSwitch) 
 
} 
 
case class Document(numOfPages: Int, typeOfDoc: String) </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">---------Method V1----------- 
Printing Color Page 1. 
Printing Color Page 2. </pre>
<p class="calibre2">Take a closer look and you'll be able to see that we removed the <kbd class="calibre11">()</kbd> parenthesis and added <kbd class="calibre11"><em class="calibre18">=&gt;</em></kbd> in our function signature. This makes our code understand that this is a <em class="calibre18">by name</em> parameter, and to evaluate it only when it's called. This is the reason we are allowed to make this call:</p>
<pre class="calibre19">printPages(Document(15, "DOCX"), 2, colorPrint, !printerSwitch) </pre>
<p class="calibre2">This call consists of a Boolean expression as a last argument. And because our function expects it to be of <em class="calibre18">by name</em> type, it's going to be evaluated later when the call is actually made.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Call by value</h1>
                
            
            <article>
                
<p class="calibre2"><em class="calibre18">Call by value</em> is a simple and common evaluation strategy, where an expression is evaluated and the result is bound to the parameter. At the place where the parameter is used, the bound value is simply substituted with that. We've already seen many examples for this strategy:</p>
<pre class="calibre19">def compareIntegers(value1: Int, value2: Int): Int = 
       if (value1 == value2) 0 else if (value1 &gt; value2) 1 else -1 
 
compareIntegers(10, 8) </pre>
<p class="calibre2">Calls made to this function are examples of the <em class="calibre18">call by value</em> strategy. We simply give values as arguments that get substituted in the function by parameter values.</p>
<p class="calibre2">These strategies give us a variety of ways we can call a function. Also, evaluating an expression only when it's needed is characteristic of functional languages; it's called <em class="calibre18">lazy evaluation.</em> We'll learn about <em class="calibre18">lazy evaluation</em> in more detail in <a href="https://cdp.packtpub.com/learning_scala_programming/wp-admin/post.php?post=157&amp;action=edit" class="calibre10">Chapter 9</a>, <em class="calibre18">Using Powerful Functional Constructs</em>, when we'll discuss <em class="calibre18">powerful functional constructs.</em></p>
<p class="calibre2">Functional programming supports this analogy of writing functions that are valid and work for input values rather than failing them with an error. And to support this, Scala has a feature to define partial functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Partial functions</h1>
                
            
            <article>
                
<p class="calibre2">Partial functions do not suffice for every input given, which means these are defined to serve a purpose for a specific set of input parameters. To understand more, let's first define a partial function:</p>
<pre class="calibre19">scala&gt; val oneToFirst: PartialFunction[Int, String] = { 
     | case 1 =&gt; "First" 
     | } 
oneToFirst: PartialFunction[Int, String] = &lt;function1&gt; 
 
scala&gt; println(oneToFirst(1)) 
First </pre>
<p class="calibre2">In the preceding code, we defined a partial function named <kbd class="calibre11">oneToFirst</kbd><em class="calibre18">.</em> We also specified type parameters for our partial function; in our case we passed <kbd class="calibre11">Int</kbd>, <kbd class="calibre11">String</kbd>. The <kbd class="calibre11">PartialFunction</kbd> function is a trait in Scala, defined as:</p>
<pre class="calibre19">trait PartialFunction[-A, +B] extends (A) =&gt; B </pre>
<p class="calibre2">The trait as shown expects two parameters <kbd class="calibre11">A</kbd> and <kbd class="calibre11">B</kbd>, that become the input and output types of our partial function. Our <kbd class="calibre11">oneToFirst</kbd> <span>partial function </span>simply expects <kbd class="calibre11">1</kbd> and returns a string representation for 1 as first. That's why when we try to call the function by passing 1, it works fine; but if we try to pass any other argument, let's say <kbd class="calibre11">2</kbd>, it'll throw a <kbd class="calibre11">MatchError</kbd>:</p>
<pre class="calibre19">scala&gt; println(oneToFirst(2)) 
scala.MatchError: 2 (of class java.lang.Integer) 
  at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:254) 
  at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:252) 
  at $anonfun$1.applyOrElse(&lt;console&gt;:12) 
  at $anonfun$1.applyOrElse(&lt;console&gt;:11) 
  at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:34) </pre>
<p class="calibre2">This is because our partial function is only applicable for a single value, that is, <kbd class="calibre11">1</kbd>; and for others it's not. To ensure that our function does not throw an error, we can check whether the partial function is applicable for a value or not using the <kbd class="calibre11">isDefinedAt</kbd> method:</p>
<pre class="calibre19">scala&gt; oneToFirst.isDefinedAt(1) 
res3: Boolean = true 
 
scala&gt; oneToFirst.isDefinedAt(2) 
res4: Boolean = false </pre>
<p class="calibre2">For values that our partial function supports, <kbd class="calibre11">isDefinedAt</kbd> gives <kbd class="calibre11">true</kbd>; for other values, it returns <kbd class="calibre11">false</kbd>. These partial functions can also be composed. For that, the trait <kbd class="calibre11">PartialFunction</kbd> defines two methods: <kbd class="calibre11">orElse</kbd> and <kbd class="calibre11">andThen</kbd><em class="calibre18">:</em></p>
<pre class="calibre19">object PartialFunctions extends App { 
 
  val isPrimeEligible: PartialFunction[Item, Boolean] = { 
    case item =&gt; item.isPrimeEligible 
  } 
 
  val amountMoreThan500: PartialFunction[Item, Boolean] = { 
    case item =&gt; item.price &gt; 500.0 
  } 
 
  val freeDeliverable = isPrimeEligible orElse amountMoreThan500 
 
  def deliveryCharge(item: Item): Double = if(freeDeliverable(item)) 0 else 50 
 
  println(deliveryCharge(Item("1", "ABC Keyboard", 490.0, false))) 
 
} 
 
case class Item(id: String, name: String, price: Double, isPrimeEligible: Boolean)</pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">50.0 </pre>
<p class="calibre2">In the preceding program, we defined the partial functions named <kbd class="calibre11">isPrimeEligible</kbd> and <kbd class="calibre11">amountMoreThan500</kbd><em class="calibre18">,</em> and then composed another partial function using the <kbd class="calibre11">orElse</kbd> method , which checks if the item is deliverable for free or not. Thus, partial functions provide us with ways to compose and define functions to serve specific purposes for a set of values. Moreover, partial functions give us a way to define separate logic from a given set of input values based on some distinction. It's important to keep in mind that our partial function works on only one operand. Hence, this is a form of unary function and it's the programmer's responsibility to check whether for a specific value, the function is defined or not.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">It's time to conclude our chapter. In this chapter, we had a brief introduction to the important concept of <em class="calibre18">functions</em> in Scala. We started with the syntax for defining a function. It is important to know that we're allowed to nest functions and make our code look cleaner. We learned about how we can make function calls in a variety of ways, for example with a variable number of arguments, with a default parameter value, and with a named argument. Then we learned how to write function literals in Scala. Afterwards, we discussed a couple of evaluation strategies for functions in Scala, where we talked about <em class="calibre18">call by name</em> and <em class="calibre18">call by value.</em> Finally, we discussed another important concept of defining a <em class="calibre18">partial function</em> in Scala.</p>
<p class="calibre2">With this chapter, we have completed the first part of our journey. Learning all these concepts has certainly increased our ability to write and understand a mature piece of Scala code. In later parts, we will continue to do so. The second part is about Scala's rich collections hierarchy. In the next chapter, we'll learn about the number of collections Scala provides and various methods to use collections in a variety of ways.</p>


            </article>

            
        </section>
    </body></html>