<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Installation and a Sneak Peek into Java 9</h1>
                </header>
            
            <article>
                
<p><span>In this</span> chapter, we will cover the following recipes: </p>
<ul>
<li>Installing JDK 9 on Windows and setting up the PATH variable</li>
<li>Installing JDK 9 on Linux (Ubuntu, x64) and configuring the PATH variable</li>
<li>Compiling and running a Java application</li>
<li>New features in Java 9</li>
<li>Using new tools in JDK 9</li>
<li>Comparing JDK 8 with JDK 9</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Every quest for learning a programming language begins with setting up the environment to experiment our learning. Keeping in sync with this philosophy, in this chapter, we will show you how to set up your development environment and then run a simple modular application to test our installation. After that, we'll give you an introduction to the new features and tools in JDK 9. Then, we'll end the chapter with a comparison between the JDK 8 and JDK 9 installations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing JDK 9 on Windows and setting up the PATH variable</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will look at installing JDK on Windows and how to set up the <kbd>PATH</kbd> variable to be able to access the Java executables (such as <kbd>javac</kbd>, <kbd>java</kbd>, and <kbd>jar</kbd>, among others) from anywhere within the command shell.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>
<div class="CDPAlignCenter CDPAlign">
<p>Visit <a href="http://jdk.java.net/9/">https://jdk9.java.net/download/</a> and accept the early adopter license agreement, which looks like this:</p>
<img height="89" width="393" class="image-border" src="assets/364e286c-924b-4f24-96dd-67fc0f0fa569.png"/></div>
</li>
<li>
<p>After accepting the license, you will get a grid of the available JDK bundles based on the OS and architecture (32/64 bit), as shown here:</p>
<div class="CDPAlignCenter CDPAlign"><img height="175" width="348" class="image-border" src="assets/0f718e54-83fe-4500-8dca-64cbee4714e7.png"/></div>
</li>
</ol>
<p> </p>
<ol start="3">
<li>Click to download the relevant JDK executable (<kbd>.exe</kbd>) for your Windows platform.</li>
<li>Run the JDK executable (<kbd>.exe</kbd>) and follow the onscreen instructions to install JDK on your system.</li>
<li>If you have chosen all the defaults during the installation, you will find JDK installed in <kbd>C:/Program Files/Java</kbd> for 64 bit and <kbd>C:/Program Files (x86)/Java</kbd> for 32 bit.</li>
</ol>
<p>Now that we have finished installing JDK, let's see how we can set the <kbd>PATH</kbd> variable.</p>
<p>The tools provided with JDK, namely <kbd>javac</kbd>, <kbd>java</kbd>, <kbd>jconsole</kbd>, and <kbd>jlink</kbd>, among others, are available in the bin directory of your JDK installation. There are two ways you could run these tools from the command prompt:</p>
<ol>
<li>Navigate to the directory where the tools are installed and then run them, as follows: </li>
</ol>
<pre><strong>      cd "C:\Program Files\Java\jdk-9\bin"
      javac -version</strong></pre>
<ol start="2">
<li>Export the path to the directory so that the tools are available from any directory in the command prompt. To achieve this, we have to add the path to the JDK tools in the <kbd>PATH</kbd> environment variable. The command prompt will search for the relevant tool in all the locations declared in the <kbd>PATH</kbd> environment variable. </li>
</ol>
<p>Let's see how you can add the JDK bin directory to the <kbd>PATH</kbd> variable:</p>
<ol>
<li>Right click on <span class="packt_screen">My Computer</span> and then click on <span class="packt_screen">Properties</span>. You will see your system information. Search for <span class="packt_screen">Advanced system settings</span> and click on it to get a window, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="356" width="314" class="image-border" src="assets/efd8b32d-cb96-4eef-987e-639258678843.png"/> </div>
<ol start="2">
<li>Click on <span class="packt_screen">Environment Variables</span> to view the variables defined in your system. You will see that there are quite a few environment variables already defined, as shown in the following screenshot (the variables will differ across systems; in the following screenshot, there are a few predefined variables and a few variables added by me):
<div class="CDPAlignCenter CDPAlign"><img height="406" width="429" class="image-border" src="assets/3575c25c-371d-486d-848a-fc4349eb22bd.png"/></div>
The variables defined under <span class="packt_screen">System variables</span> are available across all the users of the system, and those defined under <span class="packt_screen">User variables for sanaulla</span> are available only to the user, <kbd>sanaulla</kbd>.</li>
<li>Click on <span class="packt_screen">New</span> under <span class="packt_screen">User variables for &lt;your username&gt;</span> to add a new variable, with the name <kbd>JAVA_HOME</kbd>, and its value as the location of the JDK 9 installation. For example, it would be <span><span><kbd>C:/Program Files/Java/jdk-9</kbd> (for 64 bit) or <kbd>C:/Program Files (x86)/Java/jdk-9</kbd> (for 32 bit):</span></span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="117" width="462" class="image-border" src="assets/173219d2-184e-49f1-8835-41b2cffdebd8.png"/></div>
<ol start="4">
<li>The next step is to update the <kbd>PATH</kbd> environment variable with the location of the bin directory of your JDK installation (defined in the <kbd>JAVA_HOME</kbd> environment variable). If you already see the <kbd>PATH</kbd> variable defined in the list, then you need to select that variable and click on <span class="packt_screen">Edit</span>. If the <kbd>PATH</kbd> variable is not seen, then click on <span class="packt_screen">New</span>.</li>
<li>Any of the actions in the previous step will give you a popup, as shown in the following screenshot (on Windows 10):</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="343" width="395" class="image-border" src="assets/eb4dffc5-ffae-490b-8df7-1867a0afe983.png"/></div>
<p style="padding-left: 60px" class="mce-root CDPAlignLeft CDPAlign">The following image shows the other Windows versions:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="123" width="487" class="image-border" src="assets/61f9e13f-1e2a-40d3-ba3b-6a32ba94a98d.png"/></div>
<ol start="6">
<li>You can either click on <span class="packt_screen">New</span> in the first picture and insert the value, <kbd>%JAVA_HOME%/bin</kbd>, or you can append the value against the <span class="packt_screen">Variable value</span> field by adding <kbd>; %JAVA_HOME%/bin</kbd><span>. The semicolon (<kbd>;</kbd>) in Windows is used to separate multiple values for a given variable name.</span></li>
<li>After setting the values, open the command prompt and then run <kbd>javac -version</kbd>, and you should be able to see <kbd>javac 9-ea</kbd> as the output. If you don't see it, then it means that the bin directory of your JDK installation has not been correctly added to the <kbd>PATH</kbd> variable.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing JDK 9 on Linux (Ubuntu, x64) and configuring the PATH variable</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will look at installing JDK on Linux (Ubuntu, x64) and also how to configure the <kbd>PATH</kbd> variable to make the JDK tools (such as <kbd>javac</kbd>, <kbd>java</kbd>, <kbd>jar</kbd>, and others) available from any location within the terminal.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Follow the Steps 1 and 2 of the <em>Installing JDK 9 on Windows and setting up the PATH variable</em> recipe to reach the downloads page.</li>
<li>Copy the download link (<kbd>tar.gz</kbd>) for the JDK for the Linux x64 platform from the downloads page. </li>
<li>Download the JDK by using <kbd>$&gt; wget &lt;copied link&gt;</kbd>, for example, <kbd>$&gt; wget http://download.java.net/java/jdk9/archive/180/binaries/jdk-9+180_linux-x64_bin.tar.gz</kbd>.</li>
<li>Once the download completes, you should have the relevant JDK available, for example, <kbd>jdk-9+180_linux-x64_bin.tar.gz</kbd>. You can list the contents by using <kbd>$&gt; tar -tf jdk-9+180_linux-x64_bin.tar.gz</kbd>. You can even pipe it to <kbd>more</kbd> to paginate the output: <kbd>$&gt; tar -tf jdk-9+180_linux-x64_bin.tar.gz | more</kbd>.</li>
<li>Extract the contents of the <kbd>tar.gz</kbd> file under <kbd>/usr/lib</kbd> by using <kbd>$&gt; tar -xvzf jdk-9+180_linux-x64_bin.tar.gz -C /usr/lib</kbd>. This will extract the contents into a directory, <kbd>/usr/lib/jdk-9</kbd>. You can then list the contents of JDK 9 by using <kbd>$&gt; ls /usr/lib/jdk-9</kbd>.</li>
</ol>
<p> </p>
<ol start="6">
<li>Update the <kbd>JAVA_HOME</kbd> and <kbd>PATH</kbd> variables by editing the <kbd>.bash_aliases</kbd> file in your Linux home directory: </li>
</ol>
<pre><strong>      $&gt; vim ~/.bash_aliases
      export JAVA_HOME=/usr/lib/jdk-9
      export PATH=$PATH:$JAVA_HOME/bin</strong></pre>
<p style="padding-left: 60px">Source the <kbd>.bashrc</kbd> file to apply the new aliases:</p>
<pre><strong>      $&gt; source ~/.bashrc
      $&gt; echo $JAVA_HOME
      /usr/lib/jdk-9
      $&gt;javac -version
      javac 9
      $&gt; java -version
      java version "9"</strong><br/><strong>      Java(TM) SE Runtime Environment (build 9+180)</strong><br/><strong>      Java HotSpot(TM) 64-Bit Server VM (build 9+180, mixed mode)</strong></pre>
<div class="mce-root packt_infobox">All the examples in this book are run against JDK installed on Linux (Ubuntu, x64), except for places where we have specifically mentioned that these are run on Windows. We have tried <span>to provide run scripts for both platforms.<br/></span>The recipes on JavaFX are completely executed on Windows. </div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compiling and running a Java application</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will write a very simple modular <kbd>Hello world</kbd> program to test our JDK installation. This simple example prints <kbd>Hello world</kbd> in XML; after all it's the world of web services.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You should have JDK installed and the <kbd>PATH</kbd> variable updated to point to the JDK installation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Let's define the model object with the relevant properties and annotations that will be serialized into XML:</li>
</ol>
<pre>        @XmlRootElement
        @XmlAccessorType(XmlAccessType.FIELD) 
        class Messages{     
          @XmlElement 
          public final String message = "Hello World in XML"; 
        }</pre>
<p style="padding-left: 60px">In the preceding code, <kbd>@XmlRootElement</kbd> is used to define the root tag, <kbd>@XmlAccessorType</kbd> is used to define the type of source for the tag name and tag values, and <kbd>@XmlElement</kbd> is used to identify the sources that become the tag name and tag values in the XML.</p>
<ol start="2">
<li>Now, let's serialize an instance of the <kbd>Message</kbd> class into XML using JAXB:</li>
</ol>
<pre>        public class HelloWorldXml{
          public static void main(String[] args) throws JAXBException{
            JAXBContext jaxb = JAXBContext.newInstance(Messages.class);
            Marshaller marshaller = jaxb.createMarshaller();
            marshaller.setProperty(Marshaller.JAXB_FRAGMENT,<br/>                                   Boolean.TRUE);
            StringWriter writer = new StringWriter();
            marshaller.marshal(new Messages(), writer);
            System.out.println(writer.toString());
          } 
        }</pre>
<ol start="3">
<li>We will now create a module named <kbd>com.packt</kbd>. To create a module, we need to create a file named <kbd>module-info.java</kbd>, which contains the module definition. The module definition contains the dependencies of the module and the packages exported by the module to other modules:</li>
</ol>
<pre>        module com.packt{
          //depends on the java.xml.bind module
          requires java.xml.bind;
          //need this for Messages class to be available to java.xml.bind
          exports  com.packt to java.xml.bind;
        }</pre>
<div class="packt_infobox">We will explain modules in detail in <a href="488da544-ff73-4ef7-9d57-00b67479defd.xhtml">Chapter 3</a>, <em>Modular Programming</em>. But this example is just to give you a taste of modular programming and also to test your JDK installation. </div>
<p style="padding-left: 60px">The directory structure with the preceding files is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="120" width="182" class="image-border" src="assets/596281af-90c6-4cee-a81e-bb3a54cba9eb.png"/></div>
<ol start="4">
<li>Let's now compile and run the code. From the directory, <kbd>hellowordxml</kbd>, create a new directory in which to place your compiled class files:</li>
</ol>
<pre>     <strong> mkdir -p mods/com.packt</strong></pre>
<p style="padding-left: 60px">Compile the source, <kbd>HelloWorldXml.java</kbd> and <kbd>module-info.java</kbd>, into the <kbd>mods/com.packt</kbd> directory:</p>
<pre><strong>      javac -d mods/com.packt/ src/com.packt/module-info.java<br/>      src/com.packt/com/packt/HelloWorldXml.java</strong></pre>
<ol start="5">
<li>Run the compiled code by using <kbd>java --module-path mods -m com.packt/com.packt.HelloWorldXml</kbd>. You will see the following output:</li>
</ol>
<pre style="padding-left: 60px">&lt;messages&gt;&lt;message&gt;Hello World in XML&lt;/message&gt;&lt;/messages&gt;</pre>
<p style="padding-left: 60px">Do not worry if you are not able to understand the options passed with the <kbd>java</kbd> or <kbd>javac</kbd> commands. You will learn about them in <a href="488da544-ff73-4ef7-9d57-00b67479defd.xhtml">Chapter 3</a>, <em>Modular Programming</em>. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">New features in Java 9</h1>
                </header>
            
            <article>
                
<p>The release of Java 9 is a milestone in the Java ecosystem. The much awaited modular framework developed under Project Jigsaw will be part of this Java SE release. Another major feature in this is the JShell tool, which is an REPL tool for Java. Apart from this, there are other important API changes and JVM-level changes to improve the performance and debuggability of the JVM. In a blog post (<a href="https://blogs.oracle.com/java/jdk-9-categories">https://blogs.oracle.com/java/jdk-9-categories</a>), Yolande Poirier categorizes JDK 9 features into the following: </p>
<ol>
<li>Behind the scenes</li>
<li>New functionality</li>
<li>Specialized</li>
<li>New standards</li>
<li>Housekeeping</li>
<li>Gone</li>
</ol>
<p>The same blog post has summarized the preceding categorization into the following image:</p>
<div class="CDPAlignCenter CDPAlign"><img height="329" width="581" class="alignnone size-full wp-image-1543 image-border" src="assets/6de210f1-c649-46d9-9eed-ac2394a1dbe2.png"/></div>
<p>In this recipe, we will discuss a few important features of JDK 9 and, wherever possible, also show a small code snippet of that feature in action. Every new feature in JDK is introduced by means of <strong>JDK Enhancement Proposals</strong>, also called <strong>JEPs</strong>. More information about the different JEPs part of JDK 9 and the release schedule of JDK 9 can be found on the official project page:<br/>
<a href="http://openjdk.java.net/projects/jdk9/">http://openjdk.java.net/projects/jdk9/</a>. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We have picked a few features, which we feel are amazing and worth knowing about. In the following few sections, we'll briefly introduce you to those features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JEP 102 -- Process API updates</h1>
                </header>
            
            <article>
                
<p>Java's Process API has been quite primitive, with support only to launch new processes, redirect the processes' output, and error streams. In this release, the updates to the Process API enable the following:</p>
<ul>
<li>Get the PID of the current JVM process and any other processes spawned by the JVM</li>
<li>Enumerate the processes running in the system to get information such as PID, name, and resource usage</li>
<li>Managing process trees</li>
<li>Managing sub processes</li>
</ul>
<p>Let's look at a sample code, which prints the current PID as well as the current process information:</p>
<pre>//NewFeatures.java
public class NewFeatures{
  public static void main(String [] args) {
    ProcessHandle currentProcess = ProcessHandle.current();
    System.out.println("PID: " + currentProcess.getPid());
    ProcessHandle.Info currentProcessInfo = currentProcess.info();
    System.out.println("Info: " + currentProcessInfo);
  }
}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JEP 110 -- HTTP/2 client</h1>
                </header>
            
            <article>
                
<div class="packt_infobox">This feature is being included in the incubator module. This means that the feature is expected to change in the subsequent releases and may even be removed completely. So, we advise you to use this on an experimental basis.</div>
<p>Java's HTTP API has been the most primitive. Developers often resort to using third-party libraries, such as Apache HTTP, RESTlet, Jersey, and so on. In addition to this, Java's HTTP API predates the HTTP/1.1 specification and is synchronous and hard to maintain. These limitations called for the need to add a new API. The new HTTP client API provides the following:</p>
<ul>
<li>A simple and concise API to deal with most HTTP requests</li>
<li>Support for HTTP/2 specification</li>
<li>Better performance</li>
<li>Better security</li>
<li>A few more enhancements</li>
</ul>
<p>Let's see a sample code to make an HTTP GET request using the new APIs. Below is the module definition defined within the file <kbd>module-info.java</kbd>:</p>
<pre>//module-info.java
module newfeatures{
    requires jdk.incubator.httpclient;
}<br/><br/></pre>
<p>The following code uses the HTTP Client API, which is part of <kbd>jdk.incubator.httpclient</kbd> module:</p>
<p> </p>
<div>
<pre class="mce-root">import jdk.incubator.http.*;<br/>import java.net.URI;<br/>public class Http2Feature{<br/>  public static void main(String[] args) throws Exception{ <br/>    HttpClient client = HttpClient.newBuilder().build();<br/>    HttpRequest request = HttpRequest<br/>      .newBuilder(new URI("http://httpbin.org/get"))<br/>      .GET()<br/>      .version(HttpClient.Version.HTTP_1_1)<br/>      .build();<br/>    HttpResponse&lt;String&gt; response = client.send(request, <br/>      HttpResponse.BodyHandler.asString());<br/>    System.out.println("Status code: " + response.statusCode());<br/>    System.out.println("Response Body: " + response.body()); <br/>  }<br/>}</pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JEP 213 -- milling project coin</h1>
                </header>
            
            <article>
                
<p>In Java SE 7, <kbd>_</kbd> were introduced as part of the numbers, whereby a large number could be conveniently written by introducing <kbd>_</kbd> between the digits. This helped in increasing the readability of the number, for example:</p>
<pre>Integer large_Number = 123_123_123; <br/>System.out.println(large_Number); </pre>
<p>In Java <span>SE</span> 8, the use of <kbd>_</kbd> in the variable names, as shown earlier, resulted in a warning, but in Java <span>SE</span> 9, this use results in an error, which means that the variables can no longer have <kbd>_</kbd> in their names.</p>
<p>The other changed part of this JEP is to support private methods in interfaces. Java started with interfaces with absolutely no method implementations. Then, Java SE 8 introduced default methods that allowed interfaces to have methods with implementations, called default methods. So any class implementing this interface could choose not to override the default methods and use the implementation provided in the interface.</p>
<p>Java SE 9 is introducing private methods, wherein the default methods in the interfaces can share code between them by refactoring the common code into private methods. </p>
<p>Another useful feature is the allowing of effectively final variables to be used with try-with-resources. As of Java SE 8, we needed to declare a variable within the try-with-resources block, such as the following: </p>
<pre>try(Connection conn = getConnection()){}catch(Exception ex){}. </pre>
<p>However, with Java SE 9, we can do the following: </p>
<pre>try(conn){}catch(Exception ex){} </pre>
<p><span>Here, <kbd>conn</kbd> is effectively final; that is, it has been declared and defined before, and will never be reassigned during out the course of the program execution.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JEP 222: jshell -- the Java shell (Read-Eval-Print Loop)</h1>
                </header>
            
            <article>
                
<p>You must have seen languages, such as Ruby, Scala, Groovy, Clojure, and others shipping with a tool, which is often called <strong>REPL</strong> (<strong>Read-Eval-Print-Loop</strong>). This REPL tool is extremely useful in trying out the language features. For example, in Scala, we can write a simple <kbd>Hello World</kbd> program as <kbd>scala&gt; println("Hello World");</kbd></p>
<p>Some of the advantages of the JShell REPL are as follows:</p>
<ul>
<li>Help language learners to quickly try out the language features</li>
<li>Help experienced developers to quickly prototype and experiment before adopting it in their main code base</li>
<li>Java developers can now boast of an REPL</li>
</ul>
<p>Let's quickly spawn our command prompts/terminals and run the JShell command, as shown in the following image:</p>
<div class="CDPAlignCenter CDPAlign"><img height="122" width="259" class="image-border" src="assets/93270775-b773-4add-bf2b-fe2ed3d61cef.png"/></div>
<p>There is a lot more we can do, but we will keep that for <a href="cb8070b8-52d8-4181-9644-05557d27b499.xhtml">Chapter 13</a>, <em>The Read-Evaluate-Print Loop (REPL) Using JShell</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JEP 238 -- multi-release JAR files</h1>
                </header>
            
            <article>
                
<p>As of now, JAR files can contain classes that can only run on the Java version they were compiled for. To leverage the new features of the Java platform on newer versions, the library developers have to release a newer version of their library. Soon, there will be multiple versions of the library being maintained by the developers, which can be a nightmare. To overcome this limitation, the new feature of multirelease JAR files allows developers to build JAR files with different versions of class files for different Java versions. The following example makes it more clear. </p>
<p>Here is an illustration of the current JAR files:</p>
<pre>jar root
  - A.class
  - B.class
  - C.class</pre>
<p>Here is how multirelease JAR files look:</p>
<pre>jar root
  - A.class
  - B.class
  - C.class
  - META-INF
    - versions 
      - 9
        - A.class
      - 10
        - B.class</pre>
<p>In the preceding illustration, the JAR files support class files for two Java versions--9 and 10. So, when the earlier JAR is executed on Java 9, the <kbd>A.class</kbd> under the <kbd>versions</kbd> <kbd>- 9</kbd> folder is picked for execution. On a platform that doesn't support multirelease JAR files, the classes under the versions directory are never used. So, if you run the multirelease JAR file on Java 8, it's as good as running a simple JAR file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JEP 266 -- more concurrency updates</h1>
                </header>
            
            <article>
                
<p>In this update, a new class, <kbd>java.util.concurrent.Flow</kbd>, has been introduced, which has nested interfaces supporting the implementation of a publish-subscribe framework. The publish-subscribe framework enables developers to build components that can asynchronously consume a live stream of data by setting up publishers that produce the data and subscribers that consume the data via subscription, which manages them. The four new interfaces are as follows:</p>
<ul>
<li><kbd>java.util.concurrent.Flow.Publisher</kbd></li>
<li><kbd><span>java.util.concurrent.Flow.</span>Subscriber</kbd></li>
<li><kbd><span>java.util.concurrent.Flow.</span>Subscription</kbd></li>
<li><kbd><span>java.util.concurrent.Flow.</span>Processor</kbd> (which acts as both <kbd>Publisher</kbd> and <kbd>Subscriber</kbd>).</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project Jigsaw</h1>
                </header>
            
            <article>
                
<p>The main aim of this project is to introduce the concept of modularity; support for creating modules in Java and then apply the same to the JDK; that is, modularize the JDK. Some of the benefits of modularity are as follows:</p>
<ul>
<li>Stronger encapsulation: The modules can access only those parts of the module that have been made available for use. So, the public classes in a package are not public unless the package is explicitly exported in the module info file. This encapsulation cannot be broken by using reflection (except in cases where the module is an open module or specific packages in the module have been made open).</li>
<li>Clear dependencies: Modules must declare which other modules they would be using via the <kbd>requires</kbd> clause.</li>
<li>Combining modules to create a smaller runtime, which can be easily scaled to smaller computing devices.</li>
<li>Make the applications more reliable by eliminating runtime errors. For example, you must have experienced your application failing during runtime due to missing classes, resulting in <kbd>ClassNotFoundException</kbd>.</li>
</ul>
<p>There are various JEPs, which are part of this project, as follows:</p>
<ul>
<li><strong>JEP 200 - modular JDK</strong>: This applies the Java platform module system to modularize the JDK  into a set of modules that can be combined at compile time, build time, or runtime.</li>
<li><strong>JEP 201 - modular source code</strong>: This modularizes the JDK source code into modules and enhances the build tools to compile the modules.</li>
<li><strong>JEP 220 - modular runtime images</strong>: This restructures the JDK and JRE runtime images to accommodate modules and to improve performance, security, and maintainability.</li>
<li><strong>JEP 260 - encapsulate most internal APIs</strong>: This allows a lot of internal APIs to be accessed directly or via reflection. Accessing internal APIs that are bound to change is quite risky. To prevent its use, they are being encapsulated into modules and only those internal APIs that are widely used are being made available until a proper API is in its place.</li>
<li><strong>JEP 261 - module system</strong>: This implements the module system Java specification by changing the Java programming language, JVM, and other standard APIs (<a href="http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html">http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html</a>). This includes the introduction of a new construct called module, <kbd>{ }</kbd>, with its supported keywords, such as <kbd>requires</kbd>, <kbd>exports</kbd>, <kbd>opens</kbd>, and <kbd>uses</kbd>. </li>
<li><strong>JEP 282: jlink, the Java linker</strong>: This allows packaging modules and their dependencies into smaller run times. </li>
</ul>
<p>More details about Project Jigsaw can be found from the Project Jigsaw homepage (<a href="http://openjdk.java.net/projects/jigsaw/">http://openjdk.java.net/projects/jigsaw/</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>There are quite a few features listed that are significant for developers, and we thought of grouping them together for your benefit:</p>
<ul>
<li>Enhance the Javadoc tool to generate HTML 5 output and the generated Javadoc should support the local search for classes and other elements. </li>
<li>Make G1 as the default garbage collector and remove GC combinations that have been deprecated in Java 8. G1 is the new garbage collector (which has been in existence since Java SE 7), which focuses on reducing the pause times of the garbage collection activity. These pause times are very critical to latency-critical applications and, hence, such applications are going towards adopting the new garbage collector.</li>
<li>Changing the internal representation of <kbd>String</kbd> to make use of a byte array rather than a character array. In a character array, each array element is 2 bytes, and it was observed that a majority of strings use 1 byte. This resulted in wasteful allocation. The new representation would also introduce a flag to indicate the type of encoding used. </li>
<li>The new stackwalking API to support navigating the stack trace, which will help to do much more than just print the stack trace.</li>
<li>Allow the image I/O plugin to support the TIFF image format.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using new tools in JDK 9</h1>
                </header>
            
            <article>
                
<p>There are a few new command-line tools introduced in JDK 9 to support new features. We will give you a quick overview of these tools and the same will be explained with recipes of their own in the later chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You should have JDK 9 installed and the <kbd>PATH</kbd> environment variable updated to add the path to the <kbd>bin</kbd> directory of your JDK installation. Also, you need to have tried out <kbd>HelloWorldXml</kbd> explained in the recipe, <em>Compiling and running a Java application</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We will look at a few interesting new command-line tools introduced.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">jdeprscan</h1>
                </header>
            
            <article>
                
<p>This tool is used for scanning the usage of deprecated APIs in a given JAR file, classpath, or source directory. Suppose we have a simple class that makes use of the deprecated method, <kbd>addItem</kbd>, of the <kbd>java.awt.List</kbd> class, as follows:</p>
<pre>import java.awt.List;
public class Test{
  public static void main(String[] args){
    List list = new List();
    list.addItem("Hello");
  }
}</pre>
<p>Compile the preceding class and then use <kbd>jdeprscan</kbd>, as follows:</p>
<pre><strong>C:Program FilesJavajdk-9bin&gt;jdeprscan.exe -cp . Test</strong></pre>
<p>You will notice that this tool prints out <kbd>class Test uses method java/awt/List addItem (Ljava/lang/String;)V deprecated</kbd>, which is exactly what we expected.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">jdeps</h1>
                </header>
            
            <article>
                
<p>This tool analyses your code base specified by the path to the <kbd>.class</kbd> file, directory, or JAR, lists the package-wise dependency of your application, and also lists the JDK module in which the package exists. This helps in identifying the JDK modules that the application depends on and is the first step in migrating to modular applications.</p>
<p>We can run the tool on our <kbd>HelloWorldXml</kbd> example written earlier and see what <kbd>jdeps</kbd> provides:</p>
<pre>$&gt; jdeps mods/com.packt/
com.packt -&gt; java.base
com.packt -&gt; java.xml.bind
com.packt -&gt; java.io                          java.base
com.packt -&gt; java.lang                        java.base
com.packt -&gt; javax.xml.bind                   java.xml.bind
com.packt -&gt; javax.xml.bind.annotation        java.xml.bind</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">jlink</h1>
                </header>
            
            <article>
                
<p>This tool is used to select modules and create a smaller runtime image with the selected modules. For example, we can create a runtime image by adding the <kbd>com.packt</kbd> modules created in our <kbd>HelloWorldXml</kbd> example:</p>
<pre><strong>$&gt; jlink --module-path mods/:$JAVA_HOME/jmods/ --add-modules com.packt --output img</strong></pre>
<p>Looking at the contents of the <kbd>img</kbd> folder, we should find that it has the <kbd>bin</kbd>, <kbd>conf</kbd>, <kbd>include</kbd>, and <kbd>lib</kbd> directories. We will learn more about <kbd>jlink</kbd> under <a href="488da544-ff73-4ef7-9d57-00b67479defd.xhtml">Chapter 3</a>, <em>Modular Programming</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">jmod</h1>
                </header>
            
            <article>
                
<p>JMOD is a new format for packaging your modules. This format allows including native code, configuration files, and other data that do not fit into JAR files. The JDK modules have been packaged as JMOD files.</p>
<p>The <kbd>jmod</kbd> command-line tool allows <kbd>create</kbd>, <kbd>list</kbd>, <kbd>describe</kbd>, and <kbd>hash</kbd> JMOD files:</p>
<ul>
<li><kbd>create</kbd>: This is used to create a new <kbd>jmod</kbd> file</li>
<li><kbd>list</kbd>:  This is used to list the contents of a <kbd>jmod</kbd> file</li>
<li><kbd>describe</kbd>: This is used to describe module details</li>
<li><kbd>hash</kbd>: This is used to record hashes of tied modules</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JShell</h1>
                </header>
            
            <article>
                
<p>This tool has been briefly explained earlier, under the title, <em>JEP 222: jshell - the Java shell (Read-Eval-Print Loop)</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Comparing JDK 8 and JDK 9</h1>
                </header>
            
            <article>
                
<p>Due to the application of a modular system to JDK under Project Jigsaw, there have been a few changes in the JDK directory structure installed in your systems. In addition to these, there were a few changes undertaken to fix the JDK installation structure, which dates back to the times of Java 1.2. This has been deemed to be a golden opportunity by the JDK team to fix the issues with the JDK directory structure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>To see the difference in the JDK 9 directory structure, you will need to install a pre-JDK 9 version. We have chosen to use JDK 8 to compare with JDK 9. So, go ahead and install JDK 8 before you proceed further. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>We did a side-by-side comparison of both the JDK installation directories as shown in the following:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="224" width="376" class="image-border" src="assets/b3a4d907-5b86-464f-88a5-0f0e83b5ce91.png"/></div>
<ol start="2">
<li>Following are our observations from the preceding comparison:
<ul>
<li>The <kbd>jre</kbd> directory has been completely removed and has been replaced by <kbd>jmods</kbd> and <kbd>conf</kbd>. The <kbd>jmods</kbd> directory contains the runtime images of the JDK modules, the <kbd>conf</kbd> directory contains configuration and property files, which were earlier under the <kbd>jre</kbd> directory. </li>
<li>The contents of <kbd>jrebin</kbd> and <kbd>jrelib</kbd> have been moved to the lib and bin directories of JDK installation.</li>
</ul>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipe of this chapter:</p>
<ul>
<li>Using new tools in JDK 9</li>
</ul>


            </article>

            
        </section>
    </body></html>