<html><head></head><body>
		<div id="_idContainer050">
			<h1 id="_idParaDest-109"><a id="_idTextAnchor109"/>Chapter 5: Exploring the Most Common Development Models</h1>
			<p>In this chapter, we will position some of the notions we have discussed so far into a more complete picture. We are going to elaborate on the most common development models. We've already seen the importance of designing proper architectures, how to collect requirements, and how to translate the architectural ideas into code solutions that answer those requirements.</p>
			<p>The software development models that we will see in this chapter revolve around all of those aspects (and some more), arranging them in proper and tested ways, to achieve different results or emphasize certain areas.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Learning about Code and Fix</li>
				<li>Glancing at the Waterfall model</li>
				<li>Understanding the Agile methodology</li>
				<li>Introducing Lean software development</li>
				<li>Exploring Scrum</li>
				<li>Learning about other Agile practices</li>
				<li>Understanding DevOps and its siblings</li>
			</ul>
			<p>When discussing development models today, everybody goes all-in with <strong class="bold">DevOps</strong> and <strong class="bold">Agile</strong> techniques. While I do endorse all this enthusiasm for those approaches, my personal experience says that it's not that easy to apply them correctly in all the different contexts. For this reason, it's important to know many different approaches and try to get the crucial lessons from each one. Even if you do not have the ideal conditions for working with DevOps, it doesn't mean that you cannot use some of the good ideas associated with it.</p>
			<p>At the end of this chapter, you will have an overview of the most widespread development models, along with their pros and cons. This will help you choose the right model, depending on your project needs.</p>
			<p>But first, let's start with the naive development model (or a <em class="italic">non-model</em>, if you want), that is, <strong class="bold">Code and Fix</strong>.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor110"/>Learning about Code and Fix</h1>
			<p>Let me get to the point as soon as possible – Code and Fix is not a model. It is something more akin to anarchy. The whole concept here is about diving into coding with no planning at all. For this reason, it is called <a id="_idIndexMarker465"/>Code and Fix. In this, you completely skip all the crucial phases highlighted hitherto (requirements collection, architectural design, modeling, and so on) and start coding.</p>
			<p>Then, if things go wrong, such as there are bugs or the software does not behave as expected, you start fixing. There is no dedicated time for writing documentation, nor for <strong class="bold">automation</strong> and <strong class="bold">unit testing</strong>. Versioning of the code is naive, and so is the dependency between modules (or maybe everything is stuck in just one huge module).</p>
			<p>As you can imagine, there are few, if any, advantages to adopting this non-model. Let's start with the (obvious) disadvantages: </p>
			<ul>
				<li>You are basically <a id="_idIndexMarker466"/>working against whoever will maintain the code (perhaps your future self). All the quick fixes and workarounds that you will stick into your code will come back to bite you when you need to touch it again. This phenomenon is usually <a id="_idIndexMarker467"/>known as <strong class="bold">technical debt</strong>.</li>
				<li>Since you are not analyzing requirements properly, you risk wasting effort working on a feature that does not provide any value to the customer and the final user.</li>
				<li>Collaboration between developers in the team, and with external teams, is hard, as there is no clear <a id="_idIndexMarker468"/>separation of duties (hence, Code and Fix is also known as <strong class="bold">cowboy coding</strong>).</li>
				<li>It's hard to estimate the time needed to complete a release.</li>
			</ul>
			<p>So, it's easy to say that adopting Code and Fix is not advisable at all. But surprisingly enough, it is still very widespread. These are the<a id="_idIndexMarker469"/> main reasons for its widespread application:</p>
			<ul>
				<li>Small teams with no dedicated roles (or with just one developer)</li>
				<li>A lack of skills and experience</li>
				<li>A lack of time (not a good excuse at all, as a bit of structure will probably save time anyway)</li>
			</ul>
			<p>However, Code and Fix <a id="_idIndexMarker470"/>can be partially justified when working on very small projects that will not require any maintenance or evolution, such as prototypes or projects with a defined, short lifetime. </p>
			<p>It's also worth noticing, before diving into more complex and complete techniques, that embracing such methodologies is not a warranty of a successful project, and implementing Scrum, DevOps, or whatever you like is not going to be the perfect way to avoid a technical debt. Indeed, the software development methodologies are suggestions on how to give cadence on a project and what are the meaningful splits of roles and responsibilities, as seen in other projects. But it's ultimately the responsibility of the project team (and yours, as an architect) to ensure that the methodology (if any) is correctly used and that no pieces are left behind, in terms of technical debt, code quality, and project scheduling.</p>
			<p>With that said, the natural step after Code and Fix is to provide a bit of structure, sequentially, which is known as the <strong class="bold">Waterfall</strong> model.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor111"/>Glancing at the Waterfall model</h1>
			<p>As has been said, the <a id="_idIndexMarker471"/>Waterfall model is a structured development model based on a sequence of different phases. This means that each phase begins when the previous one has ended.</p>
			<p>The Waterfall model probably stems from the application of project management practices coming from other kinds of projects, such as constructing buildings or manufacturing objects. Indeed, while I am no expert on them, it's easy to understand that in order to build a house, you have to precisely follow a sequence of steps, such as calculating the materials and weights, building foundations, and constructing walls.</p>
			<p>The Waterfall model originated from a number of different articles and lectures (with the most important coming from Winston Royce) and has also been ratified in an official document by the <strong class="bold">US Department of Defense</strong>.</p>
			<p>The phases in the <a id="_idIndexMarker472"/>Waterfall model are as follows:</p>
			<ul>
				<li><strong class="bold">Requirement management</strong>: You probably have a very good idea of what this phase entails, as per <a href="B16354_02_Final_JM_ePUB.xhtml#_idTextAnchor034"><em class="italic">Chapter 2</em></a>, <em class="italic">Software Requirements – Collecting, Documenting, Managing</em>. In the Waterfall model, the requirement specification must be completed and formally accepted before proceeding with the next phase, while we discussed how, usually, an iterative approach is more natural.</li>
				<li><strong class="bold">Analysis/design</strong>: Sometimes defined as two different phases, the goal is to start from system requirements and then define the solution architecture to satisfy them. As in the previous phases, whoever is in charge of the next phase must formally accept the deliverables coming from this phase (such as system blueprints, diagrams, and pseudocode) in order for the process to continue. This basically means that developers must clearly understand what they are supposed to implement.</li>
				<li><strong class="bold">Implementation</strong>: In this phase, the development team, starting from requirements and from the deliverables produced in the previous phase, must write the code to implement a proper software solution. This phase is, of course, crucial, and the correct completion of this phase basically means the success of the whole project.</li>
				<li><strong class="bold">Testing</strong>: As seen before, the acceptance of the deliverables coming from the preceding step is part of each phase. With testing, the approval is so important (and so complex) that it overlaps with the whole phase. The Waterfall model does not specifically distinguish between different kinds of testing, but this phase is commonly intended <a id="_idIndexMarker473"/>as <strong class="bold">user acceptance testing</strong>.</li>
				<li><strong class="bold">Operations/maintenance</strong>: This is the final step, facilitated by technical activities ensuring the proper setup of the solution in a production environment, as well as all the planned and unplanned activities to keep it operating properly.</li>
			</ul>
			<p>The following diagram demonstrates the phases of the Waterfall model:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/Figure_5.01_B16354.jpg" alt="Figure 5.1 – The Waterfall phases&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – The Waterfall phases</p>
			<p>As you can see, the <a id="_idIndexMarker474"/>Waterfall model is a big jump when starting from Code and Fix, as we are starting to see a clearer distinction of what should be done in each phase. </p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor112"/>Advantages and disadvantages of the Waterfall model</h2>
			<p>The Waterfall <a id="_idIndexMarker475"/>software development model is still widely used. Some of the advantages of this model are as follows:</p>
			<ul>
				<li>There is a clear definition of phases, hence planning is rather easier. Even though the phases should not overlap, it flows sequentially.</li>
				<li>The mechanism encourages a proper handover between teams, including a formal acceptance between one phase and the following, giving greater control over planning and project quality. </li>
			</ul>
			<p>However, as you probably already know, there are <a id="_idIndexMarker476"/>some disadvantages to this methodology:</p>
			<ul>
				<li>The first and most evident disadvantage is the lack of flexibility. If you implement the Waterfall model entirely, you should not start implementing it before requirements have been collected in their entirety and the design has been carried out in full. In the real world, this is unlikely to happen; as we have seen, the requirement collection keeps flowing and the architecture design evolves while we face (and resolve) implementation issues.</li>
				<li>Moreover, the <a id="_idIndexMarker477"/>software that we are building is seen and tested once implementation is complete. This means that you will not receive feedback on your code until very late in the project (maybe too late). </li>
			</ul>
			<p>For this reason, the Waterfall model has undergone several transformations, usually shortening the feedback loop, or cycling and jumping between phases (such as adding more requirements while implementing or managing defects identified during the testing phase). But while this model is still used, more flexible methodologies are now widespread, as they offer a less risky approach to development, and it all starts with Agile methodologies.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor113"/>Understanding the Agile methodology</h1>
			<p>The <strong class="bold">Agile</strong> methodology <a id="_idIndexMarker478"/>is a galaxy of best practices and techniques. A lot of still widely used methodologies inspired Agile (such <a id="_idIndexMarker479"/>as <strong class="bold">Scrum</strong> and <strong class="bold">Kanban</strong>), but the<a id="_idIndexMarker480"/> official birth of the movement stems from the <em class="italic">Agile Manifesto</em>, published in 2001. The four very popular key concepts (values) of the <em class="italic">Agile Manifesto</em> are as <a id="_idIndexMarker481"/>follows:</p>
			<ul>
				<li><em class="italic">Individuals and interactions</em> over processes and tools</li>
				<li><em class="italic">Working software</em> over comprehensive documentation</li>
				<li><em class="italic">Customer collaboration</em> over contract negotiation</li>
				<li><em class="italic">Responding to change</em> over following a plan</li>
			</ul>
			<p>While some of the preceding points can be misinterpreted and result in bad behaviors, such as ditching documentation and planning, it's enlightening to think about such simple but powerful advice. Also, be careful that the manifesto itself advocates against complete anarchy as a result of the following note: </p>
			<p class="author-quote"><em class="italic">"While there is value in the items on the right, we value the items on the left more."</em></p>
			<p class="callout-heading">Important Note:</p>
			<p class="callout">The values on the left here are the ones mentioned at the beginning of each value and refer to <em class="italic">freedom</em> (such as working software), while the ones on the right are the ones at the end, referring to <em class="italic">discipline</em> (such as comprehensive documentation).</p>
			<p>This part is often foreseen by teams looking into Agile methodologies as an excuse to skip the boring parts of the development process. The Agile process appreciates freedom but does not preclude some level of order.</p>
			<p>There is moreover a very important observation to make while introducing the topic of Agile. The <a id="_idIndexMarker482"/>Agile methodology, and all its implementations described in this chapter, consider it crucial to have the customer (or the business owner, in other words, who is paying for the project) be aware of the methodology and willing to be part of it. Indeed, it's common to see in the following <em class="italic">The Agile principles</em> section the advice and principles involving the customers, as they're an active part of the software development project by providing inputs and feedbacks in many steps of the process. For such a reason, the adoption of an Agile practice will not be possible if the customer does not agree (implicitly or explicitly) with it.</p>
			<p>The <em class="italic">Agile Manifesto</em> further details the basic values of Agile by providing a list of principles.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor114"/>The Agile principles</h2>
			<p>As opposed to Waterfall, Agile <a id="_idIndexMarker483"/>bets everything on collaboration (within the team, and with customers too) and releases small chunks of working software often with a view to getting feedback early and adapting planning if necessary. Instead of trying to foresee everything and plan accordingly, Agile teams focus on quickly adapting to changing conditions and acting subsequently. This is well detailed in the Agile principles:</p>
			<ul>
				<li>Our highest priority is to satisfy the customer through early and continuous delivery of valuable software. </li>
				<li>Welcome changing requirements, even late in development. Agile processes harness change for the customer's competitive advantage.</li>
				<li>Deliver working software frequently, from a couple of weeks to a couple of months, with a preference for the shorter timescale.</li>
				<li>Business people and developers must work together daily throughout the project.</li>
				<li>Build projects around motivated individuals. Give them the environment and support they need and trust them to get the job done.</li>
				<li>The most efficient and effective method of conveying information to and within a development team is face-to-face conversation.</li>
				<li>Working software is the primary measure of progress.</li>
				<li>Agile processes promote sustainable development.</li>
				<li>Sponsors, developers, and users should be able to maintain a constant pace indefinitely. </li>
				<li>Continuous <a id="_idIndexMarker484"/>attention to technical excellence and good design enhances agility.</li>
				<li>Simplicity – the art of maximizing the amount of work not done – is essential.</li>
				<li>The best architectures, requirements, and designs emerge from self-organizing teams.</li>
				<li>At regular intervals, the team reflects on how to become more effective and then tunes and adjusts its behavior accordingly.</li>
			</ul>
			<p>As you may see, other best practices are stressed in these principles, such as focusing on good architecture, privileging simple solutions, and building motivated teams. Of course, those are the general ideas. Before and after the publishing of the manifesto, a number of practices have been built around similar topics. In the next section, we will talk about Lean software development, a practice often associated with Agile development, which has its roots in the manufacturing industry.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor115"/>Introducing Lean software development</h1>
			<p><strong class="bold">Lean software development</strong> is a<a id="_idIndexMarker485"/> framework developed after the manufacturing method of the same name, which, in turn, is derived from the <strong class="bold">Toyota Production System</strong>. The interesting concept regarding this topic, indeed, is how it<a id="_idIndexMarker486"/> translates best practices from industrial production into software production. This is also due to the experience of one of the authors (Mary Poppendieck) in this context. She worked in the manufacturing industry and had the opportunity to learn about the production processes in a factory context directly.</p>
			<p>We will quickly cover a selection of the principles of Lean software development in the upcoming sections.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor116"/>Eliminating waste</h2>
			<p>Waste is a <a id="_idIndexMarker487"/>concept directly mutated from the Toyota Production System. Basically, waste is everything that costs resources without giving any value to the finished product.</p>
			<p>Taking it to the extreme, in software development, everything that is not related to analysis or coding could be a waste. This can be seen as another point of view in the <strong class="bold">simplicity</strong> Agile principle.</p>
			<p>To identify waste in software development, Lean software development suggests looking into its seven main areas:</p>
			<ul>
				<li><strong class="bold">Partially done work</strong>: This area relates to non-completed or non-released features. This means accumulating code, which has to be maintained, without providing any utility to the final customer. Moreover, since incomplete work is never proven in production, you can never be 100% sure that everything works as expected. You can also take into account the fact that releasing the software, which we are building in production, is the only way to understand whether such code is valuable.</li>
			</ul>
			<p>A famous paper by Ron Kohavi states that just one-third of the implemented features provide positive impacts, while the rest are neutral or even negative. The only way to figure it out is to release the code in production and see the feedback of real customers using it.</p>
			<ul>
				<li><strong class="bold">Extra Processes</strong>: This refers <a id="_idIndexMarker488"/>to bureaucracy. This means paperwork, approval processes, and similar issues. We all know that there are things that just can't be skipped, such as security checklists and handoff documents for production release. Often, however, those processes are overcomplicated and overengineered. This area should be looked at for simplifications or even automation where relevant. Instead of manually answering security-related questions, maybe you could just run automated tests, as an example.</li>
				<li><strong class="bold">Extra features</strong>: This is a very common pitfall. Perhaps in the requirement analysis, we are just pushing more and more features without any specific thoughts on whether those are useful or not. Or maybe, when implementing a new feature, it's just so easy to add a similar one, which nobody is asking for but <em class="italic">can be useful sooner or later</em>. This is just wrong. Even if the code is easy to add, it must be maintained, or else it can potentially introduce bugs.</li>
				<li><strong class="bold">Task switching</strong>: Now, it's common sense to know that context switches are time-consuming. That is particularly true in software development, where you have a lot of things to sort out, from setting up your environment (although this can, and should, be automated), to focusing on project structure and code standards, and recalling the team dynamics and latest updates. It is basically as painful as it seems, yet very tempting to juggle multiple projects at a time.</li>
				<li><strong class="bold">Waiting</strong>: This is a very common thing to relate to. We end up waiting for a number of reasons, such as the environment being created and an analysis being completed. While the technical stuff can be mitigated by automation, from a project management <a id="_idIndexMarker489"/>standpoint, it is way harder to plan everything to ensure synchronized handoffs between teams. To act against waiting, you may be tempted (or forced) to help out on other tasks and projects, while this can easily transform into other waste (as per the previous point, task switching is not the best idea).</li>
				<li><strong class="bold">Motion</strong>: As introduced previously, we have handoffs between different teams. That's the concept of motion. The longer it takes, the more waste you will have. This includes having a huge amount of back and forth, or simply too many teams cooperating. Handoffs not only include the exchange of artifacts (such as source code) but knowledge in general (such as documents or simply answers).</li>
				<li><strong class="bold">Defects</strong>: Everybody knows what a bug is and how much time it can take to find the causes and solve it. Of course, it's just impossible to write software without any bugs. But there are things you can do to reduce the impact of bugs, such as improving test coverage (including code analysis), which will end up saving time by identifying issues <a id="_idIndexMarker490"/>before they move into a snowball effect. Also, as has already been discussed, the sooner you go into production, the sooner you will find bugs (and have the opportunity to enrich your test suite).</li>
			</ul>
			<p>To identify waste in your software production cycle, the Lean software development framework provides a very useful tool <a id="_idIndexMarker491"/>called <strong class="bold">Value Stream Mapping</strong>.</p>
			<p>Value Stream Mapping is used to observe the software development process from an external point of view, mapping all the steps necessary (and the waiting time between them) for a requirement to go from inception to production release (usually known as the time to market).</p>
			<p>You are supposed to track down this simply with paper and pencil. After tracking down the whole software cycle, you usually end up figuring out that the majority of the time is lost in waiting or in other types of waste, as per the previous list. Now that you have some quantitative data, with good executive sponsorship, you can act by changing the flow to maximize the time spent delivering value and minimizing waste. This will usually include simplifying approval processes and automating manual steps. The efficiency that can be attained here is mind-blowing.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor117"/>Deciding as late as possible</h2>
			<p>This section is all <a id="_idIndexMarker492"/>about being open to changes. Especially when making expensive choices, it is good to defer the decision as much as possible, as more information may come to light to support the choice. Moreover, making a decision later will reduce the risk of having to get back to redoing part of the work owing to a wrong decision. </p>
			<p>However, there are more subtle implications in this principle. What comes to my mind is the mythical quote from Donald Knuth:</p>
			<p><em class="italic">"Premature optimization is the root of all evil."</em></p>
			<p>This means that if you make choices (especially hard to undo choices) too soon, you may end up making the wrong choice because of a lack of information, or simply wasting time with a topic that will end up not being that relevant. So, one strong piece of advice from the Lean software development framework is that you shouldn't commit to everything unless you have to, stay open and flexible, and defer from making complex decisions until you have no alternatives.</p>
			<p>Translated in the software world, there are a number of different ways to do this, such as using stubs instead of real systems (before deciding which system to use), defining modular options (to facilitate the switching of different implementations), and using feature flags (to elicit specific behaviors directly in production). Just make sure that you find the right trade-off to avoid piling up waste. Implementing tens of different behaviors because you don't know what the final decision will be is, of course, not an option, but there are middle grounds. </p>
			<p>A rule of thumb is usually to avoid planning for years or even months in advance. It's better to end up with very detailed planning for the upcoming weeks, which will become less and less detailed going forward in time.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor118"/>Delivering as fast as possible</h2>
			<p>This is a <a id="_idIndexMarker493"/>concept that I've emphasized a lot, so I will keep it as concise as possible. Organizing the delivery work in small chunks is key. That's what <em class="italic">fast</em> refers to. You have to plan for releasing often. This will do for having feedback early and perfecting your strategy on the go.</p>
			<p>There are several pieces of advice here, such as having a regular rate of release (both in terms of the time window and in terms of the number of features) and moving from a push to a pull approach (there will be more on this when we discuss it in the <em class="italic">Kanban board</em> section). Personally, I think the most important thing is to avoid keeping the team overloaded. Having some spare capacity will allow the team to work more efficiently.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor119"/>Optimizing the whole product</h2>
			<p>As stated <a id="_idIndexMarker494"/>previously, optimization is tempting but not necessarily always the answer. The thinking here is about approaching the process (and the system) as a whole. Optimizing just one of the subparts (or the subprocess) may indeed have adverse effects on the final result. Let me explain this with the aid of two practical examples (in the process and system area):</p>
			<ul>
				<li>It may be tempting to reduce the testing phase to improve the time to market. However, if you have a holistic approach, the time spent on fixing bugs will probably be bigger than the saving. And we are not taking into account the impacts of bugs, such as downtimes, bad reputation, and customer churn.</li>
				<li>You may consider optimizing the disk usage of your application in many ways, such as compressing files or using special formats (such as binary). But this may, of course, come at the cost of a slower reading so, overall, it may not be a good idea.</li>
			</ul>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor120"/>Pros and cons of Lean development</h2>
			<p>As we have seen, Lean is the first practical implementation of the Agile concepts. For that reason, the advantages<a id="_idIndexMarker495"/> over more structured methodologies (such as the Waterfall model, which we have already seen) are evident:</p>
			<ul>
				<li>A greater flexibility, meaning that changes in the planning and requirements are better tolerated</li>
				<li>Enhanced freedom for the teams, where they may choose what works for them locally, that is, both technologically and from an organizational point of view</li>
				<li>A shorter feedback cycle, which means faster time to market and understanding sooner how your software performs (as discussed in <a href="B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089"><em class="italic">Chapter 4</em></a>, <em class="italic">Best Practices for Design and Development</em>, when talking about Minimum Viable Products)</li>
			</ul>
			<p>The disadvantages<a id="_idIndexMarker496"/> of Lean development will definitely vary, based on the team composition and the project complexity. Some common ones are as follows:</p>
			<ul>
				<li>Lean is more of a set of principles (part of the broader set of Agile principles), rather than a structured methodology. This means that the outcome may be less predictable.</li>
				<li>As a further consequence, it doesn't usually work well with less-skilled teams, as it requires high maturity and greatly delegates decisions to each team member.</li>
				<li>In the case of big projects, the modularization for being worked by many small lean teams is accomplished, while the methodology can scale well. It's also hard to keep track of the greater picture and synchronize between each team and subproject.</li>
				<li>Deciding as late as possible means that some architectural decisions are delayed too much. As a<a id="_idIndexMarker497"/> consequence, from time to time, some rework may happen (because of wrong choices or simply the lack of any choice).</li>
			</ul>
			<p>In this section, we learned about Lean software development, which is a framework full of good ideas, practices, and tools. </p>
			<p>We've seen a walk-through of a lot of valuable ideas, such as waste reduction, openness to changes, holistic optimization, and fast feedback loop.</p>
			<p>Bear in mind that there is a bit of overlap and mutual influence between the different philosophies in the Agile spectrum. Let's now switch to another well-known one – Scrum.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor121"/>Exploring Scrum</h1>
			<p>The <strong class="bold">Scrum</strong> methodology<a id="_idIndexMarker498"/> was launched by Ken Schwaber and Jeff Sutherland in a paper published in 1995. The authors were also involved in the creation of the <em class="italic">Agile Manifesto</em> a bit later, so some of those ideas are directly linked.</p>
			<p>Scrum differs slightly from Lean software development because, more than principles and high-level advice, it focuses directly on roles, project cadence (via the so-called <em class="italic">events</em>), and rules. The authors stress the fact that while you can customize the technique a bit, Scrum is intended to be <em class="italic">all or nothing</em>, meaning that you should accept and practice all the key components before embarking on a Scrum project.</p>
			<p>Scrum <a id="_idIndexMarker499"/>refers to a phase of rugby and is regarded as an analogy for a cohesive, cross-functional team, pushing together to pursue a common objective.</p>
			<p>In this section, we will see the fundamental elements of Scrum: the team composition (roles and responsibilities), the events (meetings and other key appointments of a Scrum project), and artifacts (the tool supporting the Scrum methodology).</p>
			<p>Let's start with the team setting.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor122"/>Understanding the Scrum teams</h2>
			<p>The <a id="_idIndexMarker500"/>Scrum teams are kind of a self-sufficient ecosystem. This means having all the skills needed to deliver tasks (or, in other words, being a cross-functional team), and being self-organized (as long as the team satisfies expectations, it can follow its own rules). The Scrum methodology identifies three main roles: the <strong class="bold">Scrum master</strong>, the <strong class="bold">product owner</strong>, and the members of the development team.</p>
			<h3>Development team</h3>
			<p>The <a id="_idIndexMarker501"/>development team, as you<a id="_idIndexMarker502"/> can imagine, is the one that will <em class="italic">hands-on</em> complete the assigned tasks, in the form of implemented and testable features. It is, by design, a flat team (no hierarchy or sub-teams are allowed) and has all the skills needed to complete the tasks (meaning that you can suppose it will not only include developers but also security experts, DBAs, and everyone else that should be needed).</p>
			<p>As said, the development team is autonomous in terms of technical choices but is accountable (as a whole) for the outcomes of those choices. One of the main discussions centers on development teams when Scrum is applied to large enterprise environments. Indeed, often, the enterprise has guidelines and policies that have to be respected and, in this sense, are limiting the development team's freedom. Moreover, the need for different kinds of skills may lead to variability in the team's composition (with people temporarily moving between different projects), and that is a mechanism that needs to be sometimes facilitated and monitored, as schedule clashes may occur.</p>
			<h3>Product owner</h3>
			<p>The <strong class="bold">product owner</strong> is <a id="_idIndexMarker503"/>essentially responsible for the development pace. The product owner<a id="_idIndexMarker504"/> is the person committed to selecting the working items from a bunch of to-dos (also known as the Product Backlog, as we have briefly seen in <a href="B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089"><em class="italic">Chapter 4</em></a>, <em class="italic">Best Practices for Design and Development</em>, when talking about User Story Mapping), and understand which items must be implemented and when.</p>
			<p>We will talk more about the Product Backlog soon, in the <em class="italic">Understanding Scrum artifacts</em> section, but for now, you can imagine how crucial this task is in terms of customer expectations, and how important it is to choose tasks with the right rationales to maximize overall throughput.</p>
			<h3>Scrum Master</h3>
			<p>The <strong class="bold">Scrum Master</strong> is<a id="_idIndexMarker505"/> basically the sponsor and advocate of the Scrum methodology, both internally to the team and externally to the rest of the organization. Their <a id="_idIndexMarker506"/>role is to mentor the junior members of the team and, generally, anyone who is not an expert in the methodology.</p>
			<p>If the organization is adopting Scrum at scale, all Scrum Masters create community-exchanging best practices on how to achieve results better. Scrum Masters are responsible for facilitating the jobs of the other members of the team by circumventing the blockers that prevent the team from performing at their full potential. The Scrum Master and the product owner are two different roles, and they should be filled by different individuals.</p>
			<p>In the next section, we'll be looking at Scrum Events.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor123"/>Learning about Scrum Events</h2>
			<p><strong class="bold">Scrum Events</strong> are <a id="_idIndexMarker507"/>the institutionalized project's recurring appointments that set the pace of overall implementations. </p>
			<p>Scrum Events are instrumental to a project's success by providing the opportunity for the planning, execution, and reviewing of the work that needs to be done.</p>
			<p>The basic unit of measure of this pace in Scrum is the Sprint.</p>
			<h3>Sprint</h3>
			<p>A <strong class="bold">Sprint</strong> in<a id="_idIndexMarker508"/> Scrum is a recurrent iteration, time-boxing a set of development activities. A Sprint is usually considered a mini project, with a fixed timeframe of 2–4 weeks. During the Sprint, there is a fixed set of goals that cannot be changed, and they are picked from the development team in the way they want.</p>
			<p>A Sprint is essentially <a id="_idIndexMarker509"/>used to implement Agile best practices for working iteratively by releasing working software often and in small batches. This is, of course, very useful in reducing risks. If there is a shift in priorities, or something else goes wrong, your biggest risk in terms of resources is to lose one Sprint's worth of effort.</p>
			<h3>Sprint planning</h3>
			<p><strong class="bold">Sprint planning</strong> is, of course, the<a id="_idIndexMarker510"/> meeting at which the whole Scrum team reunites to choose what will be done during a particular Sprint. The product owner clarifies the priorities and the features to be implemented by looking at the Product Backlog. Then, in accordance <a id="_idIndexMarker511"/>with the development team (and facilitated by the Scrum Master), the <strong class="bold">Sprint Goal</strong> is defined.</p>
			<p>The Sprint goal is usually<a id="_idIndexMarker512"/> one or more consistent features, representing the objectives for the Sprint. The Sprint goal is then defined as a set of workable items, picked from the Product Backlog. Those items, and the way to achieve them (which is the responsibility of the development team to define), constitute the Sprint Backlog.</p>
			<h3>Daily Scrum</h3>
			<p>The <strong class="bold">daily Scrum</strong> is a short <a id="_idIndexMarker513"/>meeting held every day of the Sprint by the development team. It's usually set up at the beginning of the workday, with a duration of 15 minutes (this is just a rule-of-thumb time slot; it may more or less depend on the team size and project complexity). The Scrum Master and product owner can join, but the meeting is led by the development team.</p>
			<p>The goal is to stick to <a id="_idIndexMarker514"/>Sprint planning. While there is no fixed agenda, it is usually aimed at reviewing the activities from the day before, planning activities for the current day, and addressing any issue that may put the Sprint goal at risk. Ideally, the daily Scrum should be the only sync meeting for the day, thereby boosting the development team's productivity. However, in the real world, it is not unusual for development teams to have follow-up meetings to address particularly complex issues.</p>
			<p>The daily Scrum is also<a id="_idIndexMarker515"/> called a <em class="italic">standup meeting</em>, a naming that is also used in other Agile project methodologies. The reason behind it is that (in theory) it should be done standing up, giving further motivation to the participants to make it quicker (it will be uncomfortable to stand up for an hour during a boring meeting) and to <a id="_idIndexMarker516"/>stay active and participate during the meeting.</p>
			<h3>Sprint review</h3>
			<p>The <strong class="bold">Sprint review</strong> is a<a id="_idIndexMarker517"/> recurrent meeting held at the end of each Sprint. The entire Scrum team participates, and relevant business stakeholders are invited by the product <a id="_idIndexMarker518"/>owner. The development team has a demo of what was implemented during the Sprint, if possible. There is then a question-and-answer session to address doubts and discuss any issues that arose, if any.</p>
			<p>This is also an opportunity to discuss Product Backlog based on current circumstances. This may also include changing priorities. Other <em class="italic">all hands</em> discussions may occur as well, such as budget, planning, resources, and similar topics. All those interactions usually provide valuable inputs for the next Sprint planning.</p>
			<h3>Sprint retrospective</h3>
			<p>The <strong class="bold">Sprint retrospective</strong> is a<a id="_idIndexMarker519"/> meeting lasting a few hours that takes place after the Sprint review and before the Sprint planning. The meeting involves the entire Scrum team. The goal is to focus on what went well and what needs to improve by looking at the previous Sprint. This meeting is usually focused more on processes, tools, and <a id="_idIndexMarker520"/>team interactions. This is also often used as a team-building activity. </p>
			<p>It's worth noticing that there is a difference between the review and the retrospective. The Sprint review is focused on what has been implemented (the product); it includes a demo, and the business stakeholders are present and an active part of it. The focus is then on <em class="italic">what</em> we have done. In the retrospective, the business stakeholders may or may not be invited, and the focus is on <em class="italic">how</em> we have done whatever we have done. In other words, the spotlight is on the Scrum team, the interactions, and the processes. We may discuss the adopted tools, the choice of frameworks, the architecture, or simply what we liked and didn't like about how we worked in our last Sprint. </p>
			<p>The Sprint retrospective meets a common goal of most Agile methodologies, which is continuous improvement. We will come back to this concept later when talking about Kaizen.</p>
			<h3>Backlog refinement</h3>
			<p><strong class="bold">Backlog refinement</strong> is<a id="_idIndexMarker521"/> usually a continuous process, more than a fixed appointment. The <a id="_idIndexMarker522"/>objective of refinement is reviewing items in the Product Backlog (the project's to-do list; there will be more on this in the <em class="italic">Understanding Scrum artifacts</em> section). This is done by the product owner and the development team (or part of the development team). They cooperate to detail the items (basically, analyzing technical aspects and revisiting requisites) and refine the estimation (which is the responsibility of the development team).</p>
			<p>Priority shifting may happen. Usually, the items with the highest priority (which are likely to happen in the next one or two Sprints) are supposed to be the clearer ones, while the lower-priority items are expected to be reviewed again. In practice, those activities are completed by the team in one or two fixed appointments per Sprint. Scrum suggests using less than 10% of the team's capacity in this sense.</p>
			<p>In the next section, we will be learning about Scrum artifacts.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor124"/>Understanding Scrum artifacts</h2>
			<p><strong class="bold">Scrum artifacts</strong> are tools<a id="_idIndexMarker523"/> supporting the Scrum activities. This methodology refers to such tools as a way to implement transparency. In this sense, those artifacts should be available to all the teams and the relevant stakeholders.</p>
			<p>While digital supports are commonly used, the use of physical items (such as whiteboards and sticky notes) to encourage brainstorming and in-person collaboration is also widespread. The work produced with physical tools should then be digitized for tracking and sharing purposes. Let's now see what those tools are, starting with the Product Backlog, followed by the Spring Backlog.</p>
			<h3>Product Backlog</h3>
			<p>We have already referred to<a id="_idIndexMarker524"/> the <strong class="bold">Product Backlog</strong> a couple of times, so by now you probably already have an idea of what it is, more or less. In simple terms, the Product Backlog is the single source of truth for each thing that should happen in the <a id="_idIndexMarker525"/>product, meaning new features, bug fixes, and other developments (improvements, refactoring, and so on).</p>
			<p>These are categorized, including a description, unique ID, priority, and the effort required. The effort is constantly evaluated and refined by the development team. Items in the Product Backlog may be attached to test cases and other details, such as mockups and more. The product owner is ultimately accountable for the Product Backlog.</p>
			<p>Since the Product Backlog is the funnel ingesting requests to be implemented by the development team, it can be regarded as an <em class="italic">infinite scroll</em>, meaning that new items will continuously be added to it. As already discussed in <a href="B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089"><em class="italic">Chapter 4</em></a>, <em class="italic">Best Practices for Design and Development</em>, the <strong class="bold">User Story Mapping</strong> technique <a id="_idIndexMarker526"/>can be considered a variation or evolution of the Product Backlog, adding more information and dimensions to it.</p>
			<h3>Sprint Backlog</h3>
			<p>The <strong class="bold">Sprint Backlog</strong> is the<a id="_idIndexMarker527"/> chunk of work to be done during each Sprint. It comprises the following:</p>
			<ul>
				<li>The <strong class="bold">Sprint goal</strong>, being the <a id="_idIndexMarker528"/>feature (sub-feature, or set of features) that we aim<a id="_idIndexMarker529"/> to add to the product as a result of the Sprint</li>
				<li>A set of items selected from the Product Backlog that need to be implemented in order to achieve the Sprint goal</li>
				<li>A plan for implementing those items during the Sprint</li>
			</ul>
			<p>That's the way to keep work structured at a consistent pace in Scrum.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor125"/>Advantages and disadvantages of Scrum</h2>
			<p>It should be evident, at this point, that Scrum is a very well-structured methodology (while still being flexible and adhering to Agile principles). For this reason, it is so widespread, up to the point that there are professional certifications available and plenty of job positions for experienced Scrum professionals.</p>
			<p>The main advantages<a id="_idIndexMarker530"/> of adopting Scrum could be summarized as follows:</p>
			<ul>
				<li>The roles and responsibilities are very well defined, leaving less room for conflicts and misunderstandings.</li>
				<li>There is a defined timetable and some predictable moments in which updates (and deliverables) are shared with the rest of the team (and made visible to management).</li>
				<li>It's easier to do the planning (even with some expected flexibility and inaccuracy) and have visibility on what's completed and what is left almost constantly (also thanks to the concept of backlog and, in general, to the Scrum artifacts).</li>
			</ul>
			<p>The Scrum disadvantages<a id="_idIndexMarker531"/> are similar to the ones in the other Agile and Lean methodologies. The following comes to mind:</p>
			<ul>
				<li>The structured process flow and events could be seen as boring and time-intensive, especially when working with highly experienced teams or in long-term projects.</li>
				<li>The coordination of multiple Scrum teams working on different projects may be complex.</li>
				<li>Bigger teams (with more than nine people) usually don't work well in a Scrum setup (hence, they should be modularized into smaller teams, and coordination will be a downside, as per the previous point).</li>
			</ul>
			<p>As you have learned in this section, Scrum is a simple but disciplined way to structure the software development process. And due to its simplicity and effectiveness, it has become widespread. So, I hope the information shared in this section has motivated you to learn more and to apply Scrum principles to your projects. </p>
			<p>In the next section, we will see some more Agile practices that are not directly linked with Scrum or any other particular framework but are often used complementarily.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor126"/>Learning about other Agile practices</h1>
			<p>So far, we have seen the <a id="_idIndexMarker532"/>Agile methodologies and had a quick overview of the Lean software development principles and the Scrum framework. All of those ideas are often complemented by a number of practices and tools useful for completing specific phases.</p>
			<p>In this section, we'll learn about some of those tools, namely, Kaizen, Planning Poker, Kanban boards, and Burndown charts. </p>
			<p>Let's begin with Kaizen.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor127"/>Kaizen</h2>
			<p><strong class="bold">Kaizen</strong> is a <a id="_idIndexMarker533"/>principle directly borrowed from the Toyota Production System, which, as we have seen, is a core inspiration for Lean software development. <em class="italic">Kaizen</em> comes from the Japanese word for <em class="italic">continuous improvement</em>.</p>
			<p>This simple concept is the essence of Kaizen, which articulates it with a comprehensive and elegant philosophy, embodying the concepts of humanization of the workplace, constant change (the opposite of big-bang, huge transformations). It is also responsible for identifying and removing waste (as we discussed in the <em class="italic">Introducing Lean software development</em> section), encouraging valuable feedback (both internal and external), involving all individuals in the organization (from top managers to lower levels), and so on.</p>
			<p>Another core concept of Kaizen (again, very close to some of the Agile principles seen so far) is the shift in the testing process (in a broad sense, as in inspecting the quality of the product) from the end of production to an ongoing process, once again getting feedback early to minimize drift and facilitate constant optimization.</p>
			<p>Kaizen is often<a id="_idIndexMarker534"/> orchestrated as a loop of five recurring phases:</p>
			<ol>
				<li><strong class="bold">Observe</strong>: This<a id="_idIndexMarker535"/> phase is used to understand what issues should be solved (or which aspect can be improved).</li>
				<li><strong class="bold">Plan</strong>: This phase is used for setting measurable objectives for achievement.</li>
				<li><strong class="bold">Do</strong>: This phase is used for putting into practice actions to meet those measurable objectives.</li>
				<li><strong class="bold">Check</strong>: This phase is used for comparing actual results with expected objectives.</li>
				<li><strong class="bold">Act</strong>: This phase<a id="_idIndexMarker536"/> is used for adjusting (or complementing) the plan to enhance <a id="_idIndexMarker537"/>the results and start the loop again.</li>
			</ol>
			<p>The following diagram illustrates these phases:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/Figure_5.02_B16354.jpg" alt="Figure 5.2 – The OPDCA loop&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – The OPDCA loop</p>
			<p>While nicely summarized by the <em class="italic">continuous improvement</em> concept as seen, Kaizen contains a lot of sage advice and ideas, very close to the whole idea of Lean and Agile.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor128"/>Planning Poker</h2>
			<p><strong class="bold">Planning Poker</strong> is an<a id="_idIndexMarker538"/> estimation technique, often used as part of the Scrum framework (but not a mandatory part of the framework itself). When used in Scrum, Planning Poker is done as part of Sprint planning to estimate (or refine the estimation of) the items from the Backlog.</p>
			<p>Planning Poker is a way of getting an estimation of the effort of a given item, and it works by inciting the participant to provide a size with no influence from the other team members.</p>
			<p>Poker is played by a team of estimators (usually the development team, which will then implement the features), a moderator, and a responsible project participant (which is usually the product owner if the Scrum methodology is used, or otherwise someone with a knowledge of the overall project and roadmap, such as a project manager or other senior staff).</p>
			<p>Each estimator team member has a deck of cards (or, commonly, a mobile app) used to represent a difficulty grade. There is no standard here; it is common to use a Fibonacci progression, but your mileage may vary. The Fibonacci sequence has a reasoning behind it: the more the number grows, the more distant they are from each other, and so your choice must be more thoughtful. Another commonly used unit is the t-shirt size (<em class="italic">S</em>, <em class="italic">M</em>, <em class="italic">L</em>, <em class="italic">XL</em>, and so on).</p>
			<p>Also, the expressed value (being a card, a number, or a t-shirt size) may directly map to time (as in days to implement) or not.</p>
			<p>When the <a id="_idIndexMarker539"/>meeting starts, the moderator acts as a note-taker and master of ceremonies. They read each feature to estimate and start a discussion to clarify the meaning by including estimators and the product owner. Then, the estimators select a unit (by drawing a card, picking a number, or a size) simultaneously (to avoid influencing each other), indicating the estimated difficulty. If there is no consensus, the owner of the highest and lowest estimation has to explain their point of view. Then, everybody again draws a card until a consensus is reached. Consensus rules can be customized, such as having a defined maximum gap from a perfect average or having team members that will own that development to agree on what's an acceptable stop.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor129"/>Kanban board</h2>
			<p>A <strong class="bold">Kanban board</strong>, in<a id="_idIndexMarker540"/> the software development world, is a visual way to represent the flow of items, from the ingestion to the development team to the implementation. It is a subset<a id="_idIndexMarker541"/> of the <strong class="bold">Value Stream Map</strong> (as seen in the <em class="italic">Introducing Lean software development</em> section). Kanban is indeed inspired by, and adapted from, the Toyota Production System. </p>
			<p>In its simplistic implementation, a Kanban board is a whiteboard (physical or digital), with three vertical swim lanes splitting it into <strong class="bold">TO DO</strong>, <strong class="bold">DOING</strong>, and <strong class="bold">DONE</strong>. Each item is represented as a sticky note moving between those lanes. However, it is common to customize it by adding different columns (such as splitting <strong class="bold">DOING</strong> into <strong class="bold">Design</strong>, <strong class="bold">Code</strong>, and <strong class="bold">Test</strong>), or horizontal swim lanes (to represent concepts such as priority by having a kind of fast lane for urgent things such as production issues). The following diagram illustrates this:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/Figure_5.03_B16354.jpg" alt="Figure 5.3 – A Kanban Board&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – A Kanban board</p>
			<p>Kanban <a id="_idIndexMarker542"/>boards are just an artifact part of a bigger philosophy (Kanban), which is applied both to software development and industrial production (as Lean).</p>
			<p>While describing the entire philosophy is beyond the scope of this book, there are at least a couple of concepts worth mentioning. The<a id="_idIndexMarker543"/> first is <strong class="bold">Work In Progress</strong> (<strong class="bold">WIP</strong>). This is the number of open items that the team is working on. WIP is easily tracked and visualized on the board. As per the Lean methodology, Kanban advises against using context switching; hence, a constraint on WIP should be present at any time.</p>
			<p>Another important <a id="_idIndexMarker544"/>concept is <strong class="bold">pull</strong>. Basically, the Kanban approach puts the working items at disposal of the development team (in the <strong class="bold">TO DO</strong> column). As opposed to the push paradigm, the team chooses (pulls) what to do at their own pace. This avoids hogging the team and maximizes throughput.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor130"/>Burndown chart</h2>
			<p>A <strong class="bold">Burndown chart</strong> is <a id="_idIndexMarker545"/>a common artifact (physical or digital) to clearly show a project's progression. It is very useful, regardless of which Agile methodology is used, because it gives real-time insights into planning. As has been mentioned, Agile is against detailed, advanced planning, so having a current snapshot of the project's progression (and maybe some forecasting) is precious for management.</p>
			<p>A Burndown chart plots the tasks (usually as a sum of the required effort) as the vertical axis and the timeline as the horizontal axis. Drawing a line from the top left (project start) to the bottom right (project completion) provides an ideal, linear progression. At regular times (such as every day, or at the end of each Scrum Sprint), a dot is plotted that crosses the implemented tasks and the current moment in time. The following diagram is an example of a Burndown chart:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/Figure_5.04_B16354.jpg" alt="Figure 5.4 – A Burndown chart&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – A Burndown chart</p>
			<p>As you can see, by drawing a line over those dots, you can compare the ideal project progression versus the actual project's progression. Roughly speaking, if the real project progression is above the ideal one, you are probably late, whereas if it's below, you are ahead. Having minimal deviations from the ideal progression means staying on track, and it's usually a good indicator of a project's health. Also, it gives good hints on when the project (or, at least, the represented list of tasks) will be completed.</p>
			<p>In this section, we have seen a nice list of tools that can provide you with support in Agile software development. Regardless of the methodology you are using, if any, such tools can be useful in addressing common use cases, such as optimizing processes and estimating development effort.</p>
			<p>In the next section, we will talk about a very hot and debated topic, which seems to be getting all the attention lately – DevOps.</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor131"/>Understanding DevOps and its siblings</h1>
			<p>At the time of <a id="_idIndexMarker546"/>writing, <strong class="bold">DevOps</strong> is an overinflated term. It is seen as a silver bullet for every development problem, and a mandatory prerequisite for being considered cool. I'm not going to decrease the hype about DevOps, as I truly believe it's a precious technique useful for ensuring functional and high-performing teams. However, it must be said that DevOps is more a set of best practices, rather than a well-codified, magic recipe. And, as is common in these cases, one size does not fit all.</p>
			<p>DevOps can be seen as essentially an extension of Agile methodologies. Indeed, the adoption of Agile practices (not one specifically) can be seen as a prerequisite of DevOps. And, in turn, DevOps is considered to be an essential condition for the adoption of cutting-edge approaches such<a id="_idIndexMarker547"/> as <strong class="bold">microservices</strong> (more on this in <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em>).</p>
			<p>The essential characteristic of DevOps is cooperation between different roles. This commonly means, in practical terms, a small team, encompassing all the different skills needed to build and maintain a software product in production. </p>
			<p>In this section, we will cover some core aspects of the DevOps movement, such as team composition, roles and responsibilities, and variants of DevOps, which are about including more functions in this collaboration method. But let's start with a common consideration covered in DevOps regarding team size.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor132"/>DevOps team size</h2>
			<p>When it comes to<a id="_idIndexMarker548"/> team size, the Scrum guide says that a team should be small enough to stay lean but large enough to develop a reasonable number of features in each Sprint. A common rule of thumb is to have a team of around 10 or fewer people.</p>
			<p>This rule of thumb is commonly accepted and has echoes in other stories, such as the famous two pizzas team, which states that it should be possible to feed the team with two large pizzas (so, again, roughly fewer than 10 people).</p>
			<p>This depends on the<a id="_idIndexMarker549"/> logic of links. In a functional team, each team member should have a link with the others. This means that in a team of 10 people, you will have 90 links. That's the reason why the team should not grow much above 10, or else you will have too many internal interactions to manage, which quickly impacts productivity. </p>
			<p><em class="italic">But what about the internal team's responsibility?</em></p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor133"/>Roles and responsibilities in a DevOps team</h2>
			<p>As is obvious from the name, DevOps aims at blurring the responsibilities between developers and operations. This does not mean that everybody should be capable of doing everything; it is more about having a shared goal. </p>
			<p>One of the most<a id="_idIndexMarker550"/> hateful dynamics in IT teams is the lack of accountability in case of issues. </p>
			<p>The most commonly involved teams are Ops, who are the operations and system engineers responsible for the infrastructure (and for the uptime of production systems), and Devs, which are, well, the developers, of course.</p>
			<p>Ops will always blame Devs' buggy code when something goes wrong in production, and Devs will throw code at Ops for releasing without caring about the release outcome, to the battle cry of <em class="italic">works on my machine</em>.</p>
			<p>While these dynamics are purposefully exaggerated, you can agree that the relationship between Devs and Ops is not always the best. DevOps starts here. Everybody is accountable for production – <em class="italic">you build it, you run it</em>.</p>
			<p>This means that the team (and the individuals) must shift from a skill perspective (I'm a specialist only accountable for my limited piece) to a product perspective (my first responsibility is to have a fully functional product in production, and I will use my skills for this goal). The goal of this is to build high-quality products (everybody is committed to a fully functional production service) in less time (you eliminate handovers between different departments).</p>
			<p>Taking apart the philosophy and motivations behind DevOps, there are some direct technological impacts, which can be seen both as a prerequisite and fundamental benefit of adopting DevOps:</p>
			<ul>
				<li><strong class="bold">Pervasive automation</strong>, also known<a id="_idIndexMarker551"/> as <strong class="bold">infrastructure as code</strong>: Everything, including environment definitions, should be declarative, versioned (usually in a code versioning system<a id="_idIndexMarker552"/> such as <strong class="bold">Git</strong>), and<a id="_idIndexMarker553"/> repeatable. This avoids drifting (environments strictly adhere to the expected configurations) and reduces the time for recovering from failures (it's easy to spin up new copies of the environment). This is something usually driven by the team members with prevalent Ops skills. It is common, in this regard, to see a shift<a id="_idIndexMarker554"/> toward <strong class="bold">Site reliability engineering</strong> practices, meaning that Ops will intentionally use an increasing part of their time to develop automation and other production support tools, instead of doing exclusively production-related tasks (even manually).</li>
				<li><strong class="bold">Shifting quality into software development</strong>: This means embedding all the feedback coming from production exposure into software development. This often means increasing observability (to support troubleshooting and performance tuning in production), improving code testing (to reduce the defects found in production), and everything that's necessary for safer, high-quality production releases (such as automated rollbacks in case of failures, supporting auto-scaling, and modularizing releases).</li>
			</ul>
			<p>It is now safe to try to extend this philosophy beyond Devs and Ops.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor134"/>Devs, Ops, and more</h2>
			<p>It is natural to try to extend such good practices, such as borderless collaboration (breaking silos) and tooling support (automating everything) beyond development and operations. </p>
			<p><strong class="bold">DevSecOps</strong> is a <a id="_idIndexMarker555"/>clear example of that. This is all about shifting security concerns into all phases of product development. This means, of course, integrating security specialists in the DevOps team. Very often, the approach to security is to run specific tests against the finished product soon before (or shortly after) the production release. The result is that, often, it's too late and maybe you don't have the time (or it's costly) to fix the security findings.</p>
			<p>At the opposite end, DevSecOps<a id="_idIndexMarker556"/> impacts the production process in several ways. The first is to embed best practices in the development of code, then to automate testing against security principles and rules, and lastly, continuously check compliance with those principles as part of production operation practices. This extension is particularly well accepted in highly regulated environments (such as banks, government institutions, and healthcare), and it has a positive impact in terms of the time to market and overall security.</p>
			<p><strong class="bold">BizDevOps</strong> is <a id="_idIndexMarker557"/>another variant, breaking another wall and making business owners (analysts, budget owners, and even marketing) part of the team. The collaboration model used here is less structured than with Devs and Ops (and security, if you want), since some of the activities are not perfectly overlapped, nor comprehensible between technicians and business people.</p>
			<p>However, if you think about it, Agile methodologies (and DevOps, by extension) inherently encourage cooperation with business by emphasizing short and frequent feedback loops, and openness to changes in the product life cycle. What's probably a distinct characteristic of BizDevOps is the crossed visibility on KPIs.</p>
			<p>This includes the technical team having insights into business KPIs (things such as budget, the number of users, sales trends, and more) in order to try to figure out how technical choices (new releases, changes in the infrastructure, and resource efficiency) impact on it. And it's also true the other way around; that is, the business team could have a look at the technical teams' <em class="italic">tuning wheels</em> (the size of the team, resources, and the number of changes) and how they impact the end-to-end process, in terms of development speed, costs, and so on.</p>
			<p>Lastly, <strong class="bold">NoOps</strong> is a<a id="_idIndexMarker558"/> trending topic, gaining visibility as a result of the assonance with DevOps. As it's easy to imagine, the idea here is to get rid of the Operations team completely. While it is theoretically possible, as a result of using heavily automated environments such<a id="_idIndexMarker559"/> as <strong class="bold">Platform as a Service </strong>and<strong class="bold"> Cloud</strong> (there is more on this in <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em>), to have developers capable of basic Ops tasks, such as the provisioning of new environments and deployments, <em class="italic">I strongly believe NoOps is a dead end (at least for the foreseeable future)</em>. It can be applied when reducing Ops resources in small contexts (such as serverless applications; this topic will be discussed in <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em>), but this seems more like outsourcing. You basically do not need to care about the infrastructure because someone else is taking care of it for you (a cloud provider, or maybe another department).</p>
			<p>Personally, I feel such an approach is completely the opposite of DevOps. You will end up having a huge gap between platform users (Devs) and the team running the infrastructure (Ops, which are indeed not even part of the project).</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor135"/>DevOps and the bigger organization</h2>
			<p>A model that is commonly seen as a large-scale implementation of DevOps is the <strong class="bold">Spotify</strong> development model, which is<a id="_idIndexMarker560"/> famous because it has been created and used in the homonym company building the music streaming app. </p>
			<p>Even though, in their seminal work, theorized in a publicly available paper entitled <em class="italic">Scaling Agile @ Spotify</em>, there is no mention of the word <em class="italic">DevOps</em>, you can recognize some common principles.</p>
			<p>You will find the link to the full paper in the <em class="italic">Further reading</em> section. For now, it's enough to consider that DevOps must solve the conflicting needs of having a multidisciplinary team focused on delivery (and production quality) with knowledge and best practice sharing. In the Spotify model, this is resolved with a matrix organization, in which individuals belong to one team (so-called <em class="italic">squads</em> and <em class="italic">tribes</em>) with product-delivery purposes but share interests with people of the same skills (such as DBAs or frontend developers) for knowledge sharing and personal growth purposes (in the so-called <em class="italic">chapters</em> and <em class="italic">guilds</em>).</p>
			<p>The Spotify model suggests a number of other mechanisms for boosting collaboration. It's an interesting point of view and gives some practical advice. However, considering that every organization is different, and has different challenges and strengths, so the first piece of advice is flexibility. No model will simply work out of the box; you have to look at the company's objectives and people skills and keep adapting to changing conditions. </p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor136"/>Pros and cons of DevOps</h2>
			<p>We anticipated some impacts of DevOps, both in positive and negative ways, in the previous sections. However, to summarize, here are some advantages<a id="_idIndexMarker561"/> of adopting a DevOps model:</p>
			<ul>
				<li>It's a high-performance methodology, meaning that, when working properly, it enables us to deliver high-quality software frequently. Hence, it's rapidly responding to changing conditions, such as new requirements or production issues.</li>
				<li>It copes well (and often is seen as a requirement) with modern architectures, such as cloud-based and microservices applications.</li>
				<li>It's challenging and <a id="_idIndexMarker562"/>rewarding for team members, meaning that there is a lot of room for learning, as each team member can easily enrich his/her skills and responsibilities.</li>
			</ul>
			<p>The disadvantages<a id="_idIndexMarker563"/> can be summarized as follows:</p>
			<ul>
				<li>It's a huge paradigm shift and can be hard to accept for more traditional organizations, as it requires many people to get out of their comfort zone and start thinking about their role in a different way (stretching everybody's responsibilities).</li>
				<li>It may be difficult to map from an organizational point of view, as it will require breaking the traditional silos and setting up cross-department, product-oriented teams.</li>
				<li>It requires highly skilled and motivated team members. It may be stressful in the long term.</li>
			</ul>
			<p>With this section, we have completed our overview of DevOps.</p>
			<p>We have seen what the founding principles of such a methodology are and why it claims to boost efficiency, along with some of the variants, such as DevSecOps. </p>
			<p>In the next section, we will have a look at some examples and case studies.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor137"/>Case studies and examples</h1>
			<p>In this section, we will <a id="_idIndexMarker564"/>model an ideal Product Backlog in the Scrum way, applied to our mobile payments example.</p>
			<p>The official Scrum guide does not provide any example of a Product Backlog, and there are no standards as regards the fields that should be included. Based on my personal experience, a Product Backlog should look like this:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/Figure_5.05_B16354.jpg" alt="Figure 5.5 – Mobile payments Product Backlog&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – Mobile payments Product Backlog</p>
			<p>This is, of course, just a small subset, but several considerations can be made:</p>
			<ul>
				<li><strong class="bold">Items are identified by ID and DESCRIPTION</strong>: Most likely, <strong class="bold">ID</strong> will link to a detailed requirements document or at least a more detailed description. Also, every item is likely categorized as part of a bigger user <strong class="bold">STORY</strong>. As discussed previously, User Story Mapping is a different way to visualize this kind of relationship.</li>
				<li><strong class="bold">Items are categorized</strong>: Usually, at least features and fixes are categorized, while more types, such as <a id="_idIndexMarker565"/>enhancements and technical terms (for things such as refactoring and other internal tasks), may be used.</li>
				<li><strong class="bold">Dependencies</strong>: This is a way to help choose items through the links to other items.</li>
				<li><strong class="bold">Effort</strong>: This is something that may be roughly evaluated when adding items to the backlog. However, this is likely to change over time when more details will be known.</li>
			</ul>
			<p>You can see some similarities with the requirements template seen in <a href="B16354_02_Final_JM_ePUB.xhtml#_idTextAnchor034"><em class="italic">Chapter 2</em></a>, <em class="italic">Software Requirements – Collecting, Documenting, Managing</em>, and indeed the goals are similar. However, a different level of detail is evident, as those two artifacts have different goals in the project cycle.</p>
			<p>With this simple example, we have covered all the topics relevant to this chapter. </p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor138"/>Summary</h1>
			<p>In this chapter, we have seen a complete overview of the development models. Starting with the more traditional approaches, such as Code and Fix and Waterfall, we then moved to the core of the chapter, focusing on Agile.</p>
			<p>As we have seen, Agile is a broad term, including more structured frameworks (such as Scrum) and other tools and best practices (such as Lean and some other techniques, such as Kanban), which can be mixed and matched to better suit the needs of other projects. As a last big topic, we discussed DevOps (and some extensions of it). While not being a well-codified practice, the huge potential of this approach is clear, which is now seeing widespread adoption in many innovative projects. DevOps, indeed, is the prerequisite for some advanced architectures that we will see in the forthcoming chapters, such as microservices.</p>
			<p>In the next chapter, we will focus on Java architectural patterns. We will cover some essential topics, including multi-tier architectures, encapsulation, and practical tips regarding performance and scalability. </p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor139"/>Further reading</h1>
			<ul>
				<li><em class="italic">The pros and cons of Waterfall Software Development</em> (<a href="https://www.dcsl.com/pros-cons-waterfall-software-development/">https://www.dcsl.com/pros-cons-waterfall-software-development/</a>), DCSL GuideSmiths</li>
				<li><em class="italic">The Waterfall Model: Advantages, disadvantages, and when you should use it</em> (<a href="https://developer.ibm.com/articles/waterfall-model-advantages-disadvantages/">https://developer.ibm.com/articles/waterfall-model-advantages-disadvantages/</a>), by Aiden Gallagher, Jack Dunleavy, and Peter Reeves</li>
				<li><em class="italic">The Waterfall model: Advantages and disadvantages</em> (<a href="https://www.blocshop.io/blog/waterfall-advantages-disadvantages/">https://www.blocshop.io/blog/waterfall-advantages-disadvantages/</a>), Blocshop</li>
				<li>The Agile Manifesto (<a href="https://agilemanifesto.org">https://agilemanifesto.org</a>), by Kent Beck, Mike Beedle, Arie van Bennekum, Alistair Cockburn, Ward Cunningham, Martin Fowler, James Grenning, Jim Highsmith, Andrew Hunt, Ron Jeffries, Jon Kern, Brian Marick, Robert C. Martin, Steve Mellor, Ken Schwaber, Jeff Sutherland, and Dave Thomas</li>
				<li><em class="italic">Lean Software Development: An Agile Toolkit</em>, <em class="italic">Mary Poppendieck and Tom Poppendieck</em>, <em class="italic">Pearson Education</em> (2003)</li>
				<li><em class="italic">Implementing Lean Software Development: From Concept to Cash</em>, <em class="italic">Mary and Tom Poppendieck</em>, <em class="italic">Pearson Education</em> (2006)</li>
				<li><em class="italic">Lean Software Development in Action</em>, <em class="italic">Andrea Janes and Giancarlo Succi</em>, <em class="italic">Springer Berlin Heidelberg</em> (2014)</li>
				<li><em class="italic">Agile Metrics in Action: How to measure and improve team performance</em>, <em class="italic">Christopher Davis</em>, <em class="italic">Manning Publications</em> (2015)</li>
				<li><em class="italic">The Surprising Power of Online Experiments</em> (<a href="https://hbr.org/2017/09/the-surprising-power-of-online-experiments">https://hbr.org/2017/09/the-surprising-power-of-online-experiments</a>), by Ron Kohavi and Stefan Thomke</li>
				<li><em class="italic">The Art of Lean Software Development</em>, <em class="italic">Curt Hibbs, Steve Jewett, and Mike Sullivan</em>, <em class="italic">O'Reilly Media</em> (2009).</li>
				<li>The Scrum guide (<a href="https://www.scrumguides.org">https://www.scrumguides.org</a>), by Jeff Sutherland and Ken Schwaber</li>
				<li><em class="italic">Scrum: The Art of Doing Twice the Work in Half the Time</em>, <em class="italic">Jeff Sutherland</em>, <em class="italic">Random House</em> (2014)</li>
				<li><em class="italic">9 retrospective techniques that won't bore your team to death</em> (<a href="https://www.atlassian.com/blog/teamwork/revitalize-retrospectives-fresh-techniques">https://www.atlassian.com/blog/teamwork/revitalize-retrospectives-fresh-techniques</a>), by Sarah Goff-Dupont</li>
				<li><em class="italic">6 Effective Sprint Retrospective Techniques</em> (<a href="https://www.parabol.co/resources/agile-sprint-retrospective-ideas">https://www.parabol.co/resources/agile-sprint-retrospective-ideas</a>), Parabol</li>
				<li><em class="italic">DevOpsCulture</em> (<a href="https://martinfowler.com/bliki/DevOpsCulture.html">https://martinfowler.com/bliki/DevOpsCulture.html</a>), by Rouan Wilsenach</li>
				<li><em class="italic">Scaling Agile @ Spotify with Tribes, Squads, Chapters &amp; Guilds</em> (<a href="https://blog.crisp.se/wp-content/uploads/2012/11/SpotifyScaling.pdf">https://blog.crisp.se/wp-content/uploads/2012/11/SpotifyScaling.pdf</a>), by Henrik Kniberg and Anders Ivarsson</li>
				<li><em class="italic">Create Your Successful Agile Project: Collaborate, Measure, Estimate, Deliver</em>, <em class="italic">Johanna Rothman</em>, <em class="italic">Pragmatic Bookshelf</em> (2017)</li>
				<li><em class="italic">Operations Anti-Patterns, DevOps Solutions</em>, <em class="italic">Jeffery D. Smith</em>, <em class="italic">Manning Publications</em> (2020)</li>
			</ul>
		</div>
	</body></html>