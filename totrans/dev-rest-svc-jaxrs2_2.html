<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;WebSockets and Server-sent Events"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. WebSockets and Server-sent Events</h1></div></div></div><p>With the advancements in web architecture and emerging platforms, which can provide real-time or near real-time information, the necessity of having an effective way of communicating these updates to clients caused the urge of introducing new programming models and new standards that make use of this real-time information easier for the consumer side of the system, also known as clients (mostly web browsers).</p><p>In this chapter we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The programming models and solutions that can be used to address near real-time update transfer to clients</li><li class="listitem" style="list-style-type: disc">Using Server-sent Events (SSE)</li><li class="listitem" style="list-style-type: disc">Using WebSockets</li></ul></div><p>Different snippets are included in this chapter but complete samples which shows these snippet in actions are included as part of the book's source code download bundle.</p><div class="section" title="The programming models"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>The programming models</h1></div></div></div><p>In this section we will <a id="id123" class="indexterm"/>cover the different programming models that emerged to address the near real-time updating of the client view based on the updates that are produced by the server.</p><div class="section" title="Polling"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Polling</h2></div></div></div><p>As mentioned before, <a id="id124" class="indexterm"/>HTTP, which is the<a id="id125" class="indexterm"/> foundation of<a id="id126" class="indexterm"/> communication over the Internet, uses a simple request/response model in which a request either timeouts or get a response back from the server. The response can be the actual response the request was intended for or it can be an error message, underneath one of the standard error status codes. The client always initiates the communication; the server cannot initiate a communication channel without receiving a request from a client to send back a response.</p><p>So, basically, to update the client it is required to check for the new updates on the server and if an update is available the client can react to the update and, for example, change a text to denote that a book that was not available is available for borrowing now or a show a new image, or to perform any other action that maps to the response received from the server.</p><p>Sending periodical <a id="id127" class="indexterm"/>requests to a server to check for updates is called <span class="strong"><strong>polling</strong></span>. It does not scale to<a id="id128" class="indexterm"/> hundreds of thousands of clients and thus it cannot be an effective programming model to handle the massive client numbers of today's applications. In the polling model the response does not necessarily includes updates generated in the server but rather it may just be a <code class="literal">200 OK</code> response without any particular updates for the client to use. In this model, tens of requests may receive nothing but <code class="literal">200 OK</code> without any meaningful update for the client, which means these tens wasted the resources in vain. Of course, this model is useful if the number of clients is limited and if severe compatibility issues exist that prevent the clients to update to newer versions, for example, very old browsers. The following diagram shows the polling model:</p><div class="mediaobject"><img src="graphics/8125ENT_02_01.jpg" alt="Polling"/></div><p>The polling-based model is enriched with JavaScript in the client side; the browsers, to update the view without changing the page and thus list available books in a library application, can change without the user refreshing the page. The following code snippet shows the server side of a polling pair written in Java:</p><div class="informalexample"><pre class="programlisting">public class PollingServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.setContentType("text/plain");
        response.setCharacterEncoding("UTF-8");
        response.getWriter().write((new Date()).toString());
    }
}</pre></div><p>The preceding sample does not use<a id="id129" class="indexterm"/> JSON for data format or any of the new Async functionalities introduced in Java EE 7 and Servlet 3.1 which are discussed in <a class="link" href="ch03.html" title="Chapter 3. Understanding WebSockets and Server-sent Events in Detail">Chapter 3</a>, <span class="emphasis"><em>Understanding WebSockets and Server-sent Events in Detail</em></span> and <a class="link" href="ch04.html" title="Chapter 4. JSON and Asynchronous Processing">Chapter 4</a>, <span class="emphasis"><em>JSON and Asynchronous Processing</em></span>, but rather shows how the basics work. The Servlet writes the current date on the response for any <code class="literal">GET</code> request. The servlet is mapped to <code class="literal">PollingServlet</code> path in the <code class="literal">web.xml</code> file.</p><p>The following <a id="id130" class="indexterm"/>code snippet shows how we can use JavaScript to perform a request in the background, get the response, and update content of a <code class="literal">div</code> element of the HTML page by manipulating the equivalent DOM tree element.</p><div class="informalexample"><pre class="programlisting"> &lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Ajax Continues Polling&lt;/title&gt;        
      &lt;script&gt;
        function startUpdating() {
          req = new XMLHttpRequest();
          req.onreadystatechange = function() {updateDiv();};
          req.open("GET", "/PollingServlet", true);
          req.send(null);  
          results = req.responseText;
        }

        function updateDiv(){
          results = req.responseText;
          document.getElementById("dateDiv").innerHTML = results;
          setTimeout("startUpdating()", 5000);
        }
      &lt;/script&gt;
  &lt;/head&gt;
  &lt;body onload="startUpdating()"&gt;
    &lt;p&gt;polling the time from server:&lt;/p&gt;
    &lt;div id="dateDiv"&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>The HTML page in the preceding snippet is the simplest possible form; it does not check whether the response for each request is <code class="literal">OK</code> neither does it check whether the code is being executed in IE or a non-IE browser for the sake of simplicity.</p><p>Now, the <code class="literal">startUpdating</code> function<a id="id131" class="indexterm"/> is invoked when the page is loaded, the function sends a request to the Servlet shown before and invokes the <code class="literal">updateDiv</code> function <a id="id132" class="indexterm"/>to update the GUI and then schedule another invocation of it after 5 seconds.</p><p>The limitations of the <a id="id133" class="indexterm"/>polling model can be summarized as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It is the client that performs polling and there is no service pushing involved</li><li class="listitem" style="list-style-type: disc">It is resource-consuming as many requests will result in a response that does not have any effective update for the client</li><li class="listitem" style="list-style-type: disc">Long intervals between requests may yield an outdated client view while short intervals overload the servers</li></ul></div></div><div class="section" title="Long polling"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Long polling</h2></div></div></div><p>With the<a id="id134" class="indexterm"/> limitation of the <a id="id135" class="indexterm"/>polling model in mind, a new programming model emerged in which a request either timeouts or carries back useful updates to the client. In this model a request is sent to the server and the request is set to a timeout after a very long time so that the cost of handshake and request initiation reduces as much as possible by a reduction in the number of requests and responses in a fixed period of time. A response is only sent back if there are some updates in the server, which the client should receive. When such an update becomes available in the server, the server sends back the response with the update and client initiates another request after consuming the update it received. The benefit of this model is fewer numbers of requests compared to polling, which reduces the resource consumption and increases the scalability. The following diagram shows the <span class="strong"><strong>long polling</strong></span> model.</p><div class="mediaobject"><img src="graphics/8125ENT_02_02.jpg" alt="Long polling"/></div><div class="section" title="Long polling clients and XMLHttpRequest"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl4sec04"/>Long polling clients and XMLHttpRequest</h3></div></div></div><p>The <code class="literal">XMLHttpRequest</code> object<a id="id136" class="indexterm"/> is available as part of the <a id="id137" class="indexterm"/>JavaScript in-browser API to<a id="id138" class="indexterm"/> facilitate the interaction of the JavaScript part of a web page with the web server. It can be used to send a request to the server and receive the response without refreshing the page after the page is loaded; for example, to update the list of available books after the <code class="literal">available.html</code> page is loaded.</p><p>The functionality of the <code class="literal">XMLHttpRequest</code> object is categorized in events, methods, and properties. The important properties, events, and important methods are discussed shortly.</p><p>The values of properties change when an event is fired and when methods are invocated. Checking the property values makes it possible to evaluate the current state of the <code class="literal">XMLHttpRequest</code> object or to handle the response.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">readyState</code>: Stores the current state of the ongoing request. The table after the list shows different values of the <code class="literal">readyState</code> attribute.</li><li class="listitem" style="list-style-type: disc"><code class="literal">responseText</code>: Returns the response text.</li><li class="listitem" style="list-style-type: disc"><code class="literal">responseXML</code>: Returns a DOM object representing the response data. The assumption is that the response text is a valid XML document. The XML document can be traversed using standard DOM parser methods.</li><li class="listitem" style="list-style-type: disc"><code class="literal">status</code>: Shows the status code of the request; for example, <code class="literal">200</code>, <code class="literal">404</code>, and so on.</li><li class="listitem" style="list-style-type: disc"><code class="literal">statusText</code>: Human readable text equivalent of request status code. For example <code class="literal">"OK"</code>, <code class="literal">"Not Found"</code>, and so on.</li></ul></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>The readyState value and textual equivalent</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">0</code> (<code class="literal">UNINITIALIZED</code>)</p>
</td><td style="text-align: left" valign="top">
<p>The <code class="literal">XMLHttpRequest</code> object is created, but not opened.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">1</code> (<code class="literal">LOADING</code>)</p>
</td><td style="text-align: left" valign="top">
<p>The <code class="literal">XMLHttpRequest</code> object is created, the open method is called but no request is sent. </p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">2</code> (<code class="literal">LOADED</code>)</p>
</td><td style="text-align: left" valign="top">
<p>The send method is called, no response yet.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">3</code> (<code class="literal">INTERACTIVE</code>)</p>
</td><td style="text-align: left" valign="top">
<p>The send method is called, some data was received but the response is not concluded yet.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">4</code> (<code class="literal">COMPLETED</code>)</p>
</td><td style="text-align: left" valign="top">
<p>Response is concluded and the entire message is received. Message content is available in the <code class="literal">responseBody</code> and <code class="literal">responseText</code> properties.</p>
</td></tr></tbody></table></div><p>Each event can <a id="id139" class="indexterm"/>have an associated method, which is <a id="id140" class="indexterm"/>invoked when the event is fired. The sample code afterward shows how these events can be used.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">onreadystatechange</code>: This event is fired when the state of a request initiated by this <code class="literal">XMLHttpRequest</code> instance is changed. The state change is communicated via the <code class="literal">readyState</code> property.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ontimeout</code>: This event is fired when a request initiated with this <code class="literal">XMLHttpRequest</code> instance is timed out.</li></ul></div><p>After invocation of each method the value of the relevant properties will change.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">abort</code>: This aborts the current request of the <code class="literal">XMLHttpRequest</code> instance. The <code class="literal">readyState</code> value is set to <code class="literal">0</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">open</code>: This prepares a request by setting the method, URL and security credentials.</li><li class="listitem" style="list-style-type: disc"><code class="literal">send</code>: This sends the request that is prepared by the <code class="literal">open</code> method.</li></ul></div></div><div class="section" title="Chunked transfer encoding"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec12"/>Chunked transfer encoding</h3></div></div></div><p>Another <a id="id141" class="indexterm"/>possible <a id="id142" class="indexterm"/>way of using the long polling model is to use the message body streaming to send chunks of data and update events, when those chunks are available in the server and ready to be consumed by the developer. In the message body streaming model the server does not close the response but rather keeps it open and sends the update events to client as they are produced in the server. The message body streaming involves using the chunked transfer encoding which is a <code class="literal">HTTP/1.1</code> feature.</p><p>The <a id="id143" class="indexterm"/>chunked transfer encoding can be used to send many chunks of <a id="id144" class="indexterm"/>data as part of the response body, which is opened as a stream. The chunks can be JavaScript tags which are loaded in the hidden <code class="literal">iframe</code> and executed in the order of arrival. The execution of arriving scripts can cause the view to update or to trigger any other action that is required. The following diagram shows the long polling in action.</p><div class="mediaobject"><img src="graphics/8125ENT_02_03.jpg" alt="Chunked transfer encoding"/></div><p>In the preceding diagram the client sent a request along with the <code class="literal">client_id</code> value to the server and the server started sending chunks of responses when some updates are available to be sent to the client. The updates are sent as JavaScript tags which are then executed in the client's browser to update the GUI.</p><p>The limitations of the long polling<a id="id145" class="indexterm"/> model can be summarized as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One-way communication</li><li class="listitem" style="list-style-type: disc">No standard data format or message format when used in chunked transfer encoding mode</li><li class="listitem" style="list-style-type: disc">One response per request when no <code class="literal">iframe</code> technique is used</li><li class="listitem" style="list-style-type: disc">Each connection initiation has an initiation cost</li><li class="listitem" style="list-style-type: disc">No caching between the clients and server, which impacts server performance<a id="id146" class="indexterm"/> instead of reading content from the cache</li></ul></div></div></div></div></div>
<div class="section" title="Emerging standards"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Emerging standards</h1></div></div></div><p>With the emergence of requirements and solutions for those requirements, standards emerged to ensure compatibility between different the layers, applications, and components that form a solution; asynchronous communication, and especially event propagation between clients and servers, is one.</p><div class="section" title="Server-sent Events"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Server-sent Events</h2></div></div></div><p>
<span class="strong"><strong>Server-sent Events</strong></span> (<span class="strong"><strong>SSE</strong></span>), or sometimes simply referred to as <span class="strong"><strong>EventSource</strong></span>
<a id="id147" class="indexterm"/>, is an HTML5 browser API that makes event pushing between server and client <a id="id148" class="indexterm"/>available to web application developers. The SSE component provides a structured mechanism for having a capability similar to long polling without some of the long polling drawbacks. As it is an HTML5 component, the browser should support HTML5 SSE to be able to take advantage of this API.</p><p>The SSE kernel includes <code class="literal">EventSource</code> and <code class="literal">Event</code>.</p><p>
<code class="literal">EventSource</code> is the API that provides the client with the means of subscribing to an event source, which can be a Servlet or anything of that sort. After subscription, which is nothing more than opening the connection to the URL, events are sent to the client in the order that they are produced and in the client the event listener can react to the events, for example by updating a chat window, changing a graph, or updating the list of available books to borrow or list people that are interested in the subject that the event URL is meant for.</p><div class="section" title="The SSE anatomy"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec13"/>The SSE anatomy</h3></div></div></div><p>Before we go deep into <a id="id149" class="indexterm"/>the API <a id="id150" class="indexterm"/>and see how the API works, it is good to look more closely at the characteristics of SSE and how SSE works. The following diagram shows SSE in action, which closely resembles the chunked encoding diagram shown in the preceding section. The question may a rise: what makes SSE better than long polling if both of them work similarly when it comes to request, response, and message content?</p><div class="mediaobject"><img src="graphics/8125ENT_02_04.jpg" alt="The SSE anatomy"/></div><p>With SSE the <a id="id151" class="indexterm"/>events are plain text messages sent from the server to the clients after the client opens the initial <a id="id152" class="indexterm"/>request meaning that it does not require to be a collection of JavaScript tags that need to be executed in the client side to update something but rather it can be data that can be consumed in the client side by the event listener and event listener can interpret and react to the received event.</p><p>The second difference is the message format; SSE defines a message format for the events that are sent from the server to the clients. The message format is composed of a plain text line-separated stream of characters. Lines that carry the message body or data start with <code class="literal">data:</code> and lines that carry some <span class="strong"><strong>Quality of Service</strong></span> (<span class="strong"><strong>QoS</strong></span>)<a id="id153" class="indexterm"/> directives start with the QoS attribute name followed by a colon and then the QoS attribute's value, <code class="literal">directive: value</code>. The standard format makes it possible to develop generic libraries around SSE to make software development easier. The following snippet shows a sample message that can indicate a new dot in a graph. When the client receives the message it can draw the new dot on the graph to show a change in the data the graph is being constructed from. The following sample data shows a multiline message in which each line is separated from the next using <code class="literal">\n</code> and end of message is marked with <code class="literal">\n\n</code>.</p><div class="informalexample"><pre class="programlisting">data: Position: 75,55\n\n
data: Label: Large increase\n\n
data: Color: red\n\n</pre></div><p>It is possible to develop the server component of a SSE solution using a servlet and the client side can be developed using either JavaScript or Java API. The Java API to consume SSE events is part of the Java EE 7 provided by means of JAX-RS 2.0. The next two sections go into details of the client side API and also the server side component of the solution, which is a servlet.</p><p>As mentioned earlier, in addition to the actual message or message body each SSE message can carry some directive, which instructs the browser or SSE-compatible client on some of the QoS attributes of the interaction. Some of these QoS directives are discussed next.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>The reference implementation of JAX-RS 2.0 is done under the Jersey 2.0 project. The Jersey project is located at <a class="ulink" href="http://jersey.java.net/ ">http://jersey.java.net/ </a>with extensive documentation.</p></div></div></div></div><div class="section" title="Associating an ID with an event"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Associating an ID with an event</h2></div></div></div><p>Each SSE message can have<a id="id154" class="indexterm"/> a message identifier, which <a id="id155" class="indexterm"/>can<a id="id156" class="indexterm"/> be used for a variety of purposes; one use of the message ID standard usage is to keep track of the messages that the client has received. When a message ID is used in SSE, the client can supply the last message ID as one of the connection parameters to instruct the server to resume form and specific message onward. Of course the server should implement proper the procedure for resuming a communication from where a client requests it. </p><p>An example message format with message ID can be as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">id: 123 \n
data: single line data \n\n</pre></div><div class="section" title="Connection loss and reconnecting retries"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec14"/>Connection loss and reconnecting retries</h3></div></div></div><p>Browsers that support SSE, which are listed early in this section, can try reconnecting to the server in case the connection between browser and server is severed. The default retry interval is <code class="literal">3000</code> milliseconds but it can be adjusted by including the <code class="literal">retry</code> directive<a id="id157" class="indexterm"/> in the messages that the server sends to the client. For example, to increase the retry interval to <code class="literal">5000</code> milliseconds the SSE message that the server sends can be similar to the following code snippet:</p><div class="informalexample"><pre class="programlisting">retry: 5000\n
data: This is a single line data\n\n</pre></div></div><div class="section" title="Associating event names with events"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec15"/>Associating event names with events</h3></div></div></div><p>Another SSE directive<a id="id158" class="indexterm"/> is the event name. Each event source can <a id="id159" class="indexterm"/>generate more than one type of event and the client can decide how to consume each event type based on what event type it subscribes to. The following snippet shows how event name directives incorporate into the message:</p><div class="informalexample"><pre class="programlisting">event: bookavailable\n
data: {"name" : "Developing RESTful Services with JAX-RS 2.0, WebSockets and JSON"}\n\n
event: newbookadded\n
data: {"name" :"Netbeans IDE7 Cookbook"}\n\n</pre></div></div><div class="section" title="Server-sent Events and JavaScript"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec16"/>Server-sent Events and JavaScript</h3></div></div></div><p>The major SSE API that is<a id="id160" class="indexterm"/> considered the foundation of SSE in the client side <a id="id161" class="indexterm"/>for JavaScript developers is the <code class="literal">EventSource</code> interface. The <code class="literal">EventSource</code> interface contains a fair number of functions and attributes but the most important ones are listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The addEventListener function</strong></span>: To add an<a id="id162" class="indexterm"/> event listener to handle <a id="id163" class="indexterm"/>the incoming events based on event type.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The removeEventListener event function</strong></span>: To <a id="id164" class="indexterm"/>remove an already <a id="id165" class="indexterm"/>registered listener.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The onmessage event function</strong></span>: It is<a id="id166" class="indexterm"/> invoked on message arrival. There<a id="id167" class="indexterm"/> is no custom event handling available when using the <code class="literal">onmessage</code> method. Listeners manage the custom event handling. </li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The onerror event function</strong></span>: It is <a id="id168" class="indexterm"/>invoked when something goes wrong with the <a id="id169" class="indexterm"/>connection.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The onopen event function</strong></span>: It is<a id="id170" class="indexterm"/> invoked when a<a id="id171" class="indexterm"/> connection is opened.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The close function</strong></span>: It is<a id="id172" class="indexterm"/> invoked when a connection is<a id="id173" class="indexterm"/> closed.</li></ul></div><p>The following snippet shows how to subscribe for different event types omitted by one source.  The snippet assumes that the incoming messages are JSON-formatted messages.  The <code class="literal">'bookavailable' </code>listener uses a simple JSON parser to parse the incoming JSON and then will use that to update the GUI while the <code class="literal">'newbookadded'</code> listener uses the reviver function to filter out and selectively process the JSON pairs.</p><div class="informalexample"><pre class="programlisting">var source = new EventSource('books');
source.addEventListener('bookavailable', function(e) {
  var data = JSON.parse(e.data);
  // use data to update some GUI element...
}, false);

source.addEventListener('newbookadded', function(e) {
  var data = JSON.parse(e.data, function (key, value) {
    var type;
    if (value &amp;&amp; typeof value === 'string') {
return "String value is: "+value;
    }
    return value;
});
}, false);</pre></div><p>Before we move to <a id="id174" class="indexterm"/>WebSockets as another emerging technology let's take a look <a id="id175" class="indexterm"/>at the following paired server and client, which are written as a Java EE Servlet and JavaScript to see how SSE works:</p><p>Servlet's <code class="literal">processRequest</code> function<a id="id176" class="indexterm"/> look like the following snippet:</p><div class="informalexample"><pre class="programlisting">  protected void processRequest(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {        
                   response.setContentType("text/event-stream");
                   response.setCharacterEncoding("utf-8");

        PrintWriter out = response.getWriter();
        while(true){                
                Date serverDate = new Date();
                out.write( "event:server-time\n");
                out.write( "data:&lt;b&gt;Current Server Time is:" + serverDate.toString() +"&lt;/b&gt;\n\n");
                out.flush();                
                try {
                        Thread.sleep(1000);
                } catch (InterruptedException e) {
                        e.printStackTrace();
                }   
        }                
    }</pre></div><p>The preceding Servlet writes out the current date every one second and, if the browser hits the Servlet's URL, the output should be similar to the following figure.</p><div class="mediaobject"><img src="graphics/8125ENT_02_05.png.jpg" alt="Server-sent Events and JavaScript"/></div><p>And the <a id="id177" class="indexterm"/>JSP page in<a id="id178" class="indexterm"/> the same web application look like the following:</p><div class="informalexample"><pre class="programlisting">&lt;%@page contentType="text/html" pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;JSP Page With SSE EventSource&lt;/title&gt;
      &lt;script type="text/JavaScript"&gt;
        function startSSEConnection(){
        var source = new EventSource('SimpleDateServlet');
        source.addEventListener("server-time", function(event){
         document.getElementById("server-time").innerHTML=event.data;
         },false);
       }

      &lt;/script&gt;
 
      &lt;/script&gt;
    &lt;/head&gt;
    &lt;body onload="startSSEConnection();"&gt;
      &lt;div id="server-time"&gt;[Server-Time]&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></div><p>Checking the JSP page's URL will show an output similar to the following screenshot. As you can see, the Servlet's output messages are shown with formatting as it is specified in the JavaScript code in the JSP page:</p><div class="mediaobject"><img src="graphics/8125ENT_02_06.png.jpg" alt="Server-sent Events and JavaScript"/></div><p>More complete and advanced examples are included in <a class="link" href="ch03.html" title="Chapter 3. Understanding WebSockets and Server-sent Events in Detail">Chapter 3</a>, <span class="emphasis"><em>Understanding WebSockets and Server-sent Events in Detail</em></span> and <a class="link" href="ch05.html" title="Chapter 5. RESTful Web Services by Example">Chapter 5</a>, <span class="emphasis"><em>RESTful Web Services by Example</em></span>. The complete code for the preceding example is included in the book's code bundle.</p></div></div><div class="section" title="WebSockets"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>WebSockets</h2></div></div></div><p>The <a id="id179" class="indexterm"/>WebSockets<a id="id180" class="indexterm"/> component of HTML5 adds a brand new method for interaction between clients and servers to address the scalability and flexibility required for modern web-scale applications by introducing a full duplex event-based communication channel between clients and servers. After being initiated by the client, the server can send binary and textual data concerning the client over the channel and the client can, without reinitiating a connection, send messages to the server. The event source and event subscription model discussed in the <span class="emphasis"><em>Server-sent Events</em></span> section is available in WebSockets as well.</p><div class="section" title="WebSocket handshake"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec17"/>WebSocket handshake</h3></div></div></div><p>There is an optional handshake <a id="id181" class="indexterm"/>request-response devised to let the applications switch to WebSockets when required. In a sample scenario shown below, the client requests the protocol upgrade to WebSockets by sending the upgrade request header to the server. If the server supports the upgrade the response will include the protocol upgrade as shown afterward.</p><p>The client request to upgrade to WebSockets looks as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">GET /demo HTTP/1.1
Host: mybookstoresample.com
Connection: Upgrade
Upgrade: WebSocket
Origin: http://mybookstoresample.com</pre></div><p>And the server response handshake can look as shown in the following snippet:</p><div class="informalexample"><pre class="programlisting">        HTTP/1.1 101 WebSocket Protocol Handshake
        Upgrade: WebSocket
        Connection: Upgrade</pre></div><a id="id182" class="indexterm"/><p>After the handshake is completed the communication between the client and server occurs over a bidirectional socket. The WebSockets wire level communication protocol is different than HTTP wire protocol and because of that it is possible that intermediate servers like proxy servers or cache servers are not capable or intercepting and processing the WebSockets messages as they do with HTTP messages.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>In <a class="link" href="ch03.html" title="Chapter 3. Understanding WebSockets and Server-sent Events in Detail">Chapter 3</a>, <span class="emphasis"><em>Understanding WebSockets and Server-sent Events in Detail</em></span> in the WebSockets section you can learn more details on the WebSockets client and server implementation along with details on protocol upgrade. <a class="link" href="ch05.html" title="Chapter 5. RESTful Web Services by Example">Chapter 5</a>, <span class="emphasis"><em>RESTful Web Services by Example</em></span>, includes complete sample applications that further dive into using WebSockets.</p></div></div></div><div class="section" title="Browser and JavaScript support for WebSockets"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec18"/>Browser and JavaScript support for WebSockets</h3></div></div></div><p>New versions of major web <a id="id183" class="indexterm"/>browsers support <a id="id184" class="indexterm"/>WebSockets and using WebSockets in the client side just involves creating a WebSockets object and then setting different listeners and event handlers for different events. The following list shows the important functions and attributes of the <code class="literal">WebSocket</code> class:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The constructor</strong></span>: To<a id="id185" class="indexterm"/> initialize the <code class="literal">WebSocket</code> object, the resource URL is enough to be passed to the <code class="literal">WebSocket</code> constructor<a id="id186" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The send function</strong></span>: The<a id="id187" class="indexterm"/> <code class="literal">send</code> function <a id="id188" class="indexterm"/>can be used to send a message to the server's specified URL during the object construction.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The onopen event function</strong></span>: This<a id="id189" class="indexterm"/> function is invoked when the connection is <a id="id190" class="indexterm"/>created. The <code class="literal">onopen</code> handles the <code class="literal">open</code> event type.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The onclose event function</strong></span>: The <a id="id191" class="indexterm"/>function is invoked when the connection is <a id="id192" class="indexterm"/>being closed. The <code class="literal">onclose</code> handles the <code class="literal">close</code> event type.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The onmessage event function</strong></span>: When a<a id="id193" class="indexterm"/> new message arrives, the <code class="literal">onmessage</code> function <a id="id194" class="indexterm"/>is invoked to handle the <code class="literal">message</code> event.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The onerror event function</strong></span>: The <a id="id195" class="indexterm"/>function is invoked to handle the <code class="literal">error</code> event when an <a id="id196" class="indexterm"/>error in the communication channel occurs.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The close function</strong></span>: To<a id="id197" class="indexterm"/> close the communication socket and end the interaction <a id="id198" class="indexterm"/>between the client and the server.</li></ul></div><p>A very basic<a id="id199" class="indexterm"/> example of using the JavaScript WebSocket API is <a id="id200" class="indexterm"/>shown below:</p><div class="informalexample"><pre class="programlisting">//Constructionof the WebSocket object
var websocket = new WebSocket("books"); 
//Setting the message event Function
websocket.onmessage = function(evt) { onMessageFunc(evt) };
//onMessageFunc which when a message arrives is invoked.
function onMessageFunc (evt) { 
//Perform some GUI update depending the message content
}
//Sending a message to the server
websocket.send("books.selected.id=1020"); 
//Setting an event listener for the event type "open".
addEventListener('open', function(e){
        onOpenFunc(evt)});

//Close the connection.
websocket.close();</pre></div><p>An example server-side component, a WebSockets endpoint, is shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">@ServerEndpoint(
decoders = BookDecoder.class,
encoders = BookEncoder.class,
path = "/books/")
public class BooksWebSocketsEndpoint {
@OnOpen
public void onOpen(Session session) {
            }

@OnMessage
public void bookReturned(Library.Book book, Session session) {
            }

@OnClose
public void onClose(Session session){
sessionToId.remove(session);
}
}</pre></div><p>Details of how the implementation of a WebSockets endpoint looks is included in <a class="link" href="ch03.html" title="Chapter 3. Understanding WebSockets and Server-sent Events in Detail">Chapter 3</a>, <span class="emphasis"><em>Understanding WebSockets and Server-sent Events in Detail</em></span> and <a class="link" href="ch05.html" title="Chapter 5. RESTful Web Services by Example">Chapter 5</a>, <span class="emphasis"><em>RESTful Web Services by Example</em></span>.</p></div></div></div>
<div class="section" title="Java EE and the emerging standards"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Java EE and the emerging standards</h1></div></div></div><p>Java EE has always<a id="id201" class="indexterm"/> been an <a id="id202" class="indexterm"/>adopter of emerging standards and features and capabilities, which were required by the Java EE community. Starting from Java EE 6, Java EE spec leads focused their attention on the emerging standards and in Java EE 7 full support for HTML5, SSE and WebSockets is included in the spec; thus any Java EE application server can host a WebSockets, SSE, and HTML5-oriented application without any compatibility issue at the server side.</p><div class="section" title="Java EE and Server-sent Events"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Java EE and Server-sent Events</h2></div></div></div><p>For the SSE, which is an <a id="id203" class="indexterm"/>HTML5 browser API component, the server side can be <a id="id204" class="indexterm"/>a Servlet that produces SSE messages according to the SSE message format or it can be a SSE resource which is POJO annotated with <code class="literal">@Path</code>. In the client side, JavaScript can be used as the standard in-browser API to consume the SSE events or it can be developed using the SSE client side API introduced in Jersey 2.0 if a Java-based client is required.</p><p>The following table shows the important classes and interfaces that are entry points to SSE APIs included in Jersey 2.0:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Class</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Broadcaster</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Used for broadcasting SSE to multiple <code class="literal">EventChannel</code> instances.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">OutboundEvent</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the outgoing event class to send the Server-sent Events. An <code class="literal">OutboundEvent</code> can have id, name, date, and comment associated with it.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">EventChannel</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the outgoing event message channel. When returned from resource method, the underlying connection is kept open and the application is able to send events. One instance of this class corresponds with exactly one HTTP connection.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">EventSource</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the client for reading and processing Server-sent <code class="literal">InboundEvents</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">InboundEvent</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This represents an incoming event.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ClientFactory</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the main entry point to the client API used to bootstrap client instances. For example:</p>
<div class="informalexample"><pre class="programlisting">
<code class="literal">Client client = ClientFactory.newClient();</code>
<code class="literal">WebTarget webTarget= client.target(new URI(TARGET_URI)) ;</code>
</pre></div><p>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Client</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Client is the main entry point to the fluent API used to build and execute client requests in order to consume responses returned.</p>
<div class="informalexample"><pre class="programlisting">
<code class="literal">Client client = ClientFactory.newClient();</code>
<code class="literal">WebTarget webTarget= client.target(new URI(TARGET_URI)) ;</code>
</pre></div><p>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ResourceConfig</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This encapsulates the configuration for configuring a web application.</p>
</td></tr></tbody></table></div><p>The following table <a id="id205" class="indexterm"/>shows important annotations included in Java EE 7 and<a id="id206" class="indexterm"/> used throughout this book for developing SSE applications:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Annotation</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@Path</code>
</p>
</td><td style="text-align: left" valign="top">
<p>To annotate a <a id="id207" class="indexterm"/>POJO with the resource path it represent. For example <code class="literal">@Path("books")</code> or to annotate a sub-resource which is a method in the annotated class. For example <code class="literal">getBook</code> with related parameters for that method along with validation expression for the method parameters. For example:</p>
<p>
<code class="literal">@Path("{id: ^\d{9}[\d|X]$}")</code>
</p>
<p>
<code class="literal">getBook(@PathParam("id") String isbn10)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@Produces</code>
</p>
</td><td style="text-align: left" valign="top">
<p>To specify<a id="id208" class="indexterm"/> the type of output that the resource produces or in a narrower scope the type of output that a method in a resource produces. For example: <code class="literal">@Produces(MediaType.APPLICATION_JSON)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@Consumes</code>
</p>
</td><td style="text-align: left" valign="top">
<p>To <a id="id209" class="indexterm"/>specify the type of input that the resource consumes or in a narrower scope the type of input that a method in a resource consumes. For example: <code class="literal">@Consumes (MediaType.APPLICATION_JSON)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@GET@POST@DELETE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>To map the<a id="id210" class="indexterm"/> HTTP methods to <a id="id211" class="indexterm"/>methods in the resource<a id="id212" class="indexterm"/> representing class. For example <code class="literal">@GET</code> can be placed on the <code class="literal">getBook </code>method</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@PathParam</code>
</p>
</td><td style="text-align: left" valign="top">
<p>To specify the <a id="id213" class="indexterm"/>mapping between the query parameter's name and method. For example: <code class="literal">getBook(@PathParam("id") String isbn10)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@ApplicationPath</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Identifies the <a id="id214" class="indexterm"/>application path that serves as the base URI for all resource URIs provided by <code class="literal">@Path</code>. For example, <code class="literal">@ApplicationPath("library")</code> for the library application.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@Context</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This can be<a id="id215" class="indexterm"/> used to inject contextual objects such as <code class="literal">UriInfo</code>, which provides contextual request-specific information about the request URI. For example:</p>
<p>
<code class="literal">getBook(@Context UriInfo uriInfo)</code>
</p>
</td></tr></tbody></table></div><p>
<a class="link" href="ch03.html" title="Chapter 3. Understanding WebSockets and Server-sent Events in Detail">Chapter 3</a>, <span class="emphasis"><em>Understanding WebSockets and Server-sent Events in Detail</em></span>, is dedicated to annotations; it<a id="id216" class="indexterm"/> explains how to use these annotations and more advanced features <a id="id217" class="indexterm"/>of Server-sent Events and <a class="link" href="ch05.html" title="Chapter 5. RESTful Web Services by Example">Chapter 5</a>, <span class="emphasis"><em>RESTful Web Services by Example</em></span>, includes complete examples of how Server-sent Events and WebSockets work in real use cases.</p></div><div class="section" title="Java EE and WebSockets"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Java EE and WebSockets</h2></div></div></div><p>In Java EE 7, there is a <a id="id218" class="indexterm"/>new JSR to <a id="id219" class="indexterm"/>support WebSockets in Java EE container. JSR-356 defines the requirements and the API that a Java EE application server provides to develop WebSockets-based applications. The important annotations provided for WebSockets development are included in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Annotation</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@ClientEndpoint</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A class-level<a id="id220" class="indexterm"/> annotation that is used to denote that a POJO is a WebSocket client for instructing the server to deploy it as a managed component of that type.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@OnClose</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A method-level<a id="id221" class="indexterm"/> annotation to decorate a Java method that requires to be called when a WebSocket session is closing.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@OnError</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A method-level <a id="id222" class="indexterm"/>annotation to decorate a Java method that requires to be called in order to handle connection errors.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@OnMessage</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A <a id="id223" class="indexterm"/>method-level annotation to mark a Java method as WebSocket message receiver. </p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@OnOpen</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A method <a id="id224" class="indexterm"/>level annotation to decorate a Java method that should be called when a new WebSocket session is open.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@PathParam</code>
</p>
</td><td style="text-align: left" valign="top">
<p>To specify the <a id="id225" class="indexterm"/>mapping between the query parameter's name and method. For example:</p>
<p>
<code class="literal">getBook(@PathParam("id") String isbn10)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@ServerEndpoint</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A class-level<a id="id226" class="indexterm"/> annotation that declares the class it decorates is a WebSocket endpoint that will be deployed and made available in the URI-space of a WebSocket server. For example:</p>
<p>
<code class="literal">@ServerEndpoint("/books ");  public class Books {…}</code>
</p>
</td></tr></tbody></table></div><p>The following<a id="id227" class="indexterm"/> table <a id="id228" class="indexterm"/>shows the important classes and interfaces that are used throughout the book when WebSockets is discussed:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Class</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Encode(and subintefaces and subclasses)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Defines how to map a WebSocket message to a Java object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Decoder(and subintefaces and subclasses)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Defines how to map a Java object to a WebSocket message.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Session</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A WebSocket session represents a conversation between two WebSocket endpoints. As soon as the WebSocket handshake completes successfully, the WebSocket implementation provides the endpoint with an open WebSocket session.</p>
</td></tr></tbody></table></div></div></div>
<div class="section" title="Comparison and use cases of different programming models and standards"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Comparison and use cases of different programming models and standards</h1></div></div></div><p>The following table shows a comparison and conclusion of how the three major techniques and standards described in this chapter compare to each other:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Subject</p>
</th><th style="text-align: left" valign="bottom">
<p>SSE</p>
</th><th style="text-align: left" valign="bottom">
<p>WebSockets</p>
</th><th style="text-align: left" valign="bottom">
<p>Long polling</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Error handling</p>
</td><td style="text-align: left" valign="top">
<p>Build-in support for error <a id="id229" class="indexterm"/>handling</p>
</td><td style="text-align: left" valign="top">
<p>Build-in support for error handling</p>
</td><td style="text-align: left" valign="top">
<p>Almost no error handling in case of chunked transfer</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Performance</p>
</td><td style="text-align: left" valign="top">
<p>Usually results are better than long polling and inferior to WebSockets</p>
</td><td style="text-align: left" valign="top">
<p>Best performance result compared to the other two solutions</p>
</td><td style="text-align: left" valign="top">
<p>Small CPU resource but idle process/thread per client connection, limits scalability and extensive memory usage</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Browser support1,2 </p>
</td><td style="text-align: left" valign="top">
<p>Firefox, Chrome, Safari, Opera </p>
</td><td style="text-align: left" valign="top">
<p>For RFC 6455: IE 10, Firefox 11, Chrome 16, Safari 6, Opera 12.10</p>
</td><td style="text-align: left" valign="top">
<p>All current browsers support this</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Browser performance</p>
</td><td style="text-align: left" valign="top">
<p>Built-in support in browser, small amount of resources</p>
</td><td style="text-align: left" valign="top">
<p>Built-in support in browser, small amount of resources</p>
</td><td style="text-align: left" valign="top">
<p>Complicated to get the performance right specially with lots of JavaScripts and possible memory leaks</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Communication channel</p>
</td><td style="text-align: left" valign="top">
<p>HTTP unidirectional</p>
</td><td style="text-align: left" valign="top">
<p>WebSockets bidirectional</p>
</td><td style="text-align: left" valign="top">
<p>HTTP unidirectional</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Implementation complexity</p>
</td><td style="text-align: left" valign="top">
<p>Easy</p>
</td><td style="text-align: left" valign="top">
<p>Requires server with WebSockets support</p>
</td><td style="text-align: left" valign="top">
<p>Easiest</p>
</td></tr></tbody></table></div><p>For more details visit <a class="ulink" href="http://en.wikipedia.org/wiki/WebSocket#Browser_support">http://en.wikipedia.org/wiki/WebSocket#Browser_support</a> and <a class="ulink" href="http://en.wikipedia.org/wiki/Server-sent_events#Web_browsers">http://en.wikipedia.org/wiki/Server-sent_events#Web_browsers</a>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>Reading the <span class="emphasis"><em>Memory leak patterns in JavaScript</em></span> article available at <a class="ulink" href="http://www.ibm.com/developerworks/web/library/wa-memleak/">http://www.ibm.com/developerworks/web/library/wa-memleak/</a> is recommended to avoid JavaScript memory leaks pitfalls.</p></div></div><p>The following list shows which types of use case match with one of the programming models and standards:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Long polling: When <a id="id230" class="indexterm"/>compatibility is an issue and browsers are not up-to-date (usually for enterprise users who stick with approved versions of software for many years)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>SSE</strong></span>: When the <a id="id231" class="indexterm"/>communication is one way and server requires sending events to browser so browser can update some GUI elements. It provides error handling and structured message format advantage over long polling. Sample use cases include:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A chart that updates in real-time</li><li class="listitem" style="list-style-type: disc">A newsreader that shows the latest headlines</li><li class="listitem" style="list-style-type: disc">Stock tickers reader</li></ul></div></li><li class="listitem" style="list-style-type: disc">WebSockets: When <a id="id232" class="indexterm"/>full duplex, bi-directional communication is required between the client and the server. Some sample applications are as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A chat application</li><li class="listitem" style="list-style-type: disc">A real-time interactive multiuser charting and drawing application</li><li class="listitem" style="list-style-type: disc">Multiuser browser-based games</li></ul></div></li><li class="listitem" style="list-style-type: disc">WebSockets provide all benefits and advantages of SSE with some disadvantages that are listed as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The wire protocol is different so some intermediate servers, such as proxy servers, may not be able to intercept and interpret the messages.</li><li class="listitem" style="list-style-type: disc">If a browser does not support WebSockets there is no way to make the browser handle the communication while in the case of SSE the browser can use JavaScript libraries to handle SSE communication, polyfilling the browser. For example, <a id="id233" class="indexterm"/><span class="strong"><strong>Remy Polyfill</strong></span>.</li><li class="listitem" style="list-style-type: disc">Lack of support for event ID.</li></ul></div></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>A good write-up to further understand the Polifill<a id="id234" class="indexterm"/> can be found at <a class="ulink" href="http://remysharp.com/2010/10/08/what-is-a-polyfill/">http://remysharp.com/2010/10/08/what-is-a-polyfill/</a>.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Summary</h1></div></div></div><p>This chapter was the opening door to the whole world of asynchronous Web by introducing the fundamental concepts involving in web architecture and going forward with the evolution of the basic request response model to polling, long polling, Server-sent Event, and WebSockets.</p><p>In the next chapter WebSockets and Server-sent Events are covered in details. <a class="link" href="ch05.html" title="Chapter 5. RESTful Web Services by Example">Chapter 5</a>, <span class="emphasis"><em>RESTful Web Services by Example</em></span>, has complete sample application developed using WebSockets and Server-sent Events.</p></div></body></html>