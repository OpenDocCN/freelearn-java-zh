- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Server-Side Coding with Jakarta
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Java’s initial connection to the web was through applet development, it
    was only a few years after the language appeared that server-side Java, first
    called the **Java 2 Enterprise Edition**, or **J2EE**, and later called the **Java
    Enterprise Edition**, or **JEE**, was introduced. Unlike standalone applications
    that can run on your desktop, JEE applications run inside another family of Java
    programs called application servers. When Oracle decided to focus primarily on
    the core language, Java SE, the specifications and libraries were turned over
    to the Eclipse Foundation. These specifications and libraries were renamed **Jakarta
    EE**.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side coding in any programming language typically involves software listening
    to an internet port, such as `80`. The passing of information from a browser to
    a server and back again follows the HTTP protocol. A browser delivers a request
    to a server. The request may be satisfied by returning a response that consists
    of HTML and JavaScript to the browser, which, in turn, renders a page. The HTTP
    protocol is language- and server-agnostic. This means that it is not tied to a
    specific language or browser.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, we have a special type of class that runs in the application server
    waiting for a request, performs some action when the request is received, and
    then returns the response that the browser can render. This special class is a
    `new` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: A Jakarta EE application is packaged in a ZIP file with a `.war` extension.
    It does not include the JEE libraries. These libraries are part of the application
    server. This means that a web app is relatively small. These libraries are required
    to compile the code. Maven will bring down the libraries so that the Java compiler
    can validate your usage of Jakarta. When packaging an app into a `.war` file for
    the server, these libraries are not part of the final package.
  prefs: []
  type: TYPE_NORMAL
- en: The Jakarta EE specification describes two page-rendering libraries. The first
    is called **Jakarta Server Pages**, previously **JavaServer Pages**, or **JSP**.
    The second is called **Jakarta Faces**, previously known as **JavaServer Faces**,
    or **JSF**. This acronym is still used widely, rather than JF. Both libraries
    support the generation of HTML and JavaScript from Java code running in the application
    server. We will look at Jakarta Faces in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the role of the Java application server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring a web project with Maven
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding what a servlet does and how it is coded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring deployment with the `web.xml` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to understand how a web application
    is constructed in Java based on HTML and how servlets are coded.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the tools required to run the examples in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A text editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven 3.8.6 or a newer version installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GlassFish 7.0 application server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A web browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sample code for this chapter is available at [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter14](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter14).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the role of the Java application server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The center of the Jakarta EE 10 programming universe is the application server.
    These programs provide a range of services that your application can call upon.
    They also contain all the Jakarta 10 libraries that your application might need.
    This simply means that your application does not need to include all the required
    external libraries, such as what a desktop application must include in the final
    JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: 'An application server can be designated in one of three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is the platform. It provides the entire set of Jakarta EE 10 services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is the Web profile, which provides a subset of the platform services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, there is the Core profile. The smallest of the profiles, it is designed
    to provide the infrastructure for microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following table shows which Jakarta EE 10 libraries can be found in each
    profile. Libraries in the columns to the right of each profile, except for Core,
    are in that profile. The platform includes the Web profile and the Core profile,
    while the Web profile includes the Core profile. As Jakarta EE evolves, new features
    can be added and libraries are updated.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Platform** | **Web profile** | **Core profile** |'
  prefs: []
  type: TYPE_TB
- en: '| Authorization 2.1 | Expression Language 5.0 | CDI Lite 4.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Activation 2.1 | Authentication 3.0 | JSON Binding 3.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Batch 2.1 | Concurrency 3.0 | Annotations 2.1 |'
  prefs: []
  type: TYPE_TB
- en: '| Connectors 2.1 | Persistence 3.1 | Interceptors 2.1 |'
  prefs: []
  type: TYPE_TB
- en: '| Mail 2.1 | Faces 4.0 | RESTful Web Services 3.1 |'
  prefs: []
  type: TYPE_TB
- en: '| Messaging 3.1 | Security 3.0 | JSON Processing 2.1 |'
  prefs: []
  type: TYPE_TB
- en: '| Enterprise Beans 4.0 | Servlet 6.0 | Dependency Injection 2.0 |'
  prefs: []
  type: TYPE_TB
- en: '|  | Standard Tag Libraries 3.0 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Server Pages 3.1 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | CDI 4.0 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | WebSocket 2.1 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Bean Validation 3.0 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Debugging Support 2.0 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Enterprise Beans Lite 4.0 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Managed Beans 2.0 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Transactions 2.0 |  |'
  prefs: []
  type: TYPE_TB
- en: Table 14.1 – Jakarta EE 10 libraries/services
  prefs: []
  type: TYPE_NORMAL
- en: A platform server is expected to provide all the services listed in the previous
    table. A Web profile server provides Web profile and Core profile services. Finally,
    a Core profile server only supports what is in its column. We will only look at
    a few of these services in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Application servers are available from several companies. These servers usually
    have a free community/open source edition, as well as versions with paid licensing.
    Paid licensing gets you support for the server. Community editions maintain mailing
    lists, on which you can ask questions and get a response from either the company
    or other users of the community editions. One specific server stands out, and
    that is open source. This is the Eclipse GlassFish server. This is the one we
    will use in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: GlassFish 7.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GlassFish server was initially developed by Sun Microsystems as the reference
    server for Java EE. This meant that any other server that wished to be identified
    as a Java EE server needed to pass the same **Technical Compatibility Kit** test
    suite, commonly called the **TCK**, as GlassFish.
  prefs: []
  type: TYPE_NORMAL
- en: When Oracle acquired Sun, they continued to maintain GlassFish. In 2017, Oracle
    decided to no longer develop Java EE. They designated the Eclipse Foundation as
    the new home for Java EE, who, in turn, renamed it Jakarta EE. The technology
    transfer included GlassFish. This also meant that Jakarta EE and GlassFish are
    open source.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading, installing, and running GlassFish
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The GlassFish server can be downloaded from [https://glassfish.org/](https://glassfish.org/).
    There are two choices for a standalone server. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse GlassFish 7.0.0 and Jakarta EE Platform 10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eclipse GlassFish 7.0.0 and Jakarta EE Web Profile 10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, there are two embedded versions. An embedded version can be used
    as part of an application. There is just one download for each choice. These are
    not Linux, macOS, or Windows versions, as they all use nearly the same class files
    and libraries, and any specific components for a given OS are part of the single
    version. It is a ZIP file. Installation is quite simple. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download GlassFish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the environment or `JAVA_HOME` shell variable to the location of your JVM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip the file you downloaded. It should create a folder called `glassfish7`
    that you can now move to where you wish it to be.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `bin` folder in the `glassfish7` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a terminal or console window in the `bin` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the server for any OS by entering `asadmin start-domain`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On Linux, ensure that the `asadmin` shell script is executable before you run
    it. On Windows, you will be running the `asadmin.bat` batch file. To stop a server,
    enter `asadmin stop-domain`. You should see messages in the console/terminal window,
    telling you that you are successful. If you are not, then please review the more
    detailed installation instructions on the GlassFish website.
  prefs: []
  type: TYPE_NORMAL
- en: To test the installation, open your web browser and enter `http://localhost:8080`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default ports that GlassFish listens to are `8080` for applications running
    on the server and `4848` for access to the admin console. If needed, both these
    ports can be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see a web page that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – The default port 8080 web page](img/B19088_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – The default port 8080 web page
  prefs: []
  type: TYPE_NORMAL
- en: To access the admin console, enter `http://localhost:4848`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should now see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – The port 4848 admin console](img/B19088_14_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – The port 4848 admin console
  prefs: []
  type: TYPE_NORMAL
- en: You should use `admin` user, as you likely noticed that you were not asked for
    a password to access the admin console. For our purposes, there is nothing more
    to be done with GlassFish. When we wish to test our applications, we can use the
    **Deploy an Application** common task.
  prefs: []
  type: TYPE_NORMAL
- en: Explore GlassFish and read its documentation, which you will find on the download
    site. Its default configuration is all we need. Let us now create the necessary
    folder structure to build a web app with Maven.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a web project with Maven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step to crafting a web app is to configure your project for Maven.
    First, we need to create the appropriate folder structure for any Jakarta EE application
    built with Maven. Here is what you need to set it up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – The required folders for a Jakarta EE app being built with
    Maven](img/B19088_14_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – The required folders for a Jakarta EE app being built with Maven
  prefs: []
  type: TYPE_NORMAL
- en: 'The only difference between a Maven desktop setup and a web setup is the addition
    of the `webapp` folder in the `main` folder. In this folder is a `WEB-INF` folder
    and an optional `styles` folder. Here is a rundown of the folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/java`: All Java source files are stored in subfolders/packages, just
    as we did in a desktop app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/main/resources/`: Language bundles and logger configuration files go here.
    Some bundles can be placed in subfolders while others cannot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/main/webapp`: This is the folder that will contain any static web pages,
    JavaServer pages, and JavaServer Faces pages. You can create subfolders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/main/webapp/WEB-INF`: This folder contains configuration files and private
    files. A private file can be anything that might just be in the `WEB-INF` folder.
    A URL cannot include this folder, and this is why they are considered private.
    The folder can be accessed by code running on the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/main/webapp/styles`: This folder will hold any CSS files. This is not
    a standard folder, so you could place your CSS files in any folder, except `WEB_INF`
    in the `webapp` folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/test`: This is the home of any unit tests or other files used exclusively
    when running unit tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When your code is ready to be compiled, you only need to open a terminal/console
    window in the project’s root folder and enter the Maven command, `mvn`. If there
    were no errors, then you will have a new folder called `target` in your project,
    and in here, you will find the `.war` file. A `.war` file, like a `.jar` file,
    is a ZIP compressed file. The difference between them is how they are laid out
    in the file. Web servers expect an organization of files that is different from
    a desktop program.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to the pom.xml file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A web application is packaged in a file with the `war` extension. The folder
    organization in this file is based on the standard for application servers. This
    means that the first change to the POM file will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In our desktop pom file, we included dependencies for logging and unit testing.
    We will use `java.util.logging`, thus eliminating all the logging dependencies.
    Unit testing for web applications requires a special code runner, such as Arquillian
    from Red Hat. We will not be covering this and, therefore, can remove the unit
    testing dependencies and plugins. The new `pom.xml` file will now, starting with
    `properties`, contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `dependencies` section that follows, we show the Jakarta library dependency.
    Note that the `scope` setting is set to `provided`, which implies that the libraries
    do not get included in the WAR file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike desktop applications, we cannot simply run a web app. It must be copied
    to the appropriate folder in GlassFish and then a browser opens the site. While
    there are Maven plugins that can do this for you, we will keep it simple. Maven
    will output a WAR file, and you can use the GlassFish admin console to deploy
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There is another way to deploy an app. There is a folder in GlassFish called
    `glassfish7\glassfish\domains\domain1\autodeploy`.
  prefs: []
  type: TYPE_NORMAL
- en: If you simply copy a WAR file to this folder, then the server will deploy it
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at the heart of Java web programming, the servlet.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what a servlet does and how it is coded
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Java web programming, there is no main method. Instead, all applications
    must have at least one servlet. When we look at Jakarta Faces’ client-side rendering,
    there is no servlet, as it is already part of the library. Let’s look at a servlet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line is an annotation that defines that this class is a servlet.
    The description is visible in the server’s admin console. The `urlPattern` attribute
    is the name you use in a URL. A servlet can be named anything and can have any
    extension, although the standard practice is to not have an extension. A servlet
    can have multiple patterns. Here is an example of a servlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wished to refer to this servlet with more than one pattern, we could
    write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A servlet in Java is a class that extends `HttpServlet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor of a servlet class is rarely used because it cannot call upon
    any methods in the `HttpServlet` superclass. You can safely leave it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you must prepare for or initialize something before the servlet receives
    its first request, then you can use the `init` method. It can access the superclass,
    but it does not get a `request` or `response` object. It is called when the servlet
    is run before the first request arrives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `destroy` method is akin to a destructor in C++. It is called by the server
    before it is unloaded to carry out any required end-of-life tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getServletInfo` method allows you to prepare a string with information
    on this servlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `service` method is called by the server whenever a request is made to
    this servlet. The `service` method calls upon the `HttpServletRequest` object’s
    `getMethod` to determine the type of request and then calls the matching `do`
    method, such as `doPost` or `doGet`. The most common reason for overriding this
    is if you wish to perform a task regardless of the request type. In this example,
    we are just calling the `service` superclass method that you must do if you are
    not calling the appropriate method in the body of the overridden `service` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There are eight different types of requests. These are the HTTP verbs that
    the servlet provides to support the protocol. They are `GET`, `POST`, `PUT`, `DELETE`,
    `HEAD`, `OPTIONS`, `CONNECT`, and `TRACE`. The first four are the most used, although
    only `GET` and `POST` can be used on an HTML page. To test requests that cannot
    be issued from an HTML page, you can use the `curl` utility. This tool allows
    you to send any type of request from the terminal/console of your computer. When
    you run this application, you will see instructions for downloading and using
    `curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There are different content types that can be returned to a browser in the
    `response` object. The type could be, among others, `image/gif` or `application/pdf`.
    Plain text is `text/plain`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For a servlet to return text to a browser, we use a `PrintWriter` object. It
    is instantiated by the `response` object such that the data you are writing will
    go to the URL found in the `response` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `doPost` method that will display the web page created by `createHTMLString`
    and show that a `POST` request is issued:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `doPut` method. As we can only issue `PUT` using `curl`, all it
    returns is a simple string that `curl` will display in your terminal/console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `doDelete` method. Just as with `PUT`, you can only issue it using
    `curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This last method is a user method that is used to generate a string of HTML
    code, which can be returned to the user’s browser. Note that the HTML page is
    enclosed in a text block using the three quotation marks. There is also a placeholder,
    `%s`, in the text that is replaced using the `formatted` string method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: What happens when a servlet is requested?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A servlet class is instantiated by the server either when the server begins
    or when the servlet is called for the first time. Once instantiated, it remains
    in the server until you explicitly ask the server to remove it. There is only
    one instance of every servlet.
  prefs: []
  type: TYPE_NORMAL
- en: Each request generates a thread of the servlet. Creating threads is faster than
    creating objects. The thread of the servlet is free to do almost anything it wants,
    such as instantiating other objects. Should a thread not receive a request within
    a user-defined time period, usually 30 minutes, it is stopped and the objects
    created by the thread go to garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: How does a servlet access the query string in a request?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assume an HTML form that has three input fields named `emailAddress`, `firstName`,
    and `lastName`. Clicking on a button of the `submit` type will create a query
    string that will be appended to the URL if you are using a `GET` request, or added
    to the request body if you are using `POST`. In both cases, the data is in the
    `key = value` format. Here is such an HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This HTML will produce the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4 – The browser rendering of the HTML](img/B19088_14_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 – The browser rendering of the HTML
  prefs: []
  type: TYPE_NORMAL
- en: In HTML, I use the `method` attribute to show that the type of request issued
    when the button is pressed is `GET`. As this form submits data to the server,
    it should use the `POST` method. I use `GET` here, as it shows the query string
    in the address bar, whereas `POST` transmits the query string in a separate component
    of a request and, therefore, is not visible. `POST` should also be preferred should
    you need to prevent the information in the query string from being sent as plain
    text and also shown in the server logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have already filled out the form, and when I click on the button, the URL
    in the browser will be updated to show as a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `doGet` method in the servlet can now read the three parameters. In my
    example, I am storing this data in a simple JavaBean-style object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the names of the key values in the query string, we can retrieve the
    data and then assign them to the `User` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, I am displaying a results page constructed in a method called `displayConfirmation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The servlet’s output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5 – Output from the servlet](img/B19088_14_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.5 – Output from the servlet
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget to review the source code for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How does a servlet remember my data?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every time you call upon a servlet that is part of an application for the first
    time, you will receive an ID number that identifies an `HttpSession` object. This
    ID is sent as a cookie to your browser or, if you are blocking cookies, as a hidden
    field in the URL every time a request is made. If you already have the ID in a
    cookie, then that will be used. The server manages the ID; you do not need to
    do anything. The server uses this ID to manage the `HttpSession` object and ensure
    that your requests are the only ones that have access. You access the session
    object with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If an `HttpSession` object associated with your ID exists, then it is returned.
    If it does not exist, then a new `HttpSession` object with its own ID is returned.
    We will use one of two methods in the `HttpSession` object, one for reading and
    one for writing. If you wanted to preserve the `User` object in this example so
    that it can be used in another servlet, you will code the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This `HttpSession` object will remain valid until the `HttpSession` timer,
    usually 30 minutes, ends or you call `session.invalidate()`. If we want to retrieve
    the `User` object in another servlet, then we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You do not want to keep data around any longer than is necessary. Data stored
    in an `HttpServletRequest` object is lost after a response is given. In many cases,
    this is sufficient. However, if you were writing a shopping cart application,
    you would want to preserve whatever a client chooses as they move from page to
    page on the site. Here is where an `HttpSession` object is used.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now look at a file that we can use to configure how a server deals with
    servlets, called `web.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring deployment with the web.xml file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `WEB-INF` folder of a web project, there is usually a file named `web.xml`.
    It was mandatory before the `@WebServlet` annotation was introduced. With the
    annotation, the application server can determine on its own which files are servlets
    and which are not. There is more that you can do in this file than just list servlets.
    For this reason, I advise you to always have a `web.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our descriptor will be quite basic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a display name that the application server can use in a report, followed
    by the welcome page. The welcome page is the name of the page to display if the
    URL does not include the page name. Let’s say you type the following in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of writing that, you only need to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTTP protocol is stateless. This means that every time you make a request,
    the server behaves as if it is the first time you have visited the site. The application
    server can remember you by using an `HttpSession` object. This object has a default
    lifetime of 30 minutes since your last visit to the website. When the time is
    up, the object is invalidated, and the server will no longer remember you. You
    can change the length of time by adding this to the `web.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, you may have data, in the form of a string, which is common
    to every servlet in the application – for example, the company email address that
    needs to appear on every page. We use `context-param` for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To access this in a servlet, we just need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You should now be able to get a web application based on a servlet up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the basics of a web application. The center of
    this universe is the servlet. There are many other frameworks, such as Spring,
    that provide an alternative set of libraries, yet all these frameworks sit on
    top of and depend upon the servlet specification, along with other Jakarta libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta is standards-based. What this means is that by adhering to the HTTP
    protocols, it can provide services to any frontend, such as React.js, Bootstrap,
    and Angular. In the next chapter, we will look at one frontend programming library,
    Jakarta Faces, that is part of the Jakarta framework.
  prefs: []
  type: TYPE_NORMAL
- en: We used the GlassFish server in this chapter, but there are a number of other
    choices for a Java application server. For example, the Payara server is based
    on Glassfish, but as it is backed by the Payara company, it provides commercial
    support that is not available with Glassfish. There are also servers from Red
    Hat, IBM, and others. There is usually a community version that you can use without
    paying for a commercial license.
  prefs: []
  type: TYPE_NORMAL
- en: As we looked at server-side programming, we needed to make changes to our Maven
    `pom.xml` file. With these in place, we were able to create a `.war` file for
    use on the server as easily as we created desktop `.``jar` files.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we will look deeper into Jakarta EE by examining an application that
    brings the Financial Calculator we saw in the previous chapter to the web.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jakarta EE: [https://jakarta.ee/](https://jakarta.ee/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP methods: [https://www.tutorialspoint.com/http/http_methods.htm](https://www.tutorialspoint.com/http/http_methods.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
