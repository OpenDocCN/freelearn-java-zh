- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Server-Side Coding with Jakarta
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jakarta 进行服务器端编码
- en: While Java’s initial connection to the web was through applet development, it
    was only a few years after the language appeared that server-side Java, first
    called the **Java 2 Enterprise Edition**, or **J2EE**, and later called the **Java
    Enterprise Edition**, or **JEE**, was introduced. Unlike standalone applications
    that can run on your desktop, JEE applications run inside another family of Java
    programs called application servers. When Oracle decided to focus primarily on
    the core language, Java SE, the specifications and libraries were turned over
    to the Eclipse Foundation. These specifications and libraries were renamed **Jakarta
    EE**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Java 与网络的最初连接是通过小程序开发实现的，但该语言出现后的几年内，服务器端 Java，最初称为 **Java 2 Enterprise Edition**
    或 **J2EE**，后来称为 **Java Enterprise Edition** 或 **JEE**，才被引入。与可以在您的桌面上运行的独立应用程序不同，JEE
    应用程序在另一组称为应用服务器的 Java 程序中运行。当 Oracle 决定主要关注核心语言 Java SE 时，规范和库被转交给 Eclipse 基金会。这些规范和库被重命名为
    **Jakarta EE**。
- en: Server-side coding in any programming language typically involves software listening
    to an internet port, such as `80`. The passing of information from a browser to
    a server and back again follows the HTTP protocol. A browser delivers a request
    to a server. The request may be satisfied by returning a response that consists
    of HTML and JavaScript to the browser, which, in turn, renders a page. The HTTP
    protocol is language- and server-agnostic. This means that it is not tied to a
    specific language or browser.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言的服务器端编码通常涉及软件监听互联网端口，例如 `80`。信息从浏览器到服务器以及返回遵循 HTTP 协议。浏览器向服务器发送请求。请求可以通过返回由
    HTML 和 JavaScript 组成的响应来满足，浏览器再将页面渲染出来。HTTP 协议是语言和服务器无关的。这意味着它与特定的语言或浏览器无关。
- en: In Java, we have a special type of class that runs in the application server
    waiting for a request, performs some action when the request is received, and
    then returns the response that the browser can render. This special class is a
    `new` keyword.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，我们有一种特殊的类，它在应用服务器中运行，等待请求，在接收到请求时执行一些操作，然后返回浏览器可以渲染的响应。这个特殊类是 `new`
    关键字。
- en: A Jakarta EE application is packaged in a ZIP file with a `.war` extension.
    It does not include the JEE libraries. These libraries are part of the application
    server. This means that a web app is relatively small. These libraries are required
    to compile the code. Maven will bring down the libraries so that the Java compiler
    can validate your usage of Jakarta. When packaging an app into a `.war` file for
    the server, these libraries are not part of the final package.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Jakarta EE 应用程序打包在一个具有 `.war` 扩展名的 ZIP 文件中。它不包含 JEE 库。这些库是应用服务器的一部分。这意味着网络应用相对较小。这些库是编译代码所必需的。Maven
    会下载这些库，以便 Java 编译器可以验证你的 Jakarta 使用情况。当将应用程序打包成用于服务器的 `.war` 文件时，这些库不是最终包的一部分。
- en: The Jakarta EE specification describes two page-rendering libraries. The first
    is called **Jakarta Server Pages**, previously **JavaServer Pages**, or **JSP**.
    The second is called **Jakarta Faces**, previously known as **JavaServer Faces**,
    or **JSF**. This acronym is still used widely, rather than JF. Both libraries
    support the generation of HTML and JavaScript from Java code running in the application
    server. We will look at Jakarta Faces in the next chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta EE 规范描述了两个页面渲染库。第一个称为 **Jakarta Server Pages**，之前称为 **JavaServer Pages**
    或 **JSP**。第二个称为 **Jakarta Faces**，之前被称为 **JavaServer Faces** 或 **JSF**。这个缩写仍然被广泛使用，而不是
    JF。这两个库都支持从运行在应用服务器的 Java 代码生成 HTML 和 JavaScript。我们将在下一章中探讨 Jakarta Faces。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Understanding the role of the Java application server
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Java 应用服务器的作用
- en: Configuring a web project with Maven
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Maven 配置网络项目
- en: Understanding what a servlet does and how it is coded
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 servlet 的作用以及其编码方式
- en: Configuring deployment with the `web.xml` file
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `web.xml` 文件配置部署
- en: By the end of this chapter, you should be able to understand how a web application
    is constructed in Java based on HTML and how servlets are coded.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够理解如何在 Java 中基于 HTML 构建一个网络应用，以及如何编写 servlet 代码。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here are the tools required to run the examples in this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中运行示例所需的工具如下：
- en: Java 17
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 17
- en: A text editor
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个文本编辑器
- en: Maven 3.8.6 or a newer version installed
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Maven 3.8.6 或更高版本
- en: The GlassFish 7.0 application server
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GlassFish 7.0 应用服务器
- en: A web browser
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个网络浏览器
- en: The sample code for this chapter is available at [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter14](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter14).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可在[https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter14](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter14)找到。
- en: Understanding the role of the Java application server
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Java应用程序服务器的作用
- en: The center of the Jakarta EE 10 programming universe is the application server.
    These programs provide a range of services that your application can call upon.
    They also contain all the Jakarta 10 libraries that your application might need.
    This simply means that your application does not need to include all the required
    external libraries, such as what a desktop application must include in the final
    JAR file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jakarta EE 10编程宇宙的中心是应用程序服务器。这些程序提供了一系列您的应用程序可以调用的服务。它们还包含了您的应用程序可能需要的所有Jakarta
    10库。这意味着您的应用程序不需要包含所有必需的外部库，例如桌面应用程序必须在最终的JAR文件中包含的库。
- en: 'An application server can be designated in one of three ways:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序服务器可以通过以下三种方式之一指定：
- en: The first is the platform. It provides the entire set of Jakarta EE 10 services.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一项是平台。它提供了Jakarta EE 10服务的全部集合。
- en: The second is the Web profile, which provides a subset of the platform services.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二项是Web配置文件，它提供平台服务的子集。
- en: Finally, there is the Core profile. The smallest of the profiles, it is designed
    to provide the infrastructure for microservices.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，是核心配置文件。这是最小的配置文件，旨在为微服务提供基础设施。
- en: The following table shows which Jakarta EE 10 libraries can be found in each
    profile. Libraries in the columns to the right of each profile, except for Core,
    are in that profile. The platform includes the Web profile and the Core profile,
    while the Web profile includes the Core profile. As Jakarta EE evolves, new features
    can be added and libraries are updated.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了每个配置文件中可以找到哪些Jakarta EE 10库。每个配置文件右侧的列中的库（除核心库外）属于该配置文件。该平台包括Web配置文件和核心配置文件，而Web配置文件包括核心配置文件。随着Jakarta
    EE的发展，可以添加新功能，库也会更新。
- en: '| **Platform** | **Web profile** | **Core profile** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **平台** | **Web配置文件** | **核心配置文件** |'
- en: '| Authorization 2.1 | Expression Language 5.0 | CDI Lite 4.0 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 授权 2.1 | 表达式语言 5.0 | CDI Lite 4.0 |'
- en: '| Activation 2.1 | Authentication 3.0 | JSON Binding 3.0 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 激活 2.1 | 认证 3.0 | JSON绑定 3.0 |'
- en: '| Batch 2.1 | Concurrency 3.0 | Annotations 2.1 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 批处理 2.1 | 并发 3.0 | 注解 2.1 |'
- en: '| Connectors 2.1 | Persistence 3.1 | Interceptors 2.1 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 连接器 2.1 | 持久化 3.1 | 拦截器 2.1 |'
- en: '| Mail 2.1 | Faces 4.0 | RESTful Web Services 3.1 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 邮件 2.1 | Faces 4.0 | RESTful Web Services 3.1 |'
- en: '| Messaging 3.1 | Security 3.0 | JSON Processing 2.1 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 消息传递 3.1 | 安全性 3.0 | JSON处理 2.1 |'
- en: '| Enterprise Beans 4.0 | Servlet 6.0 | Dependency Injection 2.0 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 企业Bean 4.0 | Servlet 6.0 | 依赖注入 2.0 |'
- en: '|  | Standard Tag Libraries 3.0 |  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|  | 标准标签库 3.0 |  |'
- en: '|  | Server Pages 3.1 |  |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|  | 服务器页面 3.1 |  |'
- en: '|  | CDI 4.0 |  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|  | CDI 4.0 |  |'
- en: '|  | WebSocket 2.1 |  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|  | WebSocket 2.1 |  |'
- en: '|  | Bean Validation 3.0 |  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|  | Bean验证 3.0 |  |'
- en: '|  | Debugging Support 2.0 |  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|  | 调试支持 2.0 |  |'
- en: '|  | Enterprise Beans Lite 4.0 |  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|  | 企业Bean Lite 4.0 |  |'
- en: '|  | Managed Beans 2.0 |  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '|  | 管理Bean 2.0 |  |'
- en: '|  | Transactions 2.0 |  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|  | 事务 2.0 |  |'
- en: Table 14.1 – Jakarta EE 10 libraries/services
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.1 – Jakarta EE 10库/服务
- en: A platform server is expected to provide all the services listed in the previous
    table. A Web profile server provides Web profile and Core profile services. Finally,
    a Core profile server only supports what is in its column. We will only look at
    a few of these services in this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 预期平台服务器提供前表中列出的所有服务。Web配置文件服务器提供Web配置文件和核心配置文件服务。最后，核心配置文件服务器仅支持其列中的内容。在本章中，我们只将查看其中的一些服务。
- en: Application servers are available from several companies. These servers usually
    have a free community/open source edition, as well as versions with paid licensing.
    Paid licensing gets you support for the server. Community editions maintain mailing
    lists, on which you can ask questions and get a response from either the company
    or other users of the community editions. One specific server stands out, and
    that is open source. This is the Eclipse GlassFish server. This is the one we
    will use in this chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序服务器由多家公司提供。这些服务器通常有一个免费的社区/开源版本，以及付费许可的版本。付费许可为您提供对服务器的支持。社区版本维护邮件列表，您可以在列表上提问，并从公司或其他社区版本用户那里获得回复。一个特定的服务器脱颖而出，那就是开源的。这就是Eclipse
    GlassFish服务器。这就是我们在本章中将使用的服务器。
- en: GlassFish 7.0
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GlassFish 7.0
- en: The GlassFish server was initially developed by Sun Microsystems as the reference
    server for Java EE. This meant that any other server that wished to be identified
    as a Java EE server needed to pass the same **Technical Compatibility Kit** test
    suite, commonly called the **TCK**, as GlassFish.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: GlassFish 服务器最初由太阳微系统公司开发，作为 Java EE 的参考服务器。这意味着任何希望被识别为 Java EE 服务器的其他服务器都需要通过与
    GlassFish 相同的 **技术兼容性工具包** 测试套件，通常称为 **TCK**。
- en: When Oracle acquired Sun, they continued to maintain GlassFish. In 2017, Oracle
    decided to no longer develop Java EE. They designated the Eclipse Foundation as
    the new home for Java EE, who, in turn, renamed it Jakarta EE. The technology
    transfer included GlassFish. This also meant that Jakarta EE and GlassFish are
    open source.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当甲骨文公司收购了太阳微系统公司后，他们继续维护 GlassFish。2017 年，甲骨文决定不再开发 Java EE。他们将 Eclipse 基金会指定为
    Java EE 的新家，该基金会随后将其更名为 Jakarta EE。技术转让包括了 GlassFish。这也意味着 Jakarta EE 和 GlassFish
    都是开源的。
- en: Downloading, installing, and running GlassFish
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载、安装和运行 GlassFish
- en: 'The GlassFish server can be downloaded from [https://glassfish.org/](https://glassfish.org/).
    There are two choices for a standalone server. These are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: GlassFish 服务器可以从 [https://glassfish.org/](https://glassfish.org/) 下载。对于独立服务器有两个选择。如下所示：
- en: Eclipse GlassFish 7.0.0 and Jakarta EE Platform 10
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse GlassFish 7.0.0 和 Jakarta EE 平台 10
- en: Eclipse GlassFish 7.0.0 and Jakarta EE Web Profile 10
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse GlassFish 7.0.0 和 Jakarta EE Web Profile 10
- en: 'In addition, there are two embedded versions. An embedded version can be used
    as part of an application. There is just one download for each choice. These are
    not Linux, macOS, or Windows versions, as they all use nearly the same class files
    and libraries, and any specific components for a given OS are part of the single
    version. It is a ZIP file. Installation is quite simple. Here are the steps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有两个嵌入式版本。嵌入式版本可以用作应用程序的一部分。每个选择只有一个下载。这些不是 Linux、macOS 或 Windows 版本，因为它们都使用几乎相同的类文件和库，任何特定于操作系统的组件都是单个版本的一部分。这是一个
    ZIP 文件。安装相当简单。以下是步骤：
- en: Download GlassFish.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 GlassFish。
- en: Set the environment or `JAVA_HOME` shell variable to the location of your JVM.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将环境或 `JAVA_HOME` shell 变量设置为 JVM 的位置。
- en: Unzip the file you downloaded. It should create a folder called `glassfish7`
    that you can now move to where you wish it to be.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压您下载的文件。它应该创建一个名为 `glassfish7` 的文件夹，您现在可以将其移动到您希望的位置。
- en: Go to the `bin` folder in the `glassfish7` folder.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `glassfish7` 文件夹中的 `bin` 文件夹。
- en: Open a terminal or console window in the `bin` folder.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bin` 文件夹中打开终端或控制台窗口。
- en: Start the server for any OS by entering `asadmin start-domain`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入 `asadmin start-domain` 在任何操作系统上启动服务器。
- en: On Linux, ensure that the `asadmin` shell script is executable before you run
    it. On Windows, you will be running the `asadmin.bat` batch file. To stop a server,
    enter `asadmin stop-domain`. You should see messages in the console/terminal window,
    telling you that you are successful. If you are not, then please review the more
    detailed installation instructions on the GlassFish website.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，在运行之前确保 `asadmin` 脚本是可执行的。在 Windows 上，您将运行 `asadmin.bat` 批处理文件。要停止服务器，请输入
    `asadmin stop-domain`。您应该在控制台/终端窗口中看到消息，告诉您操作成功。如果您不成功，请查阅 GlassFish 网站上的更详细的安装说明。
- en: To test the installation, open your web browser and enter `http://localhost:8080`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试安装，请打开您的网页浏览器并输入 `http://localhost:8080`。
- en: The default ports that GlassFish listens to are `8080` for applications running
    on the server and `4848` for access to the admin console. If needed, both these
    ports can be changed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: GlassFish 监听的默认端口是 `8080`，用于服务器上运行的应用程序，以及 `4848` 用于访问管理控制台。如果需要，这两个端口都可以更改。
- en: 'You should see a web page that looks like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到一个看起来像这样的网页：
- en: '![Figure 14.1 – The default port 8080 web page](img/B19088_14_01.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.1 – 默认端口 8080 的网页](img/B19088_14_01.jpg)'
- en: Figure 14.1 – The default port 8080 web page
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 – 默认端口 8080 的网页
- en: To access the admin console, enter `http://localhost:4848`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问管理控制台，请输入 `http://localhost:4848`。
- en: 'You should now see the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该看到以下内容：
- en: '![Figure 14.2 – The port 4848 admin console](img/B19088_14_02.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.2 – 端口 4848 的管理控制台](img/B19088_14_02.jpg)'
- en: Figure 14.2 – The port 4848 admin console
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 – 端口 4848 的管理控制台
- en: You should use `admin` user, as you likely noticed that you were not asked for
    a password to access the admin console. For our purposes, there is nothing more
    to be done with GlassFish. When we wish to test our applications, we can use the
    **Deploy an Application** common task.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用`admin`用户，因为你可能已经注意到，访问管理控制台时没有要求你输入密码。就我们的目的而言，在GlassFish上没有更多的事情要做。当我们想要测试我们的应用程序时，我们可以使用**部署应用程序**这个常用任务。
- en: Explore GlassFish and read its documentation, which you will find on the download
    site. Its default configuration is all we need. Let us now create the necessary
    folder structure to build a web app with Maven.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 探索GlassFish并阅读其文档，你将在下载网站上找到它。它的默认配置就是我们所需要的。现在让我们创建构建Maven Web应用程序所需的必要文件夹结构。
- en: Configuring a web project with Maven
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Maven配置Web项目
- en: 'The first step to crafting a web app is to configure your project for Maven.
    First, we need to create the appropriate folder structure for any Jakarta EE application
    built with Maven. Here is what you need to set it up:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 制作Web应用程序的第一步是为Maven配置你的项目。首先，我们需要为任何使用Maven构建的Jakarta EE应用程序创建适当的文件夹结构。以下是设置所需的步骤：
- en: '![Figure 14.3 – The required folders for a Jakarta EE app being built with
    Maven](img/B19088_14_03.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图14.3 – 使用Maven构建的Jakarta EE应用程序所需的文件夹](img/B19088_14_03.jpg)'
- en: Figure 14.3 – The required folders for a Jakarta EE app being built with Maven
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 – 使用Maven构建的Jakarta EE应用程序所需的文件夹
- en: 'The only difference between a Maven desktop setup and a web setup is the addition
    of the `webapp` folder in the `main` folder. In this folder is a `WEB-INF` folder
    and an optional `styles` folder. Here is a rundown of the folder:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Maven桌面设置和Web设置之间的唯一区别是在`main`文件夹中添加了`webapp`文件夹。在这个文件夹中有一个`WEB-INF`文件夹和一个可选的`styles`文件夹。以下是文件夹的概述：
- en: '`src/main/java`: All Java source files are stored in subfolders/packages, just
    as we did in a desktop app.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/main/java`: 所有Java源文件都存储在子文件夹/包中，就像我们在桌面应用程序中做的那样。'
- en: '`src/main/resources/`: Language bundles and logger configuration files go here.
    Some bundles can be placed in subfolders while others cannot.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/main/resources/`: 语言包和日志配置文件放在这里。一些包可以放在子文件夹中，而另一些则不能。'
- en: '`src/main/webapp`: This is the folder that will contain any static web pages,
    JavaServer pages, and JavaServer Faces pages. You can create subfolders.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/main/webapp`: 这是一个将包含任何静态网页、JavaServer页面和JavaServer Faces页面的文件夹。你可以创建子文件夹。'
- en: '`src/main/webapp/WEB-INF`: This folder contains configuration files and private
    files. A private file can be anything that might just be in the `WEB-INF` folder.
    A URL cannot include this folder, and this is why they are considered private.
    The folder can be accessed by code running on the server.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/main/webapp/WEB-INF`: 这个文件夹包含配置文件和私有文件。私有文件可以是任何可能在`WEB-INF`文件夹中的东西。URL不能包含这个文件夹，这就是为什么它们被认为是私有的。这个文件夹可以通过在服务器上运行的代码访问。'
- en: '`src/main/webapp/styles`: This folder will hold any CSS files. This is not
    a standard folder, so you could place your CSS files in any folder, except `WEB_INF`
    in the `webapp` folder.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/main/webapp/styles`: 这个文件夹将包含任何CSS文件。这不是一个标准文件夹，所以你可以将CSS文件放在任何文件夹中，除了`webapp`文件夹中的`WEB_INF`。'
- en: '`src/test`: This is the home of any unit tests or other files used exclusively
    when running unit tests.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/test`: 这是任何单元测试或仅在运行单元测试时使用的其他文件的存放地。'
- en: When your code is ready to be compiled, you only need to open a terminal/console
    window in the project’s root folder and enter the Maven command, `mvn`. If there
    were no errors, then you will have a new folder called `target` in your project,
    and in here, you will find the `.war` file. A `.war` file, like a `.jar` file,
    is a ZIP compressed file. The difference between them is how they are laid out
    in the file. Web servers expect an organization of files that is different from
    a desktop program.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的代码准备好编译时，你只需要在项目的根文件夹中打开一个终端/控制台窗口，并输入Maven命令`mvn`。如果没有错误，那么你将在项目中有一个名为`target`的新文件夹，在这里你可以找到`.war`文件。`.war`文件，就像`.jar`文件一样，是一个ZIP压缩文件。它们之间的区别在于它们在文件中的布局。Web服务器期望的文件组织与桌面程序不同。
- en: Changes to the pom.xml file
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改pom.xml文件
- en: 'A web application is packaged in a file with the `war` extension. The folder
    organization in this file is based on the standard for application servers. This
    means that the first change to the POM file will be as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Web应用程序被打包在一个以`war`为扩展名的文件中。这个文件中的文件夹组织基于应用程序服务器的标准。这意味着对POM文件的第一次更改将如下所示：
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In our desktop pom file, we included dependencies for logging and unit testing.
    We will use `java.util.logging`, thus eliminating all the logging dependencies.
    Unit testing for web applications requires a special code runner, such as Arquillian
    from Red Hat. We will not be covering this and, therefore, can remove the unit
    testing dependencies and plugins. The new `pom.xml` file will now, starting with
    `properties`, contain the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的桌面pom文件中，我们包括了日志记录和单元测试的依赖项。我们将使用`java.util.logging`，从而消除所有日志记录依赖项。Web应用程序的单元测试需要一个特殊的代码运行器，例如来自Red
    Hat的Arquillian。我们不会涉及这部分内容，因此可以删除单元测试依赖项和插件。新的`pom.xml`文件现在，从`properties`开始，将包含以下内容：
- en: '[PRE1]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `dependencies` section that follows, we show the Jakarta library dependency.
    Note that the `scope` setting is set to `provided`, which implies that the libraries
    do not get included in the WAR file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的`dependencies`部分，我们展示了Jakarta库依赖项。请注意，`scope`设置被设置为`provided`，这意味着库不会被包含在WAR文件中：
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Unlike desktop applications, we cannot simply run a web app. It must be copied
    to the appropriate folder in GlassFish and then a browser opens the site. While
    there are Maven plugins that can do this for you, we will keep it simple. Maven
    will output a WAR file, and you can use the GlassFish admin console to deploy
    it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与桌面应用程序不同，我们不能简单地运行一个Web应用程序。它必须被复制到GlassFish的相应文件夹中，然后打开浏览器来访问该网站。虽然有一些Maven插件可以为你完成这项工作，但我们将保持简单。Maven将输出一个WAR文件，你可以使用GlassFish管理控制台来部署它：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There is another way to deploy an app. There is a folder in GlassFish called
    `glassfish7\glassfish\domains\domain1\autodeploy`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 部署应用程序还有另一种方法。在GlassFish中有一个名为`glassfish7\glassfish\domains\domain1\autodeploy`的文件夹。
- en: If you simply copy a WAR file to this folder, then the server will deploy it
    automatically.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是将WAR文件复制到这个文件夹，那么服务器将自动部署它。
- en: Now, let’s look at the heart of Java web programming, the servlet.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看Java Web编程的核心，即servlet。
- en: Understanding what a servlet does and how it is coded
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解servlet的功能以及它的编码方式
- en: In Java web programming, there is no main method. Instead, all applications
    must have at least one servlet. When we look at Jakarta Faces’ client-side rendering,
    there is no servlet, as it is already part of the library. Let’s look at a servlet.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java Web编程中，没有main方法。相反，所有应用程序至少必须有一个servlet。当我们查看Jakarta Faces的客户端渲染时，没有servlet，因为它已经是库的一部分。让我们看看一个servlet。
- en: 'The first line is an annotation that defines that this class is a servlet.
    The description is visible in the server’s admin console. The `urlPattern` attribute
    is the name you use in a URL. A servlet can be named anything and can have any
    extension, although the standard practice is to not have an extension. A servlet
    can have multiple patterns. Here is an example of a servlet:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是一个注解，它定义了此类是一个servlet。描述在服务器的管理控制台中可见。`urlPattern`属性是在URL中使用的名称。servlet可以命名为任何东西，可以有任意扩展名，尽管标准做法是不使用扩展名。servlet可以有多个模式。以下是一个servlet的示例：
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we wished to refer to this servlet with more than one pattern, we could
    write the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望使用多个模式来引用此servlet，我们可以编写以下内容：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A servlet in Java is a class that extends `HttpServlet`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的servlet是一个扩展`HttpServlet`的类：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The constructor of a servlet class is rarely used because it cannot call upon
    any methods in the `HttpServlet` superclass. You can safely leave it out:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Servlet类的构造函数很少使用，因为它不能调用`HttpServlet`超类中的任何方法。你可以安全地省略它：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you must prepare for or initialize something before the servlet receives
    its first request, then you can use the `init` method. It can access the superclass,
    but it does not get a `request` or `response` object. It is called when the servlet
    is run before the first request arrives:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须在servlet接收到第一个请求之前准备或初始化某些内容，那么你可以使用`init`方法。它可以访问超类，但不会得到`request`或`response`对象。它在servlet在第一个请求到达之前运行时被调用：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `destroy` method is akin to a destructor in C++. It is called by the server
    before it is unloaded to carry out any required end-of-life tasks:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`destroy`方法类似于C++中的析构函数。在服务器卸载之前，它会被服务器调用以执行任何必要的结束任务：'
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `getServletInfo` method allows you to prepare a string with information
    on this servlet:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`getServletInfo`方法允许你准备一个包含关于此servlet信息的字符串：'
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `service` method is called by the server whenever a request is made to
    this servlet. The `service` method calls upon the `HttpServletRequest` object’s
    `getMethod` to determine the type of request and then calls the matching `do`
    method, such as `doPost` or `doGet`. The most common reason for overriding this
    is if you wish to perform a task regardless of the request type. In this example,
    we are just calling the `service` superclass method that you must do if you are
    not calling the appropriate method in the body of the overridden `service` method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器在每次请求此servlet时都会调用`service`方法。`service`方法调用`HttpServletRequest`对象的`getMethod`以确定请求类型，然后调用匹配的`do`方法，例如`doPost`或`doGet`。覆盖此方法的常见原因是你希望无论请求类型如何都执行一项任务。在这个例子中，我们只是调用`service`超类方法，如果你没有在覆盖的`service`方法体中调用适当的方法，你必须这样做：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There are eight different types of requests. These are the HTTP verbs that
    the servlet provides to support the protocol. They are `GET`, `POST`, `PUT`, `DELETE`,
    `HEAD`, `OPTIONS`, `CONNECT`, and `TRACE`. The first four are the most used, although
    only `GET` and `POST` can be used on an HTML page. To test requests that cannot
    be issued from an HTML page, you can use the `curl` utility. This tool allows
    you to send any type of request from the terminal/console of your computer. When
    you run this application, you will see instructions for downloading and using
    `curl`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有八种不同的请求类型。这些都是servlet提供的HTTP动词，以支持协议。它们是`GET`、`POST`、`PUT`、`DELETE`、`HEAD`、`OPTIONS`、`CONNECT`和`TRACE`。前四种是最常用的，尽管只有`GET`和`POST`可以在HTML页面上使用。要测试无法从HTML页面发出的请求，你可以使用`curl`实用程序。这个工具允许你从你的计算机的终端/控制台中发送任何类型的请求。当你运行这个应用程序时，你会看到下载和使用`curl`的说明：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are different content types that can be returned to a browser in the
    `response` object. The type could be, among others, `image/gif` or `application/pdf`.
    Plain text is `text/plain`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`response`对象中可以返回给浏览器的不同内容类型。类型可以是`image/gif`或`application/pdf`。纯文本是`text/plain`：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For a servlet to return text to a browser, we use a `PrintWriter` object. It
    is instantiated by the `response` object such that the data you are writing will
    go to the URL found in the `response` object:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让servlet返回文本给浏览器，我们使用`PrintWriter`对象。它由`response`对象实例化，这样你写入的数据就会发送到`response`对象中找到的URL：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the `doPost` method that will display the web page created by `createHTMLString`
    and show that a `POST` request is issued:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`doPost`方法，它将显示由`createHTMLString`创建的网页，并显示已发出`POST`请求：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is the `doPut` method. As we can only issue `PUT` using `curl`, all it
    returns is a simple string that `curl` will display in your terminal/console:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`doPut`方法。由于我们只能使用`curl`发出`PUT`，它只返回一个简单的字符串，`curl`将在你的终端/控制台中显示：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is the `doDelete` method. Just as with `PUT`, you can only issue it using
    `curl`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`doDelete`方法。就像`PUT`一样，你只能使用`curl`来发出它：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This last method is a user method that is used to generate a string of HTML
    code, which can be returned to the user’s browser. Note that the HTML page is
    enclosed in a text block using the three quotation marks. There is also a placeholder,
    `%s`, in the text that is replaced using the `formatted` string method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种方法是一个用户方法，用于生成HTML代码字符串，该字符串可以返回给用户的浏览器。请注意，HTML页面使用三个引号包含在一个文本块中。文本中还有一个占位符`%s`，它使用`formatted`字符串方法进行替换：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What happens when a servlet is requested?
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当请求一个servlet时会发生什么？
- en: A servlet class is instantiated by the server either when the server begins
    or when the servlet is called for the first time. Once instantiated, it remains
    in the server until you explicitly ask the server to remove it. There is only
    one instance of every servlet.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器在开始时或第一次调用servlet时，会实例化一个servlet类。一旦实例化，它就会保留在服务器上，直到你明确要求服务器将其删除。每个servlet只有一个实例。
- en: Each request generates a thread of the servlet. Creating threads is faster than
    creating objects. The thread of the servlet is free to do almost anything it wants,
    such as instantiating other objects. Should a thread not receive a request within
    a user-defined time period, usually 30 minutes, it is stopped and the objects
    created by the thread go to garbage collection.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 每个请求都会生成一个servlet的线程。创建线程比创建对象更快。servlet的线程可以自由地做几乎所有它想做的事情，比如实例化其他对象。如果一个线程在用户定义的时间段内（通常是30分钟）没有收到请求，它就会被停止，线程创建的对象将进入垃圾回收。
- en: How does a servlet access the query string in a request?
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: servlet如何访问请求中的查询字符串？
- en: 'Assume an HTML form that has three input fields named `emailAddress`, `firstName`,
    and `lastName`. Clicking on a button of the `submit` type will create a query
    string that will be appended to the URL if you are using a `GET` request, or added
    to the request body if you are using `POST`. In both cases, the data is in the
    `key = value` format. Here is such an HTML page:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个 HTML 表单，有三个名为 `emailAddress`、`firstName` 和 `lastName` 的输入字段。点击 `submit`
    类型的按钮将创建一个查询字符串，如果你使用 `GET` 请求，它将被附加到 URL 上；如果你使用 `POST`，它将被添加到请求体中。在两种情况下，数据都是
    `key = value` 格式。以下是一个这样的 HTML 页面：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This HTML will produce the following page:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 HTML 将生成以下页面：
- en: '![Figure 14.4 – The browser rendering of the HTML](img/B19088_14_04.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.4 – 浏览器对 HTML 的渲染](img/B19088_14_04.jpg)'
- en: Figure 14.4 – The browser rendering of the HTML
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4 – 浏览器对 HTML 的渲染
- en: In HTML, I use the `method` attribute to show that the type of request issued
    when the button is pressed is `GET`. As this form submits data to the server,
    it should use the `POST` method. I use `GET` here, as it shows the query string
    in the address bar, whereas `POST` transmits the query string in a separate component
    of a request and, therefore, is not visible. `POST` should also be preferred should
    you need to prevent the information in the query string from being sent as plain
    text and also shown in the server logs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML 中，我使用 `method` 属性来显示当按钮被按下时发出的请求类型是 `GET`。由于这个表单将数据提交到服务器，它应该使用 `POST`
    方法。我这里使用 `GET`，因为它在地址栏中显示了查询字符串，而 `POST` 将查询字符串传输为请求的一个单独组件，因此是不可见的。如果你需要防止查询字符串中的信息以纯文本形式发送并在服务器日志中显示，也应该首选
    `POST`。
- en: 'I have already filled out the form, and when I click on the button, the URL
    in the browser will be updated to show as a single line:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经填写了表单，当我点击按钮时，浏览器中的 URL 将更新为显示为单行：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `doGet` method in the servlet can now read the three parameters. In my
    example, I am storing this data in a simple JavaBean-style object:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: servlet 中的 `doGet` 方法现在可以读取三个参数。在我的例子中，我将这些数据存储在一个简单的 JavaBean 风格的对象中：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Using the names of the key values in the query string, we can retrieve the
    data and then assign them to the `User` object:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用查询字符串中键值的名称，我们可以检索数据，然后将它们分配给 `User` 对象：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, I am displaying a results page constructed in a method called `displayConfirmation`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我展示了使用名为 `displayConfirmation` 的方法构建的结果页面：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The servlet’s output will be as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: servlet 的输出将如下所示：
- en: '![Figure 14.5 – Output from the servlet](img/B19088_14_05.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.5 – servlet 的输出](img/B19088_14_05.jpg)'
- en: Figure 14.5 – Output from the servlet
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5 – servlet 的输出
- en: Do not forget to review the source code for this chapter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记回顾本章的源代码。
- en: How does a servlet remember my data?
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: servlet 如何记住我的数据？
- en: 'Every time you call upon a servlet that is part of an application for the first
    time, you will receive an ID number that identifies an `HttpSession` object. This
    ID is sent as a cookie to your browser or, if you are blocking cookies, as a hidden
    field in the URL every time a request is made. If you already have the ID in a
    cookie, then that will be used. The server manages the ID; you do not need to
    do anything. The server uses this ID to manage the `HttpSession` object and ensure
    that your requests are the only ones that have access. You access the session
    object with the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你第一次调用应用程序中的 servlet 时，你将收到一个 ID 号码，该号码用于标识一个 `HttpSession` 对象。这个 ID 作为 cookie
    发送到你的浏览器，或者如果你正在阻止 cookie，则在每次请求时作为 URL 中的隐藏字段发送。如果你已经在 cookie 中有了这个 ID，那么就会使用它。服务器管理这个
    ID；你不需要做任何事情。服务器使用这个 ID 来管理 `HttpSession` 对象，并确保你的请求是唯一可以访问的。你可以使用以下代码访问会话对象：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If an `HttpSession` object associated with your ID exists, then it is returned.
    If it does not exist, then a new `HttpSession` object with its own ID is returned.
    We will use one of two methods in the `HttpSession` object, one for reading and
    one for writing. If you wanted to preserve the `User` object in this example so
    that it can be used in another servlet, you will code the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与你的 ID 关联的 `HttpSession` 对象存在，则返回它。如果不存在，则返回一个新的 `HttpSession` 对象，它有自己的 ID。我们将在
    `HttpSession` 对象中使用两种方法，一种用于读取，一种用于写入。如果你想在示例中保留 `User` 对象，以便在另一个 servlet 中使用，你将编写以下代码：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This `HttpSession` object will remain valid until the `HttpSession` timer,
    usually 30 minutes, ends or you call `session.invalidate()`. If we want to retrieve
    the `User` object in another servlet, then we can write the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`HttpSession`对象将保持有效，直到`HttpSession`计时器，通常是30分钟，结束或者你调用`session.invalidate()`。如果我们想在另一个servlet中检索`User`对象，那么我们可以写以下内容：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You do not want to keep data around any longer than is necessary. Data stored
    in an `HttpServletRequest` object is lost after a response is given. In many cases,
    this is sufficient. However, if you were writing a shopping cart application,
    you would want to preserve whatever a client chooses as they move from page to
    page on the site. Here is where an `HttpSession` object is used.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你不希望保留比必要更长的时间数据。存储在`HttpServletRequest`对象中的数据在给出响应后就会丢失。在许多情况下，这已经足够了。然而，如果你正在编写一个购物车应用，你希望保留客户在网站中从一个页面移动到另一个页面时所做的选择。这就是`HttpSession`对象被使用的地方。
- en: Let us now look at a file that we can use to configure how a server deals with
    servlets, called `web.xml`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个可以用来配置服务器如何处理servlets的文件，称为`web.xml`。
- en: Configuring deployment with the web.xml file
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用web.xml文件配置部署
- en: In the `WEB-INF` folder of a web project, there is usually a file named `web.xml`.
    It was mandatory before the `@WebServlet` annotation was introduced. With the
    annotation, the application server can determine on its own which files are servlets
    and which are not. There is more that you can do in this file than just list servlets.
    For this reason, I advise you to always have a `web.xml` file.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web项目的`WEB-INF`文件夹中，通常有一个名为`web.xml`的文件。在`@WebServlet`注解引入之前，这是强制性的。有了这个注解，应用服务器可以自己确定哪些文件是servlet，哪些不是。在这个文件中，你可以做的不仅仅是列出servlet。因此，我建议你始终保留一个`web.xml`文件。
- en: 'Our descriptor will be quite basic:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的描述符将会相当基础：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We have a display name that the application server can use in a report, followed
    by the welcome page. The welcome page is the name of the page to display if the
    URL does not include the page name. Let’s say you type the following in your browser:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个显示名称，应用服务器可以在报告中使用，然后是欢迎页面。欢迎页面是当URL不包含页面名称时显示的页面名称。假设你在浏览器中输入以下内容：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Instead of writing that, you only need to write the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是写上面那样，你只需要写以下内容：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The HTTP protocol is stateless. This means that every time you make a request,
    the server behaves as if it is the first time you have visited the site. The application
    server can remember you by using an `HttpSession` object. This object has a default
    lifetime of 30 minutes since your last visit to the website. When the time is
    up, the object is invalidated, and the server will no longer remember you. You
    can change the length of time by adding this to the `web.xml` file:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议是无状态的。这意味着每次你发起请求时，服务器都会表现得像是你第一次访问网站。应用服务器可以通过使用`HttpSession`对象来记住你。这个对象自你上次访问网站以来有一个默认的30分钟生命周期。当时间到了，对象就会失效，服务器将不再记住你。你可以通过在`web.xml`文件中添加以下内容来改变这个时间长度：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In some cases, you may have data, in the form of a string, which is common
    to every servlet in the application – for example, the company email address that
    needs to appear on every page. We use `context-param` for this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能有一些数据，以字符串的形式存在，这些数据在应用中的每个servlet中都是通用的——例如，需要在每个页面上显示的公司电子邮件地址。我们使用`context-param`来处理这种情况：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To access this in a servlet, we just need the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要在servlet中访问这个文件，我们只需要以下内容：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You should now be able to get a web application based on a servlet up and running.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够启动一个基于servlet的Web应用。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the basics of a web application. The center of
    this universe is the servlet. There are many other frameworks, such as Spring,
    that provide an alternative set of libraries, yet all these frameworks sit on
    top of and depend upon the servlet specification, along with other Jakarta libraries.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Web应用的基础。这个宇宙的中心是servlet。还有许多其他框架，如Spring，提供了另一组库，但所有这些框架都建立在servlet规范之上，并依赖于Jakarta库。
- en: Jakarta is standards-based. What this means is that by adhering to the HTTP
    protocols, it can provide services to any frontend, such as React.js, Bootstrap,
    and Angular. In the next chapter, we will look at one frontend programming library,
    Jakarta Faces, that is part of the Jakarta framework.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta是基于标准的。这意味着通过遵循HTTP协议，它可以向任何前端提供服务，例如React.js、Bootstrap和Angular。在下一章中，我们将探讨一个前端编程库，即Jakarta
    Faces，它是Jakarta框架的一部分。
- en: We used the GlassFish server in this chapter, but there are a number of other
    choices for a Java application server. For example, the Payara server is based
    on Glassfish, but as it is backed by the Payara company, it provides commercial
    support that is not available with Glassfish. There are also servers from Red
    Hat, IBM, and others. There is usually a community version that you can use without
    paying for a commercial license.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了GlassFish服务器，但还有许多其他选择用于Java应用程序服务器。例如，Payara服务器基于Glassfish，但由于它由Payara公司支持，因此它提供了Glassfish所没有的商业支持。还有来自Red
    Hat、IBM和其他公司的服务器。通常有一个社区版本，您可以在不支付商业许可证费用的情况下使用。
- en: As we looked at server-side programming, we needed to make changes to our Maven
    `pom.xml` file. With these in place, we were able to create a `.war` file for
    use on the server as easily as we created desktop `.``jar` files.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看服务器端编程时，我们需要对我们的Maven `pom.xml` 文件进行修改。有了这些，我们就能像创建桌面`.jar`文件一样轻松地创建用于服务器的`.war`文件。
- en: Next up, we will look deeper into Jakarta EE by examining an application that
    brings the Financial Calculator we saw in the previous chapter to the web.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过检查一个将上一章中看到的财务计算器应用到网络的应用程序来更深入地了解Jakarta EE。
- en: Further reading
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Jakarta EE: [https://jakarta.ee/](https://jakarta.ee/'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Jakarta EE: [https://jakarta.ee/](https://jakarta.ee/)'
- en: )
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'HTTP methods: [https://www.tutorialspoint.com/http/http_methods.htm](https://www.tutorialspoint.com/http/http_methods.htm)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'HTTP方法: [https://www.tutorialspoint.com/http/http_methods.htm](https://www.tutorialspoint.com/http/http_methods.htm)'
