["```java\nlazy val akkaVersion = \"2.5.13\"\nlibraryDependencies += \"com.typesafe.akka\" %% \"akka-actor-typed\" % akkaVersion\n```", "```java\nimport akka.actor.typed._\nimport akka.actor.typed.scaladsl._\n```", "```java\nfinal case class Groceries(eggs: Int, flour: Int, sugar: Int, chocolate: Int)\nfinal case class Dough(weight: Int)\nfinal case class RawCookies(count: Int)\nfinal case class ReadyCookies(count: Int)\n```", "```java\nsealed trait Command\ncase class Put(rawCookies: Int, sender: ActorRef[Baker.Command]) extends Command\ncase class Extract(sender: ActorRef[Baker.Command]) extends Command\n```", "```java\ndef empty: Behaviors.Receive[Command] = Behaviors.receiveMessage[Command] {\n  case Put(rawCookies, sender) =>\n    val (inside, overflow: Option[RawCookies]) = insert(rawCookies)\n    overflow.foreach(sender.tell)\n    full(inside)\n}\n```", "```java\ndef full(count: Int): Behaviors.Receive[Command] = Behaviors.receiveMessage[Command] {\n  case Extract(sender) =>\n    sender ! ReadyCookies(count)\n    empty\n}\n```", "```java\nWarning:(18, 77) match may not be exhaustive.\n It would fail on the following input: Extract(_)\n def empty: Behaviors.Receive[Command] = Behaviors.receiveMessage[Command] {\n Warning:(25, 88) match may not be exhaustive.\n It would fail on the following input: Put(_, _)\n def full(count: Int): Behaviors.Receive[Command] = Behaviors.receiveMessage[Command] {\n```", "```java\ndef empty: Behaviors.Receive[Command] = Behaviors.receiveMessage[Command] {\n  case Put(rawCookies, sender) =>\n    val (inside, tooMuch) = insert(rawCookies)\n    tooMuch.foreach(sender.tell)\n    full(inside)\n  case Extract(sender) =>\n    sender ! ReadyCookies(0)\n    Behaviors.same\n}\n```", "```java\ndef full(count: Int): Behaviors.Receive[Command] = Behaviors.receiveMessage[Command] {\n  case Extract(sender) =>\n    sender ! ReadyCookies(count)\n    empty\n  case Put(rawCookies, sender) =>\n    sender ! RawCookies(rawCookies)\n    Behaviors.same\n}\n```", "```java\ndef spawnAnonymous[T](behavior: Behavior[T], props: Props = Props.empty): ActorRef[T]\n```", "```java\ndef spawn[T](behavior: Behavior[T], name: String, props: Props = Props.empty): ActorRef[T]\n```", "```java\nmixers-dispatcher {\n  executor = \"thread-pool-executor\"\n  type = PinnedDispatcher\n}\n```", "```java\nobject Chef {\n  sealed trait Command\n  final case class Mix(g: Groceries, manager: ActorRef[Manager.Command]) extends Command\n  def idle = Behaviors.receive[Command] {\n    case (context, mix@Mix(Groceries(eggs, flour, sugar, chocolate), manager)) =>\n      val props = DispatcherSelector.fromConfig(\"mixers-dispatcher\")\n      val mixers = for (i <- 1 to eggs) yield\n        context.spawn(Mixer.mix, s\"Mixer_$i\", props)\n      mixing\n  }\n  def mixing = Behaviors.unhandled[Command]i\n}\n```", "```java\ndef apply[T](guardian: Behavior[T],name: String): ActorSystem[T]\n```", "```java\nobject Mixer {\n  final case class Mix(groceries: Groceries, sender: ActorRef[Collect])\n  def mix = Behaviors.receiveMessage[Mix] {\n    case Mix(Groceries(eggs, flour, sugar, chocolate), sender) =>\n      Thread.sleep(3000)\n      sender ! Collect(Dough(eggs * 50 + flour + sugar + chocolate))\n      Behaviors.stopped\n  }\n}\n```", "```java\ndef child(name: String): Option[ActorRef[Nothing]]\n```", "```java\ndef children: Iterable[ActorRef[Nothing]]\n```", "```java\nval receptionist: ActorRef[Receptionist.Command] = context.system.receptionist\n```", "```java\nimport akka.actor.typed.receptionist.Receptionist._\n\nval SellerKey = ServiceKey[SellByList](\"GrocerySeller\")\n\nval seller = Behaviors.setup { ctx ⇒\n    ctx.system.receptionist ! Register(SellerKey, ctx.self)\n    Behaviors.receiveMessage[SellByList] {\n        case SellByList(list, toWhom) ⇒\n          import list._\n          toWhom ! Groceries(eggs, flour, sugar, chocolate)\n          Behaviors.same\n    }\n  }\n```", "```java\ndef idle: Behavior[Command] = Behaviors.setup { context =>\n  implicit val lookupTimeout: Timeout = 1.second\n  context.ask(context.system.receptionist)(Find(Shop.SellerKey)) {\n    case Success(listing: Listing) =>\n      listing\n        .serviceInstances(Shop.SellerKey)\n        .headOption\n        .map { seller =>\n          LookupSeller(seller)\n        }\n        .getOrElse {\n          NoSeller\n        }\n    case Failure(_) =>\n      NoSeller\n  }\n```", "```java\nBehaviors.receiveMessagePartial {\n  case OneSeller(seller) =>\n    val boy = context.spawn(Boy.goShopping, \"Boy\")\n    boy ! GoShopping(shoppingList, seller, context.self)\n    waitingForGroceries\n  case NoSeller =>\n    context.log.error(\"Seller could not be found\")\n    idle\n}\n```", "```java\nobject Boy {\n  final case class GoShopping(shoppingList: ShoppingList,\n                              seller: ActorRef[SellByList],\n                              manager: ActorRef[Manager.Command])\n\n  val goShopping = Behaviors.receiveMessage[GoShopping] {\n    case GoShopping(shoppingList, seller, manager) =>\n      seller ! SellByList(shoppingList, manager)\n      Behaviors.stopped\n  }\n}\n```", "```java\ndef mixing = Behaviors.unhandled[Command]\n```", "```java\ndef mixing(mixers: Set[ActorRef[Mixer.Mix]],\n           collected: Int,\n           manager: ActorRef[Manager.Command]): Behavior[Command]\n```", "```java\nBehaviors.receivePartial {\n  case (context, Collect(dough, mixer)) =>\n    val mixersToGo = mixers - mixer\n    val pastryBuf = collected + dough.weight\n    context.stop(mixer)\n    if (mixersToGo.isEmpty) {\n      manager ! ReceivePastry(Dough(pastryBuf))\n      idle\n    } else {\n      mixing(mixersToGo, pastryBuf, manager)\n    }\n}\n```", "```java\nclass MotorOverheatException extends Exception\nclass SlowRotationSpeedException extends Exception\nclass StrongVibrationException extends Exception\n```", "```java\ncase (_, Mix(Groceries(eggs, flour, sugar, chocolate), sender)) =>\n  if (Random.nextBoolean()) throw new MotorOverheatException\n  ...\n```", "```java\nval monitoring: PartialFunction[(ActorContext[Mix], Signal), Behavior[Mix]] = {\n  case (ctx, PostStop) =>\n    ctx.log.info(\"PostStop {}\", context.self)\n    Behaviors.same\n  case (context, PreRestart) =>\n    ctx.log.info(\"PreRestart {}\", context.self)\n    Behaviors.same\n  case (context, t: Terminated) =>\n    ctx.log.info(\"Terminated {} while {}\", context.self, t.failure)\n    Behaviors.same\n}\n```", "```java\n...\n [INFO] Opening Bakery\n [INFO] Go shopping to Actor[akka://Typed-Bakery/user/Seller#1376187311]\n [INFO] Mixing Groceries(13,650,130,65)\n [ERROR] [akka://Typed-Bakery/user/Chef/Mixer_5] null\n ch12.Mixer$MotorOverheatException\n at ch12.Mixer$.$anonfun$mix$1(Mixer.scala:19)\n at akka.actor.typed.internal.BehaviorImpl$ReceiveBehavior.receive(BehaviorImpl.scala:73)\n ...\n at java.lang.Thread.run(Thread.java:745)\n[INFO] PostStop Actor[akka://Typed-Bakery/user/Chef/Mixer_5#-1604172140]\n ...\n```", "```java\ndef mix: Behavior[Mix] = Behaviors.receive[Mix] {\n ...\n}.receiveSignal(monitoring)\n```", "```java\nval controlledMix: Behavior[Mix] =\n  Behaviors\n    .supervise(mix)\n    .onFailure[MotorOverheatException](SupervisorStrategy.restart)\n```", "```java\n...\n [INFO] Mixing Groceries(6,300,60,30)\n [ERROR] Supervisor [restart] saw failure: null\n ch12.Mixer$MotorOverheatException\n at ch12.Mixer$.$anonfun$mix$1(Mixer.scala:29)\n ...\n[INFO] PreRestart Actor[akka://Typed-Bakery/user/Chef/Mixer_2#-1626989026]\n [INFO] PreRestart Actor[akka://Typed-Bakery/user/Chef/Mixer_4#-668414694]\n [INFO] PreRestart Actor[akka://Typed-Bakery/user/Chef/Mixer_4#-668414694]\n```", "```java\nval controlledMix: Behavior[Mix] =\n  Behaviors\n    .supervise(mix)\n    .onFailure[MotorOverheatException](SupervisorStrategy.resume)\n```", "```java\n...\n [INFO] Mixing Groceries(5,250,50,25)\n [ERROR] Supervisor [resume] saw failure: null\n ch12.Mixer$MotorOverheatException\n at ch12.Mixer$.$anonfun$mix$1(Mixer.scala:29)\n ...\n```", "```java\nval controlledMix: Behavior[Mix] =\n  Behaviors.supervise(\n  Behaviors.supervise(\n  Behaviors.supervise(\n          mix)          .onFailure[MotorOverheatException(SupervisorStrategy.stop))  .onFailure[SlowRotationSpeedException(SupervisorStrategy.restart))\n.onFailure[StrongVibrationException](SupervisorStrategy.resume)\n```", "```java\nBehaviors.supervise(mix).onFailure[SlowRotationSpeedException](\n  SupervisorStrategy.restartWithLimit(\n    maxNrOfRetries = 4, \n    withinTimeRange = 2.seconds))\n```", "```java\n...\n [INFO] Mixing Groceries(6,300,60,30)\n [ERROR] Supervisor [restartWithLimit(4, 2.000 s)] saw failure: null\n ch12.Mixer$MotorOverheatException\n at ch12.Mixer$.$anonfun$mix$1(Mixer.scala:26)\n ...\n [ERROR] Supervisor [restartWithLimit(4, 2.000 s)] saw failure: null\n ...\n [ERROR] Supervisor [restartWithLimit(4, 2.000 s)] saw failure: null\n ...\n [ERROR] Supervisor [restartWithLimit(4, 2.000 s)] saw failure: null\n ...\n [ERROR] [akka://Typed-Bakery/user/Chef/Mixer_1] null\n akka.actor.ActorInitializationException: akka://Typed-Bakery/user/Chef/Mixer_1: exception during creation at akka.actor.ActorInitializationException$.apply(Actor.scala:193)\n ...\n Caused by: ch12.Mixer$MotorOverheatException at ch12.Mixer$.$anonfun$mix$1(Mixer.scala:26)\n ...\n[INFO] Message [ch12.Mixer$Mix] without sender to Actor[akka://Typed-Bakery/user/Chef/Mixer_1#-263229034] was not delivered.\n```", "```java\nval mixers = for (i <- 1 to eggs) \n  yield context.spawn(Mixer.controlledMix, s\"Mixer_$i\")\nmixers.foreach(mixer => context.watchWith(mixer, BrokenMixer(mixer)))\n```", "```java\ncase class BrokenMixer(mixer: ActorRef[Mixer.Mix]) extends Command\n\ndef mixing(...): Behavior[Command] = Behaviors.receivePartial {\n      ...\n      case (context, BrokenMixer(m)) =>\n        context.log.warning(\"Broken mixer detected {}\", m)\n        context.self ! Collect(Dough(0), m)\n        Behaviors.same\n    }\n```", "```java\ndef turnOvenOn: Behavior[Command] = Behaviors.setup { context =>\n  val oven = context.spawn(Oven.empty, \"Oven\")\n  idle(oven)\n}\n```", "```java\ndef idle(oven: ActorRef[Oven.Command]): Behavior[Command] =\n  Behaviors.receivePartial {\n    case (context, BakeCookies(rawCookies, manager)) =>\n      oven ! Put(rawCookies.count, context.self)\n      Behaviors.withTimers { timers =>\n        timers.startSingleTimer(TimerKey, CheckOven, DefaultBakingTime)\n        baking(oven, manager)\n      }\n  }\n```", "```java\ndef baking(oven: ActorRef[Oven.Command],\n           manager: ActorRef[Manager.Command]): Behavior[Command] =\n  Behaviors.setup[Command] { context =>\n    val buffer = StashBuffer[Command](capacity = 100)\n    Behaviors.receiveMessage {\n      case CheckOven =>\n        oven ! Extract(context.self)\n        Behaviors.same\n      case c: TooManyCookies=>\n        buffer.stash(BakeCookies(c.raw, manager))\n        Behaviors.same\n      case c : BakeCookies =>\n        buffer.stash(c)\n        Behaviors.same\n      case CookiesReady(cookies) =>\n        manager ! ReceiveReadyCookies(cookies)\n        buffer.unstashAll(context, idle(oven))\n    }\n  }\n```", "```java\ndef waitingForGroceries = receiveMessagePartial[Command] {\n  case ReceiveGroceries(g) =>\n    context.log.info(\"Mixing {}\", g)\n    chef ! Chef.Mix(g, context.self)\n    waitingForPastry\n}\ndef waitingForPastry = receiveMessagePartial[Command] {\n  case ReceivePastry(p) =>\n    context.log.info(\"Forming {}\", p)\n    cook ! Cook.FormCookies(p, context.self)\n    waitingForRawCookies\n}\n...\n```", "```java\ndef manage(chef: ActorRef[Chef.Command],\n           cook: ActorRef[Cook.FormCookies],\n           baker: ActorRef[Baker.Command]): Behavior[Command] =\n  ...\n  def sendBoyShopping = receiveMessagePartial ...\n  def waitingForGroceries = receivePartial[Command] {\n   ... \n   manage(chef, cook, baker)\n  }\n  def waitingForPastry = receiveMessagePartial[Command] {\n    ...\n    manage(chef, cook, baker)\n  }\n  def waitingForRawCookies = receiveMessagePartial[Command] {\n    case ReceiveRawCookies(c) =>\n      baker ! Baker.BakeCookies(c, context.self)\n      manage(chef, cook, baker)\n  }\n  def waitingForReadyCookies = receiveMessagePartial[Command] {\n    case ReceiveReadyCookies(c) =>\n      context.log.info(\"Done baking cookies: {}\", c)\n      manage(chef, cook, baker)\n  }\n\n  lookupSeller orElse\n    sendBoyShopping orElse\n    waitingForGroceries orElse\n    waitingForPastry orElse\n    waitingForRawCookies orElse\n    waitingForReadyCookies\n}\n```", "```java\n\"com.typesafe.akka\" %% \"akka-cluster-typed\" % akkaVersion,\n```", "```java\nakka {\n  actor.provider = \"cluster\"\n  remote {\n    netty.tcp {\n      hostname = \"127.0.0.1\"\n      port = 2552\n    }\n  }\n  cluster.seed-nodes = [\n    \"akka.tcp://Typed-Bakery@127.0.0.1:2553\",\n    \"akka.tcp://Typed-Bakery@127.0.0.1:2552\"\n  ]\n}\n```", "```java\ninclude \"application\"\nakka.remote.netty.tcp.port = 2553\n\n```", "```java\nobject Store extends App {\n  val config = ConfigFactory.load(\"grocery.conf\")\n  val system = ActorSystem(seller, \"Typed-Bakery\", config)\n}\n```", "```java\nobject Bakery extends App {\n  ...\n  val system = ActorSystem(Manager.openBakery, \"Typed-Bakery\")\n}\n```", "```java\n\"com.typesafe.akka\" %% \"akka-actor-testkit-typed\" % akkaVersion % Test,\n\"org.scalatest\" %% \"scalatest\" % \"3.0.5\" % Test\n\n```", "```java\nimport akka.actor.testkit.typed.scaladsl.BehaviorTestKit\nimport org.scalatest.WordSpec\n\nclass SynchronousSpec extends WordSpec {\n\n  \"TestScenario\" should {\n    \"have test conditions\" in {\n      val testKit = BehaviorTestKit(behaviorToTest)\n      // ... testing logic\n    }\n  }\n}\n```", "```java\nclass AsyncronousSpec extends WordSpec with ActorTestKit with BeforeAndAfterAll {\n\n  override def afterAll: Unit = shutdownTestKit()\n\n  // actual testing code\n}\n```", "```java\n\"The boy should\" should {\n  \"forward given ShoppingList to the seller\" in {\n    val testKit = BehaviorTestKit(Boy.goShopping)\n    val seller = TestInbox[Shop.SellByList]()\n    val manager = TestInbox[Manager.Command]()\n    val list = ShoppingList(1, 1, 1, 1)\n    testKit.run(GoShopping(list, seller.ref, manager.ref))\n    seller.expectMessage(SellByList(list, manager.ref))\n    assert(!testKit.isAlive)\n    testKit.expectEffect(NoEffects)\n  }\n}\n```", "```java\n\"The chef should\" should {\n  \"create and destroy mixers as required\" in {\n    val mixerFactory = Mixer.mix(0 seconds)\n    val chef = BehaviorTestKit(Chef.idle(mixerFactory))\n    val manager = TestInbox[Manager.Command]()\n    val message = Mix(Groceries(1, 1, 1, 1), manager.ref)\n    val dispatcher = DispatcherSelector.fromConfig(\"mixers-dispatcher\")\n    chef.run(message)\n    chef.expectEffect(Spawned(mixerFactory, \"Mixer_1\", dispatcher))\n    val expectedByMixer = Mixer.Mix(Groceries(1, 1, 1, 1), chef.ref)\n    chef.childInbox(\"Mixer_1\").expectMessage(expectedByMixer)\n  }\n}\n```", "```java\ncontext.system.receptionist ! Register(SellerKey, context.self)\n```", "```java\ntype ReceptionistFactory = ActorContext[SellByList] => ActorRef[Receptionist.Command]\nval systemReceptionist: ReceptionistFactory = _.system.receptionist\ndef seller(receptionist: ReceptionistFactory) = setup { ctx ⇒\n    receptionist(ctx) ! Register(SellerKey, ctx.self)\n...\n```", "```java\n\"A seller in the shop\" should {\n  \"return groceries if given a shopping list\" in {\n    val receptionist = TestInbox[Receptionist.Command]()\n    val mockReceptionist: Shop.ReceptionistFactory = _ => receptionist.ref\n    val seller = BehaviorTestKit(Shop.seller(mockReceptionist))\n    val inbox = TestInbox[Manager.Command]()\n    val message = ShoppingList(1,1,1,1)\n    seller.run(SellByList(message, inbox.ref))\n    inbox.expectMessage(ReceiveGroceries(Groceries(1, 1, 1, 1)))\n    receptionist.expectMessage(Register(Shop.SellerKey, seller.ref))\n    seller.expectEffect(NoEffects)\n  }\n}\n```", "```java\noverride def config: Config = ManualTime.config\nval manualTime: ManualTime = ManualTime()\n```", "```java\n\"The baker should\" should {\n  \"bake cookies in batches\" in {\n    val oven = TestProbe[Oven.Command]()\n    val manager = TestInbox[Manager.Command]()\n    val baker = spawn(Baker.idle(oven.ref))\n    baker ! BakeCookies(RawCookies(1), manager.ref)\n    oven.expectMessage(Oven.Put(1, baker))\n    val justBeforeDone = DefaultBakingTime - 1.millisecond\n    manualTime.expectNoMessageFor(justBeforeDone, oven)\n    manualTime.timePasses(DefaultBakingTime)\n    oven.expectMessage(Extract(baker))\n  }\n}\n```", "```java\nsbt \"runMain ch12.Store\"\n sbt \"runMain ch12.Bakery\"\n```"]