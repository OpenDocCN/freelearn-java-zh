- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jakarta Faces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover `web.xml` has been optional since Java EE 6 means
    that in many cases we can write complete web applications without having to write
    a single line of XML.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Jakarta Faces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing our first Faces application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom data validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing default messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Example source code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch06_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch06_src).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Jakarta Faces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will give a general overview of what developing web applications
    with Jakarta Faces entails, providing some background information necessary before
    digging into the nitty gritty of Jakarta Faces.
  prefs: []
  type: TYPE_NORMAL
- en: Facelets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Facelets** is the default Jakarta Faces view technology. Facelets are written
    using standard **Extensible Hypertext Markup Language** (**XHTML**), using Jakarta
    Faces-specific XML namespaces that provide Jakarta Faces-specific tags we can
    use to develop the user interface of our web applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Optional faces-config.xml
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most cases, configuring a Jakarta Faces application is not necessary, as
    it follows a convention over configuration approach.
  prefs: []
  type: TYPE_NORMAL
- en: For some specific cases, when overriding Jakarta Faces’ default error messages
    for example, we still need to configure Jakarta Faces via a `faces-config.xml`
    configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Standard resource locations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Resources** are artifacts a page or Jakarta Faces component needs to render
    properly. Resource examples are CSS stylesheets, JavaScript files, and images.'
  prefs: []
  type: TYPE_NORMAL
- en: When working with Jakarta Faces, resources can be placed in a subdirectory in
    a folder called `resources` either at the root of the WAR file or in its `META-INF`
    directory. By convention, Jakarta Faces components know they can retrieve resources
    from one of these two locations.
  prefs: []
  type: TYPE_NORMAL
- en: In order to avoid cluttering the resources directory, resources are typically
    placed in a subdirectory. This subdirectory is referred to from the `library`
    attribute of Faces components.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we could place a CSS stylesheet called `styles.css` in `/resources/css/styles.css`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our Faces pages, we could retrieve this CSS file using the `<h:outputStylesheet>`
    tag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The value of the `library` attribute must match the subdirectory where our stylesheet
    is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we could have a JavaScript file at `/resources/scripts/somescript.js`
    and an image at `/resources/images/logo.png`, and we could access these resources
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in each case, the value of the `library` attribute matches the corresponding
    subdirectory name in the `resources` directory, and the value of the name attribute
    matches the resource’s filename.
  prefs: []
  type: TYPE_NORMAL
- en: Developing our first Faces application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To illustrate basic Jakarta Faces concepts, we will develop a simple application
    consisting of two Facelet pages and a single **Contexts and Dependency Injection**
    (**CDI**) named bean.
  prefs: []
  type: TYPE_NORMAL
- en: Facelets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned in this chapter’s introduction, the default view technology
    for Jakarta Faces is called Facelets. Facelets need to be written using standard
    XML. The most popular way of developing Facelet pages is to use XHTML in conjunction
    with Jakarta Faces-specific XML namespaces. The following example shows what a
    typical Facelet page looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 6**.1* illustrates how our Facelets page renders in the browser after
    deploying our code and entering some data.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Rendered Facelets page](img/B21231_6_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Rendered Facelets page
  prefs: []
  type: TYPE_NORMAL
- en: Pretty much any Facelet page will include the two namespaces illustrated in
    the example. The first namespace (`) is for tags that render HTML components.
    By convention, the prefix **h**` **(for HTML) is used when using this tag library.**
  prefs: []
  type: TYPE_NORMAL
- en: '**The second namespace (**`) is the core Faces tag library. By convention,
    the prefix **f**` **(for Faces) is used when using this tag library.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The first Faces-specific tags we see in the preceding example are the `<h:head>`
    and the `<h:body>` tags. These tags are analogous to the standard HTML `<head>`
    and `<body>` tags and are rendered as such when the page is displayed in the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: The `<h:outputStylesheet>` tag is used to load a CSS stylesheet from a well-known
    location (Jakarta Faces standardizes the locations of resources, such as CSS stylesheets
    and javascript files, as previously discussed in this chapter). The value of the
    `library` attribute must correspond to the directory where the CSS file resides
    (this directory must be in the `resources` directory). The `name` attribute must
    correspond to the name of the CSS stylesheet we wish to load.
  prefs: []
  type: TYPE_NORMAL
- en: The next tag we see is the `<h:form>` tag. This tag generates an HTML form when
    the page is rendered. As can be seen in the example, unlike regular HTML, there
    is no need to specify an `action` or a `method` attribute for this tag. As a matter
    of fact, there is no `action` attribute or `method` attribute for this tag. The
    `action` attribute for the rendered HTML form will be generated automatically,
    and the `method` attribute will always be `"post"`. The `id` attribute of `<h:form>`
    is optional; however, it is a good idea to always add it since it makes debugging
    Faces applications easier.
  prefs: []
  type: TYPE_NORMAL
- en: The following tag we see is the `<h:messages>` tag. As its name implies, this
    tag is used to display any messages. As we will see shortly, Faces can automatically
    generate validation messages; they will be displayed inside this tag. Additionally,
    arbitrary messages can be added programmatically via the `addMessage()` method
    defined in `jakarta.faces.context.FacesContext`.
  prefs: []
  type: TYPE_NORMAL
- en: The next Jakarta Faces tag we see is `<h:panelGrid>`. This tag is roughly equivalent
    to an HTML table, but it works a bit differently. Instead of declaring rows (`<tr>`)
    and cells (`<td>`), the `<h:panelGrid>` tag has a `columns` attribute. The value
    of this attribute indicates the number of columns in the table rendered by this
    tag. As we place components inside this tag, they will be placed in a row until
    the number of columns defined in the `columns` attribute is reached, then the
    next component will be placed in the next row. In the example, the value of the
    `columns` attribute is `2`, therefore the first two tags will be placed in the
    first row, the next two will be placed in the second row, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Using HTML tables for page layout was a popular practice in the early days of
    web development. This practice fell out of favor with the advent of CSS. Most
    modern Facelets pages use CSS for layout, but we thought it was worth pointing
    out the layout capabilities provided by Jakarta Faces.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting attribute of `<h:panelGrid>` is the `columnClasses` attribute.
    This attribute assigns a CSS class to each column in the rendered table. In the
    example, two CSS classes (separated by a comma) are used as the value for this
    attribute. This has the effect of assigning the first CSS class to the first column
    and the second one to the second column. Had there been three or more columns,
    the third one would have gotten the first CSS class, the fourth one the second
    one, and so on, alternating between the first one and the second one.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing generated HTML markup
  prefs: []
  type: TYPE_NORMAL
- en: We can view the generated HTML markup of our Facelets page by right-clicking
    on the browser window and selecting **View** **Page Source**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clarify how this works, the next code snippet illustrates a portion of the
    source of the HTML markup generated by the preceding page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice how each `<td>` tag has an alternating CSS tag of `"rightAlign"` or `"leftAlign"`,
    we achieved this by assigning the value `"rightAlign,leftAlign"` to the `columnClasses`
    attribute of `<h:panelGrid>`. We should note that the CSS classes we are using
    in our example are defined in the CSS stylesheet we loaded via `<h:outputStylesheet>`,
    which we discussed earlier. The values of all the `name` and `id` attributes of
    the generated HTML tags are a combination of the ID we gave to the `<h:form>`
    component, plus the ID of each individual component. Notice that we didn’t assign
    an ID to the `<h:commandButton>` component near the end of the page, so the Faces
    runtime assigned one automatically and used it to populate the `name` attribute
    of the generated submit button.
  prefs: []
  type: TYPE_NORMAL
- en: At this point in the example, we start adding components inside `<h:panelGrid>`.
    These components will be rendered inside the table rendered by `<h:panelGrid>`.
    As we mentioned before, the number of columns in the rendered table is defined
    by the `columns` attribute of `<h:panelGrid>`. Therefore, we don’t need to worry
    about columns (or rows) we just start adding components and they will be placed
    in the right place.
  prefs: []
  type: TYPE_NORMAL
- en: The next tag we see is the `<h:outputLabel>` tag. This tag is rendered as an
    HTML `label` element. Labels are associated with other components via the `for`
    attribute, whose value must match the ID of the component that the label is for.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see the `<h:inputText>` tag. This tag generates a text field on the
    rendered page; its `label` attribute is used for any validation messages. It lets
    the user know what field the message refers to.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Although it is not required for the value of the `label` attribute of `<h:inputText>`
    to match the label displayed on the page, it is highly recommended. If there is
    an error, this will let the user know exactly what field the error message is
    referring to.
  prefs: []
  type: TYPE_NORMAL
- en: Of particular interest is the tag’s `value` attribute. What we see as the value
    for this attribute is a `firstName` in a named bean called `customer`. When a
    user enters a value for this text field and submits the form, the corresponding
    property in the named bean is updated with this value. The tag’s `required` attribute
    is optional and valid values for it are `true` and `false`. If this attribute
    is set to `true`, the container will not let the user submit the form until the
    user enters some data for the text field. If the user attempts to submit the form
    without entering a required value, the page will be reloaded and an error message
    will be displayed inside the `<h:messages>` tag, as illustrated in *Figure 6**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Required field data validation](img/B21231_6_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Required field data validation
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.2* illustrates the default error message shown when the user attempts
    to save the form in the example without entering a value for the customer’s first
    name. The first part of the message (`label` attribute of the corresponding `<h:inputTextField>`
    tag. The text of the message can be customized, as well as its style (font, color,
    etc.). We will cover how to do this later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Project stages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having an `<h:messages>` tag on every Jakarta Faces page is a good idea. Without
    it, the user might not see validation messages and will have no idea why the form
    submission is not going through. By default, Jakarta Faces validation messages
    do not generate any output in the application server log. A common mistake new
    Jakarta Faces developers make is failing to add an `<h:messages>` tag to their
    pages. Without it, if validation fails, then navigation seems to fail for no reason
    (the same page is rendered if navigation fails, and without an `<h:messages>`
    tag, no error messages are displayed in the browser).
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this situation, we can take advantage of Jakarta Faces **project stages**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following project stages are defined in Jakarta Faces:'
  prefs: []
  type: TYPE_NORMAL
- en: Production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UnitTest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SystemTest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can define the project stage as an initialization parameter to the Faces
    servlet in `web.xml` or as a custom `web.xml` are needed between environments.
  prefs: []
  type: TYPE_NORMAL
- en: How you set up a custom JNDI resource is dependent on your application server.
    Consult your application server documentation for details. For example, if we
    are using `GlassFish` to deploy our application, we can set up a custom JNDI resource
    by logging in to the web console, navigating to **JNDI** | **Custom Resources**,
    and then clicking the **New...** button, which allows us to add our custom JNDI
    resource, as illustrated in *Figure 6**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Defining Jakarta Faces project stage in GlassFish as a JNDI
    resource](img/B21231_6_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Defining Jakarta Faces project stage in GlassFish as a JNDI resource
  prefs: []
  type: TYPE_NORMAL
- en: 'To define the Jakarta Faces project stage, we need to enter the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **JNDI Name** | `jakarta.faces.PROJECT_STAGE` |'
  prefs: []
  type: TYPE_TB
- en: '| **Resource Type** | `java.lang.String` |'
  prefs: []
  type: TYPE_TB
- en: Table 6.1 – Setting the Jakarta Faces project stage in GlassFish
  prefs: []
  type: TYPE_NORMAL
- en: 'After entering the two preceding values, the **Factory Class** field will be
    automatically populated with the following value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After entering the values, we need to add a new property with a name of `value`
    and a value corresponding to the project stage we wish to use (**Development**,
    our example).
  prefs: []
  type: TYPE_NORMAL
- en: Once we add our custom JNDI resource, we need to update our `web.xml` configuration
    file to read it, this step is the same across Jakarta EE implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example `web.xml` configuration file illustrates how to do the
    Jakarta Faces project stage so that our application can use it successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `<resource-ref>` tag in `web.xml` allows us to access JNDI resources defined
    in our application server. In our case, we want to access the project stage of
    our Faces application.
  prefs: []
  type: TYPE_NORMAL
- en: '`<res-ref-name>` gives our JNDI resource a name our code can use to look up
    our JNDI resource. Our Jakarta Faces implementation will look for a JNDI resource
    named `faces/ProjectStage`, and, if one is found, will use it to determine our
    project stage.'
  prefs: []
  type: TYPE_NORMAL
- en: '`<res-type>` allows us to specify the type of the resource we are looking for,
    as arbitrary Java objects can be looked up via JNDI. When setting the Jakarta
    Faces project stage, the value of this tag must always be `java.lang.String`.'
  prefs: []
  type: TYPE_NORMAL
- en: We specify the name of the resource in the application server JNDI tree via
    the `<mapped-name>` tag. By convention, this value must always be `jakarta.faces.PROJECT_STAGE`
    when setting up the Jakarta Faces project stage via JNDI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting the project stage allows us to perform some logic only if we are running
    in a specific stage. For instance, in one of our named beans, we could have code
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, project stages allow us to modify our code’s behavior for different
    environments. More importantly, setting the project stage allows Jakarta Faces
    to behave differently based on the project stage setting. In this context, setting
    the project stage to development results in additional debugging information to
    be displayed on the rendered page. Therefore, if we forget to add an `<h:messages>`
    tag to our page; our project stage is Development, and validation fails, a validation
    error will be displayed on the page even if we omit the `<h:messages>` component.
    This is illustrated in *Figure 6**.4*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure  \uFEFF\uFEFF6.4\uFEFF – Debugging information displayed when the\
    \ project stage is in Development](img/B21231_6_04.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Debugging information displayed when the project stage is in Development
  prefs: []
  type: TYPE_NORMAL
- en: In the default Production stage, this error message is not displayed on the
    page, leaving us confused as to why our page navigation doesn’t seem to be working.
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notice that each `<h:inputField>` tag has a nested `<f:validateLength>` tag.
    As its name implies, this tag validates that the entered value for the text field
    is between a minimum and maximum length. Minimum and maximum values are defined
    by the tag’s `minimum` and `maximum` attributes. `<f:validateLength>` is one of
    the standard validators included with Jakarta Faces. Just like with the `required`
    attribute of `<h:inputText>`, Jakarta Faces will automatically display a default
    error message when a user attempts to submit a form with a value that does not
    validate, as illustrated in *Figure 6**.5*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF\uFEFF6.5 – Length validation](img/B21231_6_05.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Length validation
  prefs: []
  type: TYPE_NORMAL
- en: The default message text and CSS style for any Jakarta Faces validation message
    can be overridden; we will cover how to do this later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to `<f:validateLength>`, Jakarta Faces includes other standard
    validators, which are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Validation Tag** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `<``f:validateBean>` | Bean validation allows us to validate named bean values
    by using annotations in our named beans without having to add validators to our
    Jakarta Faces tags. This tag allows us to fine-tune Bean Validation if necessary.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<``f:validateDoubleRange>` | Validates that the input is a valid `Double`
    value between the two values specified by the tag’s `minimum` and `maximum` attributes,
    inclusive |'
  prefs: []
  type: TYPE_TB
- en: '| `<``f:validateLength>` | Validates that the input’s length is between the
    values specified by the tag’s `minimum` and `maximum` values, inclusive |'
  prefs: []
  type: TYPE_TB
- en: '| `<``f:validateLongRange>` | Validates that the input is a valid `Double`
    value between the values specified by the tag’s `minimum` and `maximum` attributes,
    inclusive |'
  prefs: []
  type: TYPE_TB
- en: '| `<``f:validateRegex>` | Validates that the input matches a regular expression
    pattern specified in the tag’s `pattern` attribute |'
  prefs: []
  type: TYPE_TB
- en: '| `<``f:validateRequired>` | Validates that the input is not empty. This tag
    is equivalent to setting the `required` attribute to `true` in the parent input
    field |'
  prefs: []
  type: TYPE_TB
- en: Table 6.2 – Jakarta Faces validation tags
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in the description for `<f:validateBean>`, we briefly mentioned
    **Bean Validation**. The Bean Validation API aims to standardize JavaBean validation.
    JavaBeans are used by several other APIs that previously had to implement their
    own validation logic. Jakarta Faces leverages Bean Validation to help validate
    named bean properties.
  prefs: []
  type: TYPE_NORMAL
- en: If we wish to take advantage of Bean Validation, all we need to do is annotate
    the desired field with the appropriate Bean Validation annotation, without having
    to explicitly use a Jakarta Faces validator.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For the complete list of Bean Validation annotations, refer to the `jakarta.validation.constraints`
    package in the Jakarta EE 10 API documentation at [https://jakarta.ee/specifications/platform/10/apidocs/](https://jakarta.ee/specifications/platform/10/apidocs/).
  prefs: []
  type: TYPE_NORMAL
- en: Grouping components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`<h:panelGroup>` is the next new tag in the example. Typically, `<h:panelGroup>`
    is used to group several components together so that they occupy a single cell
    in `<h:panelGrid>`. This can be accomplished by adding components inside `<h:panelGroup>`
    and adding `<h:panelGroup>` to `<h:panelGrid>`. As can be seen in the example,
    this particular instance of `<h:panelGroup>` has no child components. In this
    particular case, the purpose of `<h:panelGroup>` is to have an empty cell and
    make the next component, `<h:commandButton>`, align with all other input fields
    in the form.'
  prefs: []
  type: TYPE_NORMAL
- en: Form submission
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`<h:commandButton>` renders an HTML submit button in the browser. Just like
    with standard HTML, its purpose is to submit the form. Its `value` attribute simply
    sets the button’s label. This tag’s `action` attribute is used for navigation,
    the next page to show is based on the value of this attribute. The `action` attribute
    can have a string constant or a **method binding expression**, meaning that it
    can point to a method in a named bean that returns a string.'
  prefs: []
  type: TYPE_NORMAL
- en: If the base name of a page in our application matches the value of the `action`
    attribute of a `<h:commandButton>` tag, then we navigate to this page when clicking
    the button. In our example, our confirmation page is called `confirmation.xhtml`,
    therefore by convention, this page will be shown when the button is clicked, since
    the value of its `action` attribute (`"confirmation"`) matches the base name of
    the page.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Even though the label for the button reads **Save**, in our simple example,
    clicking on the button won’t actually save any data.
  prefs: []
  type: TYPE_NORMAL
- en: Named beans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jakarta Faces includes tight integration with `@Named` annotation at the class
    level. Here is the named bean for our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `@Named` class annotation designates this bean as a CDI named bean. This
    annotation has an optional `value` attribute we can use to give our bean a logical
    name to use in our Jakarta Faces pages. However, by convention, the value of this
    attribute is the same as the class name (`Customer`, in our case), with its first
    character switched to lowercase. In our example, we let this default behavior
    take place, therefore we access our bean’s properties via the `customer` logical
    name. Notice the `value` attribute of any of the input fields in our example page
    to see this logical name in action.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, other than the `@Named` and `@RequestScoped` annotations, there
    is nothing special about this bean. It is a standard JavaBean with private properties
    and corresponding getter and setter methods. The `@RequestScoped` annotation specifies
    that the bean should live through a single request. The different scopes available
    to CDI named beans are covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Named bean scopes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Named beans always have a scope. A named bean scope defines the lifespan of
    the application. The named bean scope is defined by a class-level annotation.
    The following table lists all valid named bean scopes.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Named Bean** **Scope Annnotation** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `@``ApplicationScoped` | The same instance of application-scoped named beans
    is available to all of our application’s clients. If one client modifies the value
    of an application-scoped named bean, the change is reflected across clients. |'
  prefs: []
  type: TYPE_TB
- en: '| `@``SessionScoped` | An instance of each session-scoped named bean is assigned
    to each of our application’s clients. A session-scoped named bean can be used
    to hold client-specific data across requests. |'
  prefs: []
  type: TYPE_TB
- en: '| `@``RequestScoped` | Request-scoped named beans only live through a single
    HTTP request. |'
  prefs: []
  type: TYPE_TB
- en: '| `@``Dependent` | Dependent-scoped named beans are assigned the same scope
    as the bean they are injected into. |'
  prefs: []
  type: TYPE_TB
- en: '| `@``ConversationScoped` | The conversation scope can span multiple requests
    but is typically shorter than the session scope. |'
  prefs: []
  type: TYPE_TB
- en: '| `@``ClientWindowScoped` | Client Window scoped beans are kept in memory until
    the current web browser window or tab is closed. |'
  prefs: []
  type: TYPE_TB
- en: Table 6.3 – CDI scope annotations
  prefs: []
  type: TYPE_NORMAL
- en: Named bean scopes allow us to dictate the life cycle of CDI named beans. By
    using one of the named bean scopes listed in the preceding table, we can control
    when our named beans are created and destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Static navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As can be seen in our input page, when clicking on the `customer_data_entry.xhtml`
    page, our application will navigate to a page called `confirmation.xhtml`. This
    happens because we are taking advantage of the convention over configuration capabilities
    of Jakarta Faces, in which if the value of the `action` attribute of a command
    button or link matches the base name of another page, then this navigation takes
    us to this page. This behavior is known as static navigation. Jakarta Faces also
    supports dynamic navigation, in which the landing page can be determined based
    on some business logic, we discuss dynamic navigation in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Same page reloading when clicking on a button or Link that should navigate to
    another page?
  prefs: []
  type: TYPE_NORMAL
- en: If navigation does not seem to be working properly, chances are there is a typo
    in the value of this attribute. Remember that by convention, Jakarta Faces will
    look for a page whose base name matches the value of the `action` attribute of
    a command button or link.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source for `confirmation.xhtml` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `<h:outputText>` we see on the confirmation page is the only tag we haven’t
    covered before. This tag simply displays the value of its value attribute to the
    rendered page, its `value` attribute can be a simple string or a value binding
    expression. Since the value binding expressions in our `<h:outputText>` tags are
    the same expressions used in the previous page for the `<h:inputText>` tags, their
    values will correspond to the data the user entered. We can see how the page is
    rendered in *Figure 6**.6*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF\uFEFF6.6 – Example confirmation page](img/B21231_6_06.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Example confirmation page
  prefs: []
  type: TYPE_NORMAL
- en: In traditional (i.e. non-Jakarta Faces) Java web applications, we define URL
    patterns to be processed by specific servlets. Specifically for Jakarta Faces,
    the suffix `.faces` is commonly used. Another commonly used URL mapping for Faces
    is the `/faces` prefix. Under certain conditions, modern application servers automatically
    add all both mappings to the `faces` servlet. If these conditions are met, we
    don’t have to specify any URL mappings at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'If any of the following conditions is met, then the `FacesServlet` will be
    automatically mapped:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a `faces-config.xml` file in the `WEB-INF` directory of our web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a `faces-config.xml` file in the `META-INF` directory of one of the
    dependencies of our web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a filename ending in `.faces-config.xml` in the `META-INF` directory
    of one of the dependencies of our web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We declare a context parameter named `jakarta.faces.CONFIG_FILES` in our `web.xml`
    or a `web-fragment.xml` in one of the dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We pass a non-empty set of classes when invoking the `onStartup()` method of
    `ServletContextInitializer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When none of these conditions are met, we need to explicitly map the Jakarta
    Faces servlet in our `web.xml` deployment descriptor, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The URL we used for the pages in our application was the name of our Facelets
    pages prefixed by `/faces`. We specify this in our `<servlet-mapping>` tag in
    our `web.xml` configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, we may not know ahead of time what the next page in the application
    workflow would be, we need to run some business logic to determine what page to
    display next. For example, we may want to navigate to a confirmation page if everything
    went as expected when submitting our data, or we may want to navigate to an error
    page, or even back to the input page if there was an error processing the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how we can implement dynamic navigation in
    Jakarta Faces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To achieve dynamic navigation, we need to modify the action attribute of our
    command button to be a Jakarta Expression Language method expression, that is,
    an expression that maps to a method in one of our CDI named beans. For dynamic
    navigation, the method in the expression must take no arguments and return a string.
    In our example, we are using a method called `saveCustomer()` in a CDI named bean
    named `customerController`, therefore our expression is `#{customerController.saveCustomer}`.
    We’ll take a look at the implementation of our `saveCustomer()` method next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Our example application adheres to the Model-View-Controller design pattern.
    Our CDI named bean serves as a controller and decides what page to navigate to
    when the user submits the form. If everything goes well, we navigate to the confirmation
    page as usual. If there is a problem (an exception is caught), we navigate back
    to the input page (named `index.xhtml`) and display an error message to the user.
  prefs: []
  type: TYPE_NORMAL
- en: For illustration purposes, our `saveCustomer()` method simply saves the string
    representation of the `Customer` object to a file in the filesystem to force an
    exception and allow us to illustrate dynamic navigation. Our code flips the read-only
    attribute of the file in question (makes it read-only if it is writeable, and
    vice versa), then attempts to write to the file. When attempting to write to the
    file when it is read-only, an exception is thrown and we navigate back to the
    input page, as illustrated in *Figure 6**.7*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF\uFEFF6.7\uFEFF – Dynamic navigation](img/B21231_6_07.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Dynamic navigation
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes we need to provide custom business logic validation or implement validation
    rules not included with the standard Jakarta Faces validators. In cases like this,
    we can take advantage of Jakarta Faces custom validation functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Custom data validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to providing standard validators for our use, Jakarta Faces allows
    us to create custom validators. This can be done in one of two ways: by creating
    a custom validator class or by adding validation methods to our named beans.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom validators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the standard validators, Jakarta Faces allows us to create custom
    validators by creating a Java class implementing the `jakarta.faces.validator.Validator`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class implements an email validator, which we will use to validate
    the email text input field in our customer data entry screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `@FacesValidator` annotation registers our class as a Jakarta Faces custom
    validator class. The value of its `value` attribute is the logical name that Facelets’
    pages use to refer to it.
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen in the example, the only method we need to implement when implementing
    the `Validator` interface is a method called `validate()`. This method takes three
    parameters, an instance of `jakarta.faces.context.FacesContext`, an instance of
    `jakarta.faces.component.UIComponent` and an object. Typically, application developers
    only need to be concerned with the last two. The second parameter is the component
    whose data we are validating and the third parameter is the actual value. In our
    example validator, we cast `uiComponent` to `jakarta.faces.component.html.HtmlInputText`.
    This way, we get access to its `getLabel()` method, which we can use as part of
    the error message.
  prefs: []
  type: TYPE_NORMAL
- en: If the entered value is not a valid email address format, a new instance of
    `jakarta.faces.application.FacesMessage` is created, passing the error message
    to be displayed in the browser as its constructor parameter. We then throw a new
    `jakarta.faces.validator.ValidatorException`. The error message is then displayed
    in the browser. How it gets there is done behind the scenes by the Jakarta Faces
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Apache Commons Validator
  prefs: []
  type: TYPE_NORMAL
- en: Our custom validator uses **Apache Commons Validator** to do the actual validation.
    This library includes many common validations, such as dates, credit card numbers,
    ISBN numbers, and emails. When implementing a custom validator, it is worth investigating
    if this library already has a validator that we can use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use our validator on our page, we need to use the `<f:validator>`
    tag in our Facelets pages, nested inside the field we wish to validate. The following
    code snippet illustrates the changes we had to make to our email input field to
    incorporate our custom validator.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In order to validate our email input field, we added an `<f:validator>` tag
    nested inside its markup. Notice that the value of the `validatorId` attribute
    of `<f:validator>` matches the value we used in the `@FacesValidator` annotation
    in our custom email validator.
  prefs: []
  type: TYPE_NORMAL
- en: After writing our custom validator and modifying our page to take advantage
    of it, we can see our validator in action, as illustrated in *Figure 6**.8*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF\uFEFF6.8 – Custom Jakarta Faces validator in action](img/B21231_6_08.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Custom Jakarta Faces validator in action
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how to write custom validators, we will focus our attention
    to the other way we can implement custom validation in Jakarta Faces, by writing
    validator methods.
  prefs: []
  type: TYPE_NORMAL
- en: Validator methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way we can implement custom validation is by adding validation methods
    to one or more of the application’s named beans. The following Java class illustrates
    the use of validator methods for Faces validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the class contains only the validator method, but that does
    not always have to be the case. We can give our validator method any name we want,
    but its return value must be void, and it must take the three parameters illustrated
    in the example, in that order. In other words, except for the method name, the
    signature of a validator method must be identical to the signature of the `validate()`
    method defined in the `jakarta.faces.validator.Validator` interface.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the body of the preceding validator method is nearly identical
    to the body of our custom validator’s `validate()` method. We check the value
    entered by the user to make sure it contains only alphabetic characters and/or
    spaces. If it doesn’t, then we throw a `ValidatorException` passing an instance
    of `FacesMessage` containing an appropriate error message string.
  prefs: []
  type: TYPE_NORMAL
- en: StringUtils
  prefs: []
  type: TYPE_NORMAL
- en: In the example, we used `org.apache.commons.lang3.StringUtils` to perform the
    actual validation logic. In addition to the method used in the example, this class
    contains several methods for verifying that a `string` is numeric or alphanumeric.
    This class, part of the Apache Commons Lang library, is very useful when writing
    custom validators.
  prefs: []
  type: TYPE_NORMAL
- en: Since every validator method must be in a named bean, we need to make sure the
    class containing our validator method is annotated with the `@Named` annotation,
    as illustrated in our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do to use our validator method is to bind it to our
    component via the tag’s `validator` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Since neither the first name nor the last name fields should accept anything
    other than alphabetic characters or spaces, we added our custom validator method
    to both of these fields.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the value of the validator attribute of the `<h:inputText>` tag
    is an expression written in the Jakarta expression language, it uses the default
    named bean name for the bean containing our validation method. `alphaValidator`
    is the name of our bean, and `validateAlpha` is the name of our validator method.
  prefs: []
  type: TYPE_NORMAL
- en: After modifying our page to use our custom validator, we can now see it in action,
    as seen in *Figure 6**.9*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF\uFEFF6.9 – Custom validation via validator methods](img/B21231_6_09.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Custom validation via validator methods
  prefs: []
  type: TYPE_NORMAL
- en: Notice how for the **First Name** field, both our custom validator message and
    the standard length validator were executed.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing validator methods has the advantage of not having the overhead
    of creating a whole class just for a single validator method (our example does
    just that, but in many cases, validator methods are added to an existing named
    bean containing other methods). However, the disadvantage is that each component
    can only be validated by a single validator method. When using validator classes,
    several `<f:validator>` tags can be nested inside the tag to be validated, therefore
    multiple validations, both custom and standard, can be done on the field.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how to create our own custom validation, we’ll see how we
    can customize our Jakarta Faces validation messages, we’ll see how we can change
    how they are formatted (font, color, etc.), and how to customize error message
    text for standard Jakarta Faces validators.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing default messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned earlier, it is possible to customize the style (font, color,
    text, etc.) of Jakarta Faces default validation messages. Additionally, it is
    possible to modify the text of the default Jakarta Faces validation messages.
    In the following sections, we will explain how to modify error message formatting
    and text.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing message styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Customizing message styles can be done with `<h:message>` `style` or `styleClass`
    attributes. The `style` attribute is used when we want to declare the CSS style
    inline. The `styleClass` attribute is used when we want to use a predefined style
    in a CSS style sheet or inside a `<style>` tag on our page.
  prefs: []
  type: TYPE_NORMAL
- en: The following `markup` illustrates using the `styleClass` attribute to alter
    the style of error messages. It is a modified version of the input page we saw
    in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between this page and the previous one is the use of the
    `styleClass` attribute of the `<h:messages>` tag. As we mentioned earlier, the
    value of the `styleClass` attribute must match the name of a CSS style defined
    in a cascading stylesheet that our page has access to.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we defined a CSS style for messages as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Then used this style as the value of the `styleClass` attribute of our `<``h:messages>`
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.10* illustrates how the validation error messages look after implementing
    this change.'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF\uFEFF6.10\uFEFF – Custom styles for validation messages](img/B21231_6_10.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Custom styles for validation messages
  prefs: []
  type: TYPE_NORMAL
- en: In this particular case, we just set the color of the error message text to
    red, but we are only limited by CSS capabilities in setting the style of the error
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Pretty much any standard Jakarta Faces component has both a `style` and a `styleClass`
    attribute that can be used to alter its style. The former is used for predefined
    CSS styles, the latter is used for inline CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing message text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes it is desirable to override the text of Jakarta Faces default validation
    messages. Default validation messages are defined in a resource bundle called
    `Messages.properties`. This file can typically be found inside one of the Faces
    JAR files included with your application server. For example, `GlassFish` includes
    it inside a JAR file called `jakarta.faces.jar` file under `[glassfish installation
    directory]/glassfish/modules`. The file contains several messages; we are only
    interested in validation errors at this point. The default validation error messages
    are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to override the default error messages, we need to create our own
    resource bundle using the same keys used in the default one, but altering the
    values to suit our needs. Here is a very simple customized resource bundle for
    our application. For example, to overwrite the message for minimum length validation,
    we would add the following property to our custom resource bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this resource bundle, we override the error message for when the value entered
    for a field validated by the `<f:validateLength>` tag is less than the allowed
    minimum. In order to let our application know that we have a custom resource bundle
    for message properties, we need to modify the application’s `faces-config.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the only thing we need to do to the application’s `faces-config.xml`
    file is to add a `<message-bundle>` element indicating the name and location of
    the resource bundle containing our custom messages.
  prefs: []
  type: TYPE_NORMAL
- en: After adding our custom message resource bundle and modifying the application’s
  prefs: []
  type: TYPE_NORMAL
- en: '`faces-config.xml` file, we can see our custom validation message in action,
    as illustrated in *Figure 6**.11*.'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF\uFEFF6.11 – Custom validation error message](img/B21231_6_11.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – Custom validation error message
  prefs: []
  type: TYPE_NORMAL
- en: If we haven’t overridden a validation message, the default will still be displayed.
    In our resource bundle, we only overrode the minimum length validation error message,
    therefore our custom error message is shown for the **First Name** text field.
    Since we didn’t override the error message for the other standard Jakarta Faces
    validators, the default error message is shown for each one of them. The email
    validator is the custom validator we developed previously in this chapter, since
    it is a custom validator its error message is not affected.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to develop web-based applications using Jakarta
    Faces, the standard component framework for the Jakarta EE.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered how to write a simple application by creating pages
    using Facelets as the view technology and CDI named beans. We saw how to implement
    static and dynamic navigation with Jakarta Faces. We also covered how to validate
    user input by using Faces standard validators and by creating our own custom validators
    or by writing validator methods. Additionally, we covered how to customize standard
    Faces error messages, both the message text and the message style (font, color,
    etc).
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta Faces’ tight integration with CDI allows us to efficiently develop web-based
    interfaces for our Jakarta EE applications.**
  prefs: []
  type: TYPE_NORMAL
