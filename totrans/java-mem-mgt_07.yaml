- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Avoiding Memory Leaks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we examined how to configure and monitor memory management
    in the JVM. This involved knowledge of the metrics relevant to the tuning of the
    JVM. We discussed how to obtain these metrics and, consequently, how to tune the
    JVM. We also examined how to use profiling to obtain insights into the effects
    of tuning.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter focuses on memory leaks. We will examine memory leaks under the
    following headings:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding memory leaks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spotting memory leaks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding memory leaks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us start with understanding memory leaks. After that, we will learn how
    to spot them in our code and see how to avoid and solve them.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/B18762_Java-Memory-Management](https://github.com/PacktPublishing/B18762_Java-Memory-Management).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding memory leaks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A memory leak occurs when objects that are no longer needed are not freed up.
    This causes these objects to accumulate in memory. Given that memory is a finite
    resource, this can eventually result in your application slowing down or even
    crashing (with an **out-of-memory** (**OOM**) error).
  prefs: []
  type: TYPE_NORMAL
- en: Having fast servers or hosting your application in the cloud does not abstract
    you from the effects of poor memory management (memory leaks). As stated earlier,
    memory is a finite resource and even fast servers can run out of memory. If deploying
    on the cloud, it is tempting to simply scale up to address the issue of memory
    leaks; however, this results in higher costs for deploying an instance that is
    larger than it needs to be. It can even lead to hefty cloud service bills.
  prefs: []
  type: TYPE_NORMAL
- en: How fast you run out of memory depends on where in your code the memory leak
    occurs. If this is a piece of code that seldom runs, it will take a long time
    for the memory to get full. However, if this is a piece of code that runs frequently,
    it might go a lot faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the reasons for memory leaks may vary, one likely culprit is a bug in
    your code. This leads us to our next topic: spotting memory leaks.'
  prefs: []
  type: TYPE_NORMAL
- en: Spotting memory leaks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, you may wonder what typically when your application starts to respond somewhat
    slower after running for some time. The system administrator might just restart
    the application now and then to free the unnecessarily accumulated memory. This
    need for a restart is a typical symptom of a memory leak.
  prefs: []
  type: TYPE_NORMAL
- en: 'As memory fills up due to a memory leak, applications will slow down and even
    crash. While an application slowing down is not necessarily due to a memory leak,
    this often is the case. When faced with code that you suspect contains a memory
    leak, the following metrics are very helpful in diagnosing the application:'
  prefs: []
  type: TYPE_NORMAL
- en: Heap memory footprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap dump
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to demonstrate how to monitor these metrics, we will need an application
    that contains a memory leak. *Figure 7**.1* shows such a program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Program with a memory leak](img/Figure_7.1_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Program with a memory leak
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 7**.1*, we are in an infinite loop starting on *line 15*, creating
    `Person` objects and adding them to an `ArrayList` object. As each `Person` reference
    (`p`) is re-initialized, it is easy to think that each `Person` object that the
    reference previously referred to is now eligible for garbage collection. However,
    this is not the case, as those `Person` objects are being referred to from the
    `ArrayList` object and consequently cannot be reclaimed by the garbage collector.
    Therefore, while the infinite loop results in the program eventually running out
    of memory, the memory leak itself is because the garbage collector is unable to
    reclaim the `Person` objects. Let us examine how we can diagnose the running code
    to help us arrive at this conclusion.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will run this program using the command line as we can easily specify that
    we want the heap dumped to a file if the heap runs out of memory. The current
    directory is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command in the command line (written over several lines for clarity)
    achieves this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The interesting parts here are the `–XX` options specified. In the first instance,
    we are turning on the `HeapDumpOnOutOfMemoryError` option. This means that if
    the heap runs out of memory, the JVM will dump the heap into a file. All we need
    to do now is specify the location and name of that file. This is what the second
    `–XX` option does, using the `HeapDumpPath` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have started our memory leak-affected application, we will use the
    **VisualVM** application to monitor the metrics of interest. VisualVM is an application
    that used to come with your Java SDK, but now you’ll have to download it separately
    from [https://visualvm.github.io/download.xhtml](https://visualvm.github.io/download.xhtml)
    (note that this is the active link at the time of writing). Let us start with
    our diagnosis using the heap memory footprint.
  prefs: []
  type: TYPE_NORMAL
- en: Heap memory footprint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What we are looking for here is not the size of the heap itself, but the amount
    of heap *used*. We are also very interested in whether or not the garbage collector
    reclaims the used heap. *Figure 7**.2* shows the heap footprint for the application
    outlined in *Figure 7**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Heap memory footprint](img/Figure_7.2_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Heap memory footprint
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen from the preceding screenshot, the used heap (the area between
    the *x* axis and the graph line) quickly occupies all the heap space available.
    The garbage collector does manage to reclaim some memory (the dip on the left),
    but this is not memory allocated by our application. The program runs out of memory
    and crashes due to an `OutOfMemoryError` error. This is why the used heap goes
    back to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Let us examine the garbage collector activity during this period.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collector activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we saw the effect an application containing a memory
    leak has on the heap footprint. It is interesting to examine the activity of the
    garbage collector during that period. *Figure 7**.3* reflects this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Garbage collector activity](img/Figure_7.3_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Garbage collector activity
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.3* shows that the garbage collector is very busy during the run
    of the program. However, as per *Figure 7**.2*, we know this had no effect on
    freeing up space (allocated by our application) on the heap. Thus, in spite of
    having a busy garbage collector, the heap remains full. This is a classic sign
    of a memory leak.'
  prefs: []
  type: TYPE_NORMAL
- en: So now, we have validated that we have a memory leak in our program. The next
    step is to figure out what is causing the leak. In our case, it’s rather obvious,
    but to help us understand better, let’s investigate further. The next step would
    be to look at the heap dump created by the JVM when our program crashed.
  prefs: []
  type: TYPE_NORMAL
- en: Heap dump
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we ran our application, we specified that we wanted to create a heap dump
    if the application ran out of memory. This will enable us to further debug why
    we ran out of memory in the first place. *Figure 7**.4* represents the heap dump
    summary generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Heap dump summary](img/Figure_7.4_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Heap dump summary
  prefs: []
  type: TYPE_NORMAL
- en: Two values in *Figure 7**.4* jump out straight away. The first is the number
    of *instances* (first arrow). At *205,591,192*, this is far too many. Now, we
    need to know what type of instance is causing the memory leak. The second red
    arrow highlights `ch7.Person` as the offending type, given that there are *205,544,625*
    instances of that type alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'The heap dump also enables us to drill down further. In this case, we will
    do just that, as we want to see what is *preventing* the garbage collection of
    these `Person` objects. *Figure 7**.5* will help us discuss that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Heap dump drilldown](img/Figure_7.5_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Heap dump drilldown
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we have drilled down from the summary level to
    the object level. As we know, there are a lot of `Person` objects. By drilling
    down into any one of the `Person` objects, we can see the type that is referring
    to it. As highlighted in one of the `Person` objects (in blue), we can see that
    it is an `ArrayList` object.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have a much clearer idea of what is happening. We are adding `Person`
    objects to an `ArrayList` object whose reference never goes out of scope. As a
    result, the garbage collector cannot remove any of these `Person` objects from
    the heap, and we end up with an `OutOfMemoryError` error.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section, we diagnosed a program that contained a memory
    leak. Using the heap memory footprint and garbage collection activity, we confirmed
    the presence of a memory leak. We then analyzed the heap dump to ascertain the
    offending collection (`ArrayList`) and type (`Person`). The next section will
    deal with how to avoid memory leaks in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding memory leaks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best way of avoiding a memory leak is to write code that does not contain
    any leaks in the first place. In other words, objects that we no longer need should
    *not* have connections back to the stack, as that prevents the garbage collector
    from reclaiming them. Before we get into techniques that help you avoid leaks
    in your code, let us first fix the leak presented in *Figure 7**.1*. *Figure 7**.6*
    presents the leak-free code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Leak-free program](img/Figure_7.6_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Leak-free program
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 7**.6*, the infinite loop remains. However, *lines 19* to *23* are
    new. In this new section, we increment an `i` local variable every time we add
    a `Person` reference to the `ArrayList` object. Once we have done this 1,000 times,
    we re-initialize our `list` reference. This is crucial as it enables the garbage
    collector to reclaim the old `ArrayList` object and the 1,000 `Person` objects
    referred to from the `ArrayList` object. In addition, we reset `i` back to `0`.
    This will solve the leak. (Please send us an email if you find a use case for
    this specific example, and we’ll add it to the next edition of the book. It does,
    however, illustrate the example graphs well.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now run the program using the same command-line arguments as before.
    The program does not generate an `OutOfMemoryError` error. We will now examine
    the code’s performance using VisualVM. *Figure 7**.6* reflects the heap memory
    footprint of the new memory leak-free code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Heap memory footprint (leak-free code)](img/Figure_7.7_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Heap memory footprint (leak-free code)
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the preceding screenshot, the used heap space (area between
    the *x* axis and the graph) goes up and down. The down areas reflect where the
    garbage collector reclaims memory. This pattern resembles the teeth of a saw and
    is a sign of a healthy program. Toward the end, we stopped running the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will look at the garbage collector activity during that time. *Figure
    7**.8* reflects this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Garbage collector activity (leak-free code)](img/Figure_7.8_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – Garbage collector activity (leak-free code)
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 7**.3* (the graph representing the code with the memory leak), the
    garbage collector was running at over 5%. Here, in *Figure 7**.8*, however, the
    garbage collector is barely noticeable at all and almost the same as the *x* axis.
    Again, a sign of a healthy program. As this program does not run out of heap space,
    there is no need for a heap dump.
  prefs: []
  type: TYPE_NORMAL
- en: Common pitfalls and how to avoid them
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have addressed the memory leak issue, we will review some common
    problems in code and how to avoid them. We will discuss techniques that will enable
    us to write leak-free code and code that uses memory in an optimal way without
    wasting resources that we actually did not need to use.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the tips are a bit more obvious and don’t require a lot of examples,
    such as assigning a decent amount of heap space to your program if this is possible
    for the system, as well as not creating objects that you don’t need and reusing
    objects when you can. Some of them require a little more explanation, and we’ll
    elaborate on them next.
  prefs: []
  type: TYPE_NORMAL
- en: Unnecessary references on the stack and setting the reference to null
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible that there are references on the stack that are actually no longer
    needed. In our preceding example, this was the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Re-initializing the reference (or setting it to `null`) is the approach used
    in this section to fix the memory leak. Both approaches break the link back to
    the stack, enabling the garbage collector to reclaim the heap memory. Be careful,
    though, that you only do this when your application is finished with the objects;
    otherwise, you’ll get `NullPointerException` exceptions. You can see the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’re having an object reference stored in `personObj`; when
    we no longer need it, we set it to `null`. This way, the `Person` object on the
    heap becomes eligible for garbage collection after the line where we set it to
    `null` (assuming that we didn’t assign the reference to other variables).
  prefs: []
  type: TYPE_NORMAL
- en: Whether or not this approach is still relevant for today’s software is questionable;
    for most modern applications, this approach is less favorable, but of course,
    there could be sensible use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Resource leaks and closing resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you open resources such as files, databases, streams, and so on, they take
    up memory. If these resources are not closed, this could lead to resource leaks.
    In some scenarios, it could even lead to a serious depletion of the available
    resources and affect the performance of your application—for example, the buffers
    could get full. If you are producing output—for example, writing to a file or
    committing to a database—not closing the resource might actually lead to incorrect
    persistence or writing of the data, and the data might not reach its intended
    destination such as an output file or a database.
  prefs: []
  type: TYPE_NORMAL
- en: Closing resources (such as file and database connections) when finished is a
    method to prevent this from happening. Using the `finally` block or `try-with-resources`
    is of great help here. The `finally` block is always executed, regardless of whether
    or not an exception occurs. `try-with-resources` has an in-built `finally` block
    to close any resources opened in the `try` section. Using the `finally` block
    or `try-with-resources` ensures that the resources will be closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code of a regular `try`-`catch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `finally` block executes, whether an exception occurred or not. This way,
    we can be sure that the resources are closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Java 7, it is more common to use the `try-with-resources`. At the end
    of the `try` block, it is going to call the `close()` method on the objects initialized
    in the `try` statement (these objects must be implementing the `AutoCloseable`
    interface). This is what the previous example would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is much cleaner, and it prevents you from forgetting to
    close the resources. Therefore, using `try-with-resources` whenever possible is
    recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding unnecessary String objects using StringBuilder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`String` objects are immutable and therefore cannot be changed after creation.
    In the background, your requested changes result in a new `String` object being
    created (which reflects your changes) while the original `String` object remains
    untouched.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when you concatenate one `String` object onto another `String`
    object, you actually end up with three different objects in memory: the original
    `String` object, the `String` object you want to concatenate, and the new, resultant
    `String` object reflecting the result of the concatenation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Put the `String` concatenation code into a loop, and many unnecessary objects
    are created in the background. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the outputted `String` object will look like after the loop. We’ve
    omitted the middle section to not make this snippet unnecessarily lengthy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are creating a lot of objects, and every intermediate `concat`
    step creates a new object. For example, after the first two iterations, the value
    of `strIntToChar` is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'And after three iterations, it is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: All these intermediate values are stored in a *String pool*. This is because
    `String` objects are *immutable*, and the String pool is used as an optimization
    that is working against us here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this problem would be to use `StringBuilder`. `StringBuilder`
    objects are mutable. If we rewrite the previous code using `StringBuilder`, a
    lot fewer objects are created, since we are not creating a separate `String` object
    for every intermediate value. This is what the code would look like with `StringBuilder`
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: When concatenating, there won’t be a new `StringBuilder` object created as the
    JVM manipulates the original `StringBuilder` object. As you can see, it doesn’t
    require drastic changes to the code, but it does improve memory management a lot.
    Thus, when concatenating a `String` object a lot, use `StringBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: Managing memory usage by using primitives instead of wrapper classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Wrapper classes require a lot more memory than primitives. Sometimes, you must
    use wrapper classes—it is not optional. In other cases, using primitives instead
    of wrapper types is an option. So, for example, create a local variable of type
    `int` instead of `Integer`.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive variables occupy a small amount of memory, and if the primitive is
    local to a method, it is stored on the stack (which is faster to access than the
    heap). Wrappers, on the other hand, are class types and always result in the creation
    of an object on the heap. In addition, if it’s possible, you should use the `long`
    and `double` primitives instead of `BigInteger` and `BigDecimal`. `BigDecimal`,
    in particular, is popular due to its precision in calculations. However, this
    precision comes at the price of requiring a lot more memory and slower calculations,
    so only use this class when you really need the precision.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that this is not an actual memory leak that you’re preventing, but
    rather optimizing the usage of memory by not requiring more memory than you need
    to achieve the goals of your application.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with static collections and why to avoid this
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some situations, it can be tempting to use a static collection in a class
    to keep the objects in an application, especially when you are working with a
    Java SE-only environment and you’d like to store objects. This is something that
    is quite a danger to a healthy memory footprint. This is what such an example
    could look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This could get quickly out of hand. The objects created cannot be garbage-collected
    because the static collection keeps them alive. There are a few better ways to
    go about this. If this is something you really feel you need, chances are you
    might be able to use a database instead.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a `HashMap` class as a static collection, chances are you can
    use a `WeakHashMap` (Java 8 onward) instead. This will have weak references for
    the keys (so please note this; not the values—these are held by strong references).
    These key references are stored as weak references in the `WeakHashMap`, but this
    will not prevent the garbage collector from removing the object from the heap.
    The entries in the `WeakHashMap` will be removed if the key is no longer used
    by the rest of the application. This means that it should be all right to lose
    information that is not referenced anywhere else. So, if your intention is to
    maintain the information in a `HashMap`, you *should not* be using a `WeakHashMap`
    instead. However, if you don’t require the keys of your `HashMap` to be maintained
    on the heap if that’s the only reference, it’s possible that a `WeakHashMap` is
    an optimization for your heap usage. As always, research carefully whether this
    fits your requirements before implementing it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to avoid memory leaks in our code. The first
    step was to understand that memory leaks occur when objects, when no longer needed,
    maintain links to the stack. This prevents the garbage collector from reclaiming
    them. Given that memory is a finite resource, this is never desirable. As these
    objects accumulate, your application slows down and eventually crashes.
  prefs: []
  type: TYPE_NORMAL
- en: One common source of memory leaks is bugs in our code. However, there are ways
    to debug memory leaks. In order to demonstrate how to debug leaky code, we presented
    a program containing a memory leak. VisualVM is a tool that enables us to monitor
    the metrics of interest—the heap memory footprint, garbage collection activity,
    and the heap dump (when we run out of heap space).
  prefs: []
  type: TYPE_NORMAL
- en: The heap footprint validated the presence of a memory leak as it showed the
    *used* heap space totally occupying the available heap space. In other words,
    objects on the heap were not reclaimed. Meanwhile, the garbage collector was,
    in vain, extremely busy trying to free up heap space. To figure out which type
    was causing the issue, we examined the heap dump. This led us to an `ArrayList`
    object referring to a massive number of `Person` instances.
  prefs: []
  type: TYPE_NORMAL
- en: We addressed the leaky code and, using VisualVM again, checked the heap footprint
    and garbage collector activity metrics. Both metrics were much healthier.
  prefs: []
  type: TYPE_NORMAL
- en: However, the best way to avoid memory leaks is not to code them in the first
    place. This is similar to the *prevention is better than cure* principle. With
    this in mind, we discussed a few common techniques used to avoid memory leaks
    in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes the chapter. In short, we started by covering why and how memory
    leaks occur. We then diagnosed and fixed the code containing a memory leak. We
    finished by discussing what to keep in mind to prevent writing leaky code and
    how to optimize memory usage in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: 'This doesn’t just conclude the chapter but also the book. We started with an
    overview of the memory and zoomed in on the different aspects. After that, we
    dived into garbage collection. The last chapters of the book focused on how to
    improve performance: how to tune the JVM and how to avoid memory leaks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’d like to know even more about how the JVM manages memory, the official
    documentation of the JVM is out there waiting for you. You can find the latest
    version here: [https://docs.oracle.com/javase/specs/index.xhtml](https://docs.oracle.com/javase/specs/index.xhtml).'
  prefs: []
  type: TYPE_NORMAL
