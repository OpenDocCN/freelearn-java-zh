<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Enhanced Enums in Project Amber</h1>
                </header>
            
            <article>
                
<p><span><span>E</span></span>nums add type safety to finite and predefined sets of constants. Enums enable you to define a new type (such as a class or an interface) with a state and behavior. <strong>Project Amber</strong> is enhancing enums, taking them to the next level by adding type variables (generics) and allowing sharper enum type-checking. These will enable enums to define constants with type information, state, and behavior—applicable exclusively to each constant. These enhancements will reduce the need to refactor enums to classes in order to use generics.</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>The reason for enhancing enums</li>
<li>Adding a state and behavior to enum constants</li>
<li>Creating generic enums</li>
<li>Accessing a constant, specific state and behavior</li>
<li>Performing sharper type-checking for enum constants</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A quick background</h1>
                </header>
            
            <article>
                
<p><strong>Enums</strong> introduced type safety to the use of constants, which were defined previously by using <kbd>static</kbd>, and <kbd>final</kbd> variables of a type such as <kbd>int</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An example</h1>
                </header>
            
            <article>
                
<p>Imagine limiting the sizes of a shirt to some predefined sizes (such as <kbd>Small</kbd>, <kbd>Medium</kbd>, and <kbd>Large</kbd>). The following code shows how you can do that with an enum (<kbd>Size</kbd>):</p>
<pre>enum Size {SMALL, MEDIUM, LARGE}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<div class="packt_infobox">Java's coding guidelines recommend using uppercase to define enum constants (such as <kbd>SMALL</kbd>). Multiple words in a constant can be separated by using an underscore.</div>
<p>The following code shows how you can use the <kbd>Size</kbd> enum in a class, <kbd>Shirt</kbd>, to restrict its sizes to constants defined in the <kbd>Size</kbd> enum:</p>
<pre>class Shirt { 
    Size size;              // instance variable of type Size 
    Color color; 
 
    Shirt(Size size, Color color) {      // Size object with Shirt                                                                     <br/>                                         // instantiation 
        this.size = size; 
        this.color = color; 
    } 
} </pre>
<p>The instance variable of the <kbd>Size</kbd> <span>type </span>in the <kbd>Shirt</kbd> <span>class </span>limits the values that are assigned to it to <kbd>Size.SMALL</kbd>, <kbd>Size.MEDIUM</kbd>, and <kbd>Size.LARGE</kbd>. The following code is an example of how another class, <kbd>GarmentFactory</kbd>, uses enum constants to create instances of the <kbd>Shirt</kbd> class:</p>
<pre>class GarmentFactory { 
    void createShirts() { 
        Shirt redShirtS = new Shirt(Size.SMALL, Color.red); 
        Shirt greenShirtM = new Shirt(Size.MEDIUM, Color.green); 
        Shirt redShirtL = new Shirt(Size.LARGE, Color.red); 
    } 
} </pre>
<div class="packt_infobox">Enums define new types with predefined sets of constant values. Enums add type safety to constant values.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decompiled enum – behind the scenes</h1>
                </header>
            
            <article>
                
<p>Every user-defined enum implicitly extends the <kbd>java.lang.Enum</kbd> class. Behind the scenes, the one-line <kbd>Size</kbd> <span>enum </span>(defined in the preceding section) is compiled into something similar to the following (I've added comments in the code to explain it; when you compile an enum, you won't get similar comments):</p>
<p class="mce-root"/>
<pre>final class Size extends Enum                 // 'enum' converted to final class  
{ 
    public static final Size SMALL;           // variables to store  
    public static final Size MEDIUM;          // enum constants 
    public static final Size LARGE;           //  
 
    private static final Size $VALUES[];    // array of all enum <br/>                                            // constants 
 
    static 
    {                                       // static initializer 
        SMALL = new Size("SMALL", 0);       // to initialize enum                                                                                             <br/>                                            // constants 
        MEDIUM = new Size("MEDIUM", 1);     // 
        LARGE = new Size("LARGE", 2);       // 
        $VALUES = (new Size[] {             // 
            SMALL, MEDIUM, LARGE            // &amp; populate array of enum                                             <br/>                                            // constants 
        }); 
    } 
    public static Size[] values() 
    { 
                return (Size[])$VALUES.clone();       // Avoiding any                                                                                                          <br/>                                                    // modification to  
    }                                // $VALUES by calling methods 
    public static Size valueOf(String s) 
    { 
        return (Size)Enum.valueOf(Size, s); 
    } 
    private Size(String s, int i) 
    { 
        super(s, i); 
    } 
} </pre>
<div class="packt_infobox">Enums are syntactic sugar. The compiler takes your enum construct and extends <kbd>java.lang.Enum</kbd> to create a class. It adds the variables, initializers, and methods to get the required behavior.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The state and behavior of enum constants</h1>
                </header>
            
            <article>
                
<p><span>The enum constants can have their own states and behaviors. You can define a state and behavior that is common to all enum constants, or states and behaviors that are specific to each one of them. But can you access the state or behavior that is specific to an enum constant? Let's find out.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding states and behaviors to enum constants</h1>
                </header>
            
            <article>
                
<p><span>You can add states and behaviors to enum constants by defining instance variables and methods in an enum. All of these are accessible by the enum constants. Let's modify the</span> <kbd>Size</kbd><span> enum defined in the previous section, by adding a state and behavior to it. </span>Each enum constant can define a constant, specific class body, define a new state and behavior, or override the default behavior of the enum methods in which it is defined. The following is an example of this:</p>
<pre>enum Size { 
    SMALL(36, 19), 
    MEDIUM(32, 20) {               // Constant specific class body  
        int number = 10;                    // variable specific to <br/>                                            //MEDIUM 
        int getSize() {                     // method specific to <br/>                                            //MEDIUM 
            return length + width; 
        } 
    }, 
    LARGE(34, 22) { 
        @Override  
        public String toText() {            // overriding method toText <br/>                                            //for  
            return "LARGE";                 // constant LARGE 
        } 
    }; 
 
    int length;                             // instance variable <br/>                                            //accessible 
    int width;                              // to all enum constants 
 
    Size(int length, int width) {           // enum constructor; <br/>                                            //accepts length 
        this.length = length;               // and width 
        this.width = width; 
    } 
 
    int getLength() {                       // method accessible to all <br/>                                            //enum 
        return length;                      // constants 
    } 
 
    int getWidth() {                        // method accessible to all <br/>                                            //enum 
        return width;                       // constants 
    }  
 
    public String toText() {               // method accessible to all <br/>                                           //enum 
        return length + " X " + width;     // constants 
    } 
} </pre>
<p>In the preceding example, the <kbd>Size</kbd> <span>enum </span>defines three enum constants—<kbd>SMALL</kbd>, <kbd>MEDIUM</kbd>, and <kbd>LARGE</kbd>. It also defines instance variables (<kbd>length</kbd> and <kbd>breadth</kbd>), a constructor, and the <kbd>getLength()</kbd>, <kbd>getWidth</kbd>, and <kbd>toText()</kbd> methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing the state and behavior of enum constants</h1>
                </header>
            
            <article>
                
<p>At present, an enum constant can access the following:</p>
<ul>
<li>The state and behavior common to all enum constants</li>
<li>Overridden methods</li>
</ul>
<p>For the <kbd>Size</kbd> <span>enum </span>(defined in the preceding section), you can access the state and behavior common to all enum constants, as follows:</p>
<pre>System.out.println(Size.SMALL.toText());  // toString is defined for all constants </pre>
<p>The preceding code will have the following output:</p>
<pre><strong>36 X 19</strong> </pre>
<p>You can also access the behavior that a specific enum constant overrides as follows:</p>
<pre>System.out.println(Size.LARGE.toText()); </pre>
<p>The preceding code will have the following output:</p>
<pre><strong>LARGE</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>However, you can't access the state or behavior that is specific to an enum constant, as shown in the following code:</p>
<pre>System.out.println(Size.MEDIUM.number);          // Doesn't compile 
System.out.println(Size.MEDIUM.getSize());       // Doesn't compile </pre>
<p>The <kbd>getSize()</kbd> <span>method and</span> the <kbd>number</kbd> <span>variable </span>can't be accessed by using the <kbd>MEDIUM</kbd> <span>constant.</span> That is because <kbd>MEDIUM</kbd> creates an anonymous class and overrides the methods of the <kbd>Size</kbd> <span>enum.</span> It can't access the constant, specific state or behavior, because it's still referenced by a variable of the <kbd>Size</kbd> <span>type</span>. The following figure should help you remember this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e637ffe5-79aa-46f9-9dd6-aa2d3b68f5fc.png" style="width:54.08em;height:30.42em;"/></p>
<div class="packt_infobox">Existing enums don't allow access to a state or behavior that is specific to an enum constant, because it creates an anonymous class to do so.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Workarounds to access enum constants</h1>
                </header>
            
            <article>
                
<p>One of the ways to access members such as variables and methods that are specific to an enum constant is—to define them for all members, but only allow the usage for specific members (I know, this is not recommended). I've removed code that is not relevant to show how this works, as follows:</p>
<pre>enum Size {<br/>    SMALL(36, 19),<br/>    MEDIUM(32, 20),<br/>    LARGE(34, 22);<br/>    int length;                            // instance variable <br/>                                           //accessible<br/>    int width;                             // to all enum constants<br/>    Size(int length, int width) {          // enum constructor; accepts <br/>                                            //length<br/>         this.length = length;             // and width<br/>         this.width = width;<br/>    }<br/>    int getSize() {<br/>       if (this == MEDIUM)<br/>         return length + width;<br/>       else                                           // throws runtime <br/>                                                      // exception<br/>         throw new UnsupportedOperationException();   // if used with <br/>                                                      // constants<br/>    }                                                 // other than <br/>                                                      //MEDIUM<br/>}</pre>
<p>Let's try to access the method <kbd>getSize()</kbd> using enum constants:</p>
<pre>System.out.println(MEDIUM.getSize());<br/>System.out.println(LARGE.getSize());</pre>
<p>The output of the preceding code is as follows:</p>
<pre><strong>52</strong><br/><strong><span>Exception in thread—</span><span>java.lang.UnsupportedOperationException</span></strong></pre>
<p>First and foremost, adding code (the <kbd>getSize()</kbd> method) that is not applicable to all enum constants breaks the encapsulation. In the preceding example, I defined <kbd>getSize()</kbd> in the main body, whereas only the <kbd>MEDIUM</kbd> <span>enum constant </span>required the <kbd>getSize()</kbd> <span>method. </span>This is neither desirable nor recommended.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Compared it with an arrangement of a base class and its derived classes, adding all of the behaviors specific to the different derived classes in your base class. However, it's not recommended as it doesn't define the encapsulated code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using inheritance with enum constants</h1>
                </header>
            
            <article>
                
<p>The following is another example of an enum, that works with a set of subclasses by passing instances of subclasses to the enum constructor. To get the point across, I've modified the <kbd>Size</kbd> <span>enum, </span>which we have been working on with since the beginning of this chapter. The following is the modified code:</p>
<pre>class Measurement {}                      // base class 
class Small extends Measurement {         // derived class 
    String text = "Small";                // state specific to class <br/>                                          //Small 
} 
class Medium extends Measurement {        // derived class 
    public int getLength() {              // behavior specific to class <br/>                                          //Medium 
        return 9999; 
    } 
} 
class Large extends Measurement {}        // derived class 
 
enum Size {                                
    SMALL(new Small()),                // constant created using Small <br/>                                       //instance 
    MEDIUM(new Medium()),              // constant created using Medium <br/>                                       //instance 
    LARGE(new Large());                // constant created using Large <br/>                                       //instance 
 
    private Measurement mObj;     // Measurement is base class of  
                                  // classes Small, Medium &amp; Large 
 
    Size(Measurement obj) {     // wraps Measurement instance as an <br/>                                //Enum instance 
        mObj = obj; 
    } 
    Measurement getMeasurement() { // get the wrapped instance 
        return mObj; 
    } 
}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>Again, you can't access the state and behavior of the enum-constant-specific code. The following is an example:</p>
<pre>class Test1 { 
    public static void main(String args[]) { 
        var large = Size.LARGE; 
        System.out.println(large.getMeasurement()<br/>                             .getLength());      // doesn't compile 
                                                 // the type of the                                                     <br/>                                                 // variable used 
                                                 // to wrap the value                                                  <br/>                                                 // of enum  
                                                 // constant is                                                          <br/>                                                 // Measurement  
    } 
} </pre>
<p>Here, the enhanced enums come to the rescue. JEP 301 introduced enhanced enums by adding type variables or generics to it. Let's look at how it works in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding generics to enums</h1>
                </header>
            
            <article>
                
<p>Let's rewrite the enum code from the preceding example, adding a variable<span> </span>type to the enum <kbd>Size</kbd>. The bounded type parameter (<kbd>&lt;T extends Measurement&gt;</kbd>) restricts the types that can be passed as arguments to the <kbd>Size</kbd> enum, to the <kbd>Measurement</kbd> class and its derived classes.</p>
<div class="packt_infobox">This section modifies the code from the preceding section. To understand the example code and its purpose, please read the preceding section (if you haven't already). </div>
<p>The modified code is as follows:</p>
<pre>enum Size &lt;T extends Measurement&gt; {      // enum with type parameter 
    SMALL(new Small()), 
    MEDIUM(new Medium()), 
    LARGE(new Large()); 
 
    private T mObj; 
 
    Size(T obj) { 
        mObj = obj; 
    } 
    T getMeasurement() { 
        return mObj; 
    } 
} <br/><br/>class Measurement {} 
class Small extends Measurement { 
    String text = "Small"; 
} 
class Medium extends Measurement {} 
class Large extends Measurement { 
    public int getLength() { 
        return 40; 
    } 
}</pre>
<p>The following code can be used to access behavior that is specific to a constant, say, the <kbd>getLength()</kbd> method, which is accessible only to the <kbd>LARGE</kbd> constant, as follows:</p>
<pre>var large = Size.LARGE; 
System.out.println(large.getMeasurement().getLength());  </pre>
<div class="packt_infobox">With the enhanced enums (with generics added), you will be able to access an enum constant specific state or behavior.</div>
<p>Let's work with another example of a generic enum, which can be used to restrict the user data to certain types.</p>
<p>The following example creates a generic enum, <kbd>Data</kbd>, which can be passed as a type parameter, <kbd>T</kbd>:</p>
<pre>public enum Data&lt;T&gt; { 
    NAME&lt;String&gt;,                // constants of generic  
    AGE&lt;Integer&gt;,                // enum Data 
    ADDRESS&lt;Address&gt;; 
} </pre>
<p>The <kbd>FormData</kbd> <span>class </span>defines a generic method that can accept a constant of the <kbd>Data</kbd><span> enum </span>and a value of the same type that is used for the enum constant:</p>
<pre>public class FormData { 
    public &lt;T&gt; void add(Data&lt;T&gt; type, T value) { 
        //..code 
    } 
}</pre>
<p>The following code shows how you can use the constants of the <kbd>Data</kbd> enum to restrict the combination of types of values that you pass to the <kbd>add</kbd> <span>method:</span></p>
<pre>FormData data = new FormData(); 
data.add(Data.NAME, "Pavni");            // okay; type of NAME and <br/>                                         // Pavni is String 
data.add(Data.AGE, 22);                  // okay; type of AGE and 22 is <br/>                                         // Integer 
data.add(Data.ADDRESS, "California");    // Won't compile. "California"  
                                         // is String, not Address <br/>                                         // instance </pre>
<p>With the mismatched data, the code fails at compilation, making it easier for the developer to correct it.</p>
<div class="packt_infobox">Compilation failures are always better than runtime exceptions. Using the generic <kbd>Data</kbd> <span>enum </span>will make the code fail at compile time for a mismatched combination of values passed to <kbd>add()</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sharper typing of enum constants</h1>
                </header>
            
            <article>
                
<p>One of the two major goals of enhanced enums is to perform sharper type-checking for enums. At present, the type of all enum constants is the enum in which they are defined. Referring to our example enum, <kbd>Size</kbd>, this essentially means that the type of all of the enum constants (<kbd>SMALL</kbd>, <kbd>MEDIUM</kbd>, and <kbd>LARGE</kbd>) is <kbd>Size</kbd>, which is incorrect (as depicted in the following figure):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3031f8fa-d9bf-46ed-81cb-6d6c27929742.png" style="width:35.08em;height:19.58em;"/></p>
<p>Although enum constants are allowed to define a constant specific class body, which includes variables and methods, the constant type is not sharp enough to allow for access to enum constant-specific values. Even in the case of generic enums, the static type of an enum constant is not sharp enough to capture the full type information of individual constants.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned about how the enums in Java 5 introduced type safety to constants. We covered how each enum constant can have its own distinct state and behavior, not just what is common to all enum constants. However, it's not feasible to access the state and behavior that is specific to an enum constant with the existing enums.</p>
<p>Next, we covered how the enhanced enums can use generics and access a constant specific state and behavior. With examples, we also covered how type parameters facilitate sharper typing of enum constants.</p>
<p>In the next chapter, we'll cover how the data classes in Project Amber are bringing about language changes to define data carrier classes.</p>


            </article>

            
        </section>
    </body></html>