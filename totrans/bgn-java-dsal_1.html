<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Algorithms and Complexities</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">An algorithm is a set of logical instructions to perform a particular task. Algorithms are everywhere nowadays. As a software developer, understanding the core principles of algorithms and data structures will enable you to make informed decisions on how to approach a particular problem. This is valid whether you're working in a bank writing accounting software or doing medical research data, mining genetic code. How do we determine which is the right algorithm to use when more than one solution to a problem exists? In this chapter, we will examine different types of algorithms and discuss how the performance varies in each. We will discuss what makes an algorithm more efficient than another and how to express the complexity of each.</p>
<div class="packt_infobox">The common examples of algorithms include traffic lights regulating congestion on the streets, face recognition software on smartphones, recommendation technologies, and so on.<br class="calibre2"/>
It's important for you to understand that an algorithm is just a small part of an application used to solve a well-defined problem. Examples such as sorting a list of numbers, finding the shortest route, or word prediction are all correct. Big software applications, such as email clients or an operating system are improper examples.<span class="calibre10"><br class="calibre2"/></span></div>
<p class="mce-root"><span class="calibre14">By the end of this chapter, you will be able to:</span></p>
<ul class="calibre12">
<li class="calibre13"><span class="calibre10">Define an algorithm with an example<br class="calibre2"/></span></li>
<li class="calibre13"><span class="calibre10">Measure algorithmic complexity<br class="calibre2"/></span></li>
<li class="calibre13"><span class="calibre10">Identify algorithms with different complexities<br class="calibre2"/></span></li>
<li class="calibre13"><span class="calibre10">Assess various examples with different runtime complexities</span></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Developing Our First Algorithm</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">An algorithm can be seen as a roadmap or a set of instructions to accomplish a well-defined task. In this section, we will build a simple example of one such algorithm to help us get started.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Algorithm for Converting Binary Numbers to Decimal</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre14">Number systems have different bases. Decimals numbers with a base of ten are what most of us are familiar with. Computers, on the other hand, use only ones and zeros (binary). Let's try to write some code that converts binary numbers to decimals.<br class="calibre7"/></span></p>
<p class="mce-root"><span class="calibre14">Specifically, we want to develop an algorithm that accepts a string containing ones and zeros and returns an integer.</span></p>
<p class="mce-root"><span class="calibre14">We can convert the binary string by following these steps:</span></p>
<ol class="calibre17">
<li class="chapter">Start from the end of the string and process each character at a time. The position of each digit in the binary string corresponds to a decimal number in a sequence.</li>
<li class="chapter">To generate this sequence, you start from one and multiply by two every time, so one, two, four, eight, and so on (see <em class="calibre21">Conversion Sequence</em> row of <em class="calibre21">Table 1.1</em>). More formally, the sequence is a geometric progression that starts at one and progresses in a common ratio of two.</li>
<li class="chapter"><span class="calibre10">We then apply the binary string as a mask on this sequence (see</span> <span class="calibre10">the <em class="calibre21">Binary String (Mask)</em> row of <em class="calibre21">Table 1.1</em></span><span class="calibre10">).</span></li>
<li class="chapter">The result is a new sequence where the values are only kept if the corresponding position in the binary string has a value of one (see the <em class="calibre21">Result</em> row of <em class="calibre21">Table 1.1</em>).</li>
<li class="chapter"><span class="calibre10">After applying the mask, we just need to sum up the resulting numbers together</span>.</li>
</ol>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25"><strong class="calibre3">Conversion Sequence</strong></td>
<td class="calibre25">16</td>
<td class="calibre25">8</td>
<td class="calibre25">4</td>
<td class="calibre25">2</td>
<td class="calibre25">1</td>
</tr>
<tr class="calibre26">
<td class="calibre25"><strong class="calibre3">Binary String (Mask)</strong></td>
<td class="calibre25">1</td>
<td class="calibre25">0</td>
<td class="calibre25">1</td>
<td class="calibre25">1</td>
<td class="calibre25">0</td>
</tr>
<tr class="calibre27">
<td class="calibre25"><strong class="calibre3">Result</strong></td>
<td class="calibre25">16</td>
<td class="calibre25">0</td>
<td class="calibre25">4</td>
<td class="calibre25">2</td>
<td class="calibre25">0</td>
</tr>
</tbody>
</table>
<div class="packt_figref"><span class="calibre10">Table 1.1: Binary to decimal masking</span></div>
<p class="mce-root"><span class="calibre14">In the preceding example (</span><em class="calibre19"><span class="calibre14">Table 1.1</span></em><span class="calibre14">), resulting total is <strong class="calibre6">22</strong>. This is our decimal number corresponding to the binary number 10110.</span></p>
<div class="packt_infobox">To design our algorithm, it's important to realize that we don't need to store the entire conversion sequence. Since we are processing one binary digit at a time (starting from the back), we only need to use the conversion number corresponding to the binary position we are processing.</div>
<p class="mce-root"><em class="calibre19">Snippet 1.1</em> shows us how we can do this. We use a single conversion variable instead of a sequence and initialize this variable to the value of one. We then use a loop to iterate over the length of the binary string starting from the end. While iterating, if the digit at our current position is one, we add the current conversion variable to the final result. We then simply double the current conversion variable and repeat. The code snippet is as follows:</p>
<pre class="calibre20"><span class="calibre10">public int convertToDecimal(String binary) {<br class="calibre2"/>  int conversion = 1;<br class="calibre2"/>  int result = 0;<br class="calibre2"/>  for (int i = 1; i &lt;= binary.length(); i++) {<br class="calibre2"/>    if (binary.charAt(binary.length() - i) == '1')<br class="calibre2"/>      result += conversion;<br class="calibre2"/>    conversion *= 2;<br class="calibre2"/>  }<br class="calibre2"/>  return result;<br class="calibre2"/>}</span> </pre>
<div class="packt_figref">Snippet 1.1: Binary to decimal. Source class name: BinaryToDecimal.</div>
<div class="packt_infobox"><span class="calibre10"><br class="calibre2"/>
Go to</span> <a href="https://goo.gl/rETLfq" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/rETLfq</span></a> <span class="calibre10">to access the code.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Activity: Writing an Algorithm to Convert Numbers from Octal To Decimal</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Scenario</span></strong></p>
<p class="mce-root">In aviation, the aircraft's transponders transmit a code so that they can identify one another. This code uses the octal system, a number system which has a base of 8. We have been asked to write a method to convert octal numbers into decimals. For example, the octal number 17 is represented as 15 in the decimal system.</p>
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Aim</span></strong></p>
<p class="mce-root">To be able to adapt the algorithm shown in the previous section to be used in a different scenario.</p>
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Prerequisites</span></strong></p>
<ul class="calibre12">
<li class="calibre13"><span class="calibre10">Ensure that you have a class available on the following path:</span></li>
</ul>
<p class="calibre29"><a href="https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson1/activity/octaltodecimal/OctalToDecimal.java" class="pcalibre pcalibre3 calibre11 pcalibre1 pcalibre2"><span class="calibre10">https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson1/activity/octaltodecimal/OctalToDecimal.java</span></a></p>
<ul class="calibre12">
<li class="calibre13"><span class="calibre10">You will find the following method that needs implementing:</span></li>
</ul>
<pre class="calibre30"> <span class="calibre10">public int convertToDecimal (String octal)</span> </pre>
<ul class="calibre12">
<li class="calibre13"><span class="calibre10">If you have your project set up, you can run the unit test for this activity by running the following command:</span> </li>
</ul>
<pre class="calibre30"><strong class="calibre3"><span class="calibre10">gradlew test --tests com.packt.datastructuresandalg.<br class="calibre2"/>lesson1.activity.octaltodecimal*</span> </strong></pre>
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Steps for Completion</span></strong></p>
<ol class="calibre17">
<li class="chapter">The algorithms shown in <em class="calibre21">Snippet 1.1</em> the preceding snippets of code can be adapted to work with octal numbers instead of binary.</li>
<li class="chapter"><span class="calibre10">Change the base from two to eight. This can be done by changing the conversion multiplier variable in</span> <span class="calibre10"><em class="calibre21">Snippet 1.1</em>.</span></li>
<li class="chapter"><span class="calibre10">Parse the digit being processed to convert it into an integer. This integer can then be multiplied by the conversion variable or result of the power function.</span></li>
</ol>
<p class="mce-root">In this first section, we introduced the idea of algorithms by working on a simple example. It's important to note that for every problem multiple solutions exist. Choosing the right algorithm to solve your problem will depend on several metrics, such as performance and memory requirements.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Measuring Algorithmic Complexity with Big O Notation</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Algorithmic complexity is a way to describe the efficiency of an algorithm as a relation of its input. It can be used to describe various properties of our code, such as runtime speed or memory requirements. It's also a very important tool programmers should understand to write efficient software. In this section, we will start by describing a scenario, introducing the section, and then dive into the details of the various types of complexities and the different techniques to measure them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Complexity Example</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Imagine we were given the task of writing a piece of software for air traffic control. Specifically, we were asked to write an algorithm that, in a pre-defined space and altitude, will ring out an alarm if any two aircraft get too close to each other.</p>
<p class="mce-root">In our implementation, we solved the problem by computing all possible distances between every pair in our airspace and keeping only the minimum distance. If this minimum distance is less than a certain threshold, our software will ring out an alarm. The following snippet of code shows this solution:</p>
<pre class="calibre20"><span class="calibre10">public double minimumDistance(List&lt;Point&gt; allPlanes) {<br class="calibre2"/>  double minDistance = Double.MAX_VALUE;<br class="calibre2"/>  for (Point p1 : allPlanes) {<br class="calibre2"/>    for (Point p2 : allPlanes) {<br class="calibre2"/>      double d = p1.distanceTo(p2);<br class="calibre2"/>      if (d != 0 &amp;&amp; d &lt; minDistance) minDistance = d;<br class="calibre2"/>    }<br class="calibre2"/>  }<br class="calibre2"/>  return minDistance;<br class="calibre2"/>}</span> </pre>
<div class="packt_figref"><span class="calibre10">Snippet 1.2: Minimum distance. Source class name:</span> <span class="calibre10">ClosestPlane</span> <span class="calibre10">and</span> <span class="calibre10">Point.</span></div>
<div class="packt_infobox"><span class="calibre10"><br class="calibre2"/>
Note that the <kbd class="calibre31">Point</kbd> class in the preceding piece of code is not shown. Go to</span> <a href="https://goo.gl/iDHD5J" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/iDHD5J</span></a> <span class="calibre10">to access the code.</span></div>
<p class="mce-root">Our little algorithm works fine for a couple of years and the controllers are happy to have this useful alerting. However, over the years, air traffic increases at a fast rate, and instead of having to monitor a few hundred aircraft at any given time, our algorithm has to handle tens of thousands of points. At busy times, the software is having trouble keeping up with the increased load.</p>
<p class="mce-root">We are called in to investigate and we start to write some benchmarks to test how fast the algorithm performs. We obtain the timings shown in <em class="calibre19">Table 1.2</em>. As you can see, we are doubling the load on every run; however, our algorithm is not scaling up in the same manner. Our algorithm is not slowing down at the same rate as our input.</p>
<p class="mce-root">Intuitively, you may expect that if you double the number of planes, the algorithm has, then you have twice the amount of work to do, and as a result, it should take twice as long. However, this is not what is happening.</p>
<p class="mce-root">When we double the number of planes, the time taken doesn't just double but skyrockets.</p>
<p class="mce-root">For example, our algorithm takes 2.6 seconds (2,647 ms) to finish when it's dealing with 16,000 planes. However, if we double the amount of planes to 32,000, the time it takes increases to 10.4 seconds (10,488 ms), a four-fold increase!</p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25"><strong class="calibre3">Number of planes</strong></td>
<td class="calibre25"><strong class="calibre3">Time taken (ms)</strong></td>
</tr>
<tr class="calibre26">
<td class="calibre25">1000</td>
<td class="calibre25">27</td>
</tr>
<tr class="calibre24">
<td class="calibre25">2000</td>
<td class="calibre25">48</td>
</tr>
<tr class="calibre26">
<td class="calibre25">4000</td>
<td class="calibre25">190</td>
</tr>
<tr class="calibre24">
<td class="calibre25">8000</td>
<td class="calibre25">664</td>
</tr>
<tr class="calibre26">
<td class="calibre25">16000</td>
<td class="calibre25">2647</td>
</tr>
<tr class="calibre27">
<td class="calibre25">32000</td>
<td class="calibre25">10488</td>
</tr>
</tbody>
</table>
<p class="mce-root"> </p>
<p class="mce-root">In the following graph, we plot the benchmark results in a chart. What is going on here? Our algorithm is doing a lot of work due to the nested loop. For every plane point in its input, it's calculating the distance to every other plane. This results in <em class="calibre19">n<sup class="calibre32">2</sup></em> calculations, where <em class="calibre19">n</em> is the number of planes we are monitoring. We can say that our algorithm has a runtime performance of <em class="calibre19">O(n<sup class="calibre32">2</sup>)</em>, read as <q class="pcalibre5 pcalibre4 calibre33">big O of n squared</q>. Alternatively, we can also call it the quadratic runtime performance. Take a look at this graph:</p>
<p class="cdpaligncenter"><img src="Images/46610d5d-85aa-46c3-ac1a-e268073faec6.png" class="calibre34"/></p>
<div class="packt_figref"><span class="calibre10">Figure 1.1: Algorithm benchmark result plot</span></div>
<p class="mce-root">The algorithm listed in <em class="calibre19">Snippet 1.2</em> is a slow solution for the closest pair problem. There exists a much more efficient solution that involves a divide and conquer technique.</p>
<p class="mce-root">This class of algorithms is explored in detail in the second part of this book in <a href="da07fa18-a8ce-4d4c-91eb-9dc893de7273.xhtml" class="pcalibre pcalibre3 calibre11 pcalibre1 pcalibre2">Chapter 4</a>, <em class="calibre19">Algorithm Design Paradigms</em>, where we present a faster solution to the closest pair problem.</p>
<p class="mce-root">Increasing the input load on your code does not always mean that the resource consumption will also increase in a directly proportional manner. The relation between the input size of your problem and resource usage (CPU time, memory, and so on) is what this section is all about.</p>
<p class="mce-root">In the next section, we will see different types of these relations between the problem, input size, and resource usage.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Understanding Complexity</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To better understand algorithmic complexity, we can make use of an analogy. Imagine that we were to set different types of algorithms so that they compete against one another on a race track. However, there is a slight twist: The race course has no finish line.</p>
<p class="mce-root">Since the race is infinite, the aim of the race is to surpass the other, slower opponents over time and not to finish first. In this analogy, the race track distance is our algorithm input. How far from the start we get, after a certain amount of time, represents the amount of work done by our code.</p>
<p class="mce-root">Recall the quadratic method for measuring the closest pair of planes in the preceding section. In our fictitious race, the quadratic algorithm starts quite fast and is able to move quite a distance before it starts slowing down, similar to a runner that is getting tired and slowing down. The further it gets away from the start line, the slower it gets, although it never stops moving.</p>
<p class="mce-root">Not only do the algorithms progress through the race at different speeds, but their way of moving varies from one type to another. We already mentioned that <em class="calibre19">O(n<sup class="calibre32">2</sup>)</em> solutions slow down as they progress along the race. How does this compare to the others?</p>
<p class="mce-root">Another type of runner taking part in our imaginary race is the linear algorithm. Linear algorithms are described with the notation of <em class="calibre19">O(n)</em>. Their speed on our race track is constant. Think of them as an old, reliable car moving at the same fixed speed.</p>
<p class="mce-root">In real life, solutions that have an <em class="calibre19">O(n)</em> runtime complexity have a running performance that is directly proportional to the size of their input. </p>
<p class="mce-root">This means, for example, that if you double the input size of a linear algorithm, the algorithm would also take about twice as long to finish.</p>
<p class="mce-root">The efficiency of each algorithm is always evaluated in the long run. Given a big enough input, a linear algorithm will always perform better than a quadratic one.</p>
<p class="mce-root">We can go much quicker than <em class="calibre19">O(n)</em>. Imagine that our algorithm is continually accelerating along the track instead of moving constantly. This is the opposite of quadratic runtime. Given enough distance, these solutions can get really fast. We say that these type of algorithms have a logarithmic complexity written as <em class="calibre19">O(log n)</em>.</p>
<p class="mce-root">In real life, this means that the algorithm doesn't slow much as the size of the input increases. Again, it doesn't matter if at the start, the algorithm performs slower than a linear one for a small input, as for a big enough input, a logarithmic solution will always outperform the linear one.</p>
<p class="mce-root">Can we go even faster? It turns out that there is another complexity class of algorithms that performs even better.</p>
<p class="mce-root">Picture a runner in our race who has the ability to teleport in constant time to any location along our infinite track. Even if the teleportation takes a long time, as long as it's constant and doesn't depend on the distance traveled, this type of runner will always beat any other. No matter how long the teleportation takes, given enough distance, the algorithm will always arrive there first. This is what is known as a constant runtime complexity, written as <em class="calibre19">O(1)</em>. Solutions that belong to this complexity class will have a runtime independent of the input size given.</p>
<p class="mce-root">On the other side of the spectrum, we can find algorithms that are much slower than quadratic ones. Complexities such as cubic with <em class="calibre19">O(n<sup class="calibre32">3</sup>)</em> or quartic with <em class="calibre19">O(n<sup class="calibre32">4</sup>)</em> are examples. All of the mentioned complexities up to this point are said to be polynomial complexities.</p>
<div class="packt_infobox">A polynomial is simply a mathematical term used for expressions. Expressions such as <em class="calibre21">3x<sup class="calibre35">5</sup> + 2x<sup class="calibre35">3</sup> + 6</em>, <em class="calibre21">2x – 3</em>, or even just 5 are all good examples. The key here is that polynomial complexities are of the form <em class="calibre21">O(n<sup class="calibre35">k</sup>)</em>, where <em class="calibre21">k</em> is a positive, non-fractional constant.</div>
<p class="mce-root">Not all solutions have a polynomial time behavior. A particular class of algorithms scale really badly in proportion to their input with a runtime performance of <em class="calibre19">O(k<sup class="calibre32">n</sup>)</em>. In this class, the efficiency degrades exponentially with the input size. All the other types of polynomial algorithms will outperform any exponential one pretty fast. <em class="calibre19">Figure 1.2</em> shows how this type of behavior compares with the previously mentioned polynomial algorithms.</p>
<p class="mce-root">The following graph also shows how fast an exponential algorithm degrades with input size:</p>
<p class="cdpaligncenter"><img src="Images/2ad23cb2-ff94-449b-bc0c-a80344f0c926.png" class="calibre36"/></p>
<div class="packt_figref">Figure 1.2: Operations performed versus input size for different algorithms</div>
<p class="mce-root">How much faster does a logarithmic algorithm perform versus a quadratic one? Let's try to pick a particular example. A specific algorithm performs about two operations to solve a problem; however, the relation to its input is <em class="calibre19">O(n<sup class="calibre32">2</sup>)</em>.</p>
<p class="mce-root">Assuming each operation is a slow one (such as file access) and has a constant time of about 0.25 milliseconds, the time required to perform those operations will be as shown in <em class="calibre19">Table 1.3</em>. We work out the timings by <em class="calibre19">Time = 0.25 * operations * n<sup class="calibre32">2</sup></em>, where operations is the number of operations performed (in this example it's equal to 2), <em class="calibre19">n</em> is the input size, and <em class="calibre19">0.25</em> is the time taken per operation:</p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25"><strong class="calibre3">Input Size (n)</strong></td>
<td class="calibre25"><strong class="calibre3">Time: 2 operations O(n<sup class="calibre32">2</sup>)</strong></td>
<td class="calibre25"><strong class="calibre3">Time: 400 operations O(log n)</strong></td>
</tr>
<tr class="calibre26">
<td class="calibre25">10</td>
<td class="calibre25">50 milliseconds</td>
<td class="calibre25">100 milliseconds</td>
</tr>
<tr class="calibre24">
<td class="calibre25">100</td>
<td class="calibre25">5 seconds</td>
<td class="calibre25">200 <span class="calibre10">milliseconds</span></td>
</tr>
<tr class="calibre26">
<td class="calibre25">1000</td>
<td class="calibre25">8.3 minutes</td>
<td class="calibre25"><span class="calibre10">300 milliseconds</span></td>
</tr>
<tr class="calibre27">
<td class="calibre25">10000</td>
<td class="calibre25">13.8 hours</td>
<td class="calibre25"><span class="calibre10">400 milliseconds</span></td>
</tr>
</tbody>
</table>
<div class="packt_figref">Table 1.3: How fast does it run?</div>
<p class="mce-root">Our logarithmic algorithm performs around 400 operations; however, its relation to the input size is logarithmic. Although this algorithm is slower for a smaller input, it quickly overtakes the quadratic algorithm. You can notice that, with a large enough input, the difference in performance is huge. In this case, we work out the timing using <em class="calibre19">Time = 0.25 * operations * log n</em>, with <em class="calibre19">operations = 400</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Activity: Developing a Timing Table Using the Exponential Algorithm</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Scenario</span></strong></p>
<p class="mce-root"><span class="calibre14">We have been asked to develop a timing table using an input size of 2, 10, 30, and 50 for an exponential algorithm of</span> <em class="calibre19"><span class="calibre14">O(2<sup class="calibre32">n</sup>)</span></em><span class="calibre14">. Assume an operation time of 0.5 ms and that the algorithm only performs one operation.<br class="calibre7"/></span></p>
<p class="mce-root"><span class="calibre14"><strong class="calibre6">Aim</strong><br class="calibre7"/></span></p>
<p class="mce-root"><span class="calibre14">To discover how badly exponential algorithms scale.<br class="calibre7"/></span></p>
<p class="mce-root"><span class="calibre14"><strong class="calibre6">Steps for Completion</strong><br class="calibre7"/></span></p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">0.5 x 2</span><sup class="calibre32"><span class="calibre14">2</span></sup> <span class="calibre10">= 2 ms</span></li>
<li class="chapter"><span class="calibre10">0.5 x 2</span><sup class="calibre32"><span class="calibre14">10</span></sup> <span class="calibre10">= 512 ms</span></li>
<li class="chapter"><span class="calibre10">0.5 x 2</span><sup class="calibre32"><span class="calibre14">30</span></sup> <span class="calibre10">= 0.536 billion ms = 6.2 days</span></li>
<li class="chapter"><span class="calibre10">0.5 x 2</span><sup class="calibre32"><span class="calibre14">50</span></sup> <span class="calibre10">= 5.629 and 10</span><sup class="calibre32"><span class="calibre14">14</span></sup> <span class="calibre10">ms = 17838 years<br class="calibre2"/></span></li>
</ol>
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Output</span></strong></p>
<p class="mce-root"><span class="calibre14">The results may be as follows:</span></p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25"><strong class="calibre3">Input Size (n)</strong></td>
<td class="calibre25"><strong class="calibre3">Time : 1 Operations O(2<sup class="calibre32">n</sup>)</strong></td>
</tr>
<tr class="calibre26">
<td class="calibre25">2</td>
<td class="calibre25">2 milliseconds</td>
</tr>
<tr class="calibre24">
<td class="calibre25">10</td>
<td class="calibre25">512 milliseconds</td>
</tr>
<tr class="calibre26">
<td class="calibre25">30</td>
<td class="calibre25">6.2 days</td>
</tr>
<tr class="calibre27">
<td class="calibre25">50</td>
<td class="calibre25">17838 years</td>
</tr>
</tbody>
</table>
<div class="packt_figref"><span class="calibre10">Table 1.4: Timings for the O(2</span><sup class="calibre35"><span class="calibre14">n</span></sup><span class="calibre10">) algorithm</span></div>
<p class="mce-root">In this section, we have compared different types of algorithmic runtime complexities. We have seen how each compares against the others, starting from the theory's fastest of <em class="calibre19">O(1)</em> to some of the slowest with <em class="calibre19">O(k<sup class="calibre32">n</sup>)</em>. It's also important to understand that there is a difference between theory and practice. For example, in real life, a quadratic algorithm may outperform a linear one if the operations performed are less, the input is a fixed size, and is small.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Complexity Notation</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In the previous section, we have seen how we can use the big O notation to measure the runtime performance to our algorithms in proportion to the input size. We have neither examined in detail what <em class="calibre19">O(n)</em> really means nor have we considered the performance of our algorithm in relation to the type of input it's given.</p>
<p class="mce-root">Consider the following code snippet. The method accepts an array containing a string and searches for a match. If one is found, the index of the array is returned. We will use this example and try to measure the runtime complexity. The code is as follows:</p>
<pre class="calibre20"><span class="calibre10">public int search(String strToMatch, String[] strArray) {<br class="calibre2"/>  for (int i = 0; i &lt; strArray.length; i++) {<br class="calibre2"/>    if (strArray[i].equals(strToMatch)) {<br class="calibre2"/>      return i;<br class="calibre2"/>    }<br class="calibre2"/>  }<br class="calibre2"/>  return -1;<br class="calibre2"/>}</span> </pre>
<div class="packt_figref"><span class="calibre10">Snippet 1.3: Array search. Source class name:</span> <span class="calibre10">ArraySearch.</span></div>
<div class="packt_infobox"><span class="calibre10"><br class="calibre2"/>
Go to</span> <a href="https://goo.gl/egw1Sn" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/egw1Sn</span></a> <span class="calibre10">to access the code. <br class="calibre2"/></span></div>
<p class="mce-root"><span class="calibre14"><span class="calibre14">There are a number of operations happening inside the loop. The obvious ones are the arrays accessing at <kbd class="calibre15">i</kbd> and the string <kbd class="calibre15">equals</kbd>. However, we also have the increment of <kbd class="calibre15">i</kbd>, the assignment of the new incremented value to <kbd class="calibre15">i</kbd> and the comparison of <kbd class="calibre15">i</kbd> being less than the length of the array. However, this is not the end of the story. The <kbd class="calibre15">equals()</kbd> method is also matching each character of the string to an element at <kbd class="calibre15">i</kbd> in the array.</span></span></p>
<p class="mce-root"><span class="calibre14"><span class="calibre14">The following table lists all these operations:<br class="calibre7"/></span></span></p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25"><strong class="calibre3">Operation name</strong></td>
<td class="calibre25"><strong class="calibre3">Code</strong></td>
<td class="calibre25"><strong class="calibre3">Count</strong></td>
</tr>
<tr class="calibre26">
<td class="calibre25">Array access</td>
<td class="calibre25"><kbd class="calibre15">strArray[i]</kbd></td>
<td class="calibre25">1</td>
</tr>
<tr class="calibre24">
<td class="calibre25">String equality</td>
<td class="calibre25"><kbd class="calibre15">.equals(strToMatch)</kbd></td>
<td class="calibre25">String length</td>
</tr>
<tr class="calibre26">
<td class="calibre25">Array pointer increment and assignment</td>
<td class="calibre25"><kbd class="calibre15">i = i + 1</kbd></td>
<td class="calibre25">2</td>
</tr>
<tr class="calibre27">
<td class="calibre25">Reading array length and comparing to pointer</td>
<td class="calibre25"><kbd class="calibre15">i &lt; strArray.length</kbd></td>
<td class="calibre25">2</td>
</tr>
</tbody>
</table>
<div class="packt_figref"><span class="calibre10">Table 1.5: Operations performed in the</span> <span class="calibre10">ArraySearch</span> <span class="calibre10">method for every item</span></div>
<p class="mce-root">We have seen that for each processed item in the search array, we perform <em class="calibre19">5 + m</em> operations, where <em class="calibre19">m</em> is the length of the search string. The next aspect to look at is to work out how often we perform this. The number of times we perform the operations mentioned in <em class="calibre19">Table 1.5</em> doesn't just rely on the length of our input; it also depends on how quick we are in finding our match in the input array, that is, it depends on the actual array's contents.</p>
<div class="packt_infobox">The best case of an algorithm is when the input causes the algorithm to perform in the most efficient manner possible. The worst case is the opposite, which is when a particular input makes it behave in the least efficient manner possible.</div>
<p class="mce-root">If we are lucky and the item we are searching for is located in the first element of the search array, we perform only <em class="calibre19">5 + m</em> operations. This is the best case and is the fastest manner our search can compute.</p>
<p class="mce-root">The worst case of this algorithm is either when our item is at the end of the array or when the item is not found at all. Both of these scenarios will have us then check the entire contents of the array. In the worst case, we end up performing <em class="calibre19">n(5 + m)</em> operations, where <em class="calibre19">n</em> is the array size.</p>
<p class="mce-root">In this example, we can say that the worst-case runtime complexity for our algorithm is <em class="calibre19">O(mn)</em> and our best case, when our algorithm finds a match immediately, is <em class="calibre19">O(m)</em>. We will see in the following sub-section how we arrive at this result from <em class="calibre19">5 + m</em> and <em class="calibre19">n(5 + m)</em>.</p>
<p class="mce-root">Another algorithmic analysis that is commonly used is the average case performance. The average case complexity can be found by averaging the performance over all possible inputs. This is useful, as in certain scenarios, the worst case has a low chance of occurring.</p>
<div class="packt_infobox">Although we have the best, average, and worst-case complexities, the worst case is usually the most used when measuring and comparing different algorithms to one another. <span class="calibre10">Apart from runtime performance, the other most common use of big</span> O<span class="calibre10"> notation is to measure memory requirements. However, it can be used for any resource, such as disk space or network usage.<br class="calibre2"/></span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Identifying the Best and Worst Performance of an Algorithm While Checking for Duplicates in an Array</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We want to determine the complexity of an algorithm checking for duplicates in an array by considering the best and worst case performance. Find the number of operations performed in the <em class="calibre19">Snippet 1.4</em> for both the worst and best case. There is no need to work out the algorithmic complexity in big O notation. Assume that the inner loop results in eight operations every time it executes.</p>
<p class="mce-root">For the outer loop, assume four operations:</p>
<pre class="calibre20"><span class="calibre10">public boolean containsDuplicates(int[] numbers) {<br class="calibre2"/>  for (int i=0; i&lt;numbers.length; i++) {<br class="calibre2"/>    for (int j=0; j&lt;numbers.length; j++) {<br class="calibre2"/>      if (i != j &amp;&amp; numbers[i] == numbers[j]) return true;<br class="calibre2"/>    }<br class="calibre2"/>  }<br class="calibre2"/>  return false;<br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 1.4: Checking for duplicates. Source class name:</span> <span class="calibre10">Duplicates.</span></div>
<div class="packt_infobox"><span class="calibre10"><br class="calibre2"/>
Go to</span> <a href="https://goo.gl/wEUqYk" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/wEUqYk</span></a> <span class="calibre10">to access the code.</span></div>
<p class="mce-root">To do this, we should perform the following steps:</p>
<ol class="calibre17">
<li class="chapter">In the worst- case, we execute the inner loop <em class="calibre21">n</em> times (array length).</li>
<li class="chapter">In the best case, we only execute the inner loop only twice.</li>
<li class="chapter">The best case is when the duplicate numbers are in the front of the input array. The worst is when the array doesn't contain any duplicates.</li>
</ol>
<ol start="4" class="calibre17">
<li class="chapter">The worst case is when the array doesn't contain duplicates and is of size <em class="calibre21">n</em>:
<ul class="calibre12">
<li class="calibre37">For the outer loop, we have <em class="calibre21">4*n</em> operations</li>
<li class="calibre37">For the inner loop, we have <em class="calibre21">n*(n*8)</em> operations</li>
<li class="calibre37">In total, we have <em class="calibre21">4n + 8n<sup class="calibre32">2</sup></em> operations</li>
</ul>
</li>
<li class="chapter"><span class="calibre10">In the best case, the duplicates are the first two items in the array:</span>
<ul class="calibre12">
<li class="calibre37"><span class="calibre10">For the outer loop, we have</span> <em class="calibre21"><span class="calibre10">4</span></em> <span class="calibre10">operations</span></li>
<li class="calibre37"><span class="calibre10">For the inner loop, we have</span> <em class="calibre21"><span class="calibre10">2*8</span></em> <span class="calibre10">operations as the inner loop executes twice to get to the second item in the array where the duplicate is located</span></li>
<li class="calibre37"><span class="calibre10">In total, we have</span> <span class="calibre10">20</span> <span class="calibre10">operations</span></li>
</ul>
</li>
</ol>
<p class="mce-root">We have seen how we can analyze the number of operations performed in an algorithm and how we can use big O notation to describe the best and worst case. We also discussed how the notation can be used to describe any resource usage. In the next section, we'll describe some basic rules that are used when using the notation.</p>
<p class="mce-root"><strong class="calibre6">Notation Rules</strong></p>
<p class="mce-root">There are two simple rules to follow when we want to express an algorithm using the big O notation. In this section, we will understand how to convert the expression from <em class="calibre19">4n + 8n<sup class="calibre32">2</sup></em> to the big O notation equivalent.</p>
<p class="mce-root">The first rule to follow is to drop any constants.</p>
<p class="mce-root">For example, <em class="calibre19">3n + 4</em> becomes <em class="calibre19">n</em> and, a single constant such as <em class="calibre19">5</em> becomes <em class="calibre19">1</em>. If an algorithm simply has <em class="calibre19">4</em> constant instructions that don't depend on the input, we say the algorithm is <em class="calibre19">O(1)</em>, also known as <strong class="calibre6">constant time complexity</strong>.</p>
<p class="mce-root">The second rule is to drop everything except the highest order.</p>
<div class="packt_infobox">To understand why we adopt the second rule, it's important to realize that for a large value of <em class="calibre21">n</em>, anything but the highest order becomes irrelevant. When we have a large enough input, the performance difference is negligible.<span class="calibre10"><br class="calibre2"/></span></div>
<p class="mce-root">Consider an algorithm that performs <em class="calibre19">n + n<sup class="calibre32">2</sup> + n<sup class="calibre32">3</sup></em>. The highest order variable of this is the <em class="calibre19">n<sup class="calibre32">3</sup></em> part. If we keep the highest order, we end up with a big O runtime complexity of <em class="calibre19">O(n<sup class="calibre32">3</sup>)</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Activity: Converting Expressions to Big O Notations</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre6">Scenario</strong></p>
<p class="mce-root">To convert the expression <em class="calibre19">3mn + 5mn<sup class="calibre32">4 </sup>+2n<sup class="calibre32">2 </sup>+ 6</em> to a big O notation, firstly we drop any constants from the expression, leaving us with <em class="calibre19">mn+mn<sup class="calibre32">4</sup>+n<sup class="calibre32">2</sup></em>. Next, we simply keep the highest order part, which results in <em class="calibre19">O(mn<sup class="calibre32">4</sup>)</em>.</p>
<p class="mce-root">For each of the expressions found in <em class="calibre19">Table 1.6</em>, find the equivalent in big O notation:</p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre27">
<td class="calibre25"><strong class="calibre3">Expression</strong></td>
<td class="calibre25"><em class="calibre21">3mn</em></td>
<td class="calibre25"><em class="calibre21">5n + 44n<sup class="calibre32">2</sup> + 4</em></td>
<td class="calibre25"><em class="calibre21">4 + 5 log n</em></td>
<td class="calibre25"><em class="calibre21">3<sup class="calibre32">n</sup> + 5n<sup class="calibre32">2</sup> + 8</em></td>
</tr>
</tbody>
</table>
<div class="packt_figref"><span class="calibre10">Table 1.6: Find big O equivalent</span></div>
<p class="mce-root"><strong class="calibre6">Aim</strong></p>
<p class="mce-root"><span class="calibre14">To apply notation rules to convert expressions into big O notations.</span></p>
<p class="mce-root"><strong class="calibre6">Steps for completion</strong></p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Identify and drop the constants in the expression:</span>
<ul class="calibre12">
<li class="calibre37"><em class="calibre21"><span class="calibre10">3mn → </span><span class="calibre10">No constants <span class="calibre10">→ </span></span><span class="calibre10">3mn</span></em></li>
<li class="calibre37"><em class="calibre21"><span class="calibre10">5n + 44n<sup class="calibre32">2</sup> + 4 <span class="calibre10">→ </span></span><span class="calibre10">4 <span class="calibre10">→ </span></span><span class="calibre10">5n + 44n<sup class="calibre32">2</sup></span></em></li>
<li class="calibre37"><em class="calibre21"><span class="calibre10">4 + 5 log n <span class="calibre10">→ </span></span><span class="calibre10">4 <span class="calibre10">→ </span></span><span class="calibre10">5 log n</span></em></li>
<li class="calibre37"><em class="calibre21"><span class="calibre10">3</span><sup class="calibre32"><span class="calibre14">n</span></sup> <span class="calibre10">+ 5n<sup class="calibre32">2</sup> + 8 <span class="calibre10">→ </span></span><span class="calibre10">8 <span class="calibre10">→ </span></span><span class="calibre10">3</span><sup class="calibre32"><span class="calibre14">n</span></sup> <span class="calibre10"><span class="calibre10">+ 5n<sup class="calibre32">2</sup></span></span></em></li>
</ul>
</li>
<li class="chapter"><span class="calibre10">Drop everything except the highest-order part:</span>
<ul class="calibre12">
<li class="calibre37"><em class="calibre21"><span class="calibre10">3mn <span class="calibre10">→ </span></span><span class="calibre10">O(mn)</span></em></li>
<li class="calibre37"><em class="calibre21"><span class="calibre10">5n + 44n<sup class="calibre32">2 </sup><span class="calibre10">→ </span></span><span class="calibre10">O</span><span class="calibre10">(n<sup class="calibre32">2</sup>)</span></em></li>
<li class="calibre37"><em class="calibre21"><span class="calibre10">5 log n <span class="calibre10">→ </span></span><span class="calibre10">O(log n)</span></em></li>
<li class="calibre37"><em class="calibre21"><span class="calibre10">3</span><sup class="calibre32"><span class="calibre14">n</span></sup> <span class="calibre10">+ 5n<sup class="calibre32">2 </sup><span class="calibre10">→ </span></span><span class="calibre10">O(3</span><sup class="calibre32"><span class="calibre14">n</span></sup><span class="calibre10">)</span></em></li>
</ul>
</li>
</ol>
<p class="mce-root"><strong class="calibre6">Output</strong></p>
<p class="mce-root"><span class="calibre14">The outcome may be as follows:</span></p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25"><strong class="calibre3">Expression</strong></td>
<td class="calibre25"><em class="calibre21">3mn</em></td>
<td class="calibre25">
<p class="mce-root1"><em class="calibre19">5n + 44n<sup class="calibre32">2</sup> + 4</em></p>
</td>
<td class="calibre25"><em class="calibre21">4 + 5 log n</em></td>
<td class="calibre25"><em class="calibre21">3<sup class="calibre32">n</sup> + 5n<sup class="calibre32">2</sup> + 8</em></td>
</tr>
<tr class="calibre38">
<td class="calibre25"><strong class="calibre3">Solution</strong></td>
<td class="calibre25"><em class="calibre21">O(mn)</em></td>
<td class="calibre25"><em class="calibre21">O(n<sup class="calibre32">2</sup>)</em></td>
<td class="calibre25"><em class="calibre21">O(log n)</em></td>
<td class="calibre25"><em class="calibre21">O(3<sup class="calibre32">n</sup>)</em></td>
</tr>
</tbody>
</table>
<div class="packt_figref">Table 1.7: Solution to find big O equivalent activity</div>
<p class="mce-root">In this section, we have explored two simple rules used for converting expressions to big O notations. We have also learned why we keep only the highest-order from the expression. In the next section, we shall see some examples of algorithms with different complexities.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Identifying Algorithms with Different Complexities</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this section, we shall look into examples of different complexities. This is important so that we can learn to recognize algorithms that belong to different complexity classes and possibly attempt improving the performance of each.</p>
<div class="packt_infobox">Figuring out the worst case complexity can be quite difficult for some algorithms. Sometimes, this requires some experience and is best learned by looking at many examples and getting familiar with different types of algorithms.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Linear Complexity</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Linear algorithms are the ones where the work done varies in direct proportion with the input size, that is, if you double the input size, you double the work done. These typically involve a single pass through the input.</p>
<p class="mce-root">The problem presented in this example is that of counting the number of occurrences of a particular character in a string. Imagine we are given the string <q class="pcalibre5 pcalibre4 calibre33">Sally sells sea shells on the seashore</q>, and we want to find out the number of occurrences of the letter <em class="calibre19">a</em>.</p>
<p class="mce-root">The following code in <em class="calibre19">Snippet 1.5</em> goes through each character in the input string and if the character at the current position matches the search letter, a counter is increased. At the end of the loop, the final count is returned. The code is as follows:</p>
<pre class="calibre20"><span class="calibre10">public int countChars(char c, String str) {<br class="calibre2"/>  int count = 0;<br class="calibre2"/>  for (int i = 0; i &lt; str.length(); i++) {<br class="calibre2"/>    if (str.charAt(i) == c) count++;<br class="calibre2"/>  }<br class="calibre2"/>  return count;<br class="calibre2"/>}</span> </pre>
<div class="packt_figref">Snippet 1.5: Count the number of characters in a string. Source class name: CountChars.</div>
<div class="packt_infobox"><span class="calibre10"><br class="calibre2"/>
Go to</span> <a href="https://goo.gl/M4Vy7Y" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/M4Vy7Y</span></a> <span class="calibre10">to access the code.</span></div>
<p class="mce-root">Linear complexity algorithms are the most common types of algorithms. These usually make a single pass on the input and thus scale proportionally with the input size. In this section, we have seen one such example.</p>
<div class="packt_infobox">The algorithm is linear because its runtime is directly proportional to the string length. If we take the string length to be <em class="calibre21">n</em>, the runtime complexity of this Java method is <em class="calibre21">O(n)</em>. Notice the single loop varying according to the input size. This is very typical of linear runtime complexity algorithms, where a constant number of operations are performed for each input unit. The input unit in this example is each character in the string.<span class="calibre10"><br class="calibre2"/></span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Quadratic Complexity</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Quadratic complexity algorithms are not very performant for large input sizes. The work done increases following a quadratic proportion as we increase our input size. We already saw an example of a <em class="calibre19">O(n<sup class="calibre32">2</sup>)</em> in our minimum distance solution in <em class="calibre19">Snippet 1.2</em>. There are many other examples, such as bubble and selection sorting. The problem presented in this example is about finding the common elements contained in two arrays (assuming no duplicate values exist in each array), producing the intersection of the two inputs. This results in a runtime complexity of <em class="calibre19">O(mn)</em>, where <em class="calibre19">m</em> and <em class="calibre19">n</em> are the sizes of the first and second input arrays. If the input arrays are the same size as <em class="calibre19">n</em> elements, this results in a runtime of <em class="calibre19">O(n<sup class="calibre32">2</sup>)</em>. This can be demonstrated with the help of the following code:</p>
<pre class="calibre20"><span class="calibre10">public List&lt;Integer&gt; intersection(int[] a, int[] b) {<br class="calibre2"/>  List&lt;Integer&gt; result = new ArrayList&lt;&gt;(a.length);<br class="calibre2"/>  for (int x : a) {<br class="calibre2"/>    for (int y : b) {<br class="calibre2"/>      if (x == y) result.add(x);<br class="calibre2"/>    }<br class="calibre2"/>  }<br class="calibre2"/>  return result;<br class="calibre2"/>}</span> </pre>
<div class="packt_figref"><span class="calibre10">Snippet 1.6: Intersection between two arrays. Source class name:</span> <span class="calibre10">SimpleIntersection.</span></div>
<div class="packt_infobox"><span class="calibre10"><br class="calibre2"/>
Go to</span> <a href="https://goo.gl/uHuP5B" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/uHuP5B</span></a> <span class="calibre10">to access the code. <span class="calibre10">There is a more efficient implementation of the intersection problem. This involves sorting the array first, resulting in an overall runtime of <em class="calibre21">O(n log n)</em>.<br class="calibre2"/></span><span class="calibre10"><br class="calibre2"/>
When calculating the space complexity, the memory consumed for the input arguments should be ignored. Only memory allocated inside the algorithms should be considered.</span><span class="calibre10"><br class="calibre2"/></span></span></div>
<p class="mce-root">The amount of memory we use is dictated by the size of our result listed in our method. The bigger this list, the more memory we're using.</p>
<p class="mce-root">The best case is when we use the least amount of memory. This is when the list is empty, that is, when we have no common elements between the two arrays. Thus, this method has a best case space complexity of <em class="calibre19">O(1)</em>, when there is no intersection.</p>
<p class="mce-root">The worst case is just the opposite, when we have all the elements in both arrays. This can happen when the arrays are equal to each other, although the numbers may be in a different order. The memory in this case is equal to the size of one of our input arrays. In short, the worst space complexity of the method is <em class="calibre19">O(n)</em>.</p>
<p class="mce-root">In this section, we have shown examples of quadratic algorithms. Many other examples exist. In the next chapter, we will also describe a poorly-performing sorting algorithm, which is <em class="calibre19">O(n<sup class="calibre32">2</sup>)</em>, called <strong class="calibre6">bubble sort</strong>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Logarithmic Complexity</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Logarithmic complexity algorithms are very fast, and their performance hardly degrades as you increase the problem size. These types of algorithm scale really well. Code that has a runtime complexity of <em class="calibre19">O(log n)</em> is usually recognizable since it systematically divides the input in several steps. Common examples that operate in logarithmic times are database indexes and binary trees. If we want to find an item in a list, we can do it much more efficiently if the input list is sorted in some specific order. We can then use this ordering by jumping to specific positions of our list and skipping over a number of elements.</p>
<p class="mce-root"><em class="calibre19">Snippet 1.7</em> shows an implementation of the binary search in Java. The method uses three array pointers—a start, an end, and a midpoint. The algorithm starts by checking the middle element in the array. If the element is not found and is less than the value at the middle, we choose to search in the lower half; otherwise, we choose the upper half. <em class="calibre19">Figure 1.3</em> shows the steps involved when doing a binary search. The code snippet is as follows:</p>
<pre class="calibre20"><span class="calibre10">public boolean binarySearch(int x, int[] sortedNumbers) {<br class="calibre2"/>  int end = sortedNumbers.length - 1;</span> <br class="calibre2"/><span class="calibre10">  int start = 0;<br class="calibre2"/><span class="calibre10">  while (start &lt;= end) {<br class="calibre2"/>    int mid = (end - start) / 2 + start;<br class="calibre2"/>    if (sortedNumbers[mid] == x) return true;<br class="calibre2"/>    else if (sortedNumbers[mid] &gt; x) end = mid - 1;<br class="calibre2"/>    else start = mid + 1;<br class="calibre2"/>  }<br class="calibre2"/>  return false;<br class="calibre2"/>}</span><span class="calibre10"> </span></span></pre>
<div class="packt_figref"><span class="calibre10">Snippet 1.7: Binary search. Source class name:</span> <span class="calibre10">BinarySearch.</span></div>
<div class="packt_infobox"><span class="calibre10"><br class="calibre2"/>
Go to</span> <a href="https://goo.gl/R9e31d" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/R9e31d</span></a> <span class="calibre10">to access the code.</span></div>
<p class="mce-root"><span class="calibre14">Take a look at the following diagram:</span></p>
<p class="cdpaligncenter"><img src="Images/7fb57d9b-4d48-4059-8add-761694e069f1.png" width="1451" height="816" class="calibre39"/></p>
<div class="packt_figref"><span class="calibre10">Figure 1.3: Binary search steps</span></div>
<p class="mce-root">Assuming the worst case scenario, how big would the input size have to be if our binary search algorithm is 95 array jumps (such as the one shown in <em class="calibre19">Figure 1.3</em>)? Since this is a binary search, where we're splitting the search space in two, we should use a logarithm of base 2.</p>
<p class="mce-root"><span class="calibre14">Also, the inverse of a logarithm is the exponential. Thus, we can say the following:</span></p>
<ul class="calibre12">
<li class="calibre13"><em class="calibre21"><span class="calibre10">log</span><sub class="calibre40"><span class="calibre14">2</span></sub> <span class="calibre10">n = 95</span></em></li>
<li class="calibre13"><em class="calibre21"><span class="calibre10">2</span><sup class="calibre32"><span class="calibre14">95</span></sup> <span class="calibre10">= n</span></em></li>
<li class="calibre13"><em class="calibre21"><span class="calibre10">39614081257132168796771975168 = n</span></em></li>
</ul>
<div class="packt_infobox">For the record, <em class="calibre21">2<sup class="calibre35">95</sup></em> is larger than the number of seconds in the universe by far. This example demonstrates how well these types of algorithm scale. Even for huge inputs, the number of steps performed stays very small.</div>
<p class="mce-root">Logarithmic algorithms are the opposite of exponential ones. As the input gets bigger, the rate of performance degradation gets smaller. This is a very desirable property as it means that our problem can scale to a huge size and would hardly affect our performance. In this section, we gave one such example of this class of complexity.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Exponential Complexity</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">As we have seen previously, algorithms that have an exponential runtime complexity scale really poorly. There are many examples of problems for which only an <em class="calibre19">O(k<sup class="calibre32">n</sup>)</em> solution is known. Improving these algorithms is a very dynamic area of study in computer science. Examples of these include the traveling salesman problem and cracking a password using a brute force approach. Now, let's see an example of such problem.</p>
<p class="mce-root">A prime number is only divisible by itself and one. The example problem we present here is called the <strong class="calibre6">prime factorization problem</strong>. It turns out that if you have the right set of prime numbers, you can create any other possible number by multiplying them all together. The problem is to find out these prime numbers. More specifically, given an integer input, find all the prime numbers that are factors of the input (primes that when multiplied together give us the input).</p>
<div class="packt_infobox"><span class="calibre10">A lot of the current cryptographic techniques rely on the fact that no known polynomial time algorithm is known for prime factorization. However, nobody has yet proved that one doesn't exist. Hence, if a fast technique to find prime factors is ever discovered, many of the current encryption strategies will need to be reworked.<br class="calibre2"/></span></div>
<p class="mce-root"><em class="calibre19">Snippet 1.8</em> shows one implementation for this problem, called <strong class="calibre6">trail division</strong>. If we take an input decimal number of <em class="calibre19">n</em> digits, this algorithm would perform in <em class="calibre19">O(10<sup class="calibre32">n</sup>)</em> in the worst case. The algorithm works by using a counter (called <strong class="calibre6">factor</strong> in <em class="calibre19">Snippet 1.8</em>) starting at two and checks whether if it's a factor of the input. This check is done by using the modulus operator. If the modulus operation leaves no remainder, then the value of the counter is a factor and is added to the factor list. The input is then divided by this factor. If the counter is not a factor (the mod operation leaves a remainder), then the counter is incremented by one. This continues until <kbd class="calibre15">x</kbd> is reduced to one. This is demonstrated by the following code snippet:</p>
<pre class="calibre20"><span class="calibre10">public List&lt;Long&gt; primeFactors(long x) {<br class="calibre2"/>  ArrayList&lt;Long&gt; result = new ArrayList&lt;&gt;();<br class="calibre2"/>  long factor = 2;<br class="calibre2"/>  while (x &gt; 1) {<br class="calibre2"/>    if (x % factor == 0) {<br class="calibre2"/>      result.add(factor);<br class="calibre2"/>      x /= factor;<br class="calibre2"/>    } else {<br class="calibre2"/>      factor += 1;<br class="calibre2"/>    }<br class="calibre2"/>  }<br class="calibre2"/>  return result;<br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 1.8: Prime factors. Source class name:</span> <span class="calibre10"><span class="calibre10">FindPrimeFactors.</span></span></div>
<div class="packt_infobox"><span class="calibre10"><br class="calibre2"/>
Go to</span> <a href="https://goo.gl/xU4HBV" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/xU4HBV</span></a> <span class="calibre10">to access the code.</span></div>
<p class="mce-root"><span class="calibre14">Try executing the preceding code for the following two numbers:</span></p>
<ul class="calibre12">
<li class="calibre13"><em class="calibre21"><span class="calibre10">2100078578</span></em></li>
<li class="calibre13"><em class="calibre21"><span class="calibre10">2100078577</span></em></li>
</ul>
<p class="mce-root">Why does it take so long when you try the second number? What type of input triggers the worst-case runtime of this code?</p>
<p class="mce-root">The worst case of the algorithm is when the input is a prime number, wherein it needs to sequentially count all the way up to the prime number. This is what happens in the second input.</p>
<p class="mce-root">On the other hand, the largest prime factor for the first input is only 10,973, so the algorithm only needs to count up to this, which it can do quickly.</p>
<p class="mce-root">Exponential complexity algorithms are usually best avoided, and an alternate solution should be investigated. This is due to its really bad scaling with the input size. This is not to say that these types of algorithms are useless. They may be suitable if the input size is small enough or if it's guaranteed not to hit the worst case.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Constant Complexity</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The efficiency of constant runtime algorithms remains fixed as we increase the input size. Many examples of these exist. Consider, for example, accessing an element in an array. Access performance doesn't depend on the size of the array, so as we increase the size of the array, the access speed stays constant.</p>
<p class="mce-root">Consider the code in <em class="calibre19">Snippet 1.9</em>. The number of operations performed remains constant, irrespective of the size of the input radius. Such an algorithm is said to have a runtime complexity of <em class="calibre19">O(1)</em>. The code snippet is as follows:</p>
<pre class="calibre20"><span class="calibre10">private double circleCircumference(int radius) {<br class="calibre2"/>  return 2.0 * Math.PI * radius;<br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 1.9: Circle circumference. Source class name:</span> <span class="calibre10">CircleOperations.</span></div>
<div class="packt_infobox"><br class="calibre2"/>
Go to <a href="https://goo.gl/Rp57PB" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2">https://goo.gl/Rp57PB</a> to access the code.</div>
<p class="mce-root">Constant complexity algorithms are the most desirable out of all the complexity classes for the best scaling. Many of the simple mathematical functions, such as finding the distance between two points and mapping a three-dimensional coordinate to a two-dimensional one, all fall under this class.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Activity: Developing a Faster Intersection Algorithm</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre6">Scenario</strong></p>
<p class="mce-root">We have already seen an algorithm that produces an intersection between two input arrays in <em class="calibre19">Snippet 1.6</em>.</p>
<p class="mce-root">We have already shown how the runtime complexity of this algorithm is <em class="calibre19">O(n<sup class="calibre32">2</sup>)</em>. Can we write an algorithm with a faster runtime complexity?</p>
<p class="mce-root">To find a solution for this problem, think about how you would you go about finding the intersection by hand between two decks of playing cards. Imagine you take a subset from each shuffled deck; which technique would you use to find the common cards between the first and second deck?</p>
<p class="mce-root"><strong class="calibre6">Aim</strong></p>
<p class="mce-root"><span class="calibre14">To improve the performance of the array intersection algorithm and reduce its runtime complexity.</span></p>
<p class="mce-root"><strong class="calibre6">Prerequisites</strong></p>
<ul class="calibre12">
<li class="calibre13">Ensure that you have a class available at: <br class="calibre2"/>
<a href="https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson1/activity/improveintersection/Intersection.java" class="pcalibre pcalibre3 calibre11 pcalibre1 pcalibre2">https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson1/activity/improveintersection/Intersection.java</a></li>
<li class="calibre13">You will find two methods for improving the intersection:
<ul class="calibre12">
<li class="calibre13">The slow intersection:</li>
</ul>
</li>
</ul>
<pre class="calibre41"><span class="calibre10">public List&lt;Integer&gt; intersection(int[] a, int[] b)</span>  </pre>
<ul class="calibre12">
<li class="calibre42">
<ul class="calibre12">
<li class="calibre13"><span class="calibre10">The empty stub, returning null:</span></li>
</ul>
</li>
</ul>
<pre class="calibre41"><span class="calibre10">public List&lt;Integer&gt; intersectionFast(int[] a, int[] b)</span>  </pre>
<ul class="calibre12">
<li class="calibre13"><span class="calibre10">Use the second, empty stub method, to implement a faster alternative for the intersection algorithm.</span></li>
<li class="calibre13"><span class="calibre10">Assume that each array has no duplicate values. If you have your project set up, you can run the unit test for this activity by running the following command:</span></li>
</ul>
<pre class="calibre30"><strong class="calibre3"><span class="calibre10">gradlew test --tests com.packt.datastructuresandalg.lesson1.activity.improveintersection*</span>  </strong></pre>
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Steps for Completion</span></strong></p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Assume that we have a way to sort the inputs in</span> <em class="calibre21"><span class="calibre10">O(n log n)</span></em><span class="calibre10">. This is provided in the following method:</span></li>
</ol>
<pre class="calibre30"><span class="calibre10">public void mergeSort(int[] input) {<br class="calibre2"/>  Arrays.sort(input);<br class="calibre2"/>}</span>  </pre>
<p class="calibre29"><span class="calibre14">We can use this method to sort one input array, or both, and make the intersection easier.</span></p>
<ol start="2" class="calibre17">
<li class="chapter"><span class="calibre10">To sort one input array, we can use a binary search on it. The runtime complexity is</span> <em class="calibre21"><span class="calibre10">O(n log n)</span></em> <span class="calibre10">for the merge sort plus</span> <em class="calibre21"><span class="calibre10">O(n log n)</span></em> <span class="calibre10">for the binary search<br class="calibre2"/>
per item in the first list. This is</span> <em class="calibre21"><span class="calibre10">nlog+ nlog n</span></em> <span class="calibre10">which results in a final</span> <em class="calibre21"><span class="calibre10">O(n log n)</span></em><span class="calibre10"><span class="calibre10">.</span></span></li>
<li class="chapter"><span class="calibre10">Sort both arrays, and have two pointers, one for each array.</span></li>
<li class="chapter"><span class="calibre10">Go through the input arrays in a linear fashion.</span></li>
<li class="chapter"><span class="calibre10">Advance a pointer if the other pointer is pointing to a larger value.</span></li>
<li class="chapter"><span class="calibre10">If the values at both pointers are equal, both pointers are incremented. The runtime complexity for this algorithm is</span> <em class="calibre21"><span class="calibre10">2 * (n log n)</span></em> <span class="calibre10">for the two merge sorts plus the</span> <em class="calibre21"><span class="calibre10">n</span></em> <span class="calibre10">for the linear pass after the sorting. This results in </span><em class="calibre21"><span class="calibre10">2 * (n log n) + n</span></em> <span class="calibre10">with a final</span> <em class="calibre21"><span class="calibre10">O(n log n)</span></em><span class="calibre10">.</span></li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we gave an introduction to algorithmic complexity and the notation to describe it. We have shown you how big O notation can be used to describe how well an algorithm scales as the input gets bigger. We have also seen various examples of complexities and shown you how you can intuitively differentiate between them. Understanding big O notations comes in handy when you need to design and implement new solutions or when you are diagnosing performance issues.</p>


            </article>

            
        </section>
    </div>



  </body></html>