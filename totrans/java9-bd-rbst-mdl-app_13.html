<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Concurrency and Reactive Programming</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In the previous <span class="calibre7">chapter, we covered several <strong class="calibre8">Java Enhancement Proposals</strong> (<strong class="calibre8">JEPs</strong>) that were incorporated into the Java 9 platform. These JEPs represented a wide range of tools and updates to APIs to make developing with Java easier, with greater optimization possibilities for our Java applications. We looked at the new HTTP client, changes to Javadoc and the Doclet API, the new JavaScript parser, JAR and JRE changes, the new Java-level JVM compiler interface, the new support for TIFF images, platform logging, XML catalog support, collections, and the new platform-specific desktop features. We also looked at enhancements to method handling and the deprecation annotation.</span></p>
<p class="mce-root">In this chapter <span class="calibre7">we will cover concurrency enhancements introduced with the Java 9 platform. Our primary focus</span> will <span class="calibre7">be the support for reactive programming, a concurrency enhancement that is provided by the <kbd class="calibre16">Flow</kbd> class API. Reactive programming is a new concept for Java 9, so we will take an exploratory approach to the topic. We will also explore additional concurrency enhancements introduced in Java 9.</span></p>
<p class="mce-root">Specifically, we will cover the following topics:</p>
<ul class="calibre13">
<li class="calibre14">Reactive programming</li>
<li class="calibre14">The new <kbd class="calibre16">Flow</kbd> API</li>
<li class="calibre14">Additional concurrency updates</li>
<li class="calibre14">Spin-wait hints</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Reactive Programming</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Reactive programming is when applications react to an asynchronous data stream as it occurs. The following image illustrates the flow:</p>
<div class="mce-root1"><img src="Images/a5cf435c-d95d-4d94-8eb4-26e21fb59fc7.png" width="1005" height="667" class="calibre140"/></div>
<p class="mce-root">Reactive programming is not a fancy software engineering term only used by academics. It is, in fact, a programming model that can result in much greater efficiencies as opposed to the more common method of having applications iterate over data that is in memory.</p>
<p class="mce-root">There is more to reactive programming. First, let's consider that the data stream is provided by a publisher in an asynchronous manner to the subscriber.</p>
<div class="packt_infobox">Data streams are a binary input/output of strings and primitive data types. The <kbd class="calibre39">DataInput</kbd> interface is used for an input stream and the <kbd class="calibre39">DataOutput</kbd> interface is used for output streams.</div>
<p class="mce-root">Processors, or a chain of processors, can be used to transform the data stream without the publisher or subscriber being impacted. In the following example, the <strong class="calibre8">Processors</strong> work on the stream of data without <strong class="calibre8">Publisher</strong> or <strong class="calibre8">Subscriber</strong> involvement, or even awareness:</p>
<div class="mce-root1"><img src="Images/4aa45ee8-9b19-457a-90fd-5f3a333864af.png" width="968" height="496" class="calibre141"/></div>
<p class="mce-root">In addition to greater efficiency, reactive programming represents several additional benefits, which are highlighted here:</p>
<ul class="calibre13">
<li class="calibre14">The code base can be less verbose, making it:
<ul class="calibre13">
<li class="calibre14">Easier to code</li>
<li class="calibre14">Easier to maintain</li>
<li class="calibre14">Easier to read</li>
</ul>
</li>
<li class="calibre14">Stream processing results in memory efficiencies</li>
<li class="calibre14">This is a solution for a variety of programming applications</li>
<li class="calibre14">Less boiler-plate code needs to be written, so development time can be focused on programming core functionalities</li>
<li class="calibre14">The following types of programming require less time and code:
<ul class="calibre13">
<li class="calibre14">Concurrency</li>
<li class="calibre14">Low-level threading</li>
<li class="calibre14">Synchronization</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Reactive programming standardization</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">There are standards in many aspects of software development, and reactive programming has not escaped this. There is a <strong class="calibre8">Reactive Streams</strong> initiative to standardize asynchronous stream processing. The specific focus, in the context of Java, is with the JVM and JavaScript.</p>
<p class="mce-root">The Reactive Streams initiative aims at tackling the issue of governing how the data stream is exchanged between threads. As you will recall from the previous section, the idea of processors is predicated on there being no impact on the publisher or receiver. This no-impact mandate stipulates that the following are not required:</p>
<ul class="calibre13">
<li class="calibre14">Data buffering</li>
<li class="calibre14">Data translation</li>
<li class="calibre14">Conversion</li>
</ul>
<p class="mce-root">The basic semantics of the standard define the regulation of data stream element transmission. This standard was specifically established for delivery with the Java 9 platform. Reactive Streams includes a library that will help developers convert from <kbd class="calibre16">org.reactivestreams</kbd> and <kbd class="calibre16">java.util.concurrent.Flow</kbd> namespaces.</p>
<p class="mce-root">The key to being successful with reactive programming and the Reactive Streams standardization is understanding the relevant terminology:</p>
<table class="calibre30">
<tbody class="calibre31">
<tr class="calibre32">
<td class="calibre33"><strong class="calibre3">Term</strong></td>
<td class="calibre33"><strong class="calibre3">Description</strong></td>
</tr>
<tr class="calibre34">
<td class="calibre33">Demand</td>
<td class="calibre33">Demand refers to the subscriber's request for more elements as well as referring to the total number of elements requested that have not been fulfilled by the publisher yet.</td>
</tr>
<tr class="calibre32">
<td class="calibre33">Demand</td>
<td class="calibre33">Demand also refers to the total number of elements requested that have not been fulfilled by the publisher yet.</td>
</tr>
<tr class="calibre34">
<td class="calibre33">External synchronization</td>
<td class="calibre33">External access coordination for thread safety.</td>
</tr>
<tr class="calibre32">
<td class="calibre33">Non-obstructing</td>
<td class="calibre33">Methods are said to be non-obstructing if they rapidly execute without the requirement for heavy computations. Non-obstructing methods do not delay a subscriber's thread execution.</td>
</tr>
<tr class="calibre34">
<td class="calibre33">NOP</td>
<td class="calibre33">NOP execution is execution that can be called repeatedly without impact to the calling thread.</td>
</tr>
<tr class="calibre32">
<td class="calibre33">Responsivity</td>
<td class="calibre33">This term refers to a component's ability to respond.</td>
</tr>
<tr class="calibre34">
<td class="calibre33">Return normally</td>
<td class="calibre33">Return normally refers to when there are no errors--the normal condition. The <kbd class="calibre16">onError</kbd> method is the only way permitted by the standard to inform the subscriber of a failure.</td>
</tr>
<tr class="calibre41">
<td class="calibre33">Signal</td>
<td class="calibre33">
<p class="mce-root3">One of the following methods:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">cancel</kbd></li>
<li class="calibre14"><kbd class="calibre16">onComplete</kbd></li>
<li class="calibre14"><kbd class="calibre16">onError</kbd></li>
<li class="calibre14"><kbd class="calibre16">onNext</kbd></li>
<li class="calibre14"><kbd class="calibre16">onSubscribe</kbd></li>
<li class="calibre14"><kbd class="calibre16">request</kbd></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="mce-root">Â </p>
<p class="mce-root">You can obtain the standard on Maven Central (<a href="https://search.maven.org" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://search.maven.org</a>). Here is the standard from Maven Central as of the publication date of this book:</p>
<pre class="calibre21">    &lt;dependency&gt;<br class="calibre2"/>      &lt;groupId&gt;org.reactivestreams&lt;/groupId&gt;<br class="calibre2"/>      &lt;artifactId&gt;reative-streams&lt;/artifactId&gt;<br class="calibre2"/>      &lt;version&gt;1.0.1&lt;/version&gt;<br class="calibre2"/>    &lt;/dependency&gt;<br class="calibre2"/><br class="calibre2"/>    &lt;dependency&gt;<br class="calibre2"/>      &lt;groupId&gt;org.reactivestreams&lt;/groupId&gt;<br class="calibre2"/>      &lt;artifact&gt;reactive-streams-tck&lt;/artifactId&gt;<br class="calibre2"/>      &lt;version&gt;1.0.0&lt;/version&gt;<br class="calibre2"/>      &lt;scope&gt;test&lt;/scope&gt;<br class="calibre2"/>    &lt;/dependency&gt;</pre>
<p class="mce-root">In the next section, we will look at the Flow APIs in the Java 9 platform, as they correspond to the Reactive Streams specification.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The New Flow API</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre16">Flow</kbd> class is part of the <kbd class="calibre16">java.util.concurrent</kbd> package. It helps developers incorporate reactive programming in their applications. The class has one method, <kbd class="calibre16">defaultBufferSize()</kbd>, and four interfaces.</p>
<p class="mce-root">The <kbd class="calibre16">defaultBufferSize()</kbd> is a static method that returns the default buffer size for publishing and subscribing buffering. This default value is <kbd class="calibre16">256</kbd> and it is returned as an <kbd class="calibre16">int</kbd>. Let's look at the four interfaces.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The Flow.Publisher interface</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre16">Flow.Publisher</kbd> interface is a functional interface. A <kbd class="calibre16">Publisher</kbd> is a producer of data sent to subscribers:</p>
<pre class="calibre21">    @FunctionalInterface<br class="calibre2"/>    public static interface Flow.Publisher&lt;T&gt;</pre>
<p class="mce-root"><span class="calibre7">This functional interface can serve as a lambda expression assignment target.</span> It only takes one argument--the subscribed item type <kbd class="calibre16">&lt;T&gt;</kbd>. It has one method:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16"><span class="calibre5">void onSubscribe(Flow.Subscription subscription)</span></kbd></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The Flow.Subscriber interface</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre16">Flow.Subscriber</kbd> interface is used to receive messages and its implementation is shown here:</p>
<pre class="calibre21">    public static interface Flow.Subscriber&lt;T&gt;</pre>
<p class="mce-root"><span class="calibre7">This interface is set up to receive messages.</span> It only takes one argument--the subscribed item type <kbd class="calibre16">&lt;T&gt;</kbd>. It has the following methods:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16"><span class="calibre5">void onComplete()</span></kbd></li>
<li class="calibre14"><kbd class="calibre16"><span class="calibre5">void onError(Throwable throwable)</span></kbd></li>
<li class="calibre14"><kbd class="calibre16"><span class="calibre5">void onNext(T item)</span></kbd></li>
<li class="calibre14"><kbd class="calibre16"><span class="calibre5">void onSubscribe(Flow.Subscription subscription)</span></kbd></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The Flow.Subscription interface</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre16">Flow.Subscription</kbd> interface ensures that only subscribers receive what is requested. Also, as you will see here, a subscription can be cancelled at anytime:</p>
<pre class="calibre21">    public static interface Flow.Subscription</pre>
<p class="mce-root"><span class="calibre7">This interface does not take any arguments and is the linkage that controls the messages between instances of <kbd class="calibre16">Flow.Publisher</kbd> and <kbd class="calibre16">Flow.Subscriber</kbd>. It has the following</span> methods:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16"><span class="calibre5">void cancel()</span></kbd></li>
<li class="calibre14"><kbd class="calibre16"><span class="calibre5">void request(long n)</span></kbd></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The Flow.Processor interface</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre16">Flow.Processor</kbd> interface <span class="calibre7">can serve as both a <kbd class="calibre16">Subscriber</kbd> and a <kbd class="calibre16">Publisher</kbd>. The</span> implementation is provided here:</p>
<pre class="calibre21">    static interface Flow.Processor&lt;T,R&gt; extends Flow.Subscriber&lt;T&gt;,<br class="calibre2"/>     Flow.Publisher&lt;R&gt;</pre>
<p class="mce-root"><span class="calibre7">This interface</span> takes two arguments--the subscribed item type <kbd class="calibre16">&lt;T&gt;</kbd> and the published item type <kbd class="calibre16">&lt;R&gt;</kbd>. It does not have its own methods, but does inherit the following method from <kbd class="calibre16">java.util.concurrent.Flow.Publisher</kbd>:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">void subscribe(Flow.Subscriber&lt;? super T&gt; subscriber)</kbd></li>
</ul>
<p class="mce-root"><kbd class="calibre16">Flow.Processor</kbd> also inherits the following methods from the <kbd class="calibre16">java.util.concurrent.Flow.Subscriber</kbd> interface:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16"><span class="calibre5">void onComplete()</span></kbd></li>
<li class="calibre14"><kbd class="calibre16"><span class="calibre5">void onError(Throwable throwable)</span></kbd></li>
<li class="calibre14"><kbd class="calibre16"><span class="calibre5">void onNext(T item)</span></kbd></li>
<li class="calibre14"><kbd class="calibre16"><span class="calibre5">void onSubscribe(Flow.Subscription subscription)</span></kbd></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Sample implementation</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In any given implementation of reactive programming, we will have a <kbd class="calibre16">Subscriber</kbd> that requests data and a <kbd class="calibre16">Publisher</kbd> that provides the data. Let's first look at a sample <kbd class="calibre16">Subscriber</kbd> implementation:</p>
<pre class="calibre21">    import java.util.concurrent.Flow.*;<br class="calibre2"/><br class="calibre2"/>    public class packtSubscriber&lt;T&gt; implements Subscriber&lt;T&gt;<br class="calibre2"/>    {<br class="calibre2"/>      private Subscription theSubscription;<br class="calibre2"/><br class="calibre2"/>      // We will override the four Subscriber interface methods<br class="calibre2"/><br class="calibre2"/>      @Override<br class="calibre2"/>      public void onComplete()<br class="calibre2"/>      {<br class="calibre2"/>        System.out.println("Data stream ended");<br class="calibre2"/>      }<br class="calibre2"/><br class="calibre2"/><span class="calibre5">      @Override<br class="calibre2"/></span>      public void onError(Throwable theError)<br class="calibre2"/>      {<br class="calibre2"/>        theError.printStackTrace();<br class="calibre2"/>      }<br class="calibre2"/><br class="calibre2"/>      @Override<br class="calibre2"/>      public void onNext(T theItem)<br class="calibre2"/>      {<br class="calibre2"/>        System.out.println("Next item received: " + theItem);<br class="calibre2"/>        theSubscription.request(19);  // arbitrary number for<br class="calibre2"/>         example purposes<br class="calibre2"/>      }<br class="calibre2"/><br class="calibre2"/>      @Override<br class="calibre2"/>      public void onSubscribe(Subscription theSubscription)<br class="calibre2"/>      {<br class="calibre2"/>        this.theSubscription = theSubscription;<br class="calibre2"/>        theSubscription.request(19);<br class="calibre2"/>      }<br class="calibre2"/><br class="calibre2"/>    } </pre>
<p class="mce-root">As you can see, implementing the <kbd class="calibre16">Subscriber</kbd> is not difficult. The heavy work is done with the processors in-between the <kbd class="calibre16">Subscriber</kbd> and <kbd class="calibre16">Publisher</kbd>. Let's look at a sample implementation where the <kbd class="calibre16">Publisher</kbd> publishes a data stream to subscribers:</p>
<pre class="calibre21">    import java.util.concurrent.SubsmissionPublisher;<br class="calibre2"/><br class="calibre2"/>    . . . <br class="calibre2"/><br class="calibre2"/>    // First, let's create a Publisher instance<br class="calibre2"/>    SubmissionPublisher&lt;String&gt; packtPublisher = new <br class="calibre2"/>     SubmissionPublisher&lt;&gt;();<br class="calibre2"/><br class="calibre2"/>    // Next, we will register a Subscriber<br class="calibre2"/>    PacktSubscriber&lt;String&gt; currentSubscriber = new <br class="calibre2"/>     PacktSubscriber&lt;&gt;();<br class="calibre2"/>    packtPublisher.subscribe(currentSubscriber);<br class="calibre2"/><br class="calibre2"/>    // Finally, we will publish data to the Subscriber and <br class="calibre2"/>       close the publishing effort<br class="calibre2"/>    System.out.println("||---- Publishing Data Stream ----||");<br class="calibre2"/>    . . . <br class="calibre2"/>    packtPublisher.close();<br class="calibre2"/>    System.out.println("||---- End of Data Stream Reached ----||");</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Additional Concurrency Updates</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <strong class="calibre8">More Concurrency Updates</strong> Java Enhancement Proposal, JEP 266, aimed to improve the use of concurrency in Java. In this section, we will briefly explore the concept of Java concurrency and look at related enhancements to the Java 9 platform:</p>
<ul class="calibre13">
<li class="calibre14">Java concurrency</li>
<li class="calibre14">Supporting Reactive Streams</li>
<li class="calibre14"><kbd class="calibre16">CompletableFuture</kbd> API enhancements</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Java concurrency</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this section, we will start with a brief explanation of concurrency, then look at system configurations, cover Java threads, and then look at the concurrency improvements.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Concurrency explained</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Concurrent processing has been around since the 1960s. In those formative years, we already had systems that permitted multiple processes to share a single processor. These systems are more clearly defined as pseudo-parallel systems because it only appeared that multiple processes were being simultaneously executed. Our computers today still operate in this manner. The difference between the 1960s and current day is that our computers can have multiple CPUs, each with multiple cores, which better supports concurrency.</p>
<div class="packt_infobox">Concurrency and parallelism are often used as interchangeable terms. Concurrency is when multiple processes overlap, although the start and stop times could be different. Parallelism occurs when tasks start, run, and stop at the same time.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">System configurations</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">There are several different processor configurations that need to be considered. This section features two common configurations. The first configuration is that of shared memory and is illustrated here:</p>
<div class="mce-root1"><img src="Images/4f1ef63e-003b-4a3a-973f-e82324ce684e.png" width="1930" height="798" class="calibre142"/></div>
<p class="mce-root">As you can see, the shared memory system configuration has multiple processors that all share a common system memory. The second featured system configuration is a distributed memory system:</p>
<div class="mce-root1"><img src="Images/3f1b68be-2893-44ad-a1a9-adecc3d57894.png" width="1500" height="1258" class="calibre143"/></div>
<p class="mce-root">With the distributed memory system, each processor has its own memory and each individual processor is fully linked with the other processors, making for a distributed system that is fully linked.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Java threads</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">A thread in Java is a program execution and is built into the JVM. The <kbd class="calibre16">Thread</kbd> class is part of the <kbd class="calibre16">java.lang</kbd> package (<kbd class="calibre16">java.lang.Thread</kbd>). Threads have priorities that control in what order the JVM executes them. While the concept is simple, implementation is not. Let's start by taking a close look at the <kbd class="calibre16">Thread</kbd> class.</p>
<p class="mce-root">The <kbd class="calibre16">Thread</kbd> class has two nested classes:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public static enum Thread.State</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static interface Thread.UncaughtExceptionHandler</kbd></li>
</ul>
<p class="mce-root">There are three instance variables for managing thread priorities:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public static final int MAX_PRIORITY</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static final int MIN_PRIORITY</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static final int NORM_PRIORITY</kbd></li>
</ul>
<p class="mce-root">The <kbd class="calibre16">Thread</kbd> class has eight constructors, all of which allocate a new <kbd class="calibre16">Thread</kbd> object. Here are the constructor signatures:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public Thread()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public Thread(Runnable target)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public Thread(Runnable target, String name)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public Thread(String name)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public Thread(ThreadGroup group, Runnable target)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public Thread(ThreadGroup group, Runnable target, String name)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public Thread(ThreadGroup group, Runnable target, String name, long stackSize)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public Thread(ThreadGroup group, String name)</kbd></li>
</ul>
<p class="mce-root">The <kbd class="calibre16">Thread</kbd> class also has 43 methods, six of which have been deprecated. The remaining methods are listed here, save for the accessors and mutators which are listed separately. You can consult the documentation for details about each of these methods:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public static int activeCount()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public final void checkAccess()</kbd></li>
<li class="calibre14"><kbd class="calibre16">protected Object clone() throws CloneNotSupportedException</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static Thread currentThread()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static void dumpStack()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static int enumerate(Thread[] array)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static boolean holdsLock(Object obj)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public void interrupt()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static boolean interrupted()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public final boolean isAlive()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public final boolean isDaemon()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public boolean isInterrupted()</kbd></li>
<li class="calibre14">join methods:
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public final void join() throws InterruptedException</kbd></li>
<li class="calibre14"><kbd class="calibre16">public final void join(long millis) throws InterruptedException</kbd></li>
<li class="calibre14"><kbd class="calibre16">public final void join(long millis, int nano) throws InterruptedException</kbd></li>
</ul>
</li>
<li class="calibre14"><kbd class="calibre16">public void run()</kbd></li>
<li class="calibre14">sleep methods:
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public static void sleep(long mills) throws InterruptedException</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static void sleep(long mills, int nano) throws InterruptedException</kbd></li>
</ul>
</li>
<li class="calibre14"><kbd class="calibre16">public void start()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public String toString()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static void yield()</kbd></li>
</ul>
<p class="mce-root">Here is the list of accessors/getters and mutators/setters for the <kbd class="calibre16">Thread</kbd> class:</p>
<ul class="calibre13">
<li class="calibre14">accessors/getters:
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public static Map&lt;Thread, StackTraceElement[]&gt; getAllStacktraces()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public ClassLoader getContextClassLoader()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static Thread.UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public long getId()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public final String getName()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public final int getPriority()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public StackTraceElement[] getStackTrace()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public Thread.State getState()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public final ThreadGroup getThreadGroup()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public Thread.UncaughtExceptionHandler getUncaughtExceptionHandler()</kbd></li>
</ul>
</li>
</ul>
<ul class="calibre13">
<li class="calibre14">mutators/setters:
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public void setContextClassLoader(ClassLoader cl)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public final void setDaemon(boolean on)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static void setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public final void setName(String name)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public final void setPriority(int newPriority)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public void setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)</kbd></li>
</ul>
</li>
</ul>
<p class="mce-root"><span class="calibre7">In Java, concurrency is commonly referred to as multithreading. As indicated earlier, managing threads, and especially multithreads, requires great fidelity in control. Java employs a couple of techniques including the use of locks. Code segments can be locked to ensure that only a single thread can execute that code at any given time. We can lock classes and method with the use of the <kbd class="calibre16">synchronized</kbd> keyword. Here is an example of how to lock an entire method:</span></p>
<pre class="calibre21">    public synchronized void protectedMethod()<br class="calibre2"/>    {<br class="calibre2"/>      . . . <br class="calibre2"/>    }</pre>
<p class="mce-root">The next code snippet demonstrates how to use the synchronized keyword to lock blocks of code within a method:</p>
<pre class="calibre21">    . . . <br class="calibre2"/>    public class unprotectedMethod()<br class="calibre2"/>    {<br class="calibre2"/>      . . . <br class="calibre2"/>      public int doSomething(int tValue) <br class="calibre2"/>      {<br class="calibre2"/>        synchronized (this)<br class="calibre2"/>        {<br class="calibre2"/>          if (tValue != 0)<br class="calibre2"/>          {<br class="calibre2"/>            // do something to change tValue<br class="calibre2"/>            return tValue;<br class="calibre2"/>          }<br class="calibre2"/>        }<br class="calibre2"/>      } <br class="calibre2"/>    }</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Concurrency improvements</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The ability to employ multiple threads in our Java applications stands to greatly improve efficiency and leverage the increasing processing capabilities of modern computers. The use of threads in Java gives us great granularity in our concurrency controls.</p>
<p class="mce-root">Threads are at the core of Java's concurrency functionality. We can create a thread in Java by defining a <kbd class="calibre16">run</kbd> method and instantiating a <kbd class="calibre16">Thread</kbd> object. There are two methods of accomplishing this set of tasks. Our first option is to extend the <kbd class="calibre16">Thread</kbd> class and override the <kbd class="calibre16">Thread.run</kbd> method. Here is an example of that approach:</p>
<pre class="calibre21">    . . .<br class="calibre2"/>    class PacktThread extends Thread<br class="calibre2"/>    {<br class="calibre2"/>      . . .<br class="calibre2"/>      public void run()<br class="calibre2"/>      {<br class="calibre2"/>        . . . <br class="calibre2"/>      }<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    . . . <br class="calibre2"/><br class="calibre2"/>    Thread varT = new PacktThread();<br class="calibre2"/><br class="calibre2"/>    . . .<br class="calibre2"/><br class="calibre2"/>    // This next line is start the Thread by executing<br class="calibre2"/>       the run() method.<br class="calibre2"/>    varT.start();<br class="calibre2"/><br class="calibre2"/>    . . . </pre>
<p class="mce-root">A second approach is to create a class that implements the <kbd class="calibre16">Runnable</kbd> interface and passing an instance of the class to the constructor of the <kbd class="calibre16">Thread</kbd>. Here is an example:</p>
<pre class="calibre21">    . . . <br class="calibre2"/>    class PacktRunner implements Runnable<br class="calibre2"/>    {<br class="calibre2"/>       . . .<br class="calibre2"/>      public void run()<br class="calibre2"/>      {<br class="calibre2"/>        . . .<br class="calibre2"/>      }<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    . . . <br class="calibre2"/><br class="calibre2"/>    PacktRunner varR = new PacktRunner();<br class="calibre2"/>    Thread varT = new Thread(varR);<br class="calibre2"/><br class="calibre2"/>    . . .<br class="calibre2"/><br class="calibre2"/>    // This next line is start the Thread by executing the <br class="calibre2"/>       run() method.<br class="calibre2"/>    varT.start();<br class="calibre2"/><br class="calibre2"/>    . . . </pre>
<p class="mce-root">Both of these methods work equally well, and which one you use is considered to be the developer's choice. Of course, if you are looking for additional flexibility, the second approach is probably a better one to use. You can experiment with both methods to help you make your determination.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">CompletableFuture API enhancements</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre16">CompleteableFuture&lt;T&gt;</kbd> class is part of the <kbd class="calibre16">java.util.concurrent</kbd> package. The class extends the <kbd class="calibre16">Object</kbd> class and implements the <kbd class="calibre16">Future&lt;T&gt;</kbd> and <kbd class="calibre16">CompletionStage&lt;T&gt;</kbd> interfaces. This class is used to annotate threads that can be completed. We can use the <kbd class="calibre16">CompletableFuture</kbd> class to represent a future result. When the complete method is used, that future result can be completed.</p>
<p class="mce-root">It is important to realize that if multiple threads attempt to simultaneously complete (finish or cancel), all but one will fail. Let's look at the class and then look at the enhancements.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Class details</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">The</span> <kbd class="calibre16">CompleteableFuture&lt;T&gt;</kbd> <span class="calibre7">class has one internal class that marks asynchronous tasks:</span></p>
<pre class="calibre21">    public static interface<br class="calibre2"/>     CompletableFuture.AsynchronousCompletionTask</pre>
<p class="mce-root">The constructor for <span class="calibre7">the</span> <kbd class="calibre16">CompleteableFuture&lt;T&gt;</kbd> <span class="calibre7">class has to be in sync with the provided constructor signature, and it takes no arguments. The class has the following methods organized by what they return.</span></p>
<p class="mce-root">Returns a <kbd class="calibre16">CompletionStage</kbd>:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;Void&gt; acceptEither(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;Void&gt; acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;Void&gt; acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action, Executor executor)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public &lt;U&gt; CompletableFuture&lt;U&gt; applyToEither(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public &lt;U&gt; CompletableFuture&lt;U&gt; applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public &lt;U&gt; CompletableFuture&lt;U&gt; applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn, Executor executor)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static &lt;U&gt; CompletedStage&lt;U&gt; completedStage(U value)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static &lt;U&gt; CompletionStage&lt;U&gt; failedStage(Throwable ex)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public &lt;U&gt; CompletableFuture&lt;U&gt; handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public &lt;U&gt; CompletableFuture&lt;U&gt; handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public &lt;U&gt; CompletableFuture&lt;U&gt; handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn, Executor executor)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public CompletionStage&lt;T&gt; minimalCompletionStage()</kbd></li>
<li class="calibre14"><kbd class="calibre16"><kbd class="calibre79">public CompletableFuture&lt;Void&gt; runAfterBoth(CompletionStage&lt;?&gt; other, Runnable action)</kbd></kbd></li>
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;Void&gt; runAfterBothAsync(CompletionStage&lt;?&gt; other, Runnable action)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;Void&gt; runAfterBothAsync(CompletionStage&lt;?&gt; other, Runnable action, Executor executor)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;Void&gt; runAfterEither(CompletionStage&lt;?&gt; other, Runnable action)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;Void&gt; runAfterEitherAsync(CompletionStage&lt;?&gt; other, Runnable action)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;Void&gt; runAfterEitherAsync(CompletionStage&lt;?&gt; other, Runnable action, Executor executor)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;T&gt; whenComplete(BiConsumer&lt;? super T, ? super Throwable&gt; action)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T, ? super Throwable&gt; action)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T, ? super Throwable&gt; action, Executor executor)</kbd></li>
</ul>
<p class="mce-root">These methods return a <kbd class="calibre16">CompletionStage</kbd>:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;Void&gt; thenAccept(Consumer&lt;? super T&gt; action)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action, Executor executor)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBoth(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T, ? super U&gt; action)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T, ? super U&gt; action)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T, ? super U&gt; action, Executor executor)</kbd></li>
<li class="calibre14"><kbd class="calibre16"><kbd class="calibre79">public &lt;U&gt; CompletableFuture&lt;U&gt; thenApply(Function&lt;? super T, ? extends U&gt; fn)</kbd></kbd></li>
<li class="calibre14"><kbd class="calibre16">public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T, ? extends U&gt; fn)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T, ? extends U&gt; fn, Executor executor)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public &lt;U, V&gt; CompletableFuture&lt;V&gt; thenCombine(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T, ? super U, ? extends V&gt; fn)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public &lt;U, V&gt; CompletableFuture&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T, ? super U, ? extends V&gt; fn)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public &lt;U, V&gt; CompletableFuture&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T, ? super U, ? extends V&gt; fn, Executor executor)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public &lt;U&gt; CompletableFuture&lt;U&gt; thenCompose(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public &lt;U&gt; CompletableFuture&lt;U&gt; thenComposeAsync(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public &lt;U&gt; CompletableFuture&lt;U&gt; thenComposeAsync(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;Void&gt; thenRun(Runnable action)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;Void&gt;thenRunAsync(Runnable action)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;Void&gt;thenRunAsync(Runnable action, Executor executor)</kbd></li>
</ul>
<p class="mce-root">These methods return a <kbd class="calibre16">CompleteableFuture</kbd>:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;...cfs)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static CompletableFuture&lt;Object&gt; anyOf(CompletableFuture&lt;?&gt;... cfs)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;T&gt; completeAsync(Supplier&lt;? extends T&gt; supplier, Executor executor)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;T&gt; completeAsync(Supplier&lt;? extends T&gt; supplier)</kbd></li>
<li class="calibre14"><kbd class="calibre16"><kbd class="calibre79">public static &lt;U&gt; CompletableFuture&lt;U&gt; completedFuture(U value)</kbd></kbd></li>
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;T&gt; completeOnTimeout(T value, long timeout, TimeUnit unit)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;T&gt; copy()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;T&gt; exceptionally(Function&lt;Throwable, ? extends T&gt; fn)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static &lt;U&gt; CompletableFuture&lt;U&gt; failedFuture(Throwable ex)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public &lt;U&gt; CompletableFuture&lt;U&gt; newIncompeteFuture()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;T&gt; orTimeout(long timeout, TimeUnit unit)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static ComletableFuture&lt;Void&gt; runAsync(Runnable runnable)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U. supplier, Executor executor)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public CompletableFuture&lt;T&gt; toCompletableFuture()</kbd></li>
</ul>
<p class="mce-root">These methods return a <kbd class="calibre16">Executor</kbd>:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public Executor defaultExecutor()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static Executor delayedExecutor(long delay, Timeunit unit, Executor executor)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public static Executor delayedExecutor(long delay, Timeunit unit)</kbd></li>
</ul>
<p class="mce-root"><span class="calibre7">These methods return a</span> <kbd class="calibre16">boolean</kbd>:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public boolean cancel(boolean mayInterruptIfRunning)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public boolean complete(T value)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public boolean completeExceptionally(Throwable ex)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public boolean isCancelled()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public boolean isCompletedExceptionally()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public boolean isDone()</kbd></li>
</ul>
<p class="mce-root">No return type:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public void obtrudeException(Throwable ex)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public void obtrudeValue(T value)</kbd></li>
</ul>
<p class="mce-root">Additional methods:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException</kbd></li>
<li class="calibre14"><kbd class="calibre16">public T get() throws InterruptedException, ExecutionException</kbd></li>
<li class="calibre14"><kbd class="calibre16">public T getNow(T valueIfAbsent)</kbd></li>
<li class="calibre14"><kbd class="calibre16">public int getNumberOfDependents()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public T join()</kbd></li>
<li class="calibre14"><kbd class="calibre16">public String toString()</kbd></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Enhancements</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">The</span> <kbd class="calibre16">CompleteableFuture&lt;T&gt;</kbd> <span class="calibre7">class received the following enhancements as part of the Java 9 platform:</span></p>
<ul class="calibre13">
<li class="calibre14">Added time-based enhancements:
<ul class="calibre13">
<li class="calibre14">This enables completions based on lapsed time</li>
<li class="calibre14">Delayed executions are now also supported</li>
</ul>
</li>
<li class="calibre14">Significant enhancement to subclasses:
<ul class="calibre13">
<li class="calibre14">Extending <kbd class="calibre16">CompletableFuture</kbd> is easier</li>
<li class="calibre14">Subclasses support alternative default executors</li>
</ul>
</li>
</ul>
<p class="mce-root">Specifically, the following methods were added in Java 9:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">newIncompleteFuture()</kbd></li>
<li class="calibre14"><kbd class="calibre16">defaultExecutor()</kbd></li>
<li class="calibre14"><kbd class="calibre16">copy()</kbd></li>
<li class="calibre14"><kbd class="calibre16">minimalCompletionStage()</kbd></li>
<li class="calibre14"><kbd class="calibre16">completeAsync()</kbd></li>
<li class="calibre14"><kbd class="calibre16">orTimeout()</kbd></li>
<li class="calibre14"><kbd class="calibre16"><kbd class="calibre79">completeOnTimeout()</kbd></kbd></li>
<li class="calibre14"><kbd class="calibre16">delayedExecutor()</kbd></li>
<li class="calibre14"><kbd class="calibre16">completedStage()</kbd></li>
<li class="calibre14"><kbd class="calibre16">failedFuture()</kbd></li>
<li class="calibre14"><kbd class="calibre16">failedStage()</kbd></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Spin-Wait Hints</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">With concurrency, we need to ensure that threads waiting to be executed actually get executed. The concept of spin-wait is a process that continually checks for a true condition. The aim of Java Enhancement Proposal 285 was to create an API that permits Java code to issue hints that a spin loop is currently being executed.</p>
<p class="mce-root">While this is not a feature that every Java developer will use, it can be useful for low-level programming. The hint system simply issues hints--indications, and performs no other actions. Justifications for adding these hints include the following assumptions:</p>
<ul class="calibre13">
<li class="calibre14">A spin loop's action time can be improved when using a spin hint</li>
<li class="calibre14">Use of spin hints will reduce thread-to-thread latency</li>
<li class="calibre14">CPU power consumption will be reduced</li>
<li class="calibre14">Hardware threads will execute faster</li>
</ul>
<p class="mce-root">This hint functionality will be contained in a new <kbd class="calibre16">onSpinWait()</kbd> method as part of the <kbd class="calibre16">java.lang.Thread</kbd> class. Here is an example of implementing the <kbd class="calibre16">onSpinWait()</kbd> method:</p>
<pre class="calibre21">    . . . <br class="calibre2"/><br class="calibre2"/>    volatile boolean notInReceiptOfEventNotification; <br class="calibre2"/><br class="calibre2"/>    . . . <br class="calibre2"/><br class="calibre2"/>    while ( notInReceiptOfEventNotification );<br class="calibre2"/>    {<br class="calibre2"/>      java.lang.Thread.onSpinWait();<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    // Add functionality here to read and process the event<br class="calibre2"/><br class="calibre2"/>    . . . </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we <span class="calibre7">covered concurrency enhancements introduced with the Java 9 platform. We took a deep look at concurrency both as a core Java concept and with an eye to what Java 9 is delivering. We also explored the <kbd class="calibre16">Flow</kbd> class API that</span> <span class="calibre7">supports reactive programming, a new concept in Java 9. In addition, we explored concurrency enhancements and the new spin-wait hints introduced in Java 9.</span></p>
<p class="mce-root">In the next chapter, we will highlight the security enhancements introduced in Java 9 along with practical examples.</p>


            </article>

            
        </section>
    </div>



  </body></html>