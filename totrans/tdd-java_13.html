<html><head></head><body>
<div class="IMG---Figure" id="_idContainer110">
<h1 class="chapter-number" id="_idParaDest-266"><a id="_idTextAnchor275"/><span class="koboSpan" id="kobo.1.1">13</span></h1>
<h1 id="_idParaDest-267"><a id="_idTextAnchor276"/><span class="koboSpan" id="kobo.2.1">Driving the Domain Layer</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We laid a lot of groundwork in previous chapters, covering a mixture of TDD techniques and software design approaches. </span><span class="koboSpan" id="kobo.3.2">Now we can apply those capabilities to build our Wordz game. </span><span class="koboSpan" id="kobo.3.3">We will be building on top of the useful code we have written throughout the book and working toward a well-engineered, well-tested design, written using the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">test-first approach.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Our goal for this chapter is to create the domain layer of our system. </span><span class="koboSpan" id="kobo.5.2">We will adopt the hexagonal architecture approach as described in </span><a href="B18384_09.xhtml#_idTextAnchor179"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Hexagonal Architecture – Decoupling External Systems</span></em><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">The domain model will contain all our core application logic. </span><span class="koboSpan" id="kobo.9.3">This code will not be tied to details of any external system technologies such as SQL databases or web servers. </span><span class="koboSpan" id="kobo.9.4">We will create abstractions for these external systems and use test doubles to enable us to test-drive the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">application logic.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">Using hexagonal architecture in this way allows us to write FIRST unit tests for complete user stories, which is something often requiring integration or end-to-end testing in other design approaches. </span><span class="koboSpan" id="kobo.11.2">We will write our domain model code by applying the ideas presented in the book </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">so far.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.15.1">Starting a </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">new game</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Playing </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">the game</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Ending </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">the game</span></span></li>
</ul>
<h1 id="_idParaDest-268"><a id="_idTextAnchor277"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">The final code for this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">at </span></span><a href="B18384_13.xhtml#_idTextAnchor292"><span class="No-Break"><span class="koboSpan" id="kobo.24.1">https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter13</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.25.1">.</span></span></p>
<h1 id="_idParaDest-269"><a id="_idTextAnchor278"/><span class="koboSpan" id="kobo.26.1">Starting a new game</span></h1>
<p><span class="koboSpan" id="kobo.27.1">In this section, we will make a start</span><a id="_idIndexMarker702"/><span class="koboSpan" id="kobo.28.1"> by coding our game. </span><span class="koboSpan" id="kobo.28.2">Like every project, starting is usually quite difficult, with the first decision being simply where to begin. </span><span class="koboSpan" id="kobo.28.3">A reasonable approach is to find a user story that will begin to flesh out the structure of the code. </span><span class="koboSpan" id="kobo.28.4">Once we have a reasonable structure for an application, it becomes much easier to figure out where new code should </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">be added.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">Given this, we can make a good start by considering what needs to happen when we start a new game. </span><span class="koboSpan" id="kobo.30.2">This must set things up ready to play and so will force some critical decisions to </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">be made.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">The first user story to work on is starting a </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">new game:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.34.1">As a player I want to start a new game so that I have a new word </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">to guess</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.36.1">When we start a new game, we must do </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.38.1">Select a word at random from the available words </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">to guess</span></span></li>
<li><span class="koboSpan" id="kobo.40.1">Store the selected word so that scores for guesses can </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">be calculated</span></span></li>
<li><span class="koboSpan" id="kobo.42.1">Record that the player may now make an </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">initial guess</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.44.1">We will assume the use of hexagonal architecture as we code this story, meaning that any external system will be represented by a port in the domain model. </span><span class="koboSpan" id="kobo.44.2">With this in mind, we can create our first test and take it </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">from there.</span></span></p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor279"/><span class="koboSpan" id="kobo.46.1">Test-driving starting a new game</span></h2>
<p><span class="koboSpan" id="kobo.47.1">In terms of a general direction, using hexagonal</span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.48.1"> architecture means we are free to use an outside-in approach with TDD. </span><span class="koboSpan" id="kobo.48.2">Whatever design we come up with for our domain model, none of it is going to involve</span><a id="_idIndexMarker704"/><span class="koboSpan" id="kobo.49.1"> difficult-to-test external systems. </span><span class="koboSpan" id="kobo.49.2">Our unit tests are assured to be </span><strong class="bold"><span class="koboSpan" id="kobo.50.1">FIRST</span></strong><span class="koboSpan" id="kobo.51.1"> – </span><strong class="bold"><span class="koboSpan" id="kobo.52.1">fast, isolated, repeatable, self-checking, </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.53.1">and timely</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">Importantly, we can write unit tests that cover the entire logic needed for a user story.  </span><span class="koboSpan" id="kobo.55.2">If we wrote code that is bound to external systems – for example, it contained SQL statements and connected to a database – we would need an integration test to cover a user story. </span><span class="koboSpan" id="kobo.55.3">Our choice of hexagonal architecture frees us </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">from that.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">On a tactical note, we will reuse classes that we have already test-driven, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">class WordSelection</span></strong><span class="koboSpan" id="kobo.59.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">class Word</span></strong><span class="koboSpan" id="kobo.61.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">class Score</span></strong><span class="koboSpan" id="kobo.63.1">. </span><span class="koboSpan" id="kobo.63.2">We will reuse existing code and third-party libraries whenever an opportunity </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">presents itself.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">Our starting point is to write a test</span><a id="_idIndexMarker705"/><span class="koboSpan" id="kobo.66.1"> to capture our design decisions related to starting a </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">new game:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.68.1">We will start with a test called </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">NewGameTest</span></strong><span class="koboSpan" id="kobo.70.1">. </span><span class="koboSpan" id="kobo.70.2">This test will act across the domain model to drive out our handling of everything we need to do to start a </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">new game:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.72.1">
package com.wordz.domain;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.73.1">
public class NewGameTest {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.74.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.75.1">For this test, we will start with the Act step first. </span><span class="koboSpan" id="kobo.75.2">We are assuming hexagonal architecture, so the design goal of the Act step is to design the port that handles the request to start a new game. </span><span class="koboSpan" id="kobo.75.3">In hexagonal architecture, a port is the piece of code that allows some external system to connect with the domain model. </span><span class="koboSpan" id="kobo.75.4">We begin by creating a class for </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">our port:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.77.1">
package com.wordz.domain;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.78.1">
public class NewGameTest {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.79.1">
    void </span><strong class="bold"><span class="koboSpan" id="kobo.80.1">startsNewGame</span></strong><span class="koboSpan" id="kobo.81.1">() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.82.1">
        var game = new Game();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.83.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.84.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.85.1">The key design decision here is to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">controller</span></strong><span class="koboSpan" id="kobo.87.1"> class to handle the request to start a game. </span><span class="koboSpan" id="kobo.87.2">It is a controller in the sense of the original Gang of Four’s </span><em class="italic"><span class="koboSpan" id="kobo.88.1">Design Patterns</span></em><span class="koboSpan" id="kobo.89.1"> book – a domain model object that will orchestrate other domain model objects. </span><span class="koboSpan" id="kobo.89.2">We will let the IntelliJ IDE create the empty </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">Game</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.91.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.92.1">
package com.wordz.domain;
public class </span><strong class="bold"><span class="koboSpan" id="kobo.93.1">Game</span></strong><span class="koboSpan" id="kobo.94.1"> {
}</span></pre>
<p><span class="koboSpan" id="kobo.95.1">That’s another advantage</span><a id="_idIndexMarker706"/><span class="koboSpan" id="kobo.96.1"> of TDD. </span><span class="koboSpan" id="kobo.96.2">When we write the test first, we give our IDE enough information to be able to generate boilerplate code for us. </span><span class="koboSpan" id="kobo.96.3">We enable the IDE autocomplete feature to really help us. </span><span class="koboSpan" id="kobo.96.4">If your IDE cannot autogenerate code after having written the test, consider upgrading </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">your IDE.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.98.1">The next step is to add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">start()</span></strong><span class="koboSpan" id="kobo.100.1"> method on the controller class to start a new game. </span><span class="koboSpan" id="kobo.100.2">We need to know which player we are starting a game for, so we pass in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">Player</span></strong><span class="koboSpan" id="kobo.102.1"> object. </span><span class="koboSpan" id="kobo.102.2">We write the Act step of </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">our test:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.104.1">
public class NewGameTest {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.105.1">
    @Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.106.1">
    void startsNewGame() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.107.1">
        var game = new Game();</span></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.108.1">        var player = new Player();</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.109.1">        game.start(player);</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.110.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.111.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.112.1">We allow the IDE to generate the method in </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">the controller:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.114.1">
public class Game {
    </span><strong class="bold"><span class="koboSpan" id="kobo.115.1">public void start(Player player) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.116.1">    }</span></strong><span class="koboSpan" id="kobo.117.1">
}</span></pre>
<h2 id="_idParaDest-271"><a id="_idTextAnchor280"/><span class="koboSpan" id="kobo.118.1">Tracking the progress of the game</span></h2>
<p><span class="koboSpan" id="kobo.119.1">The next design decisions concern</span><a id="_idIndexMarker707"/><span class="koboSpan" id="kobo.120.1"> the expected outcome of starting a new game for a player. </span><span class="koboSpan" id="kobo.120.2">There are two things that need to </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">be recorded:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.122.1">The selected word that the player attempts </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">to guess</span></span></li>
<li><span class="koboSpan" id="kobo.124.1">That we expect their first </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">guess next</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.126.1">The selected word and current attempt number will need to persist somewhere. </span><span class="koboSpan" id="kobo.126.2">We will use the repository pattern to abstract that. </span><span class="koboSpan" id="kobo.126.3">Our repository will need to manage some domain objects. </span><span class="koboSpan" id="kobo.126.4">Those objects will have the single responsibility of tracking our progress in </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">a game.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">Already, we see a benefit of TDD in terms of rapid design feedback. </span><span class="koboSpan" id="kobo.128.2">We haven’t written too much code yet, but already, it seems like the new class needed to track game progress would best be called </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">class Game</span></strong><span class="koboSpan" id="kobo.130.1">. </span><span class="koboSpan" id="kobo.130.2">However, we already have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">class Game</span></strong><span class="koboSpan" id="kobo.132.1">, responsible for starting a new game. </span><span class="koboSpan" id="kobo.132.2">TDD is providing feedback on our design – that our names and responsibilities </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">are mismatched.</span></span></p>
<p><span class="koboSpan" id="kobo.134.1">We must choose one of the following options </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">to proceed:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.136.1">Keep our existing </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">class Game</span></strong><span class="koboSpan" id="kobo.138.1"> as it is. </span><span class="koboSpan" id="kobo.138.2">Call this new class something such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">Progress</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.140.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">Attempt</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.143.1">Change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">start()</span></strong><span class="koboSpan" id="kobo.145.1"> method to a static method – a method that applies to all instances of </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">a class.</span></span></li>
<li><span class="koboSpan" id="kobo.147.1">Rename </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">class Game</span></strong><span class="koboSpan" id="kobo.149.1"> to something that better describes its responsibility. </span><span class="koboSpan" id="kobo.149.2">Then, we can create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">class Game</span></strong><span class="koboSpan" id="kobo.151.1"> to hold current </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">player progress.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.153.1">The static method option is unappealing. </span><span class="koboSpan" id="kobo.153.2">When using object-oriented programming in Java, static methods rarely seem as good a fit as simply creating another object that manages all the relevant instances. </span><span class="koboSpan" id="kobo.153.3">The static method becomes a normal method on this new object. </span><span class="koboSpan" id="kobo.153.4">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">class Game</span></strong><span class="koboSpan" id="kobo.155.1"> to represent progress through a game seems to result in more descriptive code. </span><span class="koboSpan" id="kobo.155.2">Let’s go with </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">that approach.</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.157.1">Use the IntelliJ IDEA IDE</span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.158.1"> to refactor/rename </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">class Game</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.160.1">class Wordz</span></strong><span class="koboSpan" id="kobo.161.1">, which represents the entry point into our domain model. </span><span class="koboSpan" id="kobo.161.2">We also rename the local variable </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">game</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.163.1">to match:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.164.1">
public class NewGameTest {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.165.1">
    @Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.166.1">
    void startsNewGame() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.167.1">
        var wordz = new Wordz();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.168.1">
        var player = new Player();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.169.1">
        wordz.start(player);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.170.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.171.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.172.1">The name of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">NewGameTest</span></strong><span class="koboSpan" id="kobo.174.1"> test is still good. </span><span class="koboSpan" id="kobo.174.2">It represents the user story we are testing and is not related to any class names. </span><span class="koboSpan" id="kobo.174.3">The production code has been refactored by the IDE </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">as well:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.176.1">
public class Wordz {
    public void start(Player player) {
    }
}</span></pre>
<ol>
<li value="2"><span class="koboSpan" id="kobo.177.1">Use the IDE to refactor/rename the </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">start()</span></strong><span class="koboSpan" id="kobo.179.1"> method </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">newGame()</span></strong><span class="koboSpan" id="kobo.181.1">. </span><span class="koboSpan" id="kobo.181.2">This seems to better describe the responsibility of the method, in the context of a class </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">Wordz</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.185.1">
public class NewGameTest {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.186.1">
    @Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.187.1">
    void startsNewGame() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.188.1">
        var wordz = new Wordz();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.189.1">
        var player = new Player();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.190.1">
        wordz.</span><strong class="bold"><span class="koboSpan" id="kobo.191.1">newGame</span></strong><span class="koboSpan" id="kobo.192.1">(player);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.193.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.194.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.195.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">class Wordz</span></strong><span class="koboSpan" id="kobo.197.1"> production code also has the </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">method renamed.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.199.1">When we start a new game, we need</span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.200.1"> to select a word to guess and start the sequence of attempts the player has. </span><span class="koboSpan" id="kobo.200.2">These facts need to be stored in a repository. </span><span class="koboSpan" id="kobo.200.3">Let’s create the repository first. </span><span class="koboSpan" id="kobo.200.4">We will call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">interface GameRepository</span></strong><span class="koboSpan" id="kobo.202.1"> and add Mockito </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">@Mock</span></strong><span class="koboSpan" id="kobo.204.1"> support for it in </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">our test:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.206.1">
package com.wordz.domain;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.207.1">
import org.junit.jupiter.api.Test;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.208.1">
import org.junit.jupiter.api.extension.ExtendWith;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.209.1">
import org.mockito.Mock;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.210.1">
import org.mockito.junit.jupiter.MockitoExtension;</span></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.211.1">@ExtendWith(MockitoExtension.class)</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.212.1">
public class NewGameTest {</span></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.213.1">    @Mock</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.214.1">    private GameRepository gameRepository;</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.215.1">    @InjectMocks</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.216.1">    private Wordz wordz;</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.217.1">
    @Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.218.1">
    void startsNewGame() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.219.1">
        var player = new Player();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.220.1">
        wordz.newGame(player);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.221.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.222.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.223.1">We add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">@ExtendWith</span></strong><span class="koboSpan" id="kobo.225.1"> annotation to the class to enable the Mockito library to automatically create test doubles for us. </span><span class="koboSpan" id="kobo.225.2">We add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">gameRepository</span></strong><span class="koboSpan" id="kobo.227.1"> field, which we annotated as a Mockito </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">@Mock</span></strong><span class="koboSpan" id="kobo.229.1">. </span><span class="koboSpan" id="kobo.229.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">@InjectMocks</span></strong><span class="koboSpan" id="kobo.231.1"> convenience annotation built into Mockito to automatically inject this dependency into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">Wordz</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.233.1"> constructor.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.234.1">We allow the IDE</span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.235.1"> to create an empty interface </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">for us:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.237.1">
package com.wordz.domain;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.238.1">
public interface GameRepository {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.239.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.240.1">For the next step, we will confirm that </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">gameRepository</span></strong><span class="koboSpan" id="kobo.242.1"> gets used. </span><span class="koboSpan" id="kobo.242.2">We decide to add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">create()</span></strong><span class="koboSpan" id="kobo.244.1"> method on the interface, which takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">class Game</span></strong><span class="koboSpan" id="kobo.246.1"> object instance as its only parameter. </span><span class="koboSpan" id="kobo.246.2">We want to inspect that object instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">class Game</span></strong><span class="koboSpan" id="kobo.248.1">, so we add an argument captor. </span><span class="koboSpan" id="kobo.248.2">This allows us to assert on the game data contained in </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">that object:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.250.1">
public class NewGameTest {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.251.1">
    @Mock</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.252.1">
    private GameRepository gameRepository;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.253.1">
    @Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.254.1">
    void startsNewGame() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.255.1">
        var player = new Player();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.256.1">
        wordz.newGame(player);</span></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.257.1">        var gameArgument =</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.258.1">               ArgumentCaptor.forClass(Game.class)</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.259.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.260.1">verify(gameRepository)</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.261.1">           .create(gameArgument.capture());</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.262.1">        var game = gameArgument.getValue();</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.263.1">        assertThat(game.getWord()).isEqualTo("ARISE");</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.264.1">        assertThat(game.getAttemptNumber()).isZero();</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.265.1">        assertThat(game.getPlayer()).isSameAs(player);</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.266.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.267.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.268.1">A good question is why </span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.269.1">we are asserting against those particular values. </span><span class="koboSpan" id="kobo.269.2">The reason is that we are going to cheat when we add the production code and </span><em class="italic"><span class="koboSpan" id="kobo.270.1">fake it until we make it</span></em><span class="koboSpan" id="kobo.271.1">. </span><span class="koboSpan" id="kobo.271.2">We will return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">Game</span></strong><span class="koboSpan" id="kobo.273.1"> object that hardcodes these values as a first step. </span><span class="koboSpan" id="kobo.273.2">We can then work in small steps. </span><span class="koboSpan" id="kobo.273.3">Once the cheat version makes the test pass, we can refine the test and test-drive the code to fetch the word for real. </span><span class="koboSpan" id="kobo.273.4">Smaller steps provide more rapid feedback. </span><span class="koboSpan" id="kobo.273.5">Rapid feedback</span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.274.1"> enables </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">better decision-making.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.276.1">Note on using getters in the domain model</span></p>
<p class="callout"><span class="koboSpan" id="kobo.277.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">Game</span></strong><span class="koboSpan" id="kobo.279.1"> class has </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">getXxx()</span></strong><span class="koboSpan" id="kobo.281.1"> methods, known as </span><em class="italic"><span class="koboSpan" id="kobo.282.1">getters</span></em><span class="koboSpan" id="kobo.283.1"> in Java terminology, for every one</span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.284.1"> of its private</span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.285.1"> fields. </span><span class="koboSpan" id="kobo.285.2">These methods break the encapsulation </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">of data.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.287.1">This is generally not recommended. </span><span class="koboSpan" id="kobo.287.2">It can lead to important logic being placed into other classes – a code</span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.288.1"> smell known as a foreign method. </span><span class="koboSpan" id="kobo.288.2">Object-oriented programming is all about co-locating logic and data, encapsulating both. </span><span class="koboSpan" id="kobo.288.3">Getters should be few and far between. </span><span class="koboSpan" id="kobo.288.4">That does not mean we should never use </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">them, however.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.290.1">In this case, the single responsibility of </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">class Game</span></strong><span class="koboSpan" id="kobo.292.1"> is to transfer the current state of the game being played to </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">GameRepository</span></strong><span class="koboSpan" id="kobo.294.1">. </span><span class="koboSpan" id="kobo.294.2">The most direct way of implementing this is to add getters to the class. </span><span class="koboSpan" id="kobo.294.3">Writing simple, clear code beats following </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">rules dogmatically.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.296.1">Another reasonable approach is to add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">getXxx()</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.298.1">diagnostic method</span></strong><span class="koboSpan" id="kobo.299.1"> at package-level visibility purely </span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.300.1">for testing. </span><span class="koboSpan" id="kobo.300.2">Check with the team that this is not part of the public API and do not use it in production code. </span><span class="koboSpan" id="kobo.300.3">It is more important to get the code correct than obsess over </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">design trivia.</span></span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.302.1">We create empty methods for these new getters using the IDE. </span><span class="koboSpan" id="kobo.302.2">The next step is to run </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">NewGameTest</span></strong><span class="koboSpan" id="kobo.304.1"> and confirm that </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">it fails:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer104">
<span class="koboSpan" id="kobo.306.1"><img alt="Figure 13.1 – Our failing test" src="image/Figure_13.1_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.307.1">Figure 13.1 – Our failing test</span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.308.1">This is enough for us to write some more </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">production</span></span><span class="No-Break"><a id="_idIndexMarker717"/></span><span class="No-Break"><span class="koboSpan" id="kobo.310.1"> code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.311.1">
package com.wordz.domain;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.312.1">
public class Wordz {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.313.1">
    private final GameRepository gameRepository;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.314.1">
    public Wordz(GameRepository gr) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.315.1">
        this.gameRepository = gr;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.316.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.317.1">
    public void newGame(Player player) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.318.1">
        var game = new Game(player, "ARISE", 0);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.319.1">
        gameRepository.create(game);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.320.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.321.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.322.1">We can rerun </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">NewGameTest</span></strong><span class="koboSpan" id="kobo.324.1"> and watch </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">it pass:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer105">
<span class="koboSpan" id="kobo.326.1"><img alt="Figure 13.2 – The test passes" src="image/Figure_13.2_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.327.1">Figure 13.2 – The test passes</span></p>
<p><span class="koboSpan" id="kobo.328.1">The test now passes. </span><span class="koboSpan" id="kobo.328.2">We</span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.329.1"> can move from our red-green phase to thinking about refactoring. </span><span class="koboSpan" id="kobo.329.2">The thing that jumps out immediately is just how unreadable that </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">ArgumentCaptor</span></strong><span class="koboSpan" id="kobo.331.1"> code is in the test. </span><span class="koboSpan" id="kobo.331.2">It contains too much detail about the mechanics of mocking and not enough detail about why we are using that technique. </span><span class="koboSpan" id="kobo.331.3">We can clarify that by extracting a </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">well-named method.</span></span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.333.1">Extract the </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">getGameInRepository()</span></strong><span class="koboSpan" id="kobo.335.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">for clarity:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.337.1">
@Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.338.1">
void startsNewGame() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.339.1">
    var player = new Player();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.340.1">
    wordz.newGame(player);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.341.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.342.1">Game game = getGameInRepository();</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.343.1">
    assertThat(game.getWord()).isEqualTo("ARISE");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.344.1">
    assertThat(game.getAttemptNumber()).isZero();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.345.1">
    assertThat(game.getPlayer()).isSameAs(player);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.346.1">
}</span></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.347.1">private Game getGameInRepository() {</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.348.1">    var gameArgument</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.349.1">       = ArgumentCaptor.forClass(Game.class)</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.350.1">    verify(gameRepository)</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.351.1">            .create(gameArgument.capture());</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.352.1">    return gameArgument.getValue();</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.353.1">}</span></strong></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.354.1">That has made the test much simpler to read and see the usual Arrange, Act, and Assert pattern in it. </span><span class="koboSpan" id="kobo.354.2">It is a simple test by nature and should read as such. </span><span class="koboSpan" id="kobo.354.3">We can now rerun the test and confirm that it still passes. </span><span class="koboSpan" id="kobo.354.4">It does, and we are satisfied that our refactoring did not </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">break anything.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">That completes</span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.357.1"> our first test – a job well done! </span><span class="koboSpan" id="kobo.357.2">We’re making good progress here. </span><span class="koboSpan" id="kobo.357.3">It always feels good to me to see a test go green, and that feeling never gets old. </span><span class="koboSpan" id="kobo.357.4">This test is essentially an end-to-end test of a user story, acting only on the domain model. </span><span class="koboSpan" id="kobo.357.5">Using hexagonal architecture enables us to write tests that cover the details of our application logic, while avoiding the need for test environments. </span><span class="koboSpan" id="kobo.357.6">We get faster-running, more stable tests as </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">a result.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">There is more work to do in our next test, as we need to remove the hardcoded creation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">Game</span></strong><span class="koboSpan" id="kobo.361.1"> object. </span><span class="koboSpan" id="kobo.361.2">In the next section, we will address this by triangulating the word selection logic. </span><span class="koboSpan" id="kobo.361.3">We design the next test to drive out the correct behavior of selecting a word </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">at random.</span></span></p>
<h2 id="_idParaDest-272"><a id="_idTextAnchor281"/><span class="koboSpan" id="kobo.363.1">Triangulating word selection</span></h2>
<p><span class="koboSpan" id="kobo.364.1">The next task is to remove </span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.365.1">the cheating that we used to make the previous test pass. </span><span class="koboSpan" id="kobo.365.2">We hardcoded some data when we created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">Game</span></strong><span class="koboSpan" id="kobo.367.1"> object. </span><span class="koboSpan" id="kobo.367.2">We need to replace that with the correct code. </span><span class="koboSpan" id="kobo.367.3">This code must select a word at random from our repository of known </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">five-letter words.</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.369.1">Add a new test to drive out the behavior of selecting a </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">random word:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.371.1">
    @Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.372.1">
    void selectsRandomWord() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.373.1">
    }</span></pre></li>
<li><span class="koboSpan" id="kobo.374.1">Random word selection</span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.375.1"> depends on two external systems – the database that holds the words to choose from and a source of random numbers. </span><span class="koboSpan" id="kobo.375.2">As we are using hexagonal architecture, the domain layer cannot access those directly. </span><span class="koboSpan" id="kobo.375.3">We will represent them with two interfaces – the ports</span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.376.1"> to those systems. </span><span class="koboSpan" id="kobo.376.2">For this test, we will use </span><strong class="bold"><span class="koboSpan" id="kobo.377.1">Mockito</span></strong><span class="koboSpan" id="kobo.378.1"> to create stubs for </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">those interfaces:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.380.1">
@ExtendWith(MockitoExtension.class)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.381.1">
public class NewGameTest {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.382.1">
    @Mock</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.383.1">
    private GameRepository gameRepository;</span></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.384.1">    @Mock</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.385.1">    private WordRepository wordRepository ;</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.386.1">    @Mock</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.387.1">    private RandomNumbers randomNumbers ;</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.388.1">
    @InjectMocks</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.389.1">
    private Wordz wordz;</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.390.1">This test introduces two new collaborating objects to </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">class Wordz</span></strong><span class="koboSpan" id="kobo.392.1">. </span><span class="koboSpan" id="kobo.392.2">These are instances of any valid implementations of both </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">interface WordRepository</span></strong><span class="koboSpan" id="kobo.394.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">interface RandomNumbers</span></strong><span class="koboSpan" id="kobo.396.1">. </span><span class="koboSpan" id="kobo.396.2">We need to inject those objects into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">Wordz</span></strong><span class="koboSpan" id="kobo.398.1"> object to make use </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">of them.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.400.1">Using dependency injection, inject the two new interface objects into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">class </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">Wordz</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.403.1"> constructor:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.404.1">
public class Wordz {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.405.1">
    private final GameRepository gameRepository;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.406.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.407.1">private final WordSelection wordSelection ;</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.408.1">
    public Wordz(GameRepository gr,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.409.1">
                 WordRepository wr,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.410.1">
                 RandomNumbers rn) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.411.1">
        this.gameRepository = gr;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.412.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.413.1">this.wordSelection = new WordSelection(wr, rn);</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.414.1">
    }</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.415.1">We’ve added two parameters</span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.416.1"> to the constructor. </span><span class="koboSpan" id="kobo.416.2">We do not need to store them directly as fields. </span><span class="koboSpan" id="kobo.416.3">Instead, we use the previously created </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">class WordSelection</span></strong><span class="koboSpan" id="kobo.418.1">. </span><span class="koboSpan" id="kobo.418.2">We create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">WordSelection</span></strong><span class="koboSpan" id="kobo.420.1"> object and store it in a field called </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">wordSelection</span></strong><span class="koboSpan" id="kobo.422.1">. </span><span class="koboSpan" id="kobo.422.2">Note that our earlier use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">@InjectMocks</span></strong><span class="koboSpan" id="kobo.424.1"> means that our test code will automatically pass in the mock objects to this constructor, without further code changes. </span><span class="koboSpan" id="kobo.424.2">It is </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">very convenient.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.426.1">We set up the mocks. </span><span class="koboSpan" id="kobo.426.2">We want them to simulate the behavior we expect from </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">interface WordRepository</span></strong><span class="koboSpan" id="kobo.428.1"> when we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">fetchWordByNumber()</span></strong><span class="koboSpan" id="kobo.430.1"> method and </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">interface RandomNumbers</span></strong><span class="koboSpan" id="kobo.432.1"> when we </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">call </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">next()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.436.1">
    @Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.437.1">
    void selectsRandomWord() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.438.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.439.1">when(randomNumbers.next(anyInt())).thenReturn(2);</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.440.1">        when(wordRepository.fetchWordByNumber(2))</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.441.1">               .thenReturn("ABCDE");</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.442.1">
    }</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.443.1">This will set up our mocks</span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.444.1"> so that when </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">next()</span></strong><span class="koboSpan" id="kobo.446.1"> is called, it will return the word number </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">2</span></strong><span class="koboSpan" id="kobo.448.1"> every time, as a test double for the random number that will be produced in the full application. </span><span class="koboSpan" id="kobo.448.2">When </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">fetchWordByNumber()</span></strong><span class="koboSpan" id="kobo.450.1"> is then called with </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">2</span></strong><span class="koboSpan" id="kobo.452.1"> as an argument, it will return the word with word number </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">2</span></strong><span class="koboSpan" id="kobo.454.1">, which will be </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">"ABCDE"</span></strong><span class="koboSpan" id="kobo.456.1"> in our test. </span><span class="koboSpan" id="kobo.456.2">Looking at that code, we can add clarity by using a local variable instead of that magic number </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">2</span></strong><span class="koboSpan" id="kobo.458.1">. </span><span class="koboSpan" id="kobo.458.2">To future readers of the code, the link between random number generator output and word repository will be </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">more obvious:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.460.1">
    @Test
    void selectsRandomWord() {
        </span><strong class="bold"><span class="koboSpan" id="kobo.461.1">int wordNumber = 2;</span></strong><span class="koboSpan" id="kobo.462.1">
        when(randomNumbers.next(anyInt()))
           .thenReturn(</span><strong class="bold"><span class="koboSpan" id="kobo.463.1">wordNumber</span></strong><span class="koboSpan" id="kobo.464.1">);
        when(wordRepository
           .fetchWordByNumber(</span><strong class="bold"><span class="koboSpan" id="kobo.465.1">wordNumber</span></strong><span class="koboSpan" id="kobo.466.1">))
               .thenReturn("ABCDE");
    }</span></pre>
<ol>
<li value="5"><span class="koboSpan" id="kobo.467.1">That still looks too detailed once again. </span><span class="koboSpan" id="kobo.467.2">There is too much emphasis on mocking mechanics and too little on what the mocking represents. </span><span class="koboSpan" id="kobo.467.3">Let’s extract a method to explain why we are setting up this stub. </span><span class="koboSpan" id="kobo.467.4">We will also pass in the word we want to be selected. </span><span class="koboSpan" id="kobo.467.5">That will help us more easily understand the purpose of the </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">test code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.469.1">
    @Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.470.1">
    void selectsRandomWord() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.471.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.472.1">givenWordToSelect("ABCDE");</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.473.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.474.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.475.1">private void givenWordToSelect(String wordToSelect){</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.476.1">        int wordNumber = 2;</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.477.1">        when(randomNumbers.next(anyInt()))</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.478.1">                .thenReturn(wordNumber);</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.479.1">        when(wordRepository</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.480.1">                .fetchWordByNumber(wordNumber))</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.481.1">                .thenReturn(wordToSelect);</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.482.1">    }</span></strong></pre></li>
<li><span class="koboSpan" id="kobo.483.1">Now, we can write</span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.484.1"> the assertion to confirm that this word is passed down to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">gameRepository</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.486.1">create()</span></strong><span class="koboSpan" id="kobo.487.1"> method – we can reuse our </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">getGameInRepository()</span></strong><span class="koboSpan" id="kobo.489.1"> assert </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">helper method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.491.1">
@Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.492.1">
void selectsRandomWord() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.493.1">
    givenWordToSelect("ABCDE");</span></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.494.1">    var player = new Player();</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.495.1">    wordz.newGame(player);</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.496.1">    Game game = getGameInRepository();</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.497.1">    assertThat(game.getWord()).isEqualTo("ABCDE");</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.498.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.499.1">This follows the same approach as the previous </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">test, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">startsNewGame</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">.</span></span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.503.1">Watch the test fail. </span><span class="koboSpan" id="kobo.503.2">Write production</span><a id="_idIndexMarker726"/><span class="koboSpan" id="kobo.504.1"> code to make the </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">test pass:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.506.1">
public void newGame(Player player) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.507.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.508.1">var word = wordSelection.chooseRandomWord();</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.509.1">
    Game game = new Game(player, </span><strong class="bold"><span class="koboSpan" id="kobo.510.1">word</span></strong><span class="koboSpan" id="kobo.511.1">, 0);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.512.1">
    gameRepository.create(game);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.513.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.514.1">Watch the new test pass and then run </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">all tests:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer106">
<span class="koboSpan" id="kobo.516.1"><img alt="Figure 13.3 – Original test failing" src="image/Figure_13.3_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.517.1">Figure 13.3 – Original test failing</span></p>
<p><span class="koboSpan" id="kobo.518.1">Our initial test has now failed. </span><span class="koboSpan" id="kobo.518.2">We’ve broken something during our latest code change. </span><span class="koboSpan" id="kobo.518.3">TDD has kept us safe by providing a regression test for us. </span><span class="koboSpan" id="kobo.518.4">What has happened is that after removing the hardcoded word </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">"ARISE"</span></strong><span class="koboSpan" id="kobo.520.1"> that the original test relied on, it fails. </span><span class="koboSpan" id="kobo.520.2">The correct solution is to add the required mock setup to our original test. </span><span class="koboSpan" id="kobo.520.3">We can reuse our </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">givenWordToSelect()</span></strong><span class="koboSpan" id="kobo.522.1"> helper method to </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">do this.</span></span></p>
<ol>
<li value="9"><span class="koboSpan" id="kobo.524.1">Add the mock</span><a id="_idIndexMarker727"/><span class="koboSpan" id="kobo.525.1"> setup to the </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">original test:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.527.1">
@Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.528.1">
void startsNewGame() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.529.1">
    var player = new Player();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.530.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.531.1">givenWordToSelect("ARISE");</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.532.1">
    wordz.newGame(player);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.533.1">
    Game game = getGameInRepository();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.534.1">
    assertThat(game.getWord()).isEqualTo("ARISE");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.535.1">
    assertThat(game.getAttemptNumber()).isZero();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.536.1">
    assertThat(game.getPlayer()).isSameAs(player);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.537.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.538.1">Rerun all tests and confirm that they </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">all pass:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer107">
<span class="koboSpan" id="kobo.540.1"><img alt="Figure 13.4 – All tests passing" src="image/Figure_13.4_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.541.1">Figure 13.4 – All tests passing</span></p>
<p><span class="koboSpan" id="kobo.542.1">We’ve test-driven our first piece</span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.543.1"> of code to start a new game, with a randomly selected word to guess, and made the tests pass. </span><span class="koboSpan" id="kobo.543.2">Before we move on, it is time to consider what – if anything – we should refactor. </span><span class="koboSpan" id="kobo.543.3">We have been tidying the code as we write it, but there is one glaring feature. </span><span class="koboSpan" id="kobo.543.4">Take a look at the two tests. </span><span class="koboSpan" id="kobo.543.5">They seem very similar now. </span><span class="koboSpan" id="kobo.543.6">The original test has become a superset of the one we used to test-drive</span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.544.1"> adding the word selection. </span><span class="koboSpan" id="kobo.544.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">selectsRandomWord()</span></strong><span class="koboSpan" id="kobo.546.1"> test is a </span><strong class="bold"><span class="koboSpan" id="kobo.547.1">scaffolding test</span></strong><span class="koboSpan" id="kobo.548.1"> that no longer serves a purpose. </span><span class="koboSpan" id="kobo.548.2">There’s only one thing to do with code like that – remove it. </span><span class="koboSpan" id="kobo.548.3">As a minor readability improvement, we can also extract a constant for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">Player</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.550.1"> variable:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.551.1">Extract a constant for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">Player</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.553.1"> variable:</span></span></li>
</ol>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.554.1">private static final Player PLAYER = new Player();</span></strong><span class="koboSpan" id="kobo.555.1">
@Test
void startsNewGame() {
    givenWordToSelect("ARISE");
    wordz.newGame(</span><strong class="bold"><span class="koboSpan" id="kobo.556.1">PLAYER</span></strong><span class="koboSpan" id="kobo.557.1">);
    Game game = getGameInRepository();
    assertThat(game.getWord()).isEqualTo("ARISE");
    assertThat(game.getAttemptNumber()).isZero();
    assertThat(game.getPlayer()).isSameAs(PLAYER);
}</span></pre>
<ol>
<li value="2"><span class="koboSpan" id="kobo.558.1">We’ll run all the tests after this to make sure that they all still pass and that </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">selectsRandomWord()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.560.1">has gone.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer108">
<span class="koboSpan" id="kobo.561.1"><img alt="Figure 13.5 – All tests passing" src="image/Figure_13.5_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.562.1">Figure 13.5 – All tests passing</span></p>
<p><span class="koboSpan" id="kobo.563.1">That’s it! </span><span class="koboSpan" id="kobo.563.2">We have test-driven out all the behavior we need to start a game. </span><span class="koboSpan" id="kobo.563.3">It’s a significant achievement because that test covers a complete user story. </span><span class="koboSpan" id="kobo.563.4">All the domain logic has been tested and is known to be working. </span><span class="koboSpan" id="kobo.563.5">The design looks straightforward. </span><span class="koboSpan" id="kobo.563.6">The test code is a clear specification of what we expect our code to do. </span><span class="koboSpan" id="kobo.563.7">This is </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">great progress.</span></span></p>
<p><span class="koboSpan" id="kobo.565.1">Following this refactoring, we can move on to the next development task – code that supports playing </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">the game.</span></span></p>
<h1 id="_idParaDest-273"><a id="_idTextAnchor282"/><span class="koboSpan" id="kobo.567.1">Playing the game</span></h1>
<p><span class="koboSpan" id="kobo.568.1">In this section, we will build the logic to play the game. </span><span class="koboSpan" id="kobo.568.2">The gameplay consists of making a number of guesses at the selected word, reviewing the score for that guess, and having another guess. </span><span class="koboSpan" id="kobo.568.3">The game ends either when the word has been guessed correctly or when the maximum number of allowed attempts has </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">been made.</span></span></p>
<p><span class="koboSpan" id="kobo.570.1">We’ll begin by assuming</span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.571.1"> that we are at the start of a typical game, about to make our first guess. </span><span class="koboSpan" id="kobo.571.2">We will also assume that this guess is not completely correct. </span><span class="koboSpan" id="kobo.571.3">This allows us to defer decisions about end-of-the-game behavior, which is a good thing, as we have enough to </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">decide already.</span></span></p>
<h2 id="_idParaDest-274"><a id="_idTextAnchor283"/><span class="koboSpan" id="kobo.573.1">Designing the scoring interface</span></h2>
<p><span class="koboSpan" id="kobo.574.1">The first design decision</span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.575.1"> we must take is what we need to return following a guess at the word. </span><span class="koboSpan" id="kobo.575.2">We need to return the following information to </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">the user:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.577.1">The score for the </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">current guess</span></span></li>
<li><span class="koboSpan" id="kobo.579.1">Whether or not the game is still in play or </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">has ended</span></span></li>
<li><span class="koboSpan" id="kobo.581.1">Possibly the previous history of scoring for </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">each guess</span></span></li>
<li><span class="koboSpan" id="kobo.583.1">Possibly a report of user </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">input errors</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.585.1">Clearly, the most important information for the player is the score for the current guess. </span><span class="koboSpan" id="kobo.585.2">Without that, the game cannot be played. </span><span class="koboSpan" id="kobo.585.3">As the game has a variable length – ending when either the word has been guessed, or when a maximum number of guesses has been attempted – we need an indicator that another guess will </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">be allowed.</span></span></p>
<p><span class="koboSpan" id="kobo.587.1">The idea behind returning the history of scores for previous guesses is that it might help the consumer of our domain model – ultimately, a user interface of some sort. </span><span class="koboSpan" id="kobo.587.2">If we return only the score for the current guess, the user interface will most likely need to retain its own history of scores, in order to present them properly. </span><span class="koboSpan" id="kobo.587.3">If we return the entire history of scores for this game, that information</span><a id="_idIndexMarker732"/><span class="koboSpan" id="kobo.588.1"> is easily available. </span><span class="koboSpan" id="kobo.588.2">A good rule of thumb in software is to follow the </span><strong class="bold"><span class="koboSpan" id="kobo.589.1">you ain’t gonna need it</span></strong><span class="koboSpan" id="kobo.590.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.591.1">YAGNI</span></strong><span class="koboSpan" id="kobo.592.1">) principle. </span><span class="koboSpan" id="kobo.592.2">As there is no requirement for a history of scores, we won’t build that at </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">this stage.</span></span></p>
<p><span class="koboSpan" id="kobo.594.1">The last decision we need to write our test is to think about the programming interface we want for this. </span><span class="koboSpan" id="kobo.594.2">We will choose an </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">assess()</span></strong><span class="koboSpan" id="kobo.596.1"> method on </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">class Wordz</span></strong><span class="koboSpan" id="kobo.598.1">. </span><span class="koboSpan" id="kobo.598.2">It will accept </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">String</span></strong><span class="koboSpan" id="kobo.600.1">, which is the current guess from the player. </span><span class="koboSpan" id="kobo.600.2">It will return </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">record</span></strong><span class="koboSpan" id="kobo.602.1">, which is a modern Java (since Java 14) way of indicating a pure data structure is to </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">be returned:</span></span></p>
<p><span class="koboSpan" id="kobo.604.1">We've now got enough to write a test. </span><span class="koboSpan" id="kobo.604.2">We'll make a new test for all guess-related behavior called </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">class GuessTest</span></strong><span class="koboSpan" id="kobo.606.1">. </span><span class="koboSpan" id="kobo.606.2">The test looks </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.608.1">
@ExtendWith(MockitoExtension.class)
public class GuessTest {
    private static final Player PLAYER = new Player();
    private static final String CORRECT_WORD = "ARISE";
    private static final String WRONG_WORD = "RXXXX";
    @Mock
    private GameRepository gameRepository;
    @InjectMocks
    private Wordz wordz;
    @Test
    void returnsScoreForGuess() {
        givenGameInRepository(
                       Game.create(PLAYER, CORRECT_WORD));
        GuessResult result = wordz.assess(PLAYER, WRONG_WORD);
        Letter firstLetter = result.score().letter(0);
        assertThat(firstLetter)
               .isEqualTo(Letter.PART_CORRECT);
    }
    private void givenGameInRepository(Game game) {
        when(gameRepository
           .fetchForPlayer(eq(PLAYER)))
              .thenReturn(Optional.of(game));
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.609.1">There are no new TDD techniques</span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.610.1"> in the test. </span><span class="koboSpan" id="kobo.610.2">It drives out the calling interface for our new </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">assess()</span></strong><span class="koboSpan" id="kobo.612.1"> method. </span><span class="koboSpan" id="kobo.612.2">We’ve used the static constructor idiom to create the game object using </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">Game.create()</span></strong><span class="koboSpan" id="kobo.614.1">. </span><span class="koboSpan" id="kobo.614.2">This method has been added to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">class Game</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.617.1">
    static Game </span><strong class="bold"><span class="koboSpan" id="kobo.618.1">create</span></strong><span class="koboSpan" id="kobo.619.1">(Player player, String correctWord) {
        return new Game(player, correctWord, 0, false);
    }</span></pre>
<p><span class="koboSpan" id="kobo.620.1">This clarifies the information necessary to create a new game. </span><span class="koboSpan" id="kobo.620.2">To get the test to compile, we create </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">record GuessResult</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.623.1">
package com.wordz.domain;
import java.util.List;
public record GuessResult(
        Score score,
        boolean isGameOver
) { }</span></pre>
<p><span class="koboSpan" id="kobo.624.1">We can make the test pass by writing the production code for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">assess()</span></strong><span class="koboSpan" id="kobo.626.1"> method in </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">class Wordz</span></strong><span class="koboSpan" id="kobo.628.1">. </span><span class="koboSpan" id="kobo.628.2">To do that, we will reuse the </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">class Word</span></strong><span class="koboSpan" id="kobo.630.1"> class that we have </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">already written:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.632.1">
public GuessResult assess(Player player, String guess) {
    var game = gameRepository.fetchForPlayer(player);
    var target = new Word(game.getWord());
    var score = target.guess(guess);
    return new GuessResult(score, false);
}</span></pre>
<p><span class="koboSpan" id="kobo.633.1">The assertion checks only that the score for the first letter is correct. </span><span class="koboSpan" id="kobo.633.2">This is intentionally a weak test. </span><span class="koboSpan" id="kobo.633.3">The detailed testing for scoring behavior is done in </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">class WordTest</span></strong><span class="koboSpan" id="kobo.635.1">, which we wrote previously. </span><span class="koboSpan" id="kobo.635.2">The test is described as weak, as it does not fully test the returned score, only the first letter of it. </span><span class="koboSpan" id="kobo.635.3">Strong testing of the scoring logic happens elsewhere, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">class WordTest</span></strong><span class="koboSpan" id="kobo.637.1">. </span><span class="koboSpan" id="kobo.637.2">The weak test here confirms we have something capable of scoring at least one letter correctly and is enough for us to test-drive the production code. </span><span class="koboSpan" id="kobo.637.3">We avoid duplicating </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">tests here.</span></span></p>
<p><span class="koboSpan" id="kobo.639.1">Running the test</span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.640.1"> shows that it passes. </span><span class="koboSpan" id="kobo.640.2">We can review the test code and production code to see whether refactoring will improve their design. </span><span class="koboSpan" id="kobo.640.3">At this point, nothing needs our urgent attention. </span><span class="koboSpan" id="kobo.640.4">We can move on to tracking progress through </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">the game.</span></span></p>
<h2 id="_idParaDest-275"><a id="_idTextAnchor284"/><span class="koboSpan" id="kobo.642.1">Triangulating game progress tracking</span></h2>
<p><span class="koboSpan" id="kobo.643.1">We need to track the number</span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.644.1"> of guesses that have been made so that we can end the game after a maximum number of attempts. </span><span class="koboSpan" id="kobo.644.2">Our design choice is to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">attemptNumber</span></strong><span class="koboSpan" id="kobo.646.1"> field in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">Game</span></strong><span class="koboSpan" id="kobo.648.1"> object and then store it </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">GameRepository</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.652.1">We add a test to drive this </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">code out:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.654.1">
@Test</span></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.655.1">void updatesAttemptNumber() {</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.656.1">    givenGameInRepository(</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.657.1">               Game.create(PLAYER, CORRECT_WORD));</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.658.1">    wordz.assess(PLAYER, WRONG_WORD);</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.659.1">    var game = getUpdatedGameInRepository();</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.660.1">    assertThat(game.getAttemptNumber()).isEqualTo(1);</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.661.1">}</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.662.1">
private Game getUpdatedGameInRepository() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.663.1">
    ArgumentCaptor&lt;Game&gt; argument</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.664.1">
            = ArgumentCaptor.forClass(Game.class);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.665.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.666.1">verify(gameRepository).update(argument.capture());</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.667.1">
    return argument.getValue();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.668.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.669.1">This test introduces</span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.670.1"> a new method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">update()</span></strong><span class="koboSpan" id="kobo.672.1">, into our </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">interface GameRepository</span></strong><span class="koboSpan" id="kobo.674.1">, responsible for writing the latest game information to storage. </span><span class="koboSpan" id="kobo.674.2">The Assert step uses a Mockito </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">ArgumentCaptor</span></strong><span class="koboSpan" id="kobo.676.1"> to inspect the </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">Game</span></strong><span class="koboSpan" id="kobo.678.1"> object that we pass into </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">update()</span></strong><span class="koboSpan" id="kobo.680.1">. </span><span class="koboSpan" id="kobo.680.2">We have written a </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">getUpdatedGameInRepository()</span></strong><span class="koboSpan" id="kobo.682.1"> method to deemphasize the inner workings of how we check what was passed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">gameRepository.update()</span></strong><span class="koboSpan" id="kobo.684.1"> method.  </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">assertThat()</span></strong><span class="koboSpan" id="kobo.686.1"> in the test verifies that </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">attemptNumber</span></strong><span class="koboSpan" id="kobo.688.1"> has been incremented. </span><span class="koboSpan" id="kobo.688.2">It started at zero, due to us creating a new game, and so the expected new value is </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">1</span></strong><span class="koboSpan" id="kobo.690.1">. </span><span class="koboSpan" id="kobo.690.2">This is the desired behavior for tracking an attempt to guess </span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">the word:</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.692.1">We add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">update()</span></strong><span class="koboSpan" id="kobo.694.1"> method to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">GameRepository</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.696.1"> interface:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.697.1">
package com.wordz.domain;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.698.1">
public interface GameRepository {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.699.1">
    void create(Game game);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.700.1">
    Game fetchForPlayer(Player player);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.701.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.702.1">void update(Game game);</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.703.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.704.1">We add the production code to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">assess()</span></strong><span class="koboSpan" id="kobo.706.1"> method in </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">class Wordz</span></strong><span class="koboSpan" id="kobo.708.1"> to increment </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">attemptNumber</span></strong><span class="koboSpan" id="kobo.710.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">call </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">update()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.714.1">
public GuessResult assess(Player player, String guess) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.715.1">
    var game = gameRepository.fetchForPlayer(player);</span></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.716.1">    game.incrementAttemptNumber();</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.717.1">    gameRepository.update(game);</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.718.1">
    var target = new Word(game.getWord());</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.719.1">
    var score = target.guess(guess);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.720.1">
    return new GuessResult(score, false);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.721.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.722.1">We add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">incrementAttemptNumber()</span></strong><span class="koboSpan" id="kobo.724.1"> method to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">class Game</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.727.1">
public void </span><strong class="bold"><span class="koboSpan" id="kobo.728.1">incrementAttemptNumber()</span></strong><span class="koboSpan" id="kobo.729.1"> {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.730.1">
    attemptNumber++;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.731.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.732.1">The test now passes. </span><span class="koboSpan" id="kobo.732.2">We can</span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.733.1"> think about any refactoring improvements we want to make. </span><span class="koboSpan" id="kobo.733.2">There are two things that seem to </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">stand out:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.735.1">The duplicated test setup between </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">class NewGameTest</span></strong><span class="koboSpan" id="kobo.737.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">class GuessTest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.740.1">At this stage, we can live with this duplication. </span><span class="koboSpan" id="kobo.740.2">The options are to combine both tests into the same test class, to extend a common test base class, or to use composition. </span><span class="koboSpan" id="kobo.740.3">None of them seem likely to aid readability much. </span><span class="koboSpan" id="kobo.740.4">It seems quite nice to have the two different test cases separate </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">for now.</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.742.1">The three lines inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">assess()</span></strong><span class="koboSpan" id="kobo.744.1"> method must always be called as a unit when we attempt another guess. </span><span class="koboSpan" id="kobo.744.2">It is possible to forget to call one of these, so it seems better to refactor to eliminate that possible error. </span><span class="koboSpan" id="kobo.744.3">We can refactor </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">like this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.746.1">
public GuessResult assess(Player player, String guess) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.747.1">
    var game = gameRepository.fetchForPlayer(player);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.748.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.749.1">Score score = game.attempt( guess );</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.750.1">    gameRepository.update(game);</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.751.1">
    return new GuessResult(score, false);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.752.1">
}</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.753.1">We move the code that used to be here into the newly created method: </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">attempt()</span></strong><span class="koboSpan" id="kobo.755.1"> on </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">class Game</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.758.1">
public Score </span><strong class="bold"><span class="koboSpan" id="kobo.759.1">attempt</span></strong><span class="koboSpan" id="kobo.760.1">(String </span><strong class="bold"><span class="koboSpan" id="kobo.761.1">latestGuess</span></strong><span class="koboSpan" id="kobo.762.1">) {
    attemptNumber++;
    var target = new Word(targetWord);
    return target.guess(</span><strong class="bold"><span class="koboSpan" id="kobo.763.1">latestGuess</span></strong><span class="koboSpan" id="kobo.764.1">);
}</span></pre>
<p><span class="koboSpan" id="kobo.765.1">Renaming the method</span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.766.1"> argument from </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">guess</span></strong><span class="koboSpan" id="kobo.768.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">latestGuess</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.770.1">improves readability.</span></span></p>
<p><span class="koboSpan" id="kobo.771.1">That completes the code needed to take a guess at the word. </span><span class="koboSpan" id="kobo.771.2">Let’s move on to test-driving the code we will need to detect when a game </span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">has ended.</span></span></p>
<h1 id="_idParaDest-276"><a id="_idTextAnchor285"/><span class="koboSpan" id="kobo.773.1">Ending the game</span></h1>
<p><span class="koboSpan" id="kobo.774.1">In this section, we will complete the tests </span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.775.1">and production code we need to drive out detecting the end of a game. </span><span class="koboSpan" id="kobo.775.2">This will happen when we do either of </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.777.1">Guess the </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">word correctly</span></span></li>
<li><span class="koboSpan" id="kobo.779.1">Make our final allowed attempt, based on a </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">maximum number</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.781.1">We can make a start by coding the end-of-game detection when we guess the </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">word correctly.</span></span></p>
<h2 id="_idParaDest-277"><a id="_idTextAnchor286"/><span class="koboSpan" id="kobo.783.1">Responding to a correct guess</span></h2>
<p><span class="koboSpan" id="kobo.784.1">In this case, the player guesses</span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.785.1"> the target word correctly. </span><span class="koboSpan" id="kobo.785.2">The game is over, and the player is awarded a number of points, based on how few attempts were needed before the correct guess was made. </span><span class="koboSpan" id="kobo.785.3">We need to communicate that the game is over and how many points have been awarded, leading to two new fields in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">class GuessResult</span></strong><span class="koboSpan" id="kobo.787.1">. </span><span class="koboSpan" id="kobo.787.2">We can add a test to our existing </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">class GuessTest</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.789.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.790.1">
@Test
void </span><strong class="bold"><span class="koboSpan" id="kobo.791.1">reportsGameOverOnCorrectGuess</span></strong><span class="koboSpan" id="kobo.792.1">(){
    var player = new Player();
    Game game = new Game(player, "ARISE", 0);
    when(gameRepository.fetchForPlayer(player))
                          .thenReturn(game);
    var wordz = new Wordz(gameRepository,
                           wordRepository, randomNumbers);
    var guess = "ARISE";
    GuessResult result = wordz.assess(player, guess);
    </span><strong class="bold"><span class="koboSpan" id="kobo.793.1">assertThat(result.isGameOver()).isTrue();</span></strong><span class="koboSpan" id="kobo.794.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.795.1">This drives out both a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">isGameOver(</span></strong><span class="koboSpan" id="kobo.797.1">)accessor in </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">class GuessResult</span></strong><span class="koboSpan" id="kobo.799.1"> and the behavior to make </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">that </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.803.1">
public GuessResult assess(Player player, String guess) {
    var game = gameRepository.fetchForPlayer(player);
    Score score = game.attempt( guess );
</span><strong class="bold"><span class="koboSpan" id="kobo.804.1">    if (score.allCorrect()) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.805.1">        return new GuessResult(score, true);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.806.1">    }</span></strong><span class="koboSpan" id="kobo.807.1">
    gameRepository.update(game);
    return new GuessResult(score, false);
}</span></pre>
<p><span class="koboSpan" id="kobo.808.1">This itself drives</span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.809.1"> out two new tests in </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">class WordTest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.812.1">
@Test
void </span><strong class="bold"><span class="koboSpan" id="kobo.813.1">reportsAllCorrect</span></strong><span class="koboSpan" id="kobo.814.1">() {
    var word = new Word("ARISE");
    var score = word.guess("ARISE");
    assertThat(score.allCorrect()).isTrue();
}
@Test
void </span><strong class="bold"><span class="koboSpan" id="kobo.815.1">reportsNotAllCorrect</span></strong><span class="koboSpan" id="kobo.816.1">() {
    var word = new Word("ARISE");
    var score = word.guess("ARI*E");
    assertThat(score.allCorrect()).isFalse();
}</span></pre>
<p><span class="koboSpan" id="kobo.817.1">These themselves drive out an implementation in </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">class Score</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.820.1">
public boolean allCorrect() {
    var totalCorrect = results.stream()
            .filter(letter -&gt; letter == Letter.CORRECT)
            .count();
    return totalCorrect == results.size();
}</span></pre>
<p><span class="koboSpan" id="kobo.821.1">With this, we have a valid implementation for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">isGameOver</span></strong><span class="koboSpan" id="kobo.823.1"> accessor in </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">record GuessResult</span></strong><span class="koboSpan" id="kobo.825.1">. </span><span class="koboSpan" id="kobo.825.2">All tests pass. </span><span class="koboSpan" id="kobo.825.3">Nothing</span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.826.1"> seems to need refactoring. </span><span class="koboSpan" id="kobo.826.2">We’ll move on to the </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">next test.</span></span></p>
<h2 id="_idParaDest-278"><a id="_idTextAnchor287"/><span class="koboSpan" id="kobo.828.1">Triangulating the game over due to too many incorrect guesses</span></h2>
<p><span class="koboSpan" id="kobo.829.1">The next test will drive out the response</span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.830.1"> to exceeding the maximum number of guesses allowed in </span><span class="No-Break"><span class="koboSpan" id="kobo.831.1">a game:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.832.1">
@Test
void gameOverOnTooManyIncorrectGuesses(){
    </span><strong class="bold"><span class="koboSpan" id="kobo.833.1">int maximumGuesses = 5</span></strong><span class="koboSpan" id="kobo.834.1">;
    givenGameInRepository(
            Game.create(PLAYER, CORRECT_WORD,
                    </span><strong class="bold"><span class="koboSpan" id="kobo.835.1">maximumGuesses-1</span></strong><span class="koboSpan" id="kobo.836.1">));
    GuessResult result = wordz.assess(PLAYER, WRONG_WORD);
    </span><strong class="bold"><span class="koboSpan" id="kobo.837.1">assertThat(result.isGameOver()).isTrue();</span></strong><span class="koboSpan" id="kobo.838.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.839.1">This test sets up </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">gameRepository</span></strong><span class="koboSpan" id="kobo.841.1"> to allow one, final guess. </span><span class="koboSpan" id="kobo.841.2">It then sets up the guess to be incorrect. </span><span class="koboSpan" id="kobo.841.3">We assert that </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">isGameOver()</span></strong><span class="koboSpan" id="kobo.843.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">true</span></strong><span class="koboSpan" id="kobo.845.1"> in this case. </span><span class="koboSpan" id="kobo.845.2">The test fails initially, as desired. </span><span class="koboSpan" id="kobo.845.3">We add an extra static constructor method in </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">class Game</span></strong><span class="koboSpan" id="kobo.847.1"> to specify an initial number </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">of attempts.</span></span></p>
<p><span class="koboSpan" id="kobo.849.1">We add the production code to end the game based on a maximum number </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">of guesses:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.851.1">
public GuessResult assess(Player player, String guess) {
    var game = gameRepository.fetchForPlayer(player);
    Score score = game.attempt( guess );
    if (score.allCorrect()) {
        return new GuessResult(score, true);
    }
    gameRepository.update(game);
    return new GuessResult(score,
                           </span><strong class="bold"><span class="koboSpan" id="kobo.852.1">game.hasNoRemainingGuesses()</span></strong><span class="koboSpan" id="kobo.853.1">);
}</span></pre>
<p><span class="koboSpan" id="kobo.854.1">We add this decision support method to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">class Game</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.857.1">
public boolean hasNoRemainingGuesses() {
    return attemptNumber == MAXIMUM_NUMBER_ALLOWED_GUESSES;
}</span></pre>
<p><span class="koboSpan" id="kobo.858.1">All our tests now pass. </span><span class="koboSpan" id="kobo.858.2">There </span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.859.1">is something suspicious about the code, however. </span><span class="koboSpan" id="kobo.859.2">It has been very finely tuned to work only if a guess is correct and within the allowed number of guesses, or when the guess is incorrect and exactly at the allowed number. </span><span class="koboSpan" id="kobo.859.3">It’s time to add some boundary condition tests and double-check </span><span class="No-Break"><span class="koboSpan" id="kobo.860.1">our logic.</span></span></p>
<h2 id="_idParaDest-279"><a id="_idTextAnchor288"/><span class="koboSpan" id="kobo.861.1">Triangulating response to guess after game over</span></h2>
<p><span class="koboSpan" id="kobo.862.1">We need a couple more tests</span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.863.1"> around the boundary conditions of the game over detection. </span><span class="koboSpan" id="kobo.863.2">The first one drives out the response to an incorrect guess being submitted after a </span><span class="No-Break"><span class="koboSpan" id="kobo.864.1">correct guess:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.865.1">
@Test
void rejectsGuessAfterGameOver(){
    var gameOver = new Game(PLAYER, CORRECT_WORD,
                1, </span><strong class="bold"><span class="koboSpan" id="kobo.866.1">true</span></strong><span class="koboSpan" id="kobo.867.1">);
    givenGameInRepository( gameOver );
    GuessResult result = wordz.assess(PLAYER, WRONG_WORD);
    </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">assertThat(result.isError()).isTrue();</span></strong><span class="koboSpan" id="kobo.869.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.870.1">There are a couple</span><a id="_idIndexMarker746"/><span class="koboSpan" id="kobo.871.1"> of design decisions captured in </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">this test:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.873.1">Once the game ends, we record this in a new field, </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">isGameOver</span></strong><span class="koboSpan" id="kobo.875.1">, in </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">class Game</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.878.1">This new field will need to be set whenever the game ends. </span><span class="koboSpan" id="kobo.878.2">We will need more tests to drive that </span><span class="No-Break"><span class="koboSpan" id="kobo.879.1">behavior out.</span></span></li>
<li><span class="koboSpan" id="kobo.880.1">We will use a simple error-reporting mechanism – a new field, </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">isError</span></strong><span class="koboSpan" id="kobo.882.1">, in </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">class GuessResult</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.885.1">This leads to a bit of automated refactoring to add the fourth parameter to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">class Game</span></strong><span class="koboSpan" id="kobo.887.1"> constructor. </span><span class="koboSpan" id="kobo.887.2">Then, we can add code to make the </span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">test pass:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.889.1">
public GuessResult assess(Player player, String guess) {
    var game = gameRepository.fetchForPlayer(player);
</span><strong class="bold"><span class="koboSpan" id="kobo.890.1">    if(game.isGameOver()) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.891.1">        return GuessResult.ERROR;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.892.1">    }</span></strong><span class="koboSpan" id="kobo.893.1">
    Score score = game.attempt( guess );
    if (score.allCorrect()) {
        return new GuessResult(score, true, </span><strong class="bold"><span class="koboSpan" id="kobo.894.1">false</span></strong><span class="koboSpan" id="kobo.895.1">);
    }
    gameRepository.update(game);
    return new GuessResult(score,
                   game.hasNoRemainingGuesses(), </span><strong class="bold"><span class="koboSpan" id="kobo.896.1">false</span></strong><span class="koboSpan" id="kobo.897.1">);
}</span></pre>
<p><span class="koboSpan" id="kobo.898.1">The design decision</span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.899.1"> here is that as soon as we fetch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">Game</span></strong><span class="koboSpan" id="kobo.901.1"> object, we check whether the game was previously marked as being over. </span><span class="koboSpan" id="kobo.901.2">If so, we report an error and we’re done. </span><span class="koboSpan" id="kobo.901.3">It’s simple and crude but adequate for our purposes. </span><span class="koboSpan" id="kobo.901.4">We also add a static constant, </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">GuessResult.ERROR</span></strong><span class="koboSpan" id="kobo.903.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">for readability:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.905.1">
    public static final GuessResult ERROR
                  = new GuessResult(null, true, true);</span></pre>
<p><span class="koboSpan" id="kobo.906.1">One consequence of this design decision is that we must update </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">GameRepository</span></strong><span class="koboSpan" id="kobo.908.1"> whenever the </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">Game.isGameOver</span></strong><span class="koboSpan" id="kobo.910.1"> field changes to </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">true</span></strong><span class="koboSpan" id="kobo.912.1">. </span><span class="koboSpan" id="kobo.912.2">An example of one of these tests </span><span class="No-Break"><span class="koboSpan" id="kobo.913.1">is this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.914.1">
@Test
void recordsGameOverOnCorrectGuess(){
    givenGameInRepository(Game.create(PLAYER, CORRECT_WORD));
    wordz.assess(PLAYER, CORRECT_WORD);
    Game game = getUpdatedGameInRepository();
    </span><strong class="bold"><span class="koboSpan" id="kobo.915.1">assertThat(game.isGameOver()).isTrue();</span></strong><span class="koboSpan" id="kobo.916.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.917.1">Here is the production</span><a id="_idIndexMarker748"/><span class="koboSpan" id="kobo.918.1"> code to add that </span><span class="No-Break"><span class="koboSpan" id="kobo.919.1">recording logic:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.920.1">
public GuessResult assess(Player player, String guess) {
    var game = gameRepository.fetchForPlayer(player);
    if(game.isGameOver()) {
        return GuessResult.ERROR;
    }
    Score score = game.attempt( guess );
    if (score.allCorrect()) {
</span><strong class="bold"><span class="koboSpan" id="kobo.921.1">        game.end();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.922.1">        gameRepository.update(game);</span></strong><span class="koboSpan" id="kobo.923.1">
        return new GuessResult(score, true, false);
    }
    gameRepository.update(game);
    return new GuessResult(score,
                 game.hasNoRemainingGuesses(), false);
}</span></pre>
<p><span class="koboSpan" id="kobo.924.1">We need another test to drive out the recording of game over when we run out of guesses. </span><span class="koboSpan" id="kobo.924.2">That will lead to a change in the production code. </span><span class="koboSpan" id="kobo.924.3">Those changes can be found in GitHub at the link given at the start of this chapter. </span><span class="koboSpan" id="kobo.924.4">They are very similar to the ones </span><span class="No-Break"><span class="koboSpan" id="kobo.925.1">made previously.</span></span></p>
<p><span class="koboSpan" id="kobo.926.1">Finally, let’s review our design and see whether we can improve it </span><span class="No-Break"><span class="koboSpan" id="kobo.927.1">still further.</span></span></p>
<h2 id="_idParaDest-280"><a id="_idTextAnchor289"/><span class="koboSpan" id="kobo.928.1">Reviewing our design</span></h2>
<p><span class="koboSpan" id="kobo.929.1">We’ve been</span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.930.1"> making small, tactical refactoring steps as we write the code, which is always a good idea. </span><span class="koboSpan" id="kobo.930.2">Like gardening, it is far easier to keep the garden tidy if we pull up weeds before they grow. </span><span class="koboSpan" id="kobo.930.3">Even so, it is worth taking a holistic look at the design of our code and tests before we move on. </span><span class="koboSpan" id="kobo.930.4">We may never get the chance to touch this code again, and it has our name on it. </span><span class="koboSpan" id="kobo.930.5">Let’s make it something that we are proud of and that will be safe and simple for our colleagues to work with in </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">the future.</span></span></p>
<p><span class="koboSpan" id="kobo.932.1">The tests we’ve already written enable us great latitude in refactoring. </span><span class="koboSpan" id="kobo.932.2">They have avoided testing specific implementations, instead testing desired outcomes. </span><span class="koboSpan" id="kobo.932.3">They also test larger units of code – in this case, the domain model of our hexagonal architecture. </span><span class="koboSpan" id="kobo.932.4">As a result, without changing any tests, it is possible to refactor our </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">class Wordz</span></strong><span class="koboSpan" id="kobo.934.1"> to look </span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.936.1">
package com.wordz.domain;
public class Wordz {
    private final GameRepository gameRepository;
    private final WordSelection selection ;
    public Wordz(GameRepository repository,
                 WordRepository wordRepository,
                 RandomNumbers randomNumbers) {
        this.gameRepository = repository;
        this.selection =
             new WordSelection(wordRepository, randomNumbers);
    }
</span><strong class="bold"><span class="koboSpan" id="kobo.937.1">    public void newGame(Player player) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.938.1">        var word = wordSelection.chooseRandomWord();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.939.1">        gameRepository.create(Game.create(player, word));</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.940.1">    }</span></strong></pre>
<p><span class="koboSpan" id="kobo.941.1">Our refactored </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">assess()</span></strong><span class="koboSpan" id="kobo.943.1"> method</span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.944.1"> now looks </span><span class="No-Break"><span class="koboSpan" id="kobo.945.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.946.1">
    public GuessResult assess(Player player, String guess) {
</span><strong class="bold"><span class="koboSpan" id="kobo.947.1">        Game game = gameRepository.fetchForPlayer(player);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.948.1">        if(game.isGameOver()) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.949.1">            return GuessResult.ERROR;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.950.1">        }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.951.1">        Score score = game.attempt( guess );</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.952.1">        gameRepository.update(game);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.953.1">        return new GuessResult(score,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.954.1">                               game.isGameOver(), false);</span></strong><span class="koboSpan" id="kobo.955.1">
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.956.1">That’s looking simpler. </span><span class="koboSpan" id="kobo.956.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">class GuessResult</span></strong><span class="koboSpan" id="kobo.958.1"> constructor code now stands out as being particularly ugly. </span><span class="koboSpan" id="kobo.958.2">It features the classic anti-pattern of using multiple Boolean flag values. </span><span class="koboSpan" id="kobo.958.3">We need to clarify what the different combinations actually mean, to simplify creating the object. </span><span class="koboSpan" id="kobo.958.4">One useful approach is to apply the static constructor idiom </span><span class="No-Break"><span class="koboSpan" id="kobo.959.1">once more:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.960.1">
package com.wordz.domain;
public record GuessResult(
        Score score,
        boolean isGameOver,
        boolean isError
) {
    static final GuessResult ERROR
         = new GuessResult(null, true, true);
</span><strong class="bold"><span class="koboSpan" id="kobo.961.1">    static GuessResult create(Score score,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.962.1">                              boolean isGameOver) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.963.1">        return new GuessResult(score, isGameOver, false);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.964.1">    }</span></strong><span class="koboSpan" id="kobo.965.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.966.1">This simplifies the </span><strong class="source-inline"><span class="koboSpan" id="kobo.967.1">assess()</span></strong><span class="koboSpan" id="kobo.968.1"> method </span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.969.1">by eliminating the need to understand that final </span><span class="No-Break"><span class="koboSpan" id="kobo.970.1">Boolean flag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.971.1">
public GuessResult assess(Player player, String guess) {
    Game game = gameRepository.fetchForPlayer(player);
    if(game.isGameOver()) {
        return GuessResult.ERROR;
    }
    Score score = game.attempt( guess );
    gameRepository.update(game);
    return </span><strong class="bold"><span class="koboSpan" id="kobo.972.1">GuessResult.create(score, game.isGameOver());</span></strong><span class="koboSpan" id="kobo.973.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.974.1">Another improvement to aid understanding concerns creating new instances of </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">class Game</span></strong><span class="koboSpan" id="kobo.976.1">. </span><span class="koboSpan" id="kobo.976.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.977.1">rejectsGuessAfterGameOver()</span></strong><span class="koboSpan" id="kobo.978.1"> test uses Boolean flag values in a four-argument constructor</span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.979.1"> to set the test up in a game-over state. </span><span class="koboSpan" id="kobo.979.2">Let’s make the goal of creating a game-over state explicit. </span><span class="koboSpan" id="kobo.979.3">We can make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">Game</span></strong><span class="koboSpan" id="kobo.981.1"> constructor private, and increase the visibility of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.982.1">end()</span></strong><span class="koboSpan" id="kobo.983.1"> method, which is already used to end a game. </span><span class="koboSpan" id="kobo.983.2">Our revised test looks </span><span class="No-Break"><span class="koboSpan" id="kobo.984.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.985.1">
@Test
void rejectsGuessAfterGameOver(){
</span><strong class="bold"><span class="koboSpan" id="kobo.986.1">    var game = Game.create(PLAYER, CORRECT_WORD);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.987.1">    game.end();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.988.1">    givenGameInRepository( game );</span></strong><span class="koboSpan" id="kobo.989.1">
    GuessResult result = wordz.assess(PLAYER, WRONG_WORD);
    assertThat(result.isError()).isTrue();
}</span></pre>
<p><span class="koboSpan" id="kobo.990.1">The Arrange step is now more descriptive. </span><span class="koboSpan" id="kobo.990.2">The four-argument constructor is no longer accessible, steering future development to use the safer, more descriptive static constructor methods. </span><span class="koboSpan" id="kobo.990.3">This improved design helps prevent defects from being introduced in </span><span class="No-Break"><span class="koboSpan" id="kobo.991.1">the future.</span></span></p>
<p><span class="koboSpan" id="kobo.992.1">We have made great progress in this chapter. </span><span class="koboSpan" id="kobo.992.2">Following these final refactoring improvements, we have an easily readable description of the core logic of our game. </span><span class="koboSpan" id="kobo.992.3">It is fully backed by FIRST unit tests. </span><span class="koboSpan" id="kobo.992.4">We have even achieved a meaningful 100% code coverage of lines of code executed by our tests. </span><span class="koboSpan" id="kobo.992.5">This is shown in the IntelliJ code </span><span class="No-Break"><span class="koboSpan" id="kobo.993.1">coverage tool:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer109">
<span class="koboSpan" id="kobo.994.1"><img alt="Figure 13.6 – Code coverage report" src="image/Figure_13.6_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.995.1">Figure 13.6 – Code coverage report</span></p>
<p><span class="koboSpan" id="kobo.996.1">That’s the core of our game finished. </span><span class="koboSpan" id="kobo.996.2">We can start a new game, play a game, and end a game. </span><span class="koboSpan" id="kobo.996.3">The game can be developed further to include features such as awarding a points score based on how quickly</span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.997.1"> the word was guessed and a high score table for players. </span><span class="koboSpan" id="kobo.997.2">These would be added using the same techniques we have been applying throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.998.1">this chapter.</span></span></p>
<h1 id="_idParaDest-281"><a id="_idTextAnchor290"/><span class="koboSpan" id="kobo.999.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1000.1">We’ve covered a lot of ground in this chapter. </span><span class="koboSpan" id="kobo.1000.2">We have used TDD to drive out the core application logic for our Wordz game. </span><span class="koboSpan" id="kobo.1000.3">We have taken small steps and used triangulation to steadily drive more details into our code implementation. </span><span class="koboSpan" id="kobo.1000.4">We have used hexagonal architecture to enable us to use FIRST unit tests, freeing us from cumbersome integration tests with their test environments. </span><span class="koboSpan" id="kobo.1000.5">We have employed test doubles to replace difficult-to-control objects, such as the database and random </span><span class="No-Break"><span class="koboSpan" id="kobo.1001.1">number generation.</span></span></p>
<p><span class="koboSpan" id="kobo.1002.1">We built up a valuable suite of unit tests that are decoupled from specific implementations. </span><span class="koboSpan" id="kobo.1002.2">This enabled us to refactor the code freely, ending up with a very nice software design, based on the SOLID principles, which will reduce maintenance </span><span class="No-Break"><span class="koboSpan" id="kobo.1003.1">efforts significantly.</span></span></p>
<p><span class="koboSpan" id="kobo.1004.1">We finished with a meaningful code coverage report that showed 100% of the lines of production code were executed by our tests, giving us a high degree of confidence in </span><span class="No-Break"><span class="koboSpan" id="kobo.1005.1">our work.</span></span></p>
<p><span class="koboSpan" id="kobo.1006.1">Next, in </span><a href="B18384_14.xhtml#_idTextAnchor293"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1007.1">Chapter 14</span></em></span></a><span class="koboSpan" id="kobo.1008.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1009.1">Driving the Database Layer</span></em><span class="koboSpan" id="kobo.1010.1">, we will write the database adapter along with an integration test to implement our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">GameRepository</span></strong><span class="koboSpan" id="kobo.1012.1">, using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1013.1">Postgres database.</span></span></p>
<h1 id="_idParaDest-282"><a id="_idTextAnchor291"/><span class="koboSpan" id="kobo.1014.1">Questions and answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1015.1">Does every method in every class have to have its own </span><span class="No-Break"><span class="koboSpan" id="kobo.1016.1">unit test?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1017.1">No. </span><span class="koboSpan" id="kobo.1017.2">That seems to be a common view, but it is harmful. </span><span class="koboSpan" id="kobo.1017.3">If we use that approach, we are locking in the implementation details and will not be able to refactor without </span><span class="No-Break"><span class="koboSpan" id="kobo.1018.1">breaking tests.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.1019.1">What is the significance of 100% code coverage when running </span><span class="No-Break"><span class="koboSpan" id="kobo.1020.1">our tests?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1021.1">Not much, by itself. </span><span class="koboSpan" id="kobo.1021.2">It simply means that all the lines of code in the units under the test were executed during the test run. </span><span class="koboSpan" id="kobo.1021.3">For us, it means a little more due to our use of test-first TDD. </span><span class="koboSpan" id="kobo.1021.4">We know that every line of code was driven by a meaningful test of behavior that is important to our application. </span><span class="koboSpan" id="kobo.1021.5">Having 100% coverage is a double-check that we didn’t forget to add </span><span class="No-Break"><span class="koboSpan" id="kobo.1022.1">a test.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.1023.1">Does 100% code coverage during the test run mean we have </span><span class="No-Break"><span class="koboSpan" id="kobo.1024.1">perfect code?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1025.1">No. </span><span class="koboSpan" id="kobo.1025.2">Testing can only reveal the presence of defects, never their absence. </span><span class="koboSpan" id="kobo.1025.3">We can have 100% coverage with very low-quality code in terms of readability and edge case handling. </span><span class="koboSpan" id="kobo.1025.4">It is important to not attach too much importance to code coverage metrics. </span><span class="koboSpan" id="kobo.1025.5">For TDD, they serve as a cross-check that we haven’t missed any boundary </span><span class="No-Break"><span class="koboSpan" id="kobo.1026.1">condition tests.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.1027.1">Is all this </span><span class="No-Break"><span class="koboSpan" id="kobo.1028.1">refactoring normal?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1029.1">Yes. </span><span class="koboSpan" id="kobo.1029.2">TDD is all about rapid feedback loops. </span><span class="koboSpan" id="kobo.1029.3">Feedback helps us explore design ideas and change our minds as we uncover better designs. </span><span class="koboSpan" id="kobo.1029.4">It frees us from the tyranny of having to understand every detail – somehow – before we start work. </span><span class="koboSpan" id="kobo.1029.5">We discover a design by doing the work and have working software to show for it at </span><span class="No-Break"><span class="koboSpan" id="kobo.1030.1">the end.</span></span></p>
<h1 id="_idParaDest-283"><a id="_idTextAnchor292"/><span class="koboSpan" id="kobo.1031.1">Further reading</span></h1>
<ul>
<li><span class="koboSpan" id="kobo.1032.1">AssertJ documentation – read more about the various kinds of assertion matchers built into AssertJ, as well as details on how to create custom assertions </span><span class="No-Break"><span class="koboSpan" id="kobo.1033.1">here: </span></span><a href="B18384_13.xhtml#_idTextAnchor291"><span class="No-Break"><span class="koboSpan" id="kobo.1034.1">https://assertj.github.io/doc/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1035.1">.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1036.1">Refactoring – Improving the Design of Existing Code</span></em><span class="koboSpan" id="kobo.1037.1">, Martin Fowler (first edition), </span><span class="No-Break"><span class="koboSpan" id="kobo.1038.1">ISBN 9780201485677:</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1039.1">The bulk of our work in TDD is refactoring code, continuously providing a good-enough design to support our new features. </span><span class="koboSpan" id="kobo.1039.2">This book contains excellent advice on how to approach refactoring in a disciplined, </span><span class="No-Break"><span class="koboSpan" id="kobo.1040.1">step-by-step way.</span></span></p>
<p><span class="koboSpan" id="kobo.1041.1">The first edition of the book uses Java for all its examples, so is more useful to us than the JavaScript-based </span><span class="No-Break"><span class="koboSpan" id="kobo.1042.1">second edition.</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.1043.1">Design Patterns – Elements of Reusable Object-Oriented Software</span></em><span class="koboSpan" id="kobo.1044.1">, Gamma, Helm, Vlissides, Johnson, </span><span class="No-Break"><span class="koboSpan" id="kobo.1045.1">ISBN 9780201633610:</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1046.1">A landmark book that cataloged common combinations of classes that occur in object-oriented software. </span><span class="koboSpan" id="kobo.1046.2">Earlier in the chapter, we used a controller class. </span><span class="koboSpan" id="kobo.1046.3">This is described as a façade pattern, in the terms of this book. </span><span class="koboSpan" id="kobo.1046.4">The listed patterns are free of any kind of framework or software layer and so are very useful in building the domain model of </span><span class="No-Break"><span class="koboSpan" id="kobo.1047.1">hexagonal architecture.</span></span></p>
</div>
</body></html>