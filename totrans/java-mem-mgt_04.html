<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><div id="_idContainer061" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-58" lang="en-GB"><a id="_idTextAnchor057" class="pcalibre pcalibre2 pcalibre1 calibre6"/>4</h1>
<h1 id="_idParaDest-59" lang="en-GB" class="calibre5"><a id="_idTextAnchor058" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Freeing Memory with Garbage Collection</h1>
<p lang="en-GB" class="calibre4">Allocated memory needs to be deallocated when it is no longer needed. In some languages, the developer needs to take care of that. In some others, such as Java, this happens automatically. For Java, the garbage collector does this. The deallocation of memory is necessary for an application to keep running. Without the ability to free memory when it is no longer needed, we would only be able to allocate memory once, and eventually, we would run out of memory. In this chapter, we will be learning more about freeing memory on the heap using the <span lang="">garbage collector.</span></p>
<p lang="en-GB" class="calibre4">This can be a tough topic! Before you are ready for this chapter, you’ll need to have a clear understanding of the heap space. Again, we’ll visualize the concepts as much as possible to increase <span lang="">your understanding.</span></p>
<p lang="en-GB" class="calibre4">Here are the topics that will <span lang="">be discussed:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11">Object eligibility for <strong class="bold" lang="">garbage </strong><span lang=""><strong class="bold" lang="">collection</strong></span><span lang=""> (</span><span lang=""><strong class="bold" lang="">GC</strong></span><span lang="">)</span></li>
<li lang="en-GB" class="calibre11">Marking by the <span lang="">garbage collector</span></li>
<li lang="en-GB" class="calibre11">Sweeping by the <span lang="">garbage collector</span></li>
<li lang="en-GB" class="calibre11">Different <span lang="">GC implementations</span></li>
</ul>
<h1 id="_idParaDest-60" lang="en-GB" class="calibre5"><a id="_idTextAnchor059" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Technical requirements</h1>
<p lang="en-GB" class="calibre4">The code for this chapter can be found on GitHub <span lang="">at </span><a href="https://github.com/PacktPublishing/B18762_Java-Memory-Management" class="pcalibre pcalibre2 pcalibre1 calibre6"><span lang="">https://github.com/PacktPublishing/B18762_Java-Memory-Management</span></a><span lang="">.</span></p>
<h1 id="_idParaDest-61" lang="en-GB" class="calibre5"><a id="_idTextAnchor060" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Being eligible for GC</h1>
<p lang="en-GB" class="calibre4">We already <a id="_idIndexMarker149" class="pcalibre pcalibre2 pcalibre1 calibre6"/>know that objects on the heap are removed when they are no longer needed. The right question to ask, then, would be, <em class="italic" lang="">when are objects no </em><span lang=""><em class="italic" lang="">longer needed?</em></span></p>
<p lang="en-GB" class="calibre4">That question is easy to answer but leads to a complex problem at the same time. Let’s first have a look at the answer: <em class="italic" lang="">objects on the heap are no longer needed when they don’t have a connection to </em><span lang=""><em class="italic" lang="">the stack</em></span><span lang="">.</span></p>
<p lang="en-GB" class="calibre4">Objects don’t have a connection to the stack when the stack doesn’t store the reference to the object in a variable. Here is a <span lang="">simple example:</span></p>
<pre class="source-code" lang="en-GB">Object o = new Object();</pre>
<pre class="source-code" lang="en-GB">System.out.println(o);</pre>
<pre class="source-code" lang="en-GB">o = null;</pre>
<p lang="en-GB" class="calibre4">In the first line, we create the object, which gets created on the heap. The <strong class="source-inline" lang="">o</strong> variable holds a reference to an object of type <strong class="source-inline" lang="">Object</strong> on the stack. We use the object because we have the reference stored. In this case, we are printing it on the second line of the example, which is clearly a rather silly output since the <strong class="source-inline" lang="">toString()</strong> method of <strong class="source-inline" lang="">Object</strong> is only going to be returning the following output to <span lang="">the console:</span></p>
<pre class="source-code" lang="en-GB">java.lang.Object@4617c264</pre>
<p lang="en-GB" class="calibre4">In the next line, we set the variable to <strong class="source-inline" lang="">null</strong>. This overrides the reference to the object and simply points nowhere, as there is no object stored in <strong class="source-inline" lang="">o</strong> anymore. Nothing else in our application holds a reference to the <strong class="source-inline" lang="">Object</strong> we’ve created. Thus, it becomes eligible <span lang="">for GC.</span></p>
<p lang="en-GB" class="calibre4">This example was rather simple. To demonstrate how difficult this problem actually is, let’s look at a slightly more complex problem and illustrate it with some diagrams. The question that we need to answer here is, <em class="italic" lang="">which objects are eligible for GC on </em><span lang=""><em class="italic" lang="">each line?</em></span></p>
<pre class="source-code" lang="en-GB">Person p1 = new Person(); // 1</pre>
<pre class="source-code" lang="en-GB">Person p2 = new Person(); // 2</pre>
<pre class="source-code" lang="en-GB">Person p3 = new Person(); // 3</pre>
<pre class="source-code" lang="en-GB">List&lt;Person&gt; personList = Arrays.asList(p1, p2, p3); // 4</pre>
<pre class="source-code" lang="en-GB">p1 = null; // 5</pre>
<pre class="source-code" lang="en-GB">personList = null; // 6</pre>
<p lang="en-GB" class="calibre4">This code <a id="_idIndexMarker150" class="pcalibre pcalibre2 pcalibre1 calibre6"/>snippet has a heap and stack that could look somewhat like <span lang=""><em class="italic" lang="">Figure 4</em></span><em class="italic" lang="">.1</em> after the first <span lang="">four lines.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer044">
<img alt="Figure 4.1 – Overview of the stack and heap for the eligibility example" src="image/Figure_4.1_B18762.jpg" class="calibre52"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Overview of the stack and heap for the eligibility example</p>
<p lang="en-GB" class="calibre4">On the fifth line, we set our <strong class="source-inline" lang="">p1</strong> to <strong class="source-inline" lang="">null</strong>. Does this mean that <strong class="source-inline" lang="">p1</strong> is eligible for GC? Quick reminder: an object on the heap is eligible for GC as soon as it doesn’t have a connection to the stack anymore. But let’s look at what happens after executing <span lang="">line 5:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer045">
<img alt="Figure 4.2 – Overview of the heap and the stack after executing line 5" src="image/Figure_4.2_B18762.jpg" class="calibre53"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Overview of the heap and the stack after executing line 5</p>
<p lang="en-GB" class="calibre4">As we <a id="_idIndexMarker151" class="pcalibre pcalibre2 pcalibre1 calibre6"/>can see, the connection to the stack in <strong class="source-inline" lang="">p1</strong> is gone. But this doesn’t mean that there’s no connection to the stack anymore. There’s still an indirect connection. We can go from the stack to the list of <strong class="source-inline" lang="">Person</strong> object, and from there we can still access the object that <strong class="source-inline" lang="">p1</strong> was holding a reference to, since the list still holds a reference to that object. Therefore, none of the objects on the heap is eligible for GC after <span lang="">line 5.</span></p>
<p lang="en-GB" class="calibre4">This changes after line 6. At line 6, we set the variable that held the list to <strong class="source-inline" lang="">null</strong>. This means that <strong class="source-inline" lang="">p1</strong> no longer has a connection to the stack after this line, as you can see in <span lang=""><em class="italic" lang="">Figure 4</em></span><span lang=""><em class="italic" lang="">.3</em></span><span lang="">.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer046">
<img alt="Figure 4.3 – Overview of the heap and stack at the end of the code" src="image/Figure_4.3_B18762.jpg" class="calibre54"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Overview of the heap and stack at the end of the code</p>
<p lang="en-GB" class="calibre4">There is no<a id="_idIndexMarker152" class="pcalibre pcalibre2 pcalibre1 calibre6"/> connection between the list and the stack, and now both the <strong class="source-inline" lang="">List</strong> object and the first instance of the <strong class="source-inline" lang="">Person</strong> object are eligible for GC. Meanwhile, the <strong class="source-inline" lang="">p2</strong> and <strong class="source-inline" lang="">p3</strong> variables still hold a reference to the objects on the heap, and therefore these objects are not eligible <span lang="">for GC.</span></p>
<p lang="en-GB" class="calibre4">It’s not hard to tell which ones are ready for GC once you understand the direct and indirect connection from the heap back to the stack. However, figuring out which ones have a connection with the stack will require some time, and this will slow down the rest of the application. There are a few ways to do it, but each comes with its own downsides with respect to accuracy <span lang="">or performance.</span></p>
<p lang="en-GB" class="calibre4">This complex problem is language-agnostic: how do we determine whether an object still has a connection to the stack? The solution we’ll be discussing is of course Java-specific. Finding objects that are no longer needed is done by the garbage collector in the marking phase. The marking phase consists of a special algorithm that determines what objects are eligible <span lang="">for GC.</span></p>
<h1 id="_idParaDest-62" lang="en-GB" class="calibre5"><a id="_idTextAnchor061" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Marking by the garbage collector</h1>
<p lang="en-GB" class="calibre4">Marking marks <a id="_idIndexMarker153" class="pcalibre pcalibre2 pcalibre1 calibre6"/>any live objects and anything not marked as ready to be garbage collected. The objects keep a special bit that determines whether they are marked or not. Upon creation, the bit is <strong class="source-inline" lang="">0</strong>. In the mark phase, if an object is still in use and should not be removed, it gets set <span lang="">to </span><span lang=""><strong class="source-inline" lang="">1</strong></span><span lang="">.</span></p>
<p lang="en-GB" class="calibre4">The heap is constantly changing and so is the stack. Objects on the heap that do not have a connection to the step are eligible for GC. They are unreachable and there is no possible way for the application to be using these objects. The objects that are not ready for removal are marked; the unmarked objects will <span lang="">be removed.</span></p>
<p lang="en-GB" class="calibre4">How exactly this is implemented differs depending on the implementation of Java and the specific garbage collector you are using. But at a high level, this process starts from the stack. All the object references on the stack are followed and the objects <span lang="">are marked.</span></p>
<p lang="en-GB" class="calibre4">If we look at our previous example, this is how they would be marked. We are using the following code sample where we do not set the reference of <strong class="source-inline" lang="">personList</strong> <span lang="">to </span><span lang=""><strong class="source-inline" lang="">null</strong></span><span lang="">:</span></p>
<pre class="source-code" lang="en-GB">Person p1 = new Person(); // 1</pre>
<pre class="source-code" lang="en-GB">Person p2 = new Person(); // 2</pre>
<pre class="source-code" lang="en-GB">Person p3 = new Person(); // 3</pre>
<pre class="source-code" lang="en-GB">List&lt;Person&gt; personList = Arrays.asList(p1, p2, p3); // 4</pre>
<pre class="source-code" lang="en-GB">p1 = null; // 5</pre>
<p lang="en-GB" class="calibre4">Before the GC starts, all the objects are unmarked. This means the special bit is <strong class="source-inline" lang="">0</strong>, which is the value they get <span lang="">upon creation.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer047">
<img alt="Figure 4.4 – Before garbage collection starts, none of the objects is marked" src="image/Figure_4.4_B18762.jpg" class="calibre55"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Before garbage collection starts, none of the objects is marked</p>
<p lang="en-GB" class="calibre4">So, to start off with, all <a id="_idIndexMarker154" class="pcalibre pcalibre2 pcalibre1 calibre6"/>of them are unmarked, as we can tell from all the <strong class="source-inline" lang="">0</strong> after the objects. The next step is to mark the objects with a connection to the stack by changing the <strong class="source-inline" lang="">0</strong> to <span lang="">a </span><span lang=""><strong class="source-inline" lang="">1</strong></span><span lang="">.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer048">
<img alt="Figure 4.5 – Marking step one: direct connection to the stack" src="image/Figure_4.5_B18762.jpg" class="calibre56"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Marking step one: direct connection to the stack</p>
<p lang="en-GB" class="calibre4">But it’s not<a id="_idIndexMarker155" class="pcalibre pcalibre2 pcalibre1 calibre6"/> enough to just mark the ones with a direct connection to the stack. Right now, the object referred to by <strong class="source-inline" lang="">Person p1</strong> would be eligible for GC even though it is reachable. This is also why the references of each object are also traveled and marked, until there are no more nested objects. <span lang=""><em class="italic" lang="">Figure 4</em></span><em class="italic" lang="">.6</em> shows what our example looks like after the <span lang="">marking phase.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer049">
<img alt="Figure 4.6 – After marking" src="image/Figure_4.6_B18762.jpg" class="calibre57"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.6 – After marking</p>
<p lang="en-GB" class="calibre4">All the objects <a id="_idIndexMarker156" class="pcalibre pcalibre2 pcalibre1 calibre6"/>on our heap are marked, as we can tell by the <strong class="source-inline" lang="">1</strong> after every object. So, in our example, none of the objects is eligible for GC as they are all <span lang="">still reachable.</span></p>
<p lang="en-GB" class="calibre4">There are different algorithms that play an important role in the marking phase. The first one that we are going to have a look at is the <span lang="">stop-the-world approach.</span></p>
<h2 id="_idParaDest-63" lang="en-GB" class="calibre7"><a id="_idTextAnchor062" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Stop-the-world</h2>
<p lang="en-GB" class="calibre4">Think<a id="_idIndexMarker157" class="pcalibre pcalibre2 pcalibre1 calibre6"/> about how this could be done for a second. While you<a id="_idIndexMarker158" class="pcalibre pcalibre2 pcalibre1 calibre6"/> are checking all the variables on the stack and marking all their objects and the nested objects, new objects could have been created in the meantime. It’s possible that you missed that part of the stack. This would lead to unmarked objects (remember, objects are initially unmarked upon creation) that should have been marked, and they would be removed as a result. That would be <span lang="">very problematic.</span></p>
<p lang="en-GB" class="calibre4">The solution <a id="_idIndexMarker159" class="pcalibre pcalibre2 pcalibre1 calibre6"/>to this impacts performance as the garbage collector needs to pause the execution of the main application in order to make sure no new objects will be created during the <a id="_idIndexMarker160" class="pcalibre pcalibre2 pcalibre1 calibre6"/>marking phase. This strategy is called stop-the-world, which – as dramatic as it sounds – is a Java term. There also are other strategies in the field of computer science, one of them being reference counting, which we will look <span lang="">at next.</span></p>
<h2 id="_idParaDest-64" lang="en-GB" class="calibre7"><a id="_idTextAnchor063" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Reference counting and islands of isolation</h2>
<p lang="en-GB" class="calibre4">Another <a id="_idIndexMarker161" class="pcalibre pcalibre2 pcalibre1 calibre6"/>implementation approach is of counting the number of references on an object. All objects would contain a count of the number of times they were referenced as some sort of property. This way, executing GC is nothing more than just removing all the objects with a <strong class="source-inline" lang="">0</strong> for the number of times they <span lang="">are referenced.</span></p>
<p lang="en-GB" class="calibre4">You might be thinking that this is a lot better than pausing the application, and so, why don’t we use it? The answer to that is islands of isolation. This is not some modern-day social phenomenon; islands of isolation are objects that just reference each other without having a connection to <span lang="">the stack.</span></p>
<p lang="en-GB" class="calibre4">Let’s explore the stack and heap for the following code sample. We have a <strong class="source-inline" lang="">Nest</strong> class in <span lang="">this example:</span></p>
<pre class="source-code" lang="en-GB">class Nest {</pre>
<pre class="source-code" lang="en-GB">    private Nest;</pre>
<pre class="source-code" lang="en-GB">    public Nest getNest() {</pre>
<pre class="source-code" lang="en-GB">        return nest;</pre>
<pre class="source-code" lang="en-GB">    }</pre>
<pre class="source-code" lang="en-GB">    public void setNest(Nest nest) {</pre>
<pre class="source-code" lang="en-GB">        this.nest = nest;</pre>
<pre class="source-code" lang="en-GB">    }</pre>
<pre class="source-code" lang="en-GB">}</pre>
<p lang="en-GB" class="calibre4">We are creating two <strong class="source-inline" lang="">Nest</strong> instances and setting them to be each other’s <span lang=""><strong class="source-inline" lang="">nest</strong></span><span lang=""> property:</span></p>
<pre class="source-code" lang="en-GB">public class IslandOfIsolation {</pre>
<pre class="source-code" lang="en-GB">    public static void main(String[] args) {</pre>
<pre class="source-code" lang="en-GB">        Nest n1 = new Nest(); // 1</pre>
<pre class="source-code" lang="en-GB">        Nest n2 = new Nest(); // 2</pre>
<pre class="source-code" lang="en-GB">        n1.setNest(n2); // 3</pre>
<pre class="source-code" lang="en-GB">        n2.setNest(n1); // 4</pre>
<pre class="source-code" lang="en-GB">        n1 = null; // 5</pre>
<pre class="source-code" lang="en-GB">        n2 = null; // 6</pre>
<pre class="source-code" lang="en-GB">    }</pre>
<pre class="source-code" lang="en-GB">}</pre>
<p lang="en-GB" class="calibre4">Let’s have a look at<a id="_idIndexMarker162" class="pcalibre pcalibre2 pcalibre1 calibre6"/> what it would like to count the references and pause after <span lang="">line 4.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer050">
<img alt="Figure 4.7 – Overview after the creation of both Nest objects and assigning them to each other’s field" src="image/Figure_4.7_B18762.jpg" class="calibre58"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Overview after the creation of both Nest objects and assigning them to each other’s field</p>
<p lang="en-GB" class="calibre4">After line 4, both counters are 2. The objects are referenced by both the other object and the stack. This<a id="_idIndexMarker163" class="pcalibre pcalibre2 pcalibre1 calibre6"/> changes after line 5 and 6 since the references to the stack <span lang="">are removed.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer051">
<img alt="Figure 4.8 – Overview after setting the stack references to null" src="image/Figure_4.8_B18762.jpg" class="calibre59"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.8 – Overview after setting the stack references to null</p>
<p lang="en-GB" class="calibre4">As you can tell by the code, after the execution of the line with comment 6 at the end, both objects are unreachable from the stack. However, if we would use the counting of the references, they would both still have a <strong class="source-inline" lang="">1</strong>, since they are both referring to <span lang="">each other.</span></p>
<p lang="en-GB" class="calibre4">Since these objects don’t have a <strong class="source-inline" lang="">0</strong> count but also do not have a connection to the stack. They are islands: islands of isolation. They should be garbage collected, but the simple counting garbage collector cannot detect them because they don’t have a reference count of <strong class="source-inline" lang="">0</strong>. The more advanced garbage collector, which marks all the elements with a connection to the stack that needs to pause the application, does garbage collect them, as they don’t have a connection to <span lang="">the stack.</span></p>
<p lang="en-GB" class="calibre4">Therefore, Java uses the more-accurate marking phase to pause the application. Without the marking garbage collector, islands of isolation would lead to a memory leak: memory that could be released but is never made available for the application to <span lang="">use again.</span></p>
<p lang="en-GB" class="calibre4">Next, let’s talk about how the memory is freed up after <span lang="">being marked.</span></p>
<h1 id="_idParaDest-65" lang="en-GB" class="calibre5"><a id="_idTextAnchor064" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Sweeping by the garbage collector</h1>
<p lang="en-GB" class="calibre4">Once the <a id="_idIndexMarker164" class="pcalibre pcalibre2 pcalibre1 calibre6"/>objects that need to be kept are marked, it’s time to start the next phase to actually free the memory. This deletion of the objects is called sweeping in GC jargon. To make it more interesting, we have three kinds <span lang="">of sweeping:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11"><span lang="">Normal sweeping</span></li>
<li lang="en-GB" class="calibre11">Sweeping <span lang="">with compacting</span></li>
<li lang="en-GB" class="calibre11">Sweeping <span lang="">with copying</span></li>
</ul>
<p lang="en-GB" class="calibre4">We are going to discuss all these in more detail with illustrations to help you understand what’s <span lang="">going on.</span></p>
<h2 id="_idParaDest-66" lang="en-GB" class="calibre7"><a id="_idTextAnchor065" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Normal sweeping</h2>
<p lang="en-GB" class="calibre4">Normal sweeping<a id="_idIndexMarker165" class="pcalibre pcalibre2 pcalibre1 calibre6"/> is the removal of unmarked <a id="_idIndexMarker166" class="pcalibre pcalibre2 pcalibre1 calibre6"/>objects. <span lang=""><em class="italic" lang="">Figure 4</em></span><em class="italic" lang="">.9</em> shows five objects in memory. Two of them, the ones with an <strong class="bold" lang="">x</strong> in them, will <span lang="">be removed.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer052">
<img alt="Figure 4.9 – Schematic overview of memory with marked objects" src="image/Figure_4.9_B18762.jpg" class="calibre60"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.9 – Schematic overview of memory with marked objects</p>
<p lang="en-GB" class="calibre4">The memory blocks are not of equal sizes; some of them are smaller while others are larger. After sweeping the unreachable objects, the memory looks <span lang="">as follows:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer053">
<img alt="Figure 4.10 – Schematic overview of memory after sweeping" src="image/Figure_4.10_B18762.jpg" class="calibre61"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.10 – Schematic overview of memory after sweeping</p>
<p lang="en-GB" class="calibre4">The memory <a id="_idIndexMarker167" class="pcalibre pcalibre2 pcalibre1 calibre6"/>has been freed up by the sweeping and <a id="_idIndexMarker168" class="pcalibre pcalibre2 pcalibre1 calibre6"/>the gaps in between the memory blocks can be allocated again. However, only blocks that fit in between the gaps can be stored there. The memory is now fragmented, and this can lead to problems with storing larger <span lang="">memory blocks.</span></p>
<h3 lang="en-GB" class="calibre8">Fragmentation</h3>
<p lang="en-GB" class="calibre4">Fragmentation <a id="_idIndexMarker169" class="pcalibre pcalibre2 pcalibre1 calibre6"/>of memory happens after storing the memory first and then removing blocks from the middle. In between the memory blocks, new memory can be allocated. This is shown in <span lang=""><em class="italic" lang="">Figure 4</em></span><span lang=""><em class="italic" lang="">.11</em></span><span lang="">.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer054">
<img alt="Figure 4.11 – Allocation of new objects in fragmented memory" src="image/Figure_4.11_B18762.jpg" class="calibre62"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.11 – Allocation of new objects in fragmented memory</p>
<p lang="en-GB" class="calibre4">The new memory blocks are stored in the gaps. This works well in the specific displayed situation, where the memory blocks fit the gaps. If the memory blocks don’t fit in between the gaps (or at the end in this overview), we have a problem. Let’s look at a situation where we want to store a <span lang="">new block.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer055">
<img alt="Figure 4.12 – Attempting to store a large block of memory that is less than the memory available" src="image/Figure_4.12_B18762.jpg" class="calibre63"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.12 – Attempting to store a large block of memory that is less than the memory available</p>
<p lang="en-GB" class="calibre4">If we would<a id="_idIndexMarker170" class="pcalibre pcalibre2 pcalibre1 calibre6"/> look at the total memory available, the block seen in the preceding figure would fit. However, we cannot store it in the fragmented memory as there isn’t enough contiguous memory available to store the <span lang="">new block.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer056">
<img alt="Figure 4.13 – Schematic overview that shows that the new memory block doesn’t fit" src="image/Figure_4.13_B18762.jpg" class="calibre64"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.13 – Schematic overview that shows that the new memory block doesn’t fit</p>
<p lang="en-GB" class="calibre4">Not being able to fit in a block of requested memory would lead to an error: <strong class="source-inline" lang="">OutOfMemoryError</strong>. Even though we are not out of memory and technically there is enough memory available to store the new block, it doesn’t fit because the memory that’s available is fragmented. This is a problem with normal sweeping. It is a very efficient and easy process, but it leads to fragmented memory. This process could be favorable if there<a id="_idIndexMarker171" class="pcalibre pcalibre2 pcalibre1 calibre6"/> is plenty of memory and the application just needs to free up memory fast. When memory is tighter, it is favorable to use one of the other options for sweeping: sweeping with compacting or sweeping with copying. Let’s have a look at sweeping with <span lang="">compacting first.</span></p>
<h2 id="_idParaDest-67" lang="en-GB" class="calibre7"><a id="_idTextAnchor066" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Sweeping with compacting</h2>
<p lang="en-GB" class="calibre4">Sweeping <a id="_idIndexMarker172" class="pcalibre pcalibre2 pcalibre1 calibre6"/>with compacting is a two-step process. Just<a id="_idIndexMarker173" class="pcalibre pcalibre2 pcalibre1 calibre6"/> like in normal sweeping, the memory blocks are deleted. This time, we do not accept the fragmented memory as the end result but execute an extra step called compacting. This moves the blocks of memory to ensure there are no gaps between them. The process is shown in <span lang=""><em class="italic" lang="">Figure 4</em></span><em class="italic" lang="">.14</em>. We assume the same memory blocks are ready for removal, as shown in <span lang=""><em class="italic" lang="">Figure 4</em></span><span lang=""><em class="italic" lang="">.9</em></span><span lang="">.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer057">
<img alt="Figure 4.14 – Sweeping with compacting" src="image/Figure_4.14_B18762.jpg" class="calibre65"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.14 – Sweeping with compacting</p>
<p lang="en-GB" class="calibre4">As you <a id="_idIndexMarker174" class="pcalibre pcalibre2 pcalibre1 calibre6"/>can see, this time we do not end up with fragmented memory. Therefore, we will not get <strong class="source-inline" lang="">OutOfMemoryError</strong>. That sounds amazing, but as always, magic comes at a price. In this case, the price is performance. The<a id="_idIndexMarker175" class="pcalibre pcalibre2 pcalibre1 calibre6"/> compacting of the memory is a costly process in terms of performance, since all the memory blocks need to be moved (and this needs to happen <span lang="">mostly sequentially).</span></p>
<p lang="en-GB" class="calibre4">There is an alternative to this costly compacting process and that’s sweeping with copying. Don’t forget about sweeping with compacting just yet as sweeping with copying comes with its <span lang="">own cost.</span></p>
<h2 id="_idParaDest-68" lang="en-GB" class="calibre7"><a id="_idTextAnchor067" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Sweeping with copying</h2>
<p lang="en-GB" class="calibre4">Sweeping with copying<a id="_idIndexMarker176" class="pcalibre pcalibre2 pcalibre1 calibre6"/> is a clever process. We<a id="_idIndexMarker177" class="pcalibre pcalibre2 pcalibre1 calibre6"/> need two memory regions for this. Instead of deleting the memory blocks we no longer need, we delete all the memory blocks! But not before we’ve copied the ones we still need to the second memory region (refer to <span lang=""><em class="italic" lang="">Figure 4</em></span><span lang=""><em class="italic" lang="">.15</em></span><span lang="">).</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer058">
<img alt="Figure 4.15 – Sweeping with copying before the actual sweeping" src="image/Figure_4.15_B18762.jpg" class="calibre66"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.15 – Sweeping with copying before the actual sweeping</p>
<p lang="en-GB" class="calibre4">First, we <a id="_idIndexMarker178" class="pcalibre pcalibre2 pcalibre1 calibre6"/>have our memory region with the objects<a id="_idIndexMarker179" class="pcalibre pcalibre2 pcalibre1 calibre6"/> that are no longer needed, and then we have a second memory region that is not <span lang="">allocated yet.</span></p>
<p lang="en-GB" class="calibre4">In the next step, we copy all the objects we need to the second <span lang="">memory region.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer059">
<img alt="Figure 4.16 – Sweeping with copying after copying" src="image/Figure_4.16_B18762.jpg" class="calibre67"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.16 – Sweeping with copying after copying</p>
<p lang="en-GB" class="calibre4">So far, we have only copied and not swept anything yet. That’s exactly what the next step is going to<a id="_idIndexMarker180" class="pcalibre pcalibre2 pcalibre1 calibre6"/> do: clear the first memory region, since all the objects we still need are kept in the second memory region. The result is shown in <span lang=""><em class="italic" lang="">Figure 4</em></span><span lang=""><em class="italic" lang="">.17</em></span><span lang="">.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer060">
<img alt="Figure 4.17 – Schematic overview of the memory after sweeping with copying" src="image/Figure_4.17_B18762.jpg" class="calibre68"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.17 – Schematic overview of the memory after sweeping with copying</p>
<p lang="en-GB" class="calibre4">After <a id="_idIndexMarker181" class="pcalibre pcalibre2 pcalibre1 calibre6"/>sweeping the first memory region, we have all our objects that are still reachable in the second memory region. This is better in terms of performance than sweeping with compacting, but as you can imagine, this requires more free memory to <span lang="">be available.</span></p>
<p lang="en-GB" class="calibre4">Which types of sweeping are used depends on the selected implementation of the garbage collector. There are rather many implementations out there. We are going to explore the most common ones in the <span lang="">next section.</span></p>
<h1 id="_idParaDest-69" lang="en-GB" class="calibre5"><a id="_idTextAnchor068" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Exploring GC implementations</h1>
<p lang="en-GB" class="calibre4">The <a id="_idIndexMarker182" class="pcalibre pcalibre2 pcalibre1 calibre6"/>standard JVM has five implementations for GC. Other Java implementations can have other GC implementations, such as the garbage collectors from IBM and Azul. The way these work is relatively easy to grasp after understanding the following five implementations that come with the <span lang="">standard JVM:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11"><span lang="">Serial GC</span></li>
<li lang="en-GB" class="calibre11"><span lang="">Parallel </span><span lang="">GC</span></li>
<li lang="en-GB" class="calibre11">CMS (concurrent mark <span lang="">sweep) GC</span></li>
<li lang="en-GB" class="calibre11"><span lang="">G1 GC</span></li>
<li lang="en-GB" class="calibre11">ZGC (Z <span lang="">garbage collector)</span></li>
</ul>
<p lang="en-GB" class="calibre4">We will <a id="_idIndexMarker183" class="pcalibre pcalibre2 pcalibre1 calibre6"/>examine in detail how these implementations work a little later (however, we will not be discussing all the different command-line options for each of them). But, before we discuss how these specific garbage collectors work, another concept needs to be addressed: the concept of <span lang="">generational GC.</span></p>
<h2 id="_idParaDest-70" lang="en-GB" class="calibre7"><a id="_idTextAnchor069" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Generational GC</h2>
<p lang="en-GB" class="calibre4">If you <a id="_idIndexMarker184" class="pcalibre pcalibre2 pcalibre1 calibre6"/>have a large Java application running, pausing the entire program in order to wait for the garbage collector to have marked every single live object would be a performance nightmare. Luckily, they thought of something cleverer by making use of the different generations on the heap. Not all of the soon-to-be-explained garbage collectors use this strategy, but some of <span lang="">them do.</span></p>
<p lang="en-GB" class="calibre4">Instead of running a full garbage collector round at once, generational garbage collectors focus on a certain part of memory, for example, the young generation. This approach would work well for applications that have most of their objects die young. It saves a lot <span lang="">of marking.</span></p>
<p lang="en-GB" class="calibre4">The generational garbage collectors often work <a id="_idIndexMarker185" class="pcalibre pcalibre2 pcalibre1 calibre6"/>with a <strong class="bold" lang="">remembered set</strong>. This is a set that has all the references from objects to the young generation coming from the old generation. This way, the old generation does not need to be scanned since the references to the young generation are already in the <span lang="">remembered set.</span></p>
<p lang="en-GB" class="calibre4">Applications that have most of their objects in the tenured generation will not thrive with the approach of focusing on the young generation with their GC. Since, in this scenario, the heap is especially heavy on the old generation, only collecting the young generation will not free a high ratio <span lang="">of memory.</span></p>
<p lang="en-GB" class="calibre4">Often generational garbage collectors have to use different strategies for different memory areas. For example, the young generation could be garbage collected with a stop-the-world garbage collector that copies the entire set of reachable objects to the old generation <a id="_idIndexMarker186" class="pcalibre pcalibre2 pcalibre1 calibre6"/>and then deletes the young generation. Meanwhile, the old generation could work with compacting and perhaps an alternative to stop-the-world, such as the CMS garbage collector, which we’ll see while going over the <span lang="">different implementations.</span></p>
<p lang="en-GB" class="calibre4">Now that we have discussed the different options for sweeping and both the stop-the-world and the generational garbage collector, we are in a better position to understand the five implementations that we listed earlier. (So, hold on, you’ve almost made it through this <span lang="">tough chapter!)</span></p>
<h2 id="_idParaDest-71" lang="en-GB" class="calibre7"><a id="_idTextAnchor070" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Serial GC</h2>
<p lang="en-GB" class="calibre4">The <strong class="bold" lang="">serial GC</strong> runs<a id="_idIndexMarker187" class="pcalibre pcalibre2 pcalibre1 calibre6"/> on a <a id="_idIndexMarker188" class="pcalibre pcalibre2 pcalibre1 calibre6"/>single thread and uses the stop-the-world strategy. This means that the application is not running its main tasks when the garbage collector runs. It is the simplest option for <span lang="">garbage collection.</span></p>
<p lang="en-GB" class="calibre4">For the young generation, it uses the mark strategy to identify which objects are eligible for GC and the sweep with copying approach for the actual freeing of the memory. For the old generation, it uses the mark and sweep with <span lang="">compacting approach.</span></p>
<p lang="en-GB" class="calibre4">The serial garbage collector<a id="_idIndexMarker189" class="pcalibre pcalibre2 pcalibre1 calibre6"/> is ideal for<a id="_idIndexMarker190" class="pcalibre pcalibre2 pcalibre1 calibre6"/> small programs, but for larger programs such as <strong class="bold" lang="">Spring</strong> or <strong class="bold" lang="">Quarkus</strong> applications, there are <span lang="">better options.</span></p>
<h2 id="_idParaDest-72" lang="en-GB" class="calibre7"><a id="_idTextAnchor071" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Parallel GC</h2>
<p lang="en-GB" class="calibre4">The <strong class="bold" lang="">parallel garbage collector</strong> is the <a id="_idIndexMarker191" class="pcalibre pcalibre2 pcalibre1 calibre6"/>default garbage collector of Java 8. It uses the mark-and-copy<a id="_idIndexMarker192" class="pcalibre pcalibre2 pcalibre1 calibre6"/> approach for the young generation and the mark-sweep-compact approach for the old generation, just like the serial garbage collector. However, and this might come as a surprise, it does so in parallel. In this case, parallel means that uses multiple threads to clean up the heap space. So, there is not one single thread taking care of the marking, copying, and compacting phases, but multiple threads. Even though it is still stop-the-world, it performs better than the serial garbage collector, since the world needs to be stopped for a shorter amount <span lang="">of time.</span></p>
<p lang="en-GB" class="calibre4">The parallel garbage collector<a id="_idIndexMarker193" class="pcalibre pcalibre2 pcalibre1 calibre6"/> will work well on machines with multiple cores. On (rarer) single-core machines, the serial garbage collector is probably a better choice, due to the costs of managing multiple threads and not really parallel processing on the <span lang="">single core.</span></p>
<h2 id="_idParaDest-73" lang="en-GB" class="calibre7"><a id="_idTextAnchor072" class="pcalibre pcalibre2 pcalibre1 calibre6"/>CMS GC</h2>
<p lang="en-GB" class="calibre4">The <strong class="bold" lang="">Concurrent Mark Sweep Garbage Collector</strong> (<strong class="bold" lang="">CMS GC</strong>) has <a id="_idIndexMarker194" class="pcalibre pcalibre2 pcalibre1 calibre6"/>an improved mark-and-sweep algorithm. It <a id="_idIndexMarker195" class="pcalibre pcalibre2 pcalibre1 calibre6"/>manages to do this with multiple threads and reduces the pause time drastically. This is the main difference between CMS GC and parallel <span lang="">garbage collector.</span></p>
<p lang="en-GB" class="calibre4">Not all systems can handle sharing resources between the main application and the garbage collector, though, but if they can, it is a great upgrade in terms of performance compared to the parallel <span lang="">garbage collector.</span></p>
<p lang="en-GB" class="calibre4">The CMS GC is a generational garbage collector as well. It has separate cycles for the young and old generation. For the young generation, it uses mark and copy with stop-the-world. So, during the GC of the young generation, the main application threads <span lang="">are paused.</span></p>
<p lang="en-GB" class="calibre4">The old generation is garbage collected with <em class="italic" lang="">mostly concurrent</em> mark and sweep. The term mostly concurrent means that it does most of the GC concurrently, but it will still use stop-the-world twice in a GC cycle. It pauses all the main application threads for the first time at the very beginning, then during the marking for a very short time, and then for a (usually) somewhat longer time around the middle of the GC cycle to do the <span lang="">final marking.</span></p>
<p lang="en-GB" class="calibre4">These pauses are typically very short, because the CMS GC attempts to collect enough of the old generation while running concurrently to the main application threads and, this way, prevent it from getting full. Sometimes, this is not possible. If the CMS GC cannot free up enough while the old generation is getting full, or the application fails to allocate an object, the CMS GC pauses all the application threads and the main focus shifts to GC. The situation in which this garbage collector fails to do the GC mostly concurrently<a id="_idIndexMarker196" class="pcalibre pcalibre2 pcalibre1 calibre6"/> is called <em class="italic" lang="">concurrent </em><span lang=""><em class="italic" lang="">mode failure</em></span><span lang="">.</span></p>
<p lang="en-GB" class="calibre4">If the collector then still cannot free up enough memory, <strong class="source-inline" lang="">OutOfMemoryError</strong> gets thrown. This happens when 98% of the application time is spent on GC and less than 2% of the heap <span lang="">is recovered.</span></p>
<p lang="en-GB" class="calibre4">This is not a <a id="_idIndexMarker197" class="pcalibre pcalibre2 pcalibre1 calibre6"/>lot different from the other garbage collectors that we’ve discussed. The very short pauses of the CMS GC sound pretty good already, but there are even later upgrades available. Let’s have a look at the <span lang="">G1 GC.</span></p>
<h2 id="_idParaDest-74" lang="en-GB" class="calibre7"><a id="_idTextAnchor073" class="pcalibre pcalibre2 pcalibre1 calibre6"/>G1 GC</h2>
<p lang="en-GB" class="calibre4">The <strong class="bold" lang="">G1</strong> (<strong class="bold" lang="">garbage-first</strong>) garbage <a id="_idIndexMarker198" class="pcalibre pcalibre2 pcalibre1 calibre6"/>collector <a id="_idIndexMarker199" class="pcalibre pcalibre2 pcalibre1 calibre6"/>came with Java 7 (minor version 4) and is an upgrade of the CMS GC. It combines different algorithms in a clever way. The G1 collector is parallel, concurrent, and aims for short pauses of the application. It employs a technique called <span lang="">incrementally compacting.</span></p>
<p lang="en-GB" class="calibre4">The G1 garbage collector divides the heap into smaller regions: much smaller than the generational garbage collector. It works with these smaller memory segments to mark and sweep them. It keeps track of the amount of reachable and unreachable objects per memory region. The regions with the most unreachable objects are garbage collected first since that frees up the most memory. That’s why it is called the garbage-first garbage collector. Regions with the most garbage are <span lang="">collected first.</span></p>
<p lang="en-GB" class="calibre4">It does all this while copying objects from one region to another region. This will result in freeing up the first region completely. This way the G1 GC kills two birds with one stone: achieving GC and compacting at the same time. This is why it is such an upgrade compared to earlier mentioned <span lang="">garbage collector.</span></p>
<p lang="en-GB" class="calibre4">The G1 GC is a great garbage collector. You may wonder whether this garbage collector manages to work without stop-the-world. No, the compacting still needs to happen this way. But due to the smaller regions, the pauses are <span lang="">much shorter.</span></p>
<p lang="en-GB" class="calibre4">Another new feature of the G1 GC garbage collector is <em class="italic" lang="">string deduplication</em>. This is literally what you’d think it is: the garbage collector runs a process to inspect the <strong class="source-inline" lang="">String</strong> objects. When it finds <strong class="source-inline" lang="">String</strong> objects that contain the same content but refer to different <strong class="source-inline" lang="">char</strong> arrays on the heap, they will be updated to both point to the same <strong class="source-inline" lang="">char</strong> array. This makes the other <strong class="source-inline" lang="">char</strong> array eligible for GC and this way, the memory usage is optimized. As if this wasn’t exciting enough, it happens completely concurrently! This option will need to be enabled using the following <span lang="">command: </span><span lang=""><strong class="source-inline" lang="">-XX:+UseStringDeduplication</strong></span><span lang="">.</span></p>
<p lang="en-GB" class="calibre4">Just like<a id="_idIndexMarker200" class="pcalibre pcalibre2 pcalibre1 calibre6"/> the CMS GC, the G1 GC tries to do a lot of the GC concurrently. So, the application threads don’t need to be paused most of the time. However, if the G1 GC cannot free up enough memory and the application is allocating more than can be freed up concurrently, the application threads need to <span lang="">be paused.</span></p>
<p lang="en-GB" class="calibre4">The G1 garbage collector <a id="_idIndexMarker201" class="pcalibre pcalibre2 pcalibre1 calibre6"/>is the go-to GC for powerful systems that are high performing and have a large memory space. This is not the most recently added garbage collector though. Let’s have a look at <span lang="">the ZGC.</span></p>
<h2 id="_idParaDest-75" lang="en-GB" class="calibre7"><a id="_idTextAnchor074" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Z GC</h2>
<p lang="en-GB" class="calibre4">Java 15 gave us yet <a id="_idIndexMarker202" class="pcalibre pcalibre2 pcalibre1 calibre6"/>another production-ready implementation of the garbage collector, the <strong class="bold" lang="">Z garbage collector</strong> (<strong class="bold" lang="">ZGC</strong>). It <a id="_idIndexMarker203" class="pcalibre pcalibre2 pcalibre1 calibre6"/>does all the garbage collecting concurrently and does not need to pause the application for more than 10 ms <span lang="">per pause.</span></p>
<p lang="en-GB" class="calibre4">It manages to do this by starting with marking the live objects. It doesn’t keep a map but uses <strong class="bold" lang="">reference coloring</strong>. Reference coloring<a id="_idIndexMarker204" class="pcalibre pcalibre2 pcalibre1 calibre6"/> means that the live state of reference is stored as the bits that are part of the reference. This requires some extra bits, which is why the ZGC only works on 64-bit systems and not on <span lang="">32-bit systems.</span></p>
<p lang="en-GB" class="calibre4">Fragmentation is avoided by using relocation. This process happens in parallel with the application in order to avoid pauses of more than 10 ms, but this happens while the application is <span lang="">being executed.</span></p>
<p lang="en-GB" class="calibre4">Without extra measurements, this could lead to unpleasant surprises. Imagine that we were trying to access a certain object with the reference, but while doing so, it got relocated and has a new reference. The old memory location could be overwritten or cleared already. In such a scenario, debugging would be <span lang="">a nightmare.</span></p>
<p lang="en-GB" class="calibre4">Of course, the Java team would not push a garbage collector to production with issues like that. They introduced load barriers to deal with this. The load barriers run whenever a reference from the heap is loaded. It checks the metadata bits of the reference and, based on the result, it may or may not do some processing before retrieving the result. This magic is <span lang="">called remapping.</span></p>
<p lang="en-GB" class="calibre4">The five <a id="_idIndexMarker205" class="pcalibre pcalibre2 pcalibre1 calibre6"/>garbage <a id="_idIndexMarker206" class="pcalibre pcalibre2 pcalibre1 calibre6"/>collectors we’ve just discussed are the main options to choose from at the moment of <a id="_idIndexMarker207" class="pcalibre pcalibre2 pcalibre1 calibre6"/>writing this book. Your options depend on the Java version that you’re using, the system configuration, and the type of application. In order to make sure the garbage collector performs well, monitoring should be in place. This is exactly what we’re going to look at in the <span lang="">next section.</span></p>
<h1 id="_idParaDest-76" lang="en-GB" class="calibre5"><a id="_idTextAnchor075" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Monitoring GC</h1>
<p lang="en-GB" class="calibre4">In order to decide <a id="_idIndexMarker208" class="pcalibre pcalibre2 pcalibre1 calibre6"/>upon the right garbage collector, you’ll need to know your application. There are a few metrics that are especially<a id="_idIndexMarker209" class="pcalibre pcalibre2 pcalibre1 calibre6"/> important for <span lang="">the GC:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">Allocation rate</strong>: How <a id="_idIndexMarker210" class="pcalibre pcalibre2 pcalibre1 calibre6"/>fast the application allocates objects <span lang="">in memory.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">Heap population</strong>: The<a id="_idIndexMarker211" class="pcalibre pcalibre2 pcalibre1 calibre6"/> number of objects and their size living on <span lang="">the heap.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">Mutation rate</strong>: How<a id="_idIndexMarker212" class="pcalibre pcalibre2 pcalibre1 calibre6"/> often references are updated <span lang="">in memory.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">Average object live time</strong>: The<a id="_idIndexMarker213" class="pcalibre pcalibre2 pcalibre1 calibre6"/> time the objects live on average. One application may have objects that die young, while another application may have objects that <span lang="">live longer.</span></li>
</ul>
<p lang="en-GB" class="calibre4">The monitoring of the performance of the GC requires different metrics. The most important ones are mark time, compaction time, and GC cycle time. The mark time entails the time it takes the garbage collector to find all the live objects on the heap. Compaction time is how long it takes the garbage collector to free up all the space and relocate the objects. The GC cycle time is how long it takes the garbage collector to perform a <span lang="">full GC.</span></p>
<p lang="en-GB" class="calibre4">Whenever there is little heap space available, you’ll see the CPU usage for GC increase. Choosing the right amount of memory will improve the performance of your application. The greater the amount of available memory, the easier the garbage collector <span lang="">can function.</span></p>
<p lang="en-GB" class="calibre4">The <a id="_idIndexMarker214" class="pcalibre pcalibre2 pcalibre1 calibre6"/>copy-and-compact collector<a id="_idIndexMarker215" class="pcalibre pcalibre2 pcalibre1 calibre6"/> needs to have enough space available for copying and relocating. This is a much more costly process when available memory is limited. Only a small memory segment could be copied to free up a bit more so that hopefully a bit more can be copied next time, and so on. The CPU usage of the garbage collector is the highest on low memory. On the other end of the spectrum, in the hypothetical situation that we would have unlimited memory, we wouldn’t really need to garbage collect <span lang="">at all.</span></p>
<p lang="en-GB" class="calibre4">In <a href="B18762_06.xhtml#_idTextAnchor086" class="pcalibre pcalibre2 pcalibre1 calibre6"><span lang=""><em class="italic" lang="">Chapter 6</em></span></a>, we’re going to have a look at the usage of JVM tuning for memory management to improve the functioning of the JVM memory. There, we’ll also see how we can tune a <span lang="">garbage collector.</span></p>
<h1 id="_idParaDest-77" lang="en-GB" class="calibre5"><a id="_idTextAnchor076" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Summary</h1>
<p lang="en-GB" class="calibre4">In this chapter, we have seen how the GC of the heap works in more depth. Objects on the heap are eligible for GC when they don’t have a connection to the stack anymore, whether directly <span lang="">or indirectly.</span></p>
<p lang="en-GB" class="calibre4">The garbage collector determines which objects are eligible for GC in the marking phase. Objects that have a connection to the stack are marked. The objects that are eligible for GC <span lang="">are unmarked.</span></p>
<p lang="en-GB" class="calibre4">After this marking phase, the actual removal happens in the sweeping phase. We discussed three kinds of sweeping, normal sweeping, sweeping with compacting, and sweeping <span lang="">with copying.</span></p>
<p lang="en-GB" class="calibre4">Then, we discussed the different implementations of the garbage collectors. A subset of them are the generational garbage collectors. These garbage collectors focus on one of the generations of the heap and, consequently, do not need to scan all the objects of the heap during the marking phase. After that, we discussed five common implementations of the <span lang="">garbage collector.</span></p>
<p lang="en-GB" class="calibre4">In the next chapter, we’re going to zoom in on <span lang="">the Metaspace.</span></p>
</div>
<div class="calibre2">
<div id="_idContainer062" class="calibre2">
</div>
</div>
</div></body></html>