- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a RESTful Web Service with Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Web services are applications that communicate over the internet using the
    HTTP protocol. There are many different types of web service architectures, but
    the principal idea across all designs is the same. In this book, we will create
    a RESTful web service: nowadays, a really popular design.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will first create a **RESTful web service** using a controller
    class. Then, we will use **Spring Data REST** to create a RESTful web service
    that also provides all CRUD functionalities automatically, and document it with
    **OpenAPI 3**. After you have created a RESTful API for your application, you
    can implement the frontend using a JavaScript library such as React. We will be
    using the database application that we created in the previous chapter as a starting
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basics of REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a RESTful web service with Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Spring Data REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting a RESTful API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Boot application created in the previous chapters is required.
  prefs: []
  type: TYPE_NORMAL
- en: You will also need Postman, cURL, or another suitable tool for transferring
    data using various HTTP methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following GitHub link will be required: [https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter04).'
  prefs: []
  type: TYPE_NORMAL
- en: Basics of REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Representational State Transfer** (**REST**) is an architectural style for
    creating web services. REST is neither language- nor platform-dependent; different
    clients like mobile apps, browsers, and other services can communicate with each
    other. RESTful services can be scaled easily to fulfill increased demand.'
  prefs: []
  type: TYPE_NORMAL
- en: 'REST is not a standard but a set of constraints, defined by Roy Fielding. The
    constraints are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stateless**: The server shouldn’t hold any information about the client state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client-server independence**: The client and server should act independently.
    The server should not send any information without a request from the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cacheable**: Many clients often request the same resources; therefore, caching
    should be applied to resources in order to improve performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uniform interface**: Requests from different clients should look the same.
    Clients may include, for example, a browser, a Java application, and a mobile
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layered system**: Components can be added or modified without affecting the
    entire service. This constraint affects scalability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code on demand**: This is an optional constraint. Most of the time, the server
    sends static content in the form of JSON or XML. This constraint allows the server
    to send executable code if needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The uniform interface constraint is important, and it means that every REST
    architecture should have the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identification of resources**: Resources should be identified by unique identifiers,
    for example, URIs in web-based REST services. REST resources should expose easily
    understood directory structure URIs. Therefore, a good resource-naming strategy
    is very important.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource manipulation through representation**: When making a request to
    a resource, the server should respond with a representation of the resource. Typically,
    the format of the representation is JSON or XML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self-descriptive messages**: Messages should contain enough information that
    the server knows how to process them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hypermedia as the Engine of Application State** (**HATEOAS**): Responses
    should contain links to other areas of the service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The RESTful web service that we are going to develop in the next sections follows
    the REST architectural principles above.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a RESTful web service with Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Spring Boot, all HTTP requests are handled by **controller classes**. To
    be able to create a RESTful web service, first, we have to create a controller
    class. We will create our own Java package for the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Activate the root package in the Eclipse **Project Explorer** and right-click.
    Select **New | Package** from the menu. We will name our new package `com.packt.cardatabase.web`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: New Java package'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create a new `controller` class in a new web package. Activate
    the `com.packt.cardatabase.web` package in the Eclipse **Project Explorer**. Right-click
    and select **New | Class** from the menu; we will name our class `CarController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: New Java class'
  prefs: []
  type: TYPE_NORMAL
- en: Now, your project structure should look like the following screenshot:![](img/B19818_04_03.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.3: Project structure'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you create classes in the wrong package accidentally, you can drag and drop
    the files between packages in the Project Explorer. Sometimes, the Project Explorer
    view might not be rendered correctly when you make some changes. Refreshing the
    Project Explorer helps (activate the Project Explorer and press *F5*).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open your controller class in the editor window and add the `@RestController`
    annotation before the class definition. Refer to the following source code. The
    `@RestController` annotation identifies that this class will be the controller
    for the RESTful web service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we add a new method inside our controller class. The method is annotated
    with the `@GetMapping` annotation, which defines the endpoint that the method
    is mapped to. In the following code snippet, you can see the sample source code.
    In this example, when a user makes a `GET` request to the `/cars` endpoint, the
    `getCars()` method is executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `getCars()` method returns all the car objects, which are then marshaled
    to JSON objects automatically by the **Jackson** library (https://github.com/FasterXML/jackson).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, the `getCars()` method handles only `GET` requests from the `/cars` endpoint
    because we are using the `@GetMapping` annotation. There are other annotations
    for the different HTTP methods, such as `@GetMapping`, `@PostMapping`, `@DeleteMapping`,
    and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To be able to return cars from the database, we have to inject `CarRepository`
    into the controller. Then, we can use the `findAll()` method that the repository
    provides to fetch all cars. Due to the `@RestController` annotation, the data
    is now serialized to JSON format in the response. The following source code shows
    the controller code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we are ready to run our application and navigate to `localhost:8080/cars`.
    We can see that there is something wrong, and the application seems to be in an
    infinite loop. This happens on account of our one-to-many relationship between
    the car and owner tables. So, what happens in practice? First, the car is serialized,
    and it contains an owner who is then serialized, and that, in turn, contains cars
    that are then serialized, and so on. There are different solutions for avoiding
    this. One way is to use the `@JsonIgnore` annotation on the `cars` field in the
    `Owner` class, which ignores the `cars` field in the serialization process. You
    can also solve this by avoiding bidirectional mapping if it is not needed. We
    will also use the `@JsonIgnoreProperties` annotation to ignore fields that are
    generated by Hibernate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, when you run the application and navigate to `localhost:8080/cars`, everything
    should go as expected and you will get all the cars from the database in JSON
    format, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_04_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: GET request to http://localhost:8080/cars'
  prefs: []
  type: TYPE_NORMAL
- en: Your output might differ from the screenshot due to browser differences. In
    this book, we are using the Chrome browser and the **JSON Viewer** extension,
    which makes JSON output more readable. JSON Viewer can be downloaded from the
    Chrome Web Store for free.
  prefs: []
  type: TYPE_NORMAL
- en: We have written our first RESTful web service. By leveraging the capabilities
    of Spring Boot, we were able to quickly implement a service that returns all the
    cars in our database. However, this is just the beginning of what Spring Boot
    has to offer for creating robust and efficient RESTful web services, and we will
    continue to explore its capabilities in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring Data REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Spring Data REST** (https://spring.io/projects/spring-data-rest) is part
    of the Spring Data project. It offers an easy and fast way to implement RESTful
    web services with Spring. Spring Data REST provides **HATEOAS** (**Hypermedia
    as the Engine of Application State**) support, an architectural principle that
    allows clients to navigate the REST API dynamically using hypermedia links. Spring
    Data REST also provides events that you can use to customize the business logic
    of your REST API endpoints.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about events in the Spring Data REST documentation: https://docs.spring.io/spring-data/rest/docs/current/reference/html/#events.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using Spring Data REST, you have to add the following dependency to
    the `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Refresh your Gradle project from Eclipse after you have modified the `build.gradle`
    file. Select the project in Eclipse’s Project Explorer and right-click to open
    the context menu. Then, select **Gradle | Refresh Gradle Project**.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Spring Data REST finds all public repositories from the application
    and creates RESTful web services for your entities automatically. In our case,
    we have two repositories: `CarRepository` and `OwnerRepository`; therefore, Spring
    Data REST creates RESTful web services automatically for those repositories.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define the endpoint of the service in your `application.properties`
    file as follows. You might need to restart your application for the changes to
    take effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can access the RESTful web service from the `localhost:8080/api` endpoint.
    By calling the root endpoint of the service, it returns the resources that are
    available. Spring Data REST returns JSON data in the **Hypertext Application Language**
    (**HAL**) format. The HAL format provides a set of conventions for expressing
    hyperlinks in JSON and it makes your RESTful web service easier to use for frontend
    developers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_04_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Spring Boot Data REST resources'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that there are links to the car and owner entity services. The Spring
    Data REST service path name is derived from the entity class name. The name will
    then be pluralized and uncapitalized. For example, the entity `Car` service path
    name will become `cars`. The `profile` link is generated by Spring Data REST and
    contains application-specific metadata. If you want to use different path naming,
    you can use the `@RepositoryRestResource` annotation in your repository class,
    as shown in the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you call the endpoint `localhost:8080/api`, you can see that the endpoint
    has been changed from `/cars` to `/vehicles`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_04_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Spring Boot Data REST resources'
  prefs: []
  type: TYPE_NORMAL
- en: You can remove the different naming, and we will continue with the default endpoint
    name, `/cars`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we’ll start to examine different services more carefully. There are multiple
    tools available for testing and consuming RESTful web services. In this book,
    we are using the **Postman** (https://www.postman.com/downloads/) desktop app,
    but you can use tools that you are familiar with, such as **cURL**. Postman can
    be acquired as a desktop application or as a browser plugin. cURL is also available
    for Windows by using Windows Ubuntu Bash (**Windows Subsystem for Linux**, **WSL**).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you make a request to the `/cars` endpoint (`http://localhost:8080/api/cars`)
    using the `GET` method (note: you can use a web browser for `GET` requests), you
    will get a list of all the cars, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_04_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Fetch cars'
  prefs: []
  type: TYPE_NORMAL
- en: In the JSON response, you can see that there is an array of cars, and each car
    contains car-specific data. All the cars also have the `_links` attribute, which
    is a collection of links, and with these links, you can access the car itself
    or get the owner of the car. To access one specific car, the path will be `http://localhost:8080/api/cars/{id}`.
  prefs: []
  type: TYPE_NORMAL
- en: The `GET` request to `http://localhost:8080/api/cars/3/owner` returns the owner
    of the car with `id` 3\. The response now contains owner data, a link to the owner,
    and links to the owner’s other cars.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Spring Data REST service provides all CRUD operations. The following table
    shows which HTTP methods you can use for different CRUD operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP method** | **CRUD** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Read |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Create |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT/PATCH` | Update |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Delete |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4.1: Spring Data REST operations'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at how to delete a car from the database by using our RESTful
    web service. In a delete operation, you have to use the `DELETE` method and the
    link to the car that will be deleted (`http://localhost:8080/api/cars/{id}`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how you can delete one car with `id` 3 by using
    the Postman desktop app. In Postman, you have to select the correct HTTP method
    from the drop-down list, enter the request URL, and then click the **Send** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_04_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: DELETE request to delete car'
  prefs: []
  type: TYPE_NORMAL
- en: If everything goes correctly, you will see the response status **200 OK** in
    Postman. After the successful `DELETE` request, you will also see that there are
    now two cars left in the database if you make a `GET` request to the `http://localhost:8080/api/cars/`
    endpoint. If you got the **404 Not Found** status in the `DELETE` response, check
    that you are using a car ID that exists in the database.
  prefs: []
  type: TYPE_NORMAL
- en: When we want to add a new car to the database, we have to use the `POST` method,
    and the request URL is `http://localhost:8080/api/cars`. The header must contain
    the `Content-Type` field with the value `application/json`, and the new car object
    will be embedded in the request body in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is one car example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you click the **Body** tab and select **raw** in Postman, you can type a
    new car JSON string under the **Body** tab. Also select JSON from the drop-down
    list, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_04_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: POST request to add a new car'
  prefs: []
  type: TYPE_NORMAL
- en: 'You also have to set a header by clicking the **Headers** tab in Postman, as
    shown in the following screenshot. Postman adds some headers automatically based
    on your request selections. Check that the `Content-Type` header is in the list
    and the value is correct (`application/json`). If it doesn’t exist, you should
    add it manually. Automatically added headers might be hidden by default, but you
    can see these by clicking the **hidden** button. Finally, you can press the **Send**
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_04_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: POST request headers'
  prefs: []
  type: TYPE_NORMAL
- en: The response will send a newly created `car` object back and the status of the
    response will be **201 Created** if everything went correctly. Now, if you make
    a `GET` request again to the `http://localhost:8080/api/cars` path, you will see
    that the new car exists in the database.
  prefs: []
  type: TYPE_NORMAL
- en: To update entities, we can use the `PATCH` method and the link to the car that
    we want to update (`http://localhost:8080/api/cars/{id}`). The header must contain
    the `Content-Type` field with the value `application/json`, and the `car` object
    with edited data will be given inside the request body.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using `PATCH`, you have to send only fields that are updated. If
    you are using `PUT`, you have to include all fields in the request body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s edit the car that we created in the previous example, changing the color
    to white. We are using `PATCH`, so the payload contains only the `color` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The Postman request is shown in the following screenshot (note: we set the
    header as in the `POST` example and use the car `id` in the URL):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_04_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: PATCH request to update existing car'
  prefs: []
  type: TYPE_NORMAL
- en: If the update succeeded, the response status is **200 OK**. If you now fetch
    the updated car using a `GET` request, you will see that the color has been updated.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will add an owner to the new car that we just created. We can use the
    `PUT` method and the `http://localhost:8080/api/cars/{id}/owner` path. In this
    example, the ID of the new car is `4`, so the link is `http://localhost:8080/api/cars/4/owner`.
    The content of the body is now linked to an owner, for example, `http://localhost:8080/api/owners/1`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_04_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: PUT request to update owner'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Content-Type` value of the headers should be `text/uri-list` in this case.
    If you can’t modify the automatically added header, you can disable it by unchecking
    it. Then, add a new one, like shown in the next image, and press the **Send**
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_04_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.13: PUT request headers'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can make a `GET` request for the car’s owner, and you should now
    see that the owner is linked to the car.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we created queries for our repository. These queries
    can also be included in our service. To include queries, you have to add the `@RepositoryRestResource`
    annotation to the repository class. Query parameters are annotated with the `@Param`
    annotation. The following source code shows `CarRepository` with these annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you make a `GET` request to the `http://localhost:8080/api/cars`
    path, you can see that there is a new endpoint called `/search`. Calling the `http://localhost:8080/api/cars/search`
    path returns the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_04_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.14: REST queries'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the response, you can see that both queries are now available in our service.
    The following URL demonstrates how to fetch cars by brand: `http://localhost:8080/api/cars/search/findByBrand?brand=Ford`.
    The output will only contain cars with the brand Ford.'
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we introduced the REST principles, and we
    can see that our RESTful API fulfills several aspects of the REST specification.
    It is stateless and requests from different clients look the same (uniform interface).
    The response contains links that can be used to navigate between related resources.
    Our RESTful API provides a URI structure that reflects the data model and relationship
    between resources.
  prefs: []
  type: TYPE_NORMAL
- en: We have now created the RESTful API for our backend, and we will consume it
    later with our React frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting a RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A RESTful API should be properly documented so that developers who are consuming
    it understand its functionality and behavior. The documentation should include
    what endpoints are available, what data formats are accepted, and how to interact
    with the API.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will use the **OpenAPI 3** library for Spring Boot (https://springdoc.org)
    to generate documentation automatically. The **OpenAPI Specification** (formerly
    Swagger Specification) is an API description format for RESTful APIs. There are
    other alternatives, such as RAML (https://raml.org/), that can be used as well.
    You can also document your REST API using some other documentation tools, which
    provide flexibility but require more manual work. The use of the OpenAPI library
    automates this work, allowing you to focus on development.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps demonstrate how you can generate documentation for your
    RESTful API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to add the OpenAPI library to our Spring Boot application. Add
    the following dependency to your `build.gradle` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create a configuration class for our documentation. Create a new class
    called `OpenApiConfig` in the `com.packt.cardatabase` package of your application.
    Below is the code for the configuration class where we can configure, for example,
    the REST API title, description, and version. We can use the `info()` method to
    define these values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `application.properties` file, we can define the path for our documentation.
    We can also enable **Swagger UI,** a user-friendly tool for visualizing RESTful
    APIs that are documented using the OpenAPI Specification (https://swagger.io/tools/swagger-ui/).
    Add the following settings to your `application.properties` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we are ready to run our project. When your application is running, navigate
    to `http://localhost:8080/swagger-ui.html` and you will see the documentation
    in Swagger UI, as shown in the following screenshot:![](img/B19818_04_15.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.15: Car RESTful API documentation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can see all the endpoints that are available in your RESTful API. If you
    open any of the endpoints, you can even try them out by pressing the **Try it
    out** button. The documentation is also available in JSON format at `http://localhost:8080/api-docs`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that you have provided documentation for your RESTful API, it is much easier
    for developers to consume it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will secure our RESTful API, which will break access
    to Swagger UI. You can allow access again by modifying your security configuration
    (allow the `"/api-docs/**"` and `"/swagger-ui/**"` paths). You can also use Spring
    Profiles, but that is out of scope for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a RESTful web service with Spring Boot. First, we
    created a controller and one method that returns all cars in JSON format. Next,
    we used Spring Data REST to get a fully functional web service with all CRUD functionalities.
    We covered different types of requests that are needed to use the CRUD functionalities
    of the service that we created. We also included our queries in the RESTful web
    service. Finally, we learned how to document our API properly with OpenAPI 3.
  prefs: []
  type: TYPE_NORMAL
- en: We will use this RESTful web service with our frontend later in this book, and
    now you can also easily implement a REST API for your own needs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will secure our backend using Spring Security. We will
    learn how to secure our data by implementing authentication. Then, only authenticated
    users will be able to access the RESTful API’s resources.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is REST?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you create a RESTful web service with Spring Boot?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you fetch items using our RESTful web service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you delete items using our RESTful web service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you add items using our RESTful web service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you update items using our RESTful web service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you use queries with our RESTful web service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the OpenAPI Specification?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Swagger UI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Packt has other resources available for learning about Spring Boot RESTful
    web services:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Postman Tutorial: Getting Started with API Testing [Video]* by Praveenkumar
    Bouna ([https://www.packtpub.com/product/postman-tutorial-getting-started-with-api-testing-video/9781803243351](https://www.packtpub.com/product/postman-tutorial-getting-started-with-api-testing-video/9781803243351))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hands-On RESTful API Design Patterns and Best Practices* by Harihara Subramanian
    J and Pethuru Raj ([https://www.packtpub.com/product/hands-on-restful-api-design-patterns-and-best-practices/9781788992664](https://www.packtpub.com/product/hands-on-restful-api-design-patterns-and-best-practices/9781788992664))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask the author questions, and learn about new releases – follow the QR code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code10796108009382640.png)'
  prefs: []
  type: TYPE_IMG
