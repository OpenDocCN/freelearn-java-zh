- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: String Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an effort to analyze every aspect of our Java applications to ensure that
    they perform at a highly efficient rate, we need to consider string objects. Strings
    are a big part of Java applications and are used for limitless purposes from a
    simple list of names to complex data storage needs, such as with a bank’s databases.
    The creation, manipulation, and management of these objects should be a primary
    concern.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focuses on the efficient use of string objects in our Java applications.
    The first concept is proper string pooling. We will examine this concept and explore
    best practices for using string pooling for high performance. The chapter also
    introduces the concept of lazy initialization, examines its benefits, and illustrates
    implementation with sample code. Lastly, we will look at additional string operation
    strategies, to include advanced string manipulation techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Proper string pooling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional string operation strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the examples and instructions in this chapter, you will need the ability
    to load, edit, and run Java code. If you have not set up your development environment,
    please refer back to [*Chapter 1*](B21942_01.xhtml#_idTextAnchor014).
  prefs: []
  type: TYPE_NORMAL
- en: 'The finished code for this chapter can be found here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter07](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter07).'
  prefs: []
  type: TYPE_NORMAL
- en: Proper string pooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our overarching concern is to ensure that our Java applications perform at a
    high level. To that end, memory management is a critical concern. It is important
    that we design, test, and implement techniques for optimizing memory usage. **String
    pooling** is one such technique, whose focus is to enable the reuse of string
    objects for greater application efficiency. The efficiency gains stem from reducing
    memory overhead.
  prefs: []
  type: TYPE_NORMAL
- en: String pooling is an important concept that is anchored to the sharing of string
    values as an alternative to creating new string instances. If your application
    uses string literals frequently, then you should find string pooling especially
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: String literal
  prefs: []
  type: TYPE_NORMAL
- en: 'A string literal is a fixed value bookended by double quotes. For example,
    the `"Read more books."` component of the following statement is a string literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.out.println("Read` `more books.");`'
  prefs: []
  type: TYPE_NORMAL
- en: To examine string pooling, we will start with the concept of **string interning**,
    then review best practices, and complete our discovery with code examples using
    Java. To take this concept one step further, we will look at string pooling for
    database queries.
  prefs: []
  type: TYPE_NORMAL
- en: String interning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: String interning is an interesting concept. It is a memory reduction technique
    that allows more than one string to use the same memory location. As you might
    expect, the contents of those strings must be identical for this to work. Memory
    reduction is possible because we can eliminate duplicate objects. String interning
    relies on string pooling for this to work. As we covered in [*Chapter 4*](B21942_04.xhtml#_idTextAnchor074),
    pooling uses a special heap area to store the string literals.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try to think like the `intern()` method, part of the `String` class, to
    accomplish this. We will look at an example later in the *Code examples* section
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In general, it is considered a good idea to employ string interning in our applications.
    When implementing string interning, there are two important considerations to
    be aware of. First, we should not overuse string interning. The performance and
    memory usage benefits are clear, but if our applications use interning on very
    large strings, then we might consume more memory than we want to.
  prefs: []
  type: TYPE_NORMAL
- en: Another best practice to consider is avoiding `intern()` method. This way, we
    can ensure consistent behavior in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Code examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at a simple example to demonstrate string interning. The following
    code starts by defining two string literals, `s1` and `s2`. Both strings have
    the same values. A third string, `s3`, is created using the `intern()` method.
    The final two statements are used to compare references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from our application’s output, both reference comparisons are
    evaluated as `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: String pooling for database queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQL and other database queries are often created dynamically in our code and
    can become quite complex. As with other large strings, we can use string pooling
    to help ensure that our application does not unnecessarily create string objects.
    Our goal is to reuse any commonly used database queries instead of recreating
    them multiple times at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The decision to not instantiate an object until it is needed is called **lazy
    initialization**. The word *lazy* normally has a negative connotation; however,
    in the context of software development, lazy initialization is a performance optimization
    approach with the goal of managing an application’s overhead. This design pattern
    is especially useful when detailing very large objects.
  prefs: []
  type: TYPE_NORMAL
- en: Should I implement lazy initialization?
  prefs: []
  type: TYPE_NORMAL
- en: If you have string objects that are large or complex and require significant
    overhead at initialization time, then you should consider lazy initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy initialization does not reduce the number of string objects created; rather,
    it delays the initialization until it is required by your application for processing.
    This delaying technique can help you with memory optimization. Let us look at
    a narrative example before we examine the source code.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you have a legacy application that uses very sophisticated string objects.
    When your application opens, a loading screen is displayed and, behind the scenes,
    the application creates several string objects to support the application’s normal
    operations. Users have complained that the application “takes forever to load”
    and that the computer often locks up when trying to launch the application. After
    reviewing the source code, you realize that many of the string objects created
    when the application is launched are only used by the application when the user
    selects certain functions. Your solution is to implement lazy initialization,
    so these string objects are only created when and if they are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Code examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let us look at how we can implement the lazy initialization design pattern
    in Java. We will start by importing `java.util.function.Supplier`. It is an interface
    that provides a single `get()` method, which we will use to retrieve a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we declare our class and use `StringBuilder` to generate a complex string
    using the `append()` method multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Staying inside the `LazyInitializationExample` class, we make a call to the
    `getLazyString()` method. This method is used to create or retrieve the complex
    string only when it is needed – not before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of our code is the `main()` method. When this method is run,
    we access the lazily initialized string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of lazy initialization is straightforward and the decision to implement
    it is easy. If you have large string objects, then you should try this approach.
    There are two best practices to consider with lazy initialization. First, we should
    implement synchronization when we are working in a multiple-thread environment.
    This is to help promote thread safety. Another best practice is to avoid overuse.
    When we overuse lazy initialization, our code might become difficult to read and
    maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Additional string operation strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: String pooling and lazy initialization are excellent optimization strategies
    that can help improve the overall performance of our Java applications. In addition
    to these strategies, we can ensure that our string concatenation operations are
    efficient, that we properly leverage regular expressions, and that we efficiently
    handle large text files. This section reviews techniques in each of those areas.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: String concatenation – the joining of two or more strings into one – using the
    plus (`+`) operator often results in inefficient code. This concatenation creates
    a new string object, which we want to avoid. Let’s look at two alternatives that
    offer better performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'This first alternative uses `StringBuilder`. In the following example, we create
    a `StringBuilder` object, append five string literals to it, convert the `StringBuilder`
    object to `String`, and then output the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Another alternative is to use `StringBuffer`. The following program is similar
    to our `StringBuilder` example but uses `StringBuffer` instead. As you can see,
    both methods are implemented in the same manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The difference between the `StringBuilder` and `StringBuffer` alternatives to
    string concatenation is that `StringBuffer` offers us thread safety, so it should
    be used in multiple-thread environments; otherwise, `StringBuilder` is an alternative
    to using the plus (`+`) operator for string concatenation.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Regular expressions** provide us with an excellent method of pattern matching
    as well as string manipulation. Because these expressions can be processor- and
    memory-intensive, it is important to learn how to use them efficiently. We can
    optimize the use of regular expressions by compiling our patterns only once and
    reusing them as needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example. In the first part of our application, we import the
    `Matcher` and `Pattern` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we establish our email pattern regex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This next section of code creates a list of sample email addresses. We will
    later check these for validity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The next statement compiles the regex pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This last section of code iterates through each email address in our list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This simple implementation of regular expression checks for email address formatting
    and demonstrates how to compile the regex pattern once and use it elsewhere in
    the application as an efficient alternative to compiling the pattern each time
    we need to perform the email address validation operation.
  prefs: []
  type: TYPE_NORMAL
- en: Large text files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some Java applications can process very large text files, even book-length files.
    It is not advisable to load the file’s complete content at one time. Our applications
    can quickly run out of available memory and cause undesirable runtime results.
    An alternative is to use a buffered approach to read the text files in segments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example assumes that there is a text file in the local directory.
    We read each line using `BufferedReader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This approach can help us manage our memory and improve the overall performance
    of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused on how to create, manipulate, and manage strings to contribute
    to the overall performance of your Java applications. You should now understand
    string pooling and have the confidence to use it effectively based on best practices.
    Lazy initialization should now be a strategy you consider implementing in your
    future applications when dealing with the extensive use of strings and you are
    concerned about thread safety. The chapter also introduced advanced string operation
    strategies to help give you choices when designing your Java applications for
    high performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, *Memory Leaks*, we will look at what memory leaks are,
    how they are created, and what effects they have on our applications. We will
    look at strategies for avoiding memory leaks to improve the performance of our
    Java applications.
  prefs: []
  type: TYPE_NORMAL
