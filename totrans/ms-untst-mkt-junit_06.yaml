- en: Chapter 6. Revealing Code Quality
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。揭示代码质量
- en: '"Testing by itself does not improve software quality. Test results are an indicator
    of quality, but in and of themselves, they don''t improve it. Trying to improve
    software quality by increasing the amount of testing is like trying to lose weight
    by weighing yourself more often. What you eat before you step onto the scale determines
    how much you will weigh, and the software development techniques you use determine
    how many errors testing will find. If you want to lose weight, don''t buy a new
    scale; change your diet. If you want to improve your software, don''t test more;
    develop better."'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"仅仅进行测试本身并不能提高软件质量。测试结果只是质量的一个指标，但本身并不能提高质量。试图通过增加测试量来提高软件质量，就像试图通过更频繁地称体重来减肥一样。你在上秤之前吃的食物决定了你的体重，而你使用的软件开发技术决定了测试能发现多少错误。如果你想减肥，不要买新的秤；改变你的饮食。如果你想提高你的软件质量，不要进行更多的测试；而是开发更好的软件。"'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Steve McConnell
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——史蒂夫·麦克康奈尔
- en: A poorly developed system generates more bugs than a well-designed system. Manual
    testing can identify software bugs but cannot improve the quality of the system;
    however, TDD and JUnit tests are considered as automated unit testing frameworks,
    and they indeed help in improving the quality of the system. Static code quality
    analysis exposes quality issues in the code and provides suggestions for improvement,
    and continuous health monitoring keeps the system healthy.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一个开发不良的系统比一个设计良好的系统产生更多的错误。手动测试可以识别软件错误，但不能提高系统的质量；然而，TDD和JUnit测试被认为是自动单元测试框架，并且它们确实有助于提高系统的质量。静态代码质量分析揭示了代码中的质量问题，并提供了改进建议，而持续的健康监控使系统保持健康。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Code quality metrics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码质量指标
- en: Static code analysis using PMD, Checkstyle, and FindBugs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PMD、Checkstyle和FindBugs进行静态代码分析
- en: The SonarQube dashboard
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SonarQube 仪表板
- en: The SonarQube runner
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SonarQube 运行器
- en: Code quality analysis using Ant, Maven, and Gradle
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ant、Maven和Gradle进行代码质量分析
- en: Understanding the static code analysis
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解静态代码分析
- en: Static code analysis is the process of analyzing code without executing it.
    Code review is also a sort of static code analysis but is performed with humans
    or team members. Generally, static code analysis is performed by an automated
    tool.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析是在不执行代码的情况下分析代码的过程。代码审查也是一种静态代码分析，但由人类或团队成员执行。通常，静态代码分析是由自动化工具执行的。
- en: 'Usually, a static analysis includes the following metrics:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，静态分析包括以下指标：
- en: Violation of coding best practices such as long method body, long parameter
    list, large classes, and variable names.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 违反编码最佳实践，如方法体过长、参数列表过长、类过大以及变量命名不当。
- en: Cohesion represents responsibility of a single module (class). If a module or
    class possesses too many responsibilities, such as tax calculation, sending e-mails,
    and formatting user inputs, the class or module is less cohesive. Performing multiple
    dissimilar tasks introduces complexity and maintainability issues. High cohesion
    means performing only a particular type of task.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内聚性代表单个模块（类）的责任。如果一个模块或类承担太多的责任，例如税务计算、发送电子邮件和格式化用户输入，那么这个类或模块的内聚性就会降低。执行多个不同的任务会引入复杂性和可维护性问题。高内聚性意味着只执行特定类型的工作。
- en: Suppose a person is assigned to handle customer tickets, code new features,
    design the architecture, organize the annual office party, and so on; this person
    will be over occupied and is bound to make mistakes. It will be very difficult
    for him or her to manage all the responsibilities.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设一个人被分配处理客户工单、编写新功能、设计架构、组织年度办公室派对等工作；这个人将会非常忙碌，并且难免会出错。他或她将很难管理所有的责任。
- en: In refactoring terms, if a class performs too many tasks, the class is called
    a GOD object or class.
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在重构的术语中，如果一个类执行太多的任务，那么这个类被称为GOD对象或类。
- en: Coupling measures the dependency on other modules or code. Low dependency enforces
    high cohesion. If module C depends on two other modules, A and B, any change in
    the APIs of A or B will force C to change.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 耦合度衡量对其他模块或代码的依赖性。低依赖性强制高内聚性。如果模块C依赖于两个其他模块，A和B，那么A或B的API的任何变化都将迫使C发生变化。
- en: Event-driven architecture is an example of loose coupling. In an event-driven
    system when something changes, an event is published to a destination without
    any knowledge of who will process the event; the event consumers consume the event
    and take action(s). This decouples the event publisher from the event consumers.
    So, any change in the consumer doesn't force the publisher to change.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事件驱动架构是松耦合的一个例子。在一个事件驱动系统中，当某个东西发生变化时，会向一个目的地发布一个事件，而无需知道谁将处理该事件；事件消费者消费事件并采取行动。这解耦了事件发布者与事件消费者。因此，消费者中的任何变化都不会强迫发布者发生变化。
- en: Cyclomatic complexity measures the complexity of a program. In 1976, Thomas
    J. McCabe, Sr. developed cyclomatic complexity. It measures the number of linearly
    independent paths in a program. This is not restricted to a program-level complexity,
    but it can also be applied to individual functions, modules, methods, or classes
    within a program.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环复杂度衡量程序的复杂度。1976年，托马斯·J·麦卡贝（Thomas J. McCabe, Sr.）开发了循环复杂度。它衡量程序中线性独立路径的数量。这不仅仅限于程序级别的复杂度，也可以应用于程序中的单个函数、模块、方法或类。
- en: Cyclomatic complexity of a program is defined with a control flow graph of the
    program. Complexity is represented as *M = E-N+2P*, where *M* is complexity, *E*
    is the number of edges of the graph, *N* is the number of nodes of the graph,
    and *P* is the number of connected components. Any method with a complexity greater
    than 10 has a serious problem.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序的循环复杂度是通过程序的控制流图定义的。复杂度表示为 *M = E-N+2P*，其中 *M* 是复杂度，*E* 是图的边数，*N* 是图的节点数，*P*
    是连通分量的数量。任何复杂度大于10的方法都存在严重问题。
- en: 'A method that has no conditional statements has a cyclomatic complexity of
    1\. The following diagram represents the directed graph and complexity:'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有条件语句的方法具有1的循环复杂度。以下图表表示了有向图和复杂度：
- en: '![Understanding the static code analysis](img/00077.jpeg)'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![理解静态代码分析](img/00077.jpeg)'
- en: 'A method with a single condition (an IF) or a single loop (a FOR) has a complexity
    of 2\. The following diagram explains the calculation:'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 具有一个条件（IF语句）或一个循环（FOR循环）的方法具有2的复杂度。以下图表解释了计算方法：
- en: '![Understanding the static code analysis](img/00078.jpeg)'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![理解静态代码分析](img/00078.jpeg)'
- en: 'The following is the corresponding code:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是对应的代码：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Various automated tools are available for static code analysis. In addition,
    the built-in Eclipse compiler can already perform a lot of static code analysis.
    The following are the widely used ones:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析有多种自动化工具可用。此外，内置的Eclipse编译器已经可以执行大量的静态代码分析。以下是一些广泛使用的工具：
- en: '**Checkstyle**: This tool performs static code analysis, and it can also be
    used to show violations of a configured coding standard. It comes under a GNU
    General Public License. You can check it out at the following link: [http://checkstyle.sourceforge.net](http://checkstyle.sourceforge.net).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Checkstyle**：这个工具执行静态代码分析，也可以用来显示配置的编码标准的违规情况。它遵循GNU通用公共许可证。您可以在以下链接查看它：[http://checkstyle.sourceforge.net](http://checkstyle.sourceforge.net)。'
- en: '**FindBugs**: This is an open source static bytecode analyzer for potential
    Java errors. Plugins are available for Eclipse, NetBeans, and IntelliJ IDEA. It
    comes under a GNU General Public License. FindBugs can be configured with Jenkins.
    The following is the link for the FindBugs website: [http://findbugs.sourceforge.net](http://findbugs.sourceforge.net).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FindBugs**：这是一个开源的Java潜在错误的静态字节码分析器。它为Eclipse、NetBeans和IntelliJ IDEA提供了插件。它遵循GNU通用公共许可证。FindBugs可以通过Jenkins进行配置。以下为FindBugs网站链接：[http://findbugs.sourceforge.net](http://findbugs.sourceforge.net)。'
- en: '**PMD**: This is a static ruleset based on the Java source code analyzer that
    identifies potential problems. PMD has an Eclipse plugin that shows an error icon
    in the editor, but PMD errors are not true errors; rather, they''re the result
    of inefficient code.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PMD**：这是一个基于Java源代码分析器的静态规则集，用于识别潜在问题。PMD有一个Eclipse插件，在编辑器中显示错误图标，但PMD错误不是真正的错误；而是不高效代码的结果。'
- en: In the next section, we will examine the static analysis tools.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将检查静态分析工具。
- en: Working with the Checkstyle plugin
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Checkstyle插件
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This class, `Calculator.java`, calculates the sum of a list of numbers. It's
    a generic class; we can calculate the sum of integers or doubles or any number.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类，`Calculator.java`，计算一系列数字的总和。它是一个泛型类；我们可以计算整数或双精度浮点数或任何数字的总和。
- en: 'Right-click on `CodeQualityChapter06` and enable **Checkstyle**. The following
    screenshot displays the Checkstyle pop-up menu:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击`CodeQualityChapter06`并启用**Checkstyle**。以下屏幕截图显示了Checkstyle弹出菜单：
- en: '![Working with the Checkstyle plugin](img/00080.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![与Checkstyle插件一起工作](img/00080.jpeg)'
- en: 'This action will trigger the Checkstyle validation. It will open the **Checks**
    tab (if the **Checks** tab is not opened automatically, then open the view from
    the show views menu) and show a graphical view of violations. The following screenshot
    displays the graphical violation pie chart:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作将触发Checkstyle验证。它将打开**检查**选项卡（如果**检查**选项卡没有自动打开，则从显示视图菜单中打开视图）并显示违规的图形视图。以下屏幕截图显示了违规的图形饼图：
- en: '![Working with the Checkstyle plugin](img/00081.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![与Checkstyle插件一起工作](img/00081.jpeg)'
- en: 'Another view shows the violations in a tabular format. The following screenshot
    displays the violations in a tabular format:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个视图以表格格式显示违规。以下屏幕截图显示了以表格格式显示的违规：
- en: '![Working with the Checkstyle plugin](img/00082.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![与Checkstyle插件一起工作](img/00082.jpeg)'
- en: Exploring the FindBugs plugin
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索FindBugs插件
- en: This section describes the configuration and usage of the FindBugs plugin.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了FindBugs插件的配置和使用。
- en: 'FindBugs works with three types of errors. You can visit [http://findbugs.sourceforge.net/bugDescriptions.html](http://findbugs.sourceforge.net/bugDescriptions.html)
    for the FindBugs error details. The following are the FindBugs-supported error
    categories and errors:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: FindBugs与三种类型的错误一起工作。您可以访问[http://findbugs.sourceforge.net/bugDescriptions.html](http://findbugs.sourceforge.net/bugDescriptions.html)以获取FindBugs错误详情。以下是一些FindBugs支持的错误类别和错误：
- en: '**Correctness bug:** This is an apparent coding mistake that results in code
    that was probably not what the developer intended; for example, a method ignores
    the return value of a self-assigned field. The following are a few examples of
    a correctness bug:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正确性错误**: 这是一种明显的编码错误，导致代码可能是开发者不希望的结果；例如，一个方法忽略了自赋值字段的返回值。以下是一些正确性错误的例子：'
- en: The class defines `tostring()` but it should be `toString()`
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类定义了`tostring()`但应该是`toString()`
- en: A value is checked here to see whether it is null, but this value can't be null
    because it was previously dereferenced, and if it were null, a null pointer exception
    would have occurred at the earlier dereference
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里检查一个值是否为null，但这个值不能为null，因为它之前已经被解引用，如果它是null，那么在早期解引用时就会发生空指针异常
- en: The method in the subclass doesn't override a similar method in a superclass
    because the type of a parameter doesn't exactly match the type of the corresponding
    parameter in the superclass
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类中的方法没有覆盖超类中类似的方法，因为参数的类型与超类中相应参数的类型不完全匹配
- en: Class defines `equal(Object)` but it should be `equals(Object)`
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类定义了`equal(Object)`但应该是`equals(Object)`
- en: '**Bad practice:** This includes violations of recommended best practices and
    essential coding practice. The following are the examples of bad practices:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不良实践**: 这包括违反推荐的最佳实践和基本编码实践。以下是不良实践的例子：'
- en: '**Hash code and equals problems**:'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**哈希码和equals问题**:'
- en: Class defines `hashCode()` but it should be `equals()` and `hashCode()`
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类定义了`hashCode()`但应该是`equals()`和`hashCode()`
- en: Class defines `equals()` but it should be `hashCode()`
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类定义了`equals()`但应该是`hashCode()`
- en: Class defines `hashCode()` and uses `Object.equals()`
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类定义了`hashCode()`并使用`Object.equals()`
- en: Class defines `equals()` and uses `Object.hashCode()`
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类定义了`equals()`并使用`Object.hashCode()`
- en: '**Cloneable idiom**:'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可克隆习语**:'
- en: Class defines `clone()` but doesn't implement `Cloneable`
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类定义了`clone()`但没有实现`Cloneable`
- en: '**Serializable problems**:'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可序列化问题**:'
- en: Class is `Serializable`, but doesn't define `serialVersionUID`
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类是`Serializable`，但没有定义`serialVersionUID`
- en: Comparator doesn't implement `Serializable`
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较器没有实现`Serializable`
- en: Non serializable class has a `serializable` inner class
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非序列化类有一个`serializable`内部类
- en: '**Dropped exceptions**: Here, an exception is created and dropped rather than
    thrown, such as the following example, where the exception was created but not
    thrown:'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**丢弃的异常**: 在这里，创建了一个异常但没有抛出，例如以下示例中，异常被创建但没有抛出：'
- en: '[PRE3]'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Misuse of finalize**:'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**finalize方法滥用**:'
- en: Explicit invocation of finalize
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确调用`finalize`
- en: Finalizer does not call the superclass finalizer
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理器没有调用超类的清理器
- en: '**Dodgy errors**: This kind of code is confusing, anomalous, or written in
    a way that leads to errors. Examples include the following:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可疑错误**: 这类代码令人困惑、异常，或以导致错误的方式编写。以下是一些例子：'
- en: '**Dead store of class literal**: An instruction assigns a class literal to
    a variable and then never uses it.'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类字面量的无效存储**：一条指令将类字面量赋给一个变量，然后从未使用它。'
- en: '**Switch fall through**: A value stored in the previous switch case is overwritten
    here due to a switch fall through. It is likely that you forgot to put a break
    or return at the end of the previous case.'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**switch 语句穿透**：由于 switch 语句穿透，这里覆盖了之前 switch 情况中存储的值。很可能你忘记在之前的 case 末尾放置
    break 或 return。'
- en: '**Unconfirmed type casts** and **redundant null check**: This error occurs
    when a value is `null`, for example, consider the following code:'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未确认的类型转换** 和 **冗余的空检查**：当值是 `null` 时，会发生此错误，例如，考虑以下代码：'
- en: '[PRE4]'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is the update site URL for the FindBugs Eclipse plugin: [http://findbugs.cs.umd.edu/eclipse](http://findbugs.cs.umd.edu/eclipse).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为 FindBugs Eclipse 插件提供的更新站点 URL：[http://findbugs.cs.umd.edu/eclipse](http://findbugs.cs.umd.edu/eclipse)。
- en: You can also install it through Eclipse Marketplace.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过 Eclipse Marketplace 安装它。
- en: 'Install FindBugs and then add the following code to the `CodeQualityChapter06`
    project for verification:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 FindBugs，然后向 `CodeQualityChapter06` 项目添加以下代码以进行验证：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Right-click on the project and click on the **Find Bugs** menu. The following
    is the pop-up menu displayed:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击项目并单击 **查找错误** 菜单。以下显示的是弹出菜单：
- en: '![Exploring the FindBugs plugin](img/00083.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![探索 FindBugs 插件](img/00083.jpeg)'
- en: 'Open the source file; it shows the bug icons. The following screenshot displays
    the bugs:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 打开源文件；它显示错误图标。以下截图显示了错误：
- en: '![Exploring the FindBugs plugin](img/00084.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![探索 FindBugs 插件](img/00084.jpeg)'
- en: 'The following screenshot displays the bugs in a tabular format with the error
    categories:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图以表格形式显示了错误类别中的错误：
- en: '![Exploring the FindBugs plugin](img/00085.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![探索 FindBugs 插件](img/00085.jpeg)'
- en: Working with the PMD plugin
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PMD 插件
- en: PMD can find duplicate code, dead code, empty if/while statements, empty try/catch
    blocks, complicated expressions, cyclomatic complexity, and so on.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: PMD 可以找到重复代码、死代码、空的 if/while 语句、空的 try/catch 块、复杂的表达式、循环复杂度等。
- en: 'The following is the update site URL for Eclipse: [http://sourceforge.net/projects/pmd/files/pmd-eclipse/update-site/](http://sourceforge.net/projects/pmd/files/pmd-eclipse/update-site/).
    You can also install it through Eclipse Marketplace.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为 Eclipse 提供的更新站点 URL：[http://sourceforge.net/projects/pmd/files/pmd-eclipse/update-site/](http://sourceforge.net/projects/pmd/files/pmd-eclipse/update-site/)。您也可以通过
    Eclipse Marketplace 安装它。
- en: 'After installation, right-click on the `CodeQualityChapter06` project and select
    the **Toggle PMD Nature** menu item. It will enable the project for PMD analysis.
    The following screenshot demonstrates the PMD pop-up menu options:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，右键单击 `CodeQualityChapter06` 项目并选择 **切换 PMD 性质** 菜单项。它将为 PMD 分析启用项目。以下截图演示了
    PMD 弹出菜单选项：
- en: '![Working with the PMD plugin](img/00086.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![使用 PMD 插件](img/00086.jpeg)'
- en: 'PMD shows the errors in the **Problems** tab. The following screenshot shows
    the PMD violations in the **Problems** tab:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: PMD 在 **问题** 选项卡中显示错误。以下截图显示了 **问题** 选项卡中的 PMD 违规：
- en: '![Working with the PMD plugin](img/00087.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![使用 PMD 插件](img/00087.jpeg)'
- en: The next section will describe the SonarQube dashboard and analyze projects
    using the SonarQube runner, Ant, Gradle, and Maven.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将描述 SonarQube 仪表板，并使用 SonarQube 运行器、Ant、Gradle 和 Maven 分析项目。
- en: Monitoring code quality with SonarQube
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SonarQube 监控代码质量
- en: SonarQube is a web-based open source continuous quality assessment dashboard.
    It comes with a GNU General Public License and supports cross-platform, so it
    can be installed on many popular operating systems. SonarQube is developed in
    Java. As of March 2014, the latest version is 4.1.2.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: SonarQube 是一个基于 Web 的开源持续质量评估仪表板。它附带 GNU 通用公共许可证，支持跨平台，因此可以安装在许多流行的操作系统上。SonarQube
    使用 Java 开发。截至 2014 年 3 月，最新版本是 4.1.2。
- en: 'SonarQube exhibits the following features:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: SonarQube 展示以下功能：
- en: It is a web-based code quality dashboard that can be accessed from anywhere.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个基于 Web 的代码质量仪表板，可以从任何地方访问。
- en: It supports numerous languages. The languages and coding platforms supported
    in Version 4.1.2 are ABAP, Android, C/C++, C#, COBOL, Erlang, Flex/ActionScript,
    Groovy, Java, JavaScript, Natural, PHP, PL/I, PL/SQL, Python, VB.NET, Visual Basic
    6, Web (analysis of HTML included in pages on HTML, JSP, JSF, Ruby, PHP, and so
    on), and XML.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持多种语言。在 4.1.2 版本中支持的语言和编码平台包括 ABAP、Android、C/C++、C#、COBOL、Erlang、Flex/ActionScript、Groovy、Java、JavaScript、Natural、PHP、PL/I、PL/SQL、Python、VB.NET、Visual
    Basic 6、Web（包括 HTML、JSP、JSF、Ruby、PHP 等页面上的 HTML 分析）和 XML。
- en: 'It offers the following metrics:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了以下指标：
- en: Bugs and potential bugs
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺陷和潜在缺陷
- en: Breach in coding standards
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码标准违规
- en: Duplications
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复
- en: Lack of unit tests
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少单元测试
- en: Bad distribution of complexities
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂性分布不均
- en: Spaghetti design
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意大利面式设计
- en: Not enough or too many comments
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释不足或过多
- en: It records history in a database and provides chronological graphs of quality
    metrics.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在数据库中记录历史，并提供质量指标的按时间顺序的图表。
- en: It can be expanded using numerous plugins.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以通过众多插件进行扩展。
- en: It supports continuous automated inspection using Ant/Maven/Gradle and CI tools
    such as Jenkins, CruiseControl, and Bamboo.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持使用Ant/Maven/Gradle和CI工具（如Jenkins、CruiseControl和Bamboo）进行持续自动化检查。
- en: It integrates with Eclipse.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与Eclipse集成。
- en: The following section covers the SonarQube installation and usage.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分涵盖了SonarQube的安装和使用。
- en: Running SonarQube
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行SonarQube
- en: 'The following are the SonarQube configuration steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在SonarQube中配置的步骤：
- en: Download SonarQube from [http://www.sonarqube.org/downloads/](http://www.sonarqube.org/downloads/).
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://www.sonarqube.org/downloads/](http://www.sonarqube.org/downloads/)下载SonarQube。
- en: Uncompress the downloaded file into the directory of your choice. We'll refer
    to it as `<sonar_install_directory>` or `SONAR_HOME` in the next steps.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将下载的文件解压缩到您选择的目录中。在接下来的步骤中，我们将将其称为`<sonar_install_directory>`或`SONAR_HOME`。
- en: Open the `<sonar_install_directory>/bin` directory. The `bin` directory lists
    the SonarQube-supported operating systems. Go to a specific OS directory such
    as open `windows-x86-64` for a Windows 64-bit machine.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`<sonar_install_directory>/bin`目录。`bin`目录列出了SonarQube支持的操作系统。转到特定的OS目录，例如为Windows
    64位机器打开`windows-x86-64`。
- en: Run a shell script or batch file to start Sonar. The following screenshot shows
    the command prompt output of a Windows 64-bit machine. Note that the server logs
    the **Web server is started** information when the web server is started:![Running
    SonarQube](img/00088.jpeg)
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行一个shell脚本或批处理文件来启动Sonar。以下截图显示了Windows 64位机器的命令提示符输出。注意，当Web服务器启动时，服务器会记录**Web服务器已启动**的信息：![运行SonarQube](img/00088.jpeg)
- en: Open Internet Explorer and type in `http://localhost:9000`. This will launch
    the SonarQube dashboard. Initially, the dashboard shows an empty project list.
    First, we need to analyze the projects to get them displayed in the dashboard.
    The following is the SonarQube dashboard on display:![Running SonarQube](img/00089.jpeg)
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Internet Explorer并输入`http://localhost:9000`。这将启动SonarQube仪表板。最初，仪表板显示一个空的项目列表。首先，我们需要分析项目以在仪表板中显示它们。以下是在仪表板中显示的SonarQube仪表板：![运行SonarQube](img/00089.jpeg)
- en: Installation is complete. Next, we need to analyze a project using SonarQube.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成。接下来，我们需要使用SonarQube分析一个项目。
- en: Analyzing code with the SonarQube runner
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SonarQube运行器分析代码
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Analyzing code with the SonarQube runner](img/00090.jpeg)*   Create a new
    `SONAR_RUNNER_HOME` environment variable, which is set to `<runner_install_directory>`.*   Add
    the `<runner_install_directory>/bin` directory to your `Path` variable.*   Open
    command prompt and check whether the runner is installed. Issue the `sonar-runner
    –h` command, and you will get the following output:![Analyzing code with the SonarQube
    runner](img/00091.jpeg)*   Go to the `CodeQualityChapter06` project folder, create
    a properties file named `sonar-project.properties`, and add the following lines
    to the file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用SonarQube运行器分析代码](img/00090.jpeg)*   创建一个新的`SONAR_RUNNER_HOME`环境变量，将其设置为`<runner_install_directory>`。*   将`<runner_install_directory>/bin`目录添加到您的`Path`变量中。*   打开命令提示符并检查运行器是否已安装。输入`sonar-runner
    –h`命令，您将得到以下输出：![使用SonarQube运行器分析代码](img/00091.jpeg)*   进入`CodeQualityChapter06`项目文件夹，创建一个名为`sonar-project.properties`的属性文件，并将以下行添加到文件中：'
- en: '[PRE7]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Open the command prompt, change the directory to `CodeQualityChapter06`, and
    issue the `sonar-runner` command; this will start the project analysis. Sonar
    will download JAR files and store the analysis data into an H2 database. Once
    the analysis is over, open `http://localhost:9000`; this will launch the SonarQube
    dashboard.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开命令提示符，将目录更改为`CodeQualityChapter06`，并输入`sonar-runner`命令；这将启动项目分析。Sonar将下载JAR文件并将分析数据存储到H2数据库中。一旦分析完成，打开`http://localhost:9000`；这将启动SonarQube仪表板。
- en: The metrics displayed in the dashboard are technical debt, code details, documentation,
    code duplication, complexity, and coverage.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仪表板中显示的指标包括技术债务、代码详细情况、文档、代码重复、复杂性和覆盖率。
- en: 'The following screenshot shows the **Technical Debt** metric:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了**技术债务**指标：
- en: '![Analyzing code with the SonarQube runner](img/00092.jpeg)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用SonarQube运行器分析代码](img/00092.jpeg)'
- en: 'The following screenshot shows the code details metric:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了代码详细指标：
- en: '![Analyzing code with the SonarQube runner](img/00093.jpeg)'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用SonarQube运行器分析代码](img/00093.jpeg)'
- en: 'The following screenshot shows the **Documentation** metric:'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了**文档**指标：
- en: '![Analyzing code with the SonarQube runner](img/00094.jpeg)'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用SonarQube运行器分析代码](img/00094.jpeg)'
- en: 'The following screenshot shows the cyclomatic **Complexity** metric:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了循环**复杂度**指标：
- en: '![Analyzing code with the SonarQube runner](img/00095.jpeg)*   Click on the
    **Issues 12** hyperlink in the **Technical Debt** metric; this will open an issue''s
    details with a severity legend. The following is the **Severity** legend:![Analyzing
    code with the SonarQube runner](img/00096.jpeg)'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用SonarQube运行器分析代码](img/00095.jpeg)*   点击**技术债务**指标中的**问题12**超链接；这将打开一个带有严重性图例的问题详情。以下为**严重性**图例：![使用SonarQube运行器分析代码](img/00096.jpeg)'
- en: 'The following screenshot shows the issue details:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了问题详情：
- en: '![Analyzing code with the SonarQube runner](img/00097.jpeg)*   Click on any
    of the three complexity hyperlinks. Sonar will open the files and show the complexity
    details.'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![使用SonarQube运行器分析代码](img/00097.jpeg)*   点击任何三个复杂度超链接。Sonar将打开文件并显示复杂度详情。'
- en: 'The following is an example of the complexity of `Buggy.java`:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下为`Buggy.java`的复杂度示例：
- en: '![Analyzing code with the SonarQube runner](img/00098.jpeg)'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用SonarQube运行器分析代码](img/00098.jpeg)'
- en: The **Hotspot** view displays the pain areas of the project, such as hotspots
    by duplicate lines, major violations, most violated rules, and the most violated
    resources.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**热点**视图显示了项目的痛点区域，例如重复行、主要违规、最常违反的规则和最常违反的资源。'
- en: The **Time Machine** view displays the chronological view of the project, such
    as a graphical day- or month-wise comparison of code complexity or code coverage.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**时间机器**视图显示了项目的按时间顺序视图，例如代码复杂度或代码覆盖率按日或按月进行图形比较。'
- en: Improving quality with the Sonar Eclipse plugin
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Sonar Eclipse插件提高质量
- en: Sonar provides an Eclipse plugin for accessing and fixing the Sonar-reported
    code issues in the Eclipse editor. The plugin can be downloaded from [http://www.sonarsource.com/products/plugins/developer-tools/eclipse/](http://www.sonarsource.com/products/plugins/developer-tools/eclipse/).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Sonar为Eclipse编辑器提供了一个插件，用于访问和修复Sonar报告的代码问题。插件可以从[http://www.sonarsource.com/products/plugins/developer-tools/eclipse/](http://www.sonarsource.com/products/plugins/developer-tools/eclipse/)下载。
- en: 'Once the plugin is installed, right-click on the project, open the **Configure**
    menu, and click on the **Associate with Sonar...** menu item. The following screenshot
    shows the **Configure** menu details:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦插件安装完毕，右键单击项目，打开**配置**菜单，然后点击**与Sonar关联...**菜单项。以下截图显示了**配置**菜单的详细信息：
- en: '![Improving quality with the Sonar Eclipse plugin](img/00099.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![使用Sonar Eclipse插件提高质量](img/00099.jpeg)'
- en: In the `sonar-project.properties` file, we stored the `sonar.projectKey=packt:CodeQualityChapter06`
    project key.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sonar-project.properties`文件中，我们存储了`sonar.projectKey=packt:CodeQualityChapter06`项目密钥。
- en: In the Sonar wizard, enter `GroupId=packt` and `ArtifactId= CodeQualityChapter06`.
    Click on **Find on server** and then click on **Finish**. This will connect to
    the local Sonar server and bring the issue details into the **Problems** tab.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在Sonar向导中，输入`GroupId=packt`和`ArtifactId=CodeQualityChapter06`。点击**在服务器上查找**然后点击**完成**。这将连接到本地Sonar服务器并将问题详情带入**问题**选项卡。
- en: 'The following is the Sonar wizard''s screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为Sonar向导的截图：
- en: '![Improving quality with the Sonar Eclipse plugin](img/00100.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![使用Sonar Eclipse插件提高质量](img/00100.jpeg)'
- en: 'The following are the violations from the Sonar repository:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从Sonar仓库中获取的违规情况：
- en: '![Improving quality with the Sonar Eclipse plugin](img/00101.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![使用Sonar Eclipse插件提高质量](img/00101.jpeg)'
- en: 'Click on any problem, and it will take you to the source code''s line and show
    a tooltip of the problem. The following screenshot shows the blocker violation
    that the `hashCode()` method is not implemented:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 点击任何问题，它将带您到源代码的行并显示问题的工具提示。以下截图显示了`hashCode()`方法未实现的阻塞违规：
- en: '![Improving quality with the Sonar Eclipse plugin](img/00102.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![使用Sonar Eclipse插件提高质量](img/00102.jpeg)'
- en: Add a `hashCode` method, rerun the Sonar runner, and launch the Sonar Eclipse
    wizard; it will remove the blocking issue.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`hashCode`方法，重新运行Sonar运行器，并启动Sonar Eclipse向导；它将移除阻塞问题。
- en: Monitoring quality with Gradle and SonarQube
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Gradle和SonarQube监控质量
- en: 'This section covers the Gradle integration with Sonar. Gradle has an inbuilt
    Sonar plugin. Create a `build.gradle` file under `/Packt/Chapter06/CodeQualityChapter06`.
    Add the following lines to the `build.gradle` file and the Sonar lines are highlighted:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了 Gradle 与 Sonar 的集成。Gradle 有一个内置的 Sonar 插件。在 `/Packt/Chapter06/CodeQualityChapter06`
    下创建一个 `build.gradle` 文件。将以下行添加到 `build.gradle` 文件中，并突出显示 Sonar 行：
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that `sonar.projectKey` refers to `packt:CodeQualityChapter06`. Open the
    command prompt and issue the `gradle sonarRunner` command. This will start building
    the project. The following is the console output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`sonar.projectKey` 指的是 `packt:CodeQualityChapter06`。打开命令提示符并执行 `gradle sonarRunner`
    命令。这将开始构建项目。以下是在控制台上的输出：
- en: '![Monitoring quality with Gradle and SonarQube](img/00103.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Gradle 和 SonarQube 监控质量](img/00103.jpeg)'
- en: 'Open the Sonar URL, and it will show the coverage computed by the JaCoCo plugin.
    The following is the code coverage and the technical debt output. Note that the
    **+8** new issues are added to the project. Technical debt is increased from 0.4
    days to 1.2 days:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Sonar URL，它将显示 JaCoCo 插件计算出的覆盖率。以下是代码覆盖率和技术债务输出。请注意，项目中新增加了 **+8** 个问题。技术债务从
    0.4 天增加到 1.2 天：
- en: '![Monitoring quality with Gradle and SonarQube](img/00104.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Gradle 和 SonarQube 监控质量](img/00104.jpeg)'
- en: Monitoring quality with Maven and SonarQube
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Maven 和 SonarQube 监控质量
- en: 'This section describes how to integrate Maven with SonarQube. We will use the
    `CodeQualityChapter06` Eclipse project for the analysis. Maven has a plugin for
    Sonar. Create a `pom.xml` file under `/Packt/Chapter06/CodeQualityChapter06`.
    Add the following lines to the `pom.xml` file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了如何将 Maven 与 SonarQube 集成。我们将使用 `CodeQualityChapter06` Eclipse 项目进行分析。Maven
    有一个用于 Sonar 的插件。在 `/Packt/Chapter06/CodeQualityChapter06` 下创建一个 `pom.xml` 文件。将以下行添加到
    `pom.xml` 文件中：
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Open the command prompt, go to the project base folder, and issue the `mvn sonar:sonar`
    command. This command will download the SonarQube version of JAR files from the
    repository and start analyzing the project. Note the highlighted section `<sonar.language>java<…>`
    in the preceding script. This `<sonar.language>` tag signifies that the Maven
    will analyze a `java` project.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 打开命令提示符，转到项目基本文件夹，并执行 `mvn sonar:sonar` 命令。此命令将从存储库下载 SonarQube 版本的 JAR 文件并开始分析项目。注意前面脚本中突出显示的
    `<sonar.language>java<…>` 部分。此 `<sonar.language>` 标签表示 Maven 将分析一个 `java` 项目。
- en: In the Gradle script or Sonar runner, we didn't mention a project version; here
    in Maven, as per the Maven project convention, we have to specify a `<version>1.0-SNAPSHOT</version>`
    version in the `POM.xml` file.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Gradle 脚本或 Sonar 运行器中，我们没有提到项目版本；在这里，根据 Maven 项目约定，我们必须在 `POM.xml` 文件中指定 `<version>1.0-SNAPSHOT</version>`
    版本。
- en: SonarQube uniquely identifies a project using a key (`GroupId` or `ArtifactId`)
    and a version. So, Maven analysis will create a new project statistics in the
    Sonar server as the version number is supplied in Maven, but not in Gradle and
    Sonar runner.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: SonarQube 使用一个密钥（`GroupId` 或 `ArtifactId`）和一个版本来唯一标识一个项目。因此，Maven 分析将在 Sonar
    服务器中创建一个新的项目统计信息，因为 Maven 提供了版本号，但 Gradle 和 Sonar 运行器没有。
- en: 'The following screenshot displays the **Projects** section on the Sonar dashboard.
    Note that the Maven analysis created **Version** **1.0-SNAPSHOT**, whereas the
    Gradle and Sonar runner both updated an **unspecified** version of the project:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 Sonar 仪表板上的 **项目** 部分。请注意，Maven 分析创建了 **版本** **1.0-SNAPSHOT**，而 Gradle
    和 Sonar 运行器都更新了项目的 **未指定** 版本：
- en: '![Monitoring quality with Maven and SonarQube](img/00105.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Maven 和 SonarQube 监控质量](img/00105.jpeg)'
- en: Monitoring quality with Ant and SonarQube
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Ant 和 SonarQube 监控质量
- en: This section describes how to configure Ant to integrate with Sonar. An Ant
    target needs a task to perform a build step. SonarQube provides an Ant task for
    project analysis. The Ant task JAR needs to be downloaded from [http://repository.codehaus.org/org/codehaus/sonar-plugins/sonar-ant-task/2.1/sonar-ant-task-2.1.jar](http://repository.codehaus.org/org/codehaus/sonar-plugins/sonar-ant-task/2.1/sonar-ant-task-2.1.jar).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了如何配置 Ant 以与 Sonar 集成。Ant 目标需要一个任务来执行构建步骤。SonarQube 提供了一个用于项目分析的 Ant 任务。需要从
    [http://repository.codehaus.org/org/codehaus/sonar-plugins/sonar-ant-task/2.1/sonar-ant-task-2.1.jar](http://repository.codehaus.org/org/codehaus/sonar-plugins/sonar-ant-task/2.1/sonar-ant-task-2.1.jar)
    下载 Ant 任务 JAR。
- en: We will analyze the `CodeQualityChapter06` project with Ant. Copy the downloaded
    JAR file in `\Packt\chapter06\lib` and create a `build.xml` file directly under
    `CodeQualityChapter06`. You can copy the existing `build.xml` file that we used
    in [Chapter 5](part0030_split_000.html#page "Chapter 5. Exploring Code Coverage"),
    *Code Coverage*, or download the code for this chapter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Ant 分析 `CodeQualityChapter06` 项目。将下载的 JAR 文件复制到 `\Packt\chapter06\lib`
    目录下，并在 `CodeQualityChapter06` 目录下直接创建一个 `build.xml` 文件。您可以复制我们在 [第 5 章](part0030_split_000.html#page
    "第 5 章。探索代码覆盖率")，*代码覆盖率* 中使用的现有 `build.xml` 文件，或者下载本章的代码。
- en: Tip
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: XML namespaces act like Java packages and provide a qualified name for an XML
    element or attribute and avoid name collision. The namespace is defined by the
    `xmlns` attribute at the start tag of an element. The namespace declaration has
    the `syntax.`
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: XML 命名空间类似于 Java 包，为 XML 元素或属性提供一个限定名，以避免名称冲突。命名空间由元素的起始标签中的 `xmlns` 属性定义。命名空间声明具有
    `syntax.` 语法。
- en: '``To access a Sonar task, we will refer to a namespace `sonar` defined in the
    `antlib:org.sonar.ant` URI. We will define the URI in `taskdef`.``'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '``Modify the `build.xml` file and add the `sonar` namespace and the following
    snippet (excluding the common tasks, compilation task, and test tasks for the
    space economy):``'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '[PRE10]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '``Note that the `sonar.projectKey`, `sonar.projectName`, `sonar.projectVersion`,
    and `sonar.language` properties are defined in the preceding XML code. The Sonar
    task uses these attributes to uniquely identify a project and project language.
    Also note that a `taskdef` URI, `uri="antlib:org.sonar.ant"`, is defined to locate
    an `org/sonar/ant/antlib.xml` XML resource in the `${lib.dir}/sonar-ant-task-2.1.jar`
    classpath. The `sonar-ant-task` JAR contains the XML file.``'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '``Open the command prompt, change the directory to `CodeQualityChapter06`,
    and issue the `ant sonar` command. This will execute the Sonar task and start
    analyzing the project.``'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '`The following is the SonarQube dashboard output. The second row with **Version**
    **2.0** and key **packt:chapter06_ant** is the Ant analysis result:`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 SonarQube 仪表板输出。第二行带有 **版本** **2.0** 和键 **packt:chapter06_ant** 的行是 Ant
    分析结果：
- en: '`![Monitoring quality with Ant and SonarQube](img/00106.jpeg)` `# Getting familiar
    with false positives    This section deals with the false positives. In general,
    a static code analysis tool analyzes a source code against a set of rules and
    reports a violation when it finds a violation pattern in the source code. However,
    when we review the pattern and find that the violation is not correct in the context,
    then the reported violation is a false positive.    Static analysis tools report
    violations, but we have to filter out correct rule sets and remove the false positive
    rules. The SonarQube manual code review feature enables you to review code, add
    comments, and flag violations as false positives. The following Sonar URL describes
    how to review violations and flag violations as false positives: [http://www.sonarqube.org/sonar-2-8-in-screenshots/](http://www.sonarqube.org/sonar-2-8-in-screenshots/).    #
    Summary    This chapter explained the static code analysis and code quality attributes
    in depth. It covered the SonarQube code quality dashboard, static code analysis
    using Eclipse plugins, the Sonar runner and build scripts such as Ant, Maven,
    and Gradle, and code quality tools such as PMD, Checkstyle, and FindBugs.    By
    now, the reader will be able to configure the Sonar dashboard, set up Eclipse
    plugins, and configure Sonar runner and build scripts to analyze code quality
    using PMD, FindBugs, and Checkstyle.    The next chapter will cover the unit testing
    web tier code with mock objects.`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`![使用Ant和SonarQube监控质量](img/00106.jpeg)` `# 熟悉误报    这一节讨论了误报问题。一般来说，静态代码分析工具会根据一组规则分析源代码，并在源代码中找到违规模式时报告违规。然而，当我们审查模式并发现违规在上下文中不正确时，那么报告的违规就是一个误报。    静态分析工具报告违规，但我们必须过滤掉正确的规则集并移除误报规则。SonarQube的手动代码审查功能允许您审查代码，添加注释，并将违规标记为误报。以下Sonar
    URL描述了如何审查违规并将违规标记为误报：[http://www.sonarqube.org/sonar-2-8-in-screenshots/](http://www.sonarqube.org/sonar-2-8-in-screenshots/)。    #
    摘要    本章深入讲解了静态代码分析和代码质量属性。它涵盖了SonarQube代码质量仪表板、使用Eclipse插件进行的静态代码分析、Sonar运行器和构建脚本（如Ant、Maven和Gradle），以及代码质量工具（如PMD、Checkstyle和FindBugs）。    到目前为止，读者将能够配置Sonar仪表板，设置Eclipse插件，并配置Sonar运行器和构建脚本，以使用PMD、FindBugs和Checkstyle分析代码质量。    下一章将介绍使用模拟对象进行单元测试Web层代码。`'
