<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">The Publisher and Subscriber APIs in a Reactor</h1>
                </header>
            
            <article>
                
<p class="mce-root">The previous chapter provided you with a brief introduction to the evolution of the reactive paradigm. In that chapter, we discussed how Reactive Streams enable us to perform reactive modeling in imperative languages, such as Java. We also discussed the key components in reactive—the publisher and subscriber. In this chapter, we will cover these two components in detail. Since Reactive Streams is a specification, it does not provide any implementations of the two components. It only lists the responsibilities of the individual components. It is left to implementation libraries, such as Reactor, to provide concrete implementations for the interfaces. Reactor also provides different methods for instantiating publisher and subscriber objects.</p>
<p class="mce-root"> We will cover the following topics in this chapter:</p>
<ul>
<li>Comparing streams to existing Java APIs</li>
<li>Understanding the Flux API</li>
<li>Understanding the Mono API</li>
<li>Building subscribers to Flux and Mono publishers</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<ul>
<li class="western">Java Standard Edition, JDK 8 or above</li>
<li>IntelliJ IDEA IDE, 2018.1 or above</li>
</ul>
<p>The GitHub link for this chapter is <a href="https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter02">https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter02</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stream publisher</h1>
                </header>
            
            <article>
                
<p class="western"><span>As we discussed in the previous chapter, the publisher is responsible for the generation of unbounded asynchronous events, and it pushes them to the associated subscribers. It is represented by the</span> <kbd>org.reactivestreams.Publisher</kbd> <span>interface, as follows:</span></p>
<pre class="western"><span><span>public interface Publisher&lt;T&gt; {</span></span>
    public void subscribe(Subscriber&lt;? super T&gt; s);
}</pre>
<p class="western"><span>The <span>interface</span> provides a single <kbd>subscribe</kbd> method. The method is invoked by any party that is interested in listening to events published b</span>y the publisher<span>. The interface is quite simple, and it can be used to publish any type of event, be it a UI event (like a mouse-click) or a data event.</span></p>
<p class="western"><span>Since the interface is simple, let's add an implementation for our custom</span> <kbd>FibonacciPublisher</kbd><span>:</span></p>
<pre style="padding-left: 30px">public class FibonacciPublisher implements Publisher&lt;Integer&gt; {<br/>    @Override<br/>    public void subscribe(Subscriber&lt;? super Integer&gt; subscriber) {<br/>        int count = 0, a = 0, b = 1;<br/>        while (count &lt; 50) {<br/>            int sum = a + b;<br/>            subscriber.onNext(b);<br/>            a = b;<br/>            b = sum;<br/>            count++;<br/>        }<br/>        subscriber.onComplete();<br/>    }<br/>}</pre>
<p class="western"><span>This implementation may look good, but does it comply to p</span>ublisher <span>behavior according to the specification? The specification prescribes rules that describe publisher behavior. A publisher must generate the following four types of events:</span></p>
<ul>
<li class="western"><span>Subscription event</span></li>
<li class="western"><span>Data of type <kbd>T</kbd>, as declared by the publisher</span></li>
<li class="western"><span>Completion event</span></li>
<li class="western"><span>Error event</span></li>
</ul>
<p class="western"><span>According to the specification, a publisher can emit any number of data events. However, it must publish only one event for completion, error, and subscription. Once a completion or an error event is published, the publisher can no longer send data events </span><span>back</span><span> to a subscriber.</span></p>
<p class="western"><span>As backpressure is an important aspect of the specification, a publisher cannot push an arbitrary number of events to a subscriber. Instead, the subscriber must specify how many events it can receive, and a publisher must publish events equal to, or less than, the specified number.</span></p>
<p class="western"><span>In order to validate a publisher, the Reactive Streams API has published a test compatibility kit. Let's add the </span><kbd>reactive-streams-tck</kbd> in <span>the <kbd>build.gradle</kbd> to our project:<br/></span></p>
<pre style="padding-left: 30px">dependencies {<br/>  // rest removed for brevity<br/>  testCompile group: 'org.reactivestreams',<br/>  name: 'reactive-streams-tck', version: '1.0.2'<br/>}</pre>
<p class="western">The <span><strong>Technology Compatibility Kit</strong> (</span><strong>TCK</strong>) provides a <kbd>PublisherVerifier</kbd> interface that must be implemented in order to validate a publisher. It provides the following two methods:</p>
<ul>
<li class="western"><kbd>createPublisher(long)</kbd>: This method must provide an instance of the publisher that can produce the specified number of events</li>
<li class="western"><kbd>createFailedPublisher()</kbd>: This method must try to build a publisher that has raised an error event</li>
</ul>
<p class="western">Let's add the following implementation to test our <kbd>FibonacciPublisher</kbd>:</p>
<pre style="padding-left: 30px">public class FibonacciPublisherVerifier extends PublisherVerification&lt;Integer&gt; {<br/>    public FibonacciPublisherVerifier(){<br/>        super(new TestEnvironment());<br/>    }<br/>    @Override<br/>    public Publisher&lt;Integer&gt; createFailedPublisher() {<br/>        return null;<br/>    }<br/>    @Override<br/>    public Publisher&lt;Integer&gt; createPublisher(long elements) {<br/>        return new FibonacciPublisher();<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="western">Now, let's run the test case to determine whether we comply with the Reactive Streams publisher specification:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/64bd8359-3a1e-4033-8489-59ddb5c94b89.png"/></div>
<p class="western">As shown in the preceding screenshot, there are around 20 test failures and 16 skipped tests. We could fix each one of them, but the aim here is to understand that even a simple interface of a publisher is governed by many behavior specifications. Therefore, it is overkill to build a custom publisher. As service builders, we can use the Reactor framework. This provides publisher implementations capable of publishing any kind of data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stream subscriber</h1>
                </header>
            
            <article>
                
<p class="western">A subscriber is used to listen to events generated by a publisher. When a subscriber registers to a publisher, it receives events in the following order:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/513711fa-108a-4652-8a8e-ced8dbefd186.jpg" style=""/></div>
<p>As a result, the subscriber has the following interface to handle all of these events:</p>
<pre style="padding-left: 30px">public interface Subscriber&lt;T&gt; {<br/>    public void onSubscribe(Subscription s);<br/>    public void onNext(T t);<br/>    public void onError(Throwable t);<br/>    public void onComplete();<br/>}</pre>
<p>Let's cover each of these methods in detail, as follows:</p>
<ul>
<li><kbd>onSubscribe(Subscription s)</kbd>: As soon as a publisher has received a subscriber, it generates a subscription event. The generated subscription event is then received in the specified method.</li>
<li><kbd>onNext (T)</kbd>: All data events generated by a publisher are received by the subscriber in the specified method. A publisher may or may not publish a data event before closing the stream.</li>
<li><kbd>onCompletion()</kbd>: This refers to the completion event, which must be handled by a subscriber. Once a completion event is received, the subscription is considered void.</li>
<li><kbd>onError()</kbd>: This refers to the error event, which must be handled by a subscriber. An error can occur at any moment—while building a subscription or while generating the next data event. In any case, the publisher must send the error event. Once the event is received, the subscription is considered void.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Subscription</h1>
                </header>
            
            <article>
                
<p>The subscription is an important component in Reactive Streams. It provides the necessary control flow, so that publishers do not over-run a subscriber. This is known as backpressure.</p>
<p>Once the subscriber receives the subscription event, it must request that the publisher publish a specified count of events over their respective subscription. This is done by invoking the <kbd>request(long)</kbd> method of the subscription object.</p>
<p>As data events are generated, they are received by the subscriber. Once the limit has been reached, the publisher must stop publishing more events. As the subscriber processes these events, it must request additional events from the publisher:</p>
<div>
<pre>public interface Subscription {<br/>    public void request(long n);<br/>    public void cancel();<br/>}</pre></div>
<p class="mce-root">The subscription object allows a subscriber to control the events it wants to receive. Whenever the subscriber determines that it no longer wants the events, it can invoke the <kbd>cancel()</kbd> method of the subscription. Once invoked, a subscriber may receive fewer data events, in accordance with the demand raised before the cancellation. Post-cancellation, the subscription will become void, meaning that it cannot be used to request additional data.</p>
<div class="mce-root packt_tip">A value of <kbd>Long.MaxValue</kbd> for the request method would result in an infinite flow of events from the publisher.</div>
<p>A subscriber can cancel an active subscription with the <kbd>onSubscribe()</kbd> method before any demand can be raised using the request method. In this case, the publisher will drop the subscription without raising any events.</p>
<p>Now that we have gone over the subscriber interface in detail, we can try to build a <kbd>FibonacciSubscriber</kbd>, as follows:</p>
<pre style="padding-left: 30px">public class FibonacciSubscriber implements Subscriber&lt;Long&gt; {<br/>    private Subscription sub;<br/>    @Override<br/>    public void onSubscribe(Subscription s) {<br/>        sub = s;<br/>        sub.request(10);<br/>    }<br/>    @Override<br/>    public void onNext(Long fibNumber) {<br/>        System.out.println(fibNumber);<br/>        sub.cancel();<br/>    }<br/>    @Override<br/>    public void onError(Throwable t) {<br/>        t.printStackTrace();<br/>        sub=null;<br/>    }<br/>    @Override<br/>    public void onComplete() {<br/>        System.out.println("Finished");<br/>        sub=null;<br/>    }<br/>}</pre>
<p>The preceding implementation does the following things:</p>
<ol>
<li>Upon receiving the subscription event, a request is raised to handle <kbd>10</kbd> events.</li>
<li>When received, all data events are printed to the output console.</li>
<li>After processing a single event, the subscriber cancels the subscription.</li>
<li>The <kbd>onCompletion</kbd> method sets the subscription to <kbd>null</kbd>.</li>
<li>The <kbd>onError</kbd> method prints the error message to the console and sets the subscription as <kbd>null</kbd>.</li>
</ol>
<p>Now, let's validate the subscriber by using the <kbd>SubscriberBlackboxVerification&lt;T&gt;</kbd> abstract class. We need to implement the <kbd>createSubsciber()</kbd> method, as shown in the following code:</p>
<pre style="padding-left: 30px">public class FibonacciSubsciberVerification extends SubscriberBlackboxVerification&lt;Long&gt; {<br/>    public FibonacciSubsciberVerification(){<br/>        super(new TestEnvironment());<br/>    }<br/>    @Override<br/>    public Subscriber&lt;Long&gt; createSubscriber() {<br/>        return new FibonacciSubscriber();<br/>    }<br/>    @Override<br/>    public Long createElement(int element) {<br/>        return new Long(element);<br/>    }<br/>}</pre>
<p>Let's run the test case to determine whether our subscriber meets the Reactive Streams criteria:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f3a2076d-7cf3-48bd-a595-41feec222b65.png"/></div>
<p class="western">Here, we can <span>also</span><span> find a large number of broken test cases. These broken test cases define the behavior for a subscriber. We could fix these, but the better option would be to use Reactor to create our services. I</span>n the following section, we will describe the publisher and subscriber implementations available in Reactor. These implementations conform to the specification behaviors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive Streams comparison</h1>
                </header>
            
            <article>
                
<p class="western">Before we jump into Reactor, let's compare the Streams model with some of the existing similar APIs, such as the <kbd>java.util.Observable</kbd> <span>interface and the JMS API. We will try to determine the similarities and the key differences between the APIs.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Observable interface</h1>
                </header>
            
            <article>
                
<p>The <kbd>java.util.Observable</kbd> interface implements the Observer pattern, which can be co-related here. However, all similarities end here. If we look at the <kbd>Observable</kbd> interface, we have the following methods:</p>
<pre>public class Observable {<br/>  void addObserver (Observer o);<br/>  void deleteObserver (Observer o);<br/>  void deleteObservers();<br/>  void notifyObservers();<br/>  void notifyObserver(int arg);<br/>  int countObservers();<br/>  boolean hasChanged();<br/>}</pre>
<p>Let's look at the <kbd>Observer</kbd> interface before we determine the differences:</p>
<pre>public interface Observer{<br/>  void update(Observable o, Object arg)<br/>}</pre>
<p>If we look at the <kbd>Observable</kbd> and <kbd>Observer</kbd> interfaces, we can see that they are all about a single event and its state. The Observable API has the responsibility of determining a change and publishing it to all interested parties. On the other hand, the <kbd>Observer</kbd> only listens to the change. This is not what we are modeling with the <kbd>Publisher</kbd> and <kbd>Subscriber</kbd> interface. The <kbd>Publisher</kbd> interface is responsible for generating unbounded events, unlike the Observable, which is all about single entity state changes. The <kbd>Subscriber</kbd>, on the other hand, lists all kinds of events, such as data, error, and completion.</p>
<p>Furthermore, the <kbd>Observable</kbd> maintains an active list of observers. It has the responsibility of removing observers that are no longer interested in the event. This is not the same as the <kbd>Publisher</kbd>, which is only responsible for subscriptions. The <kbd>Subscriber</kbd> makes the decision to close the subscription, at its will.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Java Messaging Service API</h1>
                </header>
            
            <article>
                
<p>Let's look at how Reactive Streams compares to the <strong>Java Messaging Service (JMS)</strong> API. The JMS specification describes a <kbd>Queue</kbd> and a <kbd>Topic</kbd>, to which a producer and a consumer can connect:</p>
<pre>@Resource(lookup = "jms/Queue")<br/>private static Queue queue;<br/><br/>@Resource(lookup = "jms/Topic")<br/>private static Topic topic;<br/>Session session = connection.createSession(false,Session.AUTO_ACKNOWLEDGE);<br/>MessageProducer producer = session.createProducer(queue);<br/>MessageConsumer consumer = session.createConsumer(topic)</pre>
<p>Here, the producer  is responsible for generating unbounded events on the queue or topics, while the consumer actively consumes the events. The producer and consumer are working in isolation, at their own rates. The task of managing the subscription is taken care of by the JMS broker. This is different from the Subscription API, where backpressure plays a major role in event generation. There is also no event modeling, like subscription, error, or completion. The JMS connection is like a never-ending stream of data. It cannot provide completion or error events. If we need to support this, custom objects must be modeled first.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning about the Reactor Core API</h1>
                </header>
            
            <article>
                
<p>The Reactor project is divided into different modules. The <kbd>reactor-core</kbd> module is the central library, aimed at providing implementations for Reactive Streams. The library provides Flux and Mono, which are two different implementations of the <kbd>Publisher</kbd> interface. The two publishers are different in terms of the number of events that they can emit. Flux can emit infinite sequences of elements, but the Mono API makes it possible to emit a maximum of one element. Let's cover these APIs in detail, in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Flux API</h1>
                </header>
            
            <article>
                
<p><kbd>Flux&lt;T&gt;</kbd> is a general purpose reactive publisher. It represents a stream of asynchronous events with zero or more values, optionally terminated by either a completion signal or an error. It is important to note that a Flux emits the following three events:</p>
<ul>
<li><strong>Value</strong> refers to the values generated by the publisher</li>
<li><strong>Completion</strong> refers to a normal termination of the stream</li>
<li><strong>Error</strong> refers to an erroneous termination of the stream:</li>
</ul>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/0f8368f4-1139-401a-9893-4795107b1b22.jpg" style=""/></div>
<p> All of the preceding events are optional. This can lead to streams of the following types:</p>
<ul>
<li><strong>Infinite stream</strong>: A publisher generating only value events, and no terminal events (completion and error)</li>
<li><strong>Infinite empty stream</strong>: A stream generating no value events and no terminating events</li>
<li><strong>Finite stream</strong>: A publisher generating <em>N</em> finite values, followed by a terminal event</li>
<li><strong>Empty stream</strong>: A publisher generating no value events, and only terminal events</li>
</ul>
<p class="mce-root"/>
<p>Flux supports the generation of all preceding variations, so it can be used for most of the generic use cases. It can also generate sequences of alerts for an application. The alerts are an infinite stream of values, with no terminal. Flux can also be used to stream order data from an order database. The order values get terminated at the last order value. It may be the case that there are no orders for a particular product type, making the stream empty for that type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating the Flux API</h1>
                </header>
            
            <article>
                
<p class="western">The <kbd>Flux&lt;T&gt;</kbd> API supports stream generation from various sources, such as individual values, collections, Java 8 streams, and more. It can also be used to generate a stream from a custom logic, or from an existing reactive publisher. We will discuss all of these options in detail in upcoming sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Flux.just method</h1>
                </header>
            
            <article>
                
<p>This is the simplest method for Flux generation. It takes a set of values, such as <kbd>var-args</kbd>, and generates a finite Flux stream with them. Each of the values specified as <kbd>var-args</kbd> forms a value event of the Flux. A completion event is published after publishing all <span>of the </span><span>specified values:</span></p>
<pre style="padding-left: 30px">Flux.just("Red");<br/>Flux.just("Red", "Blue", "Yellow", "Black");<br/>Flux.just(new Person("Rahul"), new Person("Rudra"));</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Flux.from methods</h1>
                </header>
            
            <article>
                
<p>The <kbd>From</kbd> methods can be used to generate a Flux from various sources, such as arrays, collections, and so on. In this case, all of the values are identified as multi-valued datasets beforehand. The generated Flux publishes the value events for each value in the original dataset, followed by a completion event. The offered methods have the following variants:</p>
<ul>
<li><kbd>Flux.fromArray</kbd>: This is used to build a stream from an array of a type.</li>
<li><kbd>Flux.fromIterable</kbd>: This is used to build a stream from collections. All collections are of the <kbd>Iterable&lt;T&gt;</kbd> type, which can be passed to this to generate the intended stream.</li>
</ul>
<ul>
<li><kbd>Flux.fromStream</kbd>: This is used to build a Flux from an existing Java 8 stream or a Java 8 stream supplier. Consider the following code:</li>
</ul>
<pre style="padding-left: 60px">Flux.fromArray(new Integer[]{1,1,2,3,5,8,13});<br/>Flux.fromIterable(Arrays.asList("Red", "Blue", "Yellow", "Black"));<br/>Flux.fromStream(IntStream.range(1,100).boxed());</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Utility methods</h1>
                </header>
            
            <article>
                
<p>Flux offers methods to generate infinite streams and empty streams, or to convert an existing Reactive Stream publisher to Flux. These methods are required to generate streams that can be combined with other streams, using the available operators, as follows:</p>
<ul>
<li class="western"><kbd>Flux.empty</kbd>: This method generates an empty stream with no values and only completion.</li>
<li class="western"><kbd>Flux.error</kbd>: <span>This method generates</span> an error stream with no values and only specified errors.</li>
<li class="western"><kbd>Flux.never</kbd>: <span>This method generates</span> a stream with no events at all. It does not generate events of any type.</li>
<li><kbd>Flux.from</kbd>: <span>This method</span> takes an existing reactive publisher and generates a Flux from it.</li>
<li><kbd>Flux.defer</kbd>: This method is used to build a lazy reactive publisher. The method takes a Java 8 supplier to instantiate a subscription-specific Reactive Stream publisher. The publisher instance is only generated when a subscriber makes a subscription to the Flux.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Flux.generate method</h1>
                </header>
            
            <article>
                
<p>Flux supports programmatic event generation. In the previous chapter, we used the API to generate Fibonacci events. This is an advanced usage method of the API, and it involves some more components. We will cover these in detail in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SynchronousSink</h1>
                </header>
            
            <article>
                
<p>The sink gets bounded to a subscriber of the publisher. It gets invoked via the consumer function, when a subscriber asks for data. For each invocation, the sink can be used to generate a <span><span>maximum of </span></span>one value event at a time. The sink can raise additional <kbd>onCompletion</kbd> or error events during the invocation.</p>
<p>It is important to note that the events generated by sink are synchronously consumed at the subscriber end. Let's reflect on<span> the Fibonacci test that we wrote in the previous chapter:</span></p>
<pre style="padding-left: 30px">Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(<br/>        () -&gt; Tuples.&lt;Long, Long&gt;of(0L, 1L),<br/>        (state, sink) -&gt; {<br/>            sink.next(state.getT1());<br/>            System.out.println("generated "+state.getT1());<br/>            return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>        });<br/>fibonacciGenerator.take(size).subscribe(t -&gt; {<br/>    System.out.println("consuming "+t);<br/>    fibonacciSeries.add(t);<br/>});</pre>
<div class="packt_tip">Generating more that one event in the sink leads to <kbd>java.lang.IllegalStateException: More than one call to onNext</kbd>.</div>
<p class="mce-root">We have added additional print statements while generating and consuming numbers. Let's run our tests to see the output, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1ae70d0b-1dc7-4672-9610-fd500cf07597.png"/></div>
<p>The consumer and producer statements are generated in an alternative manner. We can easily deduce that each number is consumed before the next number is generated. The Generate API is offered in multiple variants, and the sink can be used with or without an initial state. In our <kbd>FibonacciGenerator</kbd>, we used this with a state that is initialized on a per-subscriber basis. Optionally, we can also provide a terminal function, which gets invoked upon the termination of the events stream. This means that it will occur after the sink invokes an error or completion event. The terminal function can be used to perform any cleanup associated with the state.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Flux.create</h1>
                </header>
            
            <article>
                
<p><kbd>Flux.create</kbd> is another mechanism for generating events programmatically. It takes a <kbd>FluxSink</kbd>, which is capable of generating any number of events. The API is more generic than the <kbd>Generate</kbd> methods discussed in the previous section. The <kbd>FluxSink</kbd> is capable of generating events asynchronously. Moreover, it does not take subscription cancellation or backpressure into account. This means that even if the subscriber has cancelled its subscription, the create API will continue to generate events. All implementations must listen for the <kbd>cancel</kbd> event and explicitly initiate stream closure.</p>
<p>As for backpressure, the producer keeps generating the events without looking into any demand from the subscriber. These events are  buffered and dropped <span>by default</span><span> if the subscription is lost.</span></p>
<p>To see how the two are different, let's modify our <kbd>FibonacciGenerator</kbd> to use a <kbd>FluxSink</kbd>. Some of the key differences are highlighted as follows:</p>
<ul>
<li>There is no initial seed state in the API</li>
<li>The<span> </span><kbd>FluxSink</kbd><span> </span>keeps generating the events, irrespective of the subscription state</li>
<li>We can generate any number of events in the sink</li>
<li>The<span> </span><kbd>OnDispose</kbd><span> </span>event can be listened to in order to perform any cleanup, or to stop publishing events</li>
<li>All events that are generated are buffered and dropped once the subscription is cancelled</li>
</ul>
<p>It is important to note that the<span> </span><kbd>FluxSink</kbd><span> </span>provides lifecycle callback methods, which can be used to perform additional cleanups, or any other action, as follows:</p>
<ul>
<li><kbd>OnCancel</kbd><em>:</em> This method gets invoked when the subscription is cancelled.</li>
<li><kbd>OnDispose</kbd>: This<span> </span><span>method </span>gets invoked when the subscription is closed due to a cancel, close, or error event.</li>
<li><kbd>OnRequest</kbd>: This method is invoked with the value specified by the subscriber. It can be used to build a pull data model. When the method is invoked, the next method can be invoked for the specified number of the values:</li>
</ul>
<pre style="padding-left: 30px">@Test<br/>public void testFibonacciFluxSink() {<br/>    Flux&lt;Long&gt; fibonacciGenerator = Flux.create(e -&gt; {<br/>        long current = 1, prev = 0;<br/>        AtomicBoolean stop = new AtomicBoolean(false);<br/>        e.onDispose(()-&gt;{<br/>            stop.set(true);<br/>            System.out.println("******* Stop Received ****** ");<br/>        });<br/>        while (current &gt; 0) {<br/>            e.next(current);<br/>            System.out.println("generated " + current);<br/>            long next = current + prev;<br/>            prev = current;<br/>            current = next;<br/>        }<br/>        e.complete();<br/>    });<br/>    List&lt;Long&gt; fibonacciSeries = new LinkedList&lt;&gt;();<br/>    fibonacciGenerator.take(50).subscribe(t -&gt; {<br/>        System.out.println("consuming " + t);<br/>        fibonacciSeries.add(t);<br/>    });<br/>    System.out.println(fibonacciSeries);<br/>}</pre>
<p>Let's check the output that's generated, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8d554e76-906e-43f3-9558-95d0437731c1.png"/></div>
<div class="packt_infobox">
<p class="western"><kbd>Flux</kbd> also provides a <kbd>Push</kbd> method. This is similar to the <kbd>create</kbd> method, but the process of how error and complete events are invoked varies. These events must be invoked in a synchronous manner, from a single thread producer.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Mono API</h1>
                </header>
            
            <article>
                
<p>Now that we have covered the Flux API, let's look at Mono. It is capable of generating a maximum of one event. This is a specific use case for Flux, capable of handling one response model, such as data aggregation, HTTP request-response, service invocation response, and so on. It is important to note that a Mono emits the following three events:</p>
<ul>
<li><strong>Value</strong> refers to the single value generated by the publisher</li>
<li><strong>Completion</strong> refers to a normal termination of the stream</li>
<li><strong>Error</strong> refers to an erroneous termination of the stream</li>
</ul>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/16f7f796-cf40-4de3-b977-6ef7876bb97b.jpg" style=""/></div>
<p>Since Mono is a subset of Flux, it supports a subset of Flux operators. Let's look at how to build a Mono.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating a Mono</h1>
                </header>
            
            <article>
                
<div class="textLayer">
<p>The <kbd>Mono&lt;T&gt;</kbd> API supports stream generation from various single-value sources, like individual values, method invocations, Java 8 supplier functions, and so on. It can also be used to generate a stream from a custom logic or from an existing reactive publisher. We will now discuss these in detail.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Mono.just method</h1>
                </header>
            
            <article>
                
<p>The <kbd>Mono.just</kbd> method is the simplest method for Mono generation. It takes a single value and generates a finite Mono stream from it. A completion event is published after publishing the specified value:</p>
<pre>Mono.just("Red");<br/>Mono.justOrEmpty(value);<br/>Mono.justOrEmpty(Optional.empty());</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Mono.from method</h1>
                </header>
            
            <article>
                
<p>The <kbd>From</kbd> methods are used to  build a Flux when the value can be determined from an existing source. Unlike the Flux methods, where the sources are multi-valued, the sources for Mono are single-valued. These methods are offered in the following variants:</p>
<ul>
<li><kbd>fromCallable</kbd>: This method generates Mono with one value, followed by the completion event. If multi-valued datasets, like arrays or collections, are returned from <kbd>Callable</kbd>, then the complete dataset is pushed as an object in the single event.</li>
<li><kbd>fromFuture</kbd>: This method generates Mono with one value, followed by the completion event.</li>
<li><kbd>fromSupplier</kbd>: This method generates Mono with one value, followed by the completion event. </li>
<li><kbd>fromRunnable</kbd>: This method generates Mono with no value and only a completion event. This can be explained by using the following code:</li>
</ul>
<pre style="padding-left: 60px">Mono.fromSupplier(() -&gt; 1);<br/>Mono.fromCallable(() -&gt; new String[]{"color"}).subscribe(t -&gt; System.out.println("received " + t));<br/>Mono.fromRunnable(() -&gt; System.out.println(" ")).subscribe(t -&gt; System.out.println("received " + t), null, () -&gt; System.out.println("Finished"));</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Utility methods</h1>
                </header>
            
            <article>
                
<p>Mono offers methods to generate empty/error streams or to convert an existing Reactive Stream publisher to Mono. These methods are required to generate streams that can be combined with others by using the available operators, as follows:</p>
<ul>
<li><kbd>Mono.empty</kbd>: Generates a stream with no value and only a completion.</li>
<li><kbd>Mono.error</kbd><em>:</em> Generates a stream with no value and only a specified error.</li>
<li><kbd>Mono.never</kbd>: Generates a stream with no events at all. It does not generate an event of any type.</li>
<li><kbd>Mono.from</kbd>: Generates a Mono stream from an existing stream publisher.</li>
<li><kbd>Mono.defer</kbd>: This method is used to build a lazy reactive publisher. It also takes a Java 8 supplier to instantiate a subscription-specific Reactive Stream publisher. The publisher instance is only generated when a subscriber makes a subscription to the Mono.</li>
</ul>
<p class="mce-root"/>
<p>It is important to note that a Mono can be generated by using a Flux source. In that case, Mono uses  the first event published from the Flux, as follows:</p>
<pre style="padding-left: 30px">Mono.from(Flux.just("Red", "Blue", "Yellow", "Black")).subscribe(t -&gt; System.out.println("received " + t))<br/><br/>**** Output ******<br/><strong>received Red</strong><br/><br/><strong>Process finished with exit code 0</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mono.create</h1>
                </header>
            
            <article>
                
<p>In addition to the <kbd>Flux.create</kbd> methods, there is a <kbd>Mono.create</kbd> method. This method provides a <kbd>MonoSink</kbd>, which can be used to generate a value, completion, or error event. Unlike the Flux methods, where we are generating <em>N</em> events, if we generate more events in Mono, they are dropped. There is also no handling for backpressure, as there is only one event.</p>
<p>The API does not take subscription cancellations<span> </span><span>into account</span><span>. This means that even if the subscriber has cancelled its subscription, the create method still generates its event. Implementors must register custom hooks to lifecycle events and perform stream closures.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building subscribers to Flux and Mono</h1>
                </header>
            
            <article>
                
<p>Reactor Flux and Mono provide a wide choice of subscribe methods. Reactive publishers raise four types of events, namely subscription, value, completion, and error. Individual functions can be registered for each of the events. We can also register a subscriber without listening to any kind of event. Let's look at all of the possible variants offered, as follows:</p>
<pre>fibonacciGenerator.subscribe(); <strong>(1)</strong><br/><br/>fibonacciGenerator.subscribe(t -&gt; System.out.println("consuming " + t));   <strong>(2)</strong><br/><br/>fibonacciGenerator.subscribe(t -&gt; System.out.println("consuming " + t),<br/>                e -&gt; e.printStackTrace() ); <strong>(3)</strong><br/><br/>fibonacciGenerator.subscribe(t -&gt; System.out.println("consuming " + t),<br/>                e -&gt; e.printStackTrace(),<br/>                ()-&gt; System.out.println("Finished")); <strong>(4)</strong><br/><br/>fibonacciGenerator.subscribe(t -&gt; System.out.println("consuming " + t),<br/>                e -&gt; e.printStackTrace(),<br/>                ()-&gt; System.out.println("Finished"),<br/>                s -&gt; System.out.println("Subscribed :"+ s)); <strong>(5)</strong></pre>
<p>The preceding code shows all of the <kbd>Subscribe</kbd> methods:</p>
<ol>
<li>No event is consumed, as shown in line <kbd>1</kbd>.</li>
<li>Only value events are consumed, as shown in line <kbd>2</kbd>.</li>
<li>Along with value events, we also print error stack-trace, as shown in line <kbd>3</kbd>.</li>
<li>We can listen to value, error, and completion events, as shown in line <kbd>4</kbd>.</li>
<li>We can listen to value, error, completion, and subscription events, as shown in line <kbd>5</kbd>.</li>
</ol>
<div class="packt_tip">All <kbd>Subscribe</kbd> methods return a <kbd>Disposable</kbd> type. This type can also be used to cancel the subscription.</div>
<p>At times, we may determine that the <kbd>Subscribe</kbd> methods are not good enough. We must create a custom subscriber with its own handling. Reactor provides a <kbd>reactor.core.publisher.BaseSubsciber&lt;T&gt;</kbd> for these situations. Instead of implementing the Reactive Stream <kbd>Subscriber</kbd>, reactor recommends implementing the <kbd>BaseSubscriber</kbd> abstract class:</p>
<pre>BaseSubscriber&lt;Long&gt; fibonacciSubsciber= new BaseSubscriber&lt;Long&gt;() {<br/>            @Override<br/>            protected void hookOnSubscribe(Subscription subscription) { }<br/><br/>            @Override<br/>            protected void hookOnNext(Long value) {}<br/><br/>            @Override<br/>            protected void hookOnComplete() { }<br/><br/>            @Override<br/>            protected void hookOnError(Throwable throwable) {}<br/><br/>            @Override<br/>            protected void hookOnCancel() {}<br/>         <br/>        };</pre>
<p>If we look at the <kbd>BaseSubscriber</kbd> implementation, we will see the following:</p>
<ul>
<li>Each individual event can be handled in a separate hook method.</li>
<li>It captures the subscription and makes it accessible by using the upstream method. This method can be invoked in any lifecycle method.</li>
<li>It also handles backpressure by providing <kbd>request(long)</kbd> methods. The default method is to request values one by one. However, the subscriber can raise additional demands by using the <kbd>request</kbd> method.</li>
<li>It also presents the <kbd>requestUnbound()</kbd> method, which disables backpressures.</li>
</ul>
<p>Once we have the custom subscriber, it can be invoked by using the <kbd>subscribe()</kbd> method, available with Flux and Mono.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lifecycle hooks</h1>
                </header>
            
            <article>
                
<p>The publisher-subscriber communication generates events throughout the lifecycle of a Reactive Stream. Reactor provides corresponding lifecycle methods that can be used to hook custom logic to each of the said events, as shown in the following table:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<div class="CDPAlignCenter CDPAlign"><strong>Event</strong></div>
</td>
<td>
<div class="CDPAlignCenter CDPAlign"><strong>Method</strong></div>
</td>
</tr>
<tr>
<td>Subscribe event</td>
<td><kbd>doOnSubscribe</kbd></td>
</tr>
<tr>
<td>Request event, for <em>N</em> items from the subscriber</td>
<td><kbd>doOnRequest</kbd></td>
</tr>
<tr>
<td>Value event, for all generated values</td>
<td><kbd>doOnNext</kbd></td>
</tr>
<tr>
<td>Error event, for any error by the publisher</td>
<td><kbd>doOnError</kbd></td>
</tr>
<tr>
<td>Completion event</td>
<td><kbd>doOnCompletion</kbd></td>
</tr>
<tr>
<td>Cancel event, for cancellation by the subscriber</td>
<td><kbd>doOnCancel</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p>In addition to the preceding methods, there are the following methods:</p>
<ul>
<li><kbd>doOnEach</kbd>: This method is executed for all publisher events raised in the stream processing.</li>
<li><kbd>doOnTerminate</kbd>: This method is executed for stream closure due to an error or completion. It does not take cancellation into account.</li>
<li><kbd>doFinally</kbd>: This method is executed for stream closures due to errors, completions, or cancellations.</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Trying a hands-on project</h1>
                </header>
            
            <article>
                
<p>Now that we have discussed Reactor interfaces in detail, let's try to generate a factorial series using Reactor. Given a number, we want to generate a factorial of all numbers less than or equal to the provided number. In number theory, a factorial is described as follows:</p>
<div class="packt_quote">"The factorial of a positive number 'n' is  defined  as n! = n(n-1)(n-2)...2.1 For example, 5 ! = 5 × 4 × 3 × 2 × 1 = 120."</div>
<p>Now, let's try to build a factorial stream function that takes a number and attempts to generate a factorial for every number, from 0 to <em>N</em>:</p>
<pre style="padding-left: 30px">public class FactorialService {<br/><br/>    Flux&lt;Double&gt; generateFactorial(long number) {<br/>        Flux&lt;Double&gt; factorialStream = Flux.generate(<br/>                () -&gt; Tuples.&lt;Long, Double&gt;of(0L, 1.0d),<br/>                (state, sink) -&gt; {<br/>                    Long factNumber = state.getT1();<br/>                    Double factValue = state.getT2();<br/>                    if (factNumber &lt;= number)<br/>                        sink.next(factValue);<br/>                    else<br/>                        sink.complete();<br/>                    return Tuples.of(factNumber + 1, (factNumber + 1) * factValue);<br/>                });<br/>        return factorialStream;<br/>    }<br/>}</pre>
<p>In the preceding code, we performed the following:</p>
<ol>
<li>The initial <kbd>factorialNumber</kbd> was set to <kbd>0</kbd>, with the factorial as <kbd>1</kbd>.</li>
<li>We then checked whether the <kbd>factorialNumber</kbd> was less than or equal to the passed number, and published the factorial value for it.</li>
<li>If <kbd>factorialNumber</kbd> is more than the passed number, then we publish the completion.</li>
<li>We incremented the <kbd>factorialNumber</kbd> and computed the factorial for it.</li>
</ol>
<p class="mce-root"/>
<p>The preceding flow is quite simple, but it makes it possible to utilize various Flux components. Since the factorial service is ready, we need to validate it by subscribing to it. In the following test case, we do the following things:</p>
<ol>
<li>Invoke the generator for factorial numbers up to <kbd>10</kbd>.</li>
<li>Display each generated number by using the<span> </span><kbd>doOnNext()</kbd> lifecycle hook.</li>
<li>Use the<span> </span><kbd>last()</kbd> operator to get the last value. We will cover operators in the next chapter.</li>
<li>Compare and assert the value in the subscriber value event function:</li>
</ol>
<pre style="padding-left: 60px">public class FactorialServiceTest {<br/><br/>    @Test<br/>    public void testFactorial() {<br/>        Flux&lt;Double&gt; factorialGenerator = new FactorialService().generateFactorial(10);<br/>        factorialGenerator<br/>                .doOnNext(t -&gt; System.out.println(t))<br/>                .last()<br/>                .subscribe(t -&gt; assertEquals(3628800.0, t, 0.0));<br/>    }<br/>}</pre>
<p>Now, let's run the test case to view the output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c60ccc9f-5f0d-4172-ac28-11183fe94bb5.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we provided a detailed discussion of the publisher and the subscriber interfaces of Reactive Streams. We attempted to implement these interfaces to illustrate that there are many non-explicit rules for them. These rules have been converted into the Reactive Streams TCK, against which all implementations should be validated. We also compared the publisher-subscriber pattern with the existing Observer and JMS patterns used in Java. Next, we took a detailed look at the Flux and Mono implementations available in Reactor. We looked at methods for creating them, and then subscribed to the generated streams.</p>
<p>In the next chapter, we will look at the operators that can be used to modify the generated streams.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>How can we validate Reactive Stream publisher and subscriber implementations?</li>
<li>How is the Reactive Stream publisher-subscriber model different from the JMS API?</li>
<li>How is the Reactive Stream publisher-subscriber model different from the Observer API?</li>
<li>What is the difference between Flux and Mono?</li>
<li>What is the difference between <kbd>SynchronousSink</kbd> and <kbd>FluxSink</kbd>?</li>
<li>What are the different lifecycle hooks available in Reactor?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>For more information, please refer to the video under the Reactive Streams specification, as this is part of Java 9: <a href="https://www.packtpub.com/application-development/reactive-java-9-video">https://www.packtpub.com/application-development/reactive-java-9-video</a></li>
<li>To gain in-depth knowledge on building microservices using Akka as a Reactive Streams library, please refer to the following video: <a href="https://www.packtpub.com/application-development/building-microservice-akka-http-video">https://www.packtpub.com/application-development/building-microservice-akka-http-video</a></li>
</ul>


            </article>

            
        </section>
    </body></html>