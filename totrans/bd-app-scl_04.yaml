- en: Chapter 4. Developing Reactive Backing Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to Bootstrap your application using
    Activator, and we developed our web application using Scala and the Play framework.
    Now we will enter into the reactive world of RxJava and RxScala.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming principles and the Reactive Manifesto
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the importance of non-blocking IO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observables, functions, and error handling with Rx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring our controllers and models to call our services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding RxScala to our services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building applications today is harder than it was before. Everything now is
    more complex: we have to use more cores in processors, and we have cloud-native
    applications with hundreds of machines for a single service. Concurrent programming
    has always been hard, and it will always be so, because it is difficult to model
    time. In order to address this, we need to have a reactive style of architecture.
    In order to be able to handle more users and scale our applications, we need to
    leverage Async and non-blocking IO. To help us with this task, we can rely on
    RxJava and RxScala. Being reactive is not only about code but also about architectural
    principles.'
  prefs: []
  type: TYPE_NORMAL
- en: The Reactive Manifesto captures these principles very well, and there are a
    couple of technologies that follow these principles in order to be fully reactive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Reactive Manifesto can be shown as in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with reactive programming](img/image00266.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For more information, you can visit [http://www.reactivemanifesto.org/](http://www.reactivemanifesto.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Reactive Manifesto describes what this reactive architecture/system looks
    like. Basically, there are the following four core principles underlining the
    reactive idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Responsive**: The system should respond in a timely manner. In other words,
    the system should detect problems quickly, and deal with them effectively, apart
    from providing rapid and consistent response time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilient**: The system should stay responsive even after failure. This is
    done via replication containment, isolation, and delegation ([https://en.wikipedia.org/wiki/Delegation_pattern](https://en.wikipedia.org/wiki/Delegation_pattern)).
    Containment and isolation are ideas that come from the naval industry, and are
    defined by the bulkhead pattern ([https://en.wikipedia.org/wiki/Bulkhead_(partition)](https://en.wikipedia.org/wiki/Bulkhead_(partition))).
    Failures are contained at each component. Doing so makes sure that one system''s
    failure does not affect other systems. Recovery is delegated to another system,
    and not to the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elastic**: The ability to increase and decrease resources for the system.
    This requires you design your system without **Single Point Of Failure** (**SPOF**),
    and design using shards and replication. Reactive systems are predictive and cost-effective.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message-driven**: Reactive systems rely on asynchronous message passing to
    ensure loose coupling, isolation, and location transparency. By doing so, we can
    delegate failures as messages. This gives us elasticity, load management, and
    flow control. It''s even possible to apply back-pressure (also known as throttling)
    when needed. All this should be done with non-blocking communication for better
    resource utilization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alright, let's use these principles practically in our application with RxScala.
    RxScala is just a Scala wrapper for RxJava, but it is better to use because it
    makes the code more functional, and you don't need to create objects such as `Action1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our application, we have three major resources: products, reviews, and images.
    All products must have a price, so we will built a fully reactive price generator
    with the Play framework, RxScala, and Scala right now.'
  prefs: []
  type: TYPE_NORMAL
- en: So first of all, we will play with RxScala in our Play application, then we
    will create a separate microservice, make reactive calls to that microservice,
    and retrieve our price suggestion for that service. All data flow transformations
    are using observables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the routes for this controller at `ReactiveWebStore/conf/routes` ,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two routes here: one for a regular action, and another for an Async
    action that will return a Scala Future. Let''s create a new controller called
    `Rx Controller.scala`. This controller needs to be located at `ReactiveWebStore/app/controller`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at `RxController`, which is our reactive RxScala simple
    controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, in the very first method called `prices`, we return a regular Play framework
    Action. We receive `IPriceService` via dependency injection. This `IPriceService`
    is a reactive service, because it uses observables. So we call a method, `generatePrices`,
    which will return `Observable[Double]`. This will be our source observable, that
    is, the data source of our computation. Moving forward, we create a new observable
    subscribing into the source observable, and then we apply some transformation.
    For instance, we take just one element, and then we can perform transformation
    using `flatMap`. For this case, we do not really apply transformations. We use
    `flatMap` to simply print what we got, and then continue the chain. The next step
    is to call `toBlocking`, which will block the thread until the data is back. Once
    the data is back, we get the first element, which will be a double, and we return
    `Ok`.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking sounds bad and we don't want that. Alternatively, we can use the `async`
    controller in the Play framework, which won't block the thread and return a Future.
    So that's the second method, called `pricesAsync`. Here we have similar observable
    code. However, in the end, we return a Future which is not blocking. However,
    we call `toBlocking` from the observable that will block the call, thus making
    it the same as the previous method. To be clear, Action is not bad. By default,
    everything is Async in Play, because even if you don't return an explicit Future,
    the Play framework creates a promise for `y` and makes you code Async. Using HTTP,
    you will block the thread at some point. If you want to be 100% non-blocking from
    end to end, you need to consider a different protocol such as web sockets.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the service now. This service, and other services, need
    to be located at `ReactiveWebStore/apps/services`. First we will create `trait`
    to define the service behavior.
  prefs: []
  type: TYPE_NORMAL
- en: IPriceService - Scala trait
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you can see in the following code, we defined `IPriceService` with just
    one operation, that is, `generatePrices`, which returns `Observable[Double]`.
    The next step now is to define the service implementation. This code needs to
    be located in the same services folder as the previous trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: PriceService - RxScala PriceService implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First we create `PublishSubject`, which is a way to generate data into observables.
    Scala has a nice way of generating infinite sequences using `Stream.continually`.
    So we pass a function which generates double random numbers from 0 to 1,000\.
    This will happen forever and, because this is an expensive computation, we run
    it into a Future. The right thing to do will be to use a method after `Stream`,
    because this will finish the computation. For the sake of the exercise, we will
    keep it this way for now.
  prefs: []
  type: TYPE_NORMAL
- en: Each double random number is published into `PublishSubject` by the `onNext`
    method. Now let's move to the `generatePrices` method, which uses three observables
    to generate the number for us. To be clear, of course we could do a simpler solution
    here. However, we are doing it this way to illustrate the power of observables,
    and how you can use them in practice.
  prefs: []
  type: TYPE_NORMAL
- en: We have `Even` and `Odd` observables, both subscribing to `PublishSubject`,
    so they will receive infinite double numbers. There is a `flatMap` operation to
    add `10` to the number. Keep in mind that everything you do needs to be in an
    observable. So when you do transformations with `flatMap`, you always need to
    return an observable.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we apply the filter function to get only even numbers on the `Even`
    observable and only odd numbers on the `Odd` observable. All this happens in parallel.
    `Even` and `Odd` observables do not wait for each other.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to merge both observables. We create a third observable that
    starts empty and then merges the infinite doubles from the `Even` observable with
    the infinite doubles from the `Odd` observable. Now is the time to limit the computation
    to only 10 numbers. We don't know how many odd or how many even numbers will be
    there because of Async. If you wish to control the number of odds and evens, you
    need to apply the `take` function on each observable.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we apply `foldLeft` to sum all the numbers and get a total. However,
    when we do that, we get only 90% of the numbers. This last observable is what
    is returned to the controller. Nothing is blocked here, and it's all Async and
    reactive.
  prefs: []
  type: TYPE_NORMAL
- en: 'You maybe wondering why `Stream.Continuously` generates different values all
    the time. That happens because we use a Call-by-Name function in Scala. We import
    the `nextDouble` function, and pass a function instead of the value of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We need to register this service in Guice in `Module.scala` located in the default
    package at `ReactiveWebStore/app`.
  prefs: []
  type: TYPE_NORMAL
- en: Guice Injection - Module.scala
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your `Module.scala` file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In order to compile and run the preceding code, we need to add an extra SBT
    dependency. Open `build.sbt`, and add RxScala. We will also add another dependency,
    which is ws, a play library to make web service calls. We will use it later in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `build.sbt` should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now we can compile and run this code using `activator run`.
  prefs: []
  type: TYPE_NORMAL
- en: We can call this new route now using a CURL call. If you prefer, you can just
    open your browser and do it there.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Guice Injection - Module.scala](img/image00267.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Great! We have RxScala working with the Play framework. Now we will refactor
    our code to make it even more interesting. So we will create a microservice using
    the Play framework, and we will externalize this random number generator to the
    microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a new Play framework application. We will pick the option
    number `6) play-scala` application template. Open your console, and then type
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Guice Injection - Module.scala](img/image00268.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s create the routes on `ng-microservice`. We won''t have any UI here,
    since this will be a microservice. We need to add a route at `ng-microservice/conf/routes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now let's define the controller. This is not a regular controller, because this
    one won't serve UI views. Instead, it will serve JSON to the microservice consumers.
    Here we will have just one consumer, which will be `ReactiveWebStore`. However,
    it is possible to have as many consumers as you wish such as other microservices
    or even mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: NGServiceEndpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this controller, we just have two routes. The routes are `double` and `doubles`.
    The first route returns a double from the service, and the second one returns
    a list of doubles generated in a batch. For the second method, we get a list of
    doubles and transform that list in JSON using the Play framework utility library
    called `Json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The next step is create `trait` for the microservice. This trait is also the
    service contract in **Service Oriented Architecture** (**SOA**) terms, that is,
    the capabilities that the microservice offers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NGContract.scala` file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the Service implementation of this microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This service implementation does not have any RxScala code. However, it is very
    functional. We have two methods implemented here. The methods are `generateDouble`
    and `generateDoubleBatch`, which receive, through parameters, the number of doubles
    you want it to generate for you. For the first operation (`generateDouble`), we
    use `Stream.continually` to generate infinite random doubles, then we multiply
    these numbers by 1,000, and then take just 1 and return it.
  prefs: []
  type: TYPE_NORMAL
- en: The second operation is very similar. However, we have to add some validations
    to make sure that the numbers of double are present. There are a couple of ways
    to do it. One way use the assert method in Scala. The second way is the pattern
    matcher, which is nice because we don't need to write an `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is very common in the Scala community. So we create an option
    that takes the number, and then we pattern-match it. If there is a number present,
    the case `Some` method will be triggered, otherwise, the case `None` will be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'After these validations, we can use `Stream` to generate as many numbers as
    requested. Before we run the code, we need to define the Guice injections. This
    file is located in the default package at `ng-microservice/app/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now its time to compile and run our microservice. Since we already have a play
    application called `ReactiveWebStore` running on `port 9000`, you will have trouble
    if you simply run the microservice. To fix this, we need to run it on a different
    port. Let''s use `9090` for the microservice. Open the console, and execute the
    command `$ activator` followed by `$ run 9090`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can test our microservice by calling the two operations that we have. So
    let's open the web browser and do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The double microservice call at `http://localhost:9090/double` looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![NGServiceEndpoint](img/image00269.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Every time you call this operation, you''ll see a different random double number.
    Now we can try out the next operation: the one you pass for the number of doubles
    you want. This operation will return a list of doubles in the JSON format.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The call for double in batches microservice at `http://localhost:9090/doubles/100`
    looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![NGServiceEndpoint](img/image00270.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It works! We have 100 doubles here. Now that we have a microservice working,
    we can go back to our `ReactiveWebStore` and change our RxScala code. We will
    create new controllers. We will also update the existing code for products to
    call our new code, and suggest a price for the user on the UI, all in a reactive
    manner. Keep in mind that you need to have `ng-microservice` running; otherwise,
    `ReactiveWebStore` won't be able to retrieve doubles.
  prefs: []
  type: TYPE_NORMAL
- en: Play framework and high CPU usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you notice your CPU usage going higher than it should, do not worry; there
    is a fix for it. Actually, the issue is related to SBT. Just make sure that, when
    you run Activator, you pass the following parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ activator -Dsbt.task.forcegc=false`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to `ReactiveWebStore`, let''s create new routes. Open `ReactiveWebStore/conf/routes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the new routes, we need to create the new controller. This controller
    needs to be located with the other controllers at `ReactiveWebStore/app/controllers`.
  prefs: []
  type: TYPE_NORMAL
- en: RndDoubleGeneratorController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `RndDoubleGeneratorController` class file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: All methods in the preceding controller call the service `IRndService`. All
    operations in `RndService` call `ng-microservice`. Here we have some flavors of
    operations, which will be covered in great detail next when we explore the service
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some interesting things here: for instance, for the second operation
    called `rndCall`, we see `Action.async` in use, which means our controller will
    return a Future, and this Future comes from the service. We also execute a `Map`
    to transform the result into an `Ok`.'
  prefs: []
  type: TYPE_NORMAL
- en: The last operation called `rxScalaCallBatch` is the most interesting, and the
    one we will be using for our UI. However, you can use the other one if you wish,
    since they all return doubles, and that's good.
  prefs: []
  type: TYPE_NORMAL
- en: IRndService.scala - Scala trait
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at the service definition. First of all, we need to define a trait
    for the service that will define the operations we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: RndService.scala - RndService implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can move to the real service implementation. This needs to be located
    at `ReactiveWebStore/app/services`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In order to call our microservice (`ng-microservice`), we need to inject a special
    Play framework library called `ws`, a utility library to call web services. We
    inject it by adding the code (`ws:WSClient`) into the class definition.
  prefs: []
  type: TYPE_NORMAL
- en: When you call something with `ws`, it returns a Future. We need to have the
    Future executors in place. That's why the import `defaultContext` is very important,
    and you cannot skip it.
  prefs: []
  type: TYPE_NORMAL
- en: For the method, as you can see, we next call our microservice at `http://localhost:9090/double`
    to get a single double. We map this result, and get the body of the result, which
    will be the double itself.
  prefs: []
  type: TYPE_NORMAL
- en: For this method, we use `Await.result`, which will block and wait for the result.
    If the result is not back in five seconds, this code will fail.
  prefs: []
  type: TYPE_NORMAL
- en: The second method called `call` does the same, but the main difference is that
    we are not blocking the service; instead, we are returning a Future to the controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the last method called `rxScalaCall` does the same: it calls our microservice
    using the `ws` library. However, we return an observable. Observables are great
    because they can used as a Future.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it is time to go check out the final operation and the most interesting
    one. For this same class, we need to add another method such as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `rxScalaCallBatch` in `RndService.scala` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: So, first we create `PublishSubject` in order to be able to produce data for
    the observables. Then we make the `ws` call to our microservice. The main difference
    now is that we call the batches operation and order 10 doubles. This code happens
    in a future, so it is non-blocking.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the `Map` function to transform the result. The `ng-microservice`
    function will return JSON, so we need to deserialize this JSON into Scala objects.
    Finally, we run a pattern matcher in the Future result. If the result is a success,
    it means everything is good. So, for each double, we publish into the observables
    using `PublishSubject`. If the service is down or we have a problem, we publish
    an error to the observables downstream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we create three observables: one for odd numbers, one for even numbers,
    and a third one which will merge the other two and do extra computation. The way
    we did the conversion between Future and Observable is ideal, because it is non-blocking.'
  prefs: []
  type: TYPE_NORMAL
- en: Here we have code very similar to what we had before for the Rx controller.
    The main difference is that we have error handling, because `ng-microservice`
    might never return, as it may be down or just not working. So we need to start
    working with fallbacks. Good fallbacks are key to error handling for Reactive
    applications. Fallbacks should be sort of static; in other words, they should
    not fail at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'We provided two fallback methods: one for the `Odd` Observable and the other
    for the `Even` Observable. These fallbacks are done by setting the method `OnErrorReturn`.
    So for the even one, the fallback is static and the value is 2, and for the odd
    one the value is 1\. This is great, because even with failure our application
    continues to work.'
  prefs: []
  type: TYPE_NORMAL
- en: You might realize we are not using the take function this time. So will this
    code run forever? No, because `ng-microservice` just returns 10 doubles. Finally,
    we merge the observables into a single observable, add all the numbers, get 90%
    of the value, and return an observable.
  prefs: []
  type: TYPE_NORMAL
- en: Module.scala - Guice Injections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now hook this new service in Guice. Let''s change the Guice `Module.scala`
    located at `ReactiveWebStore/apps/Module.scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Next we need to create a JQuery function in JavaScript to call our new controller.
    This function needs to be located at `ReactiveWebStore/public/javascripts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is `price.js`, the JQuery function that calls our controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We just have a single function called `loadPrice`, which receives a document.
    We use the `JQuery.get` method to call our controller, and parse the response,
    adding to the HTML text box called `price`. If something goes wrong, we alert
    the user that it was not possible to load a price.
  prefs: []
  type: TYPE_NORMAL
- en: main.scala.html
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to change our `main.scala` code located at `ReactiveWebStore/app/views/main.scala.html`
    in order to import a new JavaScript function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: product_details.scala.html
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we need to change our product view in order to add a button to load
    the price from the controller. Let''s change the `product_details` view at `ReactiveWebStore/app/views/product_details.scala.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Great! Now we have a button that loads the data from the controller using JQuery.
    You can realize that the button `Load Rnd Price` has an `onClick` property, which
    calls our JavaScript function.
  prefs: []
  type: TYPE_NORMAL
- en: Now you need to open your console and type `$ activator run` to compile and
    run the changes as we did to `ReactiveWebStore`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command will give the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So open you browser at `http://localhost:9000`, and go to the product page to
    see our need feature integrated and working like a charm. Keep in mind that you
    need to have `ng-microservice` working in another console window; otherwise, our
    application will use static fallbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new product feature will be shown at `http://localhost:9000/product/add`
    as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![product_details.scala.html](img/image00271.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So if you click on the **Load Rnd Price** button, you will see something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![product_details.scala.html](img/image00272.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you take a look at the application log in the activator console, you will
    see something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Alright, that's it. We have everything working!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the core principles of reactive application guided
    by the Reactive Manifesto. You also learned how to create reactive applications
    using RxScala. We then explained how to call other internal and external web services
    using the ws library. Then you learned to serialize and deserialize JSON using
    the `Json` Library. Moving on, you learned how to create simple microservices
    using the Play framework support.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue building our application, and learn how
    to test our application with JUnit and ScalaTest.
  prefs: []
  type: TYPE_NORMAL
