<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Customizing and Extending jBPM"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Customizing and Extending jBPM</h1></div></div></div><p>This chapter details the extension points of jBPM. Not every user of jBPM uses the entire tool stack. Users will need to customize/extend jBPM to fit it into their solution architecture. This chapter will show you how jBPM's features can be customized and extended.</p><p>The list of topics that will be covered in the chapter is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Domain-specific processes</li><li class="listitem" style="list-style-type: disc">Writing your custom workitem handlers</li><li class="listitem" style="list-style-type: disc">Customizing the process designer</li><li class="listitem" style="list-style-type: disc">Extending variable persistence</li><li class="listitem" style="list-style-type: disc">Extending user management</li></ul></div><div class="section" title="Custom process nodes"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec43"/>Custom process nodes</h1></div></div></div><p>In <a class="link" href="ch05.html" title="Chapter 5. BPMN Constructs">Chapter 5</a>, <span class="emphasis"><em>BPMN Constructs</em></span>, we introduced the jBPM feature that lets you bind specific Java class<a id="id782" class="indexterm"/> implementations to the execution of a specific process task node type: send/receive tasks, service tasks, and ad hoc tasks.</p><p>These kinds of <span class="emphasis"><em>extensible</em></span> task nodes are often called<a id="id783" class="indexterm"/> <span class="strong"><strong>custom workitems</strong></span>, and the implementing classes that perform the horse work behind the process curtains are called <a id="id784" class="indexterm"/>
<span class="strong"><strong>workitem handlers</strong></span>. This architecture makes jBPM more flexible when it comes to adapting the engine to a particular domain, both in terms of features and tools UI. Let's start by reviewing the basics of the jBPM workitem and handlers.</p><div class="section" title="Workitem and handlers"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec121"/>Workitem and handlers</h2></div></div></div><p>jBPM defines a work item<a id="id785" class="indexterm"/> as a unit of work that is defined inside the scope of a process but can be executed outside the engine; in particular:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It accepts a set of parameters</li><li class="listitem" style="list-style-type: disc">It performs some action</li><li class="listitem" style="list-style-type: disc">It optionally returns a result</li></ul></div><p>The workitem is just an abstract definition of a work unit and has several concrete, practical implementations in jBPM: human tasks, sendMessage tasks, and so on. The engine imposes no limitations to the workitem handler apart from enforcing the implementation of the <code class="literal">org.kie.api.runtime.process.WorkItemHandler</code> interface.</p><p>The engine runtime is instructed to bind a new handler implementation through the <code class="literal">WorkItemManager.registerWorkItemHandler(String workItemName, WorkItemHandler handler)</code> method, where the <code class="literal">workItemName</code> parameter must match a custom node name since it serves as the handler key.</p><p>jBPM itself extensively uses WorkItemHandler such as <code class="literal">LocalHTWorkItemHandler</code> (workitem name <code class="literal">Human Task</code>), <code class="literal">WebServiceWorkItemHandler</code> (workitem name <code class="literal">WebService</code>), or <code class="literal">RESTWorkItemHandler</code> (name <code class="literal">Rest</code>). This feature effectively streamlines the engine customization process, letting the user enhane (or replace) jBPM functionalities. You can find several jBPM workitem handler classes in the <code class="literal">jpbm-workitems-6.2.0.Final.jar</code> library (see package details in the following class diagram).</p><div class="mediaobject"><img src="graphics/9578OS_07_03.jpg" alt="Workitem and handlers"/></div><p>
<code class="literal">AsyncWorkItemHandler</code> (we discussed it in the <span class="emphasis"><em>Async task</em></span> section in <a class="link" href="ch05.html" title="Chapter 5. BPMN Constructs">Chapter 5</a>, <span class="emphasis"><em>BPMN Constructs</em></span>) can be found<a id="id786" class="indexterm"/> in the <code class="literal">jpbm-executor-6.2.0.Final.jar</code> library.</p><div class="section" title="Life cycle"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec86"/>Life cycle</h3></div></div></div><p>The workitem state transitions are as follows: <code class="literal">ACTIVE</code>,<code class="literal"> PENDING</code>,<code class="literal"> COMPLETED</code>, and<code class="literal"> ABORTED</code>.</p><p>The WorkItemHandler call sequence<a id="id787" class="indexterm"/> is quite simple (see the following interaction diagrams), and when the handler calls complete or abort, the engine takes the control again and the process execution continues. The handler must implement two methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">executeWorkItem</code>: The workitem<a id="id788" class="indexterm"/> manager invokes the <code class="literal">executeMethod</code> handler and, upon completion (at the end of <code class="literal">executeMethod</code>), the handler must invoke the callback method called <code class="literal">completeWorkItem</code> on the manager itself (optionally passing the output parameters):<div class="mediaobject"><img src="graphics/9578OS_07_01.jpg" alt="Life cycle"/></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">abortWorkItem</code>: This method <a id="id789" class="indexterm"/>gets called as a consequence of a cancel or error event. The handler must perform clean-up operations (when needed) and call the manager back by the <code class="literal">abortWorkItem</code> method, which<a id="id790" class="indexterm"/> instructs the manager to set the workitem in the <span class="strong"><strong>ABORTED</strong></span> state:<div class="mediaobject"><img src="graphics/9578OS_07_02.jpg" alt="Life cycle"/></div></li></ul></div><div class="section" title="Cacheable and closeable interfaces"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec22"/>Cacheable and closeable interfaces</h4></div></div></div><p>jBPM 6.2 introduces a new<a id="id791" class="indexterm"/> feature that lets the user hook into the workitem handler life cycle<a id="id792" class="indexterm"/> by implementing the following interface methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">org.kie.internal.runtime.Closeable.close()</code>: Called on WorkItemManager (and Session) disposal. Here, you can<a id="id793" class="indexterm"/> perform the typical housekeeping duties (freeing resources, close connections, and so on).</li><li class="listitem" style="list-style-type: disc"><code class="literal">org.kie.internal.runtime.Cacheable.close()</code>: Called when the jBPM internal cache<a id="id794" class="indexterm"/> manager is closed/disposed. By implementing the <code class="literal">Cacheable</code> interface, we enable our Workitem handler definition to be cached by jBPM.</li></ul></div><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip22"/>Tip</h3><p>The RuntimeManager internally caches several configured object class definitions to optimize the initialization and startup times: event listeners, globals, marshalling strategies, Workitem handlers, and so on.</p></div></div><p>For a <code class="literal">Closeable</code> interface example, please have a look at the PizzaTweet handler implementation discussed in the following paragraphs.</p></div></div></div><div class="section" title="Handlers in action"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec122"/>Handlers in action</h2></div></div></div><p>The workitem customization can be seen as a two-step process:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="strong"><strong>Code implementation and runtime registration</strong></span>: Make the handler implementation available to<a id="id795" class="indexterm"/> the runtime engine in order to trigger the handler execution when the engine reaches the custom node type</li><li class="listitem"><span class="strong"><strong>Designer customization</strong></span>: Enable<a id="id796" class="indexterm"/> the usage of the custom node from the UI interface (process designer)</li></ol></div><p>Before diving into a detailed example (the <code class="literal">pizzatweet</code> project), let us look at the basics of the workitem architecture and review the three different ways in which we can register a handler: by direct registration with the API, by setting the <code class="literal">kmodule.xml</code> file, and by adding a handler configuration file.</p><div class="section" title="Direct handler registration"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec87"/>Direct handler registration</h3></div></div></div><p>The shortest, naïve way<a id="id797" class="indexterm"/> of registering a handler implementation with your engine session is to make a direct invocation to the Kie session's WorkItemManager:</p><div class="informalexample"><pre class="programlisting">// register MyWorkItemHandler for all ad hoc(None) task
ksession.getWorkItemManager().registerWorkItemHandler("task", new MyWorkItemHandler());</pre></div><p>This gives you a lot of flexibility; you do not need to define extra configuration files or properties (more on these in the upcoming section), and you are free to initialize your handler with everything you need during the execution. This is the preferred way to go when unit testing, particularly when replacing or defining a system workitem handler (<code class="literal">human task</code>, <code class="literal">service</code>, or <code class="literal">task</code>) since you do not have to tweak the Kie console to add the new node type to the <span class="strong"><strong>Service Task</strong></span> menu, which would be mandatory to properly design the process definition.</p></div><div class="section" title="Declarative kmodule.xml handler configuration"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec88"/>Declarative kmodule.xml handler configuration</h3></div></div></div><p>In case your project is a<a id="id798" class="indexterm"/> Kie module and you need a declarative, a less hardwired way to define the handlers is to add the <code class="literal">&lt;workItemHandlers&gt;</code> element to the <code class="literal">kmodule.xml</code> file as follows:</p><div class="informalexample"><pre class="programlisting">&lt;kbase name="kbase" &gt;
&lt;ksession name="ksession"&gt;
&lt;workItemHandlers&gt;
  &lt;workItemHandler name="pizzatweet" type="com.packt.masterjbpm6.pizzahandlers.PizzaTweetHandler"
&lt;/workItemHandlers&gt;

&lt;/ksession&gt;</pre></div></div><div class="section" title="Handler configuration file"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec89"/>Handler configuration file</h3></div></div></div><p>When you need to add new custom node types, the preferred, standard way to register your handler implementation is to<a id="id799" class="indexterm"/> have it listed in the standard handler configuration file: the <code class="literal">CustomWorkItemHandlers.conf</code> file.</p><p>This file must contain the handler implementation class constructors and the work item name that will be used to register them; here you have, as an example, the default configuration file shipped with jBPM 6.2:</p><div class="informalexample"><pre class="programlisting">[
  "Log": new org.jbpm.process.instance.impl.demo.SystemOutWorkItemHandler(),
  "WebService": new org.jbpm.process.workitem.webservice.WebServiceWorkItemHandler(kse ssion),
  "Rest": new org.jbpm.process.workitem.rest.RESTWorkItemHandler(),
  "Service Task" : new org.jbpm.process.workitem.bpmn2.ServiceTaskHandler(ksession)
]</pre></div><p>This file is written with the MVEL expression language and is loaded by the jBPM console runtime from the <code class="literal">jbpm-console.war\WEB-INF\classes\META-INF</code> folder; note that the filename is added to the sibling file called <code class="literal">drools.session.conf</code> whose content is as follows:</p><div class="informalexample"><pre class="programlisting">drools.workItemHandlers = CustomWorkItemHandlers.conf</pre></div><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip23"/>Tip</h3><p>Note that from the system default handler definitions (<code class="literal">Web Service</code> and <code class="literal">Service Task</code>), by defining a constructor that accepts the <code class="literal">ksession</code> parameter, the KieSession will be automatically injected at runtime in your handler instance.</p></div></div><p>The very same property called <code class="literal">drools.workItemHandlers</code> is used to load the handler configuration file(s), for instance, during Kie Session initialization with <code class="literal">KieSessionConfiguration</code>. For example:</p><div class="informalexample"><pre class="programlisting">// create the session configuration
Properties props = new Properties();
props.setProperty("drools.workItemHandlers", "MyWorkItemHandlers.conf");
KieSessionConfigurationconfig = KieServices.Factory.get().newKieSessionConfiguration (props);
   // create the session
KieSessionksession = kbase.newKieSession(config, EnvironmentFactory.newEnvironment());</pre></div><p>Alternatively, with<a id="id800" class="indexterm"/> the runtime builder classes (see <a class="link" href="ch06.html" title="Chapter 6. Core Architecture">Chapter 6</a>, <span class="emphasis"><em>Core Architecture</em></span>, for details about runtime classes), you can have the following:</p><div class="informalexample"><pre class="programlisting">RuntimeEnvironmentBuilder.Factory.get().newDefaultBuilder()
   .addConfiguration("drools.workItemHandlers", "MyWorkItemHandlers.conf");</pre></div><p>The <code class="literal">.conf</code> file is searched in the <code class="literal">META-INF/</code> classpath or in the <code class="literal">user.home</code> system folder.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip24"/>Tip</h3><p>The property supports multiple space-separated entries such as the following:</p><div class="informalexample"><pre class="programlisting">addConfiguration("drools.workItemHandlers", "MyWorkItemHandlers.conf OtherWorkItemHandlers.conf");</pre></div></div></div></div><div class="section" title="Handler definition file"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec90"/>Handler definition file</h3></div></div></div><p>The file that defines the<a id="id801" class="indexterm"/> WorkItemHandler process definition node properties is the workitem definition file (having the <code class="literal">.WID</code> extension), and it is written using the MVEL expression language.</p><p>When in the <span class="strong"><strong>Project Authoring</strong></span> mode, the KIE console creates a default <code class="literal">WorkDefinitions.wid</code> file in your project <code class="literal">resources</code> folder that defines the <code class="literal">email</code>, <code class="literal">log</code>, <code class="literal">webservice</code>, and <code class="literal">rest</code> handlers whose custom nodes can be found under the Service Task menu of the process designer palette. Additional resources (custom node icons) are created in the <code class="literal">global</code> folder.</p><p>Here, you define your custom node properties and the workitem abstract definitions: <code class="literal">name</code> (used as the key<a id="id802" class="indexterm"/> for the handler), its parameters (input), result parameters (output), <code class="literal">displayName</code> (the label used for the node), and node icon resource. Let us have a look at our <code class="literal">PizzaTweet</code> custom node (we will talk about this in the example section):</p><div class="informalexample"><pre class="programlisting">[
    [
    "name" : "pizzatweet",
    "parameters" : [
  "tweetMsg": new StringDataType (),
  "tweetTags" : new ListDataType (),
  "tweetOrder" : new ObjectDataType
("com.packt.masterjbpm6.pizza.model.Order")
    ],
    "results" : [
       "details" : new ObjectDataType("java.util.Map"),
   "tweetOK": new BooleanDataType()
    ],
    "displayName" : "Pizza Tweet",
    "icon" : "../../../global/defaultservicenodeicon.png"
 ]</pre></div><p>The <code class="literal">"parameters"</code> and <code class="literal">"results"</code> attributes are maps of typed parameters (name-type pairs).</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">parameters</code>: Defines the set of input parameters of the workitem</li><li class="listitem" style="list-style-type: disc"><code class="literal">results</code>: Defines the set of output parameters</li></ul></div><p>The types allowed for the parameters are the ones supported by the Drool core type classes: <code class="literal">StringDataType</code>, <code class="literal">IntegerDataType</code>, <code class="literal">FloatDataType</code>, <code class="literal">BooleanDataType</code>, <code class="literal">EnumDataType</code>, <code class="literal">ObjectDataType</code>, <code class="literal">ListDataType</code>, and <code class="literal">UndefinedDataType.ObjectDataType</code> wraps a type, while <code class="literal">ListDataType</code> wraps <code class="literal">java.util.List</code>.</p></div></div><div class="section" title="Workitem handler implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec123"/>Workitem handler implementation</h2></div></div></div><p>Your handler must<a id="id803" class="indexterm"/> implement the <code class="literal">org.kie.api.runtime.process.WorkItemHandler</code> interface or extend the <code class="literal">AbstractWorkItemHandler</code> abstract class. This class gives you a set of useful helper methods in case <a id="id804" class="indexterm"/>your handler needs to get runtime information from the process or its nodes.</p><div class="section" title="Handling input parameters"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec91"/>Handling input parameters</h3></div></div></div><p>The handler can read the<a id="id805" class="indexterm"/> input parameters with the <code class="literal">WorkItem.getParameter (String name)</code> method. The input parameters are passed by the engine runtime, upon evaluation of your node data input set mappings.</p></div><div class="section" title="Returning results to the process"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec92"/>Returning results to the process</h3></div></div></div><p>The handler return object (<code class="literal">"results"</code>) is defined as a collection of parameters. Each attribute name<a id="id806" class="indexterm"/> must match a data output parameter in the <code class="literal">DataOutputSet</code> node settings (<code class="literal">"details"</code> and <code class="literal">"tweetOK"</code>), for example:</p><div class="informalexample"><pre class="programlisting">Map&lt;String, Object&gt; operationresults = new HashMap&lt;String, Object&gt;();
  operationresults.put("twitterCode", "200");
  results.put(<span class="strong"><strong>"details"</strong></span>, operationresults);
  results.put(<span class="strong"><strong>"tweetOK"</strong></span>, Boolean.TRUE);</pre></div><p>The <code class="literal">details</code> and <code class="literal">tweetOk</code> keys must match both node data output parameter names (see the screenshot in the <span class="emphasis"><em>Process and task parameter mappings</em></span> section) and the workitem handler <code class="literal">"results"</code> properties:</p><div class="informalexample"><pre class="programlisting">    "results" : [
      "<span class="strong"><strong>details</strong></span>" : new ObjectDataType("java.util.Map"),
      "<span class="strong"><strong>tweetOK</strong></span>": new BooleanDataType()
    ]</pre></div></div></div><div class="section" title="The PizzaTweet example"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec124"/>The PizzaTweet example</h2></div></div></div><p>The example guides you through the definition and the installation of a full working example project, which<a id="id807" class="indexterm"/> features a custom workitem that sends <a id="id808" class="indexterm"/>messages to Twitter (Twitter API integration not implemented for clarity).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note49"/>Note</h3><p>You can find a<a id="id809" class="indexterm"/> Twitter handler implementation in the Red Hat jBPM service repository: <a class="ulink" href="http://people.redhat.com/kverlaen/repository/Twitter/">http://people.redhat.com/kverlaen/repository/Twitter/</a>.</p></div></div><p>The main project (the <code class="literal">pizzatweet</code> KIE module) contains the process definition and the WID file, and it depends on custom types that are defined in the <code class="literal">pizzamodel</code> project (a plain utility JAR). These types are also used as parameter types by the <code class="literal">PizzaTweetHandler</code> handler (defined in the <code class="literal">pizzahandlers</code> project, another plain JAR).</p><div class="section" title="The main project (the KIE module)"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec93"/>The main project (the KIE module)</h3></div></div></div><p>The main project depends on the two supplier projects: <code class="literal">pizzamodel</code> and <code class="literal">pizzahandlers</code>. Since these two projects are not KIE modules and do not need additional processing by the KIE runtime (they do not contain jBPM resources), we have set their Maven dependency scope to <code class="literal">provided</code> (see the <code class="literal">pom.xml</code> PizzaTweet project file). This speeds up the Maven<a id="id810" class="indexterm"/> build of our main KIE module; <code class="literal">kie-mave-plugin</code> in fact searches for KIE module dependencies only when their Maven scope is <code class="literal">runtime</code> or <code class="literal">compile</code>.</p><p>The KIE plugin for Maven (<code class="literal">kie-maven-plugin</code>) is the preferred way to build a KIE module. It ensures that all module business resources are valid at compile time and that the module can be successfully loaded at runtime. Make sure that you always have the <code class="literal">kie-maven-plugin</code> set in the <code class="literal">pom.xml</code> file of your KIE module (see the following <code class="literal">PizzaTweet</code> <code class="literal">pom.xml</code> excerpt):</p><div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;com.packt.masterjbpm6&lt;/groupId&gt;
  &lt;artifactId&gt;pizzamodel&lt;/artifactId&gt;
  &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
<span class="strong"><strong>  &lt;scope&gt;provided&lt;/scope&gt;</strong></span>
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;com.packt.masterjbpm6&lt;/groupId&gt;
  &lt;artifactId&gt;pizzahandlers&lt;/artifactId&gt;
  &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
<span class="strong"><strong>  &lt;scope&gt;provided&lt;/scope&gt;</strong></span>
&lt;/dependency&gt;

&lt;build&gt;
  &lt;plugins&gt;
<span class="strong"><strong>    &lt;plugin&gt;</strong></span>
<span class="strong"><strong>      &lt;groupId&gt;org.kie&lt;/groupId&gt;</strong></span>
<span class="strong"><strong>      &lt;artifactId&gt;kie-maven-plugin&lt;/artifactId&gt;</strong></span>
<span class="strong"><strong>      &lt;version&gt;6.2.0.Final&lt;/version&gt;</strong></span>
<span class="strong"><strong>      &lt;extensions&gt;true&lt;/extensions&gt;</strong></span>
<span class="strong"><strong>    &lt;/plugin&gt;</strong></span>
  &lt;/plugins&gt;
&lt;/build&gt;</pre></div></div><div class="section" title="Process and task parameter mappings"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec94"/>Process and task parameter mappings</h3></div></div></div><p>After having introduced the <code class="literal">pizzatweet</code> custom task definition in the previous section (the handler definition file), let us<a id="id811" class="indexterm"/> now look at how it fits into the process definition. The process definition is easy to understand; it has the custom tweet task and a script task that acts as a debugging step. The process variables (<code class="literal">msg</code>, <code class="literal">order</code>, and <code class="literal">tags</code>) are <a id="id812" class="indexterm"/>mapped to the custom task input parameters, while the resulting parameters (<code class="literal">tweetOK</code>, <code class="literal">details</code>) are mapped back to process variables (<code class="literal">success</code> and <code class="literal">results</code>). The following screenshot shows the <span class="strong"><strong>Assignments</strong></span> properties panel for the <code class="literal">Pizza Tweet</code> custom node (see the <code class="literal">PizzaTweet</code> process definition):</p><div class="mediaobject"><img src="graphics/9578OS_07_04.jpg" alt="Process and task parameter mappings"/></div><p>After the tweet task completes, the script task is executed. As mentioned earlier, it simply dumps the updated process <a id="id813" class="indexterm"/>variables to the console for<a id="id814" class="indexterm"/> you to see. We are now going to look at the two dependent projects (handlers and models).</p></div><div class="section" title="Handler project (pizzahandlers)"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec95"/>Handler project (pizzahandlers)</h3></div></div></div><p>This project contains the<a id="id815" class="indexterm"/> handler implementation (the <code class="literal">PizzaTweetHandler </code>class) only, the one responsible for sending the tweet. In order to deploy the dependent <code class="literal">pizzahandlers</code> handler project, we have to perform a Maven "clean build install." The JAR file will then be installed in your system's Maven repository.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip25"/>Tip</h3><p>Make sure that all the implementation classes and required dependencies are also available on the classpath of the application war (in this case, the war is our KIE console war), for example, by copying the required JAR files in the <code class="literal">/lib</code> folder.</p></div></div></div><div class="section" title="Model project (pizzamodel)"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec96"/>Model project (pizzamodel)</h3></div></div></div><p>The model project defines<a id="id816" class="indexterm"/> Java types for the process definition variables and the handler project parameters. In order to deploy the dependent <code class="literal">pizzamodel</code> project, we have to execute a Maven "clean build install." Thus, the JAR file is installed in your system's Maven repository so as to make it available to runtime dependency resolving.</p></div><div class="section" title="IDE customization"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec97"/>IDE customization</h3></div></div></div><p>In order to configure the KIE workbench (business process editor) tools and being able to use our custom node in<a id="id817" class="indexterm"/> the process editor, we have to create a workitem handler file. We create the <code class="literal">WEB-INF\classes\META-INF\PACKTworkItemHandlers.conf</code> file (in the <code class="literal">jbpm-console deployment</code> folder) and add the following content:</p><div class="informalexample"><pre class="programlisting">[
   "pizzatweet": new com.packt.masterjbpm6.pizzahandlers.PizzaTweetHandler(ksession)
]</pre></div><p>Then, we edit the <code class="literal">WEB-INF\classes\META-INF\drools.session.conf</code> file by adding our custom handler <code class="literal">.conf</code> filename to the <code class="literal">drools.workItemHandlers</code> property. Thus, the handler definitions from both the files are loaded. Please note that the handler configuration file names must be separated by a space:</p><div class="informalexample"><pre class="programlisting">drools.workItemHandlers = CustomWorkItemHandlers.conf PACKTworkItemHandlers.conf</pre></div><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip26"/>Tip</h3><p>The <code class="literal">drools.session.conf</code> file is picked up by the KIE console and read during KIE session initialization; see the <span class="emphasis"><em>Handler configuration file</em></span> section for further details.</p></div></div><p>Copy the installed <code class="literal">pizzahandlers-1.0.0-SNAPSHOT.jar</code> and <code class="literal">pizzamodel-1.0.0-SNAPSHOT.jar</code> files to the jBPM console's <code class="literal">WEB-INF\lib</code> folder (for example, <code class="literal">wildfly-8.1.0.Final\standalone\deployments\jbpm-console.war\WEB-INF\lib</code>). This makes <a id="id818" class="indexterm"/>both the custom java types and the handler class available to the Kie console (a jBoss restart is required). Note that the Pizza Tweet (<code class="literal">name: pizzatweet</code>) custom task node is now displayed in the <span class="strong"><strong>Service Tasks</strong></span> section of the object library:</p><div class="mediaobject"><img src="graphics/9578OS_07_05.jpg" alt="IDE customization"/></div></div><div class="section" title="Console test run"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec98"/>Console test run</h3></div></div></div><p>As of jBPM 6.2.0 release, the KIE console is not much of a help in letting us test our process, since the<a id="id819" class="indexterm"/> generated task forms do not support complex type parameters automatically (our process takes an input parameter of the <code class="literal">Order</code> type); we cannot easily create our new process instances from here.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note50"/>Note</h3><p>The jBPM user guide (<span class="emphasis"><em>Chapter 13</em></span>, <span class="emphasis"><em>Forms</em></span>) explains<a id="id820" class="indexterm"/> the features shipped with the KIE console Form Modeler (<a class="ulink" href="http://docs.jboss.org/jbpm/v6.2/userguide/chap-formmodeler.html">http://docs.jboss.org/jbpm/v6.2/userguide/chap-formmodeler.html</a>) and gives useful instructions on how to create customized human task forms and start process forms.</p></div></div><p>However, before leaving the console, let's check whether the process can successfully deploy without<a id="id821" class="indexterm"/> issues. Go to the <code class="literal">pizzatweet</code> project from the <span class="strong"><strong>Tools</strong></span>/<span class="strong"><strong>Project Details</strong></span> view and issue <span class="strong"><strong>build &amp; deploy</strong></span>. The process definition is registered with the runtime, and we should see it from the <span class="strong"><strong>Process Management/Process Definitions</strong></span> tab.</p><div class="mediaobject"><img src="graphics/9578OS_07_06.jpg" alt="Console test run"/></div></div><div class="section" title="Standalone test run"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec99"/>Standalone test run</h3></div></div></div><p>Get the PizzaTweetTest test class from the <code class="literal">PizzaTwitter</code> project and run (jUnit) the <code class="literal">newTweet</code>
<a id="id822" class="indexterm"/> method:</p><div class="informalexample"><pre class="programlisting">// boilerplate code omitted for clarity;
// register the handler
session.getWorkItemManager().registerWorkItemHandler("pizzatweet", newPizzaTweetHandler(session));
// init parameters

// start the process
ProcessInstanceinstance = session.startProcess("pizzatweet.tweet", params);</pre></div><p>The console prints the following text; first, we have the following handler log traces:</p><div class="informalexample"><pre class="programlisting">PizzaTweetHandler.executeWorkItem
PizzaTweetHandler.order=order: note=urgent cost=15.0</pre></div><p>Then, we have the <a id="id823" class="indexterm"/>script task log traces, showing the following handler results:</p><div class="informalexample"><pre class="programlisting">tweet success:true
twitterCode:200</pre></div><p>After the handler has been locally tested, we can move on and share it with the development team; this is where the service repository comes to the rescue.</p></div></div><div class="section" title="Service repository"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec125"/>Service repository</h2></div></div></div><p>jBPM gives us the ability to add any handler to a public service repository; these are a collection of handler<a id="id824" class="indexterm"/> definitions that can be accessed both via HTTP or locally (the FILE protocol) so that handlers can be shared with the other developers.</p><p>At the time of writing this book, the<a id="id825" class="indexterm"/> KIE workbench supported two repositories: <a class="ulink" href="http://people.redhat.com/kverlaen/repository">http://people.redhat.com/kverlaen/repository</a> and <a class="ulink" href="http://people.redhat.com/tsurdilo/repository">http://people.redhat.com/tsurdilo/repository</a>. Another repository service is available at <a class="ulink" href="http://docs.jboss.org/jbpm/v6.2/repository/">http://docs.jboss.org/jbpm/v6.2/repository/</a>. These repositories host several handler definitions; some of them are externally defined handlers (which means that the<a id="id826" class="indexterm"/> implementing JAR file is physically hosted in the repository), while other handlers are already defined in the jBPM runtime (for example, Java, REST, and transform handlers), and the repository just publishes the extended handler definition (<code class="literal">.WID</code>) file. The service repository is accessible through the <span class="strong"><strong>Connect to a service repository</strong></span> button in the business process editor. Here, you have an example repository content dialog window:</p><div class="mediaobject"><img src="graphics/9578OS_07_08.jpg" alt="Service repository"/></div><p>We are going to<a id="id827" class="indexterm"/> see how to set up an additional custom local service repository.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note51"/>Note</h3><p>For additional details about the service repository, please refer to <span class="emphasis"><em>Chapter 21, Domain-specific Processes</em></span> of the jBPM 6.2 user guide (<span class="emphasis"><em>Service Repository</em></span> paragraph).</p></div></div><div class="section" title="Custom service repository"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec100"/>Custom service repository</h3></div></div></div><p>A service repository is basically a folder structure containing handlers. The folder structure and the content to load are specified by a set of <code class="literal">index.conf</code> files. See the <code class="literal">repo.rar</code> example included with the book's source code.</p><p>Create a folder structure<a id="id828" class="indexterm"/> for our repository in a local folder (for example, <code class="literal">c:/temp/packtservicerepo</code>) containing the <code class="literal">pizzatweet</code> handler folder; inside the handler folder, we add the enhanced <code class="literal">pizzatweet.wid</code> file, which is basically a standard WID file with the following additional entries:</p><div class="informalexample"><pre class="programlisting">"defaultHandler" : "com.packt.masterjbpm6.pizzahandlers.PizzaTweetHandler",
"documentation" : "index.html",
"category" : "examples",
"dependencies" : [
      "file:./lib/pizzahandlers-1.0.0-SNAPSHOT.jar",
      "file:./lib/pizzamodel-1.0.0-SNAPSHOT.jar"
    ]</pre></div><p>The dependencies path is relative to the handler folder (<code class="literal">/lib</code>), and there we copy the two JAR files: the JAR file containing the handler definition and the JAR file defining the Java models.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note52"/>Note</h3><p>Refer to the details about the pizza handler and model projects in the <code class="literal">PizzaTweet</code> example paragraph.</p></div></div><p>It's worth <a id="id829" class="indexterm"/>mentioning that the WID file must have the handler folder name. After creating the files, we can open the service repository from the KIE workbench, giving the following local filesystem path: <code class="literal">file:///c:/temp/packtservicerepo</code>.</p><div class="mediaobject"><img src="graphics/9578OS_07_09.jpg" alt="Custom service repository"/></div><p>Now, we can use <span class="strong"><strong>Install selected item</strong></span>
<code class="literal">:</code>. This makes the KIE workbench copy the assets to the internal KIE repository so that the handler becomes available.</p></div></div></div></div>
<div class="section" title="jBPM identity management"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec44"/>jBPM identity management</h1></div></div></div><p>In <a class="link" href="ch04.html" title="Chapter 4. Operation Management">Chapter 4</a>, <span class="emphasis"><em>Operation Management</em></span>, we saw how the KIE workbench features JAAS-based user authentication and RBAC for the UI functionalities by means of the <code class="literal">user.properties</code> and <code class="literal">roles.properties</code> files.</p><p>The jBPM engine does not have built-in authentication or fine-grained authorization functionalities on<a id="id830" class="indexterm"/> process creation or task operations. TaskService and the human task management of users and groups with respect to task operations are delegated to a custom implementation of the <code class="literal">UserGroupCallback</code> interface. Here, the developer is able to implement his/her own task authorization <a id="id831" class="indexterm"/>mechanism by hooking into a custom identity management system or an ad hoc implementation.</p><p>jBPM provides a set of ready-to-use, configurable <code class="literal">UserGroupCallback</code> implementations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">DBUserGroupCallbackImpl</code>: Implementation that uses SQL queries to get user and group <a id="id832" class="indexterm"/>data from a database</li><li class="listitem" style="list-style-type: disc"><code class="literal">LDAPUserGroupCallbackImpl</code>: LDAP <a id="id833" class="indexterm"/>system integration</li><li class="listitem" style="list-style-type: disc"><code class="literal">MvelUserGroupCallbackImpl</code>: Default jBPM<a id="id834" class="indexterm"/> implementation when no callback is specified; the <code class="literal">UserGroupsAssignmentsOne.mvel</code> file is read and evaluated</li><li class="listitem" style="list-style-type: disc"><code class="literal">JAASUserGroupCallbackImpl</code>: JAAS-based implementation<a id="id835" class="indexterm"/> to be used in a container (JBoss AS and Tomcat):<div class="mediaobject"><img src="graphics/9578OS_07_11.jpg" alt="jBPM identity management"/></div></li></ul></div><div class="section" title="User callback configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec126"/>User callback configuration</h2></div></div></div><p>The <code class="literal">UserGroupCallback</code> implementation is a<a id="id836" class="indexterm"/> singleton and can <a id="id837" class="indexterm"/>be set on the environment used to create <code class="literal">RuntimeEngine</code>:</p><div class="informalexample"><pre class="programlisting">// create the environment builder
RuntimeEnvironmentBuilder builder = RuntimeEnvironmentBuilder.Factory.get().newDefaultBuilder()
.userGroupCallback(usergroupcallback);
// create the manager
RuntimeManagermanager = RuntimeManagerFactory.Factory.get()
.newSingletonRuntimeManager(builder.get(), "manager");
// create the runtimeEngine (omitted)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note53"/>Note</h3><p>All of the book's source code examples use a default custom callback class (<code class="literal">MyUserCallback</code>: you can find it in the <code class="literal">test-common</code> project). The callback is set by the <code class="literal">PacktJUnitBaseTestCase</code> class from which every test case borrows the runtime engine, the session, and so on.</p></div></div><p>The jBPM UserGroupCallback<a id="id838" class="indexterm"/> implementations rely on the <code class="literal">jbpm.usergroup.callback.properties</code> system property for the property filename or, alternatively, on the <code class="literal">jbpm.usergroup.callback.properties</code> property file for automatic configuration. The <a id="id839" class="indexterm"/>callback class can have a defined set of properties; let's review some of them for the classes shipped with jBPM.</p><div class="section" title="The DBUserGroupCallbackImpl class"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec101"/>The DBUserGroupCallbackImpl class</h3></div></div></div><p>This callback has the following four properties (let <code class="literal">users</code> and <code class="literal">groups</code> be the tables defining our users and <a id="id840" class="indexterm"/>groups data):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">db.ds.jndi.name</code>: JNDI name of the<a id="id841" class="indexterm"/> data source to be used, for example, <code class="literal">jdbc/jbpm-ds</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">db.user.query</code>: Query used to verify <a id="id842" class="indexterm"/>existence of the user (case-sensitive, expects a single parameter on position 1), for example:<div class="informalexample"><pre class="programlisting">"select userId from users where userId = ?"</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">db.roles.query</code>: Query user to check<a id="id843" class="indexterm"/> group existence (case-sensitive, expects single parameter on position 1), for example:<div class="informalexample"><pre class="programlisting">select groupId from Groups where groupId = ?"</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">db.user.roles.query</code>: Query used to<a id="id844" class="indexterm"/> get groups for a given user (case-sensitive, expects single parameter on position 1), for example:<div class="informalexample"><pre class="programlisting">select groupId from Groups where userId = ?</pre></div></li></ul></div></div><div class="section" title="The LDAPUserGroupCallbackImpl class"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec102"/>The LDAPUserGroupCallbackImpl class</h3></div></div></div><p>This callback relies on several<a id="id845" class="indexterm"/> properties (parameter descriptions):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ldap.bind.user</code> (optional if the LDAP server accepts anonymous access)</li><li class="listitem" style="list-style-type: disc"><code class="literal">ldap.bind.pwd</code> (optional if the LDAP server accepts anonymous access)</li><li class="listitem" style="list-style-type: disc"><code class="literal">ldap.user.ctx</code> (mandatory), for example, <code class="literal">ou\=Staff,dc\=packt,dc\=com</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ldap.role.ctx</code> (mandatory), for example, <code class="literal">ou\=Roles,dc\=packt,dc\=com</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ldap.user.roles.ctx</code> (optional; if not given, <code class="literal">ldap.role.ctx</code> will be used)</li><li class="listitem" style="list-style-type: disc"><code class="literal">ldap.user.filter</code> (mandatory), for example, <code class="literal">=(uid\={0})</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ldap.role.filter</code> (mandatory), for example, <code class="literal">(cn\={0})</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ldap.user.roles.filter</code> (mandatory), for example, <code class="literal">(member\={0})</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ldap.user.attr.id</code> (optional; if not given, <code class="literal">uid</code> will be used)</li><li class="listitem" style="list-style-type: disc"><code class="literal">ldap.roles.attr.id</code> (optional; if not given, <code class="literal">cn</code> will be used)</li><li class="listitem" style="list-style-type: disc"><code class="literal">ldap.user.id.dn</code> (optional; is user id a <code class="literal">DN</code>?; instructs the callback to query for a user <code class="literal">DN</code> before searching for roles; default false)</li><li class="listitem" style="list-style-type: disc"><code class="literal">ldap.search.scope</code> (optional; if not given, <code class="literal">OBJECT_SCOPE</code> will be used); the possible values are as<a id="id846" class="indexterm"/> follows: <code class="literal">OBJECT_SCOPE</code>, <code class="literal">ONELEVEL_SCOPE</code>, and <code class="literal">SUBTREE_SCOPE</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.naming.factory.initial</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.naming.security.authentication</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.naming.security.protocol</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.naming.provider.url</code>, for example, <code class="literal">ldap://localhost:10389</code></li></ul></div></div></div></div>
<div class="section" title="jBPM serialization"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec45"/>jBPM serialization</h1></div></div></div><p>We have seen that the engine features, with enabled persistence, state saving of session, process, task, and variable data<a id="id847" class="indexterm"/> to the database, and contextually, relevant object state data are marshalled and then, persisted on entity saving and unmarshaled on entity loading<a id="id848" class="indexterm"/> so as to make possible the preservation of the engine execution state in the long term, across system restarts. Here, the term <a id="id849" class="indexterm"/>
<span class="strong"><strong>marshalling</strong></span> is used<a id="id850" class="indexterm"/> because the jBPM serialization layer utilizes the Google Protobuf framework, a protocol, which, in the first instance, was used for RPC. Let us have a look at how the default jBPM serialization works and, later on, how we can manage to hook our serialization mechanism into jBPM.</p><div class="section" title="Marshalling"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec127"/>Marshalling</h2></div></div></div><p>
<code class="literal">CommandService</code> (<a class="link" href="ch06.html" title="Chapter 6. Core Architecture">Chapter 6</a>, <span class="emphasis"><em>Core Architecture</em></span>) and the related interceptors are invoked to persist entities in a transactional way; the internal object marshalling phase takes place inside the transaction.</p><p>During the saving (or update) of the <a id="id851" class="indexterm"/>session, for example, its instance gets marshalled into its <code class="literal">RULEBYTESARRAY</code> column (<code class="literal">SessionInfo</code> table) so that the <code class="literal">Knowledge Session</code> instance can be loaded after a restart. The same happens for a process instance; its instance (with variables, node definitions, swimlanes, and so on.) is marshalled into <code class="literal">PROCESSINSTANCEBYTEARRAY</code> (the <code class="literal">ProcessInstanceInfo</code> table). The task data is marshalled into the <code class="literal">WORKITEMBYTEARRAY</code> (<code class="literal">WorkItemInfo</code> table).</p><p>The engine classes, which<a id="id852" class="indexterm"/> actually perform the marshalling job, are respectively <code class="literal">SessionMarshallingHelper</code> and <code class="literal">ProtobufProcessMarshaller</code>; these classes are internally baked by the <code class="literal">ProtobufMarshaller</code> class, which manages operations through a write handler (<code class="literal">ProtobufOutputMarshaller</code>) and an input handler (<code class="literal">ProtobufInputMarshaller</code>). The class diagram shown later demonstrates these classes and also how <code class="literal">KieMarshallers</code> (we introduced this in <a class="link" href="ch06.html" title="Chapter 6. Core Architecture">Chapter 6</a>, <span class="emphasis"><em>Core Architecture</em></span>) fits into the picture. It is simply a factory default for marshaller and strategy instances. <code class="literal">Strategies</code> are classes that control the marshalling process of variables.</p><div class="section" title="Persisting variables"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec103"/>Persisting variables</h3></div></div></div><p>jBPM does not feature <a id="id853" class="indexterm"/>off-the-shelf processes and task variable persistence toward an ER model, mainly because of performance reasons. The main drawback is that you cannot search process instances by the value of a process variable. In order to add this kind of feature, you have to provide an implementation for the <code class="literal">JPAPlaceholderResolverStrategy</code> strategy (we are going to discuss it in a moment).</p></div></div><div class="section" title="Strategies"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec128"/>Strategies</h2></div></div></div><p>As we have just seen, the default jBPM marshalling process results into bytes written in the database. This could be<a id="id854" class="indexterm"/> of limited interest to our application, but luckily, jBPM gives us the tools to hook into this mechanism by controlling the way variable (at least) marshaling works, by using or adding the so-called strategies.</p><p>During marshalling, in fact, jBPM delegates the serialization of process and task variables to strategy classes; jBPM ships with<a id="id855" class="indexterm"/> some ready-to-use strategies:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">org.drools.core.marshalling.impl.SerializablePlaceholderResolverStrategy</code>: Features default Java serialization on objects implementing the <code class="literal">Serializable</code> interface. jBPM adds this strategy by default to the list of enabled strategies.</li><li class="listitem" style="list-style-type: disc"><code class="literal">org.drools.persistence.jpa.marshaller.JPAPlaceholderResolverStrategy</code>: A strategy that manages variables as entities to and from a JPA-persistent store.</li><li class="listitem" style="list-style-type: disc"><code class="literal">org.jbpm.document.marshalling.DocumentMarshallingStrategy</code>: This strategy manages marshalling for parameters of the <code class="literal">org.jbpm.document.Document</code> type. The document parameter type is used as the upload file parameter in the KIE Form modeler. These features are available with <code class="literal">jbpm-document-6-2-0.Final.jar</code>.</li></ul></div><p>jBPM supports multiple strategies at once; it invokes them sequentially (a chain of responsibility patterns) following the order in which they are given when configuring the session (more on this in the<a id="id856" class="indexterm"/> following section). Each strategy (<code class="literal">ObjectMarshallingStrategy</code>) must specify the objects that it handles (the <code class="literal">accept</code> method) and provide the <code class="literal">marshal</code> and <code class="literal">unmarshal</code> methods (see the class diagram ahead).</p><p>Let us now look at how strategies can be configured using a working example which uses the jBPM <code class="literal">JPAPlaceholderResolverStrategy</code> in order to persist our process and task variables to our domain database table. Please refer to the <code class="literal">jbpm-marshalling</code> example project for a working marshalling example.</p></div><div class="section" title="Configuring a marshalling strategy"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec129"/>Configuring a marshalling strategy</h2></div></div></div><p>The <code class="literal">jbpm-marshalling</code> example features a process definition (<code class="literal">rule_marshall.bpmn</code>), which uses an entity class as<a id="id857" class="indexterm"/> both the process variable and the task parameter. We want the engine to transparently persist our domain variable (the <code class="literal">OrderEntity </code>class) into a new domain database table (the <code class="literal">ORDERENTITY</code> table). The OrderEntity entity class must be added to our persistence unit (check the <code class="literal">persistence.xml </code>project), for example:</p><div class="informalexample"><pre class="programlisting">&lt;class&gt;com.packt.masterjbpm6.pizza.model.entity.OrderEntity&lt;/class &gt;</pre></div><p>We set the marshalling strategies by passing an array of <code class="literal">ObjectMarshallingStrategy</code> to the environment that is used to create KieSession; in the following example (the <code class="literal">MarshallTest</code> example class), we configure the <code class="literal">JPAPlaceholderResolverStrategy</code> and the <code class="literal">SerializablePlaceholderResolverStrategy</code> strategies (please refer to the <span class="emphasis"><em>RuntimeManager and the engine</em></span> section in <a class="link" href="ch06.html" title="Chapter 6. Core Architecture">Chapter 6</a>, <span class="emphasis"><em>Core Architecture</em></span>, for details).</p><div class="informalexample"><pre class="programlisting">RuntimeEnvironmentBuilder builder = RuntimeEnvironmentBuilder.Factory.get().newDefaultBuilder();
builder.entityManagerFactory(super.getEmf())
builder.addEnvironmentEntry(
  EnvironmentName.OBJECT_MARSHALLING_STRATEGIES,
  new ObjectMarshallingStrategy[] {
    new CustomJPAPlaceholderResolverStrategy (super.getEmf()),
    new SerializablePlaceholderResolverStrategy(
    ClassObjectMarshallingStrategyAcceptor.DEFAULT)});</pre></div><p>Note that we provided an extended <code class="literal">CustomJPAPlaceholderResolverStrategy</code>; this class extends and delegates all functionalities to the default <code class="literal">JPAPlaceholderResolverStrategy</code> and adds some logging features by sending the relevant information to the console<a id="id858" class="indexterm"/> during the marshalling process. Its constructor is given <code class="literal">EntityManagerFactory</code>, which has been created from the same persistence unit that the engine is using. This means that our entity table will be in the same engine database schema. The <code class="literal">ClassObjectMarshallingStrategyAcceptor</code> instance (used for <code class="literal">SerializablePlaceholderResolverStrategy</code>) performs the logic of accepting (filtering) object instances. Remember to always add the <code class="literal">SerializablePlaceholderResolverStrategy</code> strategy as the last strategy, since it's the one used by the engine.</p><div class="mediaobject"><img src="graphics/9578OS_07_07.jpg" alt="Configuring a marshalling strategy"/></div></div><div class="section" title="Persisting variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec130"/>Persisting variables</h2></div></div></div><p>The <code class="literal">MarshallTest</code> class is derived from <code class="literal">RuleTaskTest</code> (see the <span class="emphasis"><em>Rule start event</em></span> section in <a class="link" href="ch05.html" title="Chapter 5. BPMN Constructs">Chapter 5</a>, <span class="emphasis"><em>BPMN Constructs</em></span>); it sets a global session variable and then, creates the process for passing two parameters, namely a plain <code class="literal">Order</code> instance and an <code class="literal">OrderEntity</code> instance, which are<a id="id859" class="indexterm"/> then passed to the user task. Upon the completion of the user task, the business rule is triggered and the global session variable is evaluated.</p><p>If we run the example jUnit test, we can see how the <code class="literal">marshall</code> method for our strategy class gets called several times before the human task is triggered:</p><div class="informalexample"><pre class="programlisting">18:19:42.757 [main] accepted com.packt.masterjbpm6.pizza.model.entity.OrderEntity object: [OrderEntity Id: null desc= First order amount=20.0]
18:19:42.757 [main] marshal com.packt.masterjbpm6.pizza.model.entity.OrderEntity object: [OrderEntity Id: null desc= First order amount=20.0]
18:19:42.788 [main] accepted com.packt.masterjbpm6.pizza.model.entity.OrderEntity object: [OrderEntity Id: 1 desc= First order amount=20.0]
18:19:42.788 [main] marshal com.packt.masterjbpm6.pizza.model.entity.OrderEntity object: [OrderEntity Id: 1 desc= First order amount=20.0]
18:19:44.318 [main] accepted com.packt.masterjbpm6.pizza.model.entity.OrderEntity object: [OrderEntity Id: 1 desc= First order amount=20.0]
18:19:44.318 [main] marshal com.packt.masterjbpm6.pizza.model.entity.OrderEntity object: [OrderEntity Id: 1 desc= First order amount=20.0]
18:19:44.350 [main] accepted com.packt.masterjbpm6.pizza.model.entity.OrderEntity object: [OrderEntity Id: 1 desc= First order amount=20.0]
18:19:44.350 [main] marshal com.packt.masterjbpm6.pizza.model.entity.OrderEntity object: [OrderEntity Id: 1 desc= First order amount=20.0]</pre></div><p>The order entity is first inserted and then, updated several times; in the database table, we can see our record.</p><div class="mediaobject"><img src="graphics/9578OS_07_10.jpg" alt="Persisting variables"/></div><p>It is the strategy's responsibility to maintain the entity state consistent between these calls. After the task completion, the <code class="literal">unmarshall</code> method gets called twice: first when the workitem is loaded<a id="id860" class="indexterm"/> from the database before its completion, and second when the process instance is loaded from the session:</p><div class="informalexample"><pre class="programlisting">luigi is executing task User Task 1
18:27:00.220 [main] unmarshalcom.packt.masterjbpm6.pizza.model.entity.OrderEntity object: [OrderEntity Id: 1 desc= First order amount=20.0]
18:27:00.251 [main] unmarshalcom.packt.masterjbpm6.pizza.model.entity.OrderEntity object: [OrderEntity Id: 1 desc= First order amount=20.0]</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec46"/>Summary</h1></div></div></div><p>jBPM is open and configurable software. In this chapter, we reviewed three core features of the platform, which are commonly extended when tailoring jBPM systems to meet specific application requirements: domain processes and custom BPMN nodes, custom persistence for process and task variables, and human authorization based on custom implementation or legacy systems. The next chapter will provide the user with real-world jBPM solutions.</p></div></body></html>