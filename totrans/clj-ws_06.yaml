- en: 6\. Recursion and Looping
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 递归与循环
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn more flexible ways to work with collections.
    When the problem you need to solve does not fit the patterns that we've looked
    at so far. We will also use `doseq` for loops with side effects and see how you
    can avoid writing some loops by using specialized repetition functions such as
    `repeat` and `iterate`. You will use `recur` for recursive looping and identify
    when this is possible, work with the `loop` macro, and solve complex problems
    with recursion.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习更灵活的方式来处理集合。当你需要解决的问题不适合我们之前看到的模式时。我们还将使用 `doseq` 进行具有副作用循环，并了解如何通过使用专门的重复函数，如
    `repeat` 和 `iterate`，来避免编写一些循环。你将使用 `recur` 进行递归循环，并确定何时这是可能的，使用 `loop` 宏来工作，并通过递归解决复杂问题。
- en: By the end of this chapter, you will be able to implement different aspects
    of recursion and see how they can replace traditional loops.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够实现递归的不同方面，并了解它们如何取代传统的循环。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Data in our programs doesn't always take the nice, linear form for which functions
    such as `map` or `reduce` are particularly adapted. None of the techniques we've
    discussed in the last two chapters will work for traversing non-linear structures
    such as trees or graphs. And while it's possible to do a lot by being creative
    with `reduce`, the strong guard rails that `reduce` provides can sometimes get
    in the way of writing expressive code. There are situations that call for tools
    that give the programmer more control. Clojure has other resources for these kinds
    of problems and that is what we are going to look at in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序中的数据并不总是以 `map` 或 `reduce` 等函数特别适应的整洁线性形式存在。我们在前两章中讨论的所有技术都无法用于遍历非线性结构，如树或图。虽然通过创意使用
    `reduce` 可以做很多事情，但 `reduce` 提供的强大防护栏有时可能会妨碍编写表达性代码。有些情况需要程序员有更多控制权的工具。Clojure
    为这类问题提供了其他资源，这就是我们将在本章中探讨的内容。
- en: Recursion plays a major role when functions such as `map` and `reduce` are no
    longer adapted to the task at hand. Thinking recursively is an important Clojure
    skill to learn. Because functional programming languages tend to emphasize recursion,
    this might seem unfamiliar if your background is in more procedural languages.
    Most programming languages do actually support recursion, so the concept is not
    necessarily that foreign. Additionally, some of the things that we have already
    done with `reduce` are actually recursive, so even if you've never used recursion
    very much before, the learning curve should not be that steep.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当诸如 `map` 和 `reduce` 等函数不再适应手头的任务时，递归扮演着重要的角色。递归思维是学习 Clojure 技能的一个重要方面。因为函数式编程语言往往强调递归，如果你的背景是更程序性的语言，这可能会显得有些不熟悉。大多数编程语言实际上都支持递归，所以这个概念并不一定那么陌生。此外，我们用
    `reduce` 做的一些事情实际上是递归的，所以即使你之前很少使用递归，学习曲线也不应该那么陡峭。
- en: Having said that, there are some aspects of recursion that may require you to
    think in new ways if you do not have much experience with functional programming.
    Compared to `map` and `filter`, or even `reduce`, recursive approaches are far
    more flexible. And by "flexible," we mean powerful but easy to get wrong. When
    trying to get a recursive function to do just what we want, we make mistakes and
    end up in infinite loops, blowing the call stack (we'll discuss what that means
    shortly) or getting other kinds of errors that would simply not be possible otherwise.
    This is why "looping," whether it's with the `loop` macro or with recursive functions,
    should always be what you turn to when the other options just won't work.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，如果你在函数式编程方面没有太多经验，递归的一些方面可能需要你以新的方式思考。与 `map` 和 `filter` 或甚至 `reduce` 相比，递归方法要灵活得多。而“灵活”意味着强大但容易出错。当我们试图让递归函数只做我们想要的事情时，我们会犯错误，最终陷入无限循环，耗尽调用栈（我们很快就会讨论这意味着什么）或遇到其他类型的错误，否则这些错误根本不可能发生。这就是为什么“循环”，无论是使用
    `loop` 宏还是递归函数，都应该是在其他选项不起作用时你转向的选择。
- en: 'Clojure''s Most Procedural Loop: doseq'
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure 最程序性的循环：doseq
- en: 'Before we get started with recursion, let''s take a look at the `doseq` macro.
    It is arguably the most procedural of Clojure''s looping alternatives. At least,
    it looks a lot like the `foreach` loop found in other languages. Here''s a very
    simple use of `doseq`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始递归之前，让我们先看看 `doseq` 宏。它可以说是 Clojure 循环替代方案中最程序性的。至少，它看起来很像其他语言中找到的 `foreach`
    循环。下面是 `doseq` 的一个非常简单的用法：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Translated into English, we might say: "For each integer from 0 to 5, print
    out a string with the word ''Line'' and the integer." You might ask: "*What is
    that nil doing there?*" Good question. `doseq` always returns `nil`. In other
    words, `doseq` doesn''t collect anything. The sole purpose of `doseq` is to perform
    side effects, such as printing to the REPL, which is what `println` does here.
    The strings that appear in your REPL—`Line 0`, `Line 1`, and so on—are not returned
    values; they are side effects.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将其翻译成英文，我们可能会说：“对于从 0 到 5 的每个整数，打印出一个包含单词 'Line' 和整数的字符串。”你可能会问：“*那里那个 nil
    是做什么的？*”这是个好问题。`doseq` 总是返回 `nil`。换句话说，`doseq` 不收集任何东西。`doseq` 的唯一目的是执行副作用，比如打印到
    REPL，这正是 `println` 在这里所做的。出现在你的 REPL 中的字符串——`Line 0`、`Line 1` 等等——不是返回值；它们是副作用。
- en: Note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In Clojure, like in many languages in the Lisp family, functions that produce
    side effects often have names that end with an exclamation point. While it's not
    a firm rule, this convention does make code easier to read and helps to remind
    us to be careful of side effects. Clojure developers often use an exclamation
    point to indicate that a function modifies a mutable data structure, writes to
    a file or a database, or performs any kind of operation that produces a lasting
    effect outside the scope of the function.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clojure 中，就像在 Lisp 家族中的许多语言中一样，产生副作用的函数通常以感叹号结尾。虽然这不是一个严格的规则，但这种约定确实使代码更容易阅读，并有助于提醒我们注意副作用。Clojure
    开发者经常使用感叹号来表示一个函数修改了一个可变的数据结构，写入文件或数据库，或执行任何在函数作用域之外产生持久影响的操作。
- en: So, why not just use `map`? Well, there are a couple of good reasons. The first
    is that `map` does not guarantee that the entire sequence will be executed. The
    `map` function is lazy, and `doseq` is not.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么不直接使用 `map` 呢？好吧，有几个很好的理由。第一个是 `map` 并不保证整个序列都会被执行。`map` 函数是惰性的，而 `doseq`
    不是。
- en: 'Generally, with `map`, `filter`, `reduce`, and all the other sequence-manipulating
    functions, you should always try to use `println` statement can be a lifesaver.
    (Remember, though, that `println` returns `nil`, so you have to be careful not
    to place it at the end of a function where it would mask the return value). With
    sequential data of some sort, it''s important to use `doseq` when you want to
    produce side effects, and only then. By being strict about this, you also make
    your code easier to read and maintain. `doseq` is a flag in your source code that
    says: "Be careful, there are side effects here!" It is also a clear signal that
    we are not interested in the return value, since `doseq` always returns `nil`.
    This practice encourages developers to isolate code with side effects in specific
    parts of a program.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，在使用 `map`、`filter`、`reduce` 以及所有其他序列操作函数时，你应该始终尝试使用 `println` 语句，这可能会救命。（不过，记住，`println`
    返回 `nil`，所以你必须小心不要将其放在函数的末尾，否则它会掩盖返回值）。对于某种类型的顺序数据，当你想要产生副作用时，使用 `doseq` 是很重要的，而且仅在此情况下。通过对此严格，你也会使你的代码更容易阅读和维护。`doseq`
    是你源代码中的一个标志，表示：“小心，这里可能有副作用！”它也是一个明确的信号，表明我们并不关心返回值，因为 `doseq` 总是返回 `nil`。这种做法鼓励开发者将具有副作用的代码隔离在程序的具体部分。
- en: 'But what if we only wanted to print something on odd-numbered lines in the
    previous example? Here''s one way we could do that:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们只想在前面例子中的奇数行打印某些内容怎么办？这里有我们可以这样做的一种方法：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There is nothing wrong with this code per se. As a general rule, though, it
    would be preferable to remove as much logic as possible from the body of `doseq`,
    perhaps doing something like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码本身并没有问题。然而，作为一般规则，最好是从 `doseq` 的主体中移除尽可能多的逻辑，可能的做法如下：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'By enforcing the separation between the place where we shape our data and the
    place where the data is consumed, not only have we removed a conditional, but
    we''ve also organized our code in a way that opens the door to better practices.
    Maybe in the future, we will need to choose differently which lines to print.
    If that happens, our code is already in the right place, written in the clear
    vocabulary of Clojure sequence handling, and possibly benefiting from lazy evaluation.
    Remember: shape the data, and then use the data.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在数据形状的地方和消费数据的地方之间强制分离，我们不仅移除了条件语句，而且以一种方式组织了我们的代码，这为更好的实践打开了大门。也许在将来，我们可能需要选择不同的行来打印。如果发生这种情况，我们的代码已经处于正确的位置，用
    Clojure 序列处理的清晰词汇编写，并且可能从惰性评估中受益。记住：塑造数据，然后使用数据。
- en: Looping Shortcuts
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环快捷方式
- en: Generally, it is best to avoid writing real loops. Clojure provides some interesting
    functions that can help in some simple cases where what you really want is just
    a **repetition** of some kind. Unlike most of the techniques in this chapter,
    these functions return lazy sequences. We mention them here because many times,
    when a loop might seem necessary at first, these functions provide a simpler solution.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，最好避免编写真正的循环。Clojure 提供了一些有趣的函数，可以在一些简单的情况下提供帮助，在这些情况下，你真正想要的只是某种形式的**重复**。与本章中的大多数技术不同，这些函数返回懒序列。我们在这里提到它们，因为很多时候，当一开始可能需要循环时，这些函数提供了一个更简单的解决方案。
- en: 'The simplest possible example is the `repeat` function, which is so simple
    that it barely qualifies as a looping construct. However, it can still come in
    handy from time to time. `repeat` simply repeats whatever value it is called with,
    returning a lazy sequence of that value. Here''s an easy way to repeat yourself:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的例子是 `repeat` 函数，它如此简单，几乎不算是循环结构。然而，它有时仍然很有用。`repeat` 简单地重复它被调用的任何值，返回一个该值的懒序列。这是一个重复自己的简单方法：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Yes, it''s that simple. Still, it can be useful if you need to quickly load
    default values into a map. Imagine a game where each player is represented by
    a map. You need to initialize the player with default values for various counters
    and most of them have a default of `0`. One way to do this is to use `repeat`.
    Since `repeat` returns a lazy sequence, it will supply just as many zeros as you
    need:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，就这么简单。尽管如此，如果你需要快速将默认值加载到映射中，它仍然可能很有用。想象一个游戏，其中每个玩家都由一个映射表示。你需要用各种计数器的默认值初始化玩家，其中大多数的默认值是
    `0`。一种方法是用 `repeat`。由于 `repeat` 返回一个懒序列，它将提供你所需要的所有零：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The next step beyond `repeat` is the `repeatedly` function. Instead of taking
    a value, `repeatedly` takes a function and returns a lazy sequence of calls to
    that function. The function provided to `repeatedly` cannot take any arguments,
    which limits its usefulness to `repeatedly` would return a list of identical values
    just like `repeat`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat` 函数之后的下一步是 `repeatedly` 函数。`repeatedly` 不是接受一个值，而是接受一个函数，并返回对该函数的懒序列调用。提供给
    `repeatedly` 的函数不能接受任何参数，这限制了它在 `repeatedly` 中的用途，就像 `repeat` 会返回一个相同值的列表一样。'
- en: 'Probably the most common use of `repeatedly` is producing a sequence of random
    values. A call to `rand-int` potentially varies every time we call it (unless,
    of course, you call `(rand-int 1)`, which can only ever return `0`.) Here''s a
    good way of producing a list of random integers from 0 to 100, where `repeatedly`
    simply calls `rand-int` 10 times. The output from `rand-int` is different nearly
    every time it''s called, so the resulting sequence is a series of random integers:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeatedly` 最常见的用途是生成随机值的序列。`rand-int` 的调用可能会每次都变化（除非，当然，你调用 `(rand-int 1)`，它只能返回
    `0`。）这是一个生成从 0 到 100 的随机整数的列表的好方法，其中 `repeatedly` 简单地调用 `rand-int` 10 次。`rand-int`
    的输出几乎每次都不同，因此生成的序列是一系列随机整数：'
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As a convenience, `repeatedly` can take an integer argument that limits the
    number of values returned. We could write the previous expression without calling
    `take`, like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，`repeatedly` 可以接受一个整数参数，限制返回值的数量。我们可以不调用 `take` 就写出前面的表达式，如下所示：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the next exercise, we'll try a more complex scenario using `repeatedly` to
    generate random test data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将尝试一个更复杂的场景，使用 `repeatedly` 生成随机测试数据。
- en: The next step beyond `repeatedly` is a function called `iterate`. Like `repeatedly`,
    `iterate` calls a function over and over again, returning the resulting lazy sequence.
    Unlike `repeatedly`, though, the function provided to `iterate` takes arguments,
    and the result of each call is passed on to the next iteration.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeatedly` 之后的下一步是一个名为 `iterate` 的函数。像 `repeatedly` 一样，`iterate` 会反复调用一个函数，返回结果懒序列。然而，提供给
    `iterate` 的函数接受参数，并且每次调用的结果会传递给下一次迭代。'
- en: 'Let''s say we have a bank account that returns an annual rate of 1% and we
    want to project what the balance will be each month for the next year. We could
    write a function like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个年利率为 1% 的银行账户，我们想要预测下一年每个月的余额。我们可以编写一个像这样的函数：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To predict the balances over the next 12 months, we have will ask for 13 months,
    since the first value returned is the starting balance:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了预测未来 12 个月的余额，我们将请求 13 个月的余额，因为返回的第一个值是起始余额：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By compounding the interest every month, you have already earned almost 5 cents
    more than the annual rate!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过每月复利，你已经比年利率多赚了几乎 5 分！
- en: Functions such as `repeatedly` and `iterate` can be used in very specific situations
    where they perfectly match what you need. The real world is often just a little
    bit more complicated though. Sometimes, the task at hand will require writing
    customized ways of moving through your data. It's time to move on to recursion.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeatedly`和`iterate`这样的函数可以在非常具体的情况下使用，它们完美地匹配你的需求。然而，现实世界通常要复杂一点。有时，手头的任务将需要编写定制的数据遍历方式。现在是时候转向递归了。'
- en: 'Exercise 6.01: An Endless Stream of Groceries'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.01：无限流杂货
- en: 'Your employer is building a system to automatically handle groceries coming
    down a conveyor belt. As part of their research, they want you to build a simulator.
    The goal is to have an endless stream of random groceries. Your job is to write
    a function to do this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您的雇主正在构建一个系统来自动处理从传送带下来的杂货。作为他们研究的一部分，他们希望您构建一个模拟器。目标是有一个无限流随机杂货。您的任务是编写一个函数来完成这项工作：
- en: Create a new directory in a convenient place; add a `deps.edn` file containing
    just an empty map and start a new REPL.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个方便的地方创建一个新的目录；添加一个只包含一个空映射的`deps.edn`文件，并启动一个新的REPL。
- en: 'Open a new file with an expressive name such as `groceries.clj` and include
    the corresponding namespace declaration:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以一个有表达力的名称，如`groceries.clj`，打开一个新文件，并包含相应的命名空间声明：
- en: '[PRE9]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Before we start, we need to build our grocery store simulator. The first step
    is to define all the possible articles. (This store doesn''t offer a lot of choices,
    but at least it has them in infinite supply.) Copy the `grocery-articles` variable
    from [https://packt.live/2tuSvd1](https://packt.live/2tuSvd1) into your REPL and
    evaluate it:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要构建我们的杂货店模拟器。第一步是定义所有可能的商品。（这个商店提供的选项不多，但至少它有无限供应。）将`grocery-articles`变量从[https://packt.live/2tuSvd1](https://packt.live/2tuSvd1)复制到你的REPL中并评估它：
- en: '[PRE10]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Define a function that will return long lists of randomly ordered grocery articles:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，该函数将返回包含随机排序杂货文章的长列表：
- en: '[PRE11]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`rand-nth` returns a randomly selected item from `grocery-articles` each time
    it is called. `repeatedly` creates a lazy sequence of calls to `rand-nth`. The
    `n` argument tells `repeatedly` how many random articles to return.'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`rand-nth`每次被调用时都会从`grocery-articles`中返回一个随机选择的商品。`repeatedly`创建了一个对`rand-nth`的调用懒惰序列。`n`参数告诉`repeatedly`返回多少个随机商品。'
- en: 'Test the function by asking for some articles:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过请求一些文章来测试函数：
- en: '[PRE12]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Try again to make sure that the results are random:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次尝试以确保结果是随机的：
- en: '[PRE13]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It seems to work. This shows how functions can be combined in cases where,
    in other languages, it might seem more natural to write a `for` loop. In JavaScript
    once again, we might write a function like this (assuming that `groceryArticles`
    is an array of objects):'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它似乎工作得很好。这展示了在在其他语言中可能更自然地写`for`循环的情况下，函数是如何被组合的。在JavaScript中，我们可能再次编写一个像这样的函数（假设`groceryArticles`是一个对象数组）：
- en: '[PRE14]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A function such as `repeatedly` provides a concise way to express this and saves
    us the trouble of writing all this iterative logic.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`repeatedly`这样的函数提供了一种简洁的方式来表达这一点，并节省了我们编写所有这些迭代逻辑的麻烦。'
- en: Recursion at Its Simplest
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归的简单应用
- en: As we said before, a recursive function is a function that, as part of its execution,
    calls itself. Visually, recursion can be imagined as something like one of those
    pictures you've probably seen, where, inside the main picture, there is a smaller
    version of the original picture. Since the second picture is identical to the
    first, it also contains a very small, third version of the picture. After that,
    any further pictures are usually hard to represent as something bigger than a
    tiny dot. However, even if we can't see them, we can imagine the process going
    on for basically forever… or at least down to the molecular level. Recursion works
    in a similar way. And the problem of a recursive process that just keeps going
    on and on, like in the picture, is also a very real issue. However, before we
    look at the pitfalls of recursion, let's take a look at some simple examples.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，递归函数是一种在执行过程中会调用自身的函数。直观上，递归可以想象成你可能见过的那种图片，其中在主图片内部有一个原始图片的小版本。由于第二个图片与第一个图片相同，它也包含了一个非常小的第三个图片版本。之后，任何进一步的图片通常都很难表示成比一个微小的点更大的东西。然而，即使我们看不到它们，我们也可以想象这个过程基本上永远进行下去……或者至少达到分子水平。递归以类似的方式工作。而且，像图片中那样一直持续进行的递归过程的问题也是一个非常现实的问题。然而，在我们查看递归的陷阱之前，让我们先看看一些简单的例子。
- en: 'To start out, we''ll do something you already know how to do: find the sum
    of a collection of numbers. In real life, you would never use recursion for this,
    but the problem is deliberately simple so that we can point out some of the mechanisms
    of recursion:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将做一件你已经知道如何做的事情：找到一组数字的总和。在现实生活中，你永远不会为此使用递归，但这个问题故意设计得简单，这样我们就可以指出一些递归的机制：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A call to this function would look like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的调用看起来是这样的：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This probably looks familiar to you because this is quite similar to the functions
    we passed to `reduce`. This isn't too surprising. We could even think of `reduce`
    as a framework for "controlled recursion," or "recursion with guardrails," which
    is why it's generally best to use `reduce` when you can, and recursion only when
    you must.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能对你来说很熟悉，因为这与我们传递给`reduce`的函数非常相似。这并不令人惊讶。我们甚至可以将`reduce`视为“受控递归”或“有护栏的递归”的框架，这就是为什么在可能的情况下通常最好使用`reduce`，只有在必须时才使用递归。
- en: 'There are some important differences here though, so let''s take a closer look
    at how this function works. The first thing to notice is the conditional with
    two branches: `(if (first numbers))`. When we first call the function, `(first
    numbers)` returns 300\. That''s truthy, so we keep going, and right away our functions
    call `recursive-sum` again (we warned you, there''s going to be a lot of this
    in recursion.) The function gets called again but with different arguments: `(first
    numbers)` gets added to `so-far`, our accumulator, and instead of using numbers
    again as the second argument, we have `(next numbers)`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里有一些重要的区别，所以让我们更仔细地看看这个函数是如何工作的。首先要注意的是有两个分支的条件语句：`(if (first numbers))`。当我们第一次调用这个函数时，`(first
    numbers)`返回300。这是真值，所以我们继续进行，并且立即我们的函数再次调用`recursive-sum`（我们警告过你，递归中会有很多这种情况）。函数再次被调用，但参数不同：`(first
    numbers)`被加到我们的累加器`so-far`上，而不是再次使用`numbers`作为第二个参数，我们有了`(next numbers)`。
- en: 'With each call to `recursive-sum`, one more integer is shifted from the input
    sequence to the output integer:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`recursive-sum`，从输入序列到输出整数的一个整数就会被移动：
- en: '![Figure 6.1: Recursively moving items from the input sequence to the output
    integer'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1：递归地将输入序列中的项移动到输出整数'
- en: '](img/B14502_06_01.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_06_01.jpg)'
- en: 'Figure 6.1: Recursively moving items from the input sequence to the output
    integer'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：递归地将输入序列中的项移动到输出整数
- en: 'With `reduce`, we don''t need to think about how to advance through the sequence.
    The `reduce` function itself takes care of the mechanics of the iterations: moving
    from one item to the next and stopping when there are no more items. With a recursive
    function, it''s up to us to make sure that each function call receives the right
    data and that the function stops when the data has been consumed. When you need
    it, recursion is extremely powerful because, as the programmer, you have complete
    control over the iteration. You get to decide what the arguments of each successive
    call will hold. You also get to decide how and when the recursion will stop.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`reduce`，我们不需要考虑如何遍历序列。`reduce`函数本身负责迭代的机制：从一个项目移动到下一个项目，并在没有更多项目时停止。在递归函数中，我们必须确保每个函数调用都接收到正确的数据，并且在数据被消耗后函数停止。当你需要它时，递归非常强大，因为作为程序员，你完全控制迭代。你可以决定每个后续调用的参数是什么。你也可以决定递归如何以及何时停止。
- en: So, how do we move through the sequence? On each call to `recursive-sum`, the
    input sequence is split between the first item and all the following items. The
    call to `first` gives us the current item, and the call to `next` helps set up
    the argument for the next function call. Repeating this splitting action moves
    us down the sequence.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何遍历序列呢？在每次调用`recursive-sum`时，输入序列被分成第一个项目和所有后续项目之间。`first`的调用给我们当前的项目，而`next`的调用帮助设置下一次函数调用的参数。重复这个分割动作使我们沿着序列向下移动。
- en: 'There is one more problem, though: when do we stop? This is why our function,
    like the vast majority of recursive functions, is organized around a condition.
    Ours is simple: stop adding or keep going? The `next` function is important here
    too. When called on an empty list, `next` returns `nil`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个问题：我们何时停止？这就是我们的函数，就像绝大多数递归函数一样，围绕一个条件组织起来的原因。我们的条件很简单：停止添加还是继续？`next`函数在这里也很重要。当对一个空列表调用时，`next`返回`nil`：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this case, `nil` reliably means that it is time to stop iterating and just
    return the value that we have accumulated. More complex situations will require
    more complicated branching, but the basic idea generally remains the same.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`nil` 可靠地意味着是时候停止迭代并返回我们积累的值了。更复杂的情况将需要更复杂的分支，但基本思想通常保持不变。
- en: 'Exercise 6.02: Partitioning Grocery Bags'
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.02：分割购物袋
- en: 'In this exercise, we''ll go back to the grocery conveyor belt simulation from
    the previous exercise. Now that we can simulate an endless stream of random articles,
    we need to be able to place the food items into grocery bags as they arrive at
    the end of the belt. If the bag gets too full, it will break or start to overflow.
    We need to know when to stop before it gets too full. Luckily, a barcode reader
    can tell us the weight and longest dimension of the items. If either of these
    gets beyond a certain number, the bag is removed and replaced with an empty bag:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将回到上一个练习中的购物传送带模拟。现在我们能够模拟一个无限的文章流，我们需要能够在传送带末端到达时将食品项目放入购物袋。如果袋子太满，它就会破裂或开始溢出。我们需要知道何时停止，以免它太满。幸运的是，条形码阅读器可以告诉我们物品的重量和最长尺寸。如果这些中的任何一个超过了某个数值，袋子就会被移除，并用一个空袋子替换：
- en: Use the same environment as in the previous exercise.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与上一个练习相同的 环境。
- en: 'Our grocery bags will be modeled as lists of articles. Define a `full-bag?`
    predicate so that we''ll know when to stop filling a bag:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将购物袋建模为文章的列表。定义一个 `full-bag?` 断言，这样我们就会知道何时停止填充袋子：
- en: '[PRE18]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Test `full-bag?` with the output from grocery streams of different lengths:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不同长度的购物流输出测试 `full-bag?`：
- en: '[PRE19]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Set up two functions, `bag-sequences` and its recursive helper function, `bag-sequences*`.
    Define `bag-sequences*` first, since `bag-sequences` will call it:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置两个函数，`bag-sequences` 和它的递归辅助函数 `bag-sequences*`。首先定义 `bag-sequences*`，因为 `bag-sequences`
    将调用它：
- en: '[PRE20]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see from the arguments to the helper function, we''ve defined an
    accumulator, this time with two fields: `:bags` will hold the list of all the
    completed bags and `:current-bag` will hold the items we are testing. When `:current-bag`
    fills up, we will place it in `:bags` and start off with a fresh, empty vector
    in `:current-bag`.'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您从辅助函数的参数中看到的那样，我们定义了一个累加器，这次有两个字段：`:bags` 将保存所有完成的包的列表，而 `:current-bag` 将保存我们正在测试的项目。当
    `:current-bag` 填满时，我们将它放入 `:bags`，并在 `:current-bag` 中开始一个新的空向量。
- en: The second function, without the asterisk, will be the public-facing function.
    Users of our library won't have to worry about supplying the accumulator; `bag-sequences*`
    will be the truly recursive function and do all the work.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个函数，没有星号，将是面向公众的函数。我们库的用户不必担心提供累加器；`bag-sequences*` 将是真正的递归函数，并完成所有工作。
- en: 'Inside the `bag-sequences*` function, we will use a `cond` expression to react
    to the state of the articles as they arrive. Write the first, negative condition
    of the `cond` expression:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bag-sequences*` 函数内部，我们将使用 `cond` 表达式来对到达的文章的状态做出反应。写出 `cond` 表达式的第一个，负条件：
- en: '[PRE21]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we decide what happens if there are no more articles in `stream`. If there's
    nothing left to put in the bag, then it's time to add `current-bag` to the list
    and return everything we've accumulated so far.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们决定如果 `stream` 中没有更多的文章会发生什么。如果没有东西可以放入包中，那么就是时候将 `current-bag` 添加到列表中，并返回到目前为止积累的所有内容。
- en: Note
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 备注
- en: In recursive functions, it's common practice to test whether the end of the
    input sequence has been reached as early as possible. This test is often a simple
    one, so it's good to get it out of the way. More importantly, if we know that
    the input sequence is not empty, we don't have to guard against `nil` values in
    the tests that follow. This helps eliminate some possible errors in the subsequent
    test clauses and allows us to write simpler, more readable code.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在递归函数中，尽早测试输入序列是否到达末尾是一种常见的做法。这个测试通常很简单，所以最好把它放在一边。更重要的是，如果我们知道输入序列不为空，我们就不必在后续的测试中防范
    `nil` 值。这有助于消除后续测试子句中的一些可能错误，并允许我们编写更简单、更易读的代码。
- en: 'Add the condition for when the current bag is full:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加当前袋子满的条件：
- en: '[PRE22]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Thanks to the convenient `full-bag?` function, we know that the current bag
    is full. This means we need to move some data around inside `acc` when we make
    the next call to `bag-sequences*`. Both of the arguments to `bag-sequences*` need
    to be updated. Our call to `assoc` may look strange at first glance, but `assoc`
    can accept multiple pairs of keys and values.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 多亏了方便的 `full-bag?` 函数，我们知道当前袋子已满。这意味着当我们下一次调用 `bag-sequences*` 时，我们需要在 `acc`
    内部移动一些数据。`bag-sequences*` 的两个参数都需要更新。我们的 `assoc` 调用一开始看起来可能有些奇怪，但 `assoc` 可以接受多个键值对。
- en: The most recent article in `stream` is going to become the first article in
    a new "bag" vector, so we assign that to the `:current-bag` key in `acc`. At this
    point, the `current-bag` binding (from the destructuring in the function's parameters)
    still refers to the bag we decided is full. We are going to add it to the list
    of bags we are maintaining in the `:bags` key in `acc`.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`stream` 中最新的文章将成为新“袋”向量中的第一篇文章，因此我们将它分配给 `acc` 中的 `:current-bag` 键。此时，`current-bag`
    绑定（来自函数参数中的解构）仍然指向我们决定已满的袋子。我们将把它添加到我们在 `acc` 中的 `:bags` 键维护的袋子列表中。'
- en: 'And since we want to keep advancing through `stream`, we use `next` to move
    on to the next article: `(next stream)`.'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们希望继续前进到 `stream`，我们使用 `next` 来跳转到下一篇文章：（`next stream`）。
- en: 'Write the final, default condition. If we''ve made it past the two previous
    conditions, we know that `stream` is not empty and that the current bag is not
    full. In this case, all we need to do is add the current article to the current
    bag. With this condition, our function is complete:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写最终的默认条件。如果我们已经通过了前两个条件，我们知道 `stream` 不为空，当前袋子也没有满。在这种情况下，我们只需要将当前文章添加到当前袋子中。有了这个条件，我们的函数就完成了：
- en: '[PRE23]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This time, we'll use `update` instead of `assoc` to "modify" the `:current-bag`
    key in `acc`. This form of the `update` function takes, as its third argument,
    a function that will be applied to the value corresponding to the key provided
    and any further arguments. That means that, in this case, `conj` will be called
    as if we had written `(conj (:current-bag acc) (first stream))`.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次，我们将使用 `update` 而不是 `assoc` 来“修改” `acc` 中的 `:current-bag` 键。这种形式的 `update`
    函数将其第三个参数作为一个函数，该函数将被应用于与提供的键对应的值以及任何进一步的参数。这意味着在这种情况下，`conj` 将被调用，就像我们写了 `(conj
    (:current-bag acc) (first stream))` 一样。
- en: 'Test the function using the `article-stream` function that we wrote in the
    previous exercise:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们在上一项练习中编写的 `article-stream` 函数来测试该函数：
- en: '[PRE24]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This seems to work! Each bag appears as a vector of items. The length of the
    vectors varies depending on the size and weight of the items.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这看起来似乎有效！每个袋子都表现为一个物品的向量。向量的长度取决于物品的大小和重量。
- en: 'We''ve solved one of the problems we mentioned at the beginning of the chapter:
    traversing a sequence in steps of different lengths. In this example, we''ve partitioned
    the input sequence into chunks whose size depends on the properties of the underlying data.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解决了我们在本章开头提到的问题之一：以不同长度的步骤遍历序列。在这个例子中，我们将输入序列分割成大小取决于底层数据属性的数据块。
- en: When to Use recur
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用 recur
- en: 'Now, `bag-sequence` worked fine for relatively short `grocery-stream` sequences,
    but when we moved it into production in our multimodal grocery mega-platform,
    the entire system ground quickly to a halt. Here''s the message that appeared
    on all the technicians'' consoles:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`bag-sequence` 对于相对较短的 `grocery-stream` 序列工作得很好，但当我们将其移入我们的多模式杂货超级平台的生产环境中时，整个系统迅速陷入停滞。这是出现在所有技术人员控制台上的消息：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: So, what happened? What's a `StackOverflowError`?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，发生了什么？什么是 `StackOverflowError`？
- en: The **stack** is how the JVM keeps track of nested function calls. Each function
    call requires a little bit of bookkeeping to maintain some contextual information,
    such as the value of local variables. The runtime also needs to know where the
    results of each call should go. When a function is called within another function,
    the outer function waits for the inner function to complete. If the inner function
    also calls other functions, it too must wait for those to complete, and so on.
    The job of the stack is to keep track of these chains of function calls.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 栈（**stack**）是 JVM 跟踪嵌套函数调用的一种方式。每次函数调用都需要进行一点簿记工作来维护一些上下文信息，例如局部变量的值。运行时还需要知道每个调用的结果应该放在哪里。当一个函数在另一个函数内部被调用时，外部函数会等待内部函数完成。如果内部函数也调用了其他函数，它也必须等待这些函数完成，依此类推。栈的工作是跟踪这些函数调用的链。
- en: 'We can use a very simple function as an illustration. This one takes two integers
    and performs two different operations on them:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个非常简单的函数来举例。这个函数接受两个整数并对它们执行两种不同的操作：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here''s a simplified version of what happens when we call `tiny-stack`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是调用 `tiny-stack` 时发生情况的简化版本：
- en: We call `tiny-stack` and an initial stack frame is produced. It waits for the
    contents of the function to be evaluated.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 `tiny-stack` 并产生一个初始的栈帧。它等待函数内容的评估。
- en: While `tiny-stack` waits, the `*` function is called. A new stack frame is produced.
    The `b` binding evaluates right away, but it can't return yet because of the call
    to `+`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `tiny-stack` 等待的同时，`*` 函数被调用。产生一个新的栈帧。`b` 绑定立即评估，但由于对 `+` 的调用，它还不能返回。
- en: '`+` is finally called, producing a new, short-lived stack frame. The two integers
    are added together, the value is returned, and the stack frame of `+` is erased.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`+` 最终被调用，产生一个新的、短暂的栈帧。两个整数相加，返回值，然后擦除 `+` 的栈帧。'
- en: The call to `*` can now complete. It passes its return value back up to `tiny-stack`
    and then its stack frame is erased.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` 的调用现在可以完成。它将返回值传递回 `tiny-stack`，然后擦除其栈帧。'
- en: '`tiny-stack` returns `77` and its stack frame is erased:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`tiny-stack` 返回 `77` 并擦除了其栈帧：'
- en: '![Figure 6.2: A visualization of stack frames in nested function calls'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2：嵌套函数调用中栈帧的可视化](img/B14502_06_02.jpg)'
- en: '](img/B14502_06_02.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14502_06_02.jpg](img/B14502_06_02.jpg)'
- en: 'Figure 6.2: A visualization of stack frames in nested function calls'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：嵌套函数调用中栈帧的可视化
- en: 'This is how the stack frame is supposed to work. Most of the time, we don''t
    have to think about it at all. However, when we use recursion to walk the length
    of a sequence, we are actually using the stack, through nesting, to move along
    the sequence. Because there are limits to how many stack frames the runtime can
    handle, if we have a very long sequence, we will eventually run out of stack frames
    and our program will explode:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是栈帧应该工作的方式。大多数时候，我们根本不需要考虑它。然而，当我们使用递归遍历序列的长度时，我们实际上是通过嵌套使用栈来移动序列的。因为运行时可以处理的栈帧数量有限，如果我们有一个非常长的序列，我们最终会耗尽栈帧，我们的程序将会崩溃：
- en: '![Figure 6.3: Representation of recursion'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3：递归的表示](img/B14502_06_03.jpg)'
- en: '](img/B14502_06_03.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14502_06_03.jpg](img/B14502_06_03.jpg)'
- en: 'Figure 6.3: Representation of recursion'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：递归的表示
- en: With recursion, the length of the input vector is translated into depth in the
    call stack until it goes too far
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用递归，输入向量的长度被转换为调用栈中的深度，直到它太深
- en: At this point, you're probably thinking that recursion doesn't sound like such
    a great pattern after all. This is actually due to a limitation that is built
    into the JVM. Other Lisps, not based on the JVM, do not have this limitation,
    and, in those languages, the preceding code would work just fine.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能认为递归根本不是一个很好的模式。这实际上是由于JVM中内置的限制。其他基于JVM的Lisp没有这个限制，在这些语言中，前面的代码会正常工作。
- en: 'There is, however, a solution in Clojure, and it is called `recur`. Let''s
    take another look at the `recursive-sum` function that we wrote in the last section:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Clojure中有一个解决方案，它被称为 `recur`。让我们再次看看我们在上一节中编写的 `recursive-sum` 函数：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'First, let''s watch this explode on a long input sequence:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看在长输入序列上会发生什么爆炸：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To use `recur`, we simply replace the call to `recursive-sum` with the `recur`
    in our original equation:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `recur`，我们只需将原始方程中的 `recursive-sum` 调用替换为 `recur`：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Why does this work? Well, with `recur`, a function becomes tail recursive. **Tail
    recursion** means that successive calls don't add to the call stack. Instead,
    the runtime treats them as repetitions of the current frame. You can think of
    this as a way of staying in the same frame rather than waiting for all the nested
    calls to resolve. In this way, the looping can continue without adding to the
    stack. This allows us to process large amounts of data without running into the
    dreaded stack overflow.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这会起作用呢？好吧，使用 `recur`，一个函数变成了尾递归。**尾递归**意味着连续的调用不会增加调用栈。相反，运行时会将它们视为当前帧的重复。你可以将其视为保持在同一帧中，而不是等待所有嵌套调用解决。这样，循环可以继续而不会增加栈的大小。这允许我们处理大量数据而不会遇到可怕的栈溢出。
- en: A function can only be tail recursive if it returns a complete call to itself
    and nothing more. This is a little hard to understand at first, but it should
    become clearer as we work through some examples. In the next exercise, we'll look
    at a straightforward use of `recur` in a tail recursive function.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数只有在其返回一个完整的自我调用且没有其他内容时才能是尾递归。一开始这可能有点难以理解，但随着我们通过一些示例进行工作，它应该会变得更加清晰。在下一个练习中，我们将查看在尾递归函数中直接使用
    `recur` 的简单例子。
- en: 'Exercise 6.03: Large-Scale Grocery Partitioning with recur'
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.03：使用 `recur` 进行大规模杂货分区
- en: 'As we mentioned before, our previous experiment with `bag-sequences` did not
    scale well once the input stream became too long because we ran into stack overflow
    exceptions. Maybe we can improve on the previous design by using `recur`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，我们之前对 `bag-sequences` 的实验在输入流变得过长时扩展性不好，因为我们遇到了栈溢出异常。也许我们可以通过使用 `recur`
    来改进之前的设计：
- en: Set up the same environment as in the previous exercise.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将环境设置成与上一个练习相同。
- en: Make a copy of the `bag-sequences` and `bag-sequences*` functions with new names,
    such as `robust-bag-sequences` and `robust-bag-sequences*`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `bag-sequences` 和 `bag-sequences*` 函数复制一份，并使用新名称，例如 `robust-bag-sequences`
    和 `robust-bag-sequences*`。
- en: 'In `robust-bag-sequences*`, use `recur` instead of calling `bag-sequences*`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `robust-bag-sequences*` 中，使用 `recur` 而不是调用 `bag-sequences*`：
- en: '[PRE30]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The only difference with the previous version of `bag-sequences*` is that we've
    replaced the recursive calls (where we wrote out the function name, `bag-sequences*`)
    with `recur`. This function is tail recursive. Why? Well, let's look at the three
    possible outputs that correspond to the three branches of the `cond` expression.
    The first branch simply returns data, so there is no recursion at all there. The
    other two return calls to `recur` that are the last things to be evaluated in
    the function. This fits our definition of tail recursion, which is that the function
    must return a call to itself *and nothing else*.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与 `bag-sequences*` 的上一个版本相比，唯一的区别是我们已经将递归调用（我们写出的函数名，`bag-sequences*`）替换为 `recur`。这个函数是尾递归的。为什么？好吧，让我们看看与
    `cond` 表达式的三个分支相对应的三个可能的输出。第一个分支只是返回数据，所以那里根本没有任何递归。其他两个返回 `recur` 的调用，这是函数中最后要评估的内容。这符合尾递归的定义，即函数必须返回一个对自身的调用
    *并且没有其他内容*。
- en: 'In the public-facing `robust-bag-sequences` function, don''t forget to update
    the call to `bag-sequences*` to the new function name:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在面向公众的 `robust-bag-sequences` 函数中，别忘了将 `bag-sequences*` 的调用更新为新函数名：
- en: '[PRE31]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Evaluate your namespace and test the new function on a very long `article-stream`.
    Don't forget to assign the result to a variable, otherwise it will fill your REPL!
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估你的命名空间，并在一个非常长的 `article-stream` 上测试新函数。别忘了将结果赋值给一个变量，否则它将充满你的 REPL！
- en: 'Here, we put 1 million articles into 343,091 bags:'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将一百万篇文章放入 343,091 个袋子中：
- en: '[PRE32]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Because the contents of `article-stream` are random, your results will be slightly
    different.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 `article-stream` 的内容是随机的，你的结果可能会有所不同。
- en: This example shows the basics of using `recur` to easily improve the performance
    of the recursive function. The `robust-bag-sequences*` function is indeed tail
    recursive because it returns a complete call to itself and nothing more.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个例子展示了使用 `recur` 来轻松提高递归函数性能的基本方法。`robust-bag-sequences*` 函数确实是尾递归的，因为它返回一个完整的自我调用且没有其他内容。
- en: What about loop?
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么 `loop` 呢？
- en: As you may already know, Clojure does, in fact, have a `loop` macro. If, on
    hearing that, you're suddenly thinking "Great, I can just use `loop` instead!,"
    you are probably going to be disappointed. The `loop` macro can indeed be useful,
    but the terrible secret of `loop` is that it is almost identical to writing a
    recursive function with `recur`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Clojure 确实有一个 `loop` 宏。如果你听到这个，突然想到“太好了，我可以用 `loop` 来代替！”，你可能会感到失望。`loop`
    宏确实是有用的，但 `loop` 的可怕秘密是它几乎与使用 `recur` 编写的递归函数相同。
- en: The advantage of the `loop` macro is that it can be contained inside a function.
    This removes the need to write a public function that sets up the recursion and
    possibly does some "post-production" on the result, and a helper function that
    does the actual recursion. There is nothing wrong with that pattern, of course,
    but using `loop` can make a namespace easier to read by limiting the number of
    functions that need to be defined.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop` 宏的优势在于它可以包含在函数内部。这消除了编写一个设置递归并可能在结果上做一些“后期制作”的公共函数以及一个执行实际递归的辅助函数的需要。当然，这种模式没有问题，但使用
    `loop` 可以通过限制需要定义的函数数量来使命名空间更容易阅读。'
- en: Note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Clojure provides another mechanism for avoiding public functions. Functions
    defined with `defn-` instead of `defn` are only available inside the namespace
    where they are defined.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure提供了另一种避免公共函数的机制。使用`defn-`而不是`defn`定义的函数仅在其定义的命名空间内可用。
- en: The basic logic and structure of `loop` is really quite similar to that of a
    function with `recur:` a call to `loop` starts with one or more bindings and,
    just like a recursive function, starts over again thanks to `recur`. Just like
    with a recursive function, the parameters to `recur` must be modified on each
    iteration to avoid looping infinitely. And calls to `loop` must also be tail recursive,
    just like functions using `recur`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop`的基本逻辑和结构与使用`recur`的函数非常相似：`loop`的调用以一个或多个绑定开始，就像递归函数一样，由于`recur`而重新开始。就像递归函数一样，`recur`的参数必须在每次迭代中修改，以避免无限循环。并且`loop`的调用也必须是尾递归，就像使用`recur`的函数一样。'
- en: 'Here is a simple skeleton for a function that uses `loop` to do something to
    the articles in our imaginary grocery store. Let''s suppose that the `process`
    function does something important with each article, such as sending an API call
    to a different service. For now, we''ll define it as a stub function aliased to
    `identity`, which is the Clojure function that simply returns whatever arguments
    it is provided with:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用`loop`对想象中的杂货店中的商品进行操作的函数的简单框架。假设`process`函数对每个商品执行一些重要操作，例如向不同的服务发送API调用。现在，我们将它定义为别名`identity`的存根函数，这是Clojure函数，它简单地返回它提供的任何参数：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Obviously, the basic pattern is very similar to the recursive functions that
    we''ve already looked at: the conditionals to detect whether to continue iterating,
    and the call to `recur` at the end, are starting to become very familiar to you.
    It''s important to remember that the initial bindings are just that: initial.
    Just like arguments to a function, they are assigned at the beginning of the loop
    and then reassigned by the calls to `recur`. Making sure that the iteration continues
    smoothly and not infinitely is up to you.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，基本模式与我们之前看过的递归函数非常相似：检测是否继续迭代的条件语句，以及在末尾的`recur`调用，开始变得非常熟悉。重要的是要记住，初始绑定只是那样：初始。就像函数的参数一样，它们在循环开始时分配，然后通过`recur`调用重新分配。确保迭代能够顺利且不会无限进行，取决于你。
- en: 'Exercise 6.04: Groceries with loop'
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.04：使用`loop`处理杂货
- en: 'Use `loop` to rewrite the `robust-bag-sequences` function from the previous
    exercise:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`loop`重写之前练习中的`robust-bag-sequences`函数：
- en: Use the same environment as the previous exercises.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与之前练习相同的环境。
- en: 'Write the outline for a function with the same call signature as `robust-bag-sequences`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为具有与`robust-bag-sequences`相同调用签名的函数编写大纲：
- en: '[PRE34]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Set up a loop inside the function with the same arguments as `robust-bag-sequences*`:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数内部设置一个循环，其参数与`robust-bag-sequences*`相同：
- en: '[PRE35]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, the initial setup of our accumulator is going to happen in the
    bindings.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们的累加器的初始设置将在绑定中发生。
- en: 'Fill in the rest of the logic by reusing the code from `robust-bag-sequences*`
    in the previous exercise:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过重用之前练习中的`robust-bag-sequences*`代码，填写其余的逻辑：
- en: '[PRE36]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This version is almost the same as the original. The primary difference is that,
    because of the way the variables are bound, we end up using a `let` binding to
    destructure the accumulator in order to have the `current-bag` and `bags` bindings.
    Other than that, the code is the same.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个版本几乎与原始版本相同。主要区别在于，由于变量的绑定方式，我们最终使用`let`绑定来解构累加器，以便有`current-bag`和`bags`绑定。除此之外，代码相同。
- en: 'Test the new version of the function:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试函数的新版本：
- en: '[PRE37]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This version of the code illustrates how similar `loop` and a recursive function
    can be. Choosing one form or the other depends mostly on which version will make
    your code easier to understand. Thinking of `loop` as a form of recursion will
    also make it easier to remember to write tail recursive code inside the loop.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码展示了`loop`和递归函数可以多么相似。选择哪种形式主要取决于哪种版本会使你的代码更容易理解。将`loop`视为一种递归形式也会使你更容易记住在循环内编写尾递归代码。
- en: Tail Recursion
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾递归
- en: As we said earlier, `recur` tells the JVM to expect the function to be tail
    recursive. What does that mean exactly, though? Replacing the function name with
    `recur` is not, in fact, enough to make a recursive function call tail recursive.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所说，`recur`告诉JVM期望函数是尾递归。但这究竟意味着什么呢？用`recur`替换函数名实际上并不足以使递归函数调用成为尾递归。
- en: 'Let''s start with an example of what happens when a recursive function is *not*
    tail recursive. So far, we''ve done a lot of adding of sequences of integers.
    Here''s a new twist: suppose the integers are not in a simple sequence, but in
    nested sequences, perhaps like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从递归函数不是*尾递归*时会发生什么的例子开始。到目前为止，我们已经做了很多整数序列的添加。这里有一个新的变化：假设整数不是简单的序列，而是在嵌套序列中，可能像这样：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Nested vectors like this are a common way of representing trees in Clojure.
    The vectors themselves are the branch nodes and the integers, in this case, are
    the leaves:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套向量如这种在Clojure中是表示树的一种常见方式。这些向量本身是分支节点，而在这个例子中，整数是叶子：
- en: '![Figure 6.4: Nested vectors are a common way of representing tree structures'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4：嵌套向量是表示树结构的一种常见方式'
- en: '](img/B14502_06_04.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_06_04.jpg)'
- en: 'Figure 6.4: Nested vectors are a common way of representing tree structures'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：嵌套向量是表示树结构的一种常见方式
- en: 'We haven''t seen this kind of problem yet. It happens to be the kind of problem
    for which recursion is possibly the best or even the only solution. It''s also
    an important kind of problem: these nested vectors actually define a tree structure.
    Trees are, of course, one of the most useful ways of representing data, so this
    is a fairly important subject.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有遇到过这种问题。这恰好是递归可能是最佳或甚至是唯一解决方案的问题类型。它也是一个重要的类型：这些嵌套向量实际上定义了一个树结构。树当然是表示数据最有用的方式之一，所以这是一个相当重要的主题。
- en: 'Essentially, to solve this problem, we need a recursive function that adds
    when it sees a number and calls itself when it sees a list. Here''s a start that
    looks a lot like some of the other functions we''ve written so far:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，要解决这个问题，我们需要一个递归函数，当它看到数字时进行加法，当它看到列表时调用自身。这里是一个看起来很像我们之前写过的其他函数的起点：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The first condition in the `cond` form is pretty standard: if we''re at the
    end of the input, we just return whatever is in `so-far`, our accumulator. The
    next condition should also seem pretty straightforward by now: if we have a number,
    add it to our running total and keep going by splitting the input sequence between
    the first item and the next items.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`cond`形式中的第一个条件相当标准：如果我们到达输入的末尾，我们只需返回`so-far`（我们的累加器）中的内容。下一个条件现在也应该看起来相当直接：如果我们有一个数字，将其加到我们的运行总和中，然后通过在第一个项目和下一个项目之间拆分输入序列继续进行。'
- en: 'Now, let''s write that last condition for when `(first x)` is a vector. The
    new call to `recur` will need to calculate `(first x)` so that it can be an integer.
    Here''s what that would have to look like:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为当`(first x)`是一个向量时的情况写下最后一个条件。新的`recur`调用需要计算`(first x)`以便它可以是整数。这将是这样的：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you type this into your REPL and evaluate it, you''ll get an error:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这段代码输入到你的REPL中并评估它，你会得到一个错误：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: What's going on? Why doesn't this work?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？为什么这不起作用？
- en: On the surface, we're just respecting the established pattern. The nested call
    to `recur` does look a little strange. But if `(first x)` is a vector or a list,
    we can't just add it to `so-far`. Our function needs an integer as the `so-far`
    argument. We need to transform the vector at `(first x)` into an integer by evaluating
    that entire part of the tree. And when that's done, and we have a nice, simple
    integer instead of a subtree, we can finally move on to the rest of the sequence,
    with `(next x)`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上，我们只是在遵循既定的模式。嵌套的`recur`调用看起来有点奇怪。但如果`(first x)`是一个向量或列表，我们不能简单地将其添加到`so-far`中。我们的函数需要一个整数作为`so-far`参数。我们需要通过评估整个树的部分将`(first
    x)`中的向量转换成整数。当这完成时，我们有了简单、简单的整数而不是子树，我们最终可以继续处理序列的其余部分，使用`(next x)`。
- en: 'The reason that the compiler refuses to compile our code, though, is that,
    because of the final line, the function is not tail recursive. In the last line
    of the function, the first `recur` has to wait for the second one to finish before
    moving on. That is a violation of the tail position requirement of `recur`: simultaneous
    calls to `recur` are forbidden. As we said before, to be tail recursive, a function
    must return only a call to itself, and nothing more. But in this case, one `recur`
    is waiting for the other to return.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编译器拒绝编译我们的代码的原因是，由于最后一行，该函数不是尾递归的。在函数的最后一行，第一个`recur`必须等待第二个完成后再继续。这是对`recur`的尾位置要求的违反：禁止同时调用`recur`。正如我们之前所说的，要成为尾递归，一个函数必须只返回对自身的调用，不再有其他操作。但在这个情况下，一个`recur`正在等待另一个返回。
- en: 'We could also think about this in terms of stack frames. Tail recursion means
    that when the recursive function is called again (through `recur`), a new frame
    is not produced: the previous function call is "forgotten," or "erased," by the
    new one. The only trace of the previous calls is in the changes made to the arguments
    to the current call. The problem with this function is that the first call to
    `recur` can''t be "forgotten." It''s waiting for the result of the second call.
    It''s only when the second call is resolved that the first will be able to continue.
    If we''re in a situation where two stack frames need to coexist, we can''t use
    `recur`. When treating linear data, this is generally not a problem. Tree structures,
    on the other hand, usually can''t be handled in the linear way required by `recur`.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从堆栈帧的角度来考虑这个问题。尾递归意味着当递归函数再次被调用（通过`recur`）时，不会产生新的帧：前一个函数调用被新的一个“忘记”或“擦除”。前一个调用的唯一痕迹是在对当前调用参数所做的更改中。这个函数的问题在于第一次调用`recur`不能被“忘记”。它正在等待第二次调用的结果。只有当第二次调用解决后，第一次调用才能继续。如果我们处于需要两个堆栈帧共存的情况，我们就不能使用`recur`。当处理线性数据时，这通常不是问题。另一方面，树结构通常不能以`recur`所需的线性方式处理。
- en: 'Let''s try rewriting the same function without using `recur`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试不使用`recur`重写同一个函数：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This works! We might have a new problem, though. Without `recur`, this version
    of the function will explode the stack when run on a tree with too many items.
    This may, or may not, be a problem, depending on what kind of data needs to be
    processed. If we did have many thousands of items and sub-vectors, we would need
    to find another solution. For that, you'll need to wait until the next chapter,
    where we'll learn about producing our own **lazy sequences**, which will permit
    us to use recursion on large, complex trees.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这行得通！尽管我们可能遇到了新问题。没有`recur`，这个函数版本在运行包含太多项目的树时可能会使栈爆炸。这可能是也可能不是问题，这取决于需要处理的数据类型。如果我们有数千个项目或子向量，我们就需要找到另一种解决方案。为此，你需要等待下一章，我们将学习如何生成自己的**懒序列**，这将允许我们在大型、复杂的树上使用递归。
- en: 'Recursion without `recur` and without lazy sequences can work just fine in
    many cases, though. When the input data is not in the thousands or millions of
    items, "normal" non-lazy recursion will probably be all you need. For now, the
    important thing is to understand that there are limits to when `recur` can be
    used. Luckily, many of the tasks you''ll need to accomplish with recursion fit
    nicely into a tail recursive pattern. And don''t worry: if you forget, the compiler
    is always there to remind you.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用`recur`和懒序列的递归在很多情况下都可以正常工作。当输入数据不是成千上万或数百万项时，“正常”的非懒递归可能就足够了。现在，重要的是要理解`recur`的使用是有局限性的。幸运的是，许多你需要用递归完成的任务都可以很好地适应尾递归模式。而且不用担心：如果你忘记了，编译器总是在那里提醒你。
- en: Solving Complex Problems with Recursion
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用递归解决复杂问题
- en: When we talk about recursion, there are really two categories of use cases that
    are quite different from each other. This is particularly true of Clojure. On
    the one hand, recursion is the primary, low-level way to build loops where other
    languages would use `for`, `foreach`, or `with`. On the other hand, functional
    languages such as Clojure generally make it easier for programmers to find elegant,
    recursive solutions to complex problems.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论递归时，实际上有两种截然不同的用例类别。这在Clojure中尤其如此。一方面，递归是构建循环的主要、低级方式，在其他语言中会使用`for`、`foreach`或`with`。另一方面，像Clojure这样的函数式语言通常使程序员更容易找到优雅的递归解决方案来处理复杂问题。
- en: Tail recursion and functions, or loops, built around `recur` are suited for
    problems where the data, input, and output, is essentially linear. Because tail
    recursive functions can only return one call at a time, they cannot handle problems
    where it is necessary to follow multiple, forking paths through the data. Clojure
    provides the tools you need. Using them may require some practice in approaching
    the problem in a recursive style.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 尾递归和围绕`recur`构建的函数或循环适合处理数据、输入和输出基本上是线性的问题。因为尾递归函数一次只能返回一个调用，所以它们无法处理需要通过多个分支路径遍历数据的问题。Clojure提供了你需要的工具。使用它们可能需要一些练习，以递归风格来处理问题。
- en: 'To help build this skill, the remaining exercises in this chapter will be dedicated
    to solving a complex problem: finding the most efficient path through a network
    of nodes. Or, to put it differently: how to travel cheaply between European capitals.
    These exercises will show you how to break a problem down and resolve it recursively.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助构建这项技能，本章剩余的练习将致力于解决一个复杂问题：在节点网络中找到最有效的路径。或者换句话说：如何在欧洲首都之间廉价旅行。这些练习将向你展示如何分解问题并递归地解决它。
- en: 'Exercise 6.05: Europe by Train'
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.05：欧洲火车之旅
- en: 'In this exercise, we need to find the least expensive way for a traveler to
    get from one European city to another. All we have is a list of city-to-city connections
    and an amount in euros. For the sake of this exercise, we will pretend that these
    are the only routes available and that the price of train tickets is constant
    for a given route. Here are our routes:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们需要找到旅行者从一个欧洲城市到另一个城市最经济的路线。我们拥有的只是一个城市到城市连接的列表和欧元金额。为了这个练习，我们将假装这些是唯一可用的路线，并且给定路线的火车票价格是恒定的。以下是我们的路线：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And here is a visual representation:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是它的可视化表示：
- en: '![Figure 6.5: Train routes across Europe'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5：欧洲火车路线'
- en: '](img/B14502_06_05.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_06_05.jpg)'
- en: 'Figure 6.5: Train routes across Europe'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：欧洲火车路线
- en: Note
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The list of paths between cities and the visual map are two ways of representing
    a graph, which is the computer science term for a system of nodes. A tree is one
    kind of graph in which there are no "cycles": you can''t go from point A, to point
    B, to point C, and then back to point A. The European railroad network, on the
    other hand, has plenty of cycles. In graph theory, each city would be called a
    node and the paths between cities would be called an edge.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 城市之间的路径列表和可视地图是表示图（在计算机科学中指节点系统）的两种方式。树是图中没有“循环”的一种类型：你不能从点A到点B，再到点C，然后再回到点A。另一方面，欧洲铁路网络有很多循环。在图论中，每个城市都会被称为节点，城市之间的路径会被称为边。
- en: The goal is to write a function that takes two cities and returns a list of
    cities that represents the best route. To solve this problem, we will use recursion,
    as well as many of the techniques from the last two chapters.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是编写一个函数，它接受两个城市并返回表示最佳路线的城市列表。为了解决这个问题，我们将使用递归，以及上一章中介绍的大多数技术。
- en: In this exercise, we will set up the project and transform the list of routes
    into a table that we'll be able to query to see 1) if City A is connected to City
    B and, if so, 2) the cost of travel between cities A and B.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将设置项目并将路线列表转换成一个我们可以查询的表格，以查看1）城市A是否与城市B相连，如果是，2）城市A和B之间的旅行成本。
- en: 'Thus, the table would look like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，表格看起来会是这样：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We also have to make sure that all of the routes are represented in both directions.
    In the initial list, we have `[:paris :milan 129]`. We also need to represent
    the reverse route, that is, Milan to Paris. In the preceding example, we have
    `:milan` in the `:paris` section, as well as `:paris` in the `:milan` section:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须确保所有路线都在两个方向上表示。在初始列表中，我们有`[:paris :milan 129]`。我们还需要表示反向路线，即米兰到巴黎。在上面的例子中，`:milan`在`:paris`部分，以及`:paris`在`:milan`部分：
- en: Create a new project directory with a `deps.edn` file containing just an empty
    map, `{}`, and start a new REPL.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目目录，包含一个`deps.edn`文件，其中只包含一个空映射`{}`，并启动一个新的REPL。
- en: Open a new file called `train_routes.clj` with just a `(ns train-routes)` namespace
    declaration.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`train_routes.clj`为名创建一个新文件，其中只包含一个`(ns train-routes)`命名空间声明。
- en: Copy the `routes` variable from [https://packt.live/39J0Fit](https://packt.live/39J0Fit)
    into the new namespace.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将[https://packt.live/39J0Fit](https://packt.live/39J0Fit)中的`routes`变量复制到新的命名空间中。
- en: 'The first step is to group all the routes together by origin city. Use `group-by`
    to do this. Start by defining a function called `grouped-routes`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是将所有路线按出发城市分组。使用`group-by`来完成这个操作。首先定义一个名为`grouped-routes`的函数：
- en: '[PRE45]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Run this early version of the function on the route list and look at the results
    for just one city:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在路线列表上运行这个函数的早期版本，并查看单个城市的输出结果：
- en: '[PRE46]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: With the call to `group-by`, we have a list of all the `:paris` routes. We now
    need a way to change this sub-list into a map.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过调用`group-by`，我们得到了所有`:paris`路线的列表。现在我们需要一种方法将这个子列表转换成一个映射。
- en: 'Write a function that accepts one of these sub-lists and returns a map:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，它接受这些子列表之一并返回一个映射：
- en: '[PRE47]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This function uses the `map`-`into` pattern to create a list of two-item vector
    tuples. We don't need the first item because it's the same as the key associated
    with the sub-list, so we use destructuring to place `city` and `cost` in a new
    vector.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test `route-list->distance-map` in the REPL with some sample data:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Continue building the `grouped-routes` function. Use the `map-into` pattern
    again to apply `route-list->distance-map` to all the sub-lists returned by the
    call to `group-by`:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The call to `map` treats the key-value pairs of the top-level map as a series
    of two-item vectors and runs `route-list->distance-map` on each value. The call
    to `into` converts the sequence back into a map.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test this version of `grouped-routes` in the REPL:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Perfect! This kind of map will make it easy to look up a route between an origin
    (`:paris`) and a destination (`:amsterdam`).
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We still need to produce the reverse routes. We''ll use `mapcat`, in a pattern
    we mentioned back in *Chapter 4*, *Mapping and Filtering*, to produce two routes
    for each input route. This can go before the call to `group-by`:'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The anonymous function in the `mapcat` call returns a vector containing two
    sub-vectors. The first of these is the original route, and the second is the same
    route with the origin and destination cities reversed. Thanks to `mapcat`, the
    result is a flattened list with twice as many elements as the input list.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test this in the REPL again:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, the `[:madrid :paris 34]` route is also included as a `:paris` to `:madrid`
    route.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define a `lookup` variable with the lookup table:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We'll need this variable later.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test the lookup table. First, we''ll ask for a route from Paris to Madrid:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Can we go back to Paris?
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s try a route that we know does not exist:'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Our lookup table answers two important questions: Is there a route between
    City A and City B? How much does it cost?'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We now have a data store that we can consult when we need to find which cities
    are available from any given point in the European rail graph. Rearranging data
    into an easy-to-query form can be an important step when dealing with a complex
    problem like this one. The next steps will be easier thanks to this easy access
    to our data.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Pathfinding
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we are in a city that is not directly connected to the city we want to travel
    to, we need to choose intermediate cities. To get from City A to City F, maybe
    we can go to City C first; or, maybe we'll need to go to City B and then City
    D before reaching City F. To find the best path, we first need to find all the
    possible paths.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: This is why a recursive approach is a good fit. The basic strategy is to test
    whether City A and City F are connected. If so, we've already found the answer.
    If not, we look at all the cities we can reach directly from City A. We go through
    the same process on each of those, and so on and so forth, until finally we find
    a city that is connected directly to City F. The process is recursive because
    we repeat the same process on each node until we find what we are looking for.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to visualize this process, using a small part of the network. In
    this example, we''ll start in Paris and search for Berlin. The first step is to
    test the cities we can reach from Paris. In London, Amsterdam, and Frankfurt,
    we ask: are you Berlin?'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6: Starting in Paris, we query all the available cities'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_06_06.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.6: Starting in Paris, we query all the available cities'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Since none of the cities is the one that we are looking for, we repeat the
    process from London, Amsterdam, and Frankfurt:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7: Searching again from the previously found cities'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_06_07.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.7: Searching again from the previously found cities'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: From London, we have nowhere left to go. But from Amsterdam and Frankfurt, we
    can reach Berlin. Success! Not only have we found Berlin, but we've found two
    paths to get there.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'We could represent these paths as Clojure vectors:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Notice that the paths going through Prague and London end with `nil`. This is
    how we will represent paths that do not lead to our destination and must be removed
    from the result set.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: There is one more issue that we haven't dealt with yet. What prevents us from
    going from Amsterdam back to Paris? This would create infinite loops where we
    search from Paris, then search Amsterdam, then search Paris again, and so on.
    To get around this problem, we will need to "remember" where we've been.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: This is our general approach. Now, let's write some more code!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.06: The Search Function'
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is to write the main search function, a recursive function that
    we''ll call `find-path*`. The `find-path` function will be the public interface
    that calls `find-path*`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we are ready to write the main search function. The `find-path`
    function can be used for the wrapper function that will serve as the public interface.
    To get started, let''s write the empty functions:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We've written the "private" function, `find-path*`, first since the "public"
    function, `find-path`, will refer to it.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are already some design decisions here in the function arguments. Both
    functions accept the `route-lookup` argument. This will be the lookup table generated
    by `grouped-routes`. They both accept the destination argument as well. Since
    we want to build up a list of cities, a path, the private function, `find-path*`,
    doesn't take an origin argument like `find-path` does. Instead, it will take whatever
    the current path is. Since it's a recursive function, the current "origin" will
    always be whatever the last city in the path is.
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In other words, if we're testing a path, the value of `path` might be `[:paris
    :milan]`. That means that on the next iteration, `find-path*` will try all the
    cities available from `:milan`, making `:milan` the temporary origin. The next
    cities are tested in the same way and the path gets lengthened by one city on
    each successive call.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Call `find-path*` from `find-path`:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This is simple. We package the initial `origin` in a vector to pass off to `find-path*`.
    This way, we know that we will always have at least one city in the `path` parameter.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set up the basic conditional structure of the recursive function:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This part does two things. We are going to need to refer to the current position
    a lot, so it's a good idea to create a `let` binding immediately. As we mentioned
    earlier, our current position is always the last item in the `path` argument.
    The whole process is about adding cities on to the end of this list.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next thing we do is to start setting up the different checks we'll use.
    The two conditions we add here both end the recursion and return a value. These
    are the "Are we there yet?" tests. The second one is the one that will be called
    the most, so let's look at it first.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you remember how our lookup table is structured, there is a top-level set
    of keys, one for each city in our system. The value of each of those keys is a
    map of reachable cities. That''s why we can use `get-in` here. Say our lookup
    table looks something like this:'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If we call `(get-in routes-lookup [:paris :milan])`, we will get `129`. If our
    current position is `:paris` and our destination is `:milan`, then this call will
    return truthy. In that case, we add `:milan` to the current path and we return
    the path. We've arrived.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So, why do we need the first condition then? In what circumstances would the
    destination city already be in the path? There is only one way that could happen,
    but we do have to take care of it. Someday, a user will call your function and
    ask the best route from `:paris` to `:paris` and we don't want to blow up the
    stack on such a simple request.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test the simple cases. We already have enough code for two cases, so let''s
    see whether our functions work. Try `find-path*` first with a one-city path:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, let''s try the same thing with `find-path`:'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The current code should also work if the destination city is only one "hop"
    away from the origin:'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: So far so good. Onward!
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start building the recursive logic to `find-path*`:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: For the final condition, we use an expressive Clojure keyword such as `:otherwise-we-search`
    as a condition, but anything that isn't `false` or `nil` will do. If we get this
    far, we know that we haven't reached the destination yet, so we have to keep searching.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s look at this line by line. The first thing we do is define `path-set`,
    which will allow us to test whether a city is already in our path. You can try
    building and using a set in the REPL:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The reason this is important becomes apparent in the next line. We bind `from-here`
    to this:'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We can't use `get-in` like we did earlier because this time, we don't want just
    one city reachable from `position`, we want all of them. So, we grab the entire
    sub-map for the current city, with `(get route-lookup position)`, and then extract
    a list of keywords. Now, the `path-set` binding from the previous line becomes
    useful. We use it to remove any cities that we've already visited. This is how
    we avoid recursively going back and forth between `:paris` and `:amsterdam` forever.
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `from-here` binding now contains all the cities we still need to test. First,
    though, we check to see whether `from-here` is empty, using Clojure's well-named
    `empty?` predicate. Let's say our destination is `:berlin` and our current path
    is `[:paris :london]`. The only way out of `:london` is to go back to `:paris`,
    but we've already been there. This means it's time to give up, so we return `nil`.
    As you'll soon see, paths that resolve to `nil` will be ignored.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After this, we start threading `from-here` through a series of s-expressions.
    The first one is where the actual recursion is going to happen:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We''re mapping over the cities that we can reach from our current position.
    Say we''ve arrived in `:paris` from `:london`. In the lookup table, the value
    for `:paris` is as follows:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can''t go back to `:london`, so that means `from-here` is `[:frankfurt :milan
    :madrid :geneva :amsterdam]`. The anonymous function provided to `map` will be
    called once for each of these cities as `pos`. Each city will thus be appended
    to the path argument in the recursive calls to `find-path*`. The following values
    will be tried as the `path` argument to `find-path*`:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Remember that `map` returns a list. The list returned here will be the result
    of calling `find-path*` on each city. Each of those calls will produce a list
    as well, until the search finds the destination city or runs out of places to
    look.
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can start to visualize the recursive structure of our path search:'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.8: Each city resolves to a new list of cities, each of which resolves
    to a new list'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_06_08.jpg)'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.8: Each city resolves to a new list of cities, each of which resolves
    to a new list'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Eventually, the search will either find the destination or run out of options,
    at which point the lists will all be resolved. If there are no more options and
    the destination still hasn't been found, `nil` is returned. Otherwise, a list
    of resolved paths is returned. This simple call to `map` ends up walking the entire
    city graph until all the possible routes are found.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before returning, though, the call to map gets threaded through one last s-expression:
    `(remove empty?)`. This is how we filter out the `nil` paths that never find the
    destination.'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Test the current state of the function on a short path.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To make this easier to test, we''ll use a smaller rail network. Start by defining
    a new variable for the lookup table:'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'There should be precisely two paths between `:paris` and `:rome`:'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Test the current state of the function with a slightly bigger network. We''ll
    add another route between `:paris` and `:milan`:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'With this set of routes, our result is not quite what we expect:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The data looks good, but where did those extra parentheses come from? This
    is a consequence of using `map` in a recursive way. `map` always returns a list.
    The `:barcelona` route requires an extra level of recursion because it is one
    item longer than the others. As a result, it is wrapped in a list. We can verify
    this by adding another possible route:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As you can see, the five-city path that goes through `:madrid` is wrapped in
    an extra set of parentheses.
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Unnest the nested lists. To solve this problem, use `mapcat` to strip away
    the containing lists. Here is the final version of `find-path*`:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The last addition is the call to `mapcat`. It might look strange at first,
    but remember: `mapcat` removes the outer parentheses from the items in the list
    that it returns. That''s why we have the conditional: if `x` is just a path, like
    `[:prague :bratislava]`, we don''t want it to be directly concatenated, which
    is why we return `[x]` instead. The new wrapper is instantly removed when the
    items are concatenated together, and the original vector remains intact. In the
    other cases though, when the underlying vector is wrapped in a list, `mapcat`
    "removes" it.'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test this version on the small and large railroad networks. First, we''ll test
    it with `even-more-routes`:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Much better!
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, try it with the full-sized lookup table. We won''t print the full results
    here because they''re quite long:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Now, we can walk the entire network. Our `find-path` function returns all the
    possible routes between any two cities.
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once again, Clojure has helped us write a concise solution to a fairly complex
    problem. A recursive algorithm such as this depends on a design that combines
    two elements. On the one hand, the recursive function treats each new node as
    if it were the first node. Recursive solutions are often perceived as "elegant"
    because of this. By solving the problem for one item, it can be solved for an
    entire network of items. To work, however, this requires the second design element:
    a way of accumulating the results from one node to another. In this example, we
    built up our knowledge by adding cities to one of the parameters. In the next
    exercise, we''ll use different techniques for bringing the data together.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: This exercise also shows the value of using small, sample inputs at the REPL.
    The interactive programming experience allows you to quickly try things and verify
    your hypotheses.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.07: Calculating the Costs of the Routes'
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There''s just one more problem to solve. In our original problem description,
    we didn''t ask for all the possible routes, but just the least expensive one!
    We need a way to evaluate the cost of all the paths and choose one. To accomplish
    this, we will use the lookup table from the two previous exercises to calculate
    the cost of each path returned by `find-path*`. Then, we can use a reducing pattern
    from *Chapter 5*, *Many to One: Reducing,* for finding the path with the lowest
    cost:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Write a `cost-of-route` function.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To do this, we''ll use a pattern from *Chapter 4*, *Mapping and Filtering*,
    `map`, with two input lists. The first will be the path, and the second will be
    the path offset by one item so that each call can evaluate the cost of going from
    one city to the next. It should look like this:'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: By now, this should look familiar. `(next route)` provides the offset version
    of `route`. For each pair of cities, we use `get-in` the same way we did earlier.
    That call gives us the cost of a given segment in the path. Then, we use the `(apply
    +)` pattern to find the grand total.
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test the new function:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'And it even works with the edge cases:'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Write a `min-route` function to find the least expensive route.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we''ll leverage another familiar pattern, this time using `reduce`. We
    want to find the route with the lowest total cost and we need a function like
    `min`, except that it will return the *item* that has the minimum cost, and not
    just the minimum cost itself:'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The only slightly tricky aspect of this function is the initialization value
    in the call to `reduce`: `{:cost 0 :best [(ffirst routes)]}`. We start with a
    default cost of `0`. So far so good. The default `:best` route should be the route
    corresponding to a distance of zero, which means that we''re not going anywhere.
    That''s why we use `ffirst`, which is not a typo but a convenience function for
    nested lists. It is a shortcut for `(first (first my-list))`, so it returns the
    first element of the first element of the outer list.'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, put it all together. Add a call to `min-route` to the public-facing `find-path`
    function:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Test this out on several pairs of cities:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Working through this code involved a lot of different steps, but, in the end,
    it was worth it. We've actually solved a somewhat difficult problem in about 50
    lines of code. Best of all, the solution involved many techniques that we've already
    seen, which shows, one more time, how important and powerful they can be when
    used together.
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A Brief Introduction to HTML
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many of the remaining chapters of this book and starting with the activity
    at the end of this chapter, we will be working in one way or another with **Hypertext
    Markup Language** (**HTML**), which holds together just about every web page you've
    ever seen. Producing HTML from data is an extremely common programming task. Just
    about every mainstream programming language has multiple templating libraries
    for generating web pages. Even before Clojure, Lisps have used nested s-expressions
    for this. S-expressions are a particularly good fit for HTML documents, which
    are structured like logical trees.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you''re not familiar with the essentials of producing HTML, it''s worth
    briefly reviewing the basics. HTML is the content of the text file that provides
    the structure for other kinds of content (that is, images, audio, and video resources)
    on a web page. The fundamental unit of HTML is called an element. Here is a simple
    paragraph element, using the `<p>` tag:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The HTML standard, of which there are several versions, contains many, many
    kinds of elements. The `<html>` element contains a web page in its entirety. In
    turn, this contains the `<head>` and `<body>` elements. The first of these contains
    various kinds of metadata for displaying the page; the second contains the actual
    content that will be shown to the user. The `<body>` element can contain both
    text and more elements.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll only use a small handful of elements here:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '`<div>`: Perhaps the most widely used element of all, `<div>` is a generic
    container for anything from the size of the paragraph up to an entire document.
    It can''t be used for content below the size of a paragraph, however, because
    the end of a `<div>` causes a break in the text flow.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<p>`: The paragraph element.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<ul>` and `<li>`: "UL" stands for "unordered list," that is, a list without
    numbers. A `<ul>` should only contain "list items," that is, `<li>` elements.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<span>`, `<em>`, and `<strong>`: These elements are part of the text; they
    are for wrapping single words or single letters. They do not cause breaks in text
    flow. `<span>` is a generic element. `<em>` (for emphasis) generally produces
    italicized text, while `<strong>` generally produces bold text.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<a>`: A hypertext link element. This is also a text-level element. The `href`
    attribute (we''ll explain attributes in a second) of an `<a>` element tells the
    browser where to go when you click on a link.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<img>`: The `<img>` tag inserts an image, referenced by its `src` attribute.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<h1>`, `<h2>`, and `<h3>`:These are the heading elements, for page titles,
    section titles, subsection titles, and more.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These few elements are enough to get started producing web content. You can
    learn about others as needed by consulting, for example, the Mozilla Developers
    Network's MDN web documentation.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: The MDN web docs can be referred to at [https://packt.live/2s3M8go](https://packt.live/2s3M8go).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we will be producing HTML, there are only a few things you need to know
    in order to produce well-formed HTML:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'Most HTML tags have three parts: a start tag, a closing tag, and some content.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A start tag consists of a short string wrapped in angle brackets: `<h1>`.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A closing tag is similar, except that there is a slash, `/`, in front of the
    tag name, `</h1>`.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Opening tags can contain attributes, which are key-value pairs, with the values
    in quotes: `<h1 class="example-title">Example</h1>`.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Certain attributes, known as "Boolean attributes", don''t need to have a value.
    The presence of a key is enough:'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Some tags do not have any content. They can be written as a single element
    containing a slash after the tag name: `<br/>`.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In some dialects of HTML, certain tags without content can be written without
    a slash: `<img>`.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an element begins inside another element, its end tag must occur before the
    end of the containing element.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last point is important. This means that it would be invalid to write something
    like this:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The `<p>` element here should be a child element of `<div>`. A child element
    must be contained completely by its parent element. This is a very good thing
    when manipulating HTML because it means that correctly formed HTML is always a
    tree structure, with a root note, the `<html>` element that contains nodes that
    contain other nodes, and so on. As you'll see, this matches well with the kinds
    of tree structures that we've already looked at here.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Now, you know enough to write a system that will produce well-formed HTML. (To
    become a renowned web designer, however, you'll need to learn a little bit more.)
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'In Clojure, vectors are generally used for representing the structure of an
    HTML document. One of the more popular libraries that does this is called `Hiccup`.
    With `Hiccup`, a short paragraph containing a link would look like this:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The output would be as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The syntax for this is quite simple. Besides using vectors, it uses keywords
    to identify HTML tags and maps to add attributes such as `href` or `class`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Some tags, such as `<link>`, `<meta>`, `<br>`, `<input>`, and `<img>`, are generally
    not closed, so they should receive special handling. All other tags should be
    explicitly closed even if they don't have any content.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: More information on Hiccup can be found at [https://packt.live/36vXZ5U](https://packt.live/36vXZ5U).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 6.01: Generating HTML from Clojure Vectors'
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The company you work for is building a new web application. Generating and serving
    HTML pages is, quite logically, a key part of the operation. Your team has been
    asked to write a library for generating HTML from Clojure data.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Producing HTML from data is an extremely common programming task. Just about
    every mainstream programming language has multiple templating libraries for generating
    web pages. Even before Clojure, Lisps have used nested s-expressions for this.
    S-expressions are a particularly good fit for HTML documents that are structured
    like logical trees.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '**Goal**'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, you are going to write your own system for generating HTML
    from nested vectors, using this format. The goal is to be able to take any vector
    written with this syntax, including an arbitrary number of descendant vectors,
    and produce a single string containing correctly structured HTML.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Your code should also handle "Boolean attributes." Clojure maps don't allow
    keys to have no value to do this of course. You'll need to invent a convention
    so that users of your library can assign some non-string value to these attributes
    and get a Boolean attribute in the output string.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps**'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you to complete the activity:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Set up a new project directory with an empty `deps.edn` file. You don't need
    any external dependencies for this activity. Make your own namespace with a catchy
    name for this new library.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you decide to use the `clojure.string` library, now is the time to reference
    it in the `:require` part of your namespace.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's often a good idea to start by writing some of the smaller functions. Simple
    functions that take a keyword and output a string containing either an opening
    tag or a closing tag would be convenient, for example. You'll need the `name`
    function for converting a keyword into a string.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A good choice for this would be the function that will accept a map, such as
    `{:class "my-css-class"}`, and return a properly formatted set of HTML attributes:
    `class="my-css-class"`. Don''t forget to handle the case of Boolean attributes
    too. Remember that a Clojure map can be read as a sequence of key-value pairs.
    And don''t forget to put quotes around the values. A string containing a single
    escaped quotation mark looks this: `"\""`.'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It might be useful to have a predicate function to determine whether the second
    element in a vector is an attribute map.
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When parsing a vector, you'll know that the first element is a keyword. The
    second element might be a map if there are attributes, but it might not. Use the
    `map?` predicate to test that.
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The fun part will be writing the recursive function. We won't say much about
    that, except that the basic tree walking pattern that we used in the "Europe by
    train" example should provide you with a rough base. You won't be able to use
    `recur` because you need to handle a real tree.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are a lot of different kinds of elements that you need to handle, in addition
    to string content. In cases like this, it is often a good idea to write very clear
    predicates that you will use when deciding how to handle an element, such as `singleton-with-attrs?`,
    for example. These will be useful when writing the conditional part of your recursive
    function.
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Upon completing the activity, you will be able to test your code with an input
    of your choice. You should see an output similar to the following:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9: Expected output'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_06_09.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.9: Expected output'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 696.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve covered a lot of ground in this chapter. Recursion in Clojure, as in
    many functional languages, is a central concept. On the one hand, it can be necessary
    for some fairly simple looping situations. In those cases, `recur`, whether used
    with `loop` or in a recursive function, can almost be seen as just "Clojure''s
    syntax for looping." Understanding tail recursion is important for avoiding mistakes,
    but otherwise, it is relatively simple. On the other hand, recursion can be an
    extremely powerful way of solving complex problems. If it makes your head spin
    from time to time, that''s normal: recursion is more than just a technique. It''s
    a way of thinking about problem solving. Don''t worry, though. In the next chapter,
    you are going to be able to practice your recursion skills some more!'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue exploring the recursive techniques and
    focus on lazy evaluation.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
