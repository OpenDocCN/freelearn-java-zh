<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Core Architecture"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Core Architecture</h1></div></div></div><p>
<a class="link" href="ch01.html" title="Chapter 1. Business Process Modeling – Bridging Business and Technology">Chapter 1</a>, <span class="emphasis"><em>Business Process Modeling – Bridging Business and Technology</em></span>, provided you with an overview of the new KIE platform and the jBPM tool stack components. This chapter will show you how jBPM is built and what its components and subsystems are, and it will take you through the source code of jBPM, illustrating, with examples, how to leverage the flexibility provided by its modular system.</p><p>The list of topics that we will cover in this chapter is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Core API</li><li class="listitem" style="list-style-type: disc">Runtime engine</li><li class="listitem" style="list-style-type: disc">Human Task service</li><li class="listitem" style="list-style-type: disc">Persistence and transaction</li><li class="listitem" style="list-style-type: disc">History logs</li></ul></div><div class="section" title="The KIE API"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec36"/>The KIE API</h1></div></div></div><p>The new KIE API stems from the <a id="id632" class="indexterm"/>need for providing both a new common software service layer and an integrated IDE (Workbench) for well-assessed Red Hat projects, mainly Drools and jBPM. With the KIE API, several features have been added to ease the integration of these platforms with several environments: JMS, Rest, SOAP, CDI, Spring, Seam, OSGi, and plain Java applications.</p><p>The <span class="strong"><strong>droolsjbpm-integration</strong></span> additional<a id="id633" class="indexterm"/> project (hosted at <a class="ulink" href="https://github.com/droolsjbpm/droolsjbpm-integration">https://github.com/droolsjbpm/droolsjbpm-integration</a>) features integration packages for various environments and technologies.</p><p>We previewed some of the new KIE concepts in <a class="link" href="ch04.html" title="Chapter 4. Operation Management">Chapter 4</a>, <span class="emphasis"><em>Operation Management</em></span> (new Maven-based deployments, KieModule, the <code class="literal">kmodule.xml</code> file, and KieScanner), so you should be ready to go deeper into the subject. You will also find, as a companion support for our examples, class<a id="id634" class="indexterm"/> diagrams of specific KIE component relationships, which should help you to have a clearer picture of the internal KIE organization.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note41"/>Note</h3><p>
<a class="ulink" href="http://www.kiegroup.org">http://www.kiegroup.org</a> is the portal for <a id="id635" class="indexterm"/>all KIE technologies.</p></div></div><div class="section" title="KieServices"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec98"/>KieServices</h2></div></div></div><p>KieServices is a thread-safe <a id="id636" class="indexterm"/>singleton, which acts as a service factory. It gives high-level access to<a id="id637" class="indexterm"/> main KIE components and services.</p><p>It is possible to obtain a KieServices reference via its factory as follows:</p><div class="informalexample"><pre class="programlisting">KieServices ks = KieServices.Factory.get();</pre></div><p>The main KIE API services are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>KieContainer</strong></span>: This is essentially <a id="id638" class="indexterm"/>a wrapper for KieModule and KieBase(s) that it defines; it can compile and verify KieBase and generate new KieSession(s).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>KieRepository</strong></span>: This is a repository that manages KieModules abstracting away from the module <a id="id639" class="indexterm"/>source; it can be a module installed in a Maven repository or a module programmatically created and added by the user.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>KieScanner</strong></span>: This is a<a id="id640" class="indexterm"/> Maven repository artifacts scanner.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>KieBuilder</strong></span>: This is a<a id="id641" class="indexterm"/> helper for compiling and building a KieModule starting from its set of source files.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>KieResources</strong></span>: This is a<a id="id642" class="indexterm"/> factory for creating specialized resources from various I/O sources (Classpath, URL, and so on).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>KieLoggers</strong></span>: This is a logger<a id="id643" class="indexterm"/> configurator for the session.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>KieStoreServices</strong></span>: This is a store <a id="id644" class="indexterm"/>service that manages the persistency of the jBPM and Drools runtime state.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>KieMarshallers</strong></span>: Marshalling provides a customizable serialization architecture, utility classes, and<a id="id645" class="indexterm"/> strategies. We will describe the jBPM flexible marshalling architecture in <a class="link" href="ch07.html" title="Chapter 7. Customizing and Extending jBPM">Chapter 7</a>, <span class="emphasis"><em>Customizing and Extending jBPM</em></span>.</li></ul></div><p>Let us start by discussing the KIE API components whose duties are related to the jBPM runtime configuration and setup, since all your knowledge artifacts represent, at runtime, the engine's building ground<a id="id646" class="indexterm"/> for your business process execution.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note42"/>Note</h3><p>The upcoming sections are not logically grouped under this KieServices section since they all are KIE first class citizens (classes) and can be used and created irrespective of the KieServices factory class. You can find the complete source code examples for this chapter in the <code class="literal">jbpm-misc</code> project.</p></div></div></div><div class="section" title="KieContainer – KIE modules and KieBase(s)"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec99"/>KieContainer – KIE modules and KieBase(s)</h2></div></div></div><p>
<code class="literal">KieContainer</code> has<a id="id647" class="indexterm"/> been specifically designed to handle a KIE module and resolve its dependencies (other KIE modules or Mavenized JARs), even through remote Maven repositories. This is a huge improvement in terms of knowledge module sharing and management capabilities, compared to older jBPM versions. While a KIE module is <a id="id648" class="indexterm"/>an assembly that collects a set (archive) of business <a id="id649" class="indexterm"/>artifacts and static resources, it is the responsibility of KieContainer to organize the KieBase and KieSession definitions and to give the user the tools to obtain new ready-to-use references for them.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note43"/>Note</h3><p>You can find the examples in the <code class="literal">KieContainerTest</code> class.</p></div></div><p>
<code class="literal">KieContainer</code> can use the Java Classpath or the user-provided ClassLoader to detect, load, and wrap an existing <code class="literal">KieModule</code>:</p><div class="informalexample"><pre class="programlisting">KieContainer kContainer = ks.getKieClasspathContainer();</pre></div><p>The <code class="literal">getKieClasspathContainer()</code> function returns<a id="id650" class="indexterm"/> <code class="literal">KieContainer</code> that wraps <code class="literal">KieBase</code> found in your current Classpath (created by parsing the available <code class="literal">kmodule.xml</code> files).</p><p>In <a class="link" href="ch04.html" title="Chapter 4. Operation Management">Chapter 4</a> <span class="emphasis"><em>Operation Management</em></span>, we talked about the new Maven repository integration feature. <code class="literal">KieContainer</code> is able to load KieModule from a Maven repository, given its Maven <a id="id651" class="indexterm"/>
<span class="strong"><strong>GroupId-ArtifactId-Version</strong></span> (<span class="strong"><strong>GAV</strong></span>); use the <code class="literal">ReleaseId</code> class as follows:</p><div class="informalexample"><pre class="programlisting">// create the Maven GAV wrapper
ReleaseId releaseId = ks.newReleaseId("com.packt.masterjbpm6", "pizzadelivery", "1.0-SNAPSHOT");
// then create the container to load the existing module
KieContainer kieContainer = ks.newKieContainer(releaseId);</pre></div><p>The container, by putting the KIE client repository service at work, is also able to dynamically update its<a id="id652" class="indexterm"/> definitions starting from a different KIE module, given its <a id="id653" class="indexterm"/>Maven GAV. As a result, all its existing KieBase assets and KieSession definition will be incrementally updated (and the cached class definitions will<a id="id654" class="indexterm"/> be replaced with newer ones).</p><div class="informalexample"><pre class="programlisting">ReleaseId newReleaseId = ks.newReleaseId("com.packt.masterjbpm6", "pizzadelivery", "1.1-SNAPSHOT"); 
// update the container with the KIE module identified by its GAV
Results result = kieContainer.updateToVersion (newReleaseId);
if (result.hasMessages (Level.ERROR))
{
List&lt;Message&gt; errors= result.getMessages(Level.ERROR);</pre></div><p>KieBase (KnowledgeBase) is the building block of KieModule. The <code class="literal">KieBase</code> class works as the store for the KieModule knowledge definitions and serves as a dictionary for your KIE session. It contains Drools rules, processes, models, and so on. By default, these artifacts are searched in the KIE project <code class="literal">resources</code> root folder, but you can set the <code class="literal">packages</code> attribute to search in a different folder, for example (an excerpt of a <code class="literal">kmodule.xml</code>):</p><div class="informalexample"><pre class="programlisting">&lt;kbase name="kbase" <span class="strong"><strong>packages</strong></span>="com.packt.masterjbpm6.event"&gt;</pre></div><p>This will load artifacts from the <code class="literal">resources/com/packt/masterjbpm6/event</code> project folder.</p><p>Your KieModule must always have at least one named KieBase (that is, its <code class="literal">name</code> attribute must be set); alternatively, if you decide to use a <code class="literal">default</code> (that is, created without knowing its name) KieBase, omit the <code class="literal">&lt;kbase&gt;</code> element definition altogether in your <code class="literal">kmodule.xml</code> or leave the <code class="literal">kmodule.xml</code> empty.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>KieSession does not make much sense without an underlying KieBase. The KIE runtime, in case the user is not specifying one, provides you with a default KieBase. This default KieBase is KieBase with the attribute <code class="literal">packages="*"</code>, meaning that it is defined with all assets contained in all module packages.</p></div></div><p>KieBase is created by <a id="id655" class="indexterm"/>KieContainer and supports inheritance (inclusion) and<a id="id656" class="indexterm"/> multiple definitions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Inclusion</strong></span>: All knowledge <a id="id657" class="indexterm"/>artifacts belonging to "included KieBase" are added to "including KieBase"; for example, all <code class="literal">kbaseold</code> resources are added to the <code class="literal">kbasenew</code> KieBase:<div class="informalexample"><pre class="programlisting">&lt;kbase name="kbase" includes="kbaseold"
packages="com.packt.masterjbpm6.process"&gt;
    &lt;ksession name="ksession" /&gt;
&lt;/kbase&gt;</pre></div></li></ul></div><p>The included KieBase must be already available (the KieModule within which it is defined has to be deployed) or defined locally (the same <code class="literal">kmodule.xml</code> file). In <a class="link" href="ch04.html" title="Chapter 4. Operation Management">Chapter 4</a>, <span class="emphasis"><em>Operation Management</em></span> (the ManagedVesuvio repository example), the Napoli KieModule's kbase is included the Vesuvio's kbase in order to reuse its external process definition as a subprocess; let us clarify by looking at their Kie module definitions.</p><p>The Napoli <code class="literal">kbase</code>
<a id="id658" class="indexterm"/> definition (relevant part only) is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;kbase name="kbase-napoli" <span class="strong"><strong>default="true"</strong></span> packages="*" <span class="strong"><strong>includes="kbase-vesuvio"</strong></span>&gt;</pre></div><p>The Vesuvio <code class="literal">kbase</code> definition is (relevant part only) as follows:</p><div class="informalexample"><pre class="programlisting">&lt;kbase <span class="strong"><strong>name="kbase-vesuvio"</strong></span> <span class="strong"><strong>default="false"</strong></span> packages="*"&gt;</pre></div><p>Note that, in order to have KIE pick up the main kbase (<code class="literal">kbase-napoli</code>), we set <code class="literal">kbase-vesuvio </code>kbase's <code class="literal">default</code> attribute to <code class="literal">false</code>.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Multiple definitions</strong></span>: Multiple<a id="id659" class="indexterm"/> KieBase (and KieSession) can be defined inside a single KieModule:<div class="informalexample"><pre class="programlisting">&lt;kbase name="kbase" includes="kbaseold"
packages="com.packt.masterjbpm6.process"&gt;
    &lt;ksession name="ksession" /&gt;
&lt;/kbase&gt;
&lt;kbase name="kbaseold" packages="com.packt.masterjbpm6.event"&gt;
    &lt;ksession name="ksession2" /&gt;
&lt;/kbase&gt;</pre></div></li></ul></div><p>Once the KieBase is defined, you can create a stateful KieSession (the default one or a named one, by passing its <code class="literal">name</code> attribute).</p><div class="informalexample"><pre class="programlisting">KieSession kieSession=kieContainer.newKieSession ("ksession");</pre></div><p>Each KieSession is always paired with a single KieBase: KieContainer actually delegates the session creation to its KieBase.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note44"/>Note</h3><p>KieBase and KieSession support a number of declarative configuration settings that you can add to your <code class="literal">kmodule.xml</code> file; please consult the jBPM 6.2 reference documentation.</p></div></div><p>The following class<a id="id660" class="indexterm"/> diagram shows the main classes that you have to deal with <a id="id661" class="indexterm"/>when working with containers (sessions will be discussed in a forthcoming section).</p><div class="mediaobject"><img src="graphics/9578OS_06_04.jpg" alt="KieContainer – KIE modules and KieBase(s)"/></div></div><div class="section" title="The KIE builder API"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec100"/>The KIE builder API</h2></div></div></div><p>It's very likely that you<a id="id662" class="indexterm"/> might have already used <code class="literal">KnowledgeBuilderFactory</code> and <code class="literal">KnowledgeBuilder</code> to set up <code class="literal">KnowledgeBase</code>: KnowledgeBuilder parses the knowledge source files (process <code class="literal">bpmn</code> files, Drools <code class="literal">.drl</code> rule, and so on), and turns them into KnowledgePackage that KnowledgeBase can use. The resources are<a id="id663" class="indexterm"/> identified and added by type (<code class="literal">ResourceType</code> enum). KnowledgeBase is deprecated, but <code class="literal">KieBase</code> is actually implemented by <code class="literal">KnowledgeBaseImpl</code>.</p><p>The KIE API gives you tools specialized in managing KieModule: file creation and resource assembling, module dependency management, and building and deployment to Maven repositories. The following class diagram shows the main builder related classes (for a quick reference purpose only).</p><div class="mediaobject"><img src="graphics/9578OS_06_01.jpg" alt="The KIE builder API"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note45"/>Note</h3><p>You can find the examples in the <code class="literal">KieBuilderTest</code> and <code class="literal">KieResourceTest</code> classes.</p></div></div><div class="section" title="KieResources"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec78"/>KieResources</h3></div></div></div><p>The resource is a contract representation of a knowledge element (process, rule, and so on) or a resource<a id="id664" class="indexterm"/> that indirectly can be used to load a Kie module (for example: a path to <code class="literal">kmodule.xml</code>).</p><p>The <code class="literal">KieResources</code> factory eases the task of handling objects in the forms of <code class="literal">org.kie.api.io.Resource</code>; for example:</p><div class="informalexample"><pre class="programlisting">Resource res=ks.getResources().newFileSystemResource (new File("/jbpm-constructs/target/classes/"));</pre></div><p>This resource represents the path that contains a KIE module.</p></div><div class="section" title="KieModule"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec79"/>KieModule</h3></div></div></div><p>While KieContainer<a id="id665" class="indexterm"/> represents an abstraction, the very nature of KieModule is based on business asset files (resources): KieModule is a container of all the resources needed to define a set of KieBase classes.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip18"/>Tip</h3><p>The module project source structure must be compliant with the standard layout for a Maven project (such as <code class="literal">src/main/resources</code>).</p></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">pom.xml</code> defining the KieModule Maven GAV</li><li class="listitem" style="list-style-type: disc"><code class="literal">kmodule.xml</code> declaring KieBase, KieSession, and their properties</li><li class="listitem" style="list-style-type: disc">knowledge artifacts</li></ul></div><p>KieModule tracks the module dependencies from other Kie modules and from other plain JAR archives thanks to the <code class="literal">pom.xml</code> file.</p></div><div class="section" title="KieBuilder"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec80"/>KieBuilder</h3></div></div></div><p>KieBuilder allows you<a id="id666" class="indexterm"/> to build KieModule by adding resources and configuration files through a set of model classes (metamodels), which represent the key KieModule components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">KieModuleModel</code>: A KieModule abstraction</li><li class="listitem" style="list-style-type: disc"><code class="literal">KieBaseModel</code>: A KieBase abstraction</li><li class="listitem" style="list-style-type: disc"><code class="literal">KieSessionModel</code>: A KieSession abstraction</li></ul></div><p>The memory-based filesystem class (<code class="literal">KieFileSystem</code>) helps you with the creation/writing of the KIE module files (<code class="literal">pom.xml</code> and <code class="literal">kmodule.xml</code>). The following class diagram <a id="id667" class="indexterm"/>shows <code class="literal">KieBuilder</code> and the related classes (details ahead).</p><div class="mediaobject"><img src="graphics/9578OS_06_03.jpg" alt="KieBuilder"/></div><p>Let us see a practical example of KIE metamodel creation and usage in order to set up and install a KIE module (with dependencies) from scratch into a Maven repository.</p><p>You can find the complete example in the <code class="literal">KieBuilderTest</code> class (<code class="literal">testBuilderWithModels</code>):</p><div class="informalexample"><pre class="programlisting">KieServices ks = KieServices.Factory.get();
// create the KIE module model
KieModuleModel kmodule = ks.newKieModuleModel();
// create the KieBase model
KieBaseModel kieBaseModel = kmodule.newKieBaseModel("KBase");
// create the KieSession model
KieSessionModel ksession1 = kieBaseModel.newKieSessionModel("KSession").setDefault(true);
KieFileSystem kfs = ks.newKieFileSystem();
ReleaseId rid = ks.newReleaseId("com.packt.masterjbpm6", "pizzaDeliveryNew ", "1.0");
// generate pom.xml file
kfs.generateAndWritePomXML(rid);
// and write the &lt;kmodule&gt; xml file
kfs.writeKModuleXML(kmodule.toXML());</pre></div><p>When your file<a id="id668" class="indexterm"/> set is ready, pass <code class="literal">KileFileSystem</code> (content) to the builder:</p><div class="informalexample"><pre class="programlisting">KieBuilder kieBuilder = ks.newKieBuilder(kfs);

// add dependencies (here, we put jar Files as Resources but you
// can use one or more KieModule too)
Resource dependencyRes = ks.getResources().newFileSystemResource(new File("c:/temp/pizzadelivery-1.0.jar "));
kieBuilder.setDependencies(dependencyRes);</pre></div><p>We can now perform the "build." The build compiles all module knowledge packages and Java classes, validates the configuration files (pom.xml and kmodule.xml), and finally, installs the module in the local KIE repository:</p><div class="informalexample"><pre class="programlisting">kieBuilder.buildAll();
if (kieBuilder.getResults().hasMessages(Level.ERROR)) {

}</pre></div><p>Programmatically creating KieModule means you have to create the object in a file-oriented way, for example:</p><div class="informalexample"><pre class="programlisting">  String myprocess= "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; \n &lt;definitions id=\"Definition\"\n" +

kfs.write("src/main/resources/process.bpmn", myprocess);</pre></div><p>The runtime will create the file following your KieModule filesystem structure.</p></div></div><div class="section" title="Repositories and scanners"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec101"/>Repositories and scanners</h2></div></div></div><p>Maven repositories, as we <a id="id669" class="indexterm"/>already pointed out, are an important piece of the <a id="id670" class="indexterm"/>new Kie architecture: the repository service allows you to manage module installation and dependency resolution with the internal KIE repository:</p><div class="informalexample"><pre class="programlisting">KieServices ks = KieServices.Factory.get();
KieRepository kr = ks.getRepository();</pre></div><p>To add a module to the KIE repository store, you must provide the path to the <code class="literal">kmodule.xml</code> file or the path to the built KIE module JAR file:</p><div class="informalexample"><pre class="programlisting">Resource kieresource= ks.getResources().newFileSystemResource(new File("c:/Users/simo/git/masterjbpm6/pizzadelivery/target/classes/"));
// or 
ks.getResources().newFileSystemResource(new File("c:/Users/simo/git/masterjbpm6/pizzadelivery/target/pizzadelivery-1.0.jar"));
// add to the KIE repo
KieModule kModule = kr.addKieModule(kieresource);
// load and use the module
KieContainer kContainer = ks.newKieContainer(kproj.getReleaseId());</pre></div><p>The <code class="literal">addKieModule</code> method accepts the optional module resource dependencies (again, in the form of a <code class="literal">kmodule.xml</code> path or a path to a JAR archive).</p><p>To load a module from the repository is as simple as follows:</p><div class="informalexample"><pre class="programlisting">ReleaseId releaseId = ks.newReleaseId("com.packt.masterjbpm6", "pizzadelivery", "1.0-SNAPSHOT");
KieModule kModule=kr.getKieModule(releaseId);</pre></div><p>The repository service wraps the internal Maven KIE repository services as well as the <code class="literal">KieScanner</code> service that we are now going to see.</p><div class="section" title="KieScanner"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec81"/>KieScanner</h3></div></div></div><p>
<span class="strong"><strong>KieScanner</strong></span> is a monitor for<a id="id671" class="indexterm"/> Maven repositories (both local and remote) used for automatically detecting whether there are updated releases for a given KieModule: in case, a new <a id="id672" class="indexterm"/>deployed artifact for the module is found, the scanner updates KieContainer to reflect the changed definitions (KieBase, KieSession, and so on). The KIE module KieBase(s) is rebuilt, and all the new KieSessions created from KieContainer will use the updated KIE module definitions.</p><p>The scanner can perform a blocking scan update (the <code class="literal">scanNow()</code> method), which returns after the (eventual) update process is completed, or a background scanning process (the <code class="literal">start(long pollingInterval)</code> and <code class="literal">stop()</code> methods).</p><div class="informalexample"><pre class="programlisting">KieServices ks = KieServices.Factory.get();
ReleaseId releaseId = ks.newReleaseId("com.packt.masterjbpm6", "pizzadelivery", "1.0-SNAPSHOT");
KieContainer kieContainer = ks.newKieContainer(releaseId);
// bind the scanner to the container
KieScanner scanner = ks.newKieScanner(kieContainer);
// synchronous scanner
scanner.scanNow();</pre></div><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip19"/>Tip</h3><p>The scanner <a id="id673" class="indexterm"/>works only when the paired KieContainer's module Maven version (the V from its GAV) is not a FIXED version. Only modules with a version with the qualifier SNAPSHOT, LATEST, or RELEASE, or<a id="id674" class="indexterm"/> ranged versions are processed. See Maven versions reference for additional help.</p></div></div><p>The scan operation performs the following actions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Build the new Kie module, searching for errors</li><li class="listitem" style="list-style-type: disc">Update old module dependencies</li><li class="listitem" style="list-style-type: disc">Update the old module assets, compile them, and rebuild the module knowledge bases</li><li class="listitem" style="list-style-type: disc">If no build error is detected, the updated module is added to the KIE module repository</li></ul></div><p>If there are new or updated classes in use by the knowledge base, then this is fully recreated; otherwise, its resources are incrementally updated. Obsolete knowledge bases and sessions (whose definition has been removed) are deleted from the Kie container. The general advice with the scanner is to be very cautious and to evaluate its impacts on a case-by-case basis.</p><p>The example <code class="literal">KieScannerTest</code> class provides you with two test methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">testScannerUpdateNewSession</code>: This verifies whether a Kie module process definition gets updated after<a id="id675" class="indexterm"/> the scan process by creating a new session and verifying that the update process variable returns a different value from the original definition</li><li class="listitem" style="list-style-type: disc"><code class="literal">testScannerSameSessionAfterUpdate</code>: This verifies whether after the scan, the existing session<a id="id676" class="indexterm"/> continues using its old process definition, while a new KIE session picks up the updated process definition</li></ul></div><p>The scanner is a nice<a id="id677" class="indexterm"/> improvement over the previous jBPM knowledge base update mechanism (KnowledgeAgent) since it works in tight integration with Maven and provides the implementer with an asset-oriented programming style in handling KIE modules, Kie project sources, and assets. This great addition makes jBPM fit a lot better in the typical agile, lean development environment. Just think about the possibilities you have when integrating with <a id="id678" class="indexterm"/>
<span class="strong"><strong>Continuous Integration</strong></span> (<span class="strong"><strong>CI</strong></span>), deployment, and automated test tools. You may have a scanner process that checks your nightly build Maven repo trunk, updates your KIE module with the latest development version of your assets, and triggers your automated test suite.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note46"/>Note</h3><p>The KieScanner API implementation and utility<a id="id679" class="indexterm"/> classes belong to the <code class="literal">kie-ci</code> project (<a class="ulink" href="https://github.com/droolsjbpm/drools/tree/master/kie-ci">https://github.com/droolsjbpm/drools/tree/master/kie-ci</a>).</p></div></div><p>The Scanner API also provides a Maven helper class, which manages artifact lookup and deployment to the system Maven repository:</p><div class="informalexample"><pre class="programlisting">MavenRepository repo = MavenRepository.getMavenRepository();
List&lt;DependencyDescriptor&gt; dependencies = repo.getArtifactDependecies("com.packt.masterjbpm6:pizzadelivery:1.0");
Artifact module = repo.resolveArtifact(ks.newReleaseId(
  "com.packt.masterjbpm6", "pizzadelivery", "1.0"));</pre></div><p>The <code class="literal">KieScannerTest</code> jUnit test class exercises the scanner and the builder API. It creates and deploys a new release for the <code class="literal">pizzadelivery</code> KieModule (the <code class="literal">buildModuleForScannerUpdate</code> method) and then, starts the scanner update process (the <code class="literal">testScannerUpdate()</code> method).</p></div></div><div class="section" title="KieLoggers"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec102"/>KieLoggers</h2></div></div></div><p>The KieLoggers factory<a id="id680" class="indexterm"/> allows you to create audit loggers that produce log traces of all the events occurring during the execution of a specific KIE session. The following types<a id="id681" class="indexterm"/> of loggers are available:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>File based logger</strong></span>: Logger<a id="id682" class="indexterm"/> to file with a default <code class="literal">.log</code> extension; it traces the event in an XML serialized format:<div class="informalexample"><pre class="programlisting">KieRuntimeLogger logger = loggers.newFileLogger(ksession, "c:/temp/kielogger");</pre></div><p>See the <code class="literal">KieLoggersTest.testLoggers</code> method for the complete example.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Console based logger</strong></span>: Traces<a id="id683" class="indexterm"/> the log to the standard output:<div class="informalexample"><pre class="programlisting">KieRuntimeLogger logger = loggers.newConsoleLogger(ksession);</pre></div><p>Here you have an example when running the <code class="literal">testRuleWithConsoleLogger</code> method; you can see the insertion of the Drools fact and the Drool rule triggering:</p><div class="informalexample"><pre class="programlisting">13:31:03.459 [main] INFO  o.d.c.a.WorkingMemoryConsoleLogger - OBJECT ASSERTED value:com.packt.masterjbpm6.pizza.model.Order@12e13d86 factId: 1

13:31:03.708 [main] INFO  o.d.c.a.WorkingMemoryConsoleLogger - BEFORE RULEFLOW GROUP ACTIVATED group:masterRuleGroup[size=1]
13:31:03.724 [main] INFO  o.d.c.a.WorkingMemoryConsoleLogger - BEFORE ACTIVATION FIRED rule:checkorder activationId:checkorder [1] declarations: $o=com.packt.masterjbpm6.pizza.model.Order@12e13d86 ruleflow-group: masterRuleGroup</pre></div></li><li class="listitem" style="list-style-type: disc">Threaded logger: Same as the<a id="id684" class="indexterm"/> file-based logger but executes writes to the file in an asynchronous fashion; it features an option to set the write (flush) interval period in milliseconds, for example:<div class="informalexample"><pre class="programlisting">// update the log file every 5 seconds
KieRuntimeLogger logger = loggers.newThreadedFileLogger(ksession, "c:/temp/kie_threaded", 5000);</pre></div><p>See the <code class="literal">testRuleWithThreadedLogger</code> example for the complete example.</p></li></ul></div><p>Logger classes extend <code class="literal">WorkingMemoryLogger</code>, which implements all the available event listener interfaces: <code class="literal">Process</code>, <code class="literal">Agenda</code>, <code class="literal">Rule</code>, and (KIE) KnowledgeBase. Since several events are generated, you're<a id="id685" class="indexterm"/> given the ability to control event filtering with the following methods: <code class="literal">addFilter</code>, <code class="literal">removeFilter</code>, and passing an <code class="literal">ILogEventFilter</code> implementing class. We can declare and configure the KieSession loggers directly in the <code class="literal">kmodule.xml</code> file, for example:</p><div class="informalexample"><pre class="programlisting">&lt;ksession

&lt;fileLogger id="filelogger" file="mysession.log" threaded="true" interval="10" /&gt;
&lt;consoleLogger id="consolelog" /&gt;
&lt;/ksession&gt;</pre></div><p>The following class<a id="id686" class="indexterm"/> diagram shows the loggers and the event listener interfaces:</p><div class="mediaobject"><img src="graphics/9578OS_06_05.jpg" alt="KieLoggers"/></div></div><div class="section" title="KieStoreServices"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec103"/>KieStoreServices</h2></div></div></div><p>
<code class="literal">org.kie.api.persistence.jpa.KieStoreServices</code> is an interface that defines the contract for the KIE session<a id="id687" class="indexterm"/> persistence service. Its default implementation<a id="id688" class="indexterm"/> is the <code class="literal">org.drools.persistence.jpa.KnowledgeStoreServiceImpl</code> class. Let us have a look at how <code class="literal">KieStoreServices</code> can be used to restore KIE sessions by using the session ID. The following example is an excerpt of the <code class="literal">StorageTest.testRuleWithStorageServer</code> method. It demonstrates how you can load your Kie session safely from the persistence store and execute the business process consistently.</p><div class="informalexample"><pre class="programlisting">KieServices ks = KieServices.Factory.get();
KieStoreServices storeservice = ks.getStoreServices();
KieContainer kContainer = ks.getKieClasspathContainer();
KieBase kbase = kContainer.getKieBase("kbase");
// initialize the Session Environment with EMF and the TM
Environment env = EnvironmentFactory.newEnvironment();
    env.set(EnvironmentName.ENTITY_MANAGER_FACTORY, super.getEmf());

// current Bitronix transaction manager
  env.set(EnvironmentName.TRANSACTION_MANAGER,
    TransactionManagerServices.getTransactionManager());
// create the session
  ksession = storeservice.newKieSession(kbase, null, env);
// perform the Rule task test
  testRule();
  long id = ksession.getIdentifier();
// dispose the session
  ksession.dispose();
// reload the session given its ID
  KieSession loadedsession = storeservice.loadKieSession(id, kbase, null,env);
// check it is the same session
  assertEquals(id, loadedsession.getIdentifier());
// rerun the test on the loaded session
ksession = loadedsession;
  testRule();</pre></div></div></div></div>
<div class="section" title="RuntimeManager service and the engine"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec37"/>RuntimeManager service and the engine</h1></div></div></div><p>
<code class="literal">RuntimeManager</code> has been introduced to simplify the configuration of <code class="literal">KieBase</code> (<code class="literal">KnowledgeBase</code>) and <code class="literal">KieSession</code> (<code class="literal">KnowledgeSession</code>). Its main duty is to manage and create instances<a id="id689" class="indexterm"/> of <code class="literal">RuntimeEngine</code> according to predefined strategies (see the <span class="emphasis"><em>Runtime strategy </em></span>section).</p><p>
<code class="literal">org.kie.api.runtime.manager.RuntimeEngine</code> is the entry point to the engine services; its main<a id="id690" class="indexterm"/> purpose is to provide the user with pre-configured and ready-to-use engine components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">KieSession</li><li class="listitem" style="list-style-type: disc">TaskService</li><li class="listitem" style="list-style-type: disc">AuditService</li></ul></div><p>
<code class="literal">org.kie.api.runtime.manager.RuntimeManager</code> unburdens the user from the development of a typical <a id="id691" class="indexterm"/>boilerplate code; it sets up the execution environment for processes (wrapping the KieSession and the task service into the RuntimeEngine) and manages the following Drools services:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Scheduler service</strong></span>: The scheduler<a id="id692" class="indexterm"/> service manages timer-based jobs for execution (we have seen it in <a class="link" href="ch04.html" title="Chapter 4. Operation Management">Chapter 4</a>, <span class="emphasis"><em>Operation Management</em></span>, and <a class="link" href="ch05.html" title="Chapter 5. BPMN Constructs">Chapter 5</a>, <span class="emphasis"><em>BPMN Constructs</em></span> with <span class="emphasis"><em>Async task</em></span>)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>TimerService</strong></span>: Implements<a id="id693" class="indexterm"/> timer services for the sessions</li></ul></div><p>The runtime manager registers the following items on the session:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Process workitem handlers (also the default <code class="literal">human task</code> workitem handler which is responsible for managing task nodes)</li><li class="listitem" style="list-style-type: disc">Global variables</li><li class="listitem" style="list-style-type: disc">Event listeners</li></ul></div><div class="section" title="Runtime strategy"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec104"/>Runtime strategy</h2></div></div></div><p>
<code class="literal">RuntimeManager</code> implements a<a id="id694" class="indexterm"/> runtime strategy that lets you choose how to manage your KieSession life cycle; let us see the available strategies:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Singleton (default jBPM strategy for a Kie module)</strong></span>: The runtime manages only one shared <code class="literal">RuntimeEngine</code> instance (only one Kie<a id="id695" class="indexterm"/> session is active and shared)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>PerProcessInstance</strong></span>: The manager uses a <a id="id696" class="indexterm"/>dedicated Kie session for each process instance; the Kie session life cycle spans the process instance duration</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>PerRequest</strong></span>: Invoking the <a id="id697" class="indexterm"/><code class="literal">getRuntimeEngine()</code> method returns a new <code class="literal">RuntimeEngine</code> instance (creating a new Kie session and task service each time)</li></ul></div><p>
<code class="literal">RuntimeManager</code>
<a id="id698" class="indexterm"/> must be created from <code class="literal">RuntimeManagerFactory</code>, calling one of its specialized factory methods according to the chosen runtime strategy (<code class="literal">newSingletonRuntimeManager()</code>, <code class="literal">newPerRequestRuntimeManager()</code>, or <code class="literal">newPerProcessInstanceRuntimeManager()</code>) and passing an instance of <code class="literal">org.kie.api.runtime.manager.RuntimeEnvironment</code>.</p><div class="section" title="Choosing the right strategy"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec82"/>Choosing the right strategy</h3></div></div></div><p>You shall choose the<a id="id699" class="indexterm"/> right runtime strategy mainly depending on your business and system specifications. Requirements may constrain you to keep isolated jBPM session working memories (for example, one session per process instance); in other words, each session owns its rules, facts, and objects. This could be the case for short-lived processes in a heavily concurrent system where you need low resource contention and high throughput.</p><p>The singleton strategy, on the other hand, manages a single-thread safe session (with synchronized access). This could lead to performance issues in highly concurrent environments (web) but would also allow for all jBPM sharing capabilities (facts and globals shared among all processes, scope of signals across your entire working memory, and so on). These are just general insights into the matter, and you should aim at evaluating your own strategy pros and cons according to your system and functional requirements.</p></div></div><div class="section" title="The RuntimeEnvironment class"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec105"/>The RuntimeEnvironment class</h2></div></div></div><p>This class encapsulates<a id="id700" class="indexterm"/> the environment configuration required by <code class="literal">RuntimeManager</code>; we instantiate it by using the <code class="literal">RuntimeEnvironmentBuilder</code> helper class:</p><div class="informalexample"><pre class="programlisting">// preconfigured environment with disabled persistence
RuntimeEnvironmentBuilder builder=RuntimeEnvironmentBuilder.Factory.get()
      .newDefaultInMemoryBuilder();
// with enabled persistence: emf is your EntityManagerFactory
RuntimeEnvironmentBuilder.Factory.get().newDefaultBuilder().entityMan agerFactory(emf).persistence(true);</pre></div><p>
<code class="literal">RuntimeEnvironmentBuilderFactory</code> has several helper methods targeted to create preconfigured specialized <code class="literal">RuntimeEnvironmentBuilder</code> enabled for persistence, based on the classpath KIE container (<code class="literal">kmodule.xml</code>), based on a KIE module (JAR file), and so on. Since the builder <a id="id701" class="indexterm"/>wraps all the configuration details, it exposes methods to perform the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add an asset (a BPMN process, Drools rule, and so on)</li><li class="listitem" style="list-style-type: disc">Set custom <code class="literal">UsergroupCallback</code></li><li class="listitem" style="list-style-type: disc">Set a Knowledge Base (in case your <code class="literal">RuntimeEnvironmentBuilder</code> is not a KIE module classpath builder)</li><li class="listitem" style="list-style-type: disc">Set Entity Manager Factory to enable JPA persistence<div class="informalexample"><pre class="programlisting">RuntimeManagerFactory managerFactory = RuntimeManagerFactory.Factory.get();

// pass the RuntimeEnvironment we get from the EnvironmentBuilder
RuntimeManager rtManager=managerFactory.newSingletonRuntimeManager (builder.get());</pre></div></li></ul></div><p>RuntimeManagers are identified by unique identifiers. The runtime won't accept the creation of <code class="literal">RuntimeManager</code> with the same id of another active <code class="literal">RuntimeManager</code>. The following diagram shows the interactions that take place during the runtime initialization and that involve the main KIE components:</p><div class="mediaobject"><img src="graphics/9578OS_06_08.jpg" alt="The RuntimeEnvironment class"/></div></div><div class="section" title="Runtime Context"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec106"/>Runtime Context</h2></div></div></div><p>
<code class="literal">RuntimeManager</code> can handle contextual information to look up a specific <code class="literal">RuntimeEngine</code> implementation, depending on<a id="id702" class="indexterm"/> the chosen strategy; the context is passed as a <code class="literal">org.kie.api.runtime.manager.Context</code> generic interface implementation:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">EmptyContext</code>: Context <a id="id703" class="indexterm"/>used with Singleton or PerRequest RuntimeManager; no specific information is used</li><li class="listitem" style="list-style-type: disc"><code class="literal">CorrelationKeyContext</code>: Used with<a id="id704" class="indexterm"/> PerProcessInstance RuntimeManager to find <code class="literal">RuntimeEngine</code> by using a process instance correlation key</li><li class="listitem" style="list-style-type: disc"><code class="literal">ProcessInstanceIdContext</code>: Used with PerProcessInstance RuntimeManager to<a id="id705" class="indexterm"/> find <code class="literal">RuntimeEngine</code> (and the Kie session) by using a process instance ID<div class="informalexample"><pre class="programlisting">RuntimeEngine engine = rtManager.getRuntimeEngine(EmptyContext.get());
// we can now get the initialized services
KieSession ksession = engine.getKieSession();
TaskService taskService = engine.getTaskService();</pre></div></li></ul></div><p>To avoid resource leakage, it is strongly recommended to dispose <code class="literal">RuntimeManager</code> at the end of a work session, for example:</p><div class="informalexample"><pre class="programlisting">rtManager.close();</pre></div></div></div>
<div class="section" title="KieSession"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec38"/>KieSession</h1></div></div></div><p>KieSession is a stateful session that maintains its conversational state with the engine, across multiple interactions. It is the best way to interact with the engine. Sessions are created starting from KieContainer, KieBase, or configured RuntimeEngine, which always delegates to KieBase<a id="id706" class="indexterm"/> but gives you the flexibility of choosing a session runtime policy.</p><p>Depending on the enabling of persistence, the session is created as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>In-memory session</strong></span>: All data related to session and the engine status is kept in memory and lost on engine restart</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>JTA session</strong></span>: Session persisted<a id="id707" class="indexterm"/> through a JPA EntityManager and a JTA transaction manager</li></ul></div><p>To create a new (stateful) KieSession, we configure the environment and we use <code class="literal">JPAKnowledgeService</code>:</p><div class="informalexample"><pre class="programlisting">Environment env = KnowledgeBaseFactory.newEnvironment();
EntityManagerFactory emf= Persistence.createEntityManagerFactory( "com.packt.masterjbpm6.persistenceunit" ));
env.set( EnvironmentName.ENTITY_MANAGER_FACTORY,emf);
env.set( EnvironmentName.TRANSACTION_MANAGER,
bitronix.tm.TransactionManagerServices.getTransactionManager());

StatefulKnowledgeSession ksession = JPAKnowledgeService.newKieSession( kbase, null, env );</pre></div><p>The example uses <span class="strong"><strong>Bitronix Transaction Manager</strong></span> (<span class="strong"><strong>BTM</strong></span>) (more on this in the <span class="emphasis"><em>Persistence and transaction</em></span> section).</p><p>The returned <code class="literal">StatefulKnowledgeSession</code> is of type <code class="literal">CommandBaseStatefulKnowledgeSession</code>, which decorates the session implementation (<code class="literal">StatefulKnowldgeSessionImpl</code>) with a command service of type <code class="literal">SingleSessionCommandService</code> (see the following class diagram).</p><p>
<code class="literal">SingleSessionCommandService</code> transparently<a id="id708" class="indexterm"/> manages, through the <code class="literal">TransactionInterceptor</code> class, the persistence of the stateful session by the JPA <code class="literal">SessionInfo</code> entity class.</p><div class="section" title="Stateless KieSession"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec107"/>Stateless KieSession</h2></div></div></div><p>The stateless KIE session is a wrapper to a stateful session, which the runtime creates and disposes for the duration of a single <a id="id709" class="indexterm"/>command execution so that it does not maintain a conversational state and cannot persist.</p></div><div class="section" title="Globals"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec108"/>Globals</h2></div></div></div><p>KieSession manages <code class="literal">globals</code>; globals are objects used to pass information into the engine that can be used in processes or<a id="id710" class="indexterm"/> rules. Globals are shared across all processes and rule instances. Let us see what KieSession methods can handle them:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">getGlobals()</code>: Returns the<a id="id711" class="indexterm"/> internal globals resolver</li><li class="listitem" style="list-style-type: disc"><code class="literal">getGlobal (String)</code>: Returns the <a id="id712" class="indexterm"/>global object given its identifier</li><li class="listitem" style="list-style-type: disc"><code class="literal">setGlobal(String, Object)</code>: Sets the global <a id="id713" class="indexterm"/>object assigning it an identifier</li></ul></div><p>The following class diagram shows details for the Session classes:</p><div class="mediaobject"><img src="graphics/9578OS_06_06.jpg" alt="Globals"/></div></div><div class="section" title="The CommandExecutor interface"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec109"/>The CommandExecutor interface</h2></div></div></div><p>All KIE sessions (both stateless and stateful) implement the <code class="literal">CommandExecutor</code> interface, a service that lets you execute<a id="id714" class="indexterm"/> a single command or a<a id="id715" class="indexterm"/> batch of commands. Let us look at some of them:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Process/Task</strong></span>: <code class="literal">CompleteWorkItemCommand</code>, <code class="literal">AbortWorkItemCommand</code>, <code class="literal">StartProcessCommand</code>, and <a id="id716" class="indexterm"/>so on</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Drools Rules</strong></span>: <code class="literal">FireAllRulesCommand</code>, <code class="literal">GetFactHandleCommand</code>, and <a id="id717" class="indexterm"/>so on</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Runtime</strong></span>: <code class="literal">GetGlobalCommand</code>, <code class="literal">SetGlobalCommand</code>, and <a id="id718" class="indexterm"/>so on</li></ul></div><p>Normally, you would call the higher-level jBPM API methods (using the session or the task service reference), but sometimes, it could be handy to use the command classes for batching, scheduling purposes, or management operations. All the command classes support XML binding thanks to standard annotations (<code class="literal">@XmlRootElement</code>, <code class="literal">@XmlAttribute</code>, <code class="literal">@XmlElement</code>, and so on) and so, can be easily serialized or passed remotely. Commands can be created using <code class="literal">CommandFactory</code> or by simply instantiating a specific command class, which is then executed by invoking the session <code class="literal">execute</code> method. </p><p>Let us now have a look at how these commands can be created and executed from the following code:</p><div class="informalexample"><pre class="programlisting">// create the command and execute
Command startProcess= CommandFactory.newStartProcess ("pizzadelivery");
ksession.execute(startProcess);</pre></div><p>Alternatively, you can instantiate the<a id="id719" class="indexterm"/> command on your own:</p><div class="informalexample"><pre class="programlisting">GetProcessInstanceCommand getProcessInstanceCommand = new GetProcessInstanceCommand();
getProcessInstanceCommand.setProcessInstanceId( processInstance.getId());
ProcessInstance processInstance = ksession.execute( getProcessInstanceCommand );</pre></div><div class="section" title="Batch execution"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec83"/>Batch execution</h3></div></div></div><p>The session supports the<a id="id720" class="indexterm"/> execution of a batch of commands by a specialized <code class="literal">BatchExecutionCommand</code>. Here, we rewrite the <code class="literal">RuleTaskTest</code> test class of <a class="link" href="ch05.html" title="Chapter 5. BPMN Constructs">Chapter 5</a>, <span class="emphasis"><em>BPMP Constructs</em></span>, by using three different commands (see the <code class="literal">CommandsTaskTest.testRuleWithCommand</code> method):</p><div class="informalexample"><pre class="programlisting">StringBuffer orderdesc = new StringBuffer();
List&lt;Command&gt; batchcmds = new ArrayList&lt;Command&gt;();
batchcmds.add(CommandFactory.newSetGlobal("newnote", orderdesc));
Order order = new Order();
order.setCost(200);
batchcmds.add(CommandFactory.newInsert(order));
batchcmds.add(CommandFactory.newSetGlobal("orderglobal", order));
batchcmds.add(CommandFactory.newStartProcess("rule"));
ExecutionResults results = ksession.execute(CommandFactory .newBatchExecution(batchcmds));</pre></div><p>
<code class="literal">BatchExecutionCommand</code> executes the enlisted commands in the exact order that they have been added:</p><div class="informalexample"><pre class="programlisting">List&lt;Command&gt; pizzabatchcmds = new ArrayList&lt;Command&gt;();
pizzabatchcmds.add(CommandFactory.newStartProcess("pizzadelivery"));
pizzabatchcmds.add(CommandFactory.newStartProcess("pizzadelivery"));
ksession.execute(CommandFactory.newBatchExecution(pizzabatchcmds));</pre></div><p>Note that <code class="literal">BatchExecutionCommand</code>, like all Command classes, supports serialization, so you can pass it remotely<a id="id721" class="indexterm"/> for execution or easily persist it for scheduled processing.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip20"/>Tip</h3><p>Even <code class="literal">CompositeCommand</code> can execute multiple commands sequentially, but it supports human task commands only (inheriting from <code class="literal">TaskCommand</code>). This command is used internally by the task service (see the <span class="emphasis"><em>Human Task service</em></span> section).</p></div></div></div></div><div class="section" title="Event listeners"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec110"/>Event listeners</h2></div></div></div><p>KIE session can register <a id="id722" class="indexterm"/>multiple specialized listeners for different kinds of event notifications:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Process</strong></span>: <code class="literal">ProcessEventListener</code> is<a id="id723" class="indexterm"/> related to process instance execution (we saw ProcessEventListener in the <span class="emphasis"><em>KieLoggers</em></span> section).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Rule</strong></span>: <code class="literal">RuleRuntimeEventListener</code> for events<a id="id724" class="indexterm"/> related to facts.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Agenda</strong></span>: <code class="literal">AgendaEventListener</code> for events<a id="id725" class="indexterm"/> related to Drools Agenda. Agenda is a Drools component that keeps track of rule activations (rule matching) and rule action execution.</li></ul></div><p>By providing a custom implementation of one of these interfaces, you can get the filtered session events.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note47"/>Note</h3><p>All the logger classes obtained from the <code class="literal">KieLoggers</code> service extend the abstract <code class="literal">WorkingMemoryLogger</code> class, which implements the preceding three interfaces. We will see more on event and auditing in the <span class="emphasis"><em>Audit and history logs</em></span> section.</p></div></div><p>We can declaratively register listeners inside the <code class="literal">kmodule.xml</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;ksession name="ksession"&gt;
&lt;listeners&gt;
&lt;ruleRuntimeEventListener type="com.packt.masterjbpm6.RuntimeEventlistener" /&gt;
&lt;agendaEventListener type="com.packt.masterjbpm6.AgendaEventlistener" /&gt;
&lt;processEventListener type="com.packt.masterjbpm6.ProcessEventlistener" /&gt;
&lt;/listeners&gt;
&lt;/ksession&gt;</pre></div></div><div class="section" title="Channels"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec111"/>Channels</h2></div></div></div><p>Channels are communication<a id="id726" class="indexterm"/> hoses that can be established between your jBPM application and the engine, through your KIE working session. Their main purpose is to allow sending objects from the session working memory to a generic external process or function.</p><p>Let us see the basics: You must implement the <code class="literal">org.kie.api.runtime.Channel</code> interface and register it with the session, assigning a name to the channel:</p><div class="informalexample"><pre class="programlisting">public class RulesAppChannel implements Channel {
    // handle the channel object sent
public void send(Object object) {

    }
  }
ksession.registerChannel("appChannel", new RulesAppChannel());</pre></div><p>The channel can be used to notify the jBPM application, for instance, of a rule execution as follows:</p><div class="informalexample"><pre class="programlisting">when
        $o: com.packt.masterjbpm6.pizza.model.Order (cost&gt;100)
    then
    {

      channels["appChannel"].send("urgent!");
    }</pre></div><p>The list of existing channels can be retrieved from the session by calling:</p><div class="informalexample"><pre class="programlisting">  Map &lt;String, Channel&gt; channels=ksession.getChannels();</pre></div><p>Check the <code class="literal">ChannelsTaskTest.testRuleWithChannel() </code>method for a working example.</p></div></div>
<div class="section" title="Human Task service"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec39"/>Human Task service</h1></div></div></div><p>We introduced the human tasks in the previous chapter; we described the human task state transitions, task rule assignments, and task operations performed by the stakeholders.</p><p>You can get the <code class="literal">org.kie.api.task.TaskService</code> task service from <code class="literal">RuntimeEngine</code> (the<code class="literal"> getTaskService()</code> method), which is a wrapper for the service; the task service is created and wrapped into<a id="id727" class="indexterm"/> <code class="literal">RuntimeEngine</code> (and the underlying session) by <code class="literal">RuntimeManager</code>, which uses <code class="literal">TakServiceFactory</code>:</p><div class="informalexample"><pre class="programlisting">InternalTaskService internalTaskService = (InternalTaskService) taskServiceFactory.newTaskService();</pre></div><p>The factory used to instantiate <code class="literal">TaskService</code> is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">LocalTaskServiceFactory</code>: To be<a id="id728" class="indexterm"/> used in non-CDI environments</li></ul></div><p>The factory configures the task service with the following references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">EntityManagerFactory</code><a id="id729" class="indexterm"/> instance (taken from <code class="literal">RuntimeEnvironment</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">UserGroupCallback</code> (taken from <code class="literal">RuntimeEnvironment</code>). If no custom <code class="literal">UserGroupCallback</code> implementation<a id="id730" class="indexterm"/> is provided, a default <code class="literal">MvelUserGroupCallbackImpl</code> is used; this loads the <code class="literal">UserGroupsAssignmentsOne.mvel</code> file from <code class="literal">jbpm-human-task-core-6.2.0.Final.jar</code> (the <code class="literal">org\jbpm\services\task\identity</code> package).</li><li class="listitem" style="list-style-type: disc">Register task<a id="id731" class="indexterm"/> event listeners (instances of the <code class="literal">TaskLifeCycleEventListener</code> interface).</li><li class="listitem" style="list-style-type: disc"><code class="literal">TaskDeadlinesService</code>: This service is responsible for the management of the deadlines defined for a task <a id="id732" class="indexterm"/>and for triggering notifications (we talked about escalations and notifications in <a class="link" href="ch05.html" title="Chapter 5. BPMN Constructs">Chapter 5</a>, <span class="emphasis"><em>BPMN Constructs</em></span>).</li></ul></div><p>The factory also shares, at the environmental level, the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Default <code class="literal">DefaultUserInfo</code> instance (loaded with data from a <code class="literal">userinfo.properties</code> file in the <a id="id733" class="indexterm"/>classpath, if any)</li></ul></div><p>The task service leverages Commands to execute all common task operations; commands are executed via <code class="literal">CommandService</code>. Let us look at this service class and its inner working details.</p><div class="section" title="CommandService"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec112"/>CommandService</h2></div></div></div><p>RuntimeManager creates two different<a id="id734" class="indexterm"/> types of TaskService:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">CommandBasedTaskService</code>: The default task service implementation</li><li class="listitem" style="list-style-type: disc"><code class="literal">SynchronizedTaskService</code>: A synchronized task service instance that wraps <code class="literal">CommandBasedTaskService</code>. It is created using the Singleton runtime strategy</li></ul></div><p>
<code class="literal">CommandBaseTaskService</code> delegates the API executions to its internal <code class="literal">CommandService</code> executor. This is CommandExecutor and performs all the task API calls as in the KIE session (see the dedicated<span class="emphasis"><em> The CommandExecutor interface</em></span> section), for example:</p><div class="informalexample"><pre class="programlisting">public void start(long taskId, String userId) {
  executor.execute(new CompositeCommand&lt;Void&gt;(
    new StartTaskCommand(taskId, userId),
    new CancelDeadlineCommand(taskId, true, false)));
}</pre></div><p>The start (task) method, for instance, is executed as <code class="literal">CompositeCommand</code> built with two TaskCommand specializations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">StartTaskCommand</code>: It performs the task start operation by changing the state, triggering events on<a id="id735" class="indexterm"/> listeners, and so on</li><li class="listitem" style="list-style-type: disc"><code class="literal">CancelDeadlineCommand</code>: Cancel the<a id="id736" class="indexterm"/> matching deadline (if any) for this task's Start event (see the <span class="emphasis"><em>Deadlines and escalations</em></span> and the <span class="emphasis"><em>Notifications</em></span> sections in <a class="link" href="ch05.html" title="Chapter 5. BPMN Constructs">Chapter 5</a>, <span class="emphasis"><em>BPMN</em></span>)</li></ul></div><p>
<code class="literal">CompositeCommand</code> first executes the command from the varying argument <code class="literal">commands</code> and then, the <code class="literal">mainCommand</code> command. Its constructor signature is as follows:</p><div class="informalexample"><pre class="programlisting">public CompositeCommand(TaskCommand&lt;T&gt; mainCommand, TaskCommand&lt;?&gt;...commands) { 

}</pre></div></div><div class="section" title="TaskCommand and UserGroupCallback"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec113"/>TaskCommand and UserGroupCallback</h2></div></div></div><p>All task commands<a id="id737" class="indexterm"/> inherit from the <code class="literal">UserGroupCallbackTaskCommand</code> class; they call specific parent class methods on<a id="id738" class="indexterm"/> their <code class="literal">execute</code> method in order to trigger updates to the <code class="literal">ORGANIZATIONALENTITY</code> database table.</p><div class="section" title="The TaskContext command"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec84"/>The TaskContext command</h3></div></div></div><p>Upon instantiation, each task command is given <code class="literal">TaskContext</code> from <code class="literal">CommandExecutor</code>; the context duties are as<a id="id739" class="indexterm"/> follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Provides a <code class="literal">JPATaskPersistenceContext</code> instance, which handles all the database-related operations</li><li class="listitem" style="list-style-type: disc">Triggers task lifecycle-related events</li><li class="listitem" style="list-style-type: disc">Provides the core task-related services to the command</li></ul></div><p>The main task services provided are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Instance service</strong></span> (<code class="literal">TaskInstanceService</code>): The core service that implements the WS<a id="id740" class="indexterm"/> Human Task specification with respect to the task life cycle</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Query service</strong></span> (<code class="literal">TaskQueryService</code>): It returns read-only task instance information such as a list of tasks assigned to a user, potential owners for a given task, and<a id="id741" class="indexterm"/> so on</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Content service</strong></span> (<code class="literal">TaskContentService)</code>: It manages<a id="id742" class="indexterm"/> task content data (input and output)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Deadline service</strong></span> (<code class="literal">TaskDeadlineService</code>): It manages<a id="id743" class="indexterm"/> the scheduling of task deadlines</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Attachment service</strong></span> (<code class="literal">TaskAttachmentService</code>): It deals with task attachment <a id="id744" class="indexterm"/>management</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Admin service</strong></span> (<code class="literal">TaskAdminService</code>): It provides<a id="id745" class="indexterm"/> out-of-the-standard task life cycle operations such as task removal and task archival</li></ul></div><p>Tasks can be removed (literally deleted from the jBPM persistent store, making them unavailable for user assignments) but only after they have been marked as "archived."</p></div></div><div class="section" title="Transactions and interceptors"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec114"/>Transactions and interceptors</h2></div></div></div><p>TaskService CommandService is<a id="id746" class="indexterm"/> implemented by a <code class="literal">TaskCommandExecutorImpl</code> class, which, during<a id="id747" class="indexterm"/> initialization, is decorated with an <code class="literal">org.jbpm.services.task.persistence.TaskTransactionInterceptor</code> interceptor. The interceptor wraps each <code class="literal">execute</code> method invocation of the command service between transaction<a id="id748" class="indexterm"/> boundaries managed by the Drools<a id="id749" class="indexterm"/> <code class="literal">JtaTransactionManager</code>.</p></div><div class="section" title="Notification service"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec115"/>Notification service</h2></div></div></div><p>In <a class="link" href="ch05.html" title="Chapter 5. BPMN Constructs">Chapter 5</a>, <span class="emphasis"><em>BPMN Constructs</em></span>, we talked about the human task escalations and notifications features. The jBPM notification <a id="id750" class="indexterm"/>service relies on email messaging; thus, to work successfully, it requires the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A mail session properly configured</li><li class="listitem" style="list-style-type: disc">A <code class="literal">UserInfo</code> class instance defined; this provides the user's e-mail address to notify</li></ul></div><p>jBPM loads the mail session by<a id="id751" class="indexterm"/> a <span class="strong"><strong>Java Naming and Directory Interface</strong></span> (<span class="strong"><strong>JNDI</strong></span>) lookup; you can set the JNDI name through the <code class="literal">org.kie.mail.session</code> system property or, alternatively, provide the JNDI name <code class="literal">mail/jbpmMailSession</code> in your application server.</p><p>If no JNDI resource is found, jBPM fallbacks to a plain <code class="literal">email.properties</code> file loaded from the classpath.</p><p>The file defines the following properties (example values are provided):</p><div class="informalexample"><pre class="programlisting">mail.smtp.host=localhost
mail.smtp.port=2345
mail.from=alerts@packt.com
mail.replyto=replyTo@packt.com</pre></div><p>We covered the<a id="id752" class="indexterm"/> <code class="literal">UserInfo</code> class in <a class="link" href="ch05.html" title="Chapter 5. BPMN Constructs">Chapter 5</a>, <span class="emphasis"><em>BPMN Constructs</em></span>.</p></div><div class="section" title="The TaskFluent class"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec116"/>The TaskFluent class</h2></div></div></div><p>The <code class="literal">TaskFluent</code> class is a helper<a id="id753" class="indexterm"/> class that lets you conveniently configure and create a new <code class="literal">Task</code> instance and add it to the persistent store through the<a id="id754" class="indexterm"/> task service (see the <code class="literal">FluentTest</code> test class):</p><div class="informalexample"><pre class="programlisting">TaskFluent fluent = new TaskFluent();
fluent.setName("adhoc Human Task");
fluent.addPotentialUser("Luigi").setAdminUser("Administrator");
Task task = fluent.getTask();
// add the task
long taskid = taskService.addTask(task, new HashMap&lt;String, Object&gt;());</pre></div><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip21"/>Tip</h3><p>The WS-HumanTask specification defines the role of the administrator as the one who can manage the life cycle of the task, even though he might not be enlisted among the task potential owners. With releases older than jBPM 6, an "Administrator" user was created by default by jBPM.</p></div></div><p>The <code class="literal">addTask</code> operation requires you to add at least one potential business administrator for the task (by the <code class="literal">setAdminUser()</code> or <code class="literal">setAdminGroup()</code> method). The business administrator entity (user or group) is verified by the runtime with the current <code class="literal">UserGroupCallback</code> to check whether it exists. To check whether business administrators are task<a id="id755" class="indexterm"/> potential owners search the <code class="literal">PEOPLEASSIGNMENTS_BAS</code> jBPM database table.</p><p>To ease the test configuration, all our jUnit test classes are configured with a custom user callback, which lets all users pass (see the <code class="literal">MyUserCallback</code> class), so that "Administrator," "boss," or whatever makes no difference.</p><p>The runtime will evaluate the task assignments and their deadlines, and will store the task data; the engine assigns to the task, the initial state <code class="literal">CREATED</code>.</p><p>The <code class="literal">FluentTest</code> example shows how it is possible to programmatically create, add, assign, start, and complete new tasks outside the scope of a process definition (ad hoc tasks).</p><p>
<code class="literal">TaskFluent</code> lets you attach a new task to a given process instance. Since the new task has no incoming/outgoing<a id="id756" class="indexterm"/> connections, this could be of limited use, but it fits very well with ad hoc <a id="id757" class="indexterm"/>processes (see <a class="link" href="ch05.html" title="Chapter 5. BPMN Constructs">Chapter 5</a>, <span class="emphasis"><em>BPMN Constructs</em></span>), for example:</p><div class="informalexample"><pre class="programlisting">  ftask.setWorkItemId("default-singleton");
  ftask.setProcessId(PROCESS_ID);
  ftask.setProcessInstanceId(processinstance.getId());
  ftask.setProcessSessionId(ksession.getId());</pre></div></div></div>
<div class="section" title="Audit and history logs"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec40"/>Audit and history logs</h1></div></div></div><p>Auditing is the ability of the engine to let the<a id="id758" class="indexterm"/> user configure the collection and the retrieval of events relative to the runtime process execution. We introduced auditing and BAM in <a class="link" href="ch04.html" title="Chapter 4. Operation Management">Chapter 4</a>, <span class="emphasis"><em>Operation Management</em></span>, and now, we are going to see how to leverage the engine services to implement auditing at various levels.</p><p>When persistence is enabled, ready-to-use preconfigured <code class="literal">AuditService</code> (implemented by <code class="literal">JPAAuditLogService</code>) can be borrowed from <code class="literal">RuntimeEngine</code>; it returns process, node, and variable runtime audit data (see the class diagram) from the three standard jBPM auditing database tables (<code class="literal">ProcessInstanceLog</code>, <code class="literal">NodeInstanceLog</code>, and <code class="literal">VariableInstanceLog</code>). The audit service stamps each log entry with an <code class="literal">OwnerID</code> attribute, which matches the unique identifier of its RuntimeManager.</p><div class="informalexample"><pre class="programlisting">AuditLogService auditservice=engine.getAuditLogService();
List&lt;ProcessInstanceLog&gt; pizzadeliveryLogs= auditservice.findActiveProcessInstances("pizzadelivery");</pre></div><p>This AuditService usage approach (basically as a query service) is a solution that can be good for BAM or history analysis; however, if we want to collect audit data in real-time, we have to register a listener with the KIE session (see the <span class="emphasis"><em>Event listeners</em></span> section or the next section).</p><div class="section" title="AuditLoggerFactory"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec117"/>AuditLoggerFactory</h2></div></div></div><p>This factory can create<a id="id759" class="indexterm"/> ready-to-use JPA- or JMS-enabled audit loggers (see the following class diagram):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>JPA</strong></span>: A synchronous logger that <a id="id760" class="indexterm"/>by default persists the <a id="id761" class="indexterm"/>audit events between engine JTA transaction boundaries</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>JMS</strong></span>: Asynchronous<a id="id762" class="indexterm"/> logger aimed at JMS queue integration</li></ul></div><p>Remember that the logger has to be bound to KieSession to start logging:</p><div class="informalexample"><pre class="programlisting">  ksession.addEventLister(listener);</pre></div><p>We can set a different EntityManager on the JPA logger by providing custom EntityManagerFactory to a directly instantiated (no factory) <code class="literal">JPAAuditLogService</code> and, optionally, choosing an auditing strategy:</p><div class="informalexample"><pre class="programlisting">EntityManagerFactory emf = Persistence.createEntityManagerFactory("com.packt.masterjbpm6.persist enceunitApp");
AuditLogService logService = new JPAAuditLogService(emf, PersistenceStrategyType.STANDALONE_LOCAL);</pre></div><p>This allows us to adapt the engine logging service to our persistence layer configuration and transaction management: local entity manager and JTA. The main purpose of the strategy is to instruct jBPM to<a id="id763" class="indexterm"/> manage transactions when auditing in different application environments.</p><p>The KIE auditing strategies are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>KIE_SESSION</strong></span>: Select this strategy<a id="id764" class="indexterm"/> when you use the entity manager only with KieSession (default behavior)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>STANDALONE_LOCAL</strong></span>: Choose<a id="id765" class="indexterm"/> this strategy when your application uses the entity manager outside the scope of KieSession</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>STANDALONE_JTA</strong></span>: Same <a id="id766" class="indexterm"/>as the previous strategy but uses <code class="literal">java:comp/UserTransaction</code> or <code class="literal">java:jboss/UserTransaction</code> to resolve the transaction (application servers only)</li></ul></div><p>We show the relevant classes in the following class diagram:</p><div class="mediaobject"><img src="graphics/9578OS_06_02.jpg" alt="AuditLoggerFactory"/></div></div><div class="section" title="Custom logger"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec118"/>Custom logger</h2></div></div></div><p>To implement custom logging <a id="id767" class="indexterm"/>of audit events, you have to extend the <code class="literal">AbstractAuditLogger</code> class or provide a new implementation for the <code class="literal">ProcessEventListener</code> interface.</p><p>The supported audit events are as follows:</p><div class="informalexample"><pre class="programlisting">Process:
   BEFORE_START_EVENT_TYPE = 0;
   AFTER_START_EVENT_TYPE = 1;
   BEFORE_COMPLETE_EVENT_TYPE = 2;
   AFTER_COMPLETE_EVENT_TYPE = 3;
Nodes:
   BEFORE_NODE_ENTER_EVENT_TYPE = 4;
   AFTER_NODE_ENTER_EVENT_TYPE = 5;
   BEFORE_NODE_LEFT_EVENT_TYPE = 6;
   AFTER_NODE_LEFT_EVENT_TYPE = 7;
Variables:
   BEFORE_VAR_CHANGE_EVENT_TYPE = 8;
   AFTER_VAR_CHANGE_EVENT_TYPE = 9;</pre></div><p>Events are delivered as the following <code class="literal">ProcessEvent</code> implementation classes: <code class="literal">ProcessNodeEvent</code>, <code class="literal">ProcessStartedEvent</code>, <code class="literal">ProcessCompletedEvent</code>, and <code class="literal">ProcessVariableChangedEvent</code>. In order to convert the incoming typed events to Log JPA entity classes (that is, <code class="literal">VariableInstanceLog</code>), you<a id="id768" class="indexterm"/> can use a helper class (<code class="literal">DefaultAuditEventBuilderImpl)</code>:</p><div class="informalexample"><pre class="programlisting">AuditEventBuilder builder = new DefaultAuditEventBuilderImpl();
VariableInstanceLog variablelog = (VariableInstanceLog) builder.buildEvent(event);
// get process variable properties: processId, var. name and value
String processId= variablelog.getProcessId();
String variableId=variablelog.getVariableId();
String value= variablelog.getValue();
// persist
em.persist (variablelog);</pre></div></div></div>
<div class="section" title="Persistence and transactions"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec41"/>Persistence and transactions</h1></div></div></div><p>The default persistence<a id="id769" class="indexterm"/> mechanism of the jBPM engine is based on the JPA 2/Hibernate implementation. Each engine operation (start process, start task, complete<a id="id770" class="indexterm"/> task, and so on) is run inside the scope of a transaction. <code class="literal">TransactionInterceptor</code> demarcates each command execution and eventually, depending on the transaction<a id="id771" class="indexterm"/> management used (<span class="strong"><strong>Container Managed Transactions</strong></span> (<span class="strong"><strong>CMT</strong></span>) or UserTransaction <span class="strong"><strong>Bean Managed Transactions</strong></span> (<span class="strong"><strong>BMT</strong></span>)), enlists<a id="id772" class="indexterm"/> the EntityManager engine in the ongoing transaction. We have seen how both session and task persistence works through <code class="literal">CommandService</code> and the interceptor architecture.</p><p>The default engine persistence configuration boils down to the engine persistence unit (defined in a <code class="literal">persistence.xml</code> file configuration) and, usually, to a JTA datasource definition at the application server level. jBPM imposes no constraints on the number of entity managers defined; you can obviously have a number of persistence units defined in your application and make multiple entity managers coexist with jBPM Entity Manager. You can have a single database (single Entity Manager) for both jBPM and your application persistence layer or a dedicated jBPM database (and Entity Manager) and make the engine participate<a id="id773" class="indexterm"/> in your business application transactions.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note48"/>Note</h3><p>
<a class="link" href="ch08.html" title="Chapter 8. Integrating jBPM with Enterprise Architecture">Chapter 8</a>, <span class="emphasis"><em>Integrating jBPM with Enterprise Architecture</em></span>, of the jBPM 6.2 user guide explains the detailed configuration and usage of transactions.</p></div></div><div class="section" title="Local transactions with Bitronix"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec119"/>Local transactions with Bitronix</h2></div></div></div><p>We are going to see a complete jBPM <a id="id774" class="indexterm"/>persistence example configuration using local transactions. Bitronix is an open source Transaction <a id="id775" class="indexterm"/>Manager framework; it supports JTA API <a id="id776" class="indexterm"/>and the <span class="strong"><strong>Extended Architecture</strong></span> (<span class="strong"><strong>XA</strong></span>) protocol and perfectly fits all cases where a straightforward persistence configuration is needed. The required configuration steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create the datasource (pooled): The datasource will be bound to the <code class="literal">jdbc/localjbpm-ds</code> JNDI name as follows:<div class="informalexample"><pre class="programlisting">PoolingDataSource pds = new PoolingDataSource();
pds.setUniqueName(<span class="strong"><strong>"jdbc/localjbpm-ds"</strong></span>);
pds.setClassName(LrcXADataSource.class.getName());
pds.setMaxPoolSize(5);
pds.setAllowLocalTransactions(true);
pds.getDriverProperties().put("user","sa");
pds.getDriverProperties().put("password","");
pds.getDriverProperties().put("url","jdbc:h2:tcp://localhost /~/jbpm-db;MVCC=TRUE");
pds.getDriverProperties().put("driverClassName","org.h2.Driv er");
pds.init();</pre></div></li><li class="listitem">Create the <code class="literal">jndi.properties</code> file in your classpath resources, which includes the following code:<div class="informalexample"><pre class="programlisting">java.naming.factory.initial=bitronix.tm.jndi.BitronixInitialContextFactory</pre></div><p>This lets Bitronix context factory initialize the environment and bind transaction service objects to default JNDI names, notably the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">User transaction manager at <code class="literal">java:comp/UserTransaction</code></li><li class="listitem" style="list-style-type: disc">Tx synchronization registry at <code class="literal">java:comp/TransactionSynchronizationRegistry</code></li></ul></div></li><li class="listitem">Edit your<a id="id777" class="indexterm"/> <code class="literal">persistence.xml</code> file, specifying the Bitronix datasource name as follows:<div class="informalexample"><pre class="programlisting">&lt;persistence-unit name=<span class="strong"><strong>"localjbpm-persistenceunit"</strong></span>
    transaction-type="JTA"&gt;
&lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
&lt;!--  match the bitronix datasource uniqueName --&gt;
&lt;jta-data-source&gt;<span class="strong"><strong>jdbc/localjbpm-ds</strong></span>&lt;/jta-data-source&gt;</pre></div></li><li class="listitem">Now, you can<a id="id778" class="indexterm"/> create your <code class="literal">EntityManagerFactory</code> as follows:<div class="informalexample"><pre class="programlisting">EntityManagerFactory emf =Persistence.createEntityManagerFactory("localjbpm- persistenceunit");</pre></div></li></ol></div><div class="section" title="Managing transactions"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec85"/>Managing transactions</h3></div></div></div><p>jBPM provides an<a id="id779" class="indexterm"/> out-of-the-box transactional service to an enterprise application, which is able to participate in the existing transaction right from the calling application, so in case of an error (for example, a custom workitem handler throws an exception or a process node script fails), the engine transaction is marked for rollback and the exception is sent to the caller.</p><p>Let us now see a common example of<a id="id780" class="indexterm"/> <span class="strong"><strong>Entity Manager</strong></span> (<span class="strong"><strong>EM</strong></span>) and jBPM (managed by Bitronix) working together (please refer to the <code class="literal">AuditTxTest</code> test class):</p><div class="informalexample"><pre class="programlisting">AuditEntity audit = new AuditEntity();
audit.setDesc("startAudit1");
UserTransaction ut;
try {
  ut = (UserTransaction) new InitialContext()
      .lookup("java:comp/UserTransaction");
  ut.begin();
  em.joinTransaction();
  em.persist(audit);
// start process
  ProcessInstance pi = ksession.startProcess("auditTxProcess");
// new application database insert
  AuditEntity auditproc = new AuditEntity();
  auditproc.setDesc("Audit1:process started");
  em.persist(auditproc);
// commit both process instance and audit entity
  ut.commit();</pre></div></div></div><div class="section" title="Locking"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec120"/>Locking</h2></div></div></div><p>The default JPA transaction locking scheme used is optimistic. If you need to switch to a pessimistic locking<a id="id781" class="indexterm"/> mode, set the following parameter to <code class="literal">TRUE</code> in your <code class="literal">org.kie.api.runtime.Environment</code> instance:</p><div class="informalexample"><pre class="programlisting">EnvironmentName.USE_PESSIMISTIC_LOCKING</pre></div><p>This forces the engine to hold the lock on an entity (locking of type <code class="literal">LockModeType.PESSIMISTIC_FORCE_INCREMENT</code>) to ensure that the object is not modified.</p><div class="mediaobject"><img src="graphics/9578OS_06_07.jpg" alt="Locking"/></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Summary</h1></div></div></div><p>With this chapter, we took an extensive tour to the core engine components and services, not disregarding some of the engine inner implementation details. You should now be able to understand how the engine works and what happens "behind the curtains" when you use a specific engine feature.</p><p>The next chapter will deal with the engine customization and extension process in order to tailor the jBPM system features to your solution.</p></div></body></html>