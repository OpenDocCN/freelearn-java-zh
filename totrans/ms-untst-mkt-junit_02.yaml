- en: Chapter 2. Automating JUnit Tests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 自动化 JUnit 测试
- en: In this chapter, you will be introduced to the concept of **Extreme Programming**
    (**XP**), **Continuous Integration** (**CI**), the benefits of CI, and JUnit test
    automation using various tools.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解 **极限编程**（**XP**）、**持续集成**（**CI**）、CI 的好处以及使用各种工具进行 JUnit 测试自动化的概念。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: CI
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI
- en: Gradle automation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle 自动化
- en: Maven project management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven 项目管理
- en: Ant
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ant
- en: Jenkins
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins
- en: Continuous Integration
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: In college, I was working on a critical steganography (image watermarking) project
    and simultaneously developing a module on my home computer, where I integrated
    my changes with other changes on the college server. Most of my time was wasted
    in integration. After manual integration, I would find everything broken; so,
    integration was terrifying.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在大学期间，我正在做一个关键的水印技术（图像水印）项目，并同时在我的家用计算机上开发一个模块，我在那里将我的更改与其他在大学服务器上的更改集成在一起。我大部分时间都浪费在集成上。在手动集成之后，我会发现一切都不正常；所以，集成是可怕的。
- en: When CI is not available, development teams or developers make changes to code
    and then all the code changes are brought together and merged. Sometimes, this
    merge is not very simple; it involves the integration of lots of conflicting changes.
    Often, after integration, weird bugs crop up and a working module may start to
    fail, as it involves a complete rework of numerous modules. Nothing goes as planned
    and the delivery is delayed. As a result, the predictability, cost, and customer
    service are affected.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当 CI 不可用时，开发团队或开发者会对代码进行更改，然后将所有代码更改合并在一起。有时，这种合并并不简单；它涉及到大量冲突更改的集成。通常，在集成之后，奇怪的错误会出现，一个工作模块可能开始失败，因为它涉及到众多模块的完全重做。一切都不按计划进行，交付被延迟。结果，可预测性、成本和客户服务受到影响。
- en: CI is an XP concept. It was introduced to prevent integration issues. In CI,
    developers commit the code periodically, and every commit is built. Automated
    tests verify the system integrity. It helps in the incremental development and
    periodic delivery of the working software.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: CI 是一个 XP 概念。它被引入以防止集成问题。在 CI 中，开发者定期提交代码，每次提交都会构建。自动测试验证系统完整性。它有助于增量开发和定期交付可工作的软件。
- en: Benefits of CI
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI 的好处
- en: CI is meant to make sure that we're not breaking something unconsciously in
    our hurry. We want to run the tests continuously, and we need to be warned if
    they fail.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: CI 的目的是确保我们在匆忙中不会无意识地破坏某些东西。我们希望持续运行测试，如果测试失败，我们需要得到警告。
- en: In a good software development team, we'd find **test-driven development** (**TDD**)
    as well as CI.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个优秀的软件开发团队中，我们会发现 **测试驱动开发**（**TDD**）以及 CI。
- en: CI requires a listener tool to keep an eye on the version control system for
    changes. Whenever a change is committed, this tool automatically compiles and
    tests the application (sometimes it creates a WAR file, deploys the WAR/EAR file,
    and so on).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: CI 需要一个监听工具来关注版本控制系统中的更改。每当有更改提交时，此工具会自动编译和测试应用程序（有时它还会创建 WAR 文件，部署 WAR/EAR
    文件等）。
- en: If compilation fails, or a test fails, or deployment fails, or something goes
    wrong, the CI tool immediately notifies the concerned team so that they can fix
    the issue.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译失败，或者测试失败，或者部署失败，或者出现其他问题，CI 工具会立即通知相关团队，以便他们可以解决问题。
- en: CI is a concept; to adhere to CI, tools such as Sonar and FindBugs can be added
    to the build process to track the code quality, and they automatically monitor
    the code quality and code coverage metrics. Good quality code gives us confidence
    that a team is following the right path. Technical debts can be identified very
    quickly, and the team can start reducing the debts. Often, CI tools have the ability
    to present dashboards pertaining to quality metrics.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: CI 是一个概念；为了遵守 CI，可以将 Sonar 和 FindBugs 等工具添加到构建过程中，以跟踪代码质量，并自动监控代码质量和代码覆盖率指标。高质量的代码让我们有信心认为团队正在走正确的道路。技术债务可以非常快速地识别出来，团队可以开始减少债务。通常，CI
    工具具有展示与质量指标相关的仪表板的能力。
- en: In a nutshell, CI tools enforce code quality, predictability, and provide quick
    feedback, which reduces the potential risk. CI helps to increase the confidence
    in the build. A team can still write very poor quality code, even test poor quality
    code, and the CI will not care.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，CI 工具强制执行代码质量、可预测性和快速反馈，从而降低潜在风险。CI 有助于提高构建的信心。一个团队仍然可以编写非常低质量的代码，甚至测试低质量的代码，CI
    也不会关心。
- en: Numerous CI tools are available on the market, such as Go, Bamboo, TeamCity,
    CruiseControl, and Jenkins. However, CruiseControl and Jenkins are the widely
    used ones.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有许多CI工具，如Go、Bamboo、TeamCity、CruiseControl和Jenkins。然而，CruiseControl和Jenkins是广泛使用的工具。
- en: Jenkins supports various build scripting tools. It integrates almost all sorts
    of projects and is easy to configure. In this chapter, we will work with Jenkins.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins支持各种构建脚本工具。它几乎可以集成所有类型的项目，并且易于配置。在本章中，我们将使用Jenkins。
- en: CI is just a generic conduit to run the commands; often, build tools are used
    to execute the commands, and then the CI tool collects the metrics produced by
    the commands or build tools. Jenkins needs build scripts to execute tests, compile
    the source code, or even deploy deliverables. Jenkins supports different build
    tools to execute the commands—Gradle, Maven, and Ant are the widely used ones.
    We will explore the build tools and then work with Jenkins.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: CI只是一个通用的命令执行通道；通常，构建工具用于执行命令，然后CI工具收集由命令或构建工具产生的指标。Jenkins需要构建脚本来执行测试、编译源代码，甚至部署成果。Jenkins支持不同的构建工具来执行命令——Gradle、Maven和Ant是广泛使用的工具。我们将探讨构建工具，然后与Jenkins一起工作。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can download the code for this chapter. Extract the ZIP file. It contains
    a folder named `Packt`. This folder has two subfolders: `gradle` and `chapter02`.
    The `gradle` folder contains the basic Gradle examples and the `chapter02` folder
    contains the Java projects and Ant, Gradle, and Maven build scripts.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以下载本章的代码。解压缩ZIP文件。它包含一个名为`Packt`的文件夹。此文件夹有两个子文件夹：`gradle`和`chapter02`。`gradle`文件夹包含基本的Gradle示例，而`chapter02`文件夹包含Java项目和Ant、Gradle和Maven构建脚本。
- en: Gradle automation
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gradle自动化
- en: '**Gradle** is a build automation tool. Gradle has many benefits such as loose
    structure, ability to write scripts to build, simple two-pass project resolution,
    dependency management, remote plugins, and so on.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gradle**是一种构建自动化工具。Gradle具有许多优点，如松散的结构、编写构建脚本的能力、简单的两遍项目解析、依赖管理、远程插件等。'
- en: The best feature of Gradle is the ability to create a **domain-specific language**
    (**DSL**) for the build. An example would be generate-web-service-stubs or run-all-tests-in-parallel.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle的最佳特性是能够为构建创建**领域特定语言**（**DSL**）。一个例子是generate-web-service-stubs或run-all-tests-in-parallel。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A DSL is a programming language specialized for a domain and focuses on a particular
    aspect of a system. HTML is an example of DSL. We cannot build an entire system
    with a DSL, but DSLs are used to solve problems in a particular domain. The following
    are the examples of DSLs:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: DSL是一种针对特定领域的编程语言，专注于系统的特定方面。HTML是DSL的一个例子。我们无法使用DSL构建整个系统，但DSL用于解决特定领域的问题。以下是一些DSL的例子：
- en: A DSL for building Java projects
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于构建Java项目的DSL
- en: A DSL for drawing graph
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于绘制图形的DSL
- en: It's one of the **unique selling point** (**USP**) is an incremental build.
    It can be configured to build a project only if any resource has changed in the
    project. As a result, the overall build execution time decreases.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 它的一个独特卖点（**USP**）是增量构建。它可以配置为仅在项目中的任何资源发生变化时构建项目。因此，整体构建执行时间减少。
- en: Gradle comes up with numerous preloaded plugins for different projects types.
    We can either use them or override.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle为不同类型的项目提供了许多预加载的插件。我们可以使用它们或覆盖它们。
- en: Unlike Maven or Ant, Gradle is not XML based; it is based on a dynamic language
    called **Groovy**. Groovy is a developer-friendly **Java Virtual Machine** (**JVM**)
    language. Its syntax makes it easier to express the code intent and provides ways
    to effectively use expressions, collections, closures, and so on. Groovy programs
    run on JVM; so, if we write Java code in a Groovy file, it will run. Groovy supports
    DSL to make your code readable and maintainable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与Maven或Ant不同，Gradle不是基于XML的；它基于一种名为**Groovy**的动态语言。Groovy是一种面向开发者的**Java虚拟机**（**JVM**）语言。它的语法使得表达代码意图更加容易，并提供有效使用表达式、集合、闭包等方法。Groovy程序在JVM上运行；因此，如果我们在一个Groovy文件中编写Java代码，它将会运行。Groovy支持DSL，以使代码更易于阅读和维护。
- en: Groovy's home page is [http://groovy.codehaus.org/](http://groovy.codehaus.org/).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy的官方网站是[http://groovy.codehaus.org/](http://groovy.codehaus.org/)。
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We can use Ant or Maven in a Gradle script. Gradle supports the Groovy syntax.
    Gradle provides support for Java, Web, Hibernate, GWT, Groovy, Scala, OSGi, and
    many other projects.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Gradle脚本中使用Ant或Maven。Gradle支持Groovy语法。Gradle为Java、Web、Hibernate、GWT、Groovy、Scala、OSGi以及许多其他项目提供支持。
- en: Big companies such as LinkedIn and Siemens use Gradle. Many open source projects,
    such as Spring, Hibernate, and Grails use Gradle.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大型公司如 LinkedIn 和西门子使用 Gradle。许多开源项目，如 Spring、Hibernate 和 Grails，也使用 Gradle。
- en: Getting started
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入门
- en: 'Java (jdk 1.5 +) needs to be installed before executing a Gradle script. The
    steps to do this are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行 Gradle 脚本之前，需要安装 Java (jdk 1.5+)。以下是操作步骤：
- en: Go to the command prompt and run `java –version`; if Java is not installed or
    the version is older than 1.5, install the latest version from the Oracle site.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符并运行 `java –version`；如果 Java 未安装或版本低于 1.5，请从 Oracle 网站安装最新版本。
- en: Gradle is available at [http://www.gradle.org/downloads](http://www.gradle.org/downloads).
    Once the download is complete, extract the media. You will find that it includes
    a `bin` directory. Open the command prompt and go to the `bin` directory. You
    can extract the media to any directory you want. For example, if you extract the
    Gradle media under `D:\Software\gradle-1.10`, then open the command prompt and
    go to `D:\Software\gradle-1.10\bin`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gradle 可在 [http://www.gradle.org/downloads](http://www.gradle.org/downloads)
    获取。下载完成后，提取媒体文件。你会发现它包含一个 `bin` 目录。打开命令提示符并进入 `bin` 目录。你可以将媒体文件提取到任何你想要的目录。例如，如果你将
    Gradle 媒体文件提取到 `D:\Software\gradle-1.10` 下，那么打开命令提示符并进入 `D:\Software\gradle-1.10\bin`。
- en: Now, check the Gradle version using the `gradle –v` command. It will show you
    the version and other configuration. To run the Gradle from anywhere in your computer,
    create a `GRADLE_HOME` environment variable and set the value to the location
    where you extracted the Gradle media.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `gradle –v` 命令检查 Gradle 版本。它将显示版本和其他配置。要在计算机的任何位置运行 Gradle，请创建一个 `GRADLE_HOME`
    环境变量，并将其值设置为提取 Gradle 媒体文件的位置。
- en: Add `%GRADLE_HOME%\bin` (in Windows) to the `PATH` variable (export `GRADLE_HOME`
    and `PATH` to `bash_login` in Linux and `bashrc` in Mac).
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `%GRADLE_HOME%\bin`（在 Windows 上）添加到 `PATH` 变量中（在 Linux 的 `bash_login` 和 Mac
    的 `bashrc` 中导出 `GRADLE_HOME` 和 `PATH`）。
- en: Open a new command prompt, go to any folder, and run the same command `gradle
    –v` again to check whether the `PATH` variable is set correctly.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的命令提示符，进入任何文件夹，并再次运行相同的命令 `gradle –v` 以检查 `PATH` 变量是否设置正确。
- en: The other option is to use the Gradle wrapper (`gradlew`) and allow the batch
    file (or shell script) to download the version of Gradle specific to each project.
    This is an industry standard for working with Gradle, which ensures that there's
    consistency among Gradle versions. The Gradle wrapper is also checked into the
    source code control along with the build artifacts.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用 Gradle 包装器 (`gradlew`)，并允许批处理文件（或 shell 脚本）下载针对每个项目特定的 Gradle 版本。这是使用
    Gradle 的行业标准，确保 Gradle 版本之间的一致性。Gradle 包装器也随构建工件一起提交到源代码控制。
- en: Gradling
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gradling
- en: In the programming world, "Hello World" is the starting point. In this section,
    we will write our first "Hello World" Gradle script. A Gradle script can build
    one or more projects. Each project can have one or more tasks. A task can be anything
    like compiling Java files or building a WAR file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程世界中，“Hello World” 是起点。在本节中，我们将编写第一个“Hello World” Gradle 脚本。Gradle 脚本可以构建一个或多个项目。每个项目可以有一个或多个任务。任务可以是编译
    Java 文件或构建 WAR 文件等任何操作。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To execute a task, we will create a `build.gradle` file and execute the `gradle`
    command to run a build. Gradle will look for a file named `build.gradle` in the
    current directory. To execute a build file other than `build.gradle`, use the
    `–b <file name>` option.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行一个任务，我们将创建一个 `build.gradle` 文件并执行 `gradle` 命令以运行构建。Gradle 将在当前目录中查找名为 `build.gradle`
    的文件。要执行除 `build.gradle` 之外的构建文件，请使用 `–b <文件名>` 选项。
- en: 'We will create a task to print "Hello World" on the console. Perform the following
    steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个任务，在控制台上打印“Hello World”。执行以下步骤：
- en: 'Open a text editor and enter the following:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个文本编辑器并输入以下内容：
- en: '[PRE0]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Save the file as `build.gradle`.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将文件保存为 `build.gradle`。
- en: Open the command prompt and browse to the folder where you saved the `build.gradle`
    file. Run the `gradle firstTask` command, or if you saved the file under `D:\Packt\gradle`,
    simply open the command prompt and run `gradle –b D:\Packt\gradle\build.gradle
    firstTask`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符并浏览到保存 `build.gradle` 文件的文件夹。运行 `gradle firstTask` 命令，或者如果你将文件保存在 `D:\Packt\gradle`
    下，只需打开命令提示符并运行 `gradle –b D:\Packt\gradle\build.gradle firstTask`。
- en: 'The following information will be printed on the command prompt:'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命令提示符将打印以下信息：
- en: '[PRE1]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we defined a task named `aTask` using the Java method style. The task
    `aTask` contains two closure keywords: `doLast` and `doFirst`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 Java 方法风格定义了一个名为 `aTask` 的任务。任务 `aTask` 包含两个闭包关键字：`doLast` 和 `doFirst`。
- en: The `doFirst` closure is executed once the task is invoked, and the `doLast`
    closure is executed at the end.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当任务被调用后，`doFirst` 闭包会被执行，而 `doLast` 闭包会在任务结束时执行。
- en: 'When we run `gradle aTask`, it prints the following messages:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `gradle aTask` 时，它会打印以下信息：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Default tasks
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 默认任务
- en: In Ant, we can define a default target; similarly, Gradle provides options for
    default tasks using the keyword `defaultTasks 'taskName1', …'taskNameN'`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ant 中，我们可以定义一个默认目标；同样，Gradle 提供了使用关键字 `defaultTasks 'taskName1', …'taskNameN'`
    的默认任务选项。
- en: The `defaultTasks` '`aTask`' keyword defines `aTask` as a default task. So now
    if we only execute `gradle` with no task name, then it will invoke the default
    task.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultTasks` 关键字 `''aTask''` 定义 `aTask` 为默认任务。因此，如果我们只执行 `gradle` 而不带任务名称，那么它将调用默认任务。'
- en: The task dependency
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务依赖
- en: 'In Ant, a target depends on another target, for example, a Java code compile
    task may depend on cleaning of the output folder; similarly, in Gradle, a task
    may depend on another task. The dependency is defined using the `dependsOn` keyword.
    The following syntax is used to define a task dependency:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ant 中，一个目标依赖于另一个目标，例如，Java 代码编译任务可能依赖于输出文件夹的清理；同样，在 Gradle 中，一个任务可能依赖于另一个任务。依赖是通过
    `dependsOn` 关键字定义的。以下语法用于定义任务依赖：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, `secondTask` depends on `firstTask`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`secondTask` 依赖于 `firstTask`。
- en: 'Another way of defining task dependency is passing the dependency in a method-like
    style. The following code snippet shows the method argument style:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 定义任务依赖的另一种方式是以类似方法的方式传递依赖。以下代码片段显示了方法参数样式：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Execute `gradle secondTask`; it will first execute the dependent task `firstTask`
    and then execute the task `secondTask` as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `gradle secondTask`；它将首先执行依赖任务 `firstTask`，然后执行任务 `secondTask`，如下所示：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Another way of defining intertask dependency is using `secondTask.dependsOn
    = ['firstTask']` or `secondTask.dependsOn 'firstTask'`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 定义任务间依赖的另一种方式是使用 `secondTask.dependsOn = ['firstTask']` 或 `secondTask.dependsOn
    'firstTask'`。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can abbreviate each word of a task name in a camel case to execute a task.
    For example, the task name `secondTask` can be abbreviated to `sT`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将任务名称中的每个单词缩写为驼峰式，以执行任务。例如，任务名称 `secondTask` 可以缩写为 `sT`。
- en: Daemon
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 守护进程
- en: 'Each time the `gradle` command is invoked, a new process is started, the Gradle
    classes and libraries are loaded, and the build is executed. Loading classes and
    libraries take time. Execution time can be reduced if a JVM, Gradle classes, and
    libraries, are not loaded each time. The `--daemon` command-line option starts
    a new Java process and preloads the Gradle classes and libraries; so, the first
    execution takes time. The next execution with the `--daemon` option takes almost
    no time because only the build gets executed—the JVM, with the required Gradle
    classes and libraries is already loaded. The configuration for daemon is often
    put into a `GRADLE_OPTS` environment variable; so, the flag is not needed on all
    calls. The following screenshot shows the execution of daemon:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `gradle` 命令时，都会启动一个新的进程，加载 Gradle 类和库，并执行构建。加载类和库需要时间。如果每次都不加载 JVM、Gradle
    类和库，则可以减少执行时间。`--daemon` 命令行选项启动一个新的 Java 进程并预加载 Gradle 类和库；因此，第一次执行需要时间。带有 `--daemon`
    选项的后续执行几乎不需要时间，因为只有构建被执行——JVM 以及所需的 Gradle 类和库已经加载。守护进程的配置通常放入 `GRADLE_OPTS` 环境变量中；因此，不是所有调用都需要这个标志。以下截图显示了守护进程的执行：
- en: '![Daemon](img/00018.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![守护进程](img/00018.jpeg)'
- en: Note that the first build took 31 seconds, whereas the second build tool took
    only 2 seconds.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一次构建花费了 31 秒，而第二次构建工具只花费了 2 秒。
- en: To stop a daemon process, use `gradle –stop` the command-line option.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止守护进程，请使用命令行选项 `gradle –stop`。
- en: Gradle plugins
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gradle 插件
- en: Build scripts are monotonous, for example, in a Java build script, we define
    the source file location, third-party JAR location, clean output folder, compile
    Java files, run tests, create JAR file, and so on. Almost all Java project build
    scripts look similar.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 构建脚本通常是单调的，例如，在一个 Java 构建脚本中，我们定义源文件位置、第三方 JAR 文件位置、清理输出文件夹、编译 Java 文件、运行测试、创建
    JAR 文件等。几乎所有的 Java 项目构建脚本看起来都很相似。
- en: This is something similar to duplicate codes. We resolve the duplicates by refactoring
    and moving duplicates to a common place and share the common code. Gradle plugins
    solve this repetitive build task problem by moving the duplicate tasks to a common
    place so that all projects share and inherit the common tasks instead of redefining
    them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于重复代码。我们通过重构和将重复的代码移动到公共位置并共享公共代码来解决重复的代码问题。Gradle 插件通过将重复的任务移动到公共位置来解决重复的构建任务问题，这样所有项目都可以共享和继承公共任务，而不是重新定义它们。
- en: A plugin is a Gradle configuration extension. It comes with some preconfigured
    tasks that, together, do something useful. Gradle ships with a number of plugins
    and helps us write neat and clean scripts.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 插件是一个 Gradle 配置扩展。它包含一些预配置的任务，这些任务组合起来可以完成一些有用的功能。Gradle 随带了许多插件，帮助我们编写整洁的脚本。
- en: In this chapter, we will explore the Java and Eclipse plugins.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 Java 和 Eclipse 插件。
- en: The Eclipse plugin
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Eclipse 插件
- en: The Eclipse plugin generates the project files necessary to import a project
    in Eclipse.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse 插件生成导入 Eclipse 项目所需的文件。
- en: 'Any Eclipse project has two important files: a `.project` file and a `.classpath`
    file. The `.project` file contains the project information such as the project
    name and project nature. The `.classpath` file contains the classpath entries
    for the project.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 Eclipse 项目都有两个重要的文件：一个 `.project` 文件和一个 `.classpath` 文件。`.project` 文件包含项目信息，如项目名称和项目类型。`.classpath`
    文件包含项目的类路径条目。
- en: 'Let''s create a simple Gradle build with the Eclipse plugin using the following
    steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤使用 Eclipse 插件创建一个简单的 Gradle 构建脚本：
- en: 'Create a folder named `eclipse`, then a file named `build.gradle`, and add
    the following script:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `eclipse` 的文件夹，然后创建一个名为 `build.gradle` 的文件，并添加以下脚本：
- en: '[PRE8]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To inherit a plugin nature, Gradle uses the `apply plugin: ''<plug-in name>''`
    syntax.'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '要继承插件类型，Gradle 使用 `apply plugin: ''<plug-in name>''` 语法。'
- en: Open the command prompt and check all the available tasks using the `gradle
    tasks –-all` command. This will list the available Eclipse plugin tasks for you.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符，使用 `gradle tasks –-all` 命令检查所有可用的任务。这将为您列出可用的 Eclipse 插件任务。
- en: 'Now run the `gradle eclipse` command. It will generate only the `.project`
    file, as the command doesn''t know what type of project needs to be built. You
    will see the following output on the command prompt:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行 `gradle eclipse` 命令。它将只生成 `.project` 文件，因为该命令不知道需要构建哪种类型的项目。您将在命令提示符上看到以下输出：
- en: '[PRE9]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To create a Java project, add `apply plugin: ''java''` to the `build.gradle`
    file and rerun the command. This time it will execute four tasks as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '要创建一个 Java 项目，将 `apply plugin: ''java''` 添加到 `build.gradle` 文件中，并重新运行命令。这次它将执行以下四个任务：'
- en: '[PRE10]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Open the `Eclipse` folder (the location where you put the `build.gradle` file).
    You will find the `.project` and `.classpath` files and a .`settings` folder.
    For a Java project, a **Java Development Tools** (**JDT**) configuration file
    is required. The `.settings` folder contains the `org.eclipse.jdt.core.prefs`
    file.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Eclipse` 文件夹（放置 `build.gradle` 文件的位置）。您将找到 `.project` 和 `.classpath` 文件以及一个
    `.settings` 文件夹。对于 Java 项目，需要一个 **Java 开发工具**（**JDT**）配置文件。`.settings` 文件夹包含 `org.eclipse.jdt.core.prefs`
    文件。
- en: Now, we can launch Eclipse and import the project. We can edit the `.project`
    file and change the project name.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动 Eclipse 并导入项目。我们可以编辑 `.project` 文件并更改项目名称。
- en: Normally, a Java project depends on third-party JARs, such as the JUnit JAR
    and Apache utility JARs. In the next section, we will learn how a classpath can
    be generated with JAR dependencies.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Java 项目依赖于第三方 JAR 文件，例如 JUnit JAR 和 Apache 工具 JAR。在下一节中，我们将学习如何使用 JAR 依赖项生成类路径。
- en: The Java plugin
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Java 插件
- en: The Java plugin provides some default tasks for your project that will compile
    and unit test your Java source code and bundle it into a JAR file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Java 插件为您的项目提供了一些默认任务，这些任务将编译和单元测试您的 Java 源代码，并将其打包成一个 JAR 文件。
- en: The Java plugin defines the default values for many aspects of the project,
    such as the source files' location and Maven repository. We can follow the conventions
    or customize them if necessary; generally, if we follow the conventional defaults,
    then we don't need to do much in our build script.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Java 插件定义了项目许多方面的默认值，例如源文件的位置和 Maven 仓库。我们可以遵循约定或根据需要自定义它们；通常，如果我们遵循传统的默认值，那么我们就不需要在构建脚本中做很多事情。
- en: 'Let''s create a simple Gradle build script with the Java plugin and observe
    what the plugin offers. Perform the following steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的 Gradle 构建脚本，使用 Java 插件并观察插件提供了什么。执行以下步骤：
- en: 'Create a `java.gradle` build file and add the `apply plugin: ''java''` line.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个`java.gradle`构建文件并添加`apply plugin: ''java''`行。'
- en: Open the command prompt and type in `gradle -b java.gradle tasks –-all`. This
    will list the Java plugin tasks for you.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符并输入`gradle -b java.gradle tasks –-all`。这将为您列出Java插件任务。
- en: To build a project, we can use the build task; the build depends on many tasks.
    Execute the `gradle -b java.gradle build` command. The following screenshot shows
    the output:![The Java plugin](img/00019.jpeg)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建一个项目，我们可以使用构建任务；构建依赖于许多任务。执行`gradle -b java.gradle build`命令。以下截图显示了输出：![Java插件](img/00019.jpeg)
- en: Since no source code was available, the build script didn't build anything.
    However, we can see the list of available tasks—build tasks are dependent on compile,
    JAR creation, test execution, and so on.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有提供源代码，构建脚本没有构建任何内容。然而，我们可以看到可用的任务列表——构建任务依赖于编译、JAR创建、测试执行等。
- en: Java plugins come with a convention that the build source files will be under
    `src/main/java`, relative to the project directory. Non-Java resource files such
    as the XML and properties files will be under `src/main/resources`. Tests will
    be under `src/test/java`, and the test resources under the `src/test/resources`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Java插件遵循一个约定，即构建源文件将位于项目目录下的`src/main/java`。非Java资源文件，如XML和属性文件，将位于`src/main/resources`。测试将位于`src/test/java`，测试资源位于`src/test/resources`。
- en: To change the default Gradle project source file directory settings, use the
    `sourceSets` keyword. The `sourceSets` keyword allows us to change the default
    source file's location.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改默认的Gradle项目源文件目录设置，使用`sourceSets`关键字。`sourceSets`关键字允许我们更改默认源文件的位置。
- en: A Gradle script must know the location of the `lib` directory to compile files.
    The Gradle convention for library locations is repositories. Gradle supports the
    local `lib` folder, external dependencies, and remote repositories.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle脚本必须知道`lib`目录的位置才能编译文件。Gradle对库位置的约定是仓库。Gradle支持本地`lib`文件夹、外部依赖项和远程仓库。
- en: 'Gradle also supports the following repositories:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle还支持以下仓库：
- en: '**Maven repository**: Maven can be configured on our local machine, on a network
    machine, or even the preconfigured central repository.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maven仓库**：Maven可以配置在我们的本地机器上、网络机器上，甚至是预配置的中心仓库。'
- en: '**Maven central repository**: Maven''s central repository is located at [http://repo1.maven.org/maven2](http://repo1.maven.org/maven2).
    The `mavenCentral()` groovy method can be used to load dependencies from the centralized
    Maven repository. The following is an example of accessing the central repository:'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maven中心仓库**：Maven的中心仓库位于[http://repo1.maven.org/maven2](http://repo1.maven.org/maven2)。可以使用`mavenCentral()`groovy方法从集中的Maven仓库加载依赖项。以下是一个访问中心仓库的示例：'
- en: '[PRE11]'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Maven local repository**: If we have a local Maven repository, we can use
    the `mavenLocal()`method to resolve dependencies as follows:'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maven本地仓库**：如果我们有一个本地Maven仓库，我们可以使用`mavenLocal()`方法如下解决依赖项：'
- en: '[PRE12]'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'The `maven()` method can be used to access repositories configured on the intranet.
    The following is an example of accessing an intranet URL:'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以使用`maven()`方法来访问内网配置的仓库。以下是一个访问内网URL的示例：
- en: '[PRE13]'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `mavenRepo()` method can be used with the following code:'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以使用以下代码使用`mavenRepo()`方法：
- en: '[PRE14]'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A secured Maven repository needs user credentials. Gradle provides the `credentials`
    keyword to pass user credentials. The following is an example of accessing a secured
    Maven repository:'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 受保护的Maven仓库需要用户凭据。Gradle提供了`credentials`关键字来传递用户凭据。以下是一个访问受保护Maven仓库的示例：
- en: '[PRE15]'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Ivy repository**: This is a remote or local ivy repository. Gradle supports
    the same Maven methods for ivy. The following is an example of accessing an ivy
    repository and a secured ivy repository:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ivy仓库**：这是一个远程或本地Ivy仓库。Gradle支持与Maven相同的Ivy方法。以下是一个访问Ivy仓库和受保护Ivy仓库的示例：'
- en: '[PRE16]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Flat directory repository**: This is a local or network directory. The following
    is an example of accessing a local directory:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平面目录仓库**：这是一个本地或网络目录。以下是一个访问本地目录的示例：'
- en: '[PRE17]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Gradle uses `flatDir()` to locate a local or network-shared library folder.
    Here, `dir` is used to locate a single directory and `dirs` with directory locations
    separated by commas are used to locate distributed folders.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Gradle使用`flatDir()`来定位本地或网络共享的库文件夹。在这里，`dir`用于定位单个目录，而使用以逗号分隔的目录位置`dirs`用于定位分布式文件夹。
- en: 'In this section, we will create a Java project, write a test, execute the test,
    compile source or test files, and finally build a JAR file. Perform the following
    steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个Java项目，编写一个测试，执行测试，编译源文件或测试文件，并最终构建一个JAR文件。执行以下步骤：
- en: Create a `build.gradle` build script file under `packt\chapter02\java`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`packt\chapter02\java`下创建一个`build.gradle`构建脚本文件。
- en: 'Add Eclipse and Java plugin support using the following lines of code:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码行添加Eclipse和Java插件支持：
- en: '[PRE18]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will write a JUnit test, so our project will be dependent on JUnit JARs.
    Create a `lib` directory under `packt\chapter02` and copy the `hamcrest-core-1.3.jar`
    and `junit-4.11.jar` JARs (we downloaded these JARs in [Chapter 1](part0014_split_000.html#page
    "Chapter 1. JUnit 4 – a Total Recall"), *JUnit 4 – a Total Recall*).
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将编写一个JUnit测试，因此我们的项目将依赖于JUnit JARs。在`packt\chapter02`下创建一个`lib`目录，并复制`hamcrest-core-1.3.jar`和`junit-4.11.jar`
    JAR文件（我们在[第1章](part0014_split_000.html#page "第1章。JUnit 4 – 全部回忆")中下载了这些JAR文件，*JUnit
    4 – 全部回忆*）。
- en: 'In this example, we will use the flat directory repository. We created a `lib`
    directory for JUnit JARs. Add the following lines to the `build.gradle` file to
    configure our repository:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此示例中，我们将使用平面目录仓库。我们为JUnit JARs创建了一个`lib`目录。将以下行添加到`build.gradle`文件中，以配置我们的仓库：
- en: '[PRE19]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have a single `lib` folder; so, we will use `flatDir` and `dir` conventions.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们有一个单独的`lib`文件夹；因此，我们将使用`flatDir`和`dir`约定。
- en: A repository can have numerous library files, but we may need only some of them.
    For example, source file compilation doesn't require the JUnit JARs but test files
    and test execution need them.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个仓库可以包含大量的库文件，但我们可能只需要其中的一部分。例如，源文件编译不需要JUnit JARs，但测试文件和测试执行需要它们。
- en: Gradle comes with dependency management. The dependencies keyword is used to
    define dependencies.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Gradle自带依赖管理。`dependencies`关键字用于定义依赖项。
- en: 'The closure dependencies support the following default types:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 闭包依赖支持以下默认类型：
- en: '**Compile**: These are the dependencies required to compile the source of the
    project.'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译**：这些是编译项目源代码所需的依赖项。'
- en: '**Runtime**: These dependencies are required by the production classes at runtime.
    By default, these also include the compile time dependencies.'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时**：这些依赖项是生产类在运行时所需的。默认情况下，这些也包括编译时依赖项。'
- en: '**testCompile**: These dependencies are required to compile the test source
    of the project. By default, they also include the compiled production classes
    and the compile-time dependencies.'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**testCompile**：这些依赖项是编译项目测试源代码所必需的。默认情况下，它们还包括编译后的生产类和编译时依赖项。'
- en: '**testRuntime**: These dependencies are required to run the tests. By default,
    they also include the compile, runtime, and testCompile dependencies.'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**testRuntime**：这些依赖项是运行测试所必需的。默认情况下，它们还包括编译、运行时和testCompile依赖项。'
- en: 'Each dependency type needs a coordinate: a group, name, and version of a dependent
    JAR.'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每种依赖类型都需要一个坐标：依赖JAR的组、名称和版本。
- en: Some websites, such as [mvnrepository.com](http://mvnrepository.com), can help
    us to come up with a ready-to-copy-paste dependency string, such as [http://mvnrepository.com/artifact/org.springframework/spring-aop/3.1.1.RELEASE](http://mvnrepository.com/artifact/org.springframework/spring-aop/3.1.1.RELEASE).
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些网站，如[mvnrepository.com](http://mvnrepository.com)，可以帮助我们生成一个可复制粘贴的依赖字符串，例如[http://mvnrepository.com/artifact/org.springframework/spring-aop/3.1.1.RELEASE](http://mvnrepository.com/artifact/org.springframework/spring-aop/3.1.1.RELEASE)。
- en: Note
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Suppose we need to include the `org.springframework.aop-3.1.1.RELEASE.jar` file
    in our classpath (here `org.springframework` is the group, `aop` is the name,
    and `3.1.1.RELEASE` is the version). We can simply write `org.springframework:aop:3.1.1.RELEASE`
    to identify `aop.jar`.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设我们需要将`org.springframework.aop-3.1.1.RELEASE.jar`文件包含在我们的类路径中（这里`org.springframework`是组，`aop`是名称，`3.1.1.RELEASE`是版本）。我们可以简单地写`org.springframework:aop:3.1.1.RELEASE`来标识`aop.jar`。
- en: 'Tests need JUnit JAR support. Add the following lines to our `build.gradle`
    file to add the JUnit dependency:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试需要JUnit JAR支持。将以下行添加到我们的`build.gradle`文件中，以添加JUnit依赖项：
- en: '[PRE20]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Or simply add the following lines to the file:'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者简单地添加以下行到文件中：
- en: '[PRE21]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Generate an Eclipse project using the Eclipse plugin and issue the `gradle
    eclipse` command. The `eclipse` command will execute three tasks: `eclipseClasspath`,
    `eclipseJdt`, and `eclipseProject`.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Eclipse插件生成Eclipse项目，并执行`gradle eclipse`命令。`eclipse`命令将执行三个任务：`eclipseClasspath`、`eclipseJdt`和`eclipseProject`。
- en: Go to the `\chapter02\java` folder, and you will find a `.classpath` and a `.project`
    file. Open the `.classpath` file and check whether `junit-4.11` and `hamcrest-core-1.3.jar`
    have been added as `classpathentry`.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 进入 `\chapter02\java` 文件夹，你将找到 `.classpath` 和 `.project` 文件。打开 `.classpath` 文件，检查
    `junit-4.11` 和 `hamcrest-core-1.3.jar` 是否已添加为 `classpathentry`。
- en: 'The following screenshot shows the `gradle eclipse` command output:'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了 `gradle eclipse` 命令的输出：
- en: '![The Java plugin](img/00020.jpeg)'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Java 插件](img/00020.jpeg)'
- en: 'The following screenshot shows the content of the generated `.classpath` file:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了生成的 `.classpath` 文件的内容：
- en: '![The Java plugin](img/00021.jpeg)'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Java 插件](img/00021.jpeg)'
- en: Launch Eclipse and import the project by navigating to **File** | **Import**
    | **Existing Projects into Workspace**. Now browse to the `D:\Packt\chapter02\java`
    folder and import the project. Eclipse will open the `java` project—the Java community's
    best practice is to keep the test and source code files under the same package
    but in a different source folder. Java code files are stored under `src/main/java`,
    and test files are stored under `src/test/java`. Source resources are stored under
    `src/main/resources`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Eclipse，通过导航到 **文件** | **导入** | **将现有项目导入工作空间** 来导入项目。现在浏览到 `D:\Packt\chapter02\java`
    文件夹并导入项目。Eclipse 将打开 `java` 项目——Java 社区的最佳实践是将测试和源代码文件放在同一个包下，但不同的源文件夹中。Java 代码文件存储在
    `src/main/java` 下，测试文件存储在 `src/test/java` 下。源资源存储在 `src/main/resources` 下。
- en: We need to create the `src/main/java`, `src/main/resources`, and `src/test/java`
    folders directly under the Java project.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要在 Java 项目的直接下创建 `src/main/java`、`src/main/resources` 和 `src/test/java` 文件夹。
- en: 'The following screenshot displays the folder structure:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了文件夹结构：
- en: '![The Java plugin](img/00022.jpeg)'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Java 插件](img/00022.jpeg)'
- en: Right-click on the leaf folders (the `java` and `resources` folders under `src/main`
    and `src/test`, respectively); a pop-up menu will open. Now, go to **Build Path**
    | **Use as Source Folder**.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击叶文件夹（分别在 `src/main` 和 `src/test` 下的 `java` 和 `resources` 文件夹）；将打开一个弹出菜单。现在，转到
    **构建路径** | **使用为源文件夹**。
- en: 'The following screenshot shows the action:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了该操作：
- en: '![The Java plugin](img/00023.jpeg)'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Java 插件](img/00023.jpeg)'
- en: 'We will create a Java class and unit test the behavior; the Java class will
    read from a properties file and return an `enum` type depending on the value provided
    in the properties file. Reading a file from the test is not recommended as I/O
    operations are unpredictable and slow; your test may fail to read the file and
    take time to slow down the test execution. We can use mock objects to stub the
    file read, but for simplicity, we will add two methods in the service class—one
    will take a `String` argument and return an `enum` type, and the other one will
    read from a properties file and call the first method with the value. From the
    test, we will call the first method with a string. The following are the steps
    to configure the project:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个 Java 类并测试其行为；Java 类将读取属性文件并根据属性文件中提供的值返回一个 `enum` 类型。从测试中读取文件是不推荐的，因为
    I/O 操作是不可预测且缓慢的；你的测试可能无法读取文件，并花费时间减慢测试执行。我们可以使用模拟对象来模拟文件读取，但为了简单起见，我们将在服务类中添加两个方法——一个将接受一个
    `String` 参数并返回一个 `enum` 类型，另一个将读取属性文件并调用第一个方法。从测试中，我们将使用字符串调用第一个方法。以下是为配置项目所需的步骤：
- en: Add an `environment.properties` properties file under `/java/src/main/resources`
    and add `env = DEV` in that file.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/java/src/main/resources` 下添加一个 `environment.properties` 属性文件，并在该文件中添加 `env
    = DEV`。
- en: 'Create an `enum` file in the `com.packt.gradle` package under the `/java/src/main/java`
    source package:'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/java/src/main/java` 源包下的 `com.packt.gradle` 包中创建一个 `enum` 文件：
- en: '[PRE22]'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a Java class to read the properties file as follows:'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Java 类来读取属性文件，如下所示：
- en: '[PRE23]'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a `EnvironmentService` class to return an `enum` type depending on the
    environment setup as follows:'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `EnvironmentService` 类，根据环境设置返回一个 `enum` 类型，如下所示：
- en: '[PRE24]'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `getEnvironmentType()` method calls the `Environment` class to read the
    properties file value and then calls the `getEnvironmentType(String name)` method
    with the read value to return an `enum` type.
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`getEnvironmentType()` 方法调用 `Environment` 类来读取属性文件值，然后使用读取的值调用 `getEnvironmentType(String
    name)` 方法以返回一个 `enum` 类型。'
- en: 'Add a test class under `/src/test/java` in the `com.packt.gradle` package.
    The following is the code:'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `com.packt.gradle` 包下的 `/src/test/java` 中添加一个测试类。以下是其代码：
- en: '[PRE25]'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, the `returns_NULL_when_environment_not_configured()` test passes `xyz`
    to the `getEnvironmentType` method and expects that the service will return `null`,
    assuming that there won't be any `xyz` environment. In another test, it passes
    the `prod` value to the `getEnvironmentType` method and expects that a type will
    be returned.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`returns_NULL_when_environment_not_configured()` 测试将 `xyz` 传递给 `getEnvironmentType`
    方法，并期望服务返回 `null`，假设没有 `xyz` 环境。在另一个测试中，它将 `prod` 值传递给 `getEnvironmentType` 方法，并期望返回一个类型。
- en: Now open the command prompt and run `gradle build`; it will compile the source
    and test files, execute the test, and finally create a JAR file.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开命令提示符并运行 `gradle build`；它将编译源文件和测试文件，执行测试，并最终创建一个 JAR 文件。
- en: To execute only the tests, run `gradle test`.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要仅执行测试，请运行 `gradle test`。
- en: 'Open the `\chapter02\java\build` folder, and you will find three important
    folders:'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打开 `\chapter02\java\build` 文件夹，您将找到三个重要的文件夹：
- en: '`libs`: This folder contains the build output JARs—`Java.jar`'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libs`：此文件夹包含构建输出 JAR 文件—`Java.jar`'
- en: '`reports`: This folder contains the HTML test results'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reports`：此文件夹包含 HTML 测试结果'
- en: '`test-results`: This folder contains the XML format test execution result and
    the time taken to execute each test'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test-results`：此文件夹包含 XML 格式的测试执行结果和每个测试的执行时间'
- en: 'The following screenshot shows the test execution result in the HTML format:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了 HTML 格式的测试执行结果：
- en: '![The Java plugin](img/00024.jpeg)'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Java 插件](img/00024.jpeg)'
- en: 'Gradle is an intelligent build tool, and it supports incremental build. Rerun
    the `gradle build` command. It will just skip the tasks and say `UP-TO-DATE`.
    The following is a screenshot of the incremental build:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 是一个智能构建工具，它支持增量构建。重新运行 `gradle build` 命令。它将跳过任务并显示 `UP-TO-DATE`。以下是一个增量构建的截图：
- en: '![The Java plugin](img/00025.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![Java 插件](img/00025.jpeg)'
- en: 'If we make a change to the test class, only test tasks will be executed. The
    following are the test tasks: `compileTestJava`, `testClasses`, `test`, `check`,
    and `build`.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对测试类进行更改，只有测试任务将被执行。以下是一些测试任务：`compileTestJava`、`testClasses`、`test`、`check`
    和 `build`。
- en: In next chapters, we will explore more on Gradle. Do you want to dive deep now?
    If so, you can visit [http://www.gradle.org/docs/current/userguide/userguide.html](http://www.gradle.org/docs/current/userguide/userguide.html).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨更多关于 Gradle 的内容。你现在想深入了解吗？如果是这样，你可以访问 [http://www.gradle.org/docs/current/userguide/userguide.html](http://www.gradle.org/docs/current/userguide/userguide.html)。
- en: Maven project management
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Maven 项目管理
- en: Maven is a project build tool. Using Maven, we can build a visible, reusable,
    and maintainable project infrastructure.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 是一个项目构建工具。使用 Maven，我们可以构建一个可见的、可重用的和可维护的项目基础设施。
- en: 'Maven provides plugins for visibility: the code quality/best practices is visible
    through the PMD/checkstyle plugin, the XDOC plugin generates project content information,
    the JUnit report plugin makes the failure/success story visible to the team, the
    project activity tracking plugins make the daily activity visible, the change
    log plugin generates the list of changes, and so on.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 提供了用于可见性的插件：代码质量/最佳实践通过 PMD/checkstyle 插件可见，XDOC 插件生成项目内容信息，JUnit 报告插件使团队可见失败/成功故事，项目活动跟踪插件使每日活动可见，变更日志插件生成变更列表，等等。
- en: As a result, a developer knows what APIs or modules are available for use; so,
    he or she doesn't invent the wheel (rather, he or she reuses the existing APIs
    or modules). This reduces the duplication and allows a maintainable system to
    be created.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，开发者知道可以使用哪些 API 或模块；因此，他或她不会重新发明轮子（而是重用现有的 API 或模块）。这减少了重复，并允许创建一个可维护的系统。
- en: In this section, we will explore the Maven architecture and rebuild our Gradle
    project using Maven.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Maven 架构，并使用 Maven 重新构建我们的 Gradle 项目。
- en: Installation
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装
- en: A prerequisite for Maven is the **Java Development Kit** (**JDK**). Make sure
    you have JDK installed on your computer.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 的先决条件是 **Java 开发工具包**（**JDK**）。请确保您的计算机上已安装 JDK。
- en: 'The following are the steps to set up Maven:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下设置 Maven 的步骤：
- en: Download the Maven media. Go to [http://maven.apache.org/download.html](http://maven.apache.org/download.html)
    to get the latest version of Maven.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 Maven 媒体。转到 [http://maven.apache.org/download.html](http://maven.apache.org/download.html)
    获取 Maven 的最新版本。
- en: After downloading Maven, extract the archive to a folder; for example, I extracted
    it to `D:\Software\apache-maven-3.1.1`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 Maven 后，将其存档提取到一个文件夹中；例如，我将其提取到 `D:\Software\apache-maven-3.1.1`。
- en: For Windows OS, create an environment variable named `M2_HOME` and point it
    to the Maven installation folder. Modify the `PATH` variable and append `%M2_HOME%\bin`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 Windows 操作系统，创建一个名为 `M2_HOME` 的环境变量，并将其指向 Maven 安装文件夹。修改 `PATH` 变量，并追加 `%M2_HOME%\bin`。
- en: 'For Linux, we need to export the `PATH` and `M2_HOME` environment variables
    to the `.bashrc` file. Open the `.bashrc` file and edit it with the following
    text:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 Linux，我们需要将 `PATH` 和 `M2_HOME` 环境变量导出到 `.bashrc` 文件。打开 `.bashrc` 文件，并使用以下文本进行编辑：
- en: '[PRE26]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For Mac, the `.bash_login` file needs to be modified with following text:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 Mac，需要修改 `.bash_login` 文件，添加以下文本：
- en: '[PRE27]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Check the installation and execute the `mvn –version` command. This should print
    the Maven version. The following is a screenshot of the output:![Installation](img/00026.jpeg)
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查安装并执行 `mvn –version` 命令。这应该会打印出 Maven 版本。以下是一个输出截图：![安装](img/00026.jpeg)
- en: Maven is installed so we can start exploring Maven. Eclipse users with the `m2eclipse`
    plugin installed already have Maven, which they can directly use from Eclipse
    and they don't have to install Maven.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 已经安装，因此我们可以开始探索 Maven。已经安装了 `m2eclipse` 插件的 Eclipse 用户已经拥有 Maven，他们可以直接在
    Eclipse 中使用 Maven，无需安装 Maven。
- en: The Archetype plugin
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 架构插件
- en: In Maven, Archetype is a project-template generation plugin.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Maven 中，架构是一个项目模板生成插件。
- en: Maven allows us to create a project infrastructure from scratch from a list
    of predefined project types. The Maven command `mvn archetype:generate` generates
    a new project skeleton.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 允许我们从预定义的项目类型列表中从头开始创建项目基础设施。Maven 命令 `mvn archetype:generate` 生成一个新的项目骨架。
- en: The `archetype:generate` command loads a catalog of available project types.
    It tries to connect to the central Maven repository at [http://repo1.maven.org/maven2](http://repo1.maven.org/maven2),
    and downloads the archetype catalog.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`archetype:generate` 命令加载可用的项目类型目录。它尝试连接到 Maven 中央仓库 [http://repo1.maven.org/maven2](http://repo1.maven.org/maven2)，并下载架构目录。'
- en: Tip
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To get the latest catalog, you should be connected to the Internet.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取最新目录，您应该连接到互联网。
- en: 'Follow the ensuing steps to generate a Java project skeleton:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤生成 Java 项目骨架：
- en: Create a folder hierarchy `/Packt/chapter02/maven`, open the command prompt,
    and browse to the `/Packt/chapter02/maven` folder.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件夹层次结构 `/Packt/chapter02/maven`，打开命令提示符，并浏览到 `/Packt/chapter02/maven` 文件夹。
- en: Issue a `mvn archetype:generate` command; you will see a large list of archetypes
    being downloaded, each with a number, a name, and a short description.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发出 `mvn archetype:generate` 命令；您将看到一个大型架构列表正在下载，每个架构都有一个编号、一个名称和简短描述。
- en: It will prompt you to enter an archetype number. Type in the default `maven-archetype-quickstart`
    archetype. In my case, the number is 343.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它将提示您输入架构编号。输入默认的 `maven-archetype-quickstart` 架构。在我的情况下，编号是 343。
- en: 'The following screenshot shows you that the number `343` is default:'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示编号 `343` 是默认值：
- en: '![The Archetype plugin](img/00027.jpeg)'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![架构插件](img/00027.jpeg)'
- en: Tip
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To get the entire catalog on Windows OS, enter the `mvn archetype:generate >
    archetype.txt` command. This will populate the text file with the project type
    list.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在 Windows 操作系统中获取整个目录，请输入 `mvn archetype:generate > archetype.txt` 命令。这将把项目类型列表填充到文本文件中。
- en: Enter `343` or just hit *Enter* to select the default. Next, it will prompt
    you to select a version. Hit *Enter* to select the default.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `343` 或直接按 *Enter* 键选择默认值。接下来，它将提示您选择版本。按 *Enter* 键选择默认值。
- en: Now it will ask you to provide a `groupId`. A `groupId` is the root package
    for multiple projects, and `org.springframework` is the `groupId` for all Spring
    projects. Enter `org.packt` as `groupId`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，它将要求您提供一个 `groupId`。`groupId` 是多个项目的根包，`org.springframework` 是所有 Spring 项目的
    `groupId`。输入 `org.packt` 作为 `groupId`。
- en: Next, it will ask for `artifactId`. This is the project name and `aop` is the
    `artifactId` for `org.springframework.aop-3.1.1.RELEASE`. Enter `Demo` for the
    `artifactId`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它将询问 `artifactId`。这是项目名称，`aop` 是 `org.springframework.aop-3.1.1.RELEASE`
    的 `artifactId`。输入 `Demo` 作为 `artifactId`。
- en: Maven will ask for the version and the default is `1.0-SNAPSHOT`. The version
    is your project's version, and here `3.1.1.RELEASE` is the version for the `org.springframework.aop-3.1.1.RELEASE`
    project. We will accept the default. Hit *Enter* to accept the default.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Maven 将询问版本，默认为 `1.0-SNAPSHOT`。版本是项目的版本，在这里 `3.1.1.RELEASE` 是 `org.springframework.aop-3.1.1.RELEASE`
    项目的版本。我们将接受默认值。按 *Enter* 键接受默认值。
- en: Now you will be prompted to enter the package name. Enter `com.packt.edu` as
    package's name.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将提示您输入包名。输入 `com.packt.edu` 作为包名。
- en: Finally, it will show you what you entered. Review it and accept it as shown
    in the following screenshot:![The Archetype plugin](img/00028.jpeg)
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它将显示您输入的内容。请查看并接受，如下面的截图所示：![架构插件](img/00028.jpeg)
- en: 'Open the `/Packt/chapter02/maven` folder; you will see the `Demo` project folder
    is created with the following file structure:'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打开 `/Packt/chapter02/maven` 文件夹；您将看到创建的 `Demo` 项目文件夹具有以下文件结构：
- en: '![The Archetype plugin](img/00029.jpeg)'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![架构插件](img/00029.jpeg)'
- en: The Maven convention for the source Java file is `src/main/java` and the test
    source file is `src/test/java`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 对于源 Java 文件的约定是 `src/main/java`，而测试源文件是 `src/test/java`。
- en: Maven will automatically create a Java file `App.java` under `src/main/java/com/packt/edu`
    and a test file `AppTest` under `src/test/java/com/packt/edu`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 将自动在 `src/main/java/com/packt/edu` 下创建一个 Java 文件 `App.java`，并在 `src/test/java/com/packt/edu`
    下创建一个测试文件 `AppTest`。
- en: Also, it will create an XML file `pom.xml` directly under `Demo`. This file
    will be used for building the project. In the next section, we will read about
    the POM file.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它将在 `Demo` 下的直接位置创建一个 XML 文件 `pom.xml`。此文件将用于构建项目。在下一节中，我们将了解 POM 文件。
- en: The Project Object Model (POM) file
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目对象模型（POM）文件。
- en: Every Maven project contains a `pom.xml` file, which is a project metadata file.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Maven 项目都包含一个 `pom.xml` 文件，这是一个项目元数据文件。
- en: 'A POM file can contain the following sections:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: POM 文件可以包含以下部分：
- en: Project coordinates such as `<groupId/>`, `<artifactId/>`, `<version/>`, `<dependency>`,
    and inheritance through `<modules/>` and `<parent/>`
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目坐标，如 `<groupId/>`、`<artifactId/>`、`<version/>`、`<dependency>` 以及通过 `<modules/>`
    和 `<parent/>` 的继承。
- en: 'Open the `pom.xml` file in the `Demo` folder; it contains the following coordinate
    details:'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `Demo` 文件夹中打开 `pom.xml` 文件；它包含以下坐标细节：
- en: '[PRE28]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The build details in `<build>` and `<reporting>`
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<build>` 和 `<reporting>` 中的构建细节。'
- en: Project visibility details such as `<name>`, `<organization>`, `<developers>`,
    `<url>`, and `<contributors>`
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目可见性细节，如 `<name>`、`<organization>`、`<developers>`、`<url>` 和 `<contributors>`。
- en: 'Our generated `pom.xml` contains the following details:'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们生成的 `pom.xml` 包含以下细节：
- en: '[PRE29]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Project environment details such as `<scm>`, `<repository>`, and `<mailingList>`
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目环境细节，如 `<scm>`、`<repository>` 和 `<mailingList>`。
- en: Project dependency
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目依赖。
- en: In a multimodule project, a project can depend on many other projects. For example,
    say we depend on JUnit. Maven automatically discovers the required artifact dependencies.
    This is very useful as we depend on many open source projects. It's always useful,
    be it an open source or a close source project.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在多模块项目中，一个项目可以依赖于许多其他项目。例如，假设我们依赖于 JUnit。Maven 会自动发现所需的工件依赖。这对于我们依赖于许多开源项目来说非常有用。无论是开源还是闭源项目，这总是有用的。
- en: Do you remember the Gradle dependency closure? It has four default types for
    Compile, Runtime, testCompile, and testRuntime.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得 Gradle 依赖闭包吗？它有四个默认类型：编译、运行时、测试编译和测试运行时。
- en: 'Similarly, Maven has the following dependency scopes:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，Maven 有以下依赖范围：
- en: '**Compile**: Code compile time classpath dependency; this is the default scope.
    If not, it is explicitly defined and then the compile time scope is set.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译**：代码编译时间类路径依赖；这是默认范围。如果没有明确定义，则设置编译时间范围。'
- en: '**Runtime**: This is required at runtime.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时**：这是运行时所需的。'
- en: '**Test**: This dependency is required for test code compilation and test execution.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：此依赖对于测试代码编译和测试执行是必需的。'
- en: '**Provided**: The JDK or environment dependency at runtime.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供**：运行时所需的 JDK 或环境依赖。'
- en: 'A parent project defines dependencies using the following code snippet:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 父项目使用以下代码片段定义依赖：
- en: '[PRE30]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'All child projects inherit the dependency by just adding the `<dependency>`
    tag as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 所有子项目只需添加 `<dependency>` 标签即可继承依赖，如下所示：
- en: '[PRE31]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The build life cycle
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建生命周期。
- en: The build life cycle clearly defines the process of building and distributing
    a particular project artifact.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 构建生命周期明确定义了构建和分发特定项目工件的过程。
- en: 'Maven has the following three built-in build life cycles:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 有以下三个内置的构建生命周期：
- en: '**Default**: This life cycle handles the compile, test, packaging, deployment,
    and many more functions'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认**：此生命周期处理编译、测试、打包、部署以及更多功能。'
- en: '**Clean**: This life cycle generally cleans the build artifacts generated by
    the previous build(s)'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清理**：此生命周期通常清理由之前的构建（s）生成的构建工件。'
- en: '**Site**: This life cycle takes care of generation and deployment of the project''s
    site documentation'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**站点**：此生命周期负责生成和部署项目的站点文档。'
- en: Now, we will compile and test our `Demo` project.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编译和测试我们的 `Demo` 项目。
- en: In this section, we will work with compile, test, and package targets of the
    default life cycle.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将处理默认生命周期的编译、测试和打包目标。
- en: Compiling the project
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编译项目
- en: 'Perform the following steps to compile the project:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以编译项目：
- en: Open the command prompt and browse to `\Packt\chapter02\maven\Demo`. Maven needs
    a `pom.xml` file to compile a project.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符并浏览到 `\Packt\chapter02\maven\Demo`。Maven 需要一个 `pom.xml` 文件来编译项目。
- en: Type in `mvn compile`; it will compile the project and create class files under
    `\Demo\target\classes`. The following screenshot shows the output:![Compiling
    the project](img/00030.jpeg)
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `mvn compile`；它将编译项目并在 `\Demo\target\classes` 下创建类文件。以下截图显示了输出：![编译项目](img/00030.jpeg)
- en: Testing the project
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试项目
- en: 'To execute the tests in Demo, open the command prompt and type in `mvn test`;
    it will download JUnit JARs and surefire JARs for test compilation and test report
    generation respectively and then execute the test. The following screenshot shows
    the output:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Demo 中执行测试，打开命令提示符并输入 `mvn test`；它将下载 JUnit JARs 和 surefire JARs 分别用于测试编译和测试报告生成，然后执行测试。以下截图显示了输出：
- en: '![Testing the project](img/00031.jpeg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![测试项目](img/00031.jpeg)'
- en: Packaging the project
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 打包项目
- en: The `mvn package` command compiles source code, compiles tests, executes tests,
    and finally builds a JAR. It will generate `Demo-1.0-SNAPSHOT.jar` in `\Packt\chapter02\maven\Demo\target`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`mvn package` 命令编译源代码，编译测试，执行测试，并最终构建一个 JAR 文件。它将在 `\Packt\chapter02\maven\Demo\target`
    下生成 `Demo-1.0-SNAPSHOT.jar`。'
- en: The clean life cycle
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清理生命周期
- en: The `mvn clean` command removes the `target` folder and deletes all the content.
    Run the command and check that the `target` folder has been deleted from `\Packt\chapter02\maven\Demo\`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`mvn clean` 命令会删除 `target` 文件夹并删除所有内容。运行该命令并检查 `\Packt\chapter02\maven\Demo\`
    中的 `target` 文件夹是否已被删除。'
- en: The site life cycle
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网站生命周期
- en: The `mvn site` command generates a detailed project report in the HTML format
    under the target or site. It includes About, Plugin Management, Distribution Management,
    Dependency Information, Source Repository, Mailing Lists, Issue Tracking, Continuous
    Integration, Project Plugins, Project License, Project Team, Project Summary,
    and Dependencies.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`mvn site` 命令在目标或站点下生成详细的 HTML 格式项目报告。它包括关于、插件管理、分发管理、依赖信息、源代码库、邮件列表、问题跟踪、持续集成、项目插件、项目许可、项目团队、项目摘要和依赖项。'
- en: Refer to [http://maven.apache.org/guides/index.html](http://maven.apache.org/guides/index.html)
    to explore more on Maven.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下链接以了解更多关于 Maven 的信息：[http://maven.apache.org/guides/index.html](http://maven.apache.org/guides/index.html)
- en: The next section covers the Apache Ant.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍 Apache Ant。
- en: Another neat tool (Ant)
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另一个整洁的工具（Ant）
- en: Ant is a Java-based build tool from the Apache Software Foundation. Ant's build
    files are written in XML. You need Java to execute an Ant task.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Ant 是 Apache 软件基金会的一个基于 Java 的构建工具。Ant 的构建文件是用 XML 编写的。你需要 Java 来执行 Ant 任务。
- en: Download Apache Ant from [http://ant.apache.org/](http://ant.apache.org/), extract
    the media, and create an `ANT_HOME` variable and set the value to the extracted
    location. Edit `PATH` and append `%ANT_HOME%\bin` in Windows. For Mac or Linux
    OS, you need to export `ANT_HOME` and `PATH` as described in the *Installation*
    section of *Maven project management* earlier in this chapter.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [http://ant.apache.org/](http://ant.apache.org/) 下载 Apache Ant，提取媒体文件，并创建一个
    `ANT_HOME` 变量，将其值设置为提取的位置。在 Windows 中编辑 `PATH` 并追加 `%ANT_HOME%\bin`。对于 Mac 或 Linux
    操作系统，你需要像本章前面提到的 *Maven 项目管理* 部分的 *安装* 部分中描述的那样导出 `ANT_HOME` 和 `PATH`。
- en: Ant needs a `build.xml` file to execute tasks. Ant supports the `–f` option
    to specify a build script; so the `ant –f myBuildFile.xml` command will work.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Ant 需要一个 `build.xml` 文件来执行任务。Ant 支持使用 `–f` 选项来指定构建脚本；因此，`ant –f myBuildFile.xml`
    命令将有效。
- en: 'We will create a build script and execute the Maven project (`\Packt\chapter02\maven\Demo`)
    using Ant. Follow the ensuing steps:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个构建脚本并使用 Ant 执行 Maven 项目 (`\Packt\chapter02\maven\Demo`)。按照以下步骤操作：
- en: Create an XML file `build.xml` in `\Packt\chapter02\maven\Demo`.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `\Packt\chapter02\maven\Demo` 中创建一个 XML 文件 `build.xml`。
- en: 'Add the following lines in the `build.xml` file:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `build.xml` 文件中添加以下行：
- en: '[PRE32]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `<project>` tag is a defined tag in Ant. You can name your project, and
    `Demo` is the name of the project. Next, we will set properties; a property can
    have a name and value or location. Here, `src.dir` is a property name, and this
    property can be accessed from any task using the `${src.dir}` syntax. The `location`
    attribute refers to a relative location from the `build.xml` file. Since `src/main/java`
    contains the source file, we set the location value to `src/main/java`. The other
    two properties, `build.dir` and `dist.dir`, will be used by the Java compiling
    task to compile class files and generate the JAR file.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<project>`标签是Ant中定义的标签。你可以给你的项目命名，`Demo`是这个项目的名称。接下来，我们将设置属性；一个属性可以有一个名称和值或位置。在这里，`src.dir`是一个属性名称，这个属性可以通过`${src.dir}`语法在任何任务中使用。`location`属性指的是从`build.xml`文件开始的相对位置。由于`src/main/java`包含源文件，我们将位置值设置为`src/main/java`。其他两个属性，`build.dir`和`dist.dir`，将由Java编译任务用来编译类文件并生成JAR文件。'
- en: 'Do you remember the clean task in Maven? Ant doesn''t provide default targets.
    We have to define a `clean` target to remove old build outputs, and we will call
    Ant''s `<delete>` command to delete directories. Then, using the `<mkdir>` command,
    we will recreate the directories:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还记得Maven中的clean任务吗？Ant不提供默认目标。我们必须定义一个`clean`目标来删除旧的构建输出，然后我们将使用Ant的`<delete>`命令来删除目录。然后，使用`<mkdir>`命令，我们将重新创建目录：
- en: '[PRE33]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that we added two targets using the `<target>` tag. Each target is identified
    using a name. We will call the `clean` target to delete `build.dir` (generated
    `.class` files) and `dist.dir` (build output JARs).
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们使用`<target>`标签添加了两个目标。每个目标都通过一个名称来标识。我们将调用`clean`目标来删除`build.dir`（生成的`.class`文件）和`dist.dir`（构建输出JAR文件）。
- en: 'Compile task is inbuilt in Gradle/Maven, but Ant doesn''t have any inbuilt
    compile targets; so, we will create a target to compile Java files as follows:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译任务内置于Gradle/Maven中，但Ant没有内置的编译目标；因此，我们将创建一个目标来编译Java文件，如下所示：
- en: '[PRE34]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Use the `<javac>` command to compile Java files. The `<javac>` command accepts
    `srcdir` and `destdir`. Compiler reads Java files from `srcdir` and generates
    class files to `destdir`.
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`<javac>`命令编译Java文件。`<javac>`命令接受`srcdir`和`destdir`。编译器从`srcdir`读取Java文件，并将类文件生成到`destdir`。
- en: A target may depend on another, and `depends` allows us to pass comma-separated
    target names. Here, compile target depends on `clean` and `makedir`.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个目标可能依赖于另一个，`depends`允许我们传递以逗号分隔的目标名称。在这里，编译目标依赖于`clean`和`makedir`。
- en: 'The compilation is done. Now, we will create `jar` from the class files using
    the `<jar>` command as follows:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译已完成。现在，我们将使用`<jar>`命令从类文件创建`jar`，如下所示：
- en: '[PRE35]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `jar` target needs to know the class file's location and destination. The
    `destfile` attribute refers to the destination JAR file name and location and
    `basedir` refers to the class file location. Check whether we used `${dist.dir}\${ant.project.name}.jar`
    to represent the destination JAR file name and folder. Here, `${dist.dir}` refers
    to the destination folder, and `${ant.project.name}.jar` represents the JAR name.
    `${ant.project.name}` is the name (`Demo`) we mentioned in the `<project>` tag.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`jar`目标需要知道类文件的位置和目标位置。`destfile`属性指的是目标JAR文件名和位置，`basedir`指的是类文件位置。检查我们是否使用了`${dist.dir}\${ant.project.name}.jar`来表示目标JAR文件名和文件夹。在这里，`${dist.dir}`指的是目标文件夹，而`${ant.project.name}.jar`代表JAR名称。`${ant.project.name}`是我们之前在`<project>`标签中提到的名称（`Demo`）。'
- en: The Ant script is ready to compile and create a JAR. Open the command prompt,
    go to `\Packt\chapter02\maven\Demo` and issue an `ant jar` command. Here, `jar`
    depends on `compile` and `compile` depends on `clean` and `makedir`. So, the `jar`
    command will create two directories, `bin` and `ant_output`, compile the Java
    file and generate the`.class` file in the bin folder, and finally create a `Demo.jar`
    JAR in the `ant_output` folder.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ant脚本已经准备好编译并创建JAR文件。打开命令提示符，转到`\Packt\chapter02\maven\Demo`，然后执行`ant jar`命令。在这里，`jar`依赖于`compile`，而`compile`依赖于`clean`和`makedir`。因此，`jar`命令将创建两个目录，`bin`和`ant_output`，编译Java文件并在bin文件夹中生成`.class`文件，最后在`ant_output`文件夹中创建`Demo.jar`
    JAR文件。
- en: 'The compilation is done; now, it''s time to execute the tests. Tests need JUnit
    JARs and generated source class files to compile and execute. We have created
    the `lib` directory for Gradle in \`Packt\chapter02\lib` and kept the JUnit 4
    JARs in it. We will use this `lib`. Add three properties for the test source file
    directory, library directory, and test report as follows:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Check whether the `lib.dir` location is relative to the `build.xml` location.
    The `test.dir` attribute points to `src/test/main` and test reports will be generated
    inside `ant_output/report`.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Path allows us to refer to a directory or to a file path. We will define a
    `jclass.path` path to refer to all JAR files under the `lib` directory and generated
    `.class` files as follows:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `<fileset>` tag takes a directory location and `<include>` takes a file
    name or regular expression. The `**/*` value means all the directories and files
    are in `${lib.dir}`. The `pathelement` attribute refers to the `bin` directory
    where the compiled class files are put.
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we need to compile test files. Add a `testcompile` target and use the
    `javac` command. Pass `test.dir` as `srcdir` for compilation. Add `<classpath>`
    to refer the `jclass.path` value. This will compile the test files. Consider the
    following code snippet:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add another target to execute the JUnit test. Ant has a `junit` command to
    run tests. Pass `jclass.path` to point the `lib` directory and generated files
    as follows:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Issue the `ant test` command. This command compiles and executes the tests.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can set a default task in the `build.xml` file in the `<project>` tag. The
    syntax is `<project name="Demo" default="task name" basedir=".">`. Now, we don't
    have to specify a target name.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our Ant script is ready for compiling Java files, executing tests, and generating
    reports. In the next section, we will set up Jenkins and use the build scripts.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: To explore more on how to compile web archives and learn advanced topics, go
    to [http://ant.apache.org/](http://ant.apache.org/).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jenkins is an open source CI tool written in Java. It runs on any web container
    compliant with Servlet Specification 2.4\. The new Apache Tomcat server is an
    example of a web container with which Jenkins can be integrated as a Windows service.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins supports various source control platforms, such as CVS, SVN, Git, Mercurial,
    and ClearCase through the use of plugins.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: It can execute automated builds on Ant and Maven projects. Jenkins is free (MIT
    license) and runs on many operating systems. Jenkins doesn't allow you to create
    a Gradle project, but you can create a free-style project and build Gradle projects.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: To install Jenkins on your local machine, follow the instructions at [https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins](https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Jenkins is installed, we will perform the following steps to configure
    Jenkins:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Launch the Jenkins URL; from the home page go to **Manage Jenkins** | **Configure
    system**.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Jenkins URL；从主页转到 **管理 Jenkins** | **配置系统**。
- en: Now you need to set up the JDK. Go to the **JDK** section, click on **JDK installations**
    and then click on **Add JDK**. Uncheck the **Install automatically** checkbox,
    and enter a **Name** and **JAVA_HOME** path. You can add as many JDKs as you want.
    **Name** and **JAVA_HOME** location uniquely identify the version of JDK. In your
    project, you can refer to the JDK you want to use. The following screenshot shows
    the installation of JDK:![Jenkins](img/00032.jpeg)
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要设置 JDK。转到 **JDK** 部分，点击 **JDK 安装**，然后点击 **添加 JDK**。取消选择 **自动安装** 复选框，并输入一个
    **名称** 和 **JAVA_HOME** 路径。您可以添加任意数量的 JDK。**名称** 和 **JAVA_HOME** 位置唯一标识 JDK 的版本。在您的项目中，您可以引用您想要使用的
    JDK。以下截图显示了 JDK 的安装：![Jenkins](img/00032.jpeg)
- en: Now, set up Maven. Go to the **Maven** section and click on **Maven installations**.
    Now, click on **Add Maven**, uncheck the **Install automatically** checkbox, enter
    a **Name**, and set it to **MAVEN_HOME**.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，设置 Maven。转到 **Maven** 部分，点击 **Maven 安装**。现在，点击 **添加 Maven**，取消选择 **自动安装**
    复选框，输入一个 **名称**，并将其设置为 **MAVEN_HOME**。
- en: 'In general, if the checkbox **Install automatically** is checked, then Jenkins
    will ask you to select a version of the tool and download the version. You can
    install or add multiple versions of the software and just give a unique name.
    For example, you can add a name, `Maven3,` to refer to Maven Version 3.1.1 and
    add `Maven2` to refer to Version 2.2.1\. In your build job, Jenkins will show
    you the list and select the appropriate version you need. The following screenshot
    shows the installation of Maven:'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，如果复选框 **自动安装** 被勾选，那么 Jenkins 将要求您选择工具的版本并下载该版本。您可以安装或添加多个软件版本，只需给出一个独特的名称。例如，您可以添加一个名称，`Maven3,`
    来引用 Maven 版本 3.1.1，并添加 `Maven2` 来引用版本 2.2.1。在您的构建作业中，Jenkins 将显示列表并选择您需要的适当版本。以下截图显示了
    Maven 的安装：
- en: '![Jenkins](img/00033.jpeg)'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Jenkins](img/00033.jpeg)'
- en: Go to the **Ant** section and click on **Ant installations**. Then, click on
    **Add Ant**, uncheck the **Install automatically** checkbox, enter a **Name**,
    and set it to **ANT_HOME**.![Jenkins](img/00034.jpeg)
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 **Ant** 部分，点击 **Ant 安装**。然后，点击 **添加 Ant**，取消选择 **自动安装** 复选框，输入一个 **名称**，并将其设置为
    **ANT_HOME**。![Jenkins](img/00034.jpeg)
- en: Our basic configuration is complete. Next, we will start building a Java project
    using Gradle.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本配置已完成。接下来，我们将开始使用 Gradle 构建一个 Java 项目。
- en: The Gradle project
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gradle 项目
- en: 'Jenkins doesn''t come with Gradle. You need to install a plugin as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 不自带 Gradle。您需要按照以下步骤安装插件：
- en: Launch the Jenkins URL; from the home page, go to **Manage Jenkins** | **Manage
    Plugins**. Go to the **Available** tab; in the **Filter** textbox (located at
    the right top corner of the page), enter `gradle`. It will bring you **Gradle
    Plugin**. Check the checkbox associated with **Gradle Plugin** and click on **Install
    without restart**.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Jenkins URL；从主页转到 **管理 Jenkins** | **管理插件**。转到 **可用** 选项卡；在页面右上角的 **过滤器**
    文本框中，输入 `gradle`。这将带您到 **Gradle 插件**。勾选与 **Gradle 插件** 相关的复选框，然后点击 **不重启安装**。
- en: 'This will install the **Gradle plugin**. Jenkins will show you the progress
    of installation. Once the installation is over, you need to configure Gradle,
    like we did for Ant and Maven. Refer to the following screenshot to install **Gradle
    plugin**:'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将安装 **Gradle 插件**。Jenkins 将显示安装进度。安装完成后，您需要配置 Gradle，就像我们对 Ant 和 Maven 所做的那样。参考以下截图来安装
    **Gradle 插件**：
- en: '![The Gradle project](img/00035.jpeg)'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Gradle 项目](img/00035.jpeg)'
- en: From the home page, go to **Manage Jenkins** | **Configure System**. Scroll
    down to the **Gradle** section and click on Gradle installation. Then, click on
    **Add Gradle**, uncheck the **Install automatically** checkbox, enter a **Name**,
    and set **GRADLE_HOME**.![The Gradle project](img/00036.jpeg)
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主页转到 **管理 Jenkins** | **配置系统**。滚动到 **Gradle** 部分，点击 Gradle 安装。然后，点击 **添加 Gradle**，取消选择
    **自动安装** 复选框，输入一个 **名称**，并将 **GRADLE_HOME** 设置好。![Gradle 项目](img/00036.jpeg)
- en: Go back to the home page. The Jenkins convention for project building is **job**.
    A job runs continuously, invokes scripts, and gives feedback. To set up an automated
    build process, the user has to configure a job. Click on the **create new jobs**
    hyperlink to add a new project type. Jenkins supports several types of build jobs.
    Two most commonly used jobs are the free-style builds and the Maven 2/3 builds.
    The free-style projects allow you to configure any sort of build job; this job
    type is highly flexible and configurable. However, you can install plugins for
    other types.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot displays how to create a `gradleProject` free-style
    job:'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![The Gradle project](img/00037.jpeg)'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The free-style project has several settings. In **Advance Project Options**,
    you can set **Quiet period** (time to wait after a build), **Retry Count** (number
    of attempts to checkout from the repository), and so on. In **Source Code Management**,
    you can choose a version control tool type. Version control is one of the most
    important things in CI. It keeps track of software versions, we can revert our
    changes at any point in time, look at file history, and much more. By default,
    Jenkins comes with the source code management tool plugins, CVS and SVN, but we
    can install plugins to support other types, such as Git and Rational ClearCase.
    We didn't configure any version control tool yet; so, choose **None,** as shown
    in the following screenshot:![The Gradle project](img/00038.jpeg)
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next is the **Build Trigger** event, and the build trigger knows when to start
    a job. There are several types:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Build after other projects are built**: This implies that the job will be
    invoked after another job'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build periodically**: This signifies the periodic schedule for cron expressions,
    that is, every 5 minutes or every 30 minutes and so on'
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Poll SCM**: This implies polling the version control location after a specific
    time set in the **Schedule** option'
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We don''t have other jobs or a version control tool, so choose **Build periodically**
    and set **Schedule** to **H/5****** to execute the build every 5 minutes, as shown
    in the following screenshot:'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![The Gradle project](img/00039.jpeg)'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The next section is **Build**. You can add several steps to a build. Click on
    **Add build step**. It will show you a step; choose **Invoke Gradle script** to
    call our Gradle project, as shown in the following screenshot:![The Gradle project](img/00040.jpeg)
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now click on the **Invoke Gradle** radio button and choose the Gradle version
    we added. In the **Tasks** field, enter `build` to invoke the build task; you
    can add multiple tasks here. In the **Build File** field, enter the full path
    of your Gradle build file `\Packt\chapter02\java\build.gradle`, as shown in the
    following screenshot:![The Gradle project](img/00041.jpeg)
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now click on **Save**. Jenkins will take you to the project's home page. Click
    on the **Build Now** hyperlink. It will start building our first project. It will
    show you a build history table with a build number, such as **#1 Feb 4\. 2014
    09:18:45 PM**. Click on the **build#** hyperlink and then click on **Console Output**.
    It will show you the build log. The following screenshot shows our Gradle build
    log:![The Gradle project](img/00042.jpeg)
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now go back to the home page; it shows you the list of all builds and their
    status. It has a weather column—when all builds are failing, the weather shows
    a cloudy image, and when all builds are passing, the weather becomes sunny. You
    can invoke a build by clicking on the wheel symbol to the right of each build
    row. Refer to the following screenshot:![The Gradle project](img/00043.jpeg)
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our Gradle build configuration is complete. Automatically, after every five
    minutes, the build will be kicked off. We can configure a post build action to
    send an e-mail after each build. That way, if a build fails, then immediately
    a mail will be sent, and the concerned person can take care of the issue. So,
    the feedback cycle is faster.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will configure a Maven job.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: The Maven project
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will configure Jenkins to execute a Maven build job. Please
    perform the following steps:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **New Job** hyperlink to add a new project type. Select **Build
    a maven2/3 project** and enter a job name, as shown in the following screenshot:![The
    Maven project](img/00044.jpeg)
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the details page, choose **Source Code Management** as **None**, **Build
    Triggers** as **Build periodically**, and set **H/5****** to execute the build
    in every 5 minutes.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go to the **Build** section and set the **Root POM** value; set the full
    file path location of your `pom.xml` file in the `Demo` project. You can leave
    the **Goals and options** section blank. Gradle will issue the default `mvn install`
    command. Refer to the following screenshot:![The Maven project](img/00045.jpeg)
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now click on **Save**. Jenkins will take you to the project''s home page. Click
    on the **Build Now** hyperlink and it will start building our first project. It
    will show you a build history table with a build number such as **#1 Feb 4\. 2014
    09:18:45 PM**. Click on the **build#** hyperlink and then click on **Console Output**.
    It will show you the following build log:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Check whether Jenkins issued the `mvn install` command, created the JAR, and
    installed the artifacts in the `.m2` repository.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building the Ant project
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will set up a free-style software project to build using Ant. The following
    are the steps:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Open the Jenkins URL, click on **New Job,** and select **Build a free-style
    software project**. Enter the name, `ant,` and then click on **Ok**.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don't have source code management, so skip this section. Go to **Build Triggers**
    and set the **H/5 * * * *** value to kick off build automatically in every 5 minutes.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Build** section and add a **Invoke Ant** build step, as shown in
    the following screenshot:![Building the Ant project](img/00046.jpeg)
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select an Ant version from the dropdown, set `jar` as **Targets**; `jar` will
    invoke test and compile. In **Build File**, browse to our `build.xml` file location
    and set the value, as shown in the following screenshot:![Building the Ant project](img/00047.jpeg)
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the setting and the new job will be saved. Click on **Build Now**. It will
    start building the `Demo` project we created earlier in this chapter. The following
    is a screenshot of **Console Output**:![Building the Ant project](img/00048.jpeg)
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can read about securing Jenkins, the post-build action, broken build claim
    plugins, and the CI game from the Jenkins wiki at [http://jenkins-ci.org/](http://jenkins-ci.org/).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered the concept of CI, explored the build automation tools,
    and configured Jenkins to accomplish the CI.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: The Gradle section covered the environment setup, Gradle tasks, daemons, dependency
    management, repository setup, Eclipse/Java plugins, and gradually explored the
    Gradle features. The Maven part demonstrated how to set up Maven, described the
    POM file, project dependency, and explored the default, clean, and site life cycles.
    The Ant section described how to write the Ant script to compile and execute JUnit
    tests. Jenkins covered the build automation setup as well as automated build using
    Gradle, Maven, and Ant.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: By now, the reader will be able to write build scripts using Gradle, Maven,
    and Ant and configure Jenkins to execute the build scripts.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter provides an overview of test doubles and different test double
    types with examples, and includes topics such as dummy, stub, mock, spy, and fake.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
