- en: 14\. HTTP with Ring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will process requests and generate responses, route incoming
    requests and manipulate requests via middleware. We will also serve up responses
    using various content types including **JavaScript Object Notation** (**JSON**)
    and **Extensible Data Notation** (**EDN**), create a web application using Ring
    and Compojure, and serve static resources via HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to expose CRUD operations via HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we built our application layer and interacted with it via
    the REPL. This works sufficiently well for a single user performing ad hoc interactions,
    but it does not scale. Indeed, we could imagine a scenario where a third party
    or even another of our own services wants to make use of the data stored in our
    database, perform calculations, and persist updates. This interaction would be
    programmatic and would, therefore, benefit from being exposed over **HyperText
    Transfer Protocol** (**HTTP**) or similar.
  prefs: []
  type: TYPE_NORMAL
- en: We can achieve this by exposing our application layer via a web service. A web
    service allows interaction with our application layer over a network (most typically
    the internet, although it could be over an intranet for private applications).
  prefs: []
  type: TYPE_NORMAL
- en: To build our web service, we'll need a web application library to build our
    API, a web server to serve it up over HTTP, and a routing library to route incoming
    requests to the appropriate handler. Clojure has numerous implementations of each;
    however, for this chapter, we'll focus on using `Compojure` for routing, and Jetty
    to serve it all up.
  prefs: []
  type: TYPE_NORMAL
- en: An extension to this chapter could involve you taking the examples and exercises
    provided and implementing them using an alternative web app library, such as `Pedestal`.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP, Web Servers, and REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into building a web service, let's cover the basics. HTTP is
    one of the primary protocols for communicating across the internet, particularly
    when working in a web browser. This protocol provides a contract for a client
    (typically a web browser) to communicate with a (web) server. In this example,
    the browser will construct a request containing a Uniform Resource Identifier
    (URI), which it will use to communicate to the server. The server will interpret
    the request, using the URI string to determine which resource the client is interested
    in retrieving/manipulating, then constructing a response containing information
    indicating that the request has completed, or containing a payload in the form
    of the response body.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, when building a web service, we want to conform to the **REpresentational
    State Transfer** (**REST**) architecture. This architecture prescribes a set of
    operations we can choose to perform against a resource, allowing us to transition
    that resource through a number of valid states.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s assume we''re interacting with our profile on our favorite
    online retailer''s website. First, we''ll retrieve our profile, then perhaps we''ll
    retrieve our current address. We''ll make a change to this address, then save
    our changes. In terms of REST interactions over HTTP, this may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: GET [https://packt.live/30NL9hm](https://packt.live/30NL9hm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GET [https://packt.live/2U026Ur](https://packt.live/2U026Ur)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PUT [https://packt.live/2U026Ur](https://packt.live/2U026Ur)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`123` in the preceding example is our unique user ID.'
  prefs: []
  type: TYPE_NORMAL
- en: The GET/PUT method preceding the URI is known as the HTTP method. GET indicates
    that we wish to read the content associated with the resource in the URI provided.
    The PUT method has an associated body containing the updated address; we're instructing
    the server to create/update the address resource with that provided.
  prefs: []
  type: TYPE_NORMAL
- en: An important distinction to make between PUT and POST is that PUT should be
    used when updating an existing resource or when we happen to know the unique ID
    of the entity we're creating. POST is used solely for the creation of resources
    and does not require us to know its unique ID. Instead, this ID will be allocated
    by the web service itself and communicated back to the client via the response
    headers.
  prefs: []
  type: TYPE_NORMAL
- en: The full set of supported methods are GET, POST, PUT, DELETE, HEAD, PATCH, CONNECT,
    OPTIONS, and TRACE. The first four of which are most typically encountered.
  prefs: []
  type: TYPE_NORMAL
- en: Request and Response
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For those completely new to building web services, we will be covering a number
    of new concepts. These are not necessarily complex subjects, but sufficient detail
    to understand each of the building blocks will be given. As mentioned previously,
    we will use Ring (Clojure''s most widely used web application library) to build
    our web service. A Ring application consists of only four components: requests,
    handlers, responses, and middleware.'
  prefs: []
  type: TYPE_NORMAL
- en: We understand the concept of a request and response; we'll now cover them in
    detail, including how to parse the former and how to construct the latter, as
    well as the form that each typically takes.
  prefs: []
  type: TYPE_NORMAL
- en: In the most simple terms, the function of our web service should be to take
    an incoming request represented as a map, perform some operations based on the
    content of that map (for example, fetch a user's profile or update their address),
    and produce an appropriate response map ready to be rendered by a browser or interpreted
    by the client more generally. In Ring, the function that performs this conversion
    of a request to a response is referred to as a handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most basic operation would follow this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1: Representation of the request-response process'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_14_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.1: Representation of the request-response process'
  prefs: []
  type: TYPE_NORMAL
- en: 'A Ring handler is, therefore, a single-arity function, accepting a `request`
    map, and returning a `response` map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'What does a `request` map look like? At a minimum, a `request` map will contain
    the following top-level keys (sample values included):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the meaning of each attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '`:remote-addr`: The calling client''s IP address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:headers`: Additional information sent along with the request, relating to
    security, content negotiation, cookies, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:server-port`: The port of the server servicing the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:uri`: The URI pointing to the resource the client wishes to interact with
    (used in routing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:query-string`: A string that can be used to filter the resource content returned'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:body`: A stream containing an optional payload (can only be read once!)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:request-method`: An HTTP request method (used in routing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An important point worth highlighting is that this list is *not exhaustive*.
    Third-party and custom middleware can often add their own keys with their own
    special meaning and uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the point at which our handler is invoked, the `request` map contains only
    a couple of keys of interest: the `query-string` and the `body`. The remaining
    keys have already been inspected and used to route the request to the appropriate
    handler, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Response` maps are much simpler and will consist of only three keys: status,
    headers, and body. The `status` key is a three-digit number indicating the outcome
    of the request. There are a large number of these, grouped into five different
    categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '1xx: Informational'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2xx: Success'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3xx: Redirect'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '4xx: Client Error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '5xx: Server Error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, we'll encounter a `200` status indicating `OK`, or perhaps a `404`
    "`Not Found`" or `500` "`Internal Server Error`" error message.
  prefs: []
  type: TYPE_NORMAL
- en: The headers provide additional information about the generated response â€“ most
    commonly, how to interpret the body. The body (sometimes called the payload) will
    contain any data retrieved or generated that will be of interest to the client.
  prefs: []
  type: TYPE_NORMAL
- en: We can easily construct this response map manually, as we'll see in *Exercise
    14.01*, *Creating a Hello World Web Application.*
  prefs: []
  type: TYPE_NORMAL
- en: We've now encountered three of the four Ring components (with middleware being
    more complex and covered separately).
  prefs: []
  type: TYPE_NORMAL
- en: Jetty is the web server that will serve up our Ring application. It is software
    that allows interaction with our application over a network, in the same way your
    favorite websites are made available over the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.01: Creating a Hello World Web Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This exercise will see us make use of Ring and Jetty, where we''ll create a
    trivial web application with a static `Hello World` response:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin with the following dependencies in `deps.edn` or similar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now define our Ring handler, remembering it''s a single-arity function accepting
    a `request` map and returning a `response` map. Our `response` map contains an
    `ok` `200` status code and a string response in the `body`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we''ll start a Jetty web server, passing our handler and a couple of options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By default, Jetty will spin up on port 80; we've overridden that to use `8080`.
    Notice that we've also passed :join? false. This ensures that our web server will
    not block the current thread that the REPL is running on, meaning we can interact
    with it and perform other REPL-based operations in the meantime. We now have a
    web server running, exposing our single handler over HTTP.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can stop the currently running server using Java interop:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`user=> (.stop app)`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`=> nil`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If, at any point, an error such as `Address already in use` is encountered,
    be sure to stop your existing app before starting a new one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This will prove useful going forward as we make changes to our application and
    test them out in the browser. If you have stopped the app, be sure to restart
    it by rerunning *Step 3* before proceeding.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Navigate to localhost:8080 in a browser:![Figure 14.2: Printing Hello Word
    in a browser'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14502_14_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.2: Printing Hello Word in a browser'
  prefs: []
  type: TYPE_NORMAL
- en: Success! We have created our first handler and our web server is up and running
    with only a few lines of code. Be sure to stop our running app.
  prefs: []
  type: TYPE_NORMAL
- en: Request Routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, notice that run-jetty only accepts a single handler.
    We'll more than likely want our service to provide the ability to store, view,
    and otherwise manipulate numerous resources. For this, we'll need to support an
    arbitrary number of handlers to cater to each of our resources, plus a means of
    finding the correct handler to service our request. This is where request routing
    comes in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Revisiting the request object, we find that it contains (among other things)
    the following keys:'
  prefs: []
  type: TYPE_NORMAL
- en: URI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request-method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could enhance our handler to inspect the incoming request, extract the content
    of those keys, then determine the appropriate function to call to satisfy the
    request and generate a response. We'd probably call this handler our dispatcher
    or router. As we consider this approach, we should recall the chapter introduction
    where we mentioned Compojure, which bills itself as a small routing library for
    Ring that allows web applications to be composed of small, independent parts.
  prefs: []
  type: TYPE_NORMAL
- en: That's exactly what we're looking for. We'll now learn how to make use of `Compojure`
    to perform request routing and expand our application a little further.
  prefs: []
  type: TYPE_NORMAL
- en: Using Compojure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If routing requests manually sounded fairly tedious, breathe a sigh of relief
    as Compojure takes all the strain out of request routing. We define pairs of HTTP
    methods and resource paths we want to match and Compojure takes care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'A trivial route method is defined as follows, using the GET macro from the
    compojure.core namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: GET (and all other HTTP method macros) expect a path representing the resource
    we want to match against. In the preceding example, we match the hello path at
    the root of the web service. Compojure gives us a great deal of control over the
    path, allowing us to expect path parameters or match using a regular expression
    if we need to.
  prefs: []
  type: TYPE_NORMAL
- en: The next argument to the macro actually binds the incoming request map (or parts
    thereof) to the local symbol(s) we specify. In the preceding example, the entire
    incoming request map has been bound to the `request` symbol. We can choose to
    destructure elements of the map if we so wish.
  prefs: []
  type: TYPE_NORMAL
- en: The final argument to the macro is the body of our route. Here, we can add any
    logic we require, with the final expression being returned as the response. In
    this case, we simply return the string Hello world. Compojure will interpret a
    plain string as an implicit 200 response (that is, success) meaning we don't need
    to construct a map with an explicit :status key as we did in *Exercise 14.01*,
    *Creating a Hello World Web Application*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''re likely to have more than a single route in our application, but
    Jetty only accepts a single handler. We can now reach for the `routes` function
    or the defroutes macro provided by Compojure; either of these can be used to combine
    one or more routes into a single handler. Using the macro, we bring our routes
    together, binding them to the `routes` variable, which we can then pass to Jetty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'What if a user navigates to a route that we have not defined? When we define
    the routes and their unique paths, we''re asking the routing library to inspect
    the incoming request and attempt to match it to each of our routes in turn. If
    this list of routes is exhausted before finding a match, an exception is thrown.
    In a browser, we''ll receive the following (not particularly useful!) error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3: Page not working error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_14_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.3: Page not working error'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can avoid this by providing a catch-all, ensuring this is the *last* route
    defined. Compojure offers us a not-found route, which we can incorporate into
    our routes definition. It allows us to gracefully handle a request for a resource
    we cannot find a match for. The inclusion of this `not-found` route would look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 14.02: Introducing Routing with Compojure'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s begin by tweaking our `Hello World` application by replacing the handler
    with a Compojure route definition:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `compojure` dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Taking our original hello world handler, we''ll convert this to the `compojure`
    route definition format using the `GET` macro from `compojure.core`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will look as follows if we use Compojure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace `handler` with `route` in our call to `run-jetty`, start the app (stopping
    any existing apps first!), and point your browser to `localhost:8080` once again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.4: Printing the output to the browser'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_14_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.4: Printing the output to the browser'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There will be no material change; however, we have paved the way for rolling
    out Compojure and supporting an arbitrary number of routes in our application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s define multiple routes, combining them under a single handler to exercise
    Compojure''s routing ability:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pass these routes to our `run-jetty` call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now navigate to each of our routes in turn via the browser. Browse to
    our first route, `http://localhost:8080/route-1`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.5: Browsing to the first route'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_14_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.5: Browsing to the first route'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Browse to our second route, `http://localhost:8080/route-2`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.6: Browsing to the second route'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_14_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.6: Browsing to the second route'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'While we''re here, let''s attempt to navigate to a non-existent route, `localhost:8080/nothing-to-see-here`.
    Your browser should inform you of localhost''s inability to service this request,
    possibly indicating a `500` error:![Figure: 14.7: Browsing to a non-existent route'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14502_14_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure: 14.7: Browsing to a non-existent route'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Recalling our discussion of Compojure''s `not-found` route definition, let''s
    introduce that as a fallback for cases where no other route matches our request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Restarting our web server and again browsing to `http://localhost:8080/nothing-to-see-here`,
    we now receive a much friendlier message:![Figure 14.8: Navigating to nothing-to-see-here
    again'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14502_14_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.8: Navigating to nothing-to-see-here again'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, let''s (temporarily) move our `not-found` route to the beginning of
    our routes definition, restart the app, and browse to `http://localhost:8080/route-1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.9: Navigating to route-1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_14_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.9: Navigating to route-1'
  prefs: []
  type: TYPE_NORMAL
- en: This demonstrates the care required when defining and combining multiple routes.
    The web server will serve up the response for the *first* matching route it encounters.
    We can think of this as a simple order of precedence, with routes earlier in the
    definition being preferred over those following.
  prefs: []
  type: TYPE_NORMAL
- en: Excellent â€“ we now understand how to define a route using Compojure, combine
    it with other Compojure route definitions, and provide a sensible not-found message
    in the event that someone navigates to a non-existent resource.
  prefs: []
  type: TYPE_NORMAL
- en: Response Formats and Middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding trivial route definitions have all returned a string as the response
    body, which is perfectly acceptable for a human interacting with our service via
    a web browser. When we start to have other web services or a frontend interacting
    with our service, we may well have to serve up alternative response formats. A
    JavaScript frontend is likely to want a JSON response, whereas a ClojureScript
    frontend would likely prefer EDN. EDN is a data format favored in the Clojure
    ecosystem; indeed, Clojure itself is written in this format, meaning you will
    already be familiar with it by this stage!
  prefs: []
  type: TYPE_NORMAL
- en: The client can indicate which formats it accepts by providing an accept header
    as part of the request. The `accept` header takes the form of a string describing
    the `application/json` and `application/edn`. The server can inspect this header
    and render the response in accordance with the formats accepted by the client.
    The server will assist the client by returning a `content-type` header in the
    response indicating which format it has selected.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The client is in no way obligated to return data in the format requested but
    should do so if it is able.
  prefs: []
  type: TYPE_NORMAL
- en: Intuitively, we may be tempted to inspect the accept header manually within
    each of our routes and encode the response before we return it. While this would
    work, it would introduce a great deal of duplicative code into our application
    and distract from the core work of the route itself.Â Â For example, we may have
    a `render-response` function that determines which format to render based on the
    `accept` header. We would be obligated to include this call in every one of our
    routes. Much more preferable would be the ability to define this once and have
    it applied across all of our routes.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the concept of middleware comes in. In simple terms, middleware
    is a function that wraps our route, allowing us to execute code before and/or
    after generating our response.
  prefs: []
  type: TYPE_NORMAL
- en: 'A middleware function for a synchronous response (that is, where the client
    will wait for the response using the same connection) typically takes the following
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In essence, it is a function that accepts a handler, then returns a new function
    that calls the original handler. Besides that requirement, it is free to manipulate
    the request before passing it to the handler call, or it could manipulate the
    response generated by calling the handler, or both.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should now be obvious that we could define a piece of middleware to handle
    the response rendering. Before we do that, let''s take a look at `muuntaja`, which
    has been written specifically with this task in mind. Indeed, it supports JSON
    and EDN out of the box simply by wrapping our handler in a call to `muuntaja.middleware/wrap-format`.
    For example, the following tweak to our `run` function would automatically negotiate
    the incoming request body and outgoing response body formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 14.03: Response Rendering with Muuntaja'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we'll cover middleware and how it can be used to render a
    response by taking the `accept` header into consideration. Our goal is to respect
    the `accept` header provided by the caller such that we can return JSON, EDN,
    or a plain string as required. We'll also look at how to interact with our route
    using `curl`, a popular tool used to make calls to web services.
  prefs: []
  type: TYPE_NORMAL
- en: 'By leveraging `muuntaja middleware`, our route code can remain completely agnostic
    of the response format requested by the client:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin by introducing the muuntaja dependency and requiring it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let''s define a new set of routes, one of which returns a string, and another
    returning a nested data structure that can vary depending on the value of the
    `accept` header passed by the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Out of the box, Compojure does not know how to render a map, regardless of whether
    an accept header is specified.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Of interest will be how the middleware handles the keywords and sets depending
    on the response format we're interested in.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Recall that middleware wraps a handler; therefore, introducing `wrap-format`
    middleware of muuntaja is as simple as altering our `run` function like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now restart our app and request our `string` resource by expressing no preference
    for the response format, then stipulating we''d prefer `application/edn`. We''re
    using `curl` here via Terminal or Command Prompt depending on your operating system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.10: Printing the output of the curl command'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_14_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.11: Printing the output of the curl command'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_14_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.11: Printing the output of the curl command'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice the response format is identical in both cases, which can be confirmed
    by checking the preceding `content-type` header. This shows that our server is
    unable to render the response as `EDN` and has chosen to ignore the `accept` header
    directive.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our `data-structure` route is a little more interesting. Let''s submit three
    different requests and compare them. Here''s the first request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.12: Output of the first request'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_14_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.12: Output of the first request'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the second request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.13: Output of the second request'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_14_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.13: Output of the second request'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the third request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.14: Output of the third request'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_14_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.14: Output of the third request'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, omitting the `accept` header gives us a JSON response by default.
    Requests for JSON and EDN are respected.
  prefs: []
  type: TYPE_NORMAL
- en: This demonstrates how remarkably simple (and powerful) content negotiation can
    be using middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Handling a Request Body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have implemented a number of straightforward `GET` operations serving
    up static responses. Thinking back to our `GET` method is how we read data. When
    creating (`PUT`/`POST`) or updating (`PUT`), we should provide a body along with
    our request. This body is the entity we wish to create or update.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A `body` can be provided along with a `GET` request; however, this is uncommon
    and the content of the body should *not* have any material impact on the value
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: The body, particularly when storing an entity, will often take the form of a
    map. The map could, therefore, be provided as JSON or EDN and should be parsed
    accordingly. The code we write as part of our route is again agnostic of the incoming
    format since the middleware will handle the formatting for us and provide an EDN
    representation for us to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.04: Working with a request Body'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll learn how the `wrap-formats` middleware is applied
    to the incoming request body, not just the outgoing response body. We''ll also
    learn which part of the request will contain the content of the body, how to implement
    a quick in-memory database, and how to interact with a route via `clj-http` (a
    Clojure HTTP client library) rather than `curl`. We''ll use this knowledge to
    perform basic CRUD operations on our in-memory database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s introduce `clj-http` as a dependency, to demonstrate a native Clojure
    means of interacting with our web server. We''ll also need a means of constructing
    a JSON payload, hence the inclusion of `clojure.data.json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll define an atom to act as a cheap in-memory database for our server.
    Our `GET`, `PUT`, and `DELETE` routes will then use it as storage to demonstrate
    working with a `request` body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our `GET` method will read the value associated with the `:data` key; our `PUT`
    method will store the content of the `:body-params` key in our incoming request
    under the `:data` key in our atom, allowing us to roundtrip the data structure.
    Finally, our `DELETE` will remove the structure we have stored.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our `run` function remains unchanged since `muuntaja` `wrap-format` works for
    both the incoming request body and the outgoing response body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After restarting our server, use `clj-http` to persist a JSON data structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The request body *must* be a string, hence our `json/write-str` call against
    our Clojure data structure. We must also provide a `content-type` header to aid
    our web service in formatting the incoming data correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now retrieve the persisted data in EDN format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice that we attempted to persist a set as part of our payload; however,
    it has been returned as a vector. This is an important point to note: JSON to
    EDN conversion leads to a loss of data. This is due to EDN having more built-in
    type support than JSON (for example, sets and keywords).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is particularly dangerous if we have several clients interacting with our
    service; one that persists/consumes JSON and another that persists/consumes EDN.
    There is a workaround where we can define a schema and coerce the incoming request
    body.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`wrap-format` *does* coerce string keys to keywords as we saw in the preceding
    steps.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s confirm our EDN persistence and the retrieval behaves as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''re now done with our `data-structure` resource; let''s delete it from the
    server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding `200` status indicates that the deletion was successful; we can
    confirm this by attempting one more retrieval:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We receive a `404` exception, since the resource is `not found`, as we expected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Great â€“ we have learned that the `wrap-format` middleware will assist us in
    formatting JSON and EDN request bodies as well as response bodies as we noted
    earlier. We know that the request body will be consumed by the `wrap-format` middleware
    and the EDN-formatted result placed in the `body-params` of the incoming request.
    We have also picked up a few tips on interacting with a Clojure service using
    `clj-http`.
  prefs: []
  type: TYPE_NORMAL
- en: Static Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the early days of the internet, web servers were used to serve up static
    HTML pages and images. Although technology has progressed a great deal since then,
    serving up static resources is still very much a requirement of today's web servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thinking back to our CSV file of tennis matches from *Chapter 5*, *Many to
    One: Reducing*, we may wish to make this available to download via our web service.'
  prefs: []
  type: TYPE_NORMAL
- en: '`compojure.route`, which we previously used to provide a `not-found` route,
    also provides a means of easily serving static files from a custom location on
    disk. `compojure.route/files` accepts a path where the files will be exposed as
    well as an options map where we can override the directory that our files are
    served from.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code would allow us to access any files located under the `/home/<user>/packt-http/resources/`
    directory by browsing to our web server''s `/files/<filename>` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 14.05: Serving Static Files'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll make several files available via our web service,
    observing how the file-type determines the response of the web browser. We''ll
    create a text file with the `.txt` file extension and see the contents displayed
    in our browser. We''ll then see how requesting a CSV file results in the file
    being downloaded to our local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `resources` subdirectory containing a text file named `sample.txt`
    with the content `This is only a sample`, along with the `match_scores_1991-2016_unindexed_csv.csv`
    file we are familiar with from [https://packt.live/2NT96hM](https://packt.live/2NT96hM).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we''ll use the `compojure.route/files` function to serve these up behind
    a `files` route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Restart the web server, then browse to `http://localhost:8080/files/sample.txt`,
    expecting an output similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.15: Output of the sample.txt file'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_14_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.15: Output of the sample.txt file'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now browse to `http://localhost:8080/files/match_scores_1991-2016_unindexed_csv.csv`,
    expecting the file to be downloaded as follows:![Figure 14.16: Downloading the
    CSV file'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14502_14_16.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.16: Downloading the CSV file'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The browser has inspected the `content-type` header in the response headers;
    in the `sample.txt` case, it is reported as `text/plain` and is rendered in the
    browser. In the CSV case, the `content-type` header is reported as `text/csv`,
    which generally is not rendered and is instead downloaded to disk. It may, however,
    be opened by spreadsheet software depending on your default application launch
    settings in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: Excellent! We have seen how straightforward it is to expose local files via
    our web service for display or download.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with an Application Layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall the Activity Tracker database from *Activity 13.01*, *Persisting Historic
    Tennis Results and ELO Calculations*, of *Chapter 13*, *Database Interaction and
    the Application Layer*, and how it was mentioned that we could envisage a web
    service sitting on top of the application layer. Our public functions in each
    of our namespaces were candidates for exposing over HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that what we're exposing over REST is access to read or manipulate a
    given resource. Considering our `users` and `activities` as resources, we may
    want to retrieve all of our `users` resources, all of our `activities` resources,
    a single user by ID, or all activities for a given user. We start by constructing
    the paths that we would navigate to reach each intended resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the `users` resource. This is the collection of all users in
    the system and is sensibly located at the `/users` path. In terms of the route
    we''d create, our starting point would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now, to access a single user within that collection, we'd require some means
    of keying into the `users` resource. Since we have defined an `ID` field associated
    with our `users` resource, we can uniquely identify a given user by their ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'As such, we could envisage our `user-by-id` route looking very similar to the
    preceding route, with an additional parameter being passed. Our options for parameters
    are path parameters or query parameters. The distinction between the two being
    that `path` parameters are used when they uniquely identify a resource within
    a collection; `query` parameters are used to filter a resource by a property.
    As examples, we could have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the first instance, we're requesting a single user having ID 123\. In the
    latter, we're filtering our `users` collection down to those whose first name
    is `David`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this knowledge in mind, we can take our public API and map each function
    to a `path` parameter where we''ll expose it in our web service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve described each of the paths, we can see a natural grouping
    of `users`, `activities`, and `reports`. Compojure offers us a means of reflecting
    this grouping when we define our routes by using the `compojure.core/context`
    macro. For example, to group the `GET` and `POST` `/users` routes, we can do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Not only have we created a shared path prefix for both routes, we also have
    the ability to destructure the request at the context level as well as the route
    level. If we had a shared query parameter, we could destructure it when we define
    the context, then make reference to it from any route within that context.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing path and query Parameters in Compojure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A request map is structured such that the `path` and `query` parameters are
    available via the :params key. We can, therefore, destructure the parameters we''re
    interested in as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'However, Compojure offers some enhanced destructuring ability since parameters
    are some of the most common items to access within an incoming request. Using
    Compojure''s destructuring, we could rewrite the preceding route as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we've simply provided a vector containing the `id` symbol. Compojure
    then looks for an `id` key inside the `params` key of the incoming request map
    and makes the value available to us. Anything within the vector is automatically
    extracted from the value associated with the `:params` key and bound for use within
    the body of the route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.06: Integrating with an Application Layer'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we'll take the `packt-clj.fitness` backend along with the
    fitness database from the previous chapter and expand it such that we can ingest
    and query users and activities via a REST web service. We'll be reading data from
    an incoming body that is represented as an input stream. `slurp` is ideal in this
    case as it will open a reader on the stream and return the stream contents as
    a string. `slurp` also works on files, URIs, and URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following dependencies to `packt-clj.fitness` in the `deps.edn` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new namespace, `packt-clj.fitness.api`, with the following `requires`
    route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define our four routes for querying and persisting users, recalling that we
    can use a `context` to group routes that share a path prefix and/or reference
    the same `query` parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the three activity-related routes within the preceding `defroutes` definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is important to remember that our `body` is represented as a stream, meaning
    that it can only be read once. Any subsequent attempts to read from it will find
    it is already exhausted. Particular care should be taken when debugging not to
    read the body before it is actually utilized by the route. The same consideration
    should be made when writing middleware that interacts with the body.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now add our reporting route along with our catch-all `not-found` route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create our `run` function, which will start our Jetty server, serving up the
    routes we''ve defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let''s start the server and explore some of the endpoints we''ve created.
    Retrieve all users, then verify that we can retrieve a single user resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.17: Retrieving all the users'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_14_17.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.17: Retrieving all the users'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is the output for retrieving a single user:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.18: Retrieving a single user'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_14_18.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.18: Retrieving a single user'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a new user, an associated activity, then retrieve the list of activities
    that the user has taken part in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Browsing to `http://localhost:8080/users/4/activities`, the output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.19: Printing the final output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_14_19.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.19: Printing the final output'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The preceding user and activity IDs (`4` and `61`) are autogenerated and *will*
    vary if you have persisted any additional data before writing the two preceding
    records.
  prefs: []
  type: TYPE_NORMAL
- en: Excellent. We've successfully taken our existing application layer and, with
    a small amount of code, made it accessible via a web browser or any other web
    client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 14.01: Exposing Historic Tennis Results and ELO Calculations via REST'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The application layer delivered as part of `packt-clj.tennis` from *Chapter
    13*, *Database Interaction and the Application Layer*, has been well received.
    You have now been asked to make this more widely available via a REST web service.
    Of most interest is the ability to browse player data, tennis matches, and ELO
    changes over time. The ability to persist new tennis matches and recalculate the
    ELO has also been requested. The historic data should be assumed to be already
    available in our database.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the public API of your application layer, determine the resources that
    you'd like to expose, then build your web service to expose those resources via
    a web client (either a browser or another HTTP client). Additional application
    layer functions will be required to support the routes we'll create.
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you to perform the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the required dependencies to your `deps.edn` file or equivalent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the namespace, `packt-clj.tennis.api`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define our `routes` parameters, adding a `players` context containing routes
    that expose all our player resources, an individual player using their unique
    ID, and all of the tennis matches that the player took part in. Wire these routes
    up to appropriate functions in the `query` namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `run` function that will start up a Jetty server on port `8080`, exposing
    our `routes` parameter, ensuring we use middleware to help us with content negotiation
    and rationalizing the location of parameters within our request map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within our `players` context, add a route for returning the ELO of an individual
    player. Again, construct the appropriate `query` function to support this extraction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now add a `tennis-matches` context containing a route that exposes all matches,
    as well as individual matches by their unique ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Retrieve the current ELO of `Pete Sampras` (ID: `s402`) and `Novak Djokovic`
    (ID: `d643`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the `tennis-matches` context, add a route to create a new match using
    existing players. The persistence of the new match should recalculate the ELO
    of the players involved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Construct and persist a fictitious match between `Sampras` and `Djokovic` where
    `Djokovic` takes the win:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Retrieve the updated ELO of `Sampras` (`s402`) and `Djokovic` (`d643`), expecting
    ELO of `Sampras` to decrease, while Djokovic's will have increased.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the expected output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.20: Printing Sampras'' rating'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_14_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.20: Printing Sampras'' rating'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.21: Printing Djokovic''s rating'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_14_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.21: Printing Djokovic''s rating'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 753.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced us to HTTP, web servers, and the request-response interaction
    between a web server and a client. Multiple clients were introduced, including
    the most typical (the web browser) as well as `curl` and `clj-http`. We learned
    how a web server takes an incoming request and routes it according to key elements
    of the incoming request map, before constructing a response map, which is then
    presented to the requesting client.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about middleware and how it intercepts our request and/or response
    map. We then used `muuntaja` to format the content we generated for the client,
    as well as to format incoming data from the client as JSON or EDN.
  prefs: []
  type: TYPE_NORMAL
- en: After considering the content of our database in the context of groups of related
    resources, we learned how to construct appropriate paths to address them using
    a REST architecture. This paved the way for integrating our existing application
    layers with a web service that would allow any web client to interact with them
    over HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: We can now imagine a frontend (user interface) pulling resources from our web
    service, formatting them, and presenting them to a user who is then capable of
    manipulating those resources. In this case, the IDs (which are not particularly
    user-friendly) could be tracked by the UI and kept hidden from the users.
  prefs: []
  type: TYPE_NORMAL
- en: We'll explore how to interact with our new service via ClojureScript in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
