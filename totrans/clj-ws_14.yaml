- en: 14\. HTTP with Ring
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14. 使用 Ring 的 HTTP
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will process requests and generate responses, route incoming
    requests and manipulate requests via middleware. We will also serve up responses
    using various content types including **JavaScript Object Notation** (**JSON**)
    and **Extensible Data Notation** (**EDN**), create a web application using Ring
    and Compojure, and serve static resources via HTTP.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将处理请求并生成响应，通过中间件路由传入的请求并操作请求。我们还将使用各种内容类型（包括 **JavaScript 对象表示法**（**JSON**）和
    **可扩展数据表示法**（**EDN**））提供响应，使用 Ring 和 Compojure 创建一个网络应用程序，并通过 HTTP 提供静态资源。
- en: By the end of this chapter, you will be able to expose CRUD operations via HTTP.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够通过 HTTP 公开 CRUD 操作。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the last chapter, we built our application layer and interacted with it via
    the REPL. This works sufficiently well for a single user performing ad hoc interactions,
    but it does not scale. Indeed, we could imagine a scenario where a third party
    or even another of our own services wants to make use of the data stored in our
    database, perform calculations, and persist updates. This interaction would be
    programmatic and would, therefore, benefit from being exposed over **HyperText
    Transfer Protocol** (**HTTP**) or similar.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了应用程序层并通过 REPL 与其交互。这对于单个用户执行临时交互来说足够好了，但它无法扩展。实际上，我们可以想象一个场景，第三方甚至我们自己的服务想要使用我们数据库中存储的数据，执行计算，并持久化更新。这种交互将是程序性的，因此从
    **超文本传输协议**（**HTTP**）或类似协议公开将是有益的。
- en: We can achieve this by exposing our application layer via a web service. A web
    service allows interaction with our application layer over a network (most typically
    the internet, although it could be over an intranet for private applications).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过通过网络服务公开我们的应用程序层来实现这一点。网络服务允许通过网络（通常是互联网，尽管它也可以是私有应用程序的内部网络）与我们的应用程序层进行交互。
- en: To build our web service, we'll need a web application library to build our
    API, a web server to serve it up over HTTP, and a routing library to route incoming
    requests to the appropriate handler. Clojure has numerous implementations of each;
    however, for this chapter, we'll focus on using `Compojure` for routing, and Jetty
    to serve it all up.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建我们的网络服务，我们需要一个网络应用程序库来构建我们的 API，一个网络服务器来通过 HTTP 提供它，以及一个路由库来将传入的请求路由到适当的处理程序。Clojure
    有许多每种类型的实现；然而，对于本章，我们将专注于使用 `Compojure` 进行路由，并使用 Jetty 提供所有服务。
- en: An extension to this chapter could involve you taking the examples and exercises
    provided and implementing them using an alternative web app library, such as `Pedestal`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的扩展可以包括您使用提供的示例和练习，并使用替代的网页应用库，例如 `Pedestal` 来实现它们。
- en: HTTP, Web Servers, and REST
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP、Web 服务器和 REST
- en: Before we dive into building a web service, let's cover the basics. HTTP is
    one of the primary protocols for communicating across the internet, particularly
    when working in a web browser. This protocol provides a contract for a client
    (typically a web browser) to communicate with a (web) server. In this example,
    the browser will construct a request containing a Uniform Resource Identifier
    (URI), which it will use to communicate to the server. The server will interpret
    the request, using the URI string to determine which resource the client is interested
    in retrieving/manipulating, then constructing a response containing information
    indicating that the request has completed, or containing a payload in the form
    of the response body.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入构建网络服务之前，让我们先了解基础知识。HTTP 是互联网通信的主要协议之一，尤其是在使用网页浏览器进行工作时。该协议为客户端（通常是网页浏览器）与服务器通信提供了一个合同。在这个例子中，浏览器将构建一个包含统一资源标识符（URI）的请求，并将其用于与服务器通信。服务器将解释请求，使用
    URI 字符串来确定客户端感兴趣检索/操作的资源，然后构建一个包含指示请求已完成的响应信息或包含响应体形式的负载的响应。
- en: Typically, when building a web service, we want to conform to the **REpresentational
    State Transfer** (**REST**) architecture. This architecture prescribes a set of
    operations we can choose to perform against a resource, allowing us to transition
    that resource through a number of valid states.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在构建网络服务时，我们希望遵循 **表征状态转移**（**REST**）架构。该架构规定了一系列我们可以选择对资源执行的操作，使我们能够将资源通过多个有效状态进行转换。
- en: 'For example, let''s assume we''re interacting with our profile on our favorite
    online retailer''s website. First, we''ll retrieve our profile, then perhaps we''ll
    retrieve our current address. We''ll make a change to this address, then save
    our changes. In terms of REST interactions over HTTP, this may look as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们正在与我们的最喜欢的在线零售商网站上的个人资料进行交互。首先，我们将检索我们的个人资料，然后可能会检索我们的当前地址。我们将更改此地址，然后保存更改。在
    HTTP 上 REST 交互的术语中，这可能看起来如下：
- en: GET [https://packt.live/30NL9hm](https://packt.live/30NL9hm)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GET [https://packt.live/30NL9hm](https://packt.live/30NL9hm)
- en: GET [https://packt.live/2U026Ur](https://packt.live/2U026Ur)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GET [https://packt.live/2U026Ur](https://packt.live/2U026Ur)
- en: PUT [https://packt.live/2U026Ur](https://packt.live/2U026Ur)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PUT [https://packt.live/2U026Ur](https://packt.live/2U026Ur)
- en: '`123` in the preceding example is our unique user ID.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 上一示例中的 `123` 是我们的唯一用户 ID。
- en: The GET/PUT method preceding the URI is known as the HTTP method. GET indicates
    that we wish to read the content associated with the resource in the URI provided.
    The PUT method has an associated body containing the updated address; we're instructing
    the server to create/update the address resource with that provided.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 URI 前面的 GET/PUT 方法被称为 HTTP 方法。GET 表示我们希望读取 URI 提供的资源相关的内容。PUT 方法有一个包含更新地址的关联体；我们指示服务器使用提供的地址创建/更新地址资源。
- en: An important distinction to make between PUT and POST is that PUT should be
    used when updating an existing resource or when we happen to know the unique ID
    of the entity we're creating. POST is used solely for the creation of resources
    and does not require us to know its unique ID. Instead, this ID will be allocated
    by the web service itself and communicated back to the client via the response
    headers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PUT 和 POST 之间需要区分的一个重要区别是，当更新现有资源或我们偶然知道我们正在创建的实体的唯一 ID 时，应使用 PUT。POST 仅用于资源的创建，并且不需要我们知道其唯一
    ID。相反，此 ID 将由网络服务本身分配，并通过响应头传达给客户端。
- en: The full set of supported methods are GET, POST, PUT, DELETE, HEAD, PATCH, CONNECT,
    OPTIONS, and TRACE. The first four of which are most typically encountered.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的全部方法包括 GET、POST、PUT、DELETE、HEAD、PATCH、CONNECT、OPTIONS 和 TRACE。其中前四种是最常见的。
- en: Request and Response
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求和响应
- en: 'For those completely new to building web services, we will be covering a number
    of new concepts. These are not necessarily complex subjects, but sufficient detail
    to understand each of the building blocks will be given. As mentioned previously,
    we will use Ring (Clojure''s most widely used web application library) to build
    our web service. A Ring application consists of only four components: requests,
    handlers, responses, and middleware.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些完全不了解构建网络服务的人来说，我们将介绍许多新概念。这些概念不一定复杂，但将提供足够的细节来理解每个构建块。如前所述，我们将使用 Ring（Clojure
    最广泛使用的网络应用程序库）来构建我们的网络服务。一个 Ring 应用程序仅由四个组件组成：请求、处理器、响应和中间件。
- en: We understand the concept of a request and response; we'll now cover them in
    detail, including how to parse the former and how to construct the latter, as
    well as the form that each typically takes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理解请求和响应的概念；现在我们将详细讲解它们，包括如何解析前者以及如何构建后者，以及它们通常采取的形式。
- en: In the most simple terms, the function of our web service should be to take
    an incoming request represented as a map, perform some operations based on the
    content of that map (for example, fetch a user's profile or update their address),
    and produce an appropriate response map ready to be rendered by a browser or interpreted
    by the client more generally. In Ring, the function that performs this conversion
    of a request to a response is referred to as a handler.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 用最简单的话说，我们网络服务的功能应该是接收一个表示为映射的传入请求，根据该映射的内容执行一些操作（例如，获取用户的个人资料或更新他们的地址），并生成一个适当的响应映射，以便浏览器渲染或客户端更广泛地解释。在
    Ring 中，执行这种请求到响应转换的功能被称为处理器。
- en: 'The most basic operation would follow this process:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本操作将遵循以下流程：
- en: '![Figure 14.1: Representation of the request-response process'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.1：请求-响应过程的表示](img/B14502_14_01.jpg)'
- en: '](img/B14502_14_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 B14502_14_01.jpg](img/B14502_14_01.jpg)'
- en: 'Figure 14.1: Representation of the request-response process'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1：请求-响应过程的表示
- en: 'A Ring handler is, therefore, a single-arity function, accepting a `request`
    map, and returning a `response` map:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Ring 处理器是一个单参数函数，接受一个 `request` 映射，并返回一个 `response` 映射：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What does a `request` map look like? At a minimum, a `request` map will contain
    the following top-level keys (sample values included):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`request` 映射看起来像什么？至少，一个 `request` 映射将包含以下顶级键（包括示例值）：'
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here''s the meaning of each attribute:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是每个属性的含义：
- en: '`:remote-addr`: The calling client''s IP address'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:remote-addr`: 调用客户端的 IP 地址'
- en: '`:headers`: Additional information sent along with the request, relating to
    security, content negotiation, cookies, and so on'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:headers`: 随请求发送的附加信息，与安全、内容协商、cookie 等相关'
- en: '`:server-port`: The port of the server servicing the request'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:server-port`: 请求服务器所服务的端口'
- en: '`:uri`: The URI pointing to the resource the client wishes to interact with
    (used in routing)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:uri`: 指向客户端希望与之交互的资源 URI（用于路由）'
- en: '`:query-string`: A string that can be used to filter the resource content returned'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:query-string`: 可以用来过滤返回的资源内容的字符串'
- en: '`:body`: A stream containing an optional payload (can only be read once!)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:body`: 包含一个可选的有效载荷的流（只能读取一次！）'
- en: '`:request-method`: An HTTP request method (used in routing)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:request-method`: HTTP 请求方法（用于路由）'
- en: An important point worth highlighting is that this list is *not exhaustive*.
    Third-party and custom middleware can often add their own keys with their own
    special meaning and uses.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得强调的重要点是，这个列表**并不全面**。第三方和自定义中间件经常可以添加他们自己的键，具有他们自己的特殊含义和用途。
- en: 'At the point at which our handler is invoked, the `request` map contains only
    a couple of keys of interest: the `query-string` and the `body`. The remaining
    keys have already been inspected and used to route the request to the appropriate
    handler, for example.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的处理程序被调用的点上，`request` 映射中只包含几个感兴趣的键：`query-string` 和 `body`。其余的键已经检查并用于将请求路由到适当的处理程序，例如。
- en: '`Response` maps are much simpler and will consist of only three keys: status,
    headers, and body. The `status` key is a three-digit number indicating the outcome
    of the request. There are a large number of these, grouped into five different
    categories:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Response` 映射要简单得多，将只包含三个键：状态、标头和正文。`status` 键是一个三位数，表示请求的结果。这些有很多，分为五个不同的类别：'
- en: '1xx: Informational'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1xx：信息性
- en: '2xx: Success'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2xx：成功
- en: '3xx: Redirect'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3xx：重定向
- en: '4xx: Client Error'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4xx：客户端错误
- en: '5xx: Server Error'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5xx：服务器错误
- en: Generally, we'll encounter a `200` status indicating `OK`, or perhaps a `404`
    "`Not Found`" or `500` "`Internal Server Error`" error message.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会遇到表示 `OK` 的 `200` 状态，或者可能是 `404` “未找到”或 `500` “内部服务器错误”的错误消息。
- en: The headers provide additional information about the generated response – most
    commonly, how to interpret the body. The body (sometimes called the payload) will
    contain any data retrieved or generated that will be of interest to the client.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 标头提供了有关生成响应的额外信息——最常见的是如何解释正文。正文（有时称为有效载荷）将包含任何对客户端感兴趣检索或生成的数据。
- en: We can easily construct this response map manually, as we'll see in *Exercise
    14.01*, *Creating a Hello World Web Application.*
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松手动构建这个响应映射，就像我们在 *练习 14.01*，*创建一个 Hello World 网络应用程序* 中将看到的那样。
- en: We've now encountered three of the four Ring components (with middleware being
    more complex and covered separately).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经遇到了 Ring 的四个组件中的三个（中间件更复杂，将在单独的部分中介绍）。
- en: Jetty is the web server that will serve up our Ring application. It is software
    that allows interaction with our application over a network, in the same way your
    favorite websites are made available over the internet.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Jetty 是将我们的 Ring 应用程序提供到网络上的网络服务器。它是允许通过网络与我们的应用程序交互的软件，就像您的最喜欢的网站可以通过互联网提供一样。
- en: 'Exercise 14.01: Creating a Hello World Web Application'
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.01：创建一个 Hello World 网络应用程序
- en: 'This exercise will see us make use of Ring and Jetty, where we''ll create a
    trivial web application with a static `Hello World` response:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将使我们使用 Ring 和 Jetty，我们将创建一个简单的网络应用程序，具有静态的 `Hello World` 响应：
- en: 'Begin with the following dependencies in `deps.edn` or similar:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `deps.edn` 或类似的依赖项开始：
- en: '[PRE2]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now define our Ring handler, remembering it''s a single-arity function accepting
    a `request` map and returning a `response` map. Our `response` map contains an
    `ok` `200` status code and a string response in the `body`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在定义我们的 Ring 处理器，记住它是一个单参数函数，接受一个 `request` 映射并返回一个 `response` 映射。我们的 `response`
    映射包含一个 `ok` `200` 状态码和一个字符串响应在 `body` 中：
- en: '[PRE3]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we''ll start a Jetty web server, passing our handler and a couple of options:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将启动一个 Jetty 网络服务器，传递我们的处理程序和一些选项：
- en: '[PRE4]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By default, Jetty will spin up on port 80; we've overridden that to use `8080`.
    Notice that we've also passed :join? false. This ensures that our web server will
    not block the current thread that the REPL is running on, meaning we can interact
    with it and perform other REPL-based operations in the meantime. We now have a
    web server running, exposing our single handler over HTTP.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，Jetty将在端口80上启动；我们已将其覆盖为使用`8080`。请注意，我们还传递了`:join? false`。这确保我们的Web服务器不会阻塞REPL正在运行的当前线程，这意味着我们可以在同时与之交互并执行其他基于REPL的操作。我们现在有一个正在运行的Web服务器，通过HTTP公开我们的单个处理器。
- en: Note
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'We can stop the currently running server using Java interop:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用Java互操作停止当前运行的服务器：
- en: '`user=> (.stop app)`'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`user=> (.stop app)`'
- en: '`=> nil`'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`=> nil`'
- en: If, at any point, an error such as `Address already in use` is encountered,
    be sure to stop your existing app before starting a new one.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果在任何时候遇到诸如`Address already in use`之类的错误，在启动新应用之前，务必停止现有应用。
- en: This will prove useful going forward as we make changes to our application and
    test them out in the browser. If you have stopped the app, be sure to restart
    it by rerunning *Step 3* before proceeding.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在我们修改应用程序并测试它们在浏览器中的效果时非常有用。如果您已停止应用，请确保在继续之前通过重新运行*步骤3*来重新启动它。
- en: 'Navigate to localhost:8080 in a browser:![Figure 14.2: Printing Hello Word
    in a browser'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中导航到localhost:8080：![图14.2：在浏览器中打印Hello Word
- en: '](img/B14502_14_02.jpg)'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14502_14_02.jpg)'
- en: 'Figure 14.2: Printing Hello Word in a browser'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2：在浏览器中打印Hello Word
- en: Success! We have created our first handler and our web server is up and running
    with only a few lines of code. Be sure to stop our running app.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！我们已经创建了我们的第一个处理器，我们的Web服务器仅用几行代码就启动并运行了。请确保停止我们的运行中的应用程序。
- en: Request Routing
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求路由
- en: In the previous example, notice that run-jetty only accepts a single handler.
    We'll more than likely want our service to provide the ability to store, view,
    and otherwise manipulate numerous resources. For this, we'll need to support an
    arbitrary number of handlers to cater to each of our resources, plus a means of
    finding the correct handler to service our request. This is where request routing
    comes in.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，请注意，run-jetty只接受单个处理器。我们很可能希望我们的服务能够提供存储、查看以及操纵多个资源的能力。为此，我们需要支持任意数量的处理器来满足我们的每个资源，以及一种找到正确处理器来处理我们的请求的方法。这就是请求路由发挥作用的地方。
- en: 'Revisiting the request object, we find that it contains (among other things)
    the following keys:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 重新审视请求对象，我们发现它包含（包括其他内容）以下键：
- en: URI
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI
- en: Request-method
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求方法
- en: We could enhance our handler to inspect the incoming request, extract the content
    of those keys, then determine the appropriate function to call to satisfy the
    request and generate a response. We'd probably call this handler our dispatcher
    or router. As we consider this approach, we should recall the chapter introduction
    where we mentioned Compojure, which bills itself as a small routing library for
    Ring that allows web applications to be composed of small, independent parts.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以增强处理器以检查传入的请求，提取这些键的内容，然后确定调用适当的函数来满足请求并生成响应。我们可能会称这个处理器为调度器或路由器。在考虑这种方法时，我们应该回忆起章节介绍中提到的Compojure，它将自己定位为Ring的一个小型路由库，允许Web应用由小型、独立的组件组成。
- en: That's exactly what we're looking for. We'll now learn how to make use of `Compojure`
    to perform request routing and expand our application a little further.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们所寻找的。现在我们将学习如何使用`Compojure`来执行请求路由并进一步扩展我们的应用。
- en: Using Compojure
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Compojure
- en: If routing requests manually sounded fairly tedious, breathe a sigh of relief
    as Compojure takes all the strain out of request routing. We define pairs of HTTP
    methods and resource paths we want to match and Compojure takes care of the rest.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果手动路由请求听起来相当繁琐，那么请松一口气，因为Compojure将所有压力都从请求路由中释放出来。我们定义了我们要匹配的HTTP方法和资源路径的配对，Compojure会处理其余部分。
- en: 'A trivial route method is defined as follows, using the GET macro from the
    compojure.core namespace:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的路由方法定义如下，使用来自compojure.core命名空间的GET宏：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: GET (and all other HTTP method macros) expect a path representing the resource
    we want to match against. In the preceding example, we match the hello path at
    the root of the web service. Compojure gives us a great deal of control over the
    path, allowing us to expect path parameters or match using a regular expression
    if we need to.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: GET（以及所有其他HTTP方法宏）期望一个表示我们想要匹配的资源路径。在上面的示例中，我们匹配了位于Web服务根目录的hello路径。Compojure给了我们很大的控制权，允许我们期望路径参数或使用正则表达式进行匹配，如果需要的话。
- en: The next argument to the macro actually binds the incoming request map (or parts
    thereof) to the local symbol(s) we specify. In the preceding example, the entire
    incoming request map has been bound to the `request` symbol. We can choose to
    destructure elements of the map if we so wish.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 宏的下一个参数实际上是将传入的请求映射（或其部分）绑定到我们指定的本地符号。在前面的例子中，整个传入请求映射已经被绑定到 `request` 符号。如果我们愿意，可以选择解构映射的元素。
- en: The final argument to the macro is the body of our route. Here, we can add any
    logic we require, with the final expression being returned as the response. In
    this case, we simply return the string Hello world. Compojure will interpret a
    plain string as an implicit 200 response (that is, success) meaning we don't need
    to construct a map with an explicit :status key as we did in *Exercise 14.01*,
    *Creating a Hello World Web Application*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 宏的最后一个参数是路由的主体。在这里，我们可以添加我们需要的任何逻辑，最终表达式作为响应返回。在这种情况下，我们简单地返回字符串 "Hello world"。Compojure
    将普通字符串解释为隐式的 200 响应（即成功），这意味着我们不需要像在 *练习 14.01*，*创建一个 Hello World 网络应用程序* 中那样构建一个带有显式
    :status 键的映射。
- en: 'Now we''re likely to have more than a single route in our application, but
    Jetty only accepts a single handler. We can now reach for the `routes` function
    or the defroutes macro provided by Compojure; either of these can be used to combine
    one or more routes into a single handler. Using the macro, we bring our routes
    together, binding them to the `routes` variable, which we can then pass to Jetty:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们很可能会在我们的应用程序中有不止一个路由，但 Jetty 只接受一个处理器。我们现在可以求助于 Compojure 提供的 `routes` 函数或
    `defroutes` 宏；这两个都可以用来将一个或多个路由组合成一个处理器。使用宏，我们将我们的路由组合在一起，将它们绑定到 `routes` 变量，然后我们可以将其传递给
    Jetty：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'What if a user navigates to a route that we have not defined? When we define
    the routes and their unique paths, we''re asking the routing library to inspect
    the incoming request and attempt to match it to each of our routes in turn. If
    this list of routes is exhausted before finding a match, an exception is thrown.
    In a browser, we''ll receive the following (not particularly useful!) error message:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户导航到一个我们没有定义的路由，会怎样？当我们定义路由及其唯一路径时，我们是在要求路由库检查传入的请求，并依次尝试将其与我们的每个路由匹配。如果在找到匹配之前路由列表已经耗尽，则会抛出异常。在浏览器中，我们将收到以下（不是特别有用的！）错误消息：
- en: '![Figure 14.3: Page not working error'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.3：页面工作错误'
- en: '](img/B14502_14_03.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_14_03.jpg)'
- en: 'Figure 14.3: Page not working error'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3：页面工作错误
- en: 'We can avoid this by providing a catch-all, ensuring this is the *last* route
    defined. Compojure offers us a not-found route, which we can incorporate into
    our routes definition. It allows us to gracefully handle a request for a resource
    we cannot find a match for. The inclusion of this `not-found` route would look
    as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过提供一个通配符路由来避免这种情况，确保这是定义的 *最后一个* 路由。Compojure 为我们提供了一个 `not-found` 路由，我们可以将其纳入我们的路由定义中。它允许我们优雅地处理无法找到匹配资源的请求。包含此
    `not-found` 路由将如下所示：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Exercise 14.02: Introducing Routing with Compojure'
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.02：使用 Compojure 引入路由
- en: 'Let''s begin by tweaking our `Hello World` application by replacing the handler
    with a Compojure route definition:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从调整我们的 `Hello World` 应用程序开始，通过替换处理器为 Compojure 路由定义：
- en: 'Add the `compojure` dependency:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `compojure` 依赖项：
- en: '[PRE8]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Taking our original hello world handler, we''ll convert this to the `compojure`
    route definition format using the `GET` macro from `compojure.core`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的原始 `hello world` 处理器转换为 `compojure` 路由定义格式，使用 `compojure.core` 中的 `GET`
    宏：
- en: '[PRE9]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will look as follows if we use Compojure:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们使用 Compojure，它将看起来如下：
- en: '[PRE10]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Replace `handler` with `route` in our call to `run-jetty`, start the app (stopping
    any existing apps first!), and point your browser to `localhost:8080` once again:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `run-jetty` 调用中将 `handler` 替换为 `route`，启动应用程序（首先停止任何现有应用程序！），然后将您的浏览器指向
    `localhost:8080`：
- en: '[PRE11]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output is as follows:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 14.4: Printing the output to the browser'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.4：将输出打印到浏览器'
- en: '](img/B14502_14_04.jpg)'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_14_04.jpg)'
- en: 'Figure 14.4: Printing the output to the browser'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.4：将输出打印到浏览器
- en: There will be no material change; however, we have paved the way for rolling
    out Compojure and supporting an arbitrary number of routes in our application.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不会有任何实质性的变化；然而，我们已经为推出 Compojure 以及在我们的应用程序中支持任意数量的路由铺平了道路。
- en: 'Let''s define multiple routes, combining them under a single handler to exercise
    Compojure''s routing ability:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义多个路由，将它们组合在一个处理器下以练习 Compojure 的路由能力：
- en: '[PRE12]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Pass these routes to our `run-jetty` call:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些路由传递给我们的 `run-jetty` 调用：
- en: '[PRE13]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can now navigate to each of our routes in turn via the browser. Browse to
    our first route, `http://localhost:8080/route-1`:'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在可以通过浏览器依次导航到我们的每个路由。浏览到我们的第一条路由，`http://localhost:8080/route-1`：
- en: '![Figure 14.5: Browsing to the first route'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.5：浏览到第一条路由]'
- en: '](img/B14502_14_05.jpg)'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_14_05.jpg]'
- en: 'Figure 14.5: Browsing to the first route'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.5：浏览到第一条路由]'
- en: 'Browse to our second route, `http://localhost:8080/route-2`:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 浏览到我们的第二条路由，`http://localhost:8080/route-2`：
- en: '![Figure 14.6: Browsing to the second route'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.6：浏览到第二条路由]'
- en: '](img/B14502_14_06.jpg)'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_14_06.jpg]'
- en: 'Figure 14.6: Browsing to the second route'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.6：浏览到第二条路由]'
- en: 'While we''re here, let''s attempt to navigate to a non-existent route, `localhost:8080/nothing-to-see-here`.
    Your browser should inform you of localhost''s inability to service this request,
    possibly indicating a `500` error:![Figure: 14.7: Browsing to a non-existent route'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在这里时，让我们尝试导航到一个不存在的路由，`localhost:8080/nothing-to-see-here`。您的浏览器应该会通知您本地主机无法处理此请求，可能表明一个`500`错误：![图
    14.7：浏览到一个不存在的路由]
- en: '](img/B14502_14_07.jpg)'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_14_07.jpg]'
- en: 'Figure: 14.7: Browsing to a non-existent route'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.7：浏览到一个不存在的路由]'
- en: 'Recalling our discussion of Compojure''s `not-found` route definition, let''s
    introduce that as a fallback for cases where no other route matches our request:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回顾我们对 Compojure 的 `not-found` 路由定义的讨论，让我们将其作为没有其他路由匹配我们的请求的情况下的后备方案：
- en: '[PRE14]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Restarting our web server and again browsing to `http://localhost:8080/nothing-to-see-here`,
    we now receive a much friendlier message:![Figure 14.8: Navigating to nothing-to-see-here
    again'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动我们的网络服务器，并再次浏览到`http://localhost:8080/nothing-to-see-here`，我们现在收到一个更加友好的消息：![图
    14.8：再次导航到 nothing-to-see-here]
- en: '](img/B14502_14_08.jpg)'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_14_08.jpg]'
- en: 'Figure 14.8: Navigating to nothing-to-see-here again'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.8：再次导航到 nothing-to-see-here]'
- en: 'Finally, let''s (temporarily) move our `not-found` route to the beginning of
    our routes definition, restart the app, and browse to `http://localhost:8080/route-1`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们（暂时地）将我们的`not-found`路由移动到路由定义的开头，重新启动应用程序，并浏览到`http://localhost:8080/route-1`：
- en: '[PRE15]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output is as follows:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 14.9: Navigating to route-1'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.9：导航到路由-1]'
- en: '](img/B14502_14_09.jpg)'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_14_09.jpg]'
- en: 'Figure 14.9: Navigating to route-1'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.9：导航到路由-1]'
- en: This demonstrates the care required when defining and combining multiple routes.
    The web server will serve up the response for the *first* matching route it encounters.
    We can think of this as a simple order of precedence, with routes earlier in the
    definition being preferred over those following.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了在定义和组合多个路由时所需的谨慎。网络服务器将为其遇到的第一个匹配路由提供响应。我们可以将其视为一个简单的优先顺序，定义中较早的路由比后面的路由更受青睐。
- en: Excellent – we now understand how to define a route using Compojure, combine
    it with other Compojure route definitions, and provide a sensible not-found message
    in the event that someone navigates to a non-existent resource.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 很好——我们现在理解了如何使用 Compojure 定义路由，将其与其他 Compojure 路由定义结合，并在有人导航到不存在的资源时提供一个合理的未找到消息。
- en: Response Formats and Middleware
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '![响应格式和中间件]'
- en: The preceding trivial route definitions have all returned a string as the response
    body, which is perfectly acceptable for a human interacting with our service via
    a web browser. When we start to have other web services or a frontend interacting
    with our service, we may well have to serve up alternative response formats. A
    JavaScript frontend is likely to want a JSON response, whereas a ClojureScript
    frontend would likely prefer EDN. EDN is a data format favored in the Clojure
    ecosystem; indeed, Clojure itself is written in this format, meaning you will
    already be familiar with it by this stage!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的简单路由定义都返回了一个字符串作为响应体，这对于通过网络浏览器与我们的服务交互的人类来说是完全可以接受的。当我们开始有其他网络服务或前端与我们的服务交互时，我们很可能需要提供替代的响应格式。JavaScript
    前端可能希望得到一个 JSON 响应，而 ClojureScript 前端可能更倾向于 EDN。EDN 是在 Clojure 生态系统中被青睐的数据格式；实际上，Clojure
    本身就是用这种格式编写的，这意味着在这个阶段你已经熟悉它了！
- en: The client can indicate which formats it accepts by providing an accept header
    as part of the request. The `accept` header takes the form of a string describing
    the `application/json` and `application/edn`. The server can inspect this header
    and render the response in accordance with the formats accepted by the client.
    The server will assist the client by returning a `content-type` header in the
    response indicating which format it has selected.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 客户可以通过在请求中提供接受头来指示它接受的格式。`accept`头是一个描述`application/json`和`application/edn`的字符串。服务器可以检查此头，并根据客户端接受的格式渲染响应。服务器将通过在响应中返回一个指示它已选择的格式的`content-type`头来协助客户端。
- en: Note
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The client is in no way obligated to return data in the format requested but
    should do so if it is able.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 客户没有义务以请求的格式返回数据，但如果可能的话，应该这样做。
- en: Intuitively, we may be tempted to inspect the accept header manually within
    each of our routes and encode the response before we return it. While this would
    work, it would introduce a great deal of duplicative code into our application
    and distract from the core work of the route itself.  For example, we may have
    a `render-response` function that determines which format to render based on the
    `accept` header. We would be obligated to include this call in every one of our
    routes. Much more preferable would be the ability to define this once and have
    it applied across all of our routes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 直觉上，我们可能会倾向于在每个路由中手动检查`accept`头，并在返回之前对响应进行编码。虽然这会工作，但它会在我们的应用程序中引入大量重复的代码，并分散对路由本身核心工作的注意力。例如，我们可能有一个`render-response`函数，该函数根据`accept`头确定要渲染的格式。我们将被迫在所有路由中都包含这个调用。更可取的是，能够定义一次并在所有路由中应用它。
- en: This is where the concept of middleware comes in. In simple terms, middleware
    is a function that wraps our route, allowing us to execute code before and/or
    after generating our response.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是中间件概念出现的地方。简单来说，中间件是一个包裹我们的路由的函数，它允许我们在生成响应之前和/或之后执行代码。
- en: 'A middleware function for a synchronous response (that is, where the client
    will wait for the response using the same connection) typically takes the following
    format:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 用于同步响应（即客户端将使用相同的连接等待响应）的中间件函数通常具有以下格式：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In essence, it is a function that accepts a handler, then returns a new function
    that calls the original handler. Besides that requirement, it is free to manipulate
    the request before passing it to the handler call, or it could manipulate the
    response generated by calling the handler, or both.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，它是一个接受处理程序并返回一个新函数的函数，该新函数调用原始处理程序。除了这个要求之外，它可以在将请求传递给处理程序调用之前或之后操纵请求，或者操纵由调用处理程序生成的响应，或者两者都操纵。
- en: 'It should now be obvious that we could define a piece of middleware to handle
    the response rendering. Before we do that, let''s take a look at `muuntaja`, which
    has been written specifically with this task in mind. Indeed, it supports JSON
    and EDN out of the box simply by wrapping our handler in a call to `muuntaja.middleware/wrap-format`.
    For example, the following tweak to our `run` function would automatically negotiate
    the incoming request body and outgoing response body formatting:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该很明显，我们可以定义一个中间件来处理响应渲染。在我们这样做之前，让我们看看`muuntaja`，它专门为此任务而编写。确实，它通过将我们的处理程序包裹在`muuntaja.middleware/wrap-format`的调用中，可以开箱即支持JSON和EDN。例如，以下对`run`函数的调整将自动协商传入请求体和传出响应体的格式：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Exercise 14.03: Response Rendering with Muuntaja'
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.03：使用Muuntaja进行响应渲染
- en: In this exercise, we'll cover middleware and how it can be used to render a
    response by taking the `accept` header into consideration. Our goal is to respect
    the `accept` header provided by the caller such that we can return JSON, EDN,
    or a plain string as required. We'll also look at how to interact with our route
    using `curl`, a popular tool used to make calls to web services.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将介绍中间件以及如何通过考虑`accept`头来渲染响应。我们的目标是尊重调用者提供的`accept`头，以便我们可以根据需要返回JSON、EDN或纯字符串。我们还将探讨如何使用`curl`（一种流行的工具，用于向Web服务发出调用）与我们的路由进行交互。
- en: 'By leveraging `muuntaja middleware`, our route code can remain completely agnostic
    of the response format requested by the client:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用`muuntaja中间件`，我们的路由代码可以完全不受客户端请求的响应格式的影响：
- en: 'We''ll begin by introducing the muuntaja dependency and requiring it:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先介绍muuntaja依赖项并要求它：
- en: '[PRE18]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now let''s define a new set of routes, one of which returns a string, and another
    returning a nested data structure that can vary depending on the value of the
    `accept` header passed by the client:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们定义一组新的路由，其中之一返回一个字符串，另一个返回一个嵌套的数据结构，这取决于客户端传递的`accept`头值：
- en: '[PRE19]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Out of the box, Compojure does not know how to render a map, regardless of whether
    an accept header is specified.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，Compojure不知道如何渲染一个映射，无论是否指定了`accept`头。
- en: Of interest will be how the middleware handles the keywords and sets depending
    on the response format we're interested in.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们感兴趣的是中间件如何根据我们感兴趣的响应格式处理关键字和集合。
- en: 'Recall that middleware wraps a handler; therefore, introducing `wrap-format`
    middleware of muuntaja is as simple as altering our `run` function like so:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，中间件封装了一个处理器；因此，引入muuntaja的`wrap-format`中间件就像这样修改我们的`run`函数一样简单：
- en: '[PRE20]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now restart our app and request our `string` resource by expressing no preference
    for the response format, then stipulating we''d prefer `application/edn`. We''re
    using `curl` here via Terminal or Command Prompt depending on your operating system:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在重新启动我们的应用，通过表达对响应格式的无偏好，然后规定我们更喜欢`application/edn`来请求我们的`string`资源。这里我们使用`curl`，根据您的操作系统通过终端或命令提示符：
- en: '[PRE21]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 14.10: Printing the output of the curl command'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图14.10：打印curl命令的输出'
- en: '](img/B14502_14_10.jpg)'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_14_10.jpg]'
- en: '[PRE22]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 14.11: Printing the output of the curl command'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图14.11：打印curl命令的输出'
- en: '](img/B14502_14_11.jpg)'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_14_11.jpg]'
- en: 'Figure 14.11: Printing the output of the curl command'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图14.11：打印curl命令的输出
- en: Notice the response format is identical in both cases, which can be confirmed
    by checking the preceding `content-type` header. This shows that our server is
    unable to render the response as `EDN` and has chosen to ignore the `accept` header
    directive.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，两种情况下的响应格式是相同的，这可以通过检查前面的`content-type`头来确认。这表明我们的服务器无法将响应渲染为`EDN`，并选择忽略`accept`头指令。
- en: 'Our `data-structure` route is a little more interesting. Let''s submit three
    different requests and compare them. Here''s the first request:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`data-structure`路由稍微有趣一些。让我们提交三个不同的请求并比较它们。这是第一个请求：
- en: '[PRE23]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is as follows:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 14.12: Output of the first request'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图14.12：第一次请求的输出'
- en: '](img/B14502_14_12.jpg)'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_14_12.jpg]'
- en: 'Figure 14.12: Output of the first request'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.12：第一次请求的输出
- en: 'Here''s the second request:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二个请求：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 14.13: Output of the second request'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.13：第二次请求的输出'
- en: '](img/B14502_14_13.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14502_14_13.jpg]'
- en: 'Figure 14.13: Output of the second request'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.13：第二次请求的输出
- en: 'Here''s the third request:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第三个请求：
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 14.14: Output of the third request'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.14：第三次请求的输出'
- en: '](img/B14502_14_14.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14502_14_14.jpg]'
- en: 'Figure 14.14: Output of the third request'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.14：第三次请求的输出
- en: In this case, omitting the `accept` header gives us a JSON response by default.
    Requests for JSON and EDN are respected.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，省略`accept`头默认会给我们一个JSON响应。对JSON和EDN的请求会被尊重。
- en: This demonstrates how remarkably simple (and powerful) content negotiation can
    be using middleware.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了使用中间件进行内容协商是多么的简单（且强大）。
- en: Handling a Request Body
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理请求体
- en: So far, we have implemented a number of straightforward `GET` operations serving
    up static responses. Thinking back to our `GET` method is how we read data. When
    creating (`PUT`/`POST`) or updating (`PUT`), we should provide a body along with
    our request. This body is the entity we wish to create or update.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了一些简单的`GET`操作，提供静态响应。回想一下，我们的`GET`方法是如何读取数据的。在创建（`PUT`/`POST`）或更新（`PUT`）时，我们应该在请求中提供`body`。这个`body`是我们希望创建或更新的实体。
- en: Note
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A `body` can be provided along with a `GET` request; however, this is uncommon
    and the content of the body should *not* have any material impact on the value
    returned.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`GET`请求中提供`body`；然而，这并不常见，且`body`的内容不应对返回的值有任何实质性影响。
- en: The body, particularly when storing an entity, will often take the form of a
    map. The map could, therefore, be provided as JSON or EDN and should be parsed
    accordingly. The code we write as part of our route is again agnostic of the incoming
    format since the middleware will handle the formatting for us and provide an EDN
    representation for us to work with.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 主体，尤其是存储实体时，通常采用映射的形式。因此，映射可以提供为 JSON 或 EDN，并且应相应地进行解析。我们作为路由部分编写的代码对传入的格式是无关紧要的，因为中间件将为我们处理格式化并提供一个我们可以工作的
    EDN 表示。
- en: 'Exercise 14.04: Working with a request Body'
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.04：处理请求主体
- en: 'In this exercise, we''ll learn how the `wrap-formats` middleware is applied
    to the incoming request body, not just the outgoing response body. We''ll also
    learn which part of the request will contain the content of the body, how to implement
    a quick in-memory database, and how to interact with a route via `clj-http` (a
    Clojure HTTP client library) rather than `curl`. We''ll use this knowledge to
    perform basic CRUD operations on our in-memory database:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将学习 `wrap-formats` 中间件是如何应用于传入的请求主体，而不仅仅是输出的响应主体。我们还将学习请求的哪个部分将包含主体的内容，如何实现快速内存数据库，以及如何通过
    `clj-http`（一个 Clojure HTTP 客户端库）而不是 `curl` 与路由交互。我们将使用这些知识在我们的内存数据库上执行基本的 CRUD
    操作：
- en: 'Let''s introduce `clj-http` as a dependency, to demonstrate a native Clojure
    means of interacting with our web server. We''ll also need a means of constructing
    a JSON payload, hence the inclusion of `clojure.data.json`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们引入 `clj-http` 作为依赖项，以演示与我们的网络服务器交互的本地 Clojure 方法。我们还需要一种构造 JSON 有效负载的方法，因此包括了
    `clojure.data.json`：
- en: '[PRE26]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We''ll define an atom to act as a cheap in-memory database for our server.
    Our `GET`, `PUT`, and `DELETE` routes will then use it as storage to demonstrate
    working with a `request` body:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将定义一个原子作为我们服务器的低成本内存数据库。我们的 `GET`、`PUT` 和 `DELETE` 路由将使用它作为存储来演示如何使用 `request`
    主体：
- en: '[PRE27]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Our `GET` method will read the value associated with the `:data` key; our `PUT`
    method will store the content of the `:body-params` key in our incoming request
    under the `:data` key in our atom, allowing us to roundtrip the data structure.
    Finally, our `DELETE` will remove the structure we have stored.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的 `GET` 方法将读取与 `:data` 键关联的值；我们的 `PUT` 方法将存储在传入请求中的 `:body-params` 键的内容，在原子中的
    `:data` 键下，使我们能够往返数据结构。最后，我们的 `DELETE` 将删除我们存储的结构。
- en: 'Our `run` function remains unchanged since `muuntaja` `wrap-format` works for
    both the incoming request body and the outgoing response body:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `run` 函数保持不变，因为 `muuntaja` `wrap-format` 对传入的请求主体和输出的响应主体都有效：
- en: '[PRE28]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After restarting our server, use `clj-http` to persist a JSON data structure:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在重启我们的服务器后，使用 `clj-http` 持久化一个 JSON 数据结构：
- en: '[PRE29]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The request body *must* be a string, hence our `json/write-str` call against
    our Clojure data structure. We must also provide a `content-type` header to aid
    our web service in formatting the incoming data correctly.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请求主体 *必须* 是一个字符串，因此我们对 Clojure 数据结构的 `json/write-str` 调用。我们还必须提供一个 `content-type`
    标头，以帮助我们的网络服务正确格式化传入的数据。
- en: 'Now retrieve the persisted data in EDN format:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在以 EDN 格式检索持久化的数据：
- en: '[PRE30]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Notice that we attempted to persist a set as part of our payload; however,
    it has been returned as a vector. This is an important point to note: JSON to
    EDN conversion leads to a loss of data. This is due to EDN having more built-in
    type support than JSON (for example, sets and keywords).'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们尝试将一个集合作为有效负载的一部分进行持久化；然而，它被返回为一个向量。这是一个需要注意的重要点：JSON 到 EDN 转换会导致数据丢失。这是由于
    EDN 比 JSON 具有更多的内置类型支持（例如，集合和关键字）。
- en: This is particularly dangerous if we have several clients interacting with our
    service; one that persists/consumes JSON and another that persists/consumes EDN.
    There is a workaround where we can define a schema and coerce the incoming request
    body.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们有几个客户端与我们的服务交互，这尤其危险；一个持续/消费 JSON，另一个持续/消费 EDN。有一个解决方案，我们可以定义一个模式并强制转换传入的请求主体。
- en: Note
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: '`wrap-format` *does* coerce string keys to keywords as we saw in the preceding
    steps.'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`wrap-format` *确实* 将字符串键强制转换为关键字，正如我们在前面的步骤中看到的。'
- en: 'Now, let''s confirm our EDN persistence and the retrieval behaves as expected:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们确认我们的 EDN 持久性和检索是否按预期进行：
- en: '[PRE31]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We''re now done with our `data-structure` resource; let''s delete it from the
    server:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在完成了 `data-structure` 资源；让我们从服务器中删除它：
- en: '[PRE32]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding `200` status indicates that the deletion was successful; we can
    confirm this by attempting one more retrieval:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的 `200` 状态表明删除成功；我们可以通过尝试再次检索来确认这一点：
- en: '[PRE33]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We receive a `404` exception, since the resource is `not found`, as we expected.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们收到了一个 `404` 异常，正如我们所预期的，因为资源是 `not found`。
- en: Great – we have learned that the `wrap-format` middleware will assist us in
    formatting JSON and EDN request bodies as well as response bodies as we noted
    earlier. We know that the request body will be consumed by the `wrap-format` middleware
    and the EDN-formatted result placed in the `body-params` of the incoming request.
    We have also picked up a few tips on interacting with a Clojure service using
    `clj-http`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了——我们已经了解到 `wrap-format` 中间件将帮助我们格式化 JSON 和 EDN 请求体以及响应体，正如我们之前提到的。我们知道请求体将被
    `wrap-format` 中间件消费，并且 EDN 格式的结果将被放置在传入请求的 `body-params` 中。我们还获得了一些使用 `clj-http`
    与 Clojure 服务交互的技巧。
- en: Static Files
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态文件
- en: In the early days of the internet, web servers were used to serve up static
    HTML pages and images. Although technology has progressed a great deal since then,
    serving up static resources is still very much a requirement of today's web servers.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网的早期，网络服务器被用来提供静态 HTML 页面和图像。尽管从那时起技术已经取得了很大的进步，但提供静态资源仍然是当今网络服务器的一个基本要求。
- en: 'Thinking back to our CSV file of tennis matches from *Chapter 5*, *Many to
    One: Reducing*, we may wish to make this available to download via our web service.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们来自 *第 5 章* 的网球比赛 CSV 文件，*多对一：减少*，我们可能希望通过我们的网络服务提供这个文件的下载。
- en: '`compojure.route`, which we previously used to provide a `not-found` route,
    also provides a means of easily serving static files from a custom location on
    disk. `compojure.route/files` accepts a path where the files will be exposed as
    well as an options map where we can override the directory that our files are
    served from.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`compojure.route`，我们之前用它来提供 `not-found` 路由，同时也提供了一种从磁盘上的自定义位置轻松服务静态文件的方法。`compojure.route/files`
    接受一个路径，其中文件将被公开，以及一个选项映射，我们可以用它来覆盖我们的文件从哪个目录提供服务。'
- en: 'The following code would allow us to access any files located under the `/home/<user>/packt-http/resources/`
    directory by browsing to our web server''s `/files/<filename>` route:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将允许我们通过浏览我们的网络服务器的 `/files/<filename>` 路由来访问 `/home/<user>/packt-http/resources/`
    目录下的任何文件：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Exercise 14.05: Serving Static Files'
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.05：服务静态文件
- en: 'In this exercise, we''ll make several files available via our web service,
    observing how the file-type determines the response of the web browser. We''ll
    create a text file with the `.txt` file extension and see the contents displayed
    in our browser. We''ll then see how requesting a CSV file results in the file
    being downloaded to our local machine:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将通过我们的网络服务提供几个文件，观察文件类型如何决定网络浏览器的响应。我们将创建一个具有 `.txt` 文件扩展名的文本文件，并查看其内容在我们的浏览器中显示。然后我们将看到请求
    CSV 文件是如何导致文件下载到我们的本地机器的：
- en: Create a `resources` subdirectory containing a text file named `sample.txt`
    with the content `This is only a sample`, along with the `match_scores_1991-2016_unindexed_csv.csv`
    file we are familiar with from [https://packt.live/2NT96hM](https://packt.live/2NT96hM).
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `resources` 的子目录，包含一个名为 `sample.txt` 的文本文件，内容为 `This is only a sample`，以及我们从
    [https://packt.live/2NT96hM](https://packt.live/2NT96hM) 熟悉的 `match_scores_1991-2016_unindexed_csv.csv`
    文件。
- en: 'Now we''ll use the `compojure.route/files` function to serve these up behind
    a `files` route:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将使用 `compojure.route/files` 函数在 `files` 路由后面提供这些文件：
- en: '[PRE35]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Restart the web server, then browse to `http://localhost:8080/files/sample.txt`,
    expecting an output similar to the following:'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重新启动网络服务器，然后浏览到 `http://localhost:8080/files/sample.txt`，期望输出类似于以下内容：
- en: '![Figure 14.15: Output of the sample.txt file'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.15：sample.txt 文件输出'
- en: '](img/B14502_14_15.jpg)'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_14_15.jpg)'
- en: 'Figure 14.15: Output of the sample.txt file'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.15：sample.txt 文件输出
- en: 'Now browse to `http://localhost:8080/files/match_scores_1991-2016_unindexed_csv.csv`,
    expecting the file to be downloaded as follows:![Figure 14.16: Downloading the
    CSV file'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在浏览到 `http://localhost:8080/files/match_scores_1991-2016_unindexed_csv.csv`，期望文件按以下方式下载：![图
    14.16：下载 CSV 文件
- en: '](img/B14502_14_16.jpg)'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_14_16.jpg)'
- en: 'Figure 14.16: Downloading the CSV file'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.16：下载 CSV 文件
- en: Note
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The browser has inspected the `content-type` header in the response headers;
    in the `sample.txt` case, it is reported as `text/plain` and is rendered in the
    browser. In the CSV case, the `content-type` header is reported as `text/csv`,
    which generally is not rendered and is instead downloaded to disk. It may, however,
    be opened by spreadsheet software depending on your default application launch
    settings in your browser.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器已经检查了响应头中的`content-type`头；在`sample.txt`的情况下，它报告为`text/plain`并在浏览器中渲染。在CSV的情况下，`content-type`头报告为`text/csv`，通常不会渲染，而是下载到磁盘。然而，根据您在浏览器中的默认应用程序启动设置，它可能由电子表格软件打开。
- en: Excellent! We have seen how straightforward it is to expose local files via
    our web service for display or download.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们已经看到通过我们的网络服务公开本地文件以供显示或下载是多么简单。
- en: Integrating with an Application Layer
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成到应用层
- en: Recall the Activity Tracker database from *Activity 13.01*, *Persisting Historic
    Tennis Results and ELO Calculations*, of *Chapter 13*, *Database Interaction and
    the Application Layer*, and how it was mentioned that we could envisage a web
    service sitting on top of the application layer. Our public functions in each
    of our namespaces were candidates for exposing over HTTP.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下第13章中*活动13.01*，*持久化历史网球结果和ELO计算*，以及它在*数据库交互和应用层*中提到的，我们可以设想一个位于应用层之上的网络服务。我们每个命名空间中的公共函数都是公开通过HTTP的候选者。
- en: Recall that what we're exposing over REST is access to read or manipulate a
    given resource. Considering our `users` and `activities` as resources, we may
    want to retrieve all of our `users` resources, all of our `activities` resources,
    a single user by ID, or all activities for a given user. We start by constructing
    the paths that we would navigate to reach each intended resource.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们在REST中公开的是读取或操作特定资源的访问。考虑到我们的`users`和`activities`作为资源，我们可能想要检索所有`users`资源，所有`activities`资源，通过ID的单个用户，或给定用户的全部活动。我们首先构建我们导航到每个预期资源的路径。
- en: 'Let''s consider the `users` resource. This is the collection of all users in
    the system and is sensibly located at the `/users` path. In terms of the route
    we''d create, our starting point would be the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑`users`资源。这是系统中所有用户的集合，并且合理地位于`/users`路径上。就我们创建的路由而言，我们的起点将是以下内容：
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, to access a single user within that collection, we'd require some means
    of keying into the `users` resource. Since we have defined an `ID` field associated
    with our `users` resource, we can uniquely identify a given user by their ID.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要访问该集合中的单个用户，我们需要一种方法来键入`users`资源。由于我们已经定义了一个与我们的`users`资源相关的`ID`字段，我们可以通过ID唯一地识别一个特定的用户。
- en: 'As such, we could envisage our `user-by-id` route looking very similar to the
    preceding route, with an additional parameter being passed. Our options for parameters
    are path parameters or query parameters. The distinction between the two being
    that `path` parameters are used when they uniquely identify a resource within
    a collection; `query` parameters are used to filter a resource by a property.
    As examples, we could have the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以设想我们的`user-by-id`路由看起来与前面的路由非常相似，只是多了一个参数。我们的参数选项是路径参数或查询参数。两者之间的区别在于，`path`参数用于它们在集合中唯一标识资源时；`query`参数用于通过属性过滤资源。例如，我们可以有以下内容：
- en: '[PRE37]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the first instance, we're requesting a single user having ID 123\. In the
    latter, we're filtering our `users` collection down to those whose first name
    is `David`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们请求ID为123的单个用户。在后一种情况下，我们过滤`users`集合，以包含那些名字为`David`的用户。
- en: 'With this knowledge in mind, we can take our public API and map each function
    to a `path` parameter where we''ll expose it in our web service:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解这些知识的基础上，我们可以将我们的公共API映射到每个函数，将其映射到`path`参数，我们将在网络服务中公开它：
- en: '[PRE38]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now that we''ve described each of the paths, we can see a natural grouping
    of `users`, `activities`, and `reports`. Compojure offers us a means of reflecting
    this grouping when we define our routes by using the `compojure.core/context`
    macro. For example, to group the `GET` and `POST` `/users` routes, we can do the
    following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经描述了每条路径，我们可以看到`用户`、`活动`和`报告`的自然分组。Compojure通过使用`compojure.core/context`宏定义我们的路由时，为我们提供了一种反映这种分组的方法。例如，为了将`GET`和`POST`
    `/users`路由分组，我们可以这样做：
- en: '[PRE39]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Not only have we created a shared path prefix for both routes, we also have
    the ability to destructure the request at the context level as well as the route
    level. If we had a shared query parameter, we could destructure it when we define
    the context, then make reference to it from any route within that context.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅为两个路由创建了一个共享的路径前缀，而且还有在上下文级别以及路由级别解构请求的能力。如果我们有一个共享的查询参数，我们可以在定义上下文时解构它，然后从该上下文中的任何路由引用它。
- en: Accessing path and query Parameters in Compojure
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Compojure 中访问路径和查询参数
- en: 'A request map is structured such that the `path` and `query` parameters are
    available via the :params key. We can, therefore, destructure the parameters we''re
    interested in as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 请求映射的结构使得 `path` 和 `query` 参数可以通过 `:params` 键访问。因此，我们可以解构我们感兴趣的参数如下：
- en: '[PRE40]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'However, Compojure offers some enhanced destructuring ability since parameters
    are some of the most common items to access within an incoming request. Using
    Compojure''s destructuring, we could rewrite the preceding route as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Compojure 提供了一些增强的解构能力，因为参数是访问传入请求中最常见的项目之一。使用 Compojure 的解构，我们可以将前面的路由重写如下：
- en: '[PRE41]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Notice that we've simply provided a vector containing the `id` symbol. Compojure
    then looks for an `id` key inside the `params` key of the incoming request map
    and makes the value available to us. Anything within the vector is automatically
    extracted from the value associated with the `:params` key and bound for use within
    the body of the route.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只是提供了一个包含 `id` 符号的向量。Compojure 然后在传入请求映射的 `params` 键中查找 `id` 键，并将值提供给我们。向量中的任何内容都会自动从与
    `:params` 键关联的值中提取出来，并在路由体中使用。
- en: 'Exercise 14.06: Integrating with an Application Layer'
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.06：与应用层集成
- en: In this exercise, we'll take the `packt-clj.fitness` backend along with the
    fitness database from the previous chapter and expand it such that we can ingest
    and query users and activities via a REST web service. We'll be reading data from
    an incoming body that is represented as an input stream. `slurp` is ideal in this
    case as it will open a reader on the stream and return the stream contents as
    a string. `slurp` also works on files, URIs, and URLs.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用上一章中的 `packt-clj.fitness` 后端和健身数据库，将其扩展到可以通過 REST 网络服务摄取和查询用户和活动。我们将从表示为输入流的传入体中读取数据。在这种情况下，`slurp`
    是理想的，因为它将在流上打开一个读取器，并将流内容作为字符串返回。`slurp` 也可以用于文件、URI 和 URL。
- en: 'Add the following dependencies to `packt-clj.fitness` in the `deps.edn` file:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `deps.edn` 文件中将以下依赖项添加到 `packt-clj.fitness` 中：
- en: '[PRE42]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a new namespace, `packt-clj.fitness.api`, with the following `requires`
    route:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的命名空间，`packt-clj.fitness.api`，并包含以下 `requires` 路由：
- en: '[PRE43]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Define our four routes for querying and persisting users, recalling that we
    can use a `context` to group routes that share a path prefix and/or reference
    the same `query` parameters:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们查询和持久化用户的四个路由，记住我们可以使用 `context` 来分组具有相同路径前缀和/或引用相同 `query` 参数的路由：
- en: '[PRE44]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Define the three activity-related routes within the preceding `defroutes` definition:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的 `defroutes` 定义中定义三个与活动相关的路由：
- en: '[PRE45]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to remember that our `body` is represented as a stream, meaning
    that it can only be read once. Any subsequent attempts to read from it will find
    it is already exhausted. Particular care should be taken when debugging not to
    read the body before it is actually utilized by the route. The same consideration
    should be made when writing middleware that interacts with the body.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要的是要记住，我们的 `body` 被表示为一个流，这意味着它只能读取一次。任何后续尝试读取它都会发现它已经耗尽。在调试时，应特别注意不要在路由实际使用之前读取
    `body`。在编写与 `body` 交互的中间件时也应考虑这一点。
- en: 'Now add our reporting route along with our catch-all `not-found` route:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加我们的报告路由以及我们的通配符 `not-found` 路由：
- en: '[PRE46]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create our `run` function, which will start our Jetty server, serving up the
    routes we''ve defined:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的 `run` 函数，该函数将启动我们的 Jetty 服务器，提供我们定义的路由：
- en: '[PRE47]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now let''s start the server and explore some of the endpoints we''ve created.
    Retrieve all users, then verify that we can retrieve a single user resource:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们启动服务器并探索我们创建的一些端点。检索所有用户，然后验证我们是否可以检索单个用户资源：
- en: '[PRE48]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output is as follows:'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 14.17: Retrieving all the users'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.17：检索所有用户'
- en: '](img/B14502_14_17.jpg)'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_14_17.jpg)'
- en: 'Figure 14.17: Retrieving all the users'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.17：检索所有用户
- en: 'Here is the output for retrieving a single user:'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是检索单个用户的输出：
- en: '![Figure 14.18: Retrieving a single user'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.18：检索单个用户'
- en: '](img/B14502_14_18.jpg)'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_14_18.jpg](img/B14502_14_18.jpg)'
- en: 'Figure 14.18: Retrieving a single user'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.18：检索单个用户
- en: 'Add a new user, an associated activity, then retrieve the list of activities
    that the user has taken part in:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新用户，一个相关联的活动，然后检索用户参与的活动列表：
- en: '[PRE49]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Browsing to `http://localhost:8080/users/4/activities`, the output is as follows:'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 浏览到 `http://localhost:8080/users/4/activities`，输出如下：
- en: '![Figure 14.19: Printing the final output'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.19：打印最终输出'
- en: '](img/B14502_14_19.jpg)'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_14_19.jpg](img/B14502_14_19.jpg)'
- en: 'Figure 14.19: Printing the final output'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.19：打印最终输出
- en: Note
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding user and activity IDs (`4` and `61`) are autogenerated and *will*
    vary if you have persisted any additional data before writing the two preceding
    records.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的用户和活动 ID (`4` 和 `61`) 是自动生成的，如果您在写入前两个记录之前持久化了任何其他数据，它们将会发生变化。
- en: Excellent. We've successfully taken our existing application layer and, with
    a small amount of code, made it accessible via a web browser or any other web
    client.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀。我们已经成功地将现有的应用层通过少量代码使其可通过网络浏览器或任何其他网络客户端访问。
- en: 'Activity 14.01: Exposing Historic Tennis Results and ELO Calculations via REST'
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 14.01：通过 REST 暴露历史网球结果和 ELO 计算
- en: The application layer delivered as part of `packt-clj.tennis` from *Chapter
    13*, *Database Interaction and the Application Layer*, has been well received.
    You have now been asked to make this more widely available via a REST web service.
    Of most interest is the ability to browse player data, tennis matches, and ELO
    changes over time. The ability to persist new tennis matches and recalculate the
    ELO has also been requested. The historic data should be assumed to be already
    available in our database.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 `packt-clj.tennis` 的一部分提供的应用层，在 *第 13 章*，*数据库交互和应用层* 中得到了良好的反响。现在您被要求通过 REST
    网络服务使其更广泛地可用。最有兴趣的是浏览球员数据、网球比赛和随时间变化的 ELO。还请求了持久化新的网球比赛和重新计算 ELO 的能力。应假定历史数据已经存在于我们的数据库中。
- en: Consider the public API of your application layer, determine the resources that
    you'd like to expose, then build your web service to expose those resources via
    a web client (either a browser or another HTTP client). Additional application
    layer functions will be required to support the routes we'll create.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑您应用层的公共 API，确定您想要公开的资源，然后构建您的网络服务，通过网络客户端（无论是浏览器还是其他 HTTP 客户端）公开这些资源。还需要额外的应用层函数来支持我们将创建的路由。
- en: 'These steps will help you to perform the activity:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助您执行活动：
- en: Add the required dependencies to your `deps.edn` file or equivalent.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所需的依赖项添加到您的 `deps.edn` 文件或等效文件中。
- en: Create the namespace, `packt-clj.tennis.api`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建命名空间，`packt-clj.tennis.api`。
- en: Define our `routes` parameters, adding a `players` context containing routes
    that expose all our player resources, an individual player using their unique
    ID, and all of the tennis matches that the player took part in. Wire these routes
    up to appropriate functions in the `query` namespace.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们的 `routes` 参数，添加一个包含路由的 `players` 上下文，这些路由公开了所有球员资源、使用其唯一 ID 的单个球员以及球员参加的所有网球比赛。将这些路由连接到
    `query` 命名空间中适当的函数。
- en: Create a `run` function that will start up a Jetty server on port `8080`, exposing
    our `routes` parameter, ensuring we use middleware to help us with content negotiation
    and rationalizing the location of parameters within our request map.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `run` 函数，该函数将在端口 `8080` 上启动 Jetty 服务器，公开我们的 `routes` 参数，确保我们使用中间件来帮助我们进行内容协商并合理化请求映射中参数的位置。
- en: Within our `players` context, add a route for returning the ELO of an individual
    player. Again, construct the appropriate `query` function to support this extraction.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `players` 上下文中，添加一个路由以返回单个球员的 ELO。同样，构建适当的 `query` 函数以支持此提取。
- en: Now add a `tennis-matches` context containing a route that exposes all matches,
    as well as individual matches by their unique ID.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个包含路由的 `tennis-matches` 上下文，该路由公开所有比赛以及通过其唯一 ID 的单个比赛。
- en: 'Retrieve the current ELO of `Pete Sampras` (ID: `s402`) and `Novak Djokovic`
    (ID: `d643`).'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索 `Pete Sampras`（ID：`s402`）和 `Novak Djokovic`（ID：`d643`）的当前 ELO。
- en: Within the `tennis-matches` context, add a route to create a new match using
    existing players. The persistence of the new match should recalculate the ELO
    of the players involved.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `tennis-matches` 上下文中，添加一个路由以使用现有球员创建一个新的比赛。新比赛的持久化应重新计算涉及球员的 ELO。
- en: 'Construct and persist a fictitious match between `Sampras` and `Djokovic` where
    `Djokovic` takes the win:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并持久化一场虚构的比赛，由 `Sampras` 和 `Djokovic` 进行，其中 `Djokovic` 获胜：
- en: '[PRE50]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Retrieve the updated ELO of `Sampras` (`s402`) and `Djokovic` (`d643`), expecting
    ELO of `Sampras` to decrease, while Djokovic's will have increased.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`Sampras`（`s402`）和`Djokovic`（`d643`）的更新后的ELO值，预期`Sampras`的ELO值将下降，而`Djokovic`的ELO值将上升。
- en: 'Here is the expected output:'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是预期的输出：
- en: '![Figure 14.20: Printing Sampras'' rating'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.20：打印Sampras的评级'
- en: '](img/B14502_14_20.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14502_14_20.jpg](img/B14502_14_20.jpg)'
- en: 'Figure 14.20: Printing Sampras'' rating'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.20：打印Sampras的评级
- en: '![Figure 14.21: Printing Djokovic''s rating'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.21：打印Djokovic的评级'
- en: '](img/B14502_14_21.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14502_14_21.jpg](img/B14502_14_21.jpg)'
- en: 'Figure 14.21: Printing Djokovic''s rating'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.21：打印Djokovic的评级
- en: Note
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 753.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第753页找到。
- en: Summary
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced us to HTTP, web servers, and the request-response interaction
    between a web server and a client. Multiple clients were introduced, including
    the most typical (the web browser) as well as `curl` and `clj-http`. We learned
    how a web server takes an incoming request and routes it according to key elements
    of the incoming request map, before constructing a response map, which is then
    presented to the requesting client.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了HTTP、Web服务器以及Web服务器与客户端之间的请求-响应交互。介绍了多个客户端，包括最典型的（Web浏览器）以及`curl`和`clj-http`。我们学习了Web服务器如何接收传入的请求，并根据传入请求映射的关键元素进行路由，然后构建响应映射，该映射随后呈现给请求的客户端。
- en: We learned about middleware and how it intercepts our request and/or response
    map. We then used `muuntaja` to format the content we generated for the client,
    as well as to format incoming data from the client as JSON or EDN.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了中间件及其如何拦截我们的请求和/或响应映射。然后我们使用`muuntaja`来格式化我们为客户端生成的内容，以及将来自客户端的数据格式化为JSON或EDN。
- en: After considering the content of our database in the context of groups of related
    resources, we learned how to construct appropriate paths to address them using
    a REST architecture. This paved the way for integrating our existing application
    layers with a web service that would allow any web client to interact with them
    over HTTP.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑我们数据库内容与相关资源组的关系时，我们学会了如何使用REST架构构建适当的路径来处理它们。这为我们现有的应用层与一个允许任何Web客户端通过HTTP与之交互的Web服务集成铺平了道路。
- en: We can now imagine a frontend (user interface) pulling resources from our web
    service, formatting them, and presenting them to a user who is then capable of
    manipulating those resources. In this case, the IDs (which are not particularly
    user-friendly) could be tracked by the UI and kept hidden from the users.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以想象一个前端（用户界面）从我们的Web服务中提取资源，格式化它们，并将它们呈现给用户，然后用户能够操作这些资源。在这种情况下，ID（它们并不特别用户友好）可以由UI跟踪，并从用户那里隐藏。
- en: We'll explore how to interact with our new service via ClojureScript in the
    next chapter.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章探讨如何通过ClojureScript与我们的新服务交互。
