<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Design Patterns Out There and Setting Up Your Environment</h1>
                </header>
            
            <article>
                
<p>In the world of computer programming, there are multiple ways to create a solution to a given problem. However, some might wonder whether there is a correct way of achieving a specific task. The answer is yes; there is always a right way, but in software development, there are usually multiple right ways to achieve a task. Some factors exist that guide the programmer to the right solution and, depending on them, people tend to get the expected result. These factors could define many things—the actual language being used, the algorithm, the type of executable produced, the output format, and the code structure. In this book, the language is already chosen for us—Scala. There are, however, a number of ways to use Scala, and we will be focusing on them—the design patterns.</p>
<p>In this chapter, we will explain what design patterns are and why they exist. We will go through the different types of design patterns that are out there. This book aims to provide useful examples to aid you in the learning process, and being able to run them easily is key. Hence, some points on how to set up a development environment properly will be given here. The top-level topics we will go through are as follows:</p>
<ul>
<li>What is a design pattern and why do they exist?</li>
<li>The main types of design patterns and their features</li>
<li>Choosing the right design pattern</li>
<li>Setting up a development environment in real life</li>
</ul>
<p>The last point doesn't have much to do with design patterns. However, it is always a good idea to build projects properly, as this makes it much easier to work in the future.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Design patterns</h1>
                </header>
            
            <article>
                
<p>Before delving into the Scala design patterns, we have to explain what they actually are, why they exist, and why it is worth being familiar with them.</p>
<p>Software is a broad subject, and there are innumerable examples of things people can do with it. At first glance, most of these things are completely different—games, websites, mobile phone applications, and specialized systems for different industries. There are, however, many similarities in how software is built. Many times, people have to deal with similar issues, no matter the type of software they create. For example, computer games, as well as websites, might need to access a database. And throughout time, by experience, developers learn how structuring their code differs for the various tasks that they perform.</p>
<div class="packt_infobox"><span class="packt_screen">The formal definition for design patterns</span><br/>
<br/>
A design pattern is a reusable solution to a recurring problem in software design. It is not a finished piece of code but a template that helps to solve a particular problem or family of problems.</div>
<p>Design patterns are best practices at which the software community has arrived over a period of time. They are supposed to help you write efficient, readable, testable, and easily extendable code. In some cases, they can be the result of a programming language not being expressive enough to elegantly achieve a goal. This means that more feature-rich languages might not even need a design pattern, while others still do. Scala is one of those rich languages, and in some cases, it makes the use of some design patterns obsolete or simpler. We will see how exactly it does that in this book.</p>
<p>The lack or existence of a certain functionality within a programming language also makes it able to implement additional design patterns that others cannot. The opposite is also valid—it might not be able to implement things that others can.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scala and design patterns</h1>
                </header>
            
            <article>
                
<p>Scala is a hybrid language that combines features from object-oriented and functional languages. This not only allows it to keep some of the well-known object-oriented design patterns relevant, but also provides various other ways of exploiting its features to write code that is clean, efficient, testable, and extendable all at the same time. The hybrid nature of the language also makes some of the traditional object-oriented design patterns obsolete, or possible, using other cleaner techniques.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The need for design patterns and their benefits</h1>
                </header>
            
            <article>
                
<p>Writing code without the conscious use of a design pattern is something many software engineers do. In the end, however, they either end up using one without realizing it, or they end up with code that can be improved in some way. As we mentioned earlier, design patterns help to write efficient, readable, extendable, and testable code. All these features are really important to companies in the industry.</p>
<p>Even though in some cases it is preferable to quickly write a prototype and get it out, it is more usually the case that a piece of software is supposed to evolve. Maybe you will have experience of extending some badly written code, but regardless, it is a challenging task and takes a really long time, and sometimes it feels that rewriting it would be easier. Moreover, this makes introducing bugs into the system much more likely.</p>
<p>Code readability is also something that should be appreciated. Of course, one could use a design pattern and still have their code hard to read, but generally, design patterns help. Big systems are usually worked on by many people, and everyone should be able to understand what exactly is going on. Also, people who join a team are able to integrate much more easily and quickly if they are working on a well-written piece of software.</p>
<p>Testability is something that prevents developers from introducing bugs when writing or extending code. In some cases, code could be created so badly that it is not even testable. Design patterns are supposed to eliminate these problems as well.</p>
<p>While efficiency is often connected with algorithms, design patterns could also affect it. A simple example could be an object that takes a long time to instantiate, and instances are used in many places in an application, but could be made a singleton instead. You will see more concrete examples in the later chapters of this book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Design pattern categories</h1>
                </header>
            
            <article>
                
<p>The fact that software development is an extremely broad topic leads to a number of things that can be done with programming. Requirements can vary greatly between different industries and engineering teams. These facts have caused many different design patterns to be invented. This is further contributed to by the existence of various programming languages with different features and levels of expressiveness.</p>
<p>This book focuses on the design patterns from the point of view of Scala. As we mentioned previously, Scala is a hybrid language. This leads us to a few famous design patterns that are not needed anymore—one example is the null object design pattern, which can simply be replaced by Scala's <kbd>Option</kbd>. Other design patterns become possible using different approaches—the decorator design pattern can be implemented using stackable traits. Finally, some new design patterns become available that are applicable specifically to the Scala programming language—the cake design pattern, pimp my library, and so on. We will focus on all of these and make it clear where the richness of Scala helps us to make our code even cleaner and simpler.</p>
<p>Even if there are many different design patterns, they can all be grouped in the following:</p>
<ul>
<li>Creational</li>
<li>Structural</li>
<li>Behavioral</li>
<li>Functional</li>
<li>Scala-specific design patterns</li>
</ul>
<p>Some of the design patterns that are specific to Scala can be assigned to the previous groups. They can either be additions or replacements of the already existing ones. They are typical to Scala and take advantage of some advanced language features or simply features not available in other languages.</p>
<p>The first three groups contain the famous <em>Gang of Four</em> design patterns. Every design pattern book covers them and so will we. The rest, even if they can be assigned to one of the first three groups, will be specific to Scala and functional programming languages. In the next few subsections, we will explain the main characteristics of the listed groups and briefly present the actual design patterns that fall under them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creational design patterns</h1>
                </header>
            
            <article>
                
<p>The creational design patterns deal with object creation mechanisms. Their purpose is to create objects in a way that is suitable to the current situation, which could lead to unnecessary complexity and the need for extra knowledge if they were not there. The main ideas behind the creational design patterns are as follows:</p>
<ul>
<li>Knowledge encapsulation about the concrete classes</li>
<li>Hiding details about the actual creation and how objects are combined</li>
</ul>
<p>We will be focusing on the following creational design patterns in this book:</p>
<ul>
<li>The abstract factory design pattern</li>
<li>The factory method design pattern</li>
<li>The lazy initialization design pattern</li>
<li>The singleton design pattern</li>
<li>The object pool design pattern</li>
<li>The builder design pattern</li>
<li>The prototype design pattern</li>
</ul>
<p>The following few sections give a brief definition of what these patterns are. They will be looked at in depth individually later in this book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The abstract factory design pattern</h1>
                </header>
            
            <article>
                
<p>This is used to encapsulate a group of individual factories that have a common theme. When used, the developer creates a specific implementation of the abstract factory and uses its methods in the same way as in the factory design pattern to create objects. It can be thought of as another layer of abstraction that helps to instantiate classes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The factory method design pattern</h1>
                </header>
            
            <article>
                
<p>This design pattern deals with the creation of objects without explicitly specifying the actual class that the instance will have—it could be something that is decided at runtime based on many factors. Some of these factors can include operating systems, different data types, or input parameters. It gives developers the peace of mind of just calling a method rather than invoking a concrete constructor.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The lazy initialization design pattern</h1>
                </header>
            
            <article>
                
<p>This design pattern is an approach to delay the creation of an object or the evaluation of a value until the first time it is needed. It is much more simplified in Scala than it is in an object-oriented language such as Java.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The singleton design pattern</h1>
                </header>
            
            <article>
                
<p>This design pattern restricts the creation of a specific class to just one object. If more than one class in the application tries to use such an instance, then this same instance is returned for everyone. This is another design pattern that can be easily achieved with the use of basic Scala features.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The object pool design pattern</h1>
                </header>
            
            <article>
                
<p>This design pattern uses a pool of objects that are already instantiated and ready for use. Whenever someone requires an object from the pool, it is returned, and after the user is finished with it, it puts it back into the pool manually or automatically. A common use for pools are database connections, which generally are expensive to create; hence, they are created once and then served to the application on request.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The builder design pattern</h1>
                </header>
            
            <article>
                
<p>The builder design pattern is extremely useful for objects with many possible constructor parameters that would otherwise require developers to create many overrides for the different scenarios an object could be created in. This is different to the factory design pattern, which aims to enable polymorphism. Many of the modern libraries today employ this design pattern. As we will see later, Scala can achieve this pattern really easily.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The prototype design pattern</h1>
                </header>
            
            <article>
                
<p>This design pattern allows object creation using a <kbd>clone()</kbd> method from an already created instance. It can be used in cases when a specific resource is expensive to create or when the abstract factory pattern is not desired.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Structural design patterns</h1>
                </header>
            
            <article>
                
<p>Structural design patterns exist in order to help establish the relationships between different entities in order to form larger structures. They define how each component should be structured so that it has very flexible interconnecting modules that can work together in a larger system. The main features of structural design patterns include the following:</p>
<ul>
<li>The use of composition to combine the implementations of multiple objects</li>
<li>Help build a large system made of various components by maintaining a high level of flexibility</li>
</ul>
<p>In this book, we will focus on the following structural design patterns:</p>
<ul>
<li>The adapter design pattern</li>
<li>The decorator design pattern</li>
<li>The bridge design pattern</li>
<li>The composite design pattern</li>
<li>The facade design pattern</li>
<li>The flyweight design pattern</li>
<li>The proxy design pattern</li>
</ul>
<p>The next subsections will put some light on what these patterns are about before we delve into them later in this book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The adapter design pattern</h1>
                </header>
            
            <article>
                
<p>The adapter design pattern allows the interface of an existing class to be used from another interface. Imagine that there is a client who expects your class to expose a <kbd>doWork()</kbd> method. You might have the implementation ready in another class, but the method is called differently and is incompatible. It might require extra parameters too. This could also be a library that the developer doesn't have access to for modifications. This is where the adapter can help by wrapping the functionality and exposing the required methods. The adapter is useful for integrating the existing components. In Scala, the adapter design pattern can be easily achieved using implicit classes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The decorator design pattern</h1>
                </header>
            
            <article>
                
<p>Decorators are a flexible alternative to sub classing. They allow developers to extend the functionality of an object without affecting other instances of the same class. This is achieved by wrapping an object of the extended class into one that extends the same class and overrides the methods whose functionality is supposed to be changed. Decorators in Scala can be built much more easily using another design pattern called <strong>stackable traits</strong>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The bridge design pattern</h1>
                </header>
            
            <article>
                
<p>The purpose of the bridge design pattern is to decouple an abstraction from its implementation so that the two can vary independently. It is useful when the class and its functionality vary a lot. The bridge reminds us of the adapter pattern, but the difference is that the adapter pattern is used when something is already there and you cannot change it, while the bridge design pattern is used when things are being built. It helps us to avoid ending up with multiple concrete classes that will be exposed to the client. You will get a clearer understanding when we delve deeper in the topic, but for now, let's imagine that we want to have a <kbd>FileReader</kbd> class that supports multiple different platforms. The bridge will help us end up with <kbd>FileReader</kbd>, which will use a different implementation, depending on the platform. In Scala, we can use self-types in order to implement a bridge design pattern.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The composite design pattern</h1>
                </header>
            
            <article>
                
<p>The composite is a partitioning design pattern that represents a group of objects that are to be treated as only one object. It allows developers to treat individual objects and compositions uniformly and to build complex hierarchies without complicating the source code. An example of composite could be a tree structure where a node can contain other nodes, and so on.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The facade design pattern</h1>
                </header>
            
            <article>
                
<p>The purpose of the facade design pattern is to hide the complexity of a system and its implementation details by providing the client with a simpler interface to use. This also helps to make the code more readable and to reduce the dependencies of the outside code. It works as a wrapper around the system that is being simplified and, of course, it can be used in conjunction with some of the other design patterns mentioned previously.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The flyweight design pattern</h1>
                </header>
            
            <article>
                
<p>The flyweight design pattern provides an object that is used to minimize memory usage by sharing it throughout the application. This object should contain as much data as possible. A common example given is a word processor, where each character's graphical representation is shared with the other same characters. The local information then is only the position of the character, which is stored internally.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The proxy design pattern</h1>
                </header>
            
            <article>
                
<p>The proxy design pattern allows developers to provide an interface to other objects by wrapping them. They can also provide additional functionality, for example, security or thread-safety. Proxies can be used together with the flyweight pattern, where the references to shared objects are wrapped inside proxy objects.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Behavioral design patterns</h1>
                </header>
            
            <article>
                
<p>Behavioral design patterns increase communication flexibility between objects based on the specific ways they interact with each other. Here, creational patterns mostly describe a moment in time during creation, structural patterns describe a more or less static structure, and behavioral patterns describe a process or flow. They simplify this flow and make it more understandable.</p>
<p>The main features of behavioral design patterns are as follows:</p>
<ul>
<li>What is being described is a process or flow</li>
<li>The flows are simplified and made understandable</li>
<li>They accomplish tasks that would be difficult or impossible to achieve with objects</li>
</ul>
<p>In this book, we will focus our attention on the following behavioral design patterns:</p>
<ul>
<li>The value object design pattern</li>
<li>The null object design pattern</li>
<li>The strategy design pattern</li>
<li>The command design pattern</li>
<li>The chain of responsibility design pattern</li>
<li>The interpreter design pattern</li>
<li>The iterator design pattern</li>
<li>The mediator design pattern</li>
<li>The memento design pattern</li>
<li>The observer design pattern</li>
<li>The state design pattern</li>
<li>The template method design pattern</li>
<li>The visitor design pattern</li>
</ul>
<p>The following subsections will give brief definitions of the aforementioned behavioral design patterns.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The value object design pattern</h1>
                </header>
            
            <article>
                
<p>Value objects are immutable and their equality is based not on their identity, but on their fields being equal. They can be used as data transfer objects, and they can represent dates, colors, money amounts, numbers, and more. Their immutability makes them really useful in multithreaded programming. The Scala programming language promotes immutability, and value objects are something that naturally occur there.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The null object design pattern</h1>
                </header>
            
            <article>
                
<p>Null objects represent the absence of a value and they define a neutral behavior. This approach removes the need to check for <kbd>null</kbd> references and makes the code much more concise. Scala adds the concept of optional values, which can replace this pattern completely.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The strategy design pattern</h1>
                </header>
            
            <article>
                
<p>The strategy design pattern allows algorithms to be selected at runtime. It defines a family of interchangeable encapsulated algorithms and exposes a common interface to the client. Which algorithm is chosen could depend on various factors that are determined while the application runs. In Scala, we can simply pass a function as a parameter to a method, and depending on the function, a different action will be performed.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The command design pattern</h1>
                </header>
            
            <article>
                
<p>This design pattern represents an object that is used to store information about an action that needs to be triggered at a later time. The information includes the following:</p>
<ul>
<li>The method name</li>
<li>The owner of the method</li>
<li>Parameter values</li>
</ul>
<p>The client then decides which commands need to be executed and when by the invoker. This design pattern can easily be implemented in Scala using the by-name parameters feature of the language.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The chain of responsibility design pattern</h1>
                </header>
            
            <article>
                
<p>The chain of responsibility is a design pattern where the sender of a request is decoupled from its receiver. This way, it makes it possible for multiple objects to handle the request and to keep logic nicely separated. The receivers form a chain where they pass the request and, if possible, they process it, and if not, they pass it to the next receiver. There are variations where a handler might dispatch the request to multiple other handlers at the same time. This somehow reminds us of function composition, which in Scala can be achieved using the stackable traits design pattern.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The interpreter design pattern</h1>
                </header>
            
            <article>
                
<p>The interpreter design pattern is based on the ability to characterize a well-known domain with a language with a strict grammar. It defines classes for each grammar rule in order to interpret sentences in the given language. These classes are likely to represent hierarchies as grammar is usually hierarchical as well. Interpreters can be used in different parsers, for example, SQL or other languages.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The iterator design pattern</h1>
                </header>
            
            <article>
                
<p>The iterator design pattern is when an iterator is used to traverse a container and access its elements. It helps to decouple containers from the algorithms performed on them. What an iterator should provide is sequential access to the elements of an aggregate object without exposing the internal representation of the iterated collection.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The mediator design pattern</h1>
                </header>
            
            <article>
                
<p>This pattern encapsulates the communication between different classes in an application. Instead of interacting directly with each other, objects communicate through the mediator, which reduces the dependencies between them, lowers the coupling, and makes the overall application easier to read and maintain.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The memento design pattern</h1>
                </header>
            
            <article>
                
<p>This pattern provides the ability to roll back an object to its previous state. It is implemented with three objects—<strong>originator</strong>, <strong>caretaker</strong>, and <strong>memento</strong>. The originator is the object with the internal state; the caretaker will modify the originator, and a memento is an object that contains the state that the originator returns. The originator knows how to handle a memento in order to restore its previous state.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The observer design pattern</h1>
                </header>
            
            <article>
                
<p>This design pattern allows the creation of publish/subscribe systems. There is a special object called subject that automatically notifies all the observers when there are any changes in the state. This design pattern is popular in various GUI toolkits and generally where event handling is needed. It is also related to reactive programming, which is enabled by libraries such as Akka. We will see an example of this towards the end of this book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The state design pattern</h1>
                </header>
            
            <article>
                
<p>This design pattern is similar to the strategy design pattern, and it uses a state object to encapsulate different behavior for the same object. It improves the code's readability and maintainability by avoiding the use of large conditional statements.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The template method design pattern</h1>
                </header>
            
            <article>
                
<p>This design pattern defines the skeleton of an algorithm in a method and then passes some of the actual steps to the subclasses. It allows developers to alter some of the steps of an algorithm without having to modify its structure. An example of this could be a method in an abstract class that calls other abstract methods, which will be defined in the children.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The visitor design pattern</h1>
                </header>
            
            <article>
                
<p>The visitor design pattern represents an operation to be performed on the elements of an object structure. It allows developers to define a new operation without changing the original classes. Scala can minimize the verbosity of this pattern compared to the pure object-oriented way of implementing it by passing functions to methods.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Functional design patterns</h1>
                </header>
            
            <article>
                
<p>We will be looking into all of the preceding design patterns from the point of view of Scala. This means that they will look different than in other languages, but they still haven't been designed specifically for functional programming. Functional programming is much more expressive than object-oriented programming. It has its own design patterns that help to make the life of a programmer easier. We will focus on:</p>
<ul>
<li>Monoids</li>
<li>Monads</li>
<li>Functors</li>
</ul>
<p>After we've looked at some Scala functional programming concepts, and we've been through these, we will mention some interesting design patterns from the Scala world.</p>
<p>A brief explanation of the preceding listed patterns will follow in the next few subsections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Monoids</h1>
                </header>
            
            <article>
                
<p>Monoid is a concept that comes from mathematics. We will take a look at it in more detail with all the theory needed to understand it later in this book. For now, it will be enough to remember that a monoid is an algebraic structure with a single associative binary operation and an identity element. Here are the keywords that you should remember:</p>
<ul>
<li>The associative binary operation. This means <kbd>(a+b)+c = a+(b+c)</kbd>.</li>
<li>The identity element. This means <kbd>a+i = i+a = a</kbd>. Here, the identity is <kbd>i</kbd>.</li>
</ul>
<p>What is important about monoids is that they give us the possibility to work with many different types of values in a common way. They allow us to convert pairwise operations to work with sequences; the associativity gives us the possibility for parallelization, and the identity element allows us to know what to do with empty lists. Monoids are great to easily describe and implement aggregations.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Monads</h1>
                </header>
            
            <article>
                
<p>In functional programming, monads are structures that represent computations as sequences of steps. Monads are useful for building pipelines, adding operations with side effects cleanly to a language where everything is immutable, and implementing compositions. This definition might sound vague and unclear, but explaining monads in a few sentences seems to be something hard to achieve. Later in this book, we will focus on them and try and clear things up without the use of a complex mathematical theory. We will try to show why monads are useful and what they can help with, as long as developers understand them well.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Functors</h1>
                </header>
            
            <article>
                
<p>Functors come from category theory, and as for monads, it takes time to explain them properly. We will look at functors later in this book. For now, you could remember that functors are things that can allow us to lift a function of the type <kbd>A =&gt; B</kbd> to a function of the type <kbd>F[A] =&gt; F[B]</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scala-specific design patterns</h1>
                </header>
            
            <article>
                
<p>The design patterns in this group could be assigned to some of the previous groups. However, they are specific to Scala and exploit some of the language features that we will focus on in this book, and so we've decided to place them in their own group.</p>
<p>We will focus our attention on the following:</p>
<ul>
<li>The lens design pattern</li>
<li>The cake design pattern</li>
<li>Pimp my library</li>
<li>Stackable traits</li>
<li>The type class design pattern</li>
<li>Lazy evaluation</li>
<li>Partial functions</li>
<li>Implicit injection</li>
<li>Duck typing</li>
<li>Memoization</li>
</ul>
<p>The next subsections will give you some brief information about these patterns before we properly study them later in this book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The lens design pattern</h1>
                </header>
            
            <article>
                
<p>The Scala programming language promotes immutability. Having objects immutable makes it harder to make mistakes. However, sometimes mutability is required and the lens design pattern helps us to achieve this nicely.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The cake design pattern</h1>
                </header>
            
            <article>
                
<p>The cake design pattern is the Scala way to implement dependency injection. It is something that is used quite a lot in real-life applications, and there are numerous libraries that help developers achieve it. Scala has a way of doing this using language features, and this is what the cake design pattern is all about.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Pimp my library</h1>
                </header>
            
            <article>
                
<p>Many times, engineers need to work with libraries, which are made to be as generic as possible. Sometimes, we need to do something more specific to our use case, though. The pimp my library design pattern provides a way to write extension methods for libraries, which we cannot modify. We can also use it for our own libraries as well. This design pattern also helps to achieve better code readability.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Stackable traits</h1>
                </header>
            
            <article>
                
<p>Stackable traits is the Scala way to implement the decorator design pattern. It can also be used to compose functions, and it's based on a few advanced Scala features.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The type class design pattern</h1>
                </header>
            
            <article>
                
<p>This design pattern allows us to write generic code by defining a behavior that must be supported by all members of a specific type class. For example, all numbers must support the addition and subtraction operations.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Lazy evaluation</h1>
                </header>
            
            <article>
                
<p>Often, engineers have to deal with operations that are slow and/or expensive. Sometimes, the result of these operations might not even be needed. Lazy evaluation is a technique that postpones the operation execution until it is actually needed. It could be used for application optimization.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Partial functions</h1>
                </header>
            
            <article>
                
<p>Mathematics and functional programming are really close together. As a consequence, some functions exist that are only defined for a subset of all the possible input values they can get. A popular example is the square root function, which only works for non-negative numbers. In Scala, such functions can be used to efficiently perform multiple operations at the same time or to compose functions.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implicit injection</h1>
                </header>
            
            <article>
                
<p>Implicit injection is based on the implicit functionality of the Scala programming language. It automatically injects objects whenever they are needed, as long as they exist in a specific scope. It can be used for many things, including dependency injection.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Duck typing</h1>
                </header>
            
            <article>
                
<p>This is a feature that is available in Scala and is similar to what some dynamic languages provide. It allows developers to write code that requires the callers to have some specific methods (but not implement an interface). When someone uses a method with a duck type, it is actually checked during compile time whether the parameters are valid.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Memoization</h1>
                </header>
            
            <article>
                
<p>This design pattern helps with optimization by remembering function results, based on the inputs. This means that as long as the function is stable and will return the same result when the same parameters are passed, one can remember its results and simply return them for every consecutive identical call.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Choosing a design pattern</h1>
                </header>
            
            <article>
                
<p>As we already saw, there are a huge number of design patterns. In many cases, they are suitable to be used in combinations as well. Unfortunately, there is no definite answer regarding how to choose the concept of designing our code. There are many factors that could affect the final decision, and you should ask yourselves the following questions:</p>
<ul>
<li>Is this piece of code going to be fairly static or will it change in the future?</li>
<li>Do we have to dynamically decide what algorithms to use?</li>
<li>Is our code going to be used by others?</li>
<li>Do we have an agreed interface?</li>
<li>What libraries are we planning to use, if any?</li>
<li>Are there any special performance requirements or limitations?</li>
</ul>
<p>This is by no means an exhaustive list of questions. There is a huge amount of factors that could dictate our decision in how we build our systems. It is, however, really important to have a clear <em>specification</em>, and if something seems missing, it should always be checked first.</p>
<p>In the rest of the chapters, we will try to give specific recommendations about when a design pattern should and should not be used. They should help you ask the right questions and take the right decision before going on and writing code.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up the development environment</h1>
                </header>
            
            <article>
                
<p>This book will aim to give real code examples for you to run and experiment with. As well as showing the most important code snippets in the pages of the book, you will have access to the code both from Packt Publishing as well as through GitHub for your convenience. The repository can be found at <a href="https://github.com/nikolovivan/scala-design-patterns-v2">https://github.com/nikolovivan/scala-design-patterns-v2</a>.</p>
<p>Having code examples means that it is important to be able to easily run any examples we have provided here and not to fight with the code. We will do our best to have the code tested and properly packaged, but you should also make sure that you have everything needed to run the examples.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing Scala</h1>
                </header>
            
            <article>
                
<p>Of course, you will need the Scala programming language. It does require Java to be installed, it evolves quickly, and the newest version can be found at <a href="https://www.scala-lang.org/download/">https://www.scala-lang.org/download/</a>. There are different ways of installing the language and you can choose whichever is the most comfortable for you. There are a few tips about how to install the language in your operating system at <a href="https://www.scala-lang.org/download/install.html">https://www.scala-lang.org/download/install.html</a>. As the official Scala website suggests, the easiest way to get started is to download an IDE (IntelliJ, for example), get the Scala plugin, and it will set things up for you. I will provide a couple of tips that have proven useful in my career that have enabled me to be very flexible while experimenting and learning.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Tips for installing Scala manually</h1>
                </header>
            
            <article>
                
<p>You can always download multiple versions of Scala and experiment with them. I use Linux and my tips will be applicable to Mac OS users, too. Windows users can also do a similar setup. Here are the steps:</p>
<ol>
<li>Install Scala under <kbd>/opt/scala-{version}/</kbd> or any other path you prefer.</li>
<li>Create a symlink using this command: <kbd>sudo ln -s /opt/scala-{version} scala-current</kbd>. This can make switching versions much easier, if you decide to experiment.</li>
<li>Add the path to the Scala <kbd>bin</kbd> folder to your <kbd>.bashrc</kbd> (or equivalent) file using the following lines:</li>
</ol>
<ul>
<li> <kbd>export SCALA_HOME=/opt/scala-current</kbd></li>
<li> <kbd>export PATH=$PATH:$SCALA_HOME/bin</kbd></li>
</ul>
<p>Now if you had defined a symlink and you decide to install another version of Scala, you could simply redefine the existing symlink and you can go on with your real work.</p>
<div class="packt_tip">If you don't want to go through the hassle of installing Scala manually or you find that you often switch to different versions of the language, SBT might be a more comfortable option.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Tips for installing Scala using SBT</h1>
                </header>
            
            <article>
                
<p class="mce-root">You can also experiment with any Scala version using SBT. To do this, you should:</p>
<ol>
<li class="mce-root">Download and install SBT: <a href="https://www.scala-sbt.org/download.html">https://www.scala-sbt.org/download.html</a>.</li>
<li class="mce-root">Open a Terminal and run <kbd>sbt</kbd>.</li>
<li class="mce-root">In the SBT shell, type <kbd>++ 2.12.4</kbd> or any version you want to try. Please note that if the currently used Scala version is not binary compatible with the one you want to use, you will have to modify the command to the following—<kbd>++ 2.12.4!</kbd>. Binary compatibility is very important in Scala and you should try and make sure they use libraries written in the same version of Scala as they use. Otherwise, you might get into trouble.</li>
<li class="mce-root">Issue the <kbd>console</kbd> command and you will be in a Scala shell running the version of your choice.</li>
</ol>
<div class="packt_infobox">All the examples in this book use SBT or Maven (depending on your preferences). They are build and dependency management tools, which means that you might not even need to do anything extra to install Scala. You can just import an example project and everything will be taken care of automatically.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scala IDEs</h1>
                </header>
            
            <article>
                
<p>There are multiple IDEs out there that support development in Scala. There is absolutely no preference about which one to use to work with the code. Some of the most popular ones are as follows:</p>
<ul>
<li>IntelliJ</li>
<li>Eclipse</li>
<li>NetBeans</li>
</ul>
<p>IntelliJ is currently the one recommended on the Scala website and probably the most used one at the time of writing. All of those IDEs use plugins to work with Scala, and downloading and using them should be straightforward.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dependency management</h1>
                </header>
            
            <article>
                
<p>Running most of the examples in this book will not require any additional dependencies in terms of special libraries. In some cases, though, we might need to show how a Scala code is unit tested, which will require us to use a testing framework. Also, we will later present some real-life use cases in which an additional library is used. Dealing with dependencies nowadays is done using specialized tools. They usually are interchangeable, and which one to use is a personal choice. The most popular tool used with Scala projects is SBT, but Maven is also an option, and there are many others out there as well. The former is normally used when a project is started from scratch and Scala is the main programming language. The latter could be useful in cases when the main language <span>used </span>is Java, for example, and we want to add modules written in Scala.</p>
<p>Modern IDEs provide the functionality to generate the required build configuration files, but we will give some generic examples that could be useful not only here, but in future projects. Depending on the IDE you prefer, you might need to install some extra plugins to have things up and running, and a quick Google search should help.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">SBT</h1>
                </header>
            
            <article>
                
<p><strong>SBT</strong> stands for <strong>Simple Build Tool</strong> and it uses the Scala syntax to define how a project is built, managing dependencies, and so on. It uses <kbd>.sbt</kbd> files for this purpose. It also supports a setup based on Scala code in <kbd>.scala</kbd> files, as well as a mix of both.</p>
<p>To download SBT, go to <a href="http://www.scala-sbt.org/1.0/docs/Setup.html">http://www.scala-sbt.org/1.0/docs/Setup.html</a> and follow the instructions. If you wish to obtain the newest version, then simply Google it and use the result you get back.</p>
<p>The following screenshot shows the structure of a skeleton SBT project:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/956023d8-04b8-4503-90b9-864a4408bd42.png" style="width:27.42em;height:27.33em;" width="463" height="462"/></div>
<p>It is important to show the contents of the main <kbd>.sbt</kbd> files.</p>
<p>The <kbd>version.sbt</kbd> file looks as follows:</p>
<pre>version in ThisBuild := "1.0.0-SNAPSHOT"</pre>
<p>It contains the current version that is automatically incremented if a release is made.</p>
<p>The <kbd>assembly.sbt</kbd> file has the following content:</p>
<pre>assemblyMergeStrategy in assembly := {<br/>   case PathList("javax", "servlet", xs @ _*)         =&gt; MergeStrategy.first<br/>   case PathList(ps @ _*) if ps.last endsWith ".html" =&gt; MergeStrategy.first<br/>   case "application.conf"                            =&gt; MergeStrategy.concat<br/>   case "unwanted.txt"                                =&gt; MergeStrategy.discard<br/>   case x =&gt;<br/>     val oldStrategy = (assemblyMergeStrategy in assembly).value<br/>     oldStrategy(x)<br/> }<br/> <br/> assemblyJarName in assembly := { s"${name.value}_${scalaVersion.value}-${version.value}-assembly.jar" }<br/> <br/> artifact in (Compile, assembly) := {<br/>   val art = (artifact in (Compile, assembly)).value<br/>   art.withClassifier(Some("assembly"))<br/> }<br/> <br/> addArtifact(artifact in (Compile, assembly), assembly)</pre>
<p>It contains information about how to build the assembly JAR—a merge strategy, final JAR name, and so on. It uses a plugin called <kbd>sbtassembly</kbd> (<a href="https://github.com/sbt/sbt-assembly">https://github.com/sbt/sbt-assembly</a>).</p>
<p>The <kbd>build.sbt</kbd> file is the file that contains the dependencies of the project, some extra information about the compiler, and metadata. The skeleton file looks as follows:</p>
<pre>organization := "com.ivan.nikolov"<br/> <br/> name := "skeleton-sbt"<br/> <br/> scalaVersion := "2.12.4"<br/> <br/> scalacOptions := Seq("-unchecked", "-deprecation", "-encoding", "utf8")<br/> <br/> javaOptions ++= Seq("-target", "1.8", "-source", "1.8")<br/> <br/> publishMavenStyle := true<br/> <br/> libraryDependencies ++= {<br/>   val sparkVersion = "2.2.0"<br/>   Seq(<br/>     "org.apache.spark" % "spark-core_2.11" % sparkVersion % "provided",<br/>     "com.datastax.spark" % "spark-cassandra-connector_2.11" % "2.0.5",<br/>     "org.scalatest" %% "scalatest" % "3.0.4" % "test",<br/>     "org.mockito" % "mockito-all" % "1.10.19" % "test" // mockito for tests<br/>   )<br/> }</pre>
<p>As you can see, here we define the Java version against which we compile some manifest information and the library dependencies.</p>
<p>The dependencies for our project are defined in the <kbd>libraryDependencies</kbd> section of our SBT file. They have the following format:</p>
<pre>"groupId" %[%] "artifactId" % "version" [% "scope"]</pre>
<p>If we decide to separate <kbd>groupId</kbd> and <kbd>artifactId</kbd> with <kbd>%%</kbd> instead of <kbd>%</kbd>, SBT will automatically use <kbd>scalaVersion</kbd> and append <kbd>_2.12</kbd> (for Scala 2.12.*) to <kbd>artifactId</kbd>. This syntax is usually used when we include dependencies written in Scala, as the convention there requires us to have the Scala version added as part of <kbd>artifactId</kbd>. We can, of course, manually append the Scala version to <kbd>artifactId</kbd> and use <kbd>%</kbd>. This is also done in cases when we import libraries written in a different major version of Scala. In the latter case, however, we need to be careful with binary compatibility. Of course, not all libraries will be written in the version we use, so we either have to thoroughly test them and make sure they won't break our application, change our Scala version, or look for alternatives.</p>
<div class="packt_infobox">
<p>The dependencies <span>shown </span>will not be needed at any point in this book (the one for Spark and the Datastax one). They are here just for illustration purposes, and you can safely remove them if not needed.</p>
<p>SBT requires each statement to be on a new line and to be separated with a blank line from the previous one if we work with <kbd>.sbt</kbd> files. When using <kbd>.scala</kbd> files, we just write code in Scala.</p>
<p>The <kbd>%%</kbd> syntax in the dependencies is a syntactic sugar, which, using <kbd>scalaVersion</kbd>, will replace the name of the library, for example, <kbd>scalatest</kbd> will become <kbd>scalatest_2.12</kbd> in our case.</p>
<p>SBT allows the engineer to express the same things differently. One example is the preceding dependencies—instead of adding a sequence of dependencies, we can add them one by one. The final result will be the same. There is also a lot of flexibility with other parts of SBT. For more information on SBT, refer to the documentation.</p>
</div>
<p>The <kbd>project/build.properties</kbd> defines the <kbd>sbt</kbd> version to be used when building and interacting with the application under <kbd>sbt</kbd>. It is as simple as the following:</p>
<pre>sbt.version = 1.1.0</pre>
<p>Finally, there is the <kbd>project/plugins.sbt</kbd> file that defines different plugins used to get things up and running. We already mentioned <kbd>sbtassembly</kbd>:</p>
<pre>addSbtPlugin("com.eed3si9n" % "sbt-assembly" % "0.14.5")</pre>
<div class="packt_tip">There are different plugins online that provide useful functionalities. Here are some common <kbd>sbt</kbd> commands that can be run from the root folder in the Terminal of this skeleton project:<br/>
<ul>
<li><kbd>sbt</kbd><span>: This opens the sbt console for the current project. All of the commands that will follow can be issued from here by omitting the <kbd>sbt</kbd> keyword.</span></li>
<li><kbd>sbt test</kbd><span>: This runs the application unit tests.</span></li>
<li><kbd>sbt compile</kbd><span>: This compiles the application.</span></li>
<li><kbd>sbt assembly</kbd><span>: This creates an assembly of the application (a fat JAR) that can be used to run as any other Java JAR.</span></li>
</ul>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Maven</h1>
                </header>
            
            <article>
                
<p>Maven holds its configuration in files named <kbd>pom.xml</kbd>. It supports multimodule projects easily, while for <kbd>sbt</kbd>, there needs to be some extra work done. In Maven, each module simply has its own child <kbd>pom.xml</kbd> file.</p>
<p>To download Maven, go to <a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a>.</p>
<p>The following screenshot shows the structure of a skeleton Maven project:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/829bcce5-0db0-49fc-b76f-e4a1a6ab855f.png" style="width:28.83em;height:21.08em;" width="450" height="329"/></div>
<p>The main <kbd>pom.xml</kbd> file is much longer than the preceding SBT solution. Let's have a look at its parts separately.</p>
<p>There is usually some metadata about the project and different properties that can be used in the POM files in the beginning:</p>
<pre>&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br/>&lt;groupId&gt;com.ivan.nikolov&lt;/groupId&gt;<br/>&lt;artifactId&gt;skeleton-mvn&lt;/artifactId&gt;<br/>&lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;<br/>&lt;properties&gt;<br/>    &lt;scala.version&gt;2.12.4&lt;/scala.version&gt;<br/>    &lt;scalatest.version&gt;3.0.4&lt;/scalatest.version&gt;<br/>    &lt;spark.version&gt;2.2.0&lt;/spark.version&gt;<br/>&lt;/properties&gt;</pre>
<p>Then, there are the dependencies:</p>
<pre>&lt;dependencies&gt;<br/>    &lt;dependency&gt;<br/>        &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;<br/>        &lt;artifactId&gt;spark-core_2.11&lt;/artifactId&gt;<br/>        &lt;version&gt;${spark.version}&lt;/version&gt;<br/>        &lt;scope&gt;provided&lt;/scope&gt;<br/>    &lt;/dependency&gt;<br/>    &lt;dependency&gt;<br/>        &lt;groupId&gt;com.datastax.spark&lt;/groupId&gt;<br/>        &lt;artifactId&gt;spark-cassandra-connector_2.11&lt;/artifactId&gt;<br/>        &lt;version&gt;2.0.5&lt;/version&gt;<br/>    &lt;/dependency&gt;<br/>    &lt;dependency&gt;<br/>        &lt;groupId&gt;org.scala-lang&lt;/groupId&gt;<br/>        &lt;artifactId&gt;scala-library&lt;/artifactId&gt;<br/>        &lt;version&gt;${scala.version}&lt;/version&gt;<br/>    &lt;/dependency&gt;<br/>    &lt;dependency&gt;<br/>        &lt;groupId&gt;org.scalatest&lt;/groupId&gt;<br/>        &lt;artifactId&gt;scalatest_2.12&lt;/artifactId&gt;<br/>        &lt;version&gt;${scalatest.version}&lt;/version&gt;<br/>        &lt;scope&gt;test&lt;/scope&gt;<br/>    &lt;/dependency&gt;<br/>    &lt;dependency&gt;<br/>        &lt;groupId&gt;org.mockito&lt;/groupId&gt;<br/>        &lt;artifactId&gt;mockito-all&lt;/artifactId&gt;<br/>        &lt;version&gt;1.10.19&lt;/version&gt;<br/>        &lt;scope&gt;test&lt;/scope&gt;<br/>    &lt;/dependency&gt;<br/>    &lt;dependency&gt;<br/>        &lt;groupId&gt;junit&lt;/groupId&gt;<br/>        &lt;artifactId&gt;junit&lt;/artifactId&gt;<br/>        &lt;version&gt;4.12&lt;/version&gt;<br/>        &lt;scope&gt;test&lt;/scope&gt;<br/>    &lt;/dependency&gt;<br/>&lt;/dependencies&gt;</pre>
<p>Finally, there are the build definitions. Here, we can use various plugins to do different things with our project and give hints to the compiler. The build definitions are enclosed in the <kbd>&lt;build&gt;</kbd> tags.</p>
<p>First, we specify some resources:</p>
<pre>&lt;sourceDirectory&gt;src/main/scala&lt;/sourceDirectory&gt;<br/>&lt;testSourceDirectory&gt;src/test/scala&lt;/testSourceDirectory&gt;<br/>&lt;resources&gt;<br/>    &lt;resource&gt;<br/>        &lt;directory&gt;${basedir}/src/main/resources&lt;/directory&gt;<br/>    &lt;/resource&gt;<br/>&lt;/resources&gt;</pre>
<p>The first plugin we have used is <kbd>scala-maven-plugin</kbd>, which is used when working with Scala and Maven:</p>
<pre>&lt;plugin&gt;<br/>    &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt;<br/>    &lt;artifactId&gt;scala-maven-plugin&lt;/artifactId&gt;<br/>    &lt;version&gt;3.3.1&lt;/version&gt;<br/>    &lt;executions&gt;<br/>        &lt;execution&gt;<br/>            &lt;goals&gt;<br/>                &lt;goal&gt;compile&lt;/goal&gt;<br/>                &lt;goal&gt;testCompile&lt;/goal&gt;<br/>            &lt;/goals&gt;<br/>        &lt;/execution&gt;<br/>    &lt;/executions&gt;<br/>    &lt;configuration&gt;<br/>        &lt;scalaVersion&gt;${scala.version}&lt;/scalaVersion&gt;<br/>    &lt;/configuration&gt;<br/>&lt;/plugin&gt;</pre>
<p>Another plugin we use is <kbd>maven-assembly-plugin</kbd>, which is used for building the fat JAR of the application:</p>
<pre>&lt;plugin&gt;<br/>    &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;<br/>    &lt;version&gt;3.1.0&lt;/version&gt;<br/>    &lt;configuration&gt;<br/>        &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;<br/>        &lt;descriptorRefs&gt;<br/>            &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;<br/>        &lt;/descriptorRefs&gt;<br/>    &lt;/configuration&gt;<br/>    &lt;executions&gt;<br/>        &lt;execution&gt;<br/>            &lt;id&gt;make-assembly&lt;/id&gt;<br/>            &lt;phase&gt;package&lt;/phase&gt;<br/>            &lt;goals&gt;<br/>                &lt;goal&gt;single&lt;/goal&gt;<br/>            &lt;/goals&gt;<br/>        &lt;/execution&gt;<br/>    &lt;/executions&gt;<br/>&lt;/plugin&gt;</pre>
<p>The complete <kbd>pom.xml</kbd> file is equivalent to the preceding <kbd>sbt</kbd> files that we presented.</p>
<p>As before, the Spark and Datastax dependencies are here just for illustration purposes.</p>
<div class="packt_tip"><span class="packt_screen">The use of JUnit to run unit tests in Scala 2.12</span><br/>
<br/>
If you look into the dependencies in more depth, you will see that we have imported <kbd>junit</kbd>, which is a Java testing framework. At first glance, someone might think that we don't actually need it. However, there is a catch. A quick Google search about how to run Scalatest unit tests with Maven would point to resources recommending the use of <kbd>scalatest-maven-plugin</kbd>. If we followed those instructions and tried running some tests from the command line, we would get a strange error. This is due to the fact that we used Scala 2.12 and the <kbd>scalatest-maven-plugin</kbd> at its current version is not binary compatible with this version of the language.<br/>
Like many things in software engineering, we have to find workarounds. Here, we could do two things:
<ul>
<li><span>Use an older version of Scala.</span></li>
<li><span>Force Maven to run our tests.</span><br/>
<span>Of course, the second option is the more desirable. This means that the only thing we need to do in each Scalatest we write is to add the following annotation to each test class: </span><kbd>@RunWith(classOf[JUnitRunner])</kbd><span> and make sure our test classes contain the word </span><kbd>Test</kbd><span> in their name.</span></li>
</ul>
</div>
<p>Similarly to SBT, you can use Maven from the command line. Some of the commands you might find most useful with the example projects in this book are shown in the next tip.</p>
<div class="packt_tip">Useful Maven commands:<br/>
<ul>
<li><kbd>mvn clean test</kbd><span>: This runs the application unit tests</span></li>
<li><kbd>mvn clean compile</kbd><span>: This compiles the application</span></li>
<li><kbd>mvn clean package</kbd><span>: This creates an assembly of the application (a fat JAR) that can be used to run as any other Java JAR</span></li>
</ul>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">SBT versus Maven</h1>
                </header>
            
            <article>
                
<p>In this book, we will be using both SBT and Maven for dependency management and creating our projects. They are interchangeable, and our source code will not depend on which build system we choose. You can easily translate the <kbd>.pom</kbd> files to <kbd>.sbt</kbd> files using the skeleton that we've provided. The only difference will really be the dependencies and how they are expressed.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>By now, we have a fair idea about what a design pattern means and how it can affect the way we write our code. We've iterated through the most famous design patterns out there, and we have outlined the main differences between them. We saw that in many cases, we could use Scala's features in order to make a pattern obsolete, simpler, or different to implement compared to the classical case for pure object-oriented languages. This book will show you how Scala makes it easier to write high-quality code.</p>
<p>Knowing what to look for when picking a design pattern is important, and you should already know what specific details to watch out for and how important specifications are.</p>
<p>Last but not least, we advise you to run the examples in this book, and we have provided some pointers that should make this really easy. In some cases, creating a complete solution using SBT or Maven might be too much hassle and somewhat unnecessary, but we believe it is a good practice to follow. Additionally, the approaches we explained are used throughout the industry and will be beneficial outside the scope of this book.</p>
<p>In the next chapter, we will get straight to the practical part of this book, where we will look at traits and mixing compositions, what they are useful for, and how and when to use them.</p>


            </article>

            
        </section>
    </div>



  </body></html>