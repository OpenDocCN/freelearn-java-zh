- en: '*Chapter 11*: jOOQ Keys'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Choosing the proper type of keys for our tables has a significant benefit on
    our queries. jOOQ sustains this statement by supporting a wide range of keys,
    from the well-known unique and primary keys to the fancy embedded and synthetic/surrogate
    keys. The most commonly used synthetic identifiers (or surrogate identifiers)
    are numerical or UUIDs. In comparison with natural keys, surrogate identifiers
    don't have a meaning or a correspondent in the real world. A surrogate identifier
    can be generated by a Numerical Sequence Generator (for instance, an identity
    or sequence) or by a Pseudorandom Number Generator (for instance, a GUID or UUID).
    Moreover, let me use this context to recall that in clustered environments, most
    relational databases rely on *numerical sequences* and different offsets per node
    to avoid the risk of conflicts. Use *numerical sequences* instead of UUIDs because
    they require less memory than UUIDs (a UUID requires 16 bytes, while `BIGINT`
    requires 8 bytes and `INTEGER` 4 bytes) and the index usage is more performant.
    Moreover, since UUIDs are not sequential, they introduce performance penalties
    at a clustered indexes level. More precisely, we will discuss an issue known as
    *index fragmentation*, which is caused by the fact that UUIDs are random. Some
    databases (for instance, MySQL 8.0) come with significant improvements in mitigating
    UUID performance penalties (there are three new functions – `UUID_TO_BIN`, `BIN_TO_UUID`,
    and `IS_UUID`) while other databases are still prone to these issues. As Rick
    James highlights, *"If you cannot avoid UUIDs (which would be my first recommendation)
    then..."* It is recommended to read his article ([http://mysql.rjweb.org/doc.php/uuid](http://mysql.rjweb.org/doc.php/uuid))
    for a deeper understanding of the main issues and potential solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let''s get back to our chapter, which will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetching a database-generated primary key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppressing a primary key return on updatable records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating a primary key of an updatable record
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using database sequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting a SQL Server IDENTITY
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching the Oracle ROWID pseudo-column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing composite primary keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with embedded keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with jOOQ synthetic objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding primary keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter11](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: Fetching the database-generated primary key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A typical scenario consists of fetching a database-generated (identity) primary
    key after an `INSERT` operation is executed via the `insertInto()`method or the
    updatable record''s `insert()`method. If you are using `insertInto()` (`DSL.insertInto()`
    or `DSLContext.insertInto()`), the database-generated primary key can be obtained
    via the `returningResult()`/`returning()` methods. For instance, the identity
    primary key of `SALE` is shaped in MySQL via `AUTO_INCREMENT`, in SQL Server via
    `IDENTITY`, and for historic reasons (because both now support standard SQL `IDENTITY`
    columns), in PostgreSQL and Oracle via database sequences. In all these cases,
    the generated identity primary key of `SALE` can be fetched as here (`SALE.SALE_ID`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, a convenient approach relies on the `getIdentity()` method,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this approach is useful when your table has a single identity column;
    otherwise, it is better to explicitly list the identities that should be returned.
    However, don''t get me wrong here – even if some databases (for example, PostgreSQL)
    support multiple identities, that is quite an unusual approach, which personally
    I don''t like to use, but I''ll cover it in this chapter. Also, check this tweet
    to get more details: [https://twitter.com/lukaseder/status/1205046981833482240](https://twitter.com/lukaseder/status/1205046981833482240).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the `insertedId` variable holds the database-generated primary key as
    a `Record1<Long>`. Getting the `long` value can be done via `fetchOne().value1()`
    or directly via `.fetchOneInto(long.class)`. The same practice is apparent for
    a bulk insert (a multi-record insert). This time, the generated primary keys are
    stored in `Result<Record1<Long>>` or `List<Long>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For a special case when we cannot provide an identity, jOOQ allows us to use
    the handy `lastID()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: However, the `lastID()` method has at least two shortcomings that deserve our
    attention. In a concurrent transactional environment (for instance, a web application),
    there is no guarantee that the returned value belongs to the previous `INSERT`
    statement, since a concurrent transaction can sneak another `INSERT` between our
    `INSERT` and the `lastID()` call. In such a case, the returned value belongs to
    the `INSERT` statement executed by the concurrent transaction. In addition, `lastID()`
    is not quite useful in the case of bulk inserts, since it returns only the last-generated
    primary key (but maybe this is exactly what you need).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are inserting an updatable record, jOOQ will automatically return the
    generated identity primary key and populate the updatable record field, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After insert, calling `sr.getSaleId()` returns the primary key generated by
    the database for this record. The same thing can be accomplished via jOOQ''s DAO
    while inserting a POJO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This time, jOOQ set the generated primary key in the inserted POJO. You can
    find these examples in the *Keys* bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: Suppressing a primary key return on updatable records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, you saw that jOOQ automatically fetches and sets the
    generated primary key for updatable records. Suppressing this action can be done
    via the `withReturnIdentityOnUpdatableRecord()` flag setting. In some dialects,
    a database round trip (the `lastID()` style) can be prevented, so this is mostly
    a performance feature. By default, this flag is `true`, but if we explicitly set
    it to `false`, then jOOQ will no longer attempt to fetch the generated primary
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This time, calling `sr.getSaleId()` returns `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a primary key of an updatable record
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a good practice, a primary key should never be updated anyway. But, who am
    I to judge?!
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, calling the `store()` method after changing (to a non-null value)
    the primary key of an updatable record previously loaded via jOOQ causes an `INSERT`
    statement to be executed. However, we can force jOOQ to generate and execute an
    `UPDATE` of the primary key via the `withUpdatablePrimaryKeys()` flag setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we can also update the primary key via an explicit `UPDATE`, and
    if you really have to do it, then go for this instead of a jOOQ flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: You can find these examples in the *Keys* bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: Using database sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To yield sequential numbers, databases such as PostgreSQL, SQL Server, and Oracle
    rely on sequences. A database sequence lives independently from tables – it can
    be associated with the primary key and non-primary key columns, it can be auto-generated
    (as in the case of PostgreSQL (`BIG`)`SERIAL`), it can be used across multiple
    tables, it can have independent permissions, it can have cycles, it can increment
    values in its own transactions to guarantee uniqueness across transactions using
    it, we can explicitly alter its values by setting minimum, maximum, increment,
    and current values, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s consider the following sequence (`employee_seq`), defined
    in our PostgreSQL schema for the `employee.employee_number` primary key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `employee_seq` sequence doesn''t produce sequence values automatically
    on your insertions, so the application must explicitly manipulate it. On the other
    hand, the `sale_seq` sequence produces sequence values automatically on your insertions,
    and it looks like the following code block (you''ll get an automatic value when
    the `SALE_ID` column is omitted from the `INSERT` statement or `DEFAULT` or `DEFAULT
    VALUES` is used; when users set `SALE_ID` to `NULL` explicitly, there''s going
    to be a constraint violation error):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'For each such sequence, the jOOQ Code Generator produces an `org.jooq.Sequence`
    instance in `Sequences` (take your time to check the `jooq.generated.Sequences`
    class). For `employee_seq`, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The jOOQ API exposes several methods for obtaining information about a sequence.
    Among them, we have the following suggested methods (you can find out more in
    the jOOQ documentation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides these methods, we have three more that are very useful in daily tasks
    –`currval()`, `nextval()`, and `nextvals()`. The first one (`currval()`) attempts
    to return the *current* value in the sequence. This can be obtained in a `SELECT`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The second one, `nextval()`, attempts to return the *next* value in the sequence.
    It can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is a `SELECT` statement that fetches both, the current and the next
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: A potential issue of using sequences consists of selecting `currval()` from
    the sequence before *initializing* it within your session by selecting `nextval()`
    for it. Commonly, when you are in such a scenario, you'll get an explicit error
    that mentions that `currval()` is not yet defined in this session (for instance,
    in Oracle, this is ORA-08002). By executing `INSERT` or calling `nextval()` (for
    instance, in `SELECT` as the previous one), you'll initialize `currval()` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the sequence can produce values automatically then the best way to insert
    a new record is to simply omit the primary key field. Since `sale_seq` can produce
    values automatically, an `INSERT` can be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The database will use `sale_seq` to assign a value to the `SALE_ID` field (the
    primary key of `SALE`). This is like using any other type of identity associated
    with a primary key.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: There is no need to explicitly call the `currval()` or `nextval()` method as
    long as you don't have a specific case that requires a certain sequence value
    from a sequence that is auto-generated (for example, from (`BIG`)`SERIAL`) or
    set as default (for example, as `NOT NULL DEFAULT NEXTVAL ("'sale_seq'")`). Simply
    omit the primary key field (or whatever field uses the sequence) and let the database
    generate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if the sequence cannot automatically produce values (for instance,
    `employee_seq`), then an `INSERT` statement must rely on an explicit call of the
    `nextval()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay attention to how you interpret and use the `currval()` and `nextval()`
    methods. Once you fetch a sequence value via `nextval()` (for instance, via `SELECT`),
    you can safely use it later in subsequent queries (`INSERT`) because the database
    will not give this value to other (concurrent) transactions. So, `nextval()` is
    safe to be used by multiple concurrent transactions. On the other hand, in the
    case of `currval()`, you have to be aware of some aspects. Check this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: So, between the previous `INSERT` and `SELECT` of the current value, another
    transaction can execute `INSERT`, and `currval()` is modified/incremented (generally
    speaking, another transaction performs an action that updates the current value).
    This means that there is no guarantee that `cr` holds the value of `SALE_ID` of
    our `INSERT` (`SALE_ID` and `cr` can be different). If all we need is to get `SALE_ID`
    of our `INSERT`, then the best approach is to rely on `returningResult(SALE.SALE_ID)`,
    as you saw in the *Fetching a database-generated primary key* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, attempting to use the fetched `currval()` in subsequent `UPDATE`,
    `DELETE`, and so on statements falls under the same statement. For instance, there
    is no guarantee that the following `UPDATE` will update our previous `INSERT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Another approach that should be avoided in a concurrent transactional environment
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if this looks like a single query statement, it is not. This is materialized
    in a `SELECT` of the current value followed by a `DELETE`. Between these two statements,
    a concurrent transaction can still perform an `INSERT` that alters the current
    value (or, generally speaking, any kind of action that modifies/advances a sequence
    and returns a new value). Also, pay attention to these kinds of queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'This renders a single `DELETE`, as shown here (the PostgreSQL dialect):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: This time, you definitely refer to the latest current value, whatever it is.
    For instance, this may result in deleting the latest inserted record (not necessarily
    by us), or it may hit a current value that is not associated with any record yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, performing multi-inserts or batch inserts can take advantage of
    inlined `nextval()` references or pre-fetch a certain number of values via `nextvals()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, `ids1`, `ids2`, and `ids3` hold in memory 10 values that can
    be used in subsequent queries. Until we exhaust these values, there is no need
    to fetch others. This way, we reduce the number of database round trips. Here
    is an example of a multi-insert:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'The pre-fetched values can be used to pre-set IDs of `Record` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: You can find these examples in the *Keys* bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a SQL Server IDENTITY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is not the first time in this book that we have talked about inserting
    SQL Server `IDENTITY` values, but let''s consider this section a must-have for
    this chapter. The problem consists of the fact that SQL Server doesn''t allow
    us to specify an explicit value for an `IDENTITY` field as the `PRODUCT` primary
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, the following `INSERT` statement will cause the following error
    – *Cannot insert explicit value for identity column in table ''product'' when
    IDENTITY_INSERT is set to OFF*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the solution to this error is contained in the message. We have to set
    `IDENTITY_INSERT` to `ON`. However, this should be done in the SQL Server *current
    session context*. In other words, we have to issue the settings of `IDENTITY_INSERT`
    and the actual `INSERT` statements in the same batch, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: This time, there is no issue with inserting it into the `IDENTITY` column. You
    can find these examples in the *Keys* (for SQL Server) bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching the Oracle ROWID pseudo-column
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are a fan of the Oracle database, then it is impossible not to have heard
    about the ROWID pseudo-column. However, as a quick reminder, the ROWID pseudo-column
    is associated with each row by Oracle, and its main goal is to return the address
    of the row. The information contained by ROWID can be used to locate a certain
    row. In jOOQ, we can refer to ROWID via the `rowid()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the following statement inserts a new `SALE` and fetches the
    generated primary key and the ROWID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rowid()` method returns a `String`, representing the value of ROWID (for
    instance, *AAAVO3AABAAAZzBABE*). We can use the ROWID for subsequent queries,
    such as locating a record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'However, as Lukas Eder shared: *"ROWIDs are not guaranteed to remain stable,
    so clients should never keep them around for long (for instance, outside of a
    transaction). But they can be useful to identify a row in a table without a primary
    key (for instance, a logging table)."*'
  prefs: []
  type: TYPE_NORMAL
- en: In the bundled code, *Keys* (for Oracle), you can also see an example of using
    `rowid()` in the `SELECT`, `UPDATE`, and `DELETE` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing composite primary keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By definition, a composite primary key involves two or more columns that should
    uniquely identify a record. A composite primary key is usually a natural key (even
    if it is composed of references to surrogate keys) and can often be preferable
    to surrogate keys in relationship tables: [https://blog.jooq.org/2019/03/26/the-cost-of-useless-surrogate-keys-in-relationship-tables/](https://blog.jooq.org/2019/03/26/the-cost-of-useless-surrogate-keys-in-relationship-tables/).
    This means that predicates based on composite keys must contain all the involved
    columns. For instance, the `PRODUCTLINE` table has a composite key as (`PRODUCT_LINE`,
    `CODE`), and we can write a predicate for fetching a certain record by chaining
    the fields of the composite key via `and()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can separate fields from values using `row()` (the `eq()`
    method doesn''t require an explicit `row()` constructor, so use it as you like):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `row()` is also useful in conjunction with `in()`, `notIn()`, and so
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Practically, in all these examples (available in *Keys*), you have to ensure
    that you don't forget any column of the composite key. This may become a struggle
    for composite keys containing more than two fields and/or in cases where the predicates
    involve more related conditions, and it is difficult to visually isolate the composite
    key fields.
  prefs: []
  type: TYPE_NORMAL
- en: A better approach is to employ embedded keys.
  prefs: []
  type: TYPE_NORMAL
- en: Working with embedded keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As part of the embeddable types introduced in [*Chapter 7*](B16833_07.xhtml#_idTextAnchor110),
    *Types, Converters, and Bindings,* we have jOOQ-embedded keys. An embedded key
    is materialized by the jOOQ Code Generator into the implementation of the jOOQ
    `org.jooq.EmbeddableRecord` interface and a handy POJO class. An embedded key
    extends the default implementation of the `org.jooq.EmbeddableRecord` interface,
    which is `org.jooq.impl.EmbeddableRecordImpl`.
  prefs: []
  type: TYPE_NORMAL
- en: We can define embedded keys for primary and unique keys. Practically, we indicate
    to jOOQ the primary/unique keys that should become embedded keys, and jOOQ will
    generate the corresponding artifacts for each primary/unique key, as well as for
    each foreign key referencing these primary/unique keys. Roughly, embedded keys
    mirror the primary/unique keys and the corresponding foreign keys in Java classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in order to employ embedded keys, we need the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Most probably, you'll not rely on a `.*` regular expression, since you'll not
    want to transform all your primary/unique keys into embedded keys. For instance,
    you may prefer to use embedded keys for composite keys only, so you have to use
    the proper regular expression for your case. Speaking about composite keys, how
    about creating an embedded key for the composite key of `PRODUCTLINE` (introduced
    in the previous section)?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Indicate to jOOQ that we are interested in the (`product_line`, `code`) primary
    key via `<embeddablePrimaryKeys>productline_pk</embeddablePrimaryKeys>`, where
    `productline_pk` represents the name of the constraint that defines our composite
    primary key (if you want to list multiple constraints/primary keys, then use `|`
    as a separator).
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'As a rule of thumb, it''s always a good idea to explicitly name your constraints.
    This way, you never have to bother with dealing with vendor-specific generated
    names and potential issues. If you are not convinced that you should always name
    your constraints, then I suggest you read this meaningful article: [https://blog.jooq.org/how-to-quickly-rename-all-primary-keys-in-oracle/](https://blog.jooq.org/how-to-quickly-rename-all-primary-keys-in-oracle/).'
  prefs: []
  type: TYPE_NORMAL
- en: However, notice that MySQL ignores the constraint names on the primary key and
    defaults all to `PRIMARY`. In such a case, you cannot refer to a composite primary
    key via the name of its constraint but instead as `KEY_tablename_PRIMARY`. For
    instance, instead of `productline_pk`, use `KEY_productline_PRIMARY`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, jOOQ is ready to generate the classes for this embedded key,
    but let''s take another action and customize the names of these classes. At this
    point, jOOQ relies on the default matcher strategy, so the names will be `ProductlinePkRecord.java`
    and `ProductlinePk.java`. But, we prefer `EmbeddedProductlinePkRecord.java` and
    `EmbeddedProductlinePk.java` respectively. As you already know, whenever we talk
    about renaming jOOQ things, we can rely on a configurative/programmatic matcher
    strategy and regular expressions (note that the `(?i:...)` directive is a thing
    to render the expression case-insensitive). In this case, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: Okay, so far, so good! At this point, the jOOQ Code Generator is ready to materialize
    our embedded key in `EmbeddedProductlinePkRecord.java` and `EmbeddedProductlinePk.java`.
    Also, jOOQ generates the `PRODUCTLINE_PK` field in the `Productline` class (see
    `jooq.generated.tables.Productline`), representing the embedded primary key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, the jOOQ Code Generator searches the foreign keys referencing our
    composite key, and it should find the following two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: For the `product_productline_fk` and `productlinedetail_productline_fk` constraints
    (of our foreign keys), jOOQ generates the `PRODUCT_PRODUCTLINE_FK` field in the
    `Product` class (see `jooq.generated.tables.Product`) and the `PRODUCTLINEDETAIL_PRODUCTLINE_FK`
    field in the `Productlinedetail` class (see `jooq.generated.tables.Productlinedetail`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s practice! For instance, let''s assume that we want to fetch the
    composite primary key of `PRODUCTLINE` and the creation date. Most probably, without
    using the embedded key, our `SELECT` statement will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: 'We know that `PRODUCT_LINE` and `CODE` form our composite key. However, for
    someone who is not very familiar with our schema, it will be more convenient and
    less risky to rely on the `PRODUCTLINE_PK` embedded key and write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, this is less verbose and much more expressive. There is no risk of
    forgetting a field of the composite key or mixing composite key fields with other
    fields (which just increases confusion), and we can add/remove a column from the
    composite key without modifying this code. Once we rerun the Code Generator, jOOQ
    will shape `PRODUCTLINE_PK` accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access data via getters, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, since the embedded key takes advantage of a generated POJO as well,
    we can fetch the composite key directly in the POJO. Look at how cool this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: The `EmbeddedProductlinePk` POJO exposes getters and setters to access the parts
    of the embedded composite key.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Embedded keys are the embeddable types most prone to overlapping. By default,
    jOOQ tries to elegantly solve each overlapping case to our benefit, but when the
    ambiguity cannot be clarified, jOOQ will log such cases, and it's your job to
    act accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go further and see other examples. For instance, searching a composite
    key in a certain collection of composite keys can be done, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, joining `PRODUCTLINE` and `PRODUCT` can be done, as shown here
    (both the primary and foreign keys produce the primary key record):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: Again, the code is less verbose and more expressive. However, more importantly,
    there is no risk of forgetting a column of the composite key in the join predicate.
    In addition, since both primary and foreign keys produce the primary key record,
    the predicate is valid only if we rely on matching primary/foreign key columns.
    This goes beyond type checking, since there is no risk of comparing wrong fields
    (for instance, fields that don't belong to the composite key but have the same
    type as the fields of the composite key).
  prefs: []
  type: TYPE_NORMAL
- en: 'As Lukas Eder mentioned: *"The type checking aspect is also interesting for
    single-column key types. With embeddable types, column types become "semantic,"
    and what would otherwise be two compatible Field<Long> columns no longer are compatible.
    So, specifically in the case of JOIN predicates, it will no longer be possible
    to accidentally compare the wrong columns in on(). This could even help detect
    a forgotten foreign key constraint."* ([https://twitter.com/anghelleonard/status/1499751304532533251](https://twitter.com/anghelleonard/status/1499751304532533251))'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a good opportunity to reflect on your favorite way to express the `JOIN`
    predicate with composite keys in jOOQ. The following figure summarizes several
    approaches, including a simple `and()`, using `row()`, an implicit join, a synthetic
    `onKey()`, and embedded keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – The JOIN predicate with composite keys'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – The JOIN predicate with composite keys
  prefs: []
  type: TYPE_NORMAL
- en: 'How about updating/deleting/inserting an embedded key? Well, these examples
    speak for themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: Practice these examples in *EmbeddedCompositeKeys* (for SQL Server and Oracle).
    Alternatively, if you prefer to start with embedded keys for simple primary keys,
    then you can check out the *EmbeddedSimpleKeys* application (for SQL Server and
    Oracle). Next, let's talk about jOOQ synthetic objects.
  prefs: []
  type: TYPE_NORMAL
- en: Working with jOOQ synthetic objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: jOOQ *synthetic objects* is a powerful and exciting feature introduced in version
    3.14 that reveals its full usability with database (updatable) views, databases
    that you cannot but want to alter, and legacy databases that have some *missing
    parts*. By *missing parts*, we mean identities, primary keys, unique keys, and
    foreign keys that simply don't exist, or do exist but are not enabled or reported
    by the database (and are not present in the database metadata). The jOOQ Code
    Generator can tackle this aspect by producing synthetic objects that emulate these
    *missing parts*. Let's adopt the learning by example technique to see how synthetic
    objects work.
  prefs: []
  type: TYPE_NORMAL
- en: Synthetic primary/foreign keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s consider that we have the following two database views (in PostgreSQL):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: Exactly as in the case of regular tables, jOOQ generates the corresponding records,
    tables, and POJOs for these views, so you'll have `CustomerMasterRecord` (a non-updatable
    record because the view is non-updatable) and `OfficeMasterRecord` (an updatable
    record because the view is updatable) in `jooq.generated.tables.records`, and
    `CustomerMaster` and `OfficeMaster` in `jooq.generated.tables` and `jooq.generated.tables.pojos`
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s indulgently assume that a triad (`country`, `state`, and `city`)
    uniquely identifies a customer and an office, and we want to find customers that
    are in the same area as an office. For this, we can write `LEFT JOIN`, as shown
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: Look at the `JOIN` statement's predicate! It is verbose and prone to mistakes.
    Moreover, if we modify (for instance, rename or remove) any of the columns involved
    in this predicate, then we have to adjust this predicate as well. However, there
    is nothing we can do, since a database view doesn't support primary/foreign keys,
    right? Actually, here is exactly where synthetic keys enter the scene. If jOOQ
    were able to give us a composite synthetic primary key for `OFFICE_MASTER` and
    a synthetic foreign key for `CUSTOMER_MASTER` referencing the `OFFICE_MASTER`
    synthetic primary key, then we could simplify and reduce the risk of mistakes
    in our `JOIN`. Practically, we could express our `JOIN` as an implicit `JOIN`
    or via `onKey()` exactly as in the case of regular tables.
  prefs: []
  type: TYPE_NORMAL
- en: However, remember that we said to *indulgently assume the uniqueness*. Note
    that we don't even need to make an assumption of uniqueness for the natural key
    (`country`, `state`, and `city`). Synthetic **primary keys/unique keys** (**PK/UK**)
    can even be used to enable some cool features for things that aren't actually
    candidate keys, or even unique. For example, there may be hundreds of reports
    that calculate stuff based on this "location relationship," and normalizing is
    not possible because this is a data warehouse, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going further, jOOQ synthetic keys are shaped at the configuration level. For
    Maven and standalone configuration, we need the following intuitive snippet of
    code that defines the `office_master_pk` synthetic composite primary key and the
    `office_master_fk` synthetic foreign key (you should have no problem understanding
    this code by simply following the tag''s name and its content in the context of
    previous database views):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: You can find the guidance for Gradle and the programmatic approach (which, in
    jOOQ style, is very intuitive as well) in the jOOQ manual.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, after running the jOOQ Code Generator, our `JOIN` can take advantage of
    the generated synthetic keys and be simplified via the synthetic `onKey()`, introduced
    in [*Chapter 6*](B16833_06.xhtml#_idTextAnchor093), *Tackling Different Kinds
    of JOIN Statements*. So, now we can write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: In comparison to the previous approach, this is less verbose, less prone to
    mistakes, and robust against subsequent modification of the columns involved with
    the synthetic key. Of course, you can use `onKey()` to write `INNER JOIN` and
    `RIGHT JOIN` statements and so on. However, without synthetic keys, the usage
    of `onKey()` leads to `DataAccessException` – *No matching Key found between tables
    ["classicmodels"."customer_master"] and ["classicmodels"."office_master"]*.
  prefs: []
  type: TYPE_NORMAL
- en: Even if `onKey()` works just fine, you'll most probably find synthetic `onKey()`,
    which can lead to ambiguities in complex `JOIN` graphs (or even in simple ones),
    implicit joins are always non-ambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, sticking to `LEFT JOIN`, the previous `JOIN` can be simplified and reinforced
    even more by adopting an implicit `JOIN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: So cool! There are no explicit columns in the join predicate, and we can modify
    the composite key without risks! Once we run the jOOQ Code Generator to reflect
    the changes, this code will work out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the implicit join example here might lead to a peculiar weirdness.
    Since this is a synthetic foreign key, and the synthetic primary key isn''t actually/truly
    unique (we''ve just indulgently assumed the uniqueness), projecting an implicit
    join path means that we might get a Cartesian Product just from the projection,
    which is very surprising in SQL. A projection should never affect the cardinality
    of the result, but here we are... Perhaps this is a good opportunity to explore
    the `UNIQUE()` predicate to check whether their "candidate" key is actually unique:
    [https://www.jooq.org/doc/latest/manual/sql-building/conditional-expressions/unique-predicate/](https://www.jooq.org/doc/latest/manual/sql-building/conditional-expressions/unique-predicate/).'
  prefs: []
  type: TYPE_NORMAL
- en: You can practice this example in *SyntheticPkKeysImplicitJoin*.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded keys for synthetic keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, let''s assume that we want to fetch some data from the `OFFICE_MASTER`
    table, based on a given set of `country`, `state`, and `city` triads. At this
    point, we can write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we know that (`country`, `state`, `city`) is actually our synthetic
    key. This means that if we define an embedded key for this synthetic key, then
    we should take advantage of embedded keys, exactly as we saw earlier in the *Working
    with embedded keys* section. Since the synthetic key name is `office_master_pk`,
    the embedded keys resume to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun the jOOQ Code Generator to generate the jOOQ artifacts corresponding
    to this embedded key, `OfficeMasterPkRecord`, and the `OfficeMasterPk` POJO. This
    time, we can rewrite our query, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, maybe we want to fetch an embedded key value in the `OfficeMasterPk`
    POJO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: How about a `JOIN`, using explicitly `OFFICE_MASTER_PK` and `OFFICE_MASTER_FK`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, maybe an update that has a predicate based on the embedded key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples in *EmbeddedSyntheticKeys* for PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Using navigation methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Furthermore, if we inspect the generated `jooq.generated.Keys`, we notice the
    following generated keys for `OFFICE_MASTER` and `CUSTOMER_MASTER`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: 'These keys are quite useful in conjunction with jOOQ navigation methods – `fetchParent()`,
    `fetchChildren()`, `fetchChild()`, and so on. These methods were introduced in
    [*Chapter 9*](B16833_09.xhtml#_idTextAnchor162), *CRUD, Transactions, and Locking*,
    and here are two examples of using them to navigate our views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples in *SyntheticPkKeysNavigation* for PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Synthetic unique keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we used a composite synthetic primary key built on
    the triad `country`, `state`, and `city`. However, if we look carefully, we notice
    that both views select `postal_code` as well. Since we don''t have two offices
    in the same city, we can consider that `postal_code` (which has `CONSTRAINT "office_postal_code_uk"
    UNIQUE ("postal_code")` in the `office` table) is a unique key for `office_master`
    (of course, in reality, you have to pay attention to such assumptions; maybe the
    best way to represent an address is via `BLOB`, but let''s continue with what
    we have). This means that we can use a synthetic unique key as well. By simply
    replacing the `<primaryKeys/>` tag with the `<uniqueKeys/>` tag, as shown here,
    we set up `postal_code` as a synthetic unique key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: The good news is that our `JOIN` statements that rely on synthetic keys will
    work out of the box, even if we switched from a composite synthetic primary key
    to a simple synthetic unique key. The bundled code is *SyntheticUniqueKeysImplicitJoin*
    for PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Synthetic identities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you saw earlier, jOOQ can fetch an identity primary key after executing
    an insert (via `insertInto()…returningResult(pk)` or inserting an updatable record).
    However, not all identity columns must be primary keys as well. For instance,
    our `PRODUCT` table from PostgreSQL has two identity columns – one is also the
    primary key (`PRODUCT_ID`), while the second one is just a simple identity column
    (`PRODUCT_UID`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: 'Fetching both identities via `insertInto() … returningResult(pk)` can be done
    quite easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no surprise here, since `returningResult()` instructs jOOQ to return
    all columns enlisted as an argument. However, inserting a record represents a
    more interesting case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: That's cool! Besides the identity primary key, jOOQ has also populated the record
    with the database-generated `PRODUCT_UID`. So, as long as the database reports
    a column as being an identity, jOOQ can detect it and act accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s next focus on our Oracle schema that defines the `PRODUCT` table,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: 'In this scenario, `insertInto() … returningResult()` works as excepted, but
    after inserting a `ProductRecord`, we get back only the identity primary key (`PRODUCT_ID`),
    while calling `getProductUid()` will return `null`. In other words, jOOQ detected
    only `PRODUCT_ID` as being a primary key column, while `PRODUCT_UID` was not reported
    by the database as being an identity column. However, here is where the jOOQ synthetic
    identities come to the rescue. Synthetic identities allow us to configure jOOQ
    to treat as formal identities those columns that are not reported by the database
    as being identities. In this particular case, `PRODUCT_UID` falls under this umbrella,
    so here is the jOOQ-expected configuration for Maven (and standalone):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: If you have multiple tables/identities, then enlist them, separated by `|` as
    regular expressions. This time, after running the Code Generator and inserting
    a new `ProductRecord`, jOOQ fetches both `PRODUCT_ID` (check it via `getProductId()`)
    and `PRODUCT_UID` (check it via `getProductUid()`, which should return a valid
    integer). Moreover, this works for Oracle versions where formal identity columns
    are emulated using sequences and triggers (prior to Oracle 12c). So, another cool
    feature of jOOQ has been revealed.
  prefs: []
  type: TYPE_NORMAL
- en: The bundled code samples are *DetectIdentity* (for PostgreSQL) and *SyntheticIdentity*
    (for Oracle).
  prefs: []
  type: TYPE_NORMAL
- en: Hooking computed columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *computed column* is a column that cannot be written to. Its value is computed
    from a given *expression*. When a column is computed on read (for instance, in
    `SELECT` statements) it is known as a `VIRTUAL` column (in DDL, such columns appear
    roughly expressed as `… GENERATED ALWAYS AS <expression> VIRTUAL` ). Typically,
    `VIRTUAL` columns don’t exist/appear in the database schema. On the other hand,
    a column that is computed on write (for instance, in `INSERT`, `UPDATE`, `MERGE`
    statements) is known as a `STORED` column (in DDL, some common syntax is `...
    GENERATED ALWAYS AS <expression> STORED`). Such columns exist/appear in your database
    schema.
  prefs: []
  type: TYPE_NORMAL
- en: Server side computed columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this context, jOOQ 3.16 added support for *server side computed columns*.
    jOOQ ‘s Code Generator is capable of detecting server side computed columns and
    marking them as *read-only* (https://www.jooq.org/doc/latest/manual/co[de-generation/codegen-advanced/codegen-config-database/codegen-database-readonly-columns/](http://de-generation/codegen-advanced/codegen-config-database/codegen-database-readonly-columns/)).
    In other words, for your convenience, such columns are automatically excluded
    from DML statements and occur only in `SELECT` statements. However, jOOQ allows
    us to fine tune read-only columns via a bunch of settings available at [https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/readonly-columns/](https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/readonly-columns/).
    Moreover, jOOQ supports *synthetic read-only columns*, which are recognized by
    jOOQ if we configure them via `<readonlyColumns/>`, `<readonlyColumn/>` tags (Maven).
    You can explore this very exciting topic in jOOQ documentation at [https://www.jooq.org/doc/latest/manual/code-generation/codegen-advanced/codegen-config-database/codegen-database-synthetic-objects/codegen-database-synthetic-readonly-columns/](https://www.jooq.org/doc/latest/manual/code-generation/codegen-advanced/codegen-config-database/codegen-database-synthetic-objects/codegen-database-synthetic-readonly-columns/),
    but for now, let’s get back to the computed columns topic.
  prefs: []
  type: TYPE_NORMAL
- en: So, not all dialects support server side computed columns or expressions based
    on scalar subqueries (even correlated ones), or implicit joins. jOOQ 3.17 comes
    with a powerful feature that covers these limitations, and this feature is known
    as *client side computed columns*.
  prefs: []
  type: TYPE_NORMAL
- en: Client side computed columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Check out the following configuration of a client side computed column (`VIRTUAL`
    alike):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: Because the forced type matches a synthetic column (`REFUND_AMOUNT`), jOOQ semantics
    stands for a `VIRTUAL` computed column. So, the column does not exist in the database
    schema, but the computation (here, an implicit join, but correlated subqueries
    is also a supported option) will be automatically present in all of your `SELECT`
    statements containing this column. In the bundled code available for SQL Server,
    *SyntheticComputedColumns*, you can see a query sample that uses the virtual column,
    `BANK_TRANSACTION.REFUND_AMOUNT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, check this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the forced type matches an actual column (`OFFICE.ADDRESS_LINE_FIRST`),
    so jOOQ applies the semantics of a `STORED` computed column. In other words, the
    DML statements will be transformed to reflect the correct computation of the value,
    which will be written to your schema. You can check out an example in the bundled
    code, *StoredComputedColumns*, available for SQL Server. Moreover, if you are
    able to, take the time to read this great article: [https://blog.jooq.org/create-dynamic-views-with-jooq-3-17s-new-virtual-client-side-computed-columns/](https://blog.jooq.org/create-dynamic-views-with-jooq-3-17s-new-virtual-client-side-computed-columns/).'
  prefs: []
  type: TYPE_NORMAL
- en: Overriding primary keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s consider the following schema fragment (from PostgreSQL):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of updating a `CUSTOMER`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of updating a `DEPARTMENT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: 'From [*Chapter 9*](B16833_09.xhtml#_idTextAnchor162), *CRUD, Transaction, and
    Locking*, we know how `store()` works; therefore, we know that the generated SQLs
    will rely on the `CUSTOMER` primary key and the `DEPARTMENT` primary key (the
    same behavior applies to `update()`, `merge()`, `delete()`, and `refresh()`).
    For instance, `cr.store()` executes the following `UPDATE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: Since `CUSTOMER_NUMBER` is the primary key of `CUSTOMER`, jOOQ uses it for appending
    the predicate to this `UPDATE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, `dr.store()` executes this `UPDATE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: 'Something doesn''t look right here, since our schema reveals that the primary
    key of `DEPARTMENT` is `DEPARTMENT_ID`, so why does jOOQ use here a composite
    predicate containing `DEPARTMENT_NAME` and `DEPARTMENT_PHONE`? This may look confusing,
    but the answer is quite simple. We actually defined a synthetic primary key (`department_name`
    and `department_phone`), which we reveal here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: That's cool! So, jOOQ has used the synthetic key in place of the schema primary
    key. We can say that we overrode the scheme's primary key with a synthetic key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do it again! For instance, let''s suppose that we want to instruct jOOQ
    to use the `customer_name` unique key for `cr.store()` and the `code` unique key
    for `dr.store()`. This means that we need the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: 'This configuration overrides the schema defaults, and the generated SQL becomes
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: Cool, right?! The complete example is named *OverridePkKeys* for PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I hope you enjoyed this short but comprehensive chapter about jOOQ keys. The
    examples from this chapter covered popular aspects of dealing with different kinds
    of keys, from unique/primary keys to jOOQ-embedded and synthetic keys. I really
    hope that you don''t stop at these examples and get curious to deep dive into
    these amazing jOOQ features – for instance, an interesting topic that deserves
    your attention is read-only columns: [https://www.jooq.org/doc/dev/manual/sql-building/column-expressions/readonly-columns/](https://www.jooq.org/doc/dev/manual/sql-building/column-expressions/readonly-columns/).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will tackle pagination and dynamic queries.
  prefs: []
  type: TYPE_NORMAL
