<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Future Directions</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>In the last chapter, we focused on best practices with some exciting utilities provided by the Java 9 platform. Specifically, we covered</span> <span>UTF-8 Property Files,</span> <span>Unicode 7.0.0,</span> <span>Linux/AArch64 port,</span>Â m<span>ulti-resolution images, and</span> c<span>ommon locale data repository.</span></p>
<p>This chapter provides an overview of the future development of the Java platform, beyond Java 9. We will look at what is planned for Java 10 and what further changes we are likely to see in the future. Each potential change to the Java platform will be characterized as targeted, submitted, or drafted. Targeted refers to changes that have been earmarked for Java 10. Submitted refers to a change that has been submitted but does not target a specific version of the Java platform. Changes that are drafted are still on the drawing board and are not ready to be submitted or designated as targeted.</p>
<p class="mce-root"/>
<p>Specifically, this chapter covers future changes to the Java platform grouped in the following categories:</p>
<ul>
<li>JDK changes</li>
<li>Java Compiler</li>
<li>Java Virtual Machine</li>
<li>JavaX</li>
<li>Special projects</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Future Changes to the JDK</h1>
                </header>
            
            <article>
                
<p>The Java Development Kit is at core of the Java platform and is continually being updated with new capabilities and efficiencies realized with each release. Looking beyond Java 9, we see a multitude of possible changes to the JDK. Many of these changes will be implemented in Java 10 and others might be saved for later releases.</p>
<p>The changes to the JDK in Java 10 and beyond are presented in the following proposal categories:</p>
<ul>
<li>Targeted for Java 10</li>
<li>Submitted Proposals</li>
<li>Drafted Proposals</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JDK changes targeted for Java 10</h1>
                </header>
            
            <article>
                
<p>At the time of this book's publication, the following listed <strong>Java Development Kit</strong> (<strong>JDK</strong>)-related changes were slated for inclusion in the Java 10 platform:</p>
<ul>
<li>Repository consolidation</li>
<li>Native-Header Tool Removal</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Repository consolidation</h1>
                </header>
            
            <article>
                
<p>The Java 9 platform consists of eight distinct repositories as depicted in the following diagram. In Java 10, we should see all of these repositories combined into a single repository:</p>
<div class="CDPAlignCenter CDPAlign"><img height="174" width="240" src="assets/c8b331a6-e0a4-4c43-849c-f6cfb85d0253.png"/></div>
<p>Repository consolidation should help streamline development. Moreover, it should increase the ease of maintaining and updating the Java platform.</p>
<div class="packt_infobox">You can get an early look at this repository at <a href="http://hg.openjdk.java.net/jdk10/consol-proto/">http://hg.openjdk.java.net/jdk10/consol-proto/</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Native-header tool removal</h1>
                </header>
            
            <article>
                
<p>The javah tool is used to generate C header files and C source files from Java classes. C programs can reference the generated header files and source files.</p>
<p>Here is a look at the life and death of t<span>he</span> javah <span>tool:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="257" width="322" src="assets/bb5e9476-4840-4f07-8d4c-ce659e98a143.png"/></div>
<p>As illustrated earlier, the javah tool was introduced with Java 7 and its functionality was included in the javac that came with JDK8. This functionality was reportedly superior compared to that of the original tool. In JDK 9, developers received warnings each time the javah tool was used, informing them of its pending removal from the JDK. The tool is slated for removal in JDK 10.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JDK-related submitted proposals</h1>
                </header>
            
            <article>
                
<p>The following Java Enhancement Proposals have been submitted, but have not yet been committed for delivery as part of the Java 10 platform. Oracle has set a two-year release plan, so it is safe to assume that, many if not all, of the proposals listed in this section and beyond have a chance of being part of the Java 10 platform:</p>
<ul>
<li><span>Parallelize the Full GC Phase in CMS</span></li>
<li><span>REST APIs for JMX</span></li>
<li><span>Support Heap Allocation</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parallelize the Full GC Phase in CMS</h1>
                </header>
            
            <article>
                
<p>In <a href="d29f6411-3e8f-4bd3-8ee9-1dc0314d8e75.xhtml">Chapter 7</a>, <em>Leveraging the New Default G1 Garbage Collector</em>, we reviewed the changes to the <strong>Concurrent Mark Sweep</strong> (<strong>CMS</strong>) garbage collector. CMS garbage collection involves scanning <span>heap memory, marking objects for removal and then making a sweep to actually remove those objects. The CMS method of garbage collection is essentially an upgraded "Mark and Sweep" method; which you can refer to <a href="d29f6411-3e8f-4bd3-8ee9-1dc0314d8e75.xhtml">Chapter 7</a>, <em>Leveraging the New Default G1 Garbage Collector</em></span>, <span>for additional</span> information.</p>
<p>The current downside to CMS garbage collection is that the serial mark and sweep is implemented using a single thread. This results in unwanted pause times. Currently, full garbage collection takes place in four phases:</p>
<ul>
<li><strong>Marking phase</strong>: Mark objects for collection</li>
<li><strong>Forwarding phase</strong>: Determine where live objects will be relocated</li>
<li><strong>Adjust pointer phase</strong>: Updates points based on new locations of live objects</li>
<li><strong>Compaction phase</strong>: Moves objects to designated locations</li>
</ul>
<p>The future plan for CMS is to implement the mark and sweep so they can be performed in parallel. The change is not to the garbage collection algorithm. Instead, each of the above listed phases will be parallelized. This will result in greater efficiencies for CMS garbage collection and hopefully eliminate, or significantly reduce, pause times.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">REST APIs for JMX</h1>
                </header>
            
            <article>
                
<p><strong>Representational State Transfer</strong> (<strong>REST</strong>), RESTful programming, and RESTful API use a client/server cacheable communications protocol, usually HTTP. REST is a common software architecture for developing networked applications.</p>
<p>One of the future changes to the Java platform is to provide RESTful web interfaces to MBeans.</p>
<div class="packt_infobox"><strong>Managed Bean</strong> (<strong>MBean</strong>) is an object in Java that represents a resource to be managed. These resources could include a specific hardware device, an application, a service, or other component.</div>
<p><span>The interfaces will permit MBeans to use the following HTTP methods:</span></p>
<ul>
<li><kbd>CONNECT</kbd></li>
<li><kbd>DELETE</kbd></li>
<li><kbd>GET</kbd></li>
<li><kbd>HEAD</kbd></li>
<li><kbd>OPTIONS</kbd></li>
<li><kbd>POST</kbd></li>
<li><kbd>PUT</kbd></li>
<li><kbd>TRACE</kbd></li>
</ul>
<p>MBeans are managed using <strong>Java Management Extensions</strong> (<strong>JMX</strong>). The JMX architecture has three levels, as depicted in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="208" width="269" src="assets/69a5ff4d-645f-4bb4-9ca1-9016659e564c.png"/></div>
<p>As you can see, the REST adapter is part of the <strong>Distributed Services</strong> level. That level contains both connectors and adapters. The connectors provide mirroring of agent level interfaces to remote clients. The adapters, on the other hand, convert the interfaces using a different protocol. The future change will be to transform the services at the <strong>Agent</strong> level to REST APIs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Support heap allocation</h1>
                </header>
            
            <article>
                
<p>A proposed future change is to allow developers to designate alternate memory devices for the Java heap. Specifically, the proposal is to permit developers to designate non-DRAM memory for the Java heap. This change takes advantage of the decreasing cost of memory and memory devices.</p>
<p>Implementation is likely to use an <kbd>AllocateHeapAt</kbd> flag.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JDK-related drafted proposals</h1>
                </header>
            
            <article>
                
<p>This section covers several JDK-related proposals that, at the time of this book's publication, were in the draft phase. That suggests they might not be fully analyzed or might even be cancelled. That being said, it is likely that each of these will move from drafted, to submitted, and then to targeted for the Java 10 platform.</p>
<p>Draft proposals covered in this section are as follows:</p>
<ul>
<li>Finalization promptness</li>
<li><span>Java memory model</span></li>
<li>Foreign function interface</li>
<li>Isolated methods</li>
<li>Reduce metaspace waste</li>
<li><span>Improve IPv6 support</span></li>
<li><span>Unboxed argument lists for method handles</span></li>
<li><span>Enhanced MandelblotSet Demo Using Value Types</span></li>
<li><span>Efficient Array Comparison Intrinsics</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Finalization promptness</h1>
                </header>
            
            <article>
                
<p>The Java language includes finalization to clean up objects that were unreachable by garbage collection. The proposed change is to make this process quicker and will require modifications to the following:</p>
<ul>
<li><kbd>ReferenceHandleThread</kbd></li>
<li><kbd>FinalizerThread</kbd></li>
<li><kbd>java.lang.ref.Reference</kbd></li>
</ul>
<p>Additional changes related to increasing the promptness of finalization includes the creation of a new API. The following graphic details how the API will be able to implement GC and runtime actions, and then inform that finalization needs to take place. This certainly should result in faster processing:</p>
<div class="CDPAlignCenter CDPAlign"><img height="198" width="538" src="assets/b7166659-6e03-4a2c-811f-3eae26bafe3c.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Java memory model</h1>
                </header>
            
            <article>
                
<p>There is a continuing effort to keep <strong>Java's memory model</strong> (<strong>JMM</strong>) updated. Current efforts are focused on several areas to include:</p>
<ul>
<li>Shared memory concurrency</li>
<li>JVM concurrency support</li>
<li>JDK components</li>
<li>Tools</li>
</ul>
<p>Expected results of JMM-related engineering efforts are as follows:</p>
<ul>
<li>Improved formalization</li>
<li>JVM voverage</li>
<li>Extended scope</li>
<li>C11/C++11 compatibility</li>
<li>Implementation guidance</li>
<li>Testing support</li>
<li>Tool support</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Foreign Function Interfaces</h1>
                </header>
            
            <article>
                
<p><strong>Foreign Function Interfaces</strong> (<strong>FFI</strong>) are software APIs that permits programs to call methods/functions from a program written in a different language. In an upcoming version of the JDK, we are apt to see an FFI that allows developers to call upon shared libraries and operating-system kernels directly from java methods. The proposed FFI will reportedly also enable developers to manage native memory blocks.</p>
<p>The new FFI will be similar to <strong>Java Native Access</strong> (<strong>JNA</strong>) and <strong>Java Native Runtime</strong> (<strong>JNR</strong>). JNA is a library that permits access to native shared libraries without having to use the <strong>Java Native Interface</strong> (<strong>JNI</strong>). JNR is a Java API that is used for calling native code. The proposed FFI will permit and optimize native method calls as well as optimized native memory management.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Isolated methods</h1>
                </header>
            
            <article>
                
<p>The <kbd>MethodHandles.Lookup</kbd> class is part of the <kbd>java.lang.invoke</kbd> package. We use lookup objects to create method handles and a lookup class to access them. Here is the header for the lookup class:</p>
<pre class="mce-root">    public static final class MethodHandles.Lookup extends Object</pre>
<p>Future changes to the <kbd>MethodHandles.Lookup</kbd> <span>class will support the loading of method</span> byte codes without the need for an attached class. Furthermore, these methods will be referenced using method handles. The class will have a new <kbd>loadCode</kbd> method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reducing metaspace waste</h1>
                </header>
            
            <article>
                
<p>Currently, when metaspace chunks are freed, they cannot be used as different sized chunks. So, if metaspace chunk A was freed and was of size X, that space cannot be reused for a metaspace chunk greater than or less than size X. This results in a tremendous amount of unusable metaspace waste. This can also lead to out-of-memory errors.</p>
<p>A future change to the JDK will resolve this issue by increasing the reuse of metaspace chunks. The change will support the following cases:</p>
<ul>
<li>Allow neighboring chunks to form a larger chunk</li>
<li>Allow larger chunks to be divided into smaller chunks</li>
</ul>
<p>This proposed change resolves the issue by ensuring smaller chunks can be reused and that larger chunks are not wasted as they can be split to support the reuse of smaller chunks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improving IPv6 support</h1>
                </header>
            
            <article>
                
<p><strong>Internet Protocol version 6</strong> (<strong>IPv6</strong>) is the current version of the Internet Protocol. The Internet Protocol provides the identification and location schema that enables Internet traffic routing. IPv6 is considered an Internet layer protocol that is sued by packet-switched networking.</p>
<p>The following diagram shows the history of the Internet Protocol:</p>
<div class="CDPAlignCenter CDPAlign"><img height="191" width="361" src="assets/b34a14d5-d47e-4114-91f0-a22cc1873f6c.png"/></div>
<p>IPv6 is the replacement for IPv4 and has several changes that the Java platform should support. Key IPv6 changes from IPv4 are categorized as follows:</p>
<ul>
<li>Jumbograms</li>
<li>Larger address space</li>
<li>Mobility</li>
<li>Multicasting</li>
<li>Network-layer security</li>
<li>Options extensibility</li>
<li>Privacy</li>
<li>Simplified router processing</li>
<li>Stateless address auto-configuration</li>
</ul>
<p>As the Internet continues to transition from IPv4 to IPv6, the following cases are possible and should all be supported in the Java 10 platform:</p>
<ul>
<li>Multiple versions of IPv4 exist</li>
<li>One version of IPv6 exists</li>
<li>Multiple versions of IPv6 exist</li>
<li>Multiple versions of IPv4 and one version of IPv6 exist</li>
<li>Multiple versions of IPv4 and IPv6 exist</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unboxed argument lists for method handles</h1>
                </header>
            
            <article>
                
<p>The way in which unboxed argument lists are currently handled can lead to processing inefficiencies. This is especially true when we use <kbd>Object[]</kbd> or <kbd>List&lt;object&gt;</kbd> as variable-length argument lists. Java uses <kbd>java.lang.invoke</kbd> to transform the method calls using boxing. In Java, autoboxing is when the compiler automatically converts primitive types and their corresponding object wrapper classes. Here is the list of wrapper classes along with the corresponding primitive type:</p>
<table>
<tbody>
<tr>
<td><strong>Wrapper class</strong></td>
<td><strong>Primitive type</strong></td>
</tr>
<tr>
<td>Boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>Byte</td>
<td>byte</td>
</tr>
<tr>
<td>Character</td>
<td>char</td>
</tr>
<tr>
<td>Double</td>
<td>double</td>
</tr>
<tr>
<td>Float</td>
<td>float</td>
</tr>
<tr>
<td>Integer</td>
<td>int</td>
</tr>
<tr>
<td>Long</td>
<td>long</td>
</tr>
<tr>
<td>Short</td>
<td>short</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>As you can see from the following illustration autoboxing occurs when we go from primitive values to an object of the associated wrapper class and, when we go from an object of a wrapper class to primitive values it is called unboxing:</p>
<div class="CDPAlignCenter CDPAlign"><img height="253" width="289" src="assets/0ce771a6-9308-4192-a19e-62412b5b7730.png"/></div>
<p>The inefficiencies are due to mismatches between the argument's list actual types and the array or list encasing them. In a future Java release, these inefficiencies will be removed. A new <kbd>ArgumentList</kbd> class will be added to the Java platform that polymorphically boxes valid arguments lists into a heap node.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enhanced MandelblotSet demo using value types</h1>
                </header>
            
            <article>
                
<p>This low priority Java Enhancement Proposal is likely to be implemented in Java 10 as its scope is limited. The plan is to develop a sample Java application that demonstrates improvements in memory and performance specific to using Valhalla project components, value types, and generics instead of primitive types.</p>
<div class="packt_infobox">Valhalla project components refer to user-defined custom immutable primitive types as value types.</div>
<p>You can read more about value types in the Java Virtual Machine section of this chapter.</p>
<p>A Mandelbrot set is a specific example of fractal mathematics used in chaos theory. The sample MandelbrotSet that accompanied JDK 8 provides a comparison of parallel and sequential data streams. In Java 10 or beyond, the sample MandelbrotSet will be updated to show performance and memory efficiencies between using Valhalla project components, value types and generics as opposed to primitive types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Efficient array comparison intrinsics</h1>
                </header>
            
            <article>
                
<p>A future change to the Java platform will be to include a method for comparing arrays. Currently, this is something developers have to code on their own. The change will be incorporated by adding something similar to the <kbd>compareTo</kbd> method in <kbd>java.util.Arrays</kbd>.</p>
<p>Although specifics are not available, the prospect of being able to compare arrays using native functionality is exciting. This is a component that will save many developers time. This is likely to be realized in the Java 10 platform release.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Future changes to the Java Compiler</h1>
                </header>
            
            <article>
                
<p>There are two notable draft changes to the Java platform, specifically the Java Compiler. These Java Enhancement Proposals are listed as follows and detailed in this section:</p>
<ul>
<li>Policy for retiring javac <kbd>-source</kbd> and <kbd>-target</kbd> options</li>
<li>Pluggable static analyzers</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Policy for retiring javac -source and -target options</h1>
                </header>
            
            <article>
                
<p>A formal draft proposal has been submitted to define a policy for retiring <kbd>-source</kbd> and <kbd>-target</kbd> options. This effort is to help reduce maintenance costs of the compiler. The <kbd>-source</kbd> and <kbd>-target</kbd> options were provided to ease development efforts, but not formally required by any standards. Starting with the Java 9 platform, these target options are not recognized.</p>
<p>The new policy is called "one plus three back" which means that the current version will be supported as well as the three previous releases. This policy will persist with JDK 10.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pluggable static analyzers</h1>
                </header>
            
            <article>
                
<p>An ongoing research Java Enhancement Proposal was initiated in the summer of 2013 as an exploratory measure and future support for a full Java Enhancement Proposal to empower developers to define extensions that can, at compile time, conduct the arbitrary static analysis. The research is to see how <span>a pluggable static type analyzer framework can be</span> implemented for the Java Compiler.</p>
<p>The goals of the research are as follows:</p>
<ul>
<li>Collect static analyzer requirements</li>
<li>Analyze static analyzers</li>
<li>Determine the requirements for a framework that supports static analyzers</li>
<li>Implement and test</li>
</ul>
<p>The final outcome of the ongoing research will be either to submit a feature Java Enhancement Proposal or to make the recommendation that pursuit of the feature cease.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Future Changes to the Java Virtual Machine</h1>
                </header>
            
            <article>
                
<p>Several new features and enhancements to the Java Virtual Machine (JVM) and core libraries have been submitted and drafted. It is likely that at least some of these features and enhancements will be realized in the Java 10 platform, and others will be saved for later releases.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JVM-related submitted proposals</h1>
                </header>
            
            <article>
                
<p>There are three Java Enhancement Proposals that have been submitted. While, not currently earmarked for Java 10, it is likely that we will see the changes when Java 10 is released. The three proposals are listed as follows:</p>
<ul>
<li><span>Container aware Java</span></li>
<li><span>Enable execution of Java methods on GPU</span></li>
<li><span>Epsilon GC: The arbitrarily low overhead gGarbage (non-) collector</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Container aware Java</h1>
                </header>
            
            <article>
                
<p>An effort is being made so the JVM and core libraries are aware when they are running in a container. Moreover, to be adaptive in the use of available system resources. This feature is especially relevant with the ubiquitous nature of cloud computing.</p>
<p>There are two major components of the proposed feature:</p>
<ul>
<li>Detection:
<ul>
<li>Determine if Java is running inside a container</li>
</ul>
</li>
<li>Container resource exposure:
<ul>
<li>Expose container resources limits</li>
<li>Expose container resource configuration</li>
</ul>
</li>
</ul>
<p>Several configuration status points have been initially identified:</p>
<table>
<tbody>
<tr>
<td><strong>General</strong></td>
<td><strong>CPU-related</strong></td>
<td><strong>Memory-related</strong></td>
</tr>
<tr>
<td><kbd>isContainerized</kbd></td>
<td>CPU Period</td>
<td>Block I/O Device Weight</td>
</tr>
<tr>
<td/>
<td>CPU <span>Quota</span></td>
<td>Block I/O Weight</td>
</tr>
<tr>
<td/>
<td>CPU Set Memory Nodes</td>
<td>Current Memory Usage</td>
</tr>
<tr>
<td/>
<td>CPU Sets</td>
<td><span>Device I/O Read Rate</span></td>
</tr>
<tr>
<td/>
<td>CPU Usage</td>
<td><span>Device I/O Write Rate</span></td>
</tr>
<tr>
<td/>
<td>CPU Usage Per CPU</td>
<td>Max Memory Usage</td>
</tr>
<tr>
<td/>
<td>Number of CPUs</td>
<td>Maximum Kernal Memory</td>
</tr>
<tr>
<td/>
<td/>
<td>Memory Swappiness</td>
</tr>
<tr>
<td/>
<td/>
<td>OOM Kill Enabled</td>
</tr>
<tr>
<td/>
<td/>
<td>OOM Score Adjustment</td>
</tr>
<tr>
<td/>
<td/>
<td>Shared Memory Size</td>
</tr>
<tr>
<td/>
<td/>
<td>Soft Memory Limit</td>
</tr>
<tr>
<td/>
<td/>
<td>Total Memory Limit</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>Initially, this feature is scheduled to support Docker on Linux-64. A likely scenario is that this feature be released with Java 10 with sole support for Docker on Linux-64. Then, feature support will be expanded in subsequent releases of the Java platform.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enable execution of Java methods on GPU</h1>
                </header>
            
            <article>
                
<p>Enabling the seamless ability for Java applications to take advantage of GPUs is the subject of project Sumatra. The goal is to use Java's Stream API in parallel and the lambda programming model. It makes great sense for us to exploit the processing power and efficiency of GPUs.</p>
<p>The overarching goal is to make this feature easy to use for developers. The feature will be implemented with the following characteristics:</p>
<ul>
<li>Do not change the syntax of the Java parallel stream API</li>
<li>Hardware and software stacks should be automatically detected</li>
<li>Automatic detection and analysis to determine if using the GPU makes sense from a performance standard</li>
<li>Provide CPU execution when offloading processing to a GPU fails</li>
<li>There will be no performance degradation</li>
<li>There will be no new security risks introduced by this feature</li>
<li>There will be memory persistence between the CPU and GPU</li>
</ul>
<p>The key benefit of this Java Enhancement Proposal will be performance improvements for our Java applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Epsilon GC - The arbitrarily low overhead garbage (non-) collector</h1>
                </header>
            
            <article>
                
<p>In <a href="d29f6411-3e8f-4bd3-8ee9-1dc0314d8e75.xhtml">Chapter 7</a>, <em>Leveraging the New Default G1 Garbage Collector</em>, we detailed the enhancements to Java's Garbage Collection with the release of the Java 9 platform. In the spirit of continuous improvement, a Java Enhancement Proposal has been submitted to develop a garbage collection to specifically handle memory allocation. This garbage collector will signal the JVM to shutdown when no more memory is available on the Java heap.</p>
<p>The goal is for this garbage collector to be passive and use very limited overhead. The introduction of this garbage collection is not intended to degrade performance.</p>
<p>This change will not impact current garbage collectors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JVM-related drafted proposals</h1>
                </header>
            
            <article>
                
<p>The following Java Enhancement Proposals have been drafted for a future version of the Java platform and are detailed in this section:</p>
<ul>
<li><span>Provide stable USDT probe points on JVM compiled methods</span></li>
<li>Concurrent Monitor Deflation</li>
<li>Low-overhead way of sampling Java heap allocations</li>
<li>Diagnostic Command Framework</li>
<li>Enhanced Class Redefinition</li>
<li>Enable NUMA mode by default when appropriate</li>
<li>Value objects</li>
<li>Align JVM Access Checks</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Provide stable USDT probe points on JVM compiled methods</h1>
                </header>
            
            <article>
                
<p><strong>User-level Statistically Defined Tracing</strong> (<strong>USDT</strong>) is used to insert probe points to mark the entry and exit of methods. Compilers then permit a handshake with tracing tools so that those tools can discover the probe points and manipulate them.</p>
<div class="packt_tip">Common tracing tools are Dtrace and <strong>Berkeley Packet Filters</strong> (<strong>BPF</strong>).</div>
<p>The Java Virtual Machine, even with JVM 9, does not support this technology set. The current lack of support stems from how the JVM generates compiled code; it does this dynamically without any static <strong>Executable Linkable Files</strong> (<strong>ELFs</strong>). Tracing tools need the ELFs to work. An additional mitigating factor is that the JVM dynamically patches its own generated code which does not support external patching.</p>
<p>In a future Java release, likely Java 10, the <strong>JVMTI</strong> (<strong>JVM Tools Interface</strong>) will be modified to support probe tools to perform their standard operations on the JVM's dynamically compiled code. Provisionally identified changes to JVMTI APIs include:</p>
<ul>
<li>Adding patch points or method entry and exit</li>
<li>The enumeration of the compiled methods</li>
<li>State change notifications on compiled method load</li>
<li>Query support</li>
<li>Toggle trace points on/off</li>
<li>Making chunks of compiled methods inspectable</li>
</ul>
<p>The good news is that there will not need to be any changes to how Java code is compiled. It can already be patched, so the required functionality will be created by modifying the USDT API as well as a few changes to the JVM.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Concurrent monitor deflation</h1>
                </header>
            
            <article>
                
<p>A monitor, in our context, is a synchronized mechanism that controls concurrent access to an object. Monitors help prevent multiple threads from accessing a monitored object at the same time. The JVM automatically switches between three monitor implementation methods. The three implementation methods are illustrated as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="263" width="319" src="assets/b68166a9-783d-4b9c-9ab9-d3fa74e08c06.png"/></div>
<p>The initial lock of a Java object uses biased locking. That method ensures only the locking thread can lock the object. With this approach, the JVM installs a thread pointer in the Java object. When a second thread attempts to lock the Java object, the JVM switches to the basic locking monitor implementation method. This second method uses <strong>compare-and-swap</strong> (<strong>CAS</strong>) operations. When a CAS operation fails, such as when a second thread attempt to lock the Java object, the JVM switches to the third monitor implementation method. That method is a full-blown monitor. This method requires native heap storage which is referred to as the monitor being inflated.</p>
<p>The purpose of the Concurrent Monitor Deflation Java Enhancement Proposal is to perform monitor deflation while the threads are running. This will decrease the JVM-induced pause times.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Provide a low-overhead way of sampling Java heap allocations</h1>
                </header>
            
            <article>
                
<p>Mismanagement of Java heaps can result in heap exhaustion, and insufficient memory due to memory fragmentation (GC thrashing). In a future release of Java, most likely Java 10, we will have a means of sampling Java heap allocations. This will be implemented by enhancing the <strong>Java Virtual Machine Tools Interface</strong> (<strong>JVMTI</strong>). The resulting functionality will provide an extremely low-overhead solution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Diagnostic Command Framework</h1>
                </header>
            
            <article>
                
<p>Java Enhancement Proposal 137, Diagnostic Command Framework, proposes a framework be created for sending diagnostic commands to the Java Virtual Machine.</p>
<p>The framework will include a <strong>Java Management Extension</strong> (JMX) interface, which will permit remote issuing of diagnostic commands via a JMX connection.</p>
<p>The JRocket Mission Control tools already have this feature successfully implemented. This served as proof of concept and it is therefore extremely likely that this enhancement will be part of the Java 10 platform.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enhanced Class Redefinition</h1>
                </header>
            
            <article>
                
<p><span>Java Enhancement Proposal 159, Enhanced Class Redefinition, calls for enhanced JVM capabilities in regards to class redefinition at runtime. Specifically the proposal includes the following class redefinition operations:</span></p>
<ul>
<li>Adding super types</li>
<li>Adding methods</li>
<li>Adding static fields</li>
<li>Adding instance fields</li>
<li>Removing methods</li>
<li>Removing static fields</li>
<li>Removing instance fields</li>
</ul>
<p>Current JVM class redefinition capabilities are limited to method swapping. This is viewed as extremely restrictive. With the new proposed enhancement, developers will not have to restart their applications after changes. This is especially beneficial when dealing with large and distributed systems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enable NUMA mode by default when appropriate</h1>
                </header>
            
            <article>
                
<p><span>Java Enhancement Proposal 163, enable NUMA mode by default when appropriate. This proposal is only applicable to NUMA hardware. The intent is to have the JVM enable the following flag when it detects NUMA hardware:</span></p>
<pre>    XX:+UseNUMA</pre>
<p>This flag can currently be evoked manually. With the proposed enhancement, it will be evoked automatically by the JVM when it has detected that it is running on a NUMA piece of hardware.</p>
<div class="packt_infobox"><strong>Non-Uniform Memory Access</strong> (<strong>NUMA</strong>) is a memory model used in computer multiprocessing. With this memory model, access time is dependent on the memory location relative to that of the processor.</div>
<p>This will be an easy enhancement to implement and is likely to be part of the Java 10 platform release.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Value objects</h1>
                </header>
            
            <article>
                
<p><span>Java Enhancement Proposal 169, value objects, intended to provide the necessary JVM infrastructure to permit working with objects that are immutable as well as objects that are without reference. This new infrastructure will allow for the efficient by-value computation with non-primitive data types.</span></p>
<p><span>The set of goals for this proposal include the following:</span></p>
<ul>
<li><span>More closely align <kbd>java.lang.Integer</kbd> and <kbd>int</kbd> semantics.</span></li>
<li><span>Make Java data structures more portable</span></li>
<li>Support abstract data types with a performance similar to that of Java primitive data types:
<ul>
<li>User-defined</li>
<li>Library-defined</li>
</ul>
</li>
<li>Optimize parallel computations by enabling function-style computation with pure data</li>
<li>Improve support for:
<ul>
<li>Complex numbers</li>
<li>Vector values</li>
<li>Tuples</li>
</ul>
</li>
<li>Increase safety and security</li>
<li>Decrease "defensive copying"</li>
</ul>
<p>One of the stated implementation strategies is to add a <kbd>lockPermanently</kbd> operation. It will get passed an Object and then mark that Object as both immutable and unaliasable. The concept of a permanently locked object stipulates that:</p>
<ul>
<li>Fields cannot be changed</li>
<li>Elements of an array cannot be changed</li>
<li>No synchronization is possible</li>
<li>'Waiting' methods cannot be evoked</li>
<li>'Notifying' methods cannot be evoked</li>
<li>Identity hash codes inquiries are not permitted</li>
<li>Pointer equality checks cannot be performed</li>
</ul>
<p>This is likely to be one of the more popular additions to the Java 10 platform.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Align JVM Access Checks</h1>
                </header>
            
            <article>
                
<p><span>Java Enhancement Proposal 181, Align JVM Checks with Java Language Rules for Nested Classes, focuses on the need to align JVM access checking rules with Java language rules, specifically for constructors, fields, and methods in nested classes. This will be accomplished by partitioning related classes in nests. Class files will be able to access private names of other class files in the same nest.</span></p>
<p>Nests will share an access control context. With the advent of nests, access bridges will not be required. The bulk of the change will be to the JVM's access rules.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Future Changes to JavaX</h1>
                </header>
            
            <article>
                
<p>The <kbd>Javax.*</kbd> packages are the subject of two specific Java Enhancement Proposals that have been submitted for a future Java platform release. Those proposals are as follows:</p>
<ul>
<li>JMX specific annotations for registration of managed resources</li>
<li>Modernize the GTK3 Look and Feel implementation</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JMX specific annotations for registration of managed resources</h1>
                </header>
            
            <article>
                
<p>The draft Java Enhancement Proposal titled, JMX specific annotations for registration of managed resources, will provide a set of annotations for registration and configuration of <strong>MBeans</strong> <span>(<strong>Managed Bean</strong>)</span>.</p>
<div class="packt_tip">An MBean is a Java Object representing a manageable resource (app, service, component, or device).</div>
<p>The goal of this proposal is to lessen the burden on developers in the registration and configuring of MBeans. In addition, the source code readability will increase by ensuring all MBean declaration components are co-located.</p>
<p>The JMX specific annotations will be located in the <kbd>javax.management.annotations</kbd> package.</p>
<p>This Java Enhancement Proposal has been specifically planned for Java 11. Although, there is a possibility that it could be redesigned for Java 10.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modernize the GTK3 Look and Feel Implementation</h1>
                </header>
            
            <article>
                
<p>GTK3 is a widget toolkit used for creating graphical user interfaces, formally known as the GIMP toolkit. The draft Java Enhancement Proposal titled, Modernize the GTK3 Look and Feel implementation, calls for the rewriting of the current GTK2 Look and Feel so that it uses GTK3 instead.</p>
<p>GTK3 implementation will not replace GTK2. It is important to note that one or the other, not both of these can be used at runtime.</p>
<div class="packt_infobox">You can access the GTK3 reference manual at <a href="https://developer.gnome.org/gtk3/stable/">https://developer.gnome.org/gtk3/stable/</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ongoing Special Projects</h1>
                </header>
            
            <article>
                
<p>Java Enhancement Proposals present design and implementation changes to the Java platform. The criteria for a JEP being drafted is that the work must meet at least one of the following:</p>
<ul>
<li>At least two weeks of engineering work</li>
<li>Signifies a significant change to the JDK</li>
<li>Represents a high demand issue for developers or customers</li>
</ul>
<p>Projects, on the other hand, represent collaborative efforts that are sponsored by one of the following groups:</p>
<ul>
<li>2D Graphics</li>
<li>Adoption</li>
<li>AWT</li>
<li>Build</li>
<li>Compatibility and specification review</li>
<li>Compiler</li>
<li>Conformance</li>
<li>Core Libraries</li>
<li>Governing Board</li>
<li>HotSpot</li>
<li>Internationalization</li>
<li>JMX</li>
<li>Members</li>
<li>Networking</li>
<li>NetBeans Projects</li>
<li>Porters</li>
<li>Quality</li>
<li>Security</li>
<li>Serviceability</li>
<li>Sound</li>
<li>Swing</li>
<li>Web</li>
</ul>
<p>Groups are formal and new ones can be proposed.</p>
<p>The following listed active projects represent possible future enhancement areas to the Java platform. Brief information about each project is provided later in this section and provides insight into general areas of future changes:</p>
<ul>
<li>Annotations pipeline 2.0</li>
<li>Audio Synthesis Engine</li>
<li>Caciocavallo</li>
<li><span><span>Common VM Interface</span></span></li>
<li>Compiler Grammar</li>
<li>Da Vinci Machine</li>
<li><span>Device I/O</span></li>
<li><span>Graal</span></li>
<li>HarfBuzz Integration</li>
<li>Kona</li>
<li>OpenJFX</li>
<li>Panama</li>
<li>Shenandoah</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Annotations pipeline 2.0</h1>
                </header>
            
            <article>
                
<p>This project explores improvements to how annotations are handled within the Java compiler pipeline. There is no intention to propose changing specifications; rather, the focus is on performance enhancements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Audio Synthesis Engine</h1>
                </header>
            
            <article>
                
<p>This project is looking at the creation of a new midi synthesizer for the JDK. The current midi synthesizer belongs to a licensed library. The working group would like to see the new midi synthesizer as an open source JDK asset.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Caciocavallo</h1>
                </header>
            
            <article>
                
<p>The Caciocavallo project aims to improve the OpenJDK <strong>Abstract Windows Toolkit</strong> (<strong>AWT</strong>) internal interfaces. This extends to 2D subsystems. The proposed improvement stands to ease the way AWT is ported to new platforms.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Common VM Interface</h1>
                </header>
            
            <article>
                
<p>The Common VM Interface project has the goal of documenting the VM interface for OpenJDK. This should make it easier for Classpath VMs and other VMs to use OpenJDK.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compiler Grammar</h1>
                </header>
            
            <article>
                
<p>The Compiler Grammar project is working on an experimental Java Compiler that is based on ANTLR grammar. <strong>ANTLR</strong>, <strong>Another Tool for Language Recognition</strong>, is a parser that reads, processes, and executes structured text or binary files. The project team hopes this Java Compiler will replace the current one as it uses a hand-written parser, <strong>LALR</strong> (<strong>Look-Ahead Left to Right</strong>). The LALR parser has been identified by the project group as fragile and difficult to extend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Da Vinci Machine</h1>
                </header>
            
            <article>
                
<p>The Da Vinci Machine Project, represents the effort to extend the JVM with support for non-Java languages. Current efforts are focused on allowing the new languages to e<span>xist alongside Java in</span> the <span>JVM. Performance and efficiency are key characteristics of the effort.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Device I/O</h1>
                </header>
            
            <article>
                
<p>This project intends to provide access to generic peripheral devices via a Java-level API. The initial list of peripheral devices the project team wants to support include:</p>
<ul>
<li><strong>GPIO</strong> (<strong>General Purpose Input/Output</strong>)</li>
<li><strong>I2C</strong> (<strong>Inter-Integrated Circuit Bus</strong>)</li>
<li><strong>SPI</strong> (<strong>Serial Peripheral Interface</strong>)</li>
<li><strong>UART</strong> (<strong>Universal Asynchronous Receiver/Transmitter</strong>)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Graal</h1>
                </header>
            
            <article>
                
<p>The Graal project has the goal of exposing VM functionality via Java APIs. This exposure will permit developers to write, in Java, dynamic compilers for a given language runtime. This effort includes the development of a multi-language interpreter framework.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HarfBuzz Integration</h1>
                </header>
            
            <article>
                
<p>The HarfBuzz Integration project hopes to integrate the HarfBuzz layout engine into the Java Development Kit. This is intended to replace the ICU layout engine with the HarfBuzz layout engine. The ICU layout engine has been deprecated, solidifying the importance of this project's future success.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Kona</h1>
                </header>
            
            <article>
                
<p>The Kona project, is working to define and implement Java APIs to support the <strong>Internet of Things</strong> (<strong>IoT</strong>) domain. This includes networking technologies and protocols. Although not stated, safety and security will be paramount to this effort's implementation success.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OpenJFX</h1>
                </header>
            
            <article>
                
<p>There are not many details available regarding the OpenJFX project. The stated goal of this project is to create the next-generation Java client toolkit. Based on the project title, it can be assumed that the group wants to create an OpenJFX version of JavaFX, which is a set of packages used to create rich internet applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Panama</h1>
                </header>
            
            <article>
                
<p>Project panama is focused on enhancing the connections between JVM and non-Java APIs. The project includes the following selected components:</p>
<ul>
<li>Native function calls</li>
<li>Native data access from JVM</li>
<li>Native data access inside JVM heap</li>
<li>New data layouts in JVM heap</li>
<li>API extraction tools for header files</li>
</ul>
<p>The project team has generated a repository tree that matches JDK 9's structure. This significantly increases the likelihood of the project's success.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Shenandoah</h1>
                </header>
            
            <article>
                
<p>Project Shenandoah has the goal of significantly reducing the pause times with garbage collection operations. The approach is to have more garbage collection operations run concurrently with the Java application. In <a href="d29f6411-3e8f-4bd3-8ee9-1dc0314d8e75.xhtml" target="_blank">Chapter 7</a>, <em>Leveraging the New Default G1 Garbage Collector</em> you read about CMS and G1. The Shenandoah project intends to add concurrent compaction to the possible garbage collection approaches.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter we provided an overview of the future developments of the Java platform, beyond Java 9. We looked at what is planned for Java 10 and what further changes we are likely to see beyond Java 10. Each potential change to the Java platform was characterized as targeted, submitted, or drafted. Specifically, we covered future changes to the Java platform grouped in the following categories: <span>JDK Changes,</span> <span>Java Compiler,</span> <span>Java Virtual Machine,</span> <span>JavaX, and</span> s<span>pecial projects.</span></p>


            </article>

            
        </section>
    </body></html>