<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using Build Tools and Testing Java Modules</h1>
                
            
            <article>
                
<p class="calibre2">In the previous chapter, we looked at several strategies and approaches to migrate an existing Java code base to Java 9. In this chapter, we'll wrap up our journey of Java 9 modularity by looking at two important topics that you are very likely to encounter, irrespective of whether you are migrating a legacy code base or creating a new modular application from scratch. They are build tool integration and unit testing.</p>
<p class="calibre2">Here's what we'll cover in this chapter:</p>
<ul class="calibre14">
<li class="calibre15">Integrating Java 9 modules with the Maven build process</li>
<li class="calibre15">Working with a multi-module Java 9 Maven project</li>
<li class="calibre15">Writing unit test cases for Java 9 modules using JUnit</li>
<li class="calibre15">Handling new access issues and challenges with testing in Java 9</li>
</ul>
<p class="calibre2">Considering that build systems and unit testing are extremely common and important parts of a modern Java developer's workflow, it may seem odd that we are tackling both these topics in the final chapter of this book. This is for a good reason. Understanding and working with these concepts requires an understanding of a lot of the topics we've covered in the last few chapters. Now that you have explored concepts such as open modules in <a target="_blank" href="part0134.html#3VPBC0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 9</a>, <em class="calibre22">Module Design Patterns and Strategies</em>, and automatic modules in <a href="part0172.html#5410O0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 11</a>, <em class="calibre22">Migrating Your Code to Java 9</em>, you are all set to tackle this chapter with ease!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Integrating with Apache Maven</h1>
                
            
            <article>
                
<p class="calibre2">Two of the build systems that are very commonly used in the Java landscape are Apache Maven and Gradle. When you are working on an enterprise Java application, it's very likely that you'll have to deal with one of these two options. In this book so far, we've been working with the command line to get the compiler and runtime to execute. However, that's rarely a reasonable thing to do in a complex project. So, what does it take to use such a build system in a Java 9 modular application?</p>
<div class="packt_infobox">At the time of writing this, Maven has a workable integration with Java 9, while Gradle is still in active development. Thus, we'll only be covering Apache Maven integration in this book. It's only a matter of time before the Java tooling ecosystem catches up to the modularity changes in Java 9, so it shouldn't be surprising to see better integration and an overall experience of using these tools with Java 9 over time.</div>
<p class="calibre2">Let's examine the way you can create a Maven project that contains and builds a Java 9 modular application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">A Maven refresher</h1>
                
            
            <article>
                
<p class="calibre2">This chapter assumes you are familiar with at least the basic concepts of Maven, but here is a quick refresher. Maven is, among other things, a project build tool. It is based on convention and provides a formal structure to organize your code, name your artifacts, and establish dependencies on other projects. This may sound very similar to what we've been doing with Java 9 modularity, but it isn't. Unlike the Java platform module system, Maven is concerned with building (or assembling) your artifacts, and not verifying compile time or runtime accuracy.</p>
<p class="calibre2">When you create a Maven artifact, you assign <em class="calibre22">coordinates</em> to it: the group name, the artifact name, and the version. You specify this in a file called <kbd class="calibre12">pom.xml</kbd>. This file also lets you specify dependencies on other Maven artifacts so that when the build process runs, Maven can fetch the necessary dependencies and make them available to the Java compiler or runtime.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using Maven with Java 9 modules</h1>
                
            
            <article>
                
<p class="calibre2">When you bring Java 9 modules into the picture, you can see that there are two parallel concepts of modules here: the Maven concept of an artifact with the definition in <kbd class="calibre12">pom.xml</kbd> and the Java platform concept of a module with the module definition in <kbd class="calibre12">module-info.java</kbd>. However, these two work surprisingly well when you collapse the two and have each Maven project containing one Java 9 module.</p>
<p class="calibre2">Consider the following folder structure of a single Maven project. The code is in the <span><kbd class="calibre12">lib</kbd> </span>folder. It is a typical Maven project. It has a <kbd class="calibre12">pom.xml</kbd> descriptor that contains the Maven coordinates for this artifact. However, it also has the module-info.java in the <kbd class="calibre12">src/main/java</kbd> folder that sets it up as a Java 9 module!</p>
<div class="packt_figure"><img class="image-border97" src="../images/00106.jpeg"/></div>
<p class="calibre2">With this approach, the idea is to create a Maven artifact for each Java 9 module. This means that you'll need to come up with two separate names:</p>
<ul class="calibre14">
<li class="calibre15">The coordinates for the Maven artifact--comprising of group name and artifact name</li>
<li class="calibre15">The name of the Java 9 module</li>
</ul>
<p class="calibre2">Now, when it comes to establishing dependencies between two of these modules, you will need to specify dependencies in two places. Let's say, for example, that you have two Maven Java 9 projects called <strong class="calibre1">A</strong> and <strong class="calibre1">B</strong>. In order to specify that A is dependent on B, you need to do the following:</p>
<ul class="calibre14">
<li class="calibre15">Add a <kbd class="calibre12">&lt;dependency&gt;</kbd> tag in the Maven <kbd class="calibre12">pom.xml</kbd> file of A specifying the Maven coordinates of B</li>
<li class="calibre15">Add a  <kbd class="calibre12">requires</kbd> declaration in the <kbd class="calibre12">module-info.java</kbd> file of A specifying the module name of B</li>
</ul>
<p class="calibre2">The advantage of this approach is that Maven takes care of fetching the necessary artifacts and placing them in the module path. Then, the Java platform module system has everything it needs when the compiler or runtime executes! Note that this doesn't work if you miss either one of these two dependency configurations. If you forget to specify the Maven dependency, Maven will not fetch the artifact and place it in the module path. If you forget to add the requires declaration in <kbd class="calibre12">module-info.java</kbd>, your code cannot access the types in the dependency, even though Maven has made it available in the module path.</p>
<p class="calibre2">While this works great for one or two modules, this can also get tricky to manage when you are dealing with an application consisting of multiple modules. In such situations, we can leverage the multi-module project feature of Maven to better organize multiple Maven + Java 9 modules.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Working on a multi-module Java 9 Maven project</h1>
                
            
            <article>
                
<p class="calibre2">Let's look at a sample Maven multi-module project. Let's say we want to build two Java modules: <kbd class="calibre12">packt.main</kbd> and <kbd class="calibre12">packt.lib</kbd>. The <kbd class="calibre12">packt.lib</kbd> module contains a library class <kbd class="calibre12">Lib</kbd> with a method called <kbd class="calibre12">sampleMethod</kbd>, and the <kbd class="calibre12">packt.main</kbd> module contains a class <kbd class="calibre12">App</kbd> with a main method calling <kbd class="calibre12">sampleMethod</kbd> from <kbd class="calibre12">Lib</kbd>. Thus, <kbd class="calibre12">packt.main</kbd> has to read <kbd class="calibre12">packt.lib</kbd>, as shown here:</p>
<div class="packt_figure"><img class="image-border98" src="../images/00107.jpeg"/></div>
<p class="calibre2">You've already learned that you should have one Maven project corresponding to each Java module. However, in order to ease the development, and to leverage the concept of a multi-module project in Maven, we can instead create a parent root Maven artifact. Now, both the modules of our application can be Maven child projects, as shown here:</p>
<div class="packt_figure"><img class="image-border99" src="../images/00108.jpeg"/></div>
<p class="calibre2">The code is available in the <kbd class="calibre12">12-build-tools-and-testing/01-maven-integration</kbd> folder. There is a root Maven module at the root directory. This module acts as a parent module. This is just a Maven container to facilitate the build process. We don't really need a corresponding Java module for this. Within the root folder are two child Maven projects <kbd class="calibre12">main</kbd> and <kbd class="calibre12">lib</kbd>.</p>
<p class="calibre2">Here, its <kbd class="calibre12">pom.xml</kbd> at the root (truncated for brevity):</p>
<pre class="calibre23">    &lt;project  ...&gt; 
     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; 
     &lt;groupId&gt;com.packt&lt;/groupId&gt; 
     &lt;artifactId&gt;root&lt;/artifactId&gt; 
     &lt;packaging&gt;pom&lt;/packaging&gt; 
     &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; 
     &lt;name&gt;root&lt;/name&gt; 
   
     &lt;modules&gt; 
       &lt;module&gt;main&lt;/module&gt; 
       &lt;module&gt;lib&lt;/module&gt; 
     &lt;/modules&gt; 
     ... 
    &lt;/project&gt; </pre>
<p class="calibre2">The packaging node in the XML specifies the pom value, indicating that this is a parent pom. It has two module declarations indicating the two Maven child modules that it is a parent to. Don't be confused by the use of the term modules here. We are talking about Maven modules, not Java 9 modules.</p>
<p class="calibre2">Within each child module, main and lib, it's just like we've seen so far. They are standard Maven projects, but with the <kbd class="calibre12">module-info.java</kbd> file in the <kbd class="calibre12">src/main/java</kbd> location making them Java 9 modules.</p>
<p class="calibre2">The following screenshot shows the complete folders structure:</p>
<div class="packt_figure"><img class="image-border100" src="../images/00109.jpeg"/></div>
<p class="calibre2">Since the main project is using a type from the lib project, both the Maven and Java dependencies are configured.</p>
<p class="calibre2">Here's the main project's <kbd class="calibre12">pom.xml</kbd> file specifying the dependency:</p>
<pre class="calibre23">    &lt;dependency&gt; 
      &lt;groupId&gt;com.packt&lt;/groupId&gt; 
      &lt;artifactId&gt;lib&lt;/artifactId&gt; 
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; 
    &lt;/dependency&gt; </pre>
<p class="calibre2">And here's its <kbd class="calibre12">module-info.java</kbd> file:</p>
<pre class="calibre23">    module packt.main { 
      requires packt.lib; 
    }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building the multi-module project</h1>
                
            
            <article>
                
<p class="calibre2">Before we build, make sure you have the latest version of Maven installed in your path. Running the following command should give you the Maven version that's installed on your machine:</p>
<pre class="calibre23"><strong class="calibre1">$ mvn -v 
  Apache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426;</strong><br class="title-page-name"/><strong class="calibre1">  2017-04-03T12:39:06-07:00)</strong> </pre>
<p class="calibre2">If you don't see this output, you'll need to download Apache Maven from <a href="https://maven.apache.org/plugins/maven-compiler-plugin/" class="calibre4">https://maven.apache.org</a> and add the <kbd class="calibre12">bin</kbd> folder on the download to your operating system's <kbd class="calibre12">PATH</kbd> variable.</p>
<p class="calibre2">Let's try to build this project. There are inclusions in the root project's <kbd class="calibre12">pom.xml</kbd> to make this ready to be built on Java 9. Following is the Maven compiler plugin used to set the Java version to 9:</p>
<pre class="calibre23">    &lt;plugin&gt; 
     &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; 
     &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; 
     &lt;version&gt;3.6.2&lt;/version&gt; 
     &lt;configuration&gt; 
       <strong class="calibre1">&lt;release&gt;9&lt;/release&gt;</strong> 
     &lt;/configuration&gt; 
    &lt;/plugin&gt; </pre>
<p class="calibre2">With this, you should be able to run Maven's build command and have the Java 9 compiler compile our classes. Switch to the <kbd class="calibre12">12-build-tools-and-testing/01-maven-integration/root</kbd> directory and run the following command:</p>
<pre class="calibre23"><strong class="calibre1">$ mvn clean install</strong> </pre>
<p class="calibre2">The output below, truncated for readability, indicates that all the modules have been compiled:</p>
<pre class="calibre23"><strong class="calibre1">[INFO] Reactor Summary: 
[INFO] 
[INFO] root ........................................ SUCCESS [  0.379 s] 
[INFO] lib ......................................... SUCCESS [  3.646 s] 
[INFO] main ........................................ SUCCESS [  0.195 s] 
[INFO] ----------------------------------------------------------------- 
[INFO] BUILD SUCCESS</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Executing the multi-module project</h1>
                
            
            <article>
                
<p class="calibre2">In order to execute the class with the  <kbd class="calibre12">main</kbd> method as a Maven lifecycle, we use the <kbd class="calibre12">exec-maven-plugin</kbd>. This is also possible thanks to the configuration in the root project's <kbd class="calibre12">pom.xml</kbd> file. Here's the listing that specifies this configuration:</p>
<pre class="calibre23">    &lt;plugin&gt; 
       &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; 
       &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; 
       &lt;version&gt;1.6.0&lt;/version&gt; 
       &lt;executions&gt; 
         &lt;execution&gt; 
            &lt;goals&gt; 
              &lt;goal&gt;exec&lt;/goal&gt; 
            &lt;/goals&gt; 
         &lt;/execution&gt; 
       &lt;/executions&gt; 
       <strong class="calibre1">&lt;configuration&gt; 
         &lt;executable&gt;${JAVA_HOME}/bin/java&lt;/executable&gt; 
         &lt;arguments&gt; 
           &lt;argument&gt;--module-path&lt;/argument&gt; 
           &lt;modulepath/&gt; 
           &lt;argument&gt;--module&lt;/argument&gt; 
           &lt;argument&gt;packt.main/com.packt.App&lt;/argument&gt; 
         &lt;/arguments&gt; 
       &lt;/configuration&gt;</strong> 
    &lt;/plugin&gt; </pre>
<p class="calibre2">As is typical with Maven configuration, this looks verbose. However, what's interesting for us is the configuration section. We are configuring the <kbd class="calibre12">java</kbd> command, so you have the executable path here mapped from <kbd class="calibre12">$JAVA_HOME</kbd>. We are also passing in the two arguments we should be very familiar with now--the <kbd class="calibre12">--module-path</kbd> argument indicating where the compiled modules are, and the <kbd class="calibre12">--module</kbd> indicating what's the module and class containing the main method.</p>
<p class="calibre2">Note that for the <kbd class="calibre12">--module-path</kbd> argument, we aren't specifying the path manually. This is because Maven is compiling the modules for us, so we want Maven itself to supply us with the path where it has placed the compiled classes. That is done using the special <kbd class="calibre12">&lt;modulepath /&gt;</kbd> tag. We'll discuss the module path in Maven in a bit more detail in the following section.</p>
<p class="calibre2">Switch to the <kbd class="calibre12">12-build-tools-and-testing/01-maven-integration/root/main</kbd> directory and run the following command to call the <kbd class="calibre12">exec</kbd> plugin:</p>
<pre class="calibre23"><strong class="calibre1">$ mvn exec:exec</strong> </pre>
<p class="calibre2">Here's the truncated output:</p>
<pre class="calibre23"><strong class="calibre1">[INFO] Scanning for projects... 
[INFO] 
[INFO] ------------------------------------------------------------------------ 
[INFO] Building main 1.0-SNAPSHOT 
[INFO] ------------------------------------------------------------------------ 
[INFO] 
[INFO] --- exec-maven-plugin:1.6.0:exec (default-cli) @ main --- 
Library method called! 
...</strong> </pre>
<p class="calibre2">The <kbd class="calibre12">Library method called!</kbd> line is the output of the  <kbd class="calibre12">main</kbd> method calling the library method and printing the message to the console.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding the exec plugin's module path</h1>
                
            
            <article>
                
<p class="calibre2">While there are several advantages to using Maven this way, one significant advantage is how easy it becomes to manage the directories during the compile and build step. When we ran <kbd class="calibre12">javac</kbd> manually, we always had to manually specify the <em class="calibre22">output</em> directory where all the compiled classes would go. When we ran <kbd class="calibre12">java</kbd>, we had to make sure the module path contained the output location of classes, as well as any dependent modules and libraries. Maven takes that work away from us. Thanks to the <kbd class="calibre12">&lt;modulepath/&gt;</kbd> line that we added as the module path argument to <kbd class="calibre12">exec-maven-plugin</kbd>, Maven automatically constructs the module path for us. Here's what Maven adds to the module path:</p>
<ul class="calibre14">
<li class="calibre15">It automatically includes the build location of the project. We ran the plugin on the <kbd class="calibre12">main</kbd> project. Maven makes sure the compiled classes from <kbd class="calibre12">main</kbd> are available in the module path.</li>
<li class="calibre15">It automatically makes sure the dependencies are in the module path as well. In the <kbd class="calibre12">main</kbd> project's <kbd class="calibre12">pom.xml</kbd>, we specified a dependency on <kbd class="calibre12">lib</kbd> . Maven acknowledges the dependency and automatically includes the complied <kbd class="calibre12">lib</kbd> module into the module path!</li>
<li class="calibre15">It automatically includes dependencies that aren't Java 9 modules too! Let's say your <kbd class="calibre12">pom.xml</kbd> file specifies a dependency on a third-party library that isn't migrated to Java 9 yet. Maven automatically adds those jars to the module path as well. Guess what happens when you add a pre-Java 9 JAR into the module path? They become automatic modules! Your modules can use the <kbd class="calibre12">requires</kbd> syntax to depend on them, just like any Java 9 module. Thus, your workflow becomes extremely simple and consistent when dealing with dependencies, be it Java 9 or older.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Unit testing modules with Java 9</h1>
                
            
            <article>
                
<p class="calibre2">The readability and accessibility constraints pose new and interesting problems when it comes to testing in Java 9. Let's look back at the way we've always been unit testing code in Java. Here are two common practices:</p>
<ul class="calibre14">
<li class="calibre15">The unit test code typically resides in a separate source folder that is added to the classpath. This is to separate the test code from the actual application code and to also make it easy to exclude the test folder when building an application for deployment.</li>
<li class="calibre15">The unit test classes typically share the same package as the class under test. This is to make sure the test classes can access the package-private members of the classes under test, even though they are in a completely different location.</li>
</ul>
<p class="calibre2">These two design decisions work well when classes are in the classpath, because we know that the physical location of the classes in the classpath doesn't matter. However, all that is changing with Java 9! Here's how:</p>
<ul class="calibre14">
<li class="calibre15">In Java 9, the test code could face access restrictions due to strong encapsulation. Your Java 9 classes under test are in a module. So, the only way to access all the types in your module from your test classes is to put your test classes in the same module as well! This is not ideal because, when you build and ship a Java module, the entire contents go with it. The only other option is to keep your test classes outside the module and only test the classes that are <em class="calibre22">exported</em>.</li>
<li class="calibre15">If you keep your tests in a separate folder and in a separate module, you cannot have your test classes share the same package as the classes under test. This will cause the split package problem since the same package exists in both the application module and the test module. Thus, you cannot access and test package-private members</li>
</ul>
<p class="calibre2">Considering these challenges, one way to work around them is as follows:</p>
<ul class="calibre14">
<li class="calibre15">Create a separate test module for every module you need to test.</li>
<li class="calibre15">Write test cases that test the exported module interface.</li>
<li class="calibre15">If you need to write tests for any internal types that aren't exported by the module, use <kbd class="calibre12">--add-exports</kbd> overrides during test execution. Yes, <kbd class="calibre12">--add-exports</kbd> isn't a good idea for application code, but it's a reasonable workaround for testing.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing a Java 9 module</h1>
                
            
            <article>
                
<p class="calibre2">Let's examine how this works by testing the <kbd class="calibre12">packt.sortutil</kbd> from the sample address book viewer application. The code is available at the <kbd class="calibre12">12-build-tools-and-testing/02-testing</kbd> location. The <kbd class="calibre12">src</kbd> folder contains the <kbd class="calibre12">packt.sortutil</kbd> module--the module under test.</p>
<p class="calibre2">To test this, we can create a new test module: <kbd class="calibre12">packt.sortutil.test</kbd>. A good convention to follow is to name the test modules with the name of the module being tested followed by <kbd class="calibre12">.test</kbd>. Here's the module definition for <kbd class="calibre12">packt.sortutil.test</kbd>:</p>
<pre class="calibre23">    module packt.sortutil.test { 
      requires packt.sortutil; 
    } </pre>
<p class="calibre2">By declaring the dependency on the module, you can access its exported types and test them through code. Here's a sample class in the test module that verifies that the output is accurate:</p>
<pre class="calibre23">    package packt.util.test; 
    public class SortUtilTestMain { 
      public static void main(String[] args) { 
        SortUtil sortUtil = new SortUtil(); 
        List out = sortUtil.sortList(Arrays.asList("b", "a", "c")); 
        assert out.size() == 3; 
        assert "a".equals(out.get(0)); 
        assert "b".equals(out.get(1)); 
        assert "c".equals(out.get(2)); 
      } 
    } </pre>
<p class="calibre2">Compiling and running the code with assertions enabled (the <kbd class="calibre12">-ea</kbd> argument) tells us that our tests have passed:</p>
<pre class="calibre23"><strong class="calibre1">$ javac -d out --module-source-path src --module <br class="title-page-name"/>  packt.sortutil,packt.sortutil.test 
$ java -ea --module-path out:lib --module <br class="title-page-name"/>  packt.sortutil.test/packt.util.test.SortUtilTestMain</strong> </pre>
<p class="calibre2">You should not see any output, which indicates all assertions have successfully passed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Integrating with JUnit</h1>
                
            
            <article>
                
<p class="calibre2">While writing classes with main methods can get the job done with unit testing, we can do better. You typically write tests in Java using a framework such as JUnit. JUnit is a complete testing framework with handy life cycle hooks and annotations that you can use to write tests easily. Let's look at converting our test module to use JUnit.</p>
<p class="calibre2">Here are the steps:</p>
<ol class="calibre17">
<li value="1" class="calibre15">Get the JUnit jars. You can either download them from the JUnit website (<a href="http://junit.org/junit4/" class="calibre4">http://junit.org/junit4/</a>) or download them from Maven Central. It also has a dependency on the hamcrest core JAR file, so download that too. Place the JARs in a <kbd class="calibre12">lib</kbd> folder. We intend to add this location to the module path. The downloaded JAR files are available in the <kbd class="calibre12">lib</kbd> folder at <kbd class="calibre12">12-build-tools-and-testing/02-testing/src/packt.sortutil.test</kbd>.</li>
<li value="2" class="calibre15">Use the JUnit annotations in your test code. Here's the new <kbd class="calibre12">SortUtilTest</kbd> written as a JUnit test:</li>
</ol>
<pre class="calibre23">        public class SortUtilTest { 
          private SortUtil sortUtil; 
          @Before public void setUp() { 
            sortUtil = new SortUtil(); 
          } 
          @Test     
          public void testReturnsSameSize() { 
            List out = sortUtil.sortList(Arrays.asList("b", "a", "c")); 
            SortUtil sortUtil = new SortUtil(); 
            assert out.size() == 3; 
          } 
          @Test   
          public void sortsList() { 
            List out = sortUtil.sortList(Arrays.asList("b", "a", "c")); 
            assert "a".equals(out.get(0)); 
            assert "b".equals(out.get(1)); 
            assert "c".equals(out.get(2)); 
          } 
        } </pre>
<ol start="3" class="calibre17">
<li value="3" class="calibre15">Specify that the test module has a dependency on the JUnit library. Since the JUnit JAR will be added to the classpath, it will be treated as an automatic module. So, to establish dependency, you'll need to figure out what the automatic module name will be from the JAR file name. The JAR file downloaded is called <kbd class="calibre12">junit-4.12.jar</kbd>. Stripping off the <kbd class="calibre12">.jar</kbd> extension and the version number, we'll end up with the automatic module--<kbd class="calibre12">name - junit</kbd>.</li>
<li value="4" class="calibre15">Declare the test module as  <kbd class="calibre12">open</kbd>. The way JUnit works is by scanning the annotations on your classes to figure out what to do. So, it needs access to the test classes in your test module. You can either export the necessary packages or declare them as open. I prefer the latter, since we only need to enable reflective access to JUnit.</li>
</ol>
<p class="calibre2">Here's the updated module definition of the <kbd class="calibre12">packt.sortutil.test</kbd> module:</p>
<pre class="calibre23">          open module packt.sortutil.test { 
            requires packt.sortutil; 
            requires junit; 
          } </pre>
<p class="calibre2">Let's compile and run the test to see what the behavior is:</p>
<pre class="calibre23"><strong class="calibre1">$ javac -d out --module-source-path src --module-path lib --module <br class="title-page-name"/>  packt.sortutil,packt.sortutil.test</strong> </pre>
<p class="calibre2">The only change this time is the addition of the lib directory as the module path. This lets the Java platform treat the JUnit JAR as an automatic module, which is what we need. This should succeed without any errors.</p>
<p class="calibre2">What happens if we run this now? We are running the JUnit test runner class, so that's what we need to specify in the core JUnit runner class <kbd class="calibre12">JUnitCore</kbd> (in the automatic module <kbd class="calibre12">junit</kbd>) as value to the <kbd class="calibre12">--module</kbd> argument to Java. Following that is the fully qualified name of the class under test--<kbd class="calibre12">SortUtilTest</kbd>. Here's what the command looks like:</p>
<pre class="calibre23"><strong class="calibre1">$ java --module-path out:lib --module junit/org.junit.runner.JUnitCore</strong><br class="title-page-name"/><strong class="calibre1">  packt.util.test.SortUtilTest</strong> </pre>
<p class="calibre2">Will it work? It will not! Here's the error you should see:</p>
<pre class="calibre23"><strong class="calibre1">JUnit version 4.12.E 
Time: 0.001 
There was 1 failure: 
1) initializationError(org.junit.runner.JUnitCommandLineParseResult) 
java.lang.IllegalArgumentException: Could not find class [packt.util.test.SortUtilTest]</strong> </pre>
<p class="calibre2">Turns out Java is unable to find the <kbd class="calibre12">SortUtilTest</kbd> class. Why is that? The compiled module is available in the out directory that we've passed to the <kbd class="calibre12">--module-path</kbd> option! There's a reason why it does not see the class.</p>
<p class="calibre2">Think back to the module resolution discussion in <a href="part0124.html#3M85O0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 8</a>, U<em class="calibre22">nderstanding Linking and Using jlink</em>. The module resolution is a traversal of dependent modules originating from the starting point--the module you specify in the <kbd class="calibre12">--module</kbd> argument. Since the starting point here is the JUnit automatic module, the module resolution process never resolves the application or test modules. This is because the JUnit automatic module does not read our modules! The way to solve this problem and have the runtime see our modules is using the <kbd class="calibre12">--add-modules</kbd> option. Passing our test module using this option should result in the execution completing successfully:</p>
<pre class="calibre23"><strong class="calibre1">$ java --module-path out:lib --add-modules packt.sortutil.test --module junit/org.junit.runner.JUnitCore packt.util.test.SortUtilTest 
JUnit version 4.12 
.. 
Time: 0.005 
 
OK (2 tests)</strong> </pre>
<p class="calibre2">Note that we did not have to add the <kbd class="calibre12">packt.sortutil</kbd> module to the <kbd class="calibre12">--add-modules</kbd> option. Just the test module sufficed. This is because the test module has an explicit dependency on <kbd class="calibre12">packt.sortutil</kbd> through the requires declaration, and so the module resolution process now picks it up automatically!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Wrapping up</h1>
                
            
            <article>
                
<p class="calibre2">With this, we come to the end of our exploration of Java 9 modularity together. You now have a good understanding of Java 9 modularity and more importantly, how to use the feature and the related concepts in your code. This is certainly an exciting new addition to the Java language, and we, as developers, have both the ability and the responsibility to use these features wisely and well.</p>
<p class="calibre2">While this is the end of the book, I hope you are excited and well equipped to continue your journey into learning about and building awesome modular applications in Java.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we covered two important aspects of Java programming that play a significant role in most real-world Java applications--build systems and testing. We looked at how we can use Maven to structure our projects and align Maven's multi-module project concepts with Java 9 modular applications. We examined how such an application looks like, and learned how to compile and execute the application through Maven lifecycle processes. We then learned about how testing can be incorporated into a Java modular application. We looked at some of the challenges with testing that result from some constraints that Java modularity introduces to the language and how to work around them. We then created a JUnit test case and leveraged the JUnit framework to execute a module test case.</p>


            </article>

            
        </section>
    </body></html>