- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Exploring TDD with Quality Assurance
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与质量保证一起探索TDD
- en: Previous chapters have covered the technical practices needed to design and
    test well-engineered code. The approach presented has been primarily for developers
    to gain rapid feedback on software design. Testing has been almost a byproduct
    of these efforts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章介绍了设计和测试精心设计代码所需的技术实践。所提出的方法主要是为了让开发者能够快速获得软件设计的反馈。测试几乎成了这些努力的副产品。
- en: The combination of TDD, continuous integration, and pipelines provides us with
    a high level of confidence in our code. But they are not the whole picture when
    it comes to software **Quality Assurance** (**QA**). Creating the highest-quality
    software needs additional processes, featuring the human touch. In this chapter,
    we will highlight the importance of manual exploratory testing, code reviews,
    user experience, and security testing, together with approaches to adding a human
    decision point to a software release.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: TDD、持续集成和管道的组合为我们提供了对代码的高度信心。但当谈到软件**质量保证**（**QA**）时，它们并不是整个图景。创建最高质量的软件需要额外的流程，包括人类接触。在本章中，我们将强调手动探索性测试、代码审查、用户体验和安全测试的重要性，以及将人类决策点添加到软件发布中的方法。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: TDD – its place in the bigger quality picture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD – 在更广泛的质量图景中的位置
- en: Manual exploratory testing – discovering the unexpected
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动探索性测试 – 发现意外情况
- en: Code review and ensemble programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码审查和集成编程
- en: User interface and user experience testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面和用户体验测试
- en: Security testing and operations monitoring
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全测试和操作监控
- en: Incorporating manual elements into CI/CD workflows
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将手动元素融入CI/CD工作流程
- en: TDD – its place in the bigger quality picture
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD – 在更广泛的质量图景中的位置
- en: In this section, we will take a critical look at what TDD has brought to the
    testing table, and what remains human activities. While TDD undoubtedly has advantages
    as part of a test strategy, it can never be the entire strategy for a successful
    software system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将批判性地审视TDD为测试表带来了什么，以及哪些仍然是人类活动。虽然TDD无疑作为测试策略的一部分具有优势，但它永远不能成为成功软件系统的整个策略。
- en: Understanding the limits of TDD
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解TDD的局限性
- en: TDD is a relatively recent discipline as far as mainstream development goes.
    The modern genesis of TDD lies with Kent Beck in the Chrysler Comprehensive Compensation
    System (see the *Further reading* section, where the idea of test-first unit testing
    came from). The project began in 1993 and Kent Beck’s involvement commenced in
    1996.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从主流开发的角度来看，TDD是一个相对较新的学科。TDD的现代起源与Kent Beck在克莱斯勒综合薪酬系统（参见*进一步阅读*部分，其中介绍了测试优先单元测试的想法）有关。该项目始于1993年，Kent
    Beck的参与始于1996年。
- en: The Chrysler Comprehensive Compensation project was characterized by extensive
    use of unit tests driving small iterations and frequent releases of code. Hopefully,
    we recognize those ideas from the preceding chapters in this book. Much has changed
    since then – the deployment options are different, the number of users has increased,
    and agile approaches are more common – but the goals of testing remain the same.
    Those goals are to drive out correct, well-engineered code and ultimately satisfy
    users.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 克莱斯勒综合薪酬项目以广泛使用单元测试驱动小型迭代和频繁发布代码为特点。希望我们能从本书前几章中认识到这些想法。自那时以来，许多事情都发生了变化——部署选项不同了，用户数量增加了，敏捷方法更为常见——但测试的目标保持不变。这些目标是为了推动正确的、精心设计的代码，并最终满足用户的需求。
- en: The alternative to test automation is to run tests without automation – in other
    words, run them manually. A better term might be human-driven. Before test automation
    became commonplace, an important part of any development plan was a test strategy
    document. These lengthy documents defined when testing would be done, how it would
    be done, and who would be doing that testing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 测试自动化的替代方案是在没有自动化的情况下运行测试——换句话说，手动运行它们。一个更好的术语可能是人类驱动的。在测试自动化变得普遍之前，任何开发计划的一个重要部分都是测试策略文档。这些冗长的文档定义了何时进行测试，如何进行测试，以及谁将进行这些测试。
- en: This strategy document existed alongside detailed test plans. These would also
    be written documents, describing each test to be performed – how it would be set
    up, what steps exactly were to be tested, and what the expected results should
    be. The traditional waterfall-style project would spend a lot of time defining
    these documents. In some ways, these documents were similar to our TDD test code,
    only written on paper, rather than source code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这份策略文档与详细的测试计划并存。这些也会是书面文件，描述要执行的所有测试——如何设置，要测试的确切步骤，以及预期的结果应该是什么。传统的瀑布式项目会花费大量时间来定义这些文档。在某种程度上，这些文档与我们的TDD测试代码类似，只是写在纸上，而不是源代码中。
- en: Executing these manual test plans was a large effort. Running a test needs us
    to set up test data by hand, run the application, then click through user interfaces.
    Results must be documented. Defects found must be recorded in defect reports.
    These must be fed back up the waterfall, triggering redesigns and recoding. This
    must happen with every single release. *Human-driven* testing is repeatable, but
    only at the great cost of preparing, updating, and following test documents. All
    of this took time – and a lot of time at that.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这些手动测试计划是一项巨大的工作。运行测试需要我们手动设置测试数据，运行应用程序，然后通过用户界面进行点击。结果必须被记录。发现的缺陷必须记录在缺陷报告中。这些必须反馈到瀑布模型中，触发重新设计和重新编码。这必须发生在每个单独的版本中。*人工驱动的*测试是可重复的，但代价巨大，需要准备、更新和跟踪测试文档。这一切都花费了时间——而且很多时间。
- en: Against this background, Beck’s TDD ideas seemed remarkable. Test documents
    became executable code and could be run as often as desired, for a fraction of
    the cost of human testing. This was a compelling vision. The responsibility of
    testing code was part of the developer’s world now. The tests were part of the
    source code itself. These tests were automated, capable of being run in full on
    every build, and kept up to date as the code changed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，贝克的TDD想法似乎非常引人注目。测试文档变成了可执行的代码，可以按需运行，成本仅为人工测试的一小部分。这是一个令人信服的愿景。测试代码的责任现在成为了开发者世界的一部分。这些测试是源代码本身的一部分。这些测试是自动化的，能够在每次构建时完全运行，并且随着代码的变化而保持更新。
- en: No more need for manual testing?
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 是否不再需要手动测试？
- en: It’s tempting to think that using TDD as described in this book might eliminate
    manual testing. It does eliminate some manual processes, but certainly not all.
    The main manual steps we replace with automation are feature testing during development
    and regression testing before release.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易认为，使用本书中描述的TDD可能会消除手动测试。它确实消除了某些手动过程，但绝对不是全部。我们用自动化取代的主要手动步骤是在开发期间进行的功能测试和发布前的回归测试。
- en: As we develop a new feature with TDD, we start by writing automated tests for
    that feature. Every automated test we write is a test that does not need to be
    run by hand. We save all that test setup time, together with the often lengthy
    process to click through a user interface to trigger the behavior we’re testing.
    The main difference TDD brings is replacing test plans written in a word processor
    with test code written in an IDE. Development feature manual testing is replaced
    by automation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用TDD开发新功能时，我们首先为该功能编写自动化测试。我们编写的每个自动化测试都不需要手动运行。我们节省了所有这些测试设置时间，以及通常需要通过用户界面点击来触发我们正在测试的行为的漫长过程。TDD带来的主要区别是用在IDE中编写的测试代码替换了在文字处理程序中编写的测试计划。开发功能的手动测试被自动化所取代。
- en: 'TDD also provides us with automated regression testing, for free:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: TDD（测试驱动开发）还为我们提供了免费的自动化回归测试：
- en: '![Figure 11.1 – Regression testing](img/Figure_11.1_B18384.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 回归测试](img/Figure_11.1_B18384.jpg)'
- en: Figure 11.1 – Regression testing
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 回归测试
- en: Using TDD, we add one or more tests as we build out each feature. Significantly,
    we retain all those tests. We naturally build up a large suite of automated tests,
    captured in source control and executed on every build automatically. This is
    known as a regression test suite. Regression testing means that we re-check all
    the tests run to date on every build. This ensures that as we make changes to
    the system, we don’t break anything. Moving fast and not breaking things might
    be how we describe this approach.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TDD，我们在构建每个功能时添加一个或多个测试。值得注意的是，我们保留了所有这些测试。我们自然地建立了一个庞大的自动化测试套件，这些测试被捕获在源代码控制中，并在每次构建时自动执行。这被称为回归测试套件。回归测试意味着我们在每次构建时重新检查迄今为止运行的测试。这确保了当我们对系统进行更改时，我们不会破坏任何东西。快速移动且不破坏东西可能就是我们对这种方法的描述。
- en: Regression tests also include tests for previously reported defects. These regression
    tests confirm that they have not been re-introduced. It bears repeating that the
    regression suite saves on all the manual effort required by non-automated tests
    *each and every* time the suite gets executed. This adds up over the full software
    life cycle to a huge reduction.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 回归测试还包括对之前报告的缺陷的测试。这些回归测试确认它们没有被重新引入。需要强调的是，回归测试套件在每次套件执行时都节省了非自动化测试所需的全部手动工作。在整个软件生命周期中，这会导致巨大的减少。
- en: Test automation is good, but an automated test is a software machine. It cannot
    think for itself. It cannot visually inspect code. It cannot assess the appearance
    of a user interface. It cannot tell whether the user experience is good or bad.
    It cannot determine whether the overall system is fit for purpose.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 测试自动化是好的，但自动化测试是一个软件机器。它不能自己思考。它不能视觉检查代码。它不能评估用户界面的外观。它不能判断用户体验是好是坏。它不能确定整个系统是否适合使用。
- en: 'This is where human-driven manual testing comes in. The following sections
    will look at areas where we need human-led testing, starting with an obvious one:
    finding bugs that our tests missed.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是人类驱动的手动测试介入的地方。以下章节将探讨我们需要人类引导测试的领域，从显而易见的一个开始：找出测试遗漏的缺陷。
- en: Manual exploratory – discovering the unexpected
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动探索性测试 – 发现意外情况
- en: In this section, we will appreciate the role of manual exploratory testing as
    an important line of defense against defects where TDD is used.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将欣赏手动探索性测试在TDD（测试驱动开发）中作为防御缺陷的重要防线的作用。
- en: The biggest threat to our success with TDD lies in our ability to think about
    all the conditions our software needs to handle. Any reasonably complex piece
    of software has a huge range of possible input combinations, edge cases, and configuration
    options.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们使用TDD成功最大的威胁在于我们思考所有软件需要处理的条件的能力。任何合理的复杂软件都有巨大的可能输入组合、边缘情况和配置选项。
- en: 'Consider using TDD to write code to restrict the sales of a product to buyers
    who are 18 years old and above. We must first write a happy-path test to check
    whether the sale is allowed, make it pass, then write a negative test, confirming
    that the sale can be blocked based on age. This test has the following form:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用TDD编写代码来限制将产品销售给18岁及以上买家的销售。我们必须首先编写一个Happy-path测试来检查销售是否允许，使其通过，然后编写一个负面测试，确认基于年龄可以阻止销售。这个测试具有以下形式：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The error is obvious when we’re looking for it: what happens at the boundary
    between the ages of 17 and 18? Can an 18-year-old buy this product or not? We
    don’t know, because there is no test for that. We tested for 17 and 19 years old.
    For that matter, what should happen on that boundary? In general, that’s a stakeholder
    decision.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在寻找错误时，错误是明显的：在17岁和18岁之间的边界会发生什么？一个18岁的成年人可以购买这个产品吗？我们不知道，因为没有针对那个年龄段的测试。我们测试了17岁和19岁的人。就那个边界而言，应该发生什么？通常，这是一个利益相关者的决定。
- en: 'Automated tests cannot do two things:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试无法完成两件事：
- en: Ask a stakeholder what they want the software to do
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 询问利益相关者他们希望软件做什么
- en: Spot a missing test
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现遗漏的测试
- en: This is where manual exploratory testing comes in. This is an approach to testing
    that makes the most of human creativity. It uses our instincts and intelligence
    to work out what tests we might be missing. It then uses scientific experimentation
    to discover whether our predictions of a missing test were correct. If proven
    true, we can provide feedback on these findings and repair the defect. This can
    be done either as an informal discussion or using a formal defect tracking tool.
    In due course, we can write new automated tests to capture our discoveries and
    provide regression tests for the future.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是手动探索性测试介入的地方。这是一种充分利用人类创造力的测试方法。它利用我们的本能和智慧来确定我们可能遗漏的测试。然后，它使用科学实验来验证我们对遗漏测试的预测是否正确。如果得到证实，我们可以对这些发现提供反馈并修复缺陷。这可以通过非正式讨论或使用正式的缺陷跟踪工具来完成。在适当的时候，我们可以编写新的自动化测试来捕捉我们的发现，并为未来提供回归测试。
- en: This kind of exploratory testing is a highly technical job, based on knowledge
    of what kinds of boundaries exist in software systems. It also requires extensive
    knowledge of local deployment and setup of software systems, together with knowing
    how software is built, and where defects are likely to appear. To an extent, it
    relies on knowing how developers think and predicting the kinds of things they
    may overlook.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种探索性测试是一项高度技术性的工作，基于对软件系统中存在哪些类型的边界的了解。它还要求对本地部署和软件系统的设置有广泛的知识，以及了解软件是如何构建的，以及缺陷可能出现的地点。在一定程度上，它依赖于了解开发者的思维方式，并预测他们可能忽略的事情。
- en: 'Some key differences between automated testing and exploratory testing can
    be summarized as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试和探索性测试之间的一些关键差异可以总结如下：
- en: '| **Automated Testing** | **Manual** **Exploratory Testing** |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **自动化测试** | **手动** **探索性测试** |'
- en: '| --- | --- |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Repeatable | Creative |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 可重复 | 创造性 |'
- en: '| Tests for known outcomes | Finds unknown outcomes |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 对已知结果的测试 | 发现未知结果 |'
- en: '| Possible by machine | Requires human creativity |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 可由机器完成 | 需要人类创造力 |'
- en: '| Behavior verification | Behavior investigation |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 行为验证 | 行为调查 |'
- en: '| Planned | Opportunistic |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 计划 | 机会主义 |'
- en: '| Code is in control of the testing | Human minds control the testing |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 代码控制测试 | 人类思维控制测试 |'
- en: Table 11.1 – Automated versus manual exploratory testing
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.1 – 自动化与手动探索性测试
- en: Manual exploratory testing will always be needed. Even the best developers get
    pressed for time, distracted, or have yet another meeting that should have been
    an email. Once concentration is lost, it’s all too easy for mistakes to creep
    in. Some missing tests relate to edge cases that we cannot see alone. Another
    human perspective often brings a fresh insight we would simply never have unaided.
    Manual exploratory testing provides an important extra layer of defense in depth
    against defects going unnoticed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 手动探索性测试始终是必要的。即使是最好的开发者也会因为时间紧迫、分心或有另一个应该通过电子邮件召开的会议而感到压力。一旦注意力分散，错误就很容易悄悄溜进来。一些遗漏的测试与我们不能单独看到的边缘情况有关。另一个人类视角常常带来我们单凭自己的能力永远不会有的新见解。手动探索性测试为防止缺陷未被发现提供了重要的一层深度防御。
- en: Once exploratory testing identifies some unexpected behavior, we can feed this
    back into development. At that point, we can use TDD to write a test for the correct
    behavior, confirm the presence of the defect, then develop the fix. We now have
    a fix and a regression test to ensure the bug remains fixed. We can think of manual
    exploratory testing as the fastest possible feedback loop for a defect we missed.
    An excellent guide to exploratory testing is listed in the *Further* *reading*
    section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦探索性测试确定了某些意外的行为，我们可以将其反馈到开发中。在那个时刻，我们可以使用TDD来编写正确行为的测试，确认缺陷的存在，然后开发修复方案。我们现在有一个修复方案和一个回归测试来确保错误得到修复。我们可以将手动探索性测试视为我们遗漏的缺陷最快可能的反馈循环。关于探索性测试的优秀指南列在*进一步阅读*部分。
- en: Seen in this light, automation testing and TDD do not make manual efforts less
    important. Instead, their value is amplified. The two approaches work together
    to build quality into the code base.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，自动化测试和TDD并没有使手动工作变得不重要。相反，它们的价值得到了放大。这两种方法共同工作，将质量融入代码库。
- en: Manual testing for things we missed isn’t the only development time activity
    of value that cannot be automated. We also have the task of checking the quality
    of our source code, which is the subject of the next section.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们遗漏的事情进行手动测试并不是唯一有价值的发展时间活动，不能自动化。我们还有检查我们源代码质量的任务，这是下一节的主题。
- en: Code review and ensemble programming
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码审查和集体编程
- en: 'This section reviews another area surprisingly resistant to automation: checking
    code quality.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 本节回顾了另一个对自动化抵抗性惊人的领域：检查代码质量。
- en: As we’ve seen throughout this book, TDD is primarily concerned with the design
    of our code. As we build up a unit test, we define how our code will be used by
    its consumers. The implementation of that design is of no concern to our test,
    but it does concern us as software engineers. We want that implementation to perform
    well and to be easy for the next reader to understand. Code is read many more
    times than it is written over its life cycle.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如本书所述，TDD（测试驱动开发）主要关注我们代码的设计。当我们构建单元测试时，我们定义了我们的代码将如何被消费者使用。该设计的实现对我们测试来说无关紧要，但它确实关系到我们作为软件工程师。我们希望该实现能够高效运行，并且易于下一位读者理解。代码在其生命周期中读的次数远多于写的次数。
- en: Some automated tools exist to help with checking code quality. These are known
    as static code analysis tools. The name comes from the fact that they do not run
    code; instead, they perform an automated review of the source code. One popular
    tool for Java is Sonarqube (at [https://www.sonarqube.org/](https://www.sonarqube.org/)),
    which runs a set of rules across a code base.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一些自动化工具存在，可以帮助检查代码质量。这些被称为静态代码分析工具。这个名字来源于它们不运行代码；相反，它们对源代码进行自动审查。Java的一个流行工具是Sonarqube（在[https://www.sonarqube.org/](https://www.sonarqube.org/)），它在一组代码库上运行一系列规则。
- en: 'Out of the box, tools like this give warnings about the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此类工具会警告以下内容：
- en: Variable name conventions not being followed
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不遵循变量命名约定
- en: Uninitialized variables leading to possible `NullPointerException` problems
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未初始化的变量可能导致可能的`NullPointerException`问题
- en: Security vulnerabilities
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全漏洞
- en: Poor or risky use of programming constructs
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序结构的低效或风险使用
- en: Violations of community-accepted practices and standards
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 违反社区公认的做法和标准
- en: These rules can be modified and added to, allowing customization to be made
    to the local project house style and rules.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则可以修改和添加，以便根据本地项目风格和规则进行定制。
- en: Of course, such automated assessments have limitations. As with manual exploratory
    testing, there are simply some things only a human can do (at least at the time
    of writing). In terms of code analysis, this mainly involves bringing context
    to the decisions. One simple example here is preferring longer, more descriptive
    variable names to a primitive such as `int`, compared to a more detailed type
    such as `WordRepository`. Static tools lack that understanding of the different
    contexts.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种自动化评估也有局限性。与手动探索性测试一样，有些事情只有人类才能做到（至少在撰写本文时是这样）。在代码分析方面，这主要涉及到将上下文带入决策中。这里的一个简单例子是，相比于`int`这样的原始类型，更倾向于使用更长、更具描述性的变量名，例如`WordRepository`。静态工具缺乏对不同上下文的理解。
- en: 'Automated code analysis has its benefits and limitations, as summarized here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 自动代码分析有其优点和局限性，如下总结：
- en: '| **Automated Analysis** | **Human Review** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **自动分析** | **人工审查** |'
- en: '| --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Rigid rules (for example, variable name length) | Relaxes rules based on
    context |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 严格的规则（例如，变量名长度） | 根据上下文放宽规则 |'
- en: '| Applies a fixed set of assessment criteria | Applies experiential learning
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 应用固定的评估标准 | 应用经验学习 |'
- en: '| Reports pass/fail outcomes | Suggests alternative improvements |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 报告通过/失败结果 | 建议替代改进 |'
- en: Table 11.2 – Automated analysis versus human review
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.2 – 自动分析与人工审查
- en: Google has a very interesting system called **Google Tricorder**. This is a
    set of program analysis tools that combines the creativity of Google engineers
    in devising rules for good code with the automation to apply them. For more information,
    see [https://research.google/pubs/pub43322/](https://research.google/pubs/pub43322/).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌有一个非常有趣的系统，称为**谷歌三频仪**。这是一套程序分析工具，它结合了谷歌工程师在制定良好代码规则方面的创造力以及自动化应用这些规则。更多信息，请参阅[https://research.google/pubs/pub43322/](https://research.google/pubs/pub43322/)。
- en: 'Manually reviewing code can be done in various ways, with some common approaches:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 人工审查代码可以以各种方式进行，以下是一些常见的方法：
- en: '**Code review on** **pull requests**:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在** **拉取请求** **上进行代码审查**：'
- en: A pull request, also known as a merge request, is made by a developer when they
    wish to integrate their latest code changes into the main code base. This provides
    an opportunity for another developer to review that work and suggest improvements.
    They may even visually spot defects. Once the original developer makes agreed
    changes, the request is approved and the code is merged.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者希望将最新的代码更改集成到主代码库中时，他们会发起一个拉取请求，也称为合并请求。这为另一位开发者提供了一个审查这项工作并提出改进的机会。他们甚至可以直观地发现缺陷。一旦原始开发者做出一致的改变，请求就会被批准，代码就会被合并。
- en: '**Pair programming**:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结对编程**：'
- en: Pair programming is a way of working where two developers work on the same task
    at the same time. There is a continuous discussion about how to write the code
    in the best way. It is a continuous review process. As soon as either developer
    spots a problem, or has a suggested improvement, a discussion happens and a decision
    is made. The code is continuously corrected and refined as it is developed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 结对编程是一种工作方式，其中两位开发者同时处理同一项任务。他们持续讨论如何以最佳方式编写代码。这是一个持续审查的过程。一旦任何一位开发者发现问题或提出改进建议，就会发生讨论并做出决定。代码在开发过程中不断得到纠正和改进。
- en: '**Ensemble (****mob) programming**:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队编程（****mob）**：'
- en: Like pair programming, only the whole team takes part in writing the code for
    one task. The ultimate in collaboration, which continuously brings the expertise
    and opinions of an entire team to bear on every piece of code written.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就像结对编程一样，整个团队都参与编写一个任务的代码。这是协作的极致，它不断地将整个团队的专业知识和意见应用于每一行代码。
- en: The dramatic difference here is that a code review happens after the code is
    written, but pair programming and mobbing happen while the code is being written.
    Code reviews performed after the code is written frequently happen too late to
    allow meaningful changes to be made. Pairing and mobbing avoid this by reviewing
    and refining code continuously. Changes are made the instant they are identified.
    This can result in higher quality output delivered sooner compared to the code-then-review
    workflow.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里戏剧性的区别在于代码审查发生在代码编写之后，但结对编程和团队编程发生在代码编写过程中。编写代码后的代码审查通常发生得太晚，无法进行有意义的更改。结对和团队编程通过持续审查和改进代码来避免这种情况。一旦发现更改，就会立即进行更改。这可能导致与代码后审查工作流程相比，更早地交付更高质量的输出。
- en: Different development situations will adopt different practices. In every case,
    adding a second pair of human eyes (or more) provides an opportunity for a design-level
    improvement, not a syntax-level one.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的开发情况将采用不同的实践。在每种情况下，添加第二双（或更多）人眼提供了一个机会，进行设计层面的改进，而不是语法层面的改进。
- en: With that, we’ve seen how developers can benefit from adding manual exploratory
    testing and code review to their TDD work. Manual techniques benefit our users
    as well, as we will cover in the next section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经看到了开发者如何通过添加手动探索性测试和代码审查到他们的TDD工作中受益。手动技术也对我们用户有益，我们将在下一节中介绍。
- en: User interface and user experience testing
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面和用户体验测试
- en: In this section, we will consider how we evaluate the impact of our user interface
    on users. This is another area where automation brings benefits but cannot complete
    the job without humans being involved.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将考虑如何评估我们的用户界面对用户的影响。这是另一个自动化带来好处但无法在没有人类参与的情况下完成工作的领域。
- en: Testing the user interface
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试用户界面
- en: 'User interfaces are the only part of our software system that matters to the
    most important people of all: our users. They are – quite literally – their windows
    into our world. Whether we have a command-line interface, a mobile web application,
    or a desktop GUI, our users will be helped or hindered in their tasks by our user
    interface.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面是我们软件系统中唯一对所有人最重要的部分：我们的用户。它们——字面意义上——是他们通向我们世界的窗口。无论我们有一个命令行界面、移动网页应用还是桌面GUI，我们的用户都会因为我们的用户界面而得到帮助或受阻。
- en: 'The success of a user interface rests on two things being done well:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面的成功取决于两个方面都做得很好：
- en: It provides all the functionality a user needs (and wants)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了用户需要的（和想要的）所有功能
- en: It allows a user to accomplish their end goals in an effective and efficient
    manner
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用户能够以有效和高效的方式完成他们的最终目标
- en: The first of these, providing functionality, is the more programmatic of the
    two. In the same way that we use TDD to drive a good design for our server-side
    code, we can use it in our frontend code as well. If our Java application generates
    HTML – called server-side rendering – TDD is trivial to use. We test the HTML
    generation adapter and we’re done. If we are using a JavaScript/Typescript framework
    running in the browser, we can use TDD there, with a test framework such as Jest
    ([https://jestjs.io/](https://jestjs.io/)).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个中的第一个，提供功能，是两个中更程序化的一个。就像我们使用TDD来推动我们服务器端代码的良好设计一样，我们也可以在我们的前端代码中使用它。如果我们的Java应用程序生成HTML（称为服务器端渲染）——TDD的使用变得非常简单。我们测试HTML生成适配器，然后完成。如果我们正在使用在浏览器中运行的JavaScript/TypeScript框架，我们可以在那里使用TDD，使用如Jest（[https://jestjs.io/](https://jestjs.io/））这样的测试框架。
- en: Having tested we’re providing the right functions to the user, automation then
    becomes less useful. With TDD, we can verify that all the right sorts of graphical
    elements are present in our user interface. But we can’t tell whether they are
    meeting the needs of the user.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试了确保我们向用户提供正确的功能后，自动化变得不那么有用。使用TDD，我们可以验证我们的用户界面中是否包含所有正确的图形元素。但我们无法判断它们是否满足用户的需求。
- en: 'Consider this fictional user interface for buying merchandise relating to our
    Wordz application:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个与我们的Wordz应用程序相关的商品购买虚构用户界面：
- en: '![Figure 11.2 – Example user interface](img/Figure_11.2_B18384.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 示例用户界面](img/Figure_11.2_B18384.jpg)'
- en: Figure 11.2 – Example user interface
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 示例用户界面
- en: 'We can use TDD to test that all those interface elements – the boxes and buttons
    – are present and working. But will our users care? Here are the questions we
    need to ask:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用TDD来测试所有这些界面元素——框和按钮——是否存在并且工作正常。但我们的用户会在意吗？以下是我们需要提出的问题：
- en: Does it look and feel good?
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它看起来和感觉好吗？
- en: Does it align with corporate branding and house style guides?
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否与公司品牌和风格指南一致？
- en: For the task of buying a T-shirt, is it easy to use?
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于购买T恤的任务，它是否易于使用？
- en: Does it present a logical flow to the user, guiding them through their task?
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否向用户呈现一个逻辑流程，引导他们完成任务？
- en: Quite deliberately for this example, the answer is no to all these questions.
    This is, quite frankly, a terrible user interface layout. It has no style, no
    feeling, and no brand identity. You have to type in the product name in the text
    field. There is no product image, no description, and no price! This user interface
    is truly the worst imaginable for an e-commerce product sales page. Yet it would
    pass all our automated functionality tests.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们故意对所有这些问题回答“不”。坦白说，这是一个糟糕的用户界面布局。它没有风格，没有感觉，也没有品牌识别度。你必须将产品名称输入到文本字段中。没有产品图片，没有描述，也没有价格！对于电子商务产品的销售页面来说，这个用户界面真的是最糟糕的想象。然而，它将通过我们所有的自动化功能测试。
- en: Designing effective user interfaces is a very human skill. It involves a little
    psychology in knowing how humans behave when presented with a task, mixed with
    an artistic eye, backed by creativity. These qualities of a user interface are
    best assessed by humans, adding another manual step to our development process.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 设计有效的用户界面是一项非常人类化的技能。它涉及到一点心理学，了解人类在面临任务时的行为，结合艺术眼光，并辅以创造力。这些用户界面的特性最好由人类来评估，这为我们的发展过程增加了另一个手动步骤。
- en: Evaluating the user experience
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估用户体验
- en: Closely related to user interface design is user experience design.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面设计与用户体验设计密切相关。
- en: User experience goes beyond any individual element or view on a user interface.
    It is the entire experience our users have, end to end. When we want to order
    the latest Wordz T-shirt from our e-commerce store, we want the entire process
    to be easy. We want the workflow across every screen to be obvious, uncluttered,
    and easier to get right than to get wrong. Going further, service design is about
    optimizing the experience from wanting a T-shirt to wearing it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 用户体验超越了用户界面上任何单个元素或视图。它是我们用户从开始到结束的整个体验。当我们想要从我们的电子商务商店订购最新的Wordz T恤时，我们希望整个过程都很容易。我们希望每个屏幕上的工作流程都明显、无杂乱，并且比出错更容易正确。
- en: Ensuring users have a great experience is the job of a user experience designer.
    It is a human activity that combines empathy, psychology, and experimentation.
    Automation is limited in how it can help here. Some mechanical parts of this can
    be automated. Obvious candidates are applications such as Invision ([https://www.invisionapp.com/](https://www.invisionapp.com/)),
    which allows us to produce a screen mockup that can be interacted with, and Google
    Forms, which allows us to collect feedback over the web, with no code to set that
    up.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 确保用户有良好的体验是用户体验设计师的工作。这是一项结合同理心、心理学和实验的人类活动。自动化在这里的帮助有限。一些机械部分可以自动化。明显的候选者包括Invision（[https://www.invisionapp.com/](https://www.invisionapp.com/))这样的应用程序，它允许我们制作可以交互的屏幕原型，以及Google表单，它允许我们在网上收集反馈，无需编写代码来设置。
- en: After creating a candidate user experience, we can craft experiments where potential
    users are given a task to complete, then asked to provide feedback on how they
    found the experience.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建候选用户体验后，我们可以设计实验，让潜在用户完成一项任务，然后要求他们提供关于他们如何体验的反馈。
- en: 'A simple, manual form is more than adequate to capture this feedback:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的手动表单足以捕捉这些反馈：
- en: '| **Experience** | **Rating of 1 (Poor) –** **5 (Good)** | **Comments** |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **经验** | **1（差）-** **5（好）** | **评论** |'
- en: '| --- | --- | --- |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| My task was easy to complete | 4 | I completed the task ok after being prompted
    by your researcher. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 我的任务很容易完成 | 4 | 在你的研究人员的提示下，我完成了任务。 |'
- en: '| I felt confident completing my task without instructions | 2 | The text entry
    field about T-shirt size confused me. Could it be a dropdown of available options
    instead? |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 我在没有说明的情况下自信地完成了我的任务 | 2 | 关于T恤尺寸的文本输入字段让我困惑。它能否是一个包含可用选项的下拉菜单？ |'
- en: '| The interface guided me through the task | 3 | It was ok in the end – but
    that text field was an annoyance, so I scored this task lower. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 界面引导我完成任务 | 3 | 最后还可以接受——但那个文本字段很烦人，所以我给这个任务打了较低的分数。 |'
- en: Table 11.3 – User experience feedback form
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.3 – 用户体验反馈表
- en: User experience design is primarily a human activity. So is the evaluation of
    test results. These tools only go as far as allowing us to create a mockup of
    our visions and collect experimental results. We must run sessions with real users,
    solicit their opinions on how their experience was, then feed back the results
    in an improved design.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 用户体验设计主要是一种人类活动。测试结果的评估也是如此。这些工具只能让我们创建我们的愿景的模拟，并收集实验结果。我们必须与真实用户进行会话，征求他们对体验的看法，然后将结果反馈到改进的设计中。
- en: 'While user experience is important, the next section deals with a mission-critical
    aspect of our code: security and operations.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然用户体验很重要，但下一节将讨论我们代码的一个关键任务方面：安全和运营。
- en: Security testing and operations monitoring
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全测试和运营监控
- en: This section reflects on the critical aspects of security and operations concerns.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 本节反思了安全和运营关注的重点方面。
- en: So far, we have created an application that is well-engineered and has very
    low defects. Our user experience feedback has been positive – it is easy to use.
    But all that potential can be lost in an instant if we cannot keep the application
    running. If hackers target our site and harm users, the situation becomes even
    worse.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个工程良好且缺陷极低的软件应用。我们的用户体验反馈是积极的——它易于使用。但如果我们不能保持应用正常运行，所有这些潜力都可能在一瞬间消失。如果黑客攻击我们的网站并伤害用户，情况会变得更糟。
- en: An application that is not running does not exist. The discipline of operations
    – often called DevOps these days – aims to keep applications running in good health
    and alert us if that health starts to fail.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不运行的应用程序不存在。运营学科——如今通常被称为DevOps——旨在保持应用程序健康运行，并在健康开始恶化时提醒我们。
- en: Security testing – also called **penetration testing** (**pentesting**) – is
    a special case of manual exploratory testing. By its nature, we are looking for
    new exploits and unknown vulnerabilities in our application. Such work is not
    best served by automation. Automation repeats what is already known; to discover
    the unknown requires human ingenuity.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 安全测试——也称为**渗透测试**（**pentesting**）——是手动探索性测试的一个特殊案例。根据其本质，我们正在寻找应用中的新漏洞和未知漏洞。这种工作不适合自动化。自动化重复已知的内容；要发现未知的内容需要人类的创造力。
- en: Penetration testing is the discipline that takes a piece of software and attempts
    to circumvent its security. Security breaches can be expensive, embarrassing,
    or business-ending for a company. The exploits used to create the breach are often
    very simple.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试是一项学科，它试图绕过软件的安全措施。安全漏洞可能对公司造成昂贵的损失、尴尬或业务中断。用于创建漏洞的攻击通常非常简单。
- en: 'Security risks can be summarized roughly as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 安全风险可以大致总结如下：
- en: Things we shouldn’t see
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不应该看到的事情
- en: Things we shouldn’t change
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不应该改变的事情
- en: Things we shouldn’t use as often
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不应该经常使用的事情
- en: Things we should not be able to lie about
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不应该撒谎的事情
- en: This is an oversimplification, of course. But the fact remains that our application
    may be vulnerable to these damaging activities – and we need to know whether that
    is the case or not. This requires testing. This kind of testing must be adaptive,
    creative, devious, and continually updated. An automated approach is none of those
    things, meaning security testing must take its place as a manual step in our development
    process.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个过于简化的说法。但事实仍然是，我们的应用可能容易受到这些破坏性活动的影响——我们需要知道这是否属实。这需要测试。这种测试必须是适应性、创造性、狡猾的，并且需要不断更新。自动化方法不具备这些特点，这意味着安全测试必须成为我们开发过程中的一个手动步骤。
- en: A great starting point is to review the latest **OWASP Top 10 Web Application
    Security Risks** ([https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/))
    and begin some manual exploratory testing based on the risks listed. Further information
    on threat models such as **Spoofing, Tampering, Repudiation, Information Disclosure,
    Denial of Service, and Elevation of Privilege** (**STRIDE**) can be found at [https://www.eccouncil.org/threat-modeling/](https://www.eccouncil.org/threat-modeling/).
    OWASP also has some excellent resources on useful tools at https://owasp.org/www-community/Fuzzing.
    **Fuzzing** is an automated way of discovering defects, although it requires a
    human to interpret the results of a failed test.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的起点是回顾最新的**OWASP Top 10 网络应用安全风险**([https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/))，并根据列出的风险开始一些基于风险的手动探索性测试。有关**欺骗、篡改、否认、信息泄露、拒绝服务和权限提升**（**STRIDE**）等威胁模型的信息，可以在[https://www.eccouncil.org/threat-modeling/](https://www.eccouncil.org/threat-modeling/)找到。OWASP
    还在 https://owasp.org/www-community/Fuzzing 提供了一些关于有用工具的优秀资源。**模糊测试**是一种自动发现缺陷的方法，尽管它需要人工解释失败的测试结果。
- en: As with other manual exploratory tests, these ad hoc experiments may lead to
    some future test automation. But the real value lies in the creativity applied
    to investigating the unknown.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他手动探索性测试一样，这些临时实验可能会导致一些未来的测试自动化。但真正的价值在于应用于调查未知事物的创造力。
- en: The preceding sections have made a case for the importance of manual interventions
    to complement our test automation efforts. But how does that fit in with a **continuous
    integration/continuous delivery** (**CI/CD**) approach? That’s the focus of the
    next section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的章节已经说明了手动干预对于补充我们的测试自动化努力的重要性。但这是如何与**持续集成/持续交付**（**CI/CD**）方法相匹配的呢？这就是下一节的重点。
- en: Incorporating manual elements into CI/CD workflows
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将手动元素纳入 CI/CD 工作流程
- en: We’ve seen that not only are manual processes important in our overall workflow
    but for some things, they are irreplaceable. But how do manual steps fit into
    heavily automated workflows? That’s the challenge we will cover in this section.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，不仅手动过程在我们的整体工作流程中很重要，而且在某些事情上，它们是不可替代的。但手动步骤如何适应高度自动化的工作流程呢？这就是本节将解决的问题。
- en: Integrating manual processes into an automated CI/CD pipeline can be difficult.
    The two approaches are not natural partners in terms of a linear, repeatable sequence
    of activities. The approach we take depends on our ultimate goal. Do we want a
    fully automated continuous deployment system, or are we happy with some manual
    interruptions?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将手动流程集成到自动化的 CI/CD 管道中可能很困难。从线性、可重复的活动序列来看，这两种方法并不是天然伙伴。我们采取的方法取决于我们的最终目标。我们是否想要一个完全自动化的持续部署系统，或者我们对一些手动中断感到满意？
- en: 'The simplest approach to incorporating a manual process is to simply stop the
    automation at a suitable point, begin the manual process, then resume automaton
    once the manual process completes. We can think of this as a blocking workflow,
    as all further automated steps in the pipeline must stop until the manual work
    is completed. This is illustrated in the following diagram:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将手动流程纳入的最简单方法是简单地在一个合适的位置停止自动化，开始手动流程，然后在手动流程完成后恢复自动化。我们可以将这视为一个阻塞工作流程，因为在管道中的所有后续自动化步骤都必须停止，直到手动工作完成。这在下图中得到了说明：
- en: '![Figure 11.3 – Blocking workflow](img/Figure_11.3_B18384.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 阻塞工作流程](img/Figure_11.3_B18384.jpg)'
- en: Figure 11.3 – Blocking workflow
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 阻塞工作流程
- en: By organizing our development process as a series of stages, some being automated
    and some being manual, we create a simple blocking workflow. Blocking here means
    that the flow of value is blocked by each stage. The automation stages typically
    run more quickly than the manual stages.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的开发过程组织为一系列阶段，其中一些是自动化的，一些是手动的，我们创建了一个简单的阻塞工作流程。这里的阻塞意味着每个阶段都会阻塞价值流。自动化阶段通常比手动阶段运行得更快。
- en: 'This workflow has some advantages in that it’s simple to understand and operate.
    Each iteration of software we deliver will have all automated tests run as well
    as all the current manual processes. In one sense, this release is of the highest
    quality we know how to make at that time. The disadvantage is that each iteration
    must wait for all manual processes to complete:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工作流程有一些优点，那就是它简单易懂且易于操作。我们交付的每个软件迭代都将运行所有自动化测试以及所有当前的手动流程。从某种意义上说，这个发布是我们当时能做出的最高质量。缺点是每个迭代必须等待所有手动流程完成：
- en: '![Figure 11.4 – Dual track workflow](img/Figure_11.4_B18384.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4 – 双轨工作流程](img/Figure_11.4_B18384.jpg)'
- en: Figure 11.4 – Dual track workflow
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – 双轨工作流程
- en: One enabler for very smooth dual-track workflows is to use a single main trunk
    for the whole code base. All developers commit to this main trunk. There are no
    other branches. Any features in active development are isolated by `true or false`
    at runtime. The code inspects these flags and decides whether to run a feature
    or not. Manual testing can then happen without having to pause deployments. During
    testing, the features in progress are enabled via the relevant feature flags.
    For the general end users, features in progress are disabled.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现非常顺畅的双轨工作流程，一个启用方法是使用整个代码库的单个主分支。所有开发者都提交到这个主分支。没有其他分支。任何正在开发中的功能都通过运行时的`true
    or false`进行隔离。代码检查这些标志并决定是否运行功能。然后可以进行手动测试，而无需暂停部署。在测试期间，正在开发中的功能通过相关的功能标志启用。对于一般最终用户，正在开发中的功能被禁用。
- en: We can select the approach that fits our delivery goals the best. The blocking
    workflow trades off less rework for an extended delivery cycle. The dual-track
    approach allows for more frequent feature delivery, with a risk of having defects
    in production before they are discovered by a manual process and, subsequently,
    repaired.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择最适合我们的交付目标的方法。阻塞工作流程以更长的交付周期为代价，减少了返工。双轨方法允许更频繁地交付功能，但存在风险，即在手动过程发现并修复之前，生产中可能存在缺陷。
- en: Selecting the right process to use involves a trade-off between feature release
    cadence and tolerating defects. Whatever we choose, the goal is to focus the expertise
    of the whole team on creating software with a low defect rate.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的流程涉及在功能发布周期和容忍缺陷之间进行权衡。无论我们选择什么，目标都是将整个团队的专长集中在创建低缺陷率的软件上。
- en: Balancing automated workflows with manual, human workflows isn’t easy, but it
    does result in getting the most human intuition and experience into the product.
    That’s good for our development teams and it is good for our users. They benefit
    from improved ease of use and robustness in their applications. Hopefully, this
    chapter has shown you how we can combine these two worlds and cross that traditional
    developer-tester divide. We can make one great team, aiming at one excellent outcome.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在平衡自动化工作流程与人工、人类工作流程之间并不容易，但这确实能够将最多的人类直觉和经验融入产品中。这对我们的开发团队和用户都是有益的。他们从应用中获得了改进的易用性和鲁棒性。希望这一章已经向你展示了我们如何结合这两个世界，跨越传统的开发者-测试者之间的鸿沟。我们可以打造一个优秀的团队，致力于实现一个卓越的结果。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter discussed the importance of various manual processes during development.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了在开发过程中各种手动过程的重要性。
- en: Despite its advantages, we’ve seen how TDD cannot prevent all kinds of defects
    in software. First, we covered the benefits of applying human creativity to manual
    exploratory testing, where we can uncover defects that we missed during TDD. Then,
    we highlighted the quality improvements that code reviews and analysis bring.
    We also covered the very manual nature of creating and verifying excellent user
    interfaces with satisfying user experiences. Next, we emphasized the importance
    of security testing and operations monitoring in keeping a live system working
    well. Finally, we reviewed approaches to integrating manual steps into automation
    workflows, and the trade-offs we need to make.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管TDD有其优点，但我们已经看到了TDD无法防止软件中所有类型的缺陷。首先，我们讨论了将人类创造力应用于手动探索性测试的好处，在那里我们可以发现我们在TDD中遗漏的缺陷。然后，我们强调了代码审查和分析带来的质量改进。我们还讨论了创建和验证具有令人满意的用户体验的优秀用户界面的非常手动性质。接下来，我们强调了在保持实时系统良好运行方面进行安全测试和运营监控的重要性。最后，我们回顾了将手动步骤集成到自动化工作流程中的方法，以及我们需要做出的权衡。
- en: In the next chapter, we’ll review some ways of working related to when and where
    we develop tests, before moving on to *Part 3* of this book, where we will finish
    building our Wordz application.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾一些与何时何地开发测试相关的工作方式，然后进入本书的*第3部分*，在那里我们将完成我们的Wordz应用程序的构建。
- en: Questions and answers
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题和答案
- en: 'The following are some questions and answers regarding this chapter’s content:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于本章内容的问题和答案：
- en: Have TDD and CI/CD pipelines eliminated the need for manual testing?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TDD和CI/CD管道是否消除了手动测试的需要？
- en: No. They have changed where the value lies. Some manual processes have become
    irrelevant, whereas others have increased in importance. Traditionally, manual
    steps, such as following test documents for feature testing and regression testing,
    are no longer required. Running feature and regression tests has changed from
    writing test plans in a word processor to writing test code in an IDE. But for
    many human-centric tasks, having a human mind in the loop remains vital to success.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 不。它们已经改变了价值所在的地方。一些手动流程已经变得无关紧要，而另一些则变得更加重要。传统上，手动步骤，如遵循测试文档进行功能测试和回归测试，现在不再需要。运行功能和回归测试已经从在文字处理器中编写测试计划转变为在集成开发环境（IDE）中编写测试代码。但对于许多以人为中心的任务来说，在循环中保持人类思维对于成功至关重要。
- en: Will **artificial intelligence** (**AI**) automate away the remaining tasks?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 人工智能（AI）会自动化剩余的任务吗？
- en: This is unknown. Advances in AI at this time (the early 2020s) can probably
    improve visual identification and static code analysis. It is conceivable that
    AI image analysis may one day be able to provide a good/bad analysis of usability
    – but that is pure speculation, based on AI’s abilities to generate artworks today.
    Such a thing may remain impossible. In terms of practical advice now, assume that
    the recommended manual processes in this chapter will remain manual for some time.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个未知数。在2020年代初，人工智能的进步可能会改善视觉识别和静态代码分析。可以想象，人工智能图像分析有一天可能能够提供关于可用性的良好/不良分析——但这纯粹是基于人工智能今天生成艺术作品的能力的推测。这种事情可能仍然是不可能的。就目前的实际建议而言，假设本章中推荐的手动流程在一段时间内仍将保持手动操作。
- en: Further reading
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涉及的主题，请查看以下资源：
- en: '[https://dl.acm.org/doi/pdf/10.1145/274567.274574](https://dl.acm.org/doi/pdf/10.1145/274567.274574):'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://dl.acm.org/doi/pdf/10.1145/274567.274574](https://dl.acm.org/doi/pdf/10.1145/274567.274574):'
- en: An overview of the modern genesis of TDD by Kent Beck. While the ideas certainly
    predate this project, this is the central reference of modern TDD practice. This
    paper contains many important insights into software development and teams – including
    the quote make it run, make it right, make it fast, and the need to not feel like
    we are working all the time. Well worth reading.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Kent Beck对现代TDD起源的概述。虽然这些想法确实早于这个项目，但这却是现代TDD实践的中央参考。这篇论文包含了关于软件开发和团队的重要见解——包括“让它运行，让它正确，让它快速”的引言，以及我们不应该总感觉像是在工作的必要性。值得一读。
- en: Explore It, Elizabeth Hendrickson, ISBN 978-1937785024.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索它，Elizabeth Hendrickson，ISBN 978-1937785024。
- en: '[https://trunkbaseddevelopment.com/](https://trunkbaseddevelopment.com/).'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://trunkbaseddevelopment.com/](https://trunkbaseddevelopment.com/).'
- en: '[https://martinfowler.com/articles/feature-toggles.html](https://martinfowler.com/articles/feature-toggles.html).'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://martinfowler.com/articles/feature-toggles.html](https://martinfowler.com/articles/feature-toggles.html).'
- en: 'Inspired: How to create tech products customers love, Marty Cagan, ISBN 978-1119387503:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受启发的：如何创造客户喜爱的科技产品，Marty Cagan，ISBN 978-1119387503：
- en: An interesting book that talks about product management. While this may seem
    strange in a developer book on TDD, a lot of the ideas in this chapter came from
    developer experience in a dual-track agile project, following this book. Dual
    agile means that fast feedback loops on feature discovery feed into fast feedback
    agile/TDD delivery. Essentially, manual TDD is done at the product requirements
    level. This book is an interesting read regarding modern product management, which
    has adopted the principles of TDD for rapid validation of assumptions about user
    features. Many ideas in this chapter aim to improve the software at the product
    level.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一本关于产品管理的有趣书籍。虽然这在TDD开发者书籍中可能看起来有些奇怪，但本章中的许多想法都来自在双轨敏捷项目中跟随这本书的开发者经验。双敏捷意味着在功能发现上的快速反馈循环会输入到快速的敏捷/TDD交付中。本质上，手动TDD是在产品需求级别进行的。这本书是关于现代产品管理的有趣读物，它采用了TDD原则来快速验证关于用户功能的假设。本章中的许多想法旨在提高产品级别的软件。
