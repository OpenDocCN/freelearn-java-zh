- en: Chapter 8. Additional Play Information
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。额外的Play信息
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Testing with Travis CI
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Travis CI进行测试
- en: Monitoring with New Relic
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用New Relic进行监控
- en: Integrating a Play application with AngularJS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Play应用程序与AngularJS集成
- en: Integrating a Play application with Parse
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Play应用程序与Parse集成
- en: Creating a Play development environment using Vagrant
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vagrant创建Play开发环境
- en: Coding Play 2 web apps with IntelliJ IDEA 14
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用IntelliJ IDEA 14编写Play 2网络应用
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will explore additional recipes for Play that developers
    will find handy and useful in their toolbox. We will touch on automated testing
    and monitoring tools for Play 2.0 web applications that are essential auxiliary
    tools for the modern web application. We will also look at integrating an AngularJS
    frontend and integrating [Parse.com](http://Parse.com), a **Backend-as-a-Service**
    (**BaaS**), to manage our data in a Play web application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Play的额外食谱，开发者会发现这些食谱在他们的工具箱中非常实用和有用。我们将涉及Play 2.0网络应用的自动化测试和监控工具，这些是现代网络应用必不可少的辅助工具。我们还将探讨将AngularJS前端集成以及集成[Parse.com](http://Parse.com)，一个**后端即服务**（**BaaS**），以在Play网络应用中管理我们的数据。
- en: Finally, we will look into automating the creation of a Play development environment
    using the popular tool **Vagrant**, allowing developers to create shareable and
    more portable development environments.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨使用流行的工具**Vagrant**自动化创建Play开发环境，允许开发者创建可共享和更便携的开发环境。
- en: Testing with Travis CI
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Travis CI进行测试
- en: For this recipe, we will explore how to use **Travis CI** to build and run automated
    tests for a Play 2.0 web app. We need to sign up for an account on Travis CI together
    with a Github account. We will also configure our Travis account in such a way
    that it is connected to a Github repository to conduct automatic tests on code
    commits.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将探讨如何使用**Travis CI**为Play 2.0网络应用构建和运行自动化测试。我们需要在Travis CI上注册一个账户，并与GitHub账户一起注册。我们还将配置我们的Travis账户，使其连接到一个GitHub仓库，以便在代码提交上进行自动测试。
- en: How to do it…
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'For this recipe, you need to perform the following steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，您需要执行以下步骤：
- en: Create a Github account at [https://github.com/join](https://github.com/join):![](img/W1jMSmgF.jpg)
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[https://github.com/join](https://github.com/join)创建一个GitHub账户：![](img/W1jMSmgF.jpg)
- en: 'Create a new public Github repository called play2-travis at:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下位置创建一个新的公共GitHub仓库，命名为play2-travis：
- en: '[https://github.com/new](https://github.com/new)'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/new](https://github.com/new)'
- en: 'On your development machine, create a new Play 2.0 web app using the `activator`
    template `play-slick-angular-test-example`:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的开发机器上，使用`activator`模板`play-slick-angular-test-example`创建一个新的Play 2.0网络应用：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Edit `.travis.yml` to trigger our test script:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`.travis.yml`以触发我们的测试脚本：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Commit and push to the Github remote repository (please make special note of
    your Github username and specify it in the command below):'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交并推送到GitHub远程仓库（请特别注意您的GitHub用户名，并在以下命令中指定它）：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Sign up for a Travis account by using your Github account at:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的GitHub账户注册Travis账户：
- en: '[https://travis-ci.org](https://travis-ci.org)'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://travis-ci.org](https://travis-ci.org)'
- en: After Travis has synced your Github repositories, enable Travis builds for the
    play2-travis repository at
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Travis同步您的GitHub仓库后，在以下位置启用play2-travis仓库的Travis构建：
- en: '`https://travis-ci.org/profile/&lt;YOUR_GITHUB_USER&gt;`:'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`https://travis-ci.org/profile/<YOUR_GITHUB_USER>`:'
- en: '![](img/MFz8BeV6.jpg)'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/MFz8BeV6.jpg)'
- en: 'Next, modify `test/controllers/ReportSpec.scala` by adding a sample test failure:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过添加一个示例测试失败来修改`test/controllers/ReportSpec.scala`：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Commit and push to trigger a Travis build with the expected test failure:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交并推送以触发具有预期测试失败的Travis构建：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This should trigger our build in Travis after a few seconds. We expect our
    very first build to fail and should see a result similar to the following:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该在几秒钟后触发我们的构建。我们预计我们的第一次构建将失败，并且应该看到以下类似的结果：
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](img/BNTSYPGZ.jpg)'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/BNTSYPGZ.jpg)'
- en: 'Now, comment out the sample test failure in `test/controllers/ReportSpec.scala`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`test/controllers/ReportSpec.scala`中取消注释示例测试失败：
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s commit and push these latest changes, this time expecting our Travis
    build to pass:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们提交并推送这些最新的更改，这次我们期望Travis构建通过：
- en: '[PRE7]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This commit should again trigger a build in Travis, and this time around, we
    should see all of the tests passing in our Travis dashboard.![](img/SOMLDy56.jpg)
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个提交应该再次触发Travis的构建，这次我们应该在我们的Travis仪表板上看到所有测试都通过。![](img/SOMLDy56.jpg)
- en: How it works…
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we utilized Travis CI to build and execute tests in our linked
    Github repository. This setup enables us to establish a **development-commit-test**
    process. This setup requires user accounts for Travis CI and Github.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用了 Travis CI 在我们的链接 GitHub 存储库中构建和执行测试。这种设置使我们能够建立 **开发-提交-测试** 流程。此设置需要
    Travis CI 和 GitHub 的用户账户。
- en: 'Once we have identified a Github repository, we want to integrate with Travis.
    We need to update the Travis configuration (`.travis.yml`) in the project root,
    specifying a run script to execute our webapp tests:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了 GitHub 存储库，我们希望与 Travis 集成。我们需要更新项目根目录中的 Travis 配置（`.travis.yml`），指定一个运行脚本以执行我们的网络应用程序测试：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is the command that Travis executes when running our tests. Travis will
    configure builds based on the settings in the `.travis.yml` configuration file
    (in our recipe, running the `sbt` task test) to execute our webapp tests. Build
    results are displayed on the repository dashboard in Travis:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Travis 在运行我们的测试时执行的命令。Travis 将根据 `.travis.yml` 配置文件（在我们的配方中，运行 `sbt` 任务测试）中的设置来配置构建，以执行我们的网络应用程序测试。构建结果在
    Travis 的存储库仪表板上显示：
- en: '![](img/y58YdeMZ.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/y58YdeMZ.jpg)'
- en: Once we have our Github repository linked and enabled in Travis, we observe
    that a build is triggered after every code commit and pushed to the Github repository.
    This is a great development tool and process for developers to be made aware of
    any regression issues to recently checked-in code, with support for other build
    tooling such as artifact publishing and notifications.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将 GitHub 存储库链接并启用在 Travis 中，我们会观察到每次代码提交并推送到 GitHub 存储库后都会触发构建。这对于开发者来说是一个很好的开发工具和流程，可以帮助他们意识到最近提交的代码中的回归问题，并支持其他构建工具，如工件发布和通知。
- en: Monitoring with New Relic
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 New Relic 进行监控
- en: For this recipe, we will deploy a Play 2.0 web app using Docker and Digital
    Ocean, and monitor the web app using **New Relic**. We will deploy the web app
    as a Docker container and detail out how to instrument the computer-database-scala
    sample web application using a New Relic JAR file integrated with our activator
    build script.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将使用 Docker 和 Digital Ocean 部署 Play 2.0 网络应用程序，并使用 **New Relic** 监控该网络应用程序。我们将以
    Docker 容器的形式部署网络应用程序，并详细说明如何使用与我们的 activator 构建脚本集成的 New Relic JAR 文件来对 computer-database-scala
    示例网络应用程序进行配置。
- en: How to do it…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'For this recipe, you need to perform the following steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，您需要执行以下步骤：
- en: First, sign up for a New Relic account at [https://newrelic.com/signup](https://newrelic.com/signup)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 [https://newrelic.com/signup](https://newrelic.com/signup) 注册 New Relic
    账户
- en: Create a new Java application in the New Relic dashboard:![](img/mkHMw6TA.jpg)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 New Relic 仪表板中创建一个新的 Java 应用程序：![](img/mkHMw6TA.jpg)
- en: During the creation of the Java application, please make note of your New Relic
    license key:![](img/uUKAhSoN.jpg)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建 Java 应用程序期间，请注意您的 New Relic 许可证密钥：![](img/uUKAhSoN.jpg)
- en: Next, download the New Relic Java agent ZIP and make note of the download location.
    This ZIP file should contain the Java agent library, license key file, API documentation,
    and other useful New Relic resources.![](img/Eirt8Ocw.jpg)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，下载 New Relic Java 代理 ZIP 文件，并记下下载位置。此 ZIP 文件应包含 Java 代理库、许可证密钥文件、API 文档和其他有用的
    New Relic 资源。![](img/Eirt8Ocw.jpg)
- en: 'Unzip the Java agent ZIP file and make note of two important files that we
    will need, `newrelic.yml` and `newrelic.jar`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压 Java 代理 ZIP 文件，并注意两个重要的文件，我们将需要的 `newrelic.yml` 和 `newrelic.jar`：
- en: '[PRE9]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Edit the `newrelic.yml` file by adding a relevant name to the setting parameter
    `app_name`, For this recipe, we will name our `app_name`, `computer-database-scala`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加相关名称到设置参数 `app_name` 编辑 `newrelic.yml` 文件，对于这个配方，我们将 `app_name` 命名为 `computer-database-scala`：
- en: '[PRE10]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a new Play web application using the `activator` template `computer-database-scala`,
    and change it into the project root directory:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `activator` 模板 `computer-database-scala` 创建一个新的 Play 网络应用程序，并将其更改到项目根目录：
- en: '[PRE11]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create an `instrument` directory in the `conf` directory:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `conf` 目录中创建一个 `instrument` 目录：
- en: '[PRE12]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Copy our two New Relic config files to `conf/instrument`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的两个 New Relic 配置文件复制到 `conf/instrument`：
- en: '[PRE13]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Edit `conf/application.conf` to enable automatic database evolution:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `conf/application.conf` 以启用自动数据库演变：
- en: '[PRE14]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add a newer version of the native Docker packager `sbt` plugin in `project/plugins.sbt`,
    which has additional native support for Docker:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `project/plugins.sbt` 中添加较新版本的本地 Docker 打包器 `sbt` 插件，它具有对 Docker 的额外原生支持：
- en: '[PRE15]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Edit `build.sbt` to specify docker-specific settings for the web app:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `build.sbt` 以指定网络应用程序的特定 Docker 设置：
- en: '[PRE16]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create the Docker image using `activator`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `activator` 创建 Docker 镜像：
- en: '[PRE17]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Log in to Docker from your local development machine using your Docker Hub
    credentials:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的Docker Hub凭据从您的本地开发机器登录到Docker：
- en: '[PRE18]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Build the image and upload to [hub.docker.com](http://hub.docker.com) using
    `activator`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`activator`构建镜像并上传到[hub.docker.com](http://hub.docker.com)：
- en: '[PRE19]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Pull the `play2-deploy-81` Docker image from [hub.docker.com](http://hub.docker.com)
    into the virtual machine we will be deploying the web application on:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[hub.docker.com](http://hub.docker.com)拉取`play2-deploy-81` Docker镜像到我们将部署网络应用程序的虚拟机中：
- en: '[PRE20]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the `play2-deploy-81` Docker container in the same remote virtual machine:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一远程虚拟机中运行`play2-deploy-81` Docker容器：
- en: '[PRE21]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using a web browser, you should now be able to access our just-deployed computer
    database web application:![](img/Y52a0H5f.jpg)
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网络浏览器，您现在应该能够访问我们刚刚部署的计算机数据库网络应用程序：![](img/Y52a0H5f.jpg)
- en: Now, log in to your New Relic account and navigate to your application's dashboard.
    You should be able to see some relevant application statistics in the form of
    charts and graphs:![](img/JD52glse.jpg)
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，登录到您的New Relic账户并导航到您的应用程序仪表板。您应该能够以图表和图形的形式看到一些相关的应用程序统计数据：![](img/JD52glse.jpg)
- en: How it works…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we deployed a Play 2.0 web application in a remote **virtual
    machine** (**vm**). For the virtual machine, we used CoreOS version 607.0.0 as
    the base operating system, which should automatically install Docker:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们在远程**虚拟机**（**vm**）中部署了Play 2.0网络应用程序。对于虚拟机，我们使用了CoreOS版本607.0.0作为基础操作系统，它应该会自动安装Docker：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once the deployment VM was set up, we turned our attention to setting up our
    New Relic account. After creating the account, we downloaded the New Relic Java
    agent and made a special note of our account license key with New Relic. We will
    use both next, as we integrate the New Relic java agent with our Play web application:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦部署虚拟机设置完成，我们就将注意力转向设置我们的New Relic账户。创建账户后，我们下载了New Relic Java代理，并特别记录了我们的账户许可证密钥。我们将两者都使用，因为我们将在我们的Play网络应用程序中集成New
    Relic Java代理：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We used the activator template `computer-database-scala` for this recipe as
    our sample Play web application.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用activator模板`computer-database-scala`作为本食谱中的示例Play网络应用程序。
- en: 'Once we have our web project generated, we will place the two New Relic config
    files inside the `conf/instrument` directory in our project root:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们生成了我们的Web项目，我们将把两个New Relic配置文件放在项目根目录下的`conf/instrument`目录中：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To load the native Docker packager, we need to add the `sbt-native-packager`
    plugin to our build plugins file in `project/plugins.sbt`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载本机Docker打包器，我们需要将`sbt-native-packager`插件添加到我们的`project/plugins.sbt`构建插件文件中：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The last step is to configure our main build file `build.sbt`, to specify the
    docker-specific settings to create the image:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是配置我们的主要构建文件`build.sbt`，以指定创建镜像的docker特定设置：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With the preceding settings, we specify the default repository in [hub.docker.com](http://hub.docker.com)
    and the main port number we will be exposing our app in (in this recipe, port
    number 9000). The final setting is where we specify the `entrypoint` command.
    We had to modify it to pass in the necessary settings to specify the New Relic
    java agent:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的设置中，我们指定了[hub.docker.com](http://hub.docker.com)中的默认仓库和我们将公开应用程序的主要端口号（在本食谱中为端口号9000）。最后的设置是指定`entrypoint`命令的位置。我们不得不修改它，以便传递必要的设置来指定New
    Relic Java代理：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The generated `Dockerfile` from the preceding settings should look like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的设置生成的`Dockerfile`应该看起来像这样：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can verify that the New Relic java agent is loaded currently, by viewing
    the Docker logs as we run our Docker container:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行我们的Docker容器时查看Docker日志来验证当前是否已加载New Relic Java代理：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once we have installed and deployed the Docker container in our deployment
    VM, we can access the `computer-database-scala` web application using a web browser.
    We can then view all relevant instrumentation data points, such as JVM and database
    metrics, with charts and graphs, using the New Relic dashboard:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在部署虚拟机中安装和部署了Docker容器，我们就可以使用网络浏览器访问`computer-database-scala`网络应用程序。然后我们可以使用New
    Relic仪表板查看所有相关的仪表数据点，例如JVM和数据库指标，以图表和图形的形式：
- en: '![](img/jSVRWVg1.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/jSVRWVg1.jpg)'
- en: 'Here, we can view how in-depth New Relic''s application metrics are, with reporting
    views for the JVM, database connections, and so on:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以查看New Relic的应用指标有多深入，包括JVM、数据库连接等的报告视图：
- en: '![](img/zdXzAn7U.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/zdXzAn7U.jpg)'
- en: Integrating a Play application with AngularJS
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Play应用程序与AngularJS集成
- en: For this recipe, we will integrate a Play web application with an AngularJS-based
    frontend. AngularJS is a popular JavaScript framework and provides developers
    with tools to build powerful interactive UIs with ease. Some familiarity with
    AngularJS is assumed for this recipe.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将集成一个基于AngularJS的前端Play web应用程序。AngularJS是一个流行的JavaScript框架，为开发者提供了构建强大交互式UI的便捷工具。本食谱假定开发者对AngularJS有一定的了解。
- en: More information about AngularJS can be found here at [https://angularjs.org/](https://angularjs.org/).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于AngularJS的信息可以在[https://angularjs.org/](https://angularjs.org/)找到。
- en: In this recipe, we will also use WebJars, a Play-friendly dependency management
    repository, to manage our AngularJS libraries.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们还将使用WebJars，一个Play友好的依赖管理仓库，来管理我们的AngularJS库。
- en: More information about WebJars can be found at [http://www.webjars.org/](http://www.webjars.org/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于WebJars的信息可以在[http://www.webjars.org/](http://www.webjars.org/)找到。
- en: We will also be using RequireJS, which is a JavaScript module script loader,
    to manage the AngularJS module and `public/javascripts/main.js`, our main application
    JavaScript module. For more information about RequireJS, refer to their online
    documentation at [http://requirejs.org/](http://requirejs.org/).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用RequireJS，这是一个JavaScript模块脚本加载器，用于管理AngularJS模块和`public/javascripts/main.js`，我们的主要应用程序JavaScript模块。有关RequireJS的更多信息，请参阅他们的在线文档[http://requirejs.org/](http://requirejs.org/)。
- en: How to do it…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'For this recipe, you need to perform the following steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，你需要执行以下步骤：
- en: 'Create a new Play 2 web application project by using the `activator` template
    `play-scala`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`activator`模板`play-scala`创建一个新的Play 2 web应用程序项目：
- en: '[PRE30]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Edit the `build.sbt` build file to import RequireJS, AngularJS, and Bootstrap:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`build.sbt`构建文件以导入RequireJS、AngularJS和Bootstrap：
- en: '[PRE31]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Edit the contents of the default application controller file `app/controllers/Application.scala`,
    and replace the contents with the following snippet:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑默认应用程序控制器文件`app/controllers/Application.scala`的内容，并用以下片段替换：
- en: '[PRE32]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Edit the contents of the routes file `conf/routes`, and replace with the following
    snippet:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑路由文件`conf/routes`的内容，并用以下片段替换：
- en: '[PRE33]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Edit the contents of the default index template HTML file `app/views/index.scala.html`
    and replace with the following snippet:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑默认索引模板HTML文件`app/views/index.scala.html`的内容，并用以下片段替换：
- en: '[PRE34]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Edit the contents of the default layout template file `app/views/main.scala.html`
    and replace with the following snippets:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑默认布局模板文件`app/views/main.scala.html`的内容，并用以下片段替换：
- en: '[PRE35]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add the main JavaScript file for our web application in `public/javascripts/main.js`
    and add the following snippet:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`public/javascripts/main.js`中添加我们web应用程序的主要JavaScript文件，并添加以下片段：
- en: '[PRE36]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we add the Angular controller JavaScript file in `public/javascripts/controllers.js`
    with the following contents:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在`public/javascripts/controllers.js`中添加了Angular控制器JavaScript文件，内容如下：
- en: '[PRE37]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After adding the angular controllers file, we add the Angular factory JavaScript
    file in `public/javascript/services.js` with the following contents:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加angular控制器文件后，我们在`public/javascript/services.js`中添加了Angular工厂JavaScript文件，内容如下：
- en: '[PRE38]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, we add the products partial HTML file in `public/javascripts/partials/products.html`
    with the following contents:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在`public/javascripts/partials/products.html`中添加了产品部分的HTML文件，内容如下：
- en: '[PRE39]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can now execute the `activator` command `run` to start the Play 2 web application:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以执行`activator`命令`run`来启动Play 2 web应用程序：
- en: '[PRE40]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Using `curl`, we can verify that our products API endpoint is working correctly:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`，我们可以验证我们的产品API端点是否正常工作：
- en: '[PRE41]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can now access our Angular-driven products listing page with the Play 2 backed
    API endpoint by loading the URL `http://localhost:9000` in a web browser:![](img/rmqhYqAm.jpg)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以通过在浏览器中加载URL`http://localhost:9000`来访问由Play 2支持的API端点驱动的产品列表页面：![图片](img/rmqhYqAm.jpg)
- en: How it works…
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we created a Play 2 web application that used AngularJS and
    Bootstrap to display a listing of products. The list of products was served by
    a Play 2-based Rest API endpoint, which returns a set of products that contain
    a product title and SKU.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们创建了一个使用AngularJS和Bootstrap来显示产品列表的Play 2 web应用程序。产品列表由基于Play 2的Rest
    API端点提供，该端点返回包含产品标题和SKU的产品集。
- en: To wire up everything together, we had to modify a few configuration settings
    to the base play-scala `activator` template and add new JavaScript files that
    contained our main AngularJS script.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将所有东西连接起来，我们不得不修改一些基于play-scala的`activator`模板的配置设置，并添加包含我们主要AngularJS脚本的JavaScript文件。
- en: 'First, we had to declare that our web application required AngularJS, RequireJS,
    and Bootstrap by modifying our library dependencies in the `build.sbt` file:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须通过修改`build.sbt`文件中的库依赖项来声明我们的Web应用程序需要AngularJS、RequireJS和Bootstrap：
- en: '[PRE42]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we modified the application controller to add a product case class and
    the `listProducts` action, which will serve our products API endpoint:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们修改了应用程序控制器，添加了一个产品案例类和`listProducts`操作，这将服务于我们的产品API端点：
- en: '[PRE43]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we need to modify our `routes` file to declare new routes and reconfigure
    an existing route:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改我们的`routes`文件以声明新路由和重新配置现有路由：
- en: '[PRE44]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding snippet, we reconfigured the existing `/assets/*file` route
    by using the `versioned` action instead. We then added the products API endpoint
    route and the route entry for the WebJars assets.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们通过使用`versioned`操作来重新配置现有的`/assets/*file`路由。然后我们添加了产品API端点路由和WebJars资产的路由条目。
- en: 'Next, we need to make modifications to the existing `app/views/index.scala.html`
    template to insert the Angular View tag to render partial HTMLs:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改现有的`app/views/index.scala.html`模板以插入Angular视图标签来渲染部分HTML：
- en: '[PRE45]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The next step would be to modify the layouts template file `app/views/main.scala.html`
    to load our main JavaScript file and its dependencies:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是修改布局模板文件`app/views/main.scala.html`以加载我们的主要JavaScript文件及其依赖项：
- en: '[PRE46]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We then need to add our main JavaScript file in `public/javascripts/main.js`
    to configure our main Angular app:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要在`public/javascripts/main.js`中添加我们的主要JavaScript文件以配置我们的主要Angular应用程序：
- en: '[PRE47]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the preceding snippet, we initialized Angular and two other Angular plugins,
    `angular-routes` and `angular-resources`, which will handle request routes and
    manage API calls respectively. We also loaded and initialized our Angular controllers
    and services script files:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们初始化了Angular和另外两个Angular插件`angular-routes`和`angular-resources`，它们将处理请求路由并管理API调用。我们还加载并初始化了我们的Angular控制器和服务脚本文件：
- en: '[PRE48]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Lastly, we configured our Angular app routes using the `$routeProvider` directive.
    For this recipe, the base URL loads the products controller by default, using
    the template partial `public/javascripts/partials/products.html`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`$routeProvider`指令配置了我们的Angular应用程序路由。对于这个菜谱，默认情况下，基本URL通过模板部分`public/javascripts/partials/products.html`加载产品控制器：
- en: '[PRE49]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: For this recipe, we were successfully able to integrate AngularJS with our Play
    2 web application using the WebJars repository to manage all frontend libraries
    (for this recipe, Angular, RequireJS, and Bootstrap). We were able to access a
    products API endpoint and display its contents in an Angular template.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们成功地将AngularJS与我们的Play 2 Web应用程序集成，使用WebJars仓库来管理所有前端库（在这个菜谱中，Angular、RequireJS和Bootstrap）。我们能够访问产品API端点并显示其内容在Angular模板中。
- en: Integrating a Play application with Parse.com
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Play应用程序与Parse.com集成
- en: For this recipe, we will integrate a Play 2 Rest API with a BaaS such as [Parse.com](http://Parse.com)'s
    Parse Core, which is a cloud service that allows developers to store data in the
    cloud. In this recipe, we want to be able to see how we can use Play to integrate
    other external web services into our web application. It should not be uncommon
    for modern web applications to have more than one data source. We will use a Parse
    Core application to mimic this. We will use the Play WS library to connect to
    the Parse API, particularly using HTTP headers to send application credentials
    and JSON data to the Parse API web service. We will also be able to use [Parse.com](http://Parse.com)'s
    own core data browser to view the data we have stored in our Parse Core application.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将集成一个Play 2 Rest API与一个BaaS，如[Parse.com](http://Parse.com)的Parse Core，这是一个允许开发者将数据存储在云中的云服务。在这个菜谱中，我们想要看看我们如何使用Play将其他外部Web服务集成到我们的Web应用程序中。对于现代Web应用程序来说，拥有多个数据源并不罕见。我们将使用一个Parse
    Core应用程序来模拟这一点。我们将使用Play WS库来连接到Parse API，特别是使用HTTP头发送应用程序凭据和JSON数据到Parse API
    Web服务。我们还将能够使用[Parse.com](http://Parse.com)自己的核心数据浏览器来查看我们在Parse Core应用程序中存储的数据。
- en: For this recipe, we will need a [Parse.com](http://Parse.com) account. You can
    sign up for one at [https://parse.com/#signup](https://parse.com/#signup).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们需要一个[Parse.com](http://Parse.com)账户。你可以在[https://parse.com/#signup](https://parse.com/#signup)注册一个账户。
- en: How to do it…
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'For this recipe, you need to perform the following steps:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，你需要执行以下步骤：
- en: Sign in to your [Parse.com](http://Parse.com) account and create a new Parse
    Core application:![](img/j2XLqIq7.jpg)
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到你的[Parse.com](http://Parse.com)账户并创建一个新的Parse Core应用程序！![图片](img/j2XLqIq7.jpg)
- en: Once a new Parse app has been created, navigate to the **settings** section
    to retrieve your **application ID** and **Rest API key**:![](img/dNeR7iVv.jpg)
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Parse应用后，导航到**设置**部分以检索您的**应用程序ID**和**Rest API密钥**：![图片](img/dNeR7iVv.jpg)
- en: Next, create a new Parse class (analogous to a database table) in the Parse
    Core section. For this recipe, we will store **Item** records:![](img/ptAW9lE1.jpg)
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在Parse Core部分创建一个新的Parse类（类似于数据库表）。对于这个菜谱，我们将存储**Item**记录：![图片](img/ptAW9lE1.jpg)
- en: After creating the Parse class, add the necessary columns for our items. For
    this recipe, we will add the **title** and SKU columns:![](img/uMTZKg5W.jpg)
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Parse类后，为我们的项目添加必要的列。对于这个菜谱，我们将添加**标题**和SKU列：![图片](img/uMTZKg5W.jpg)
- en: 'Next, we will work on our Play 2 web application that will interface with Parse
    Core. Generate a new Play 2 web application based on the activator template `play-scala`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将着手于我们的Play 2 Web应用，该应用将与Parse Core进行交互。基于activator模板`play-scala`生成一个新的Play
    2 Web应用：
- en: '[PRE50]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, create a new plugin in `app/plugins/ParsePlugin.scala`, with the following
    content:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`app/plugins/ParsePlugin.scala`中创建一个新的插件，以下内容：
- en: '[PRE51]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, add the Parse Core keys, which we made note of in the previous step,
    in the `conf/application.conf file`. Make sure to replace the placeholders with
    your actual Parse app ID and Rest key:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`conf/application.conf`文件中添加Parse Core密钥，我们在上一步中做了笔记。确保用您实际的Parse应用ID和Rest密钥替换占位符：
- en: '[PRE52]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, create our Parse helper class in `app/plugins/ParseAPI.scala`, with the
    following content:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`app/plugins/ParseAPI.scala`中创建我们的Parse辅助类，以下内容：
- en: '[PRE53]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, initialize the plugin on the app startup by creating the Play plugins
    configuration file in `conf/play.plugins` with the following content:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在应用启动时初始化插件，在`conf/play.plugins`中创建Play插件配置文件，以下内容：
- en: '[PRE54]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, let''s add our `Items` controller in the `app/controllers/Items.scala`
    file, with the following contents, which should add two action methods, `index()`,
    for returning items from Parse Core, and `create()`, which will persist items
    on Parse Core:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们在`app/controllers/Items.scala`文件中添加我们的`Items`控制器，以下内容将添加两个操作方法，`index()`用于从Parse
    Core返回项目，以及`create()`，它将在Parse Core上持久化项目：
- en: '[PRE55]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Add the necessary routes entry in the `conf/routes` file for our `Items` actions:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`conf/routes`文件中添加必要的路由条目以供我们的`Items`操作使用：
- en: '[PRE56]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To run our web application, we will use the activator command `run`, with the
    tilde character (~) to signify that we want Hot-Reloading enabled for this web
    application:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行我们的Web应用，我们将使用activator命令`run`，使用波浪字符(~)表示我们希望为此Web应用启用热重载：
- en: '[PRE57]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Using `curl`, we can now insert new records into our Parse Core application:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`，我们现在可以向我们的Parse Core应用中插入新的记录：
- en: '[PRE58]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, we can also retrieve `items` stored on Parse Core by using `curl`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们也可以通过使用`curl`检索存储在Parse Core上的`items`：
- en: '[PRE59]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works…
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we looked into a more practical example of integrating an external
    web service with a Play 2 web application using the Play WS library. The Play
    WS library saves developers from a lot of boilerplate code in setting up and connecting
    to a remote HTTP host, it also provides convenient methods to set up headers,
    request parameters, and so on.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们查看了一个更实际的示例，即使用Play WS库将外部Web服务与Play 2 Web应用集成。Play WS库在设置和连接到远程HTTP主机时节省了开发者大量的样板代码，它还提供了方便的方法来设置头信息、请求参数等。
- en: Parse Core is a very popular and solid backend-as-a-service provider, which
    offers other developer services, such as mobile push notifications and mobile
    analytics, all of which are important additions to any developer toolchain.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Parse Core是一个非常受欢迎且稳定的后端即服务提供商，它为开发者提供其他服务，如移动推送通知和移动分析，这些都是任何开发者工具链的重要补充。
- en: 'Essential to this recipe is signing up for a [Parse.com](http://Parse.com)
    account and creating a Parse Core application. Once we have that set up, we can
    proceed to creating a Play plugin, which will take care of the initialization
    and setting up of our connection to the Parse API:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱来说，注册一个[Parse.com](http://Parse.com)账户并创建一个Parse Core应用是至关重要的。一旦我们设置好，我们就可以继续创建一个Play插件，该插件将负责初始化和设置我们与Parse
    API的连接：
- en: '[PRE60]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Next, we create our Parse Core delegate class `conf/plugins/ParseAPI.scala`,
    which will encapsulate all interfacing with the Parse API:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的Parse Core代理类`conf/plugins/ParseAPI.scala`，它将封装所有与Parse API的交互：
- en: '[PRE61]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In the preceding class, we created two public methods that should have data
    retrieval and record creation. We include the required Parse API headers for authentication
    whenever we do a `GET` or `POST` request:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类中，我们创建了两个公共方法，应该具有数据检索和记录创建的功能。我们在进行 `GET` 或 `POST` 请求时包括所需的 Parse API
    身份验证头：
- en: '[PRE62]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'For the `POST` request, we add the required additional header to set our content
    type to `application/json`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `POST` 请求，我们添加所需的附加头，将内容类型设置为 `application/json`：
- en: '[PRE63]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Once the Parse plugin is all set up, we create the `Items` controller, which
    will receive the requests for items and item creation and will be responsible
    for the delegation of these requests to the Parse API helper:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Parse 插件全部设置完成，我们创建 `Items` 控制器，它将接收项目请求和项目创建请求，并将负责将这些请求委派给 Parse API 辅助工具：
- en: '[PRE64]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Do not forget to add the subsequent routes in the `conf/routes` config file:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在 `conf/routes` 配置文件中添加后续的路由：
- en: '[PRE65]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can use the Parse Core dashboard to view all data created via the Parse
    API:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Parse Core 仪表板查看通过 Parse API 创建的所有数据：
- en: '![](img/K0GHawAH.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/K0GHawAH.jpg)'
- en: There's more…
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: For more information about Parse Core, please refer to their online documentation
    found at [https://parse.com/docs](https://parse.com/docs).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Parse Core 的更多信息，请参阅他们位于 [https://parse.com/docs](https://parse.com/docs)
    的在线文档。
- en: Creating a Play development environment using Vagrant
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Vagrant 创建 Play 开发环境
- en: We will explore how to create a portable development environment for Play 2
    development using **Vagrant**, a powerful addition to any developer's toolchain.
    Vagrant allows developers to automate the creation of a development environment,
    from installing the required development kits for **Read-Eval-Print Loop** (**REPL**)
    tools, to installing other services such as MySQL and Redis. This setup is useful
    for multimember development teams or developers who work off of multiple workstations,
    where a consistent, identical development environment is necessary and ideal.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何创建一个用于 Play 2 开发的便携式开发环境，使用 **Vagrant**，这是任何开发者工具链的有力补充。Vagrant 允许开发者自动化创建开发环境，从安装用于
    **Read-Eval-Print Loop** (**REPL**) 工具所需的开发套件，到安装其他服务如 MySQL 和 Redis。这种设置对于多成员开发团队或需要在多个工作站上工作的开发者来说非常有用，其中需要一个一致、相同的开发环境，这是必要且理想的。
- en: For this recipe, we will create our Vagrant instance from the ground up, installing
    the required libraries to run our sample Play web application, and running a MySQL
    service using Docker and the actual sample Play web application using the `activator`
    template `play-slick-angular-test-example`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将从头开始创建我们的 Vagrant 实例，安装运行我们的示例 Play 网络应用程序所需的库，并使用 Docker 运行 MySQL
    服务，以及使用 `activator` 模板 `play-slick-angular-test-example` 运行实际的示例 Play 网络应用程序。
- en: How to do it…
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'For this recipe, you need to perform the following steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，你需要执行以下步骤：
- en: 'Install Vagrant by following the installation instructions at the following
    link:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下链接中的安装说明安装 Vagrant：
- en: '[https://docs.vagrantup.com/v2/installation/index.html](https://docs.vagrantup.com/v2/installation/index.html)'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Vagrant 安装文档](https://docs.vagrantup.com/v2/installation/index.html)'
- en: 'You should now have a version of Vagrant installed locally:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你应该已经安装了本地的 Vagrant 版本：
- en: '[PRE66]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Create a workspace directory and change into the newly created directory:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个工作空间目录并切换到新创建的目录：
- en: '[PRE67]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create a `Vagrantfile` in the project root with the following content:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目根目录中创建一个 `Vagrantfile`，内容如下：
- en: '[PRE68]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Create a Bootstrap bash script file `bootstrap.sh`, with the following content:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Bootstrap bash 脚本文件 `bootstrap.sh`，内容如下：
- en: '[PRE69]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Create a git ignore file `.gitignore`, to exclude the Vagrant directory workspace
    from git:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 git 忽略文件 `.gitignore`，以排除 Vagrant 目录工作空间从 git：
- en: '[PRE70]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Once Vagrant is installed and our `Vagrantfile` has been configured properly,
    we can initialize our Vagrant instance:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 Vagrant 安装完成并且我们的 `Vagrantfile` 已经正确配置，我们就可以初始化我们的 Vagrant 实例：
- en: '[PRE71]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We can log in to the Vagrant instance using the following command:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令登录到 Vagrant 实例：
- en: '[PRE72]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Once logged in to the Vagrant instance, change into the Vagrant workspace directory
    with the following command:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到 Vagrant 实例后，使用以下命令切换到 Vagrant 工作空间目录：
- en: '[PRE73]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'List the contents of the `/vagrant` directory to verify that you are in the
    correct directory:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出 `/vagrant` 目录的内容以验证你处于正确的目录：
- en: '[PRE74]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'For this recipe, we will use the `activator` template `play-slick-angular-test-example`
    and generate a new Play 2 project based on this:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将使用 `activator` 模板 `play-slick-angular-test-example` 并基于此生成一个新的 Play
    2 项目：
- en: '[PRE75]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Edit the configuration file in `conf/application.conf` by modifying the following
    lines of code:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过修改以下代码行编辑 `conf/application.conf` 配置文件：
- en: '[PRE76]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Run the Play web application using `activator`:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `activator` 运行 Play 网络应用：
- en: '[PRE77]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You should now be able to access the Play web application by using a web browser:![](img/aLB0M6Rs.jpg)
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你应该能够通过网页浏览器访问 Play 网络应用：![](img/aLB0M6Rs.jpg)
- en: How it works…
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: 'In this recipe, we installed Vagrant, a popular developer tool that automates
    the initialization and setup of developer environments, as per the following steps:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们按照以下步骤安装了 Vagrant，这是一个流行的开发者工具，它自动化了开发者环境的初始化和设置：
- en: 'In the `Vagrantfile` config file, we declared that we will be using a Centos
    6.5 Vagrant box as our base OS:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Vagrantfile` 配置文件中，我们声明我们将使用 Centos 6.5 Vagrant box 作为我们的基础操作系统：
- en: '[PRE78]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We declared that we want our `bootstrap.sh` script file to be run during the
    Vagrant instance provisioning:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明在 Vagrant 实例配置过程中运行我们的 `bootstrap.sh` 脚本文件：
- en: '[PRE79]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Next, we declared which ports to forward from our vagrant instance to our host
    machine, port 9000 for Play and port 3306 for MySQL:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们声明了从我们的 Vagrant 实例转发到主机机的端口，Play 使用端口 9000，MySQL 使用端口 3306：
- en: '[PRE80]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Finally, we optionally configured our Vagrant instance to have a 4-GB RAM and
    utilize two CPUs:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可选地配置了我们的 Vagrant 实例具有 4-GB RAM 并使用两个 CPU：
- en: '[PRE81]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We installed relevant tools for Play development, which we specified in the
    `bootstrap.sh` script file. We declared the version of Scala and Activator at
    the top of the `bootstrap.sh` file:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们安装了用于 Play 开发的相关工具，我们在 `bootstrap.sh` 脚本文件中指定了这些工具。我们在 `bootstrap.sh` 文件的顶部声明了
    Scala 和 Activator 的版本：
- en: '[PRE82]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We also declared the default MySQL password to use for our MySQL instance:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还声明了用于我们的 MySQL 实例的默认密码：
- en: '[PRE83]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Next, we installed the required and necessary CentOS packages:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们安装了所需的 CentOS 软件包：
- en: '[PRE84]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The next packages to install are Docker and its required libraries:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个要安装的软件包是 Docker 及其所需的库：
- en: '[PRE85]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Next, we installed the JDK, a Scala binary, and Activator:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们安装了 JDK、Scala 二进制文件和 Activator：
- en: '[PRE86]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Finally, we ran a MySQL Docker container on the instance start up:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在实例启动时运行了一个 MySQL Docker 容器：
- en: '[PRE87]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We run the Vagrant command `vagrant up`, to initialize the Vagrant instance
    from scratch. After a short while, our Play 2 development environment should be
    ready. Log in to the Vagrant instance using the command `vagrant ssh`. You should
    be able to verify whether all the required binaries have been installed:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们运行 Vagrant 命令 `vagrant up`，从头开始初始化 Vagrant 实例。经过一段时间后，我们的 Play 2 开发环境应该准备好了。使用命令
    `vagrant ssh` 登录到 Vagrant 实例。你应该能够验证是否已安装所有必需的二进制文件：
- en: '[PRE88]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Once the Vagrant instance is up and running, we can build and run a Play web
    application; in this recipe, the `play-slick-angular-test-example` activator template
    that we installed in the `/vagrant` directory:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 Vagrant 实例启动并运行，我们就可以构建和运行一个 Play 网络应用；在这个菜谱中，我们在 `/vagrant` 目录中安装的 `play-slick-angular-test-example`
    activator 模板：
- en: '[PRE89]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: There's more…
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Remember to pause your Vagrant instance whenever you want to shut down the
    instance for a while and return to it later:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在你想暂时关闭实例并稍后返回时暂停你的 Vagrant 实例：
- en: '[PRE90]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This allows the Vagrant instance to retain its current state without having
    to reinitialize the Vagrant instance later. For more information about Vagrant,
    refer to the documentation at [https://docs.vagrantup.com/v2/](https://docs.vagrantup.com/v2/).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许 Vagrant 实例在不重新初始化 Vagrant 实例的情况下保留其当前状态。有关 Vagrant 的更多信息，请参阅[https://docs.vagrantup.com/v2/](https://docs.vagrantup.com/v2/)的文档。
- en: Coding Play 2 web apps with IntelliJ IDEA 14
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 IntelliJ IDEA 14 编码 Play 2 网络应用
- en: 'For this recipe, we will explore how to use the popular IDE, IntelliJ IDEA
    14 to code Play 2 web applications. We will be using the community edition:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将探讨如何使用流行的 IDE，IntelliJ IDEA 14 来编码 Play 2 网络应用。我们将使用社区版：
- en: How to do it…
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'For this recipe, you need to perform the following steps:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，你需要执行以下步骤：
- en: 'Download and install IntelliJ IDEA 14 from the Jetbrains website:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 JetBrains 网站下载并安装 IntelliJ IDEA 14：
- en: '[https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/)'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/)'
- en: 'Navigate to the Play 2 web application with which you will want to use IDEA
    14; in this recipe, `play2-parse-84`:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你想使用 IDEA 14 的 Play 2 网络应用；在这个菜谱中，`play2-parse-84`：
- en: '[PRE91]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Using `activator`, generate the base IDEA 14 project files:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `activator` 生成基础 IDEA 14 项目文件：
- en: '[PRE92]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Start IntelliJ IDEA 14 and click on **Import Project**:![](img/Me0lXmyK.jpg)
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 IntelliJ IDEA 14 并点击 **导入项目**：![](img/Me0lXmyK.jpg)
- en: Using IDEA 14, navigate to the project directory of the project you want to
    work on; in this recipe, **play2-parse-84**:![](img/Oskb2rVI.jpg)
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用IDEA 14，导航到您想要工作的项目目录；在这个菜谱中，**play2-parse-84**:![](img/Oskb2rVI.jpg)
- en: On the next screen, select **SBT** as the external model for the project:![](img/CNcotwH8.jpg)
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏幕上，选择**SBT**作为项目的外部模型:![](img/CNcotwH8.jpg)
- en: Next, select additional project settings, such as the installed JDK version
    to use:![](img/ptXtiYwi.jpg)
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择额外的项目设置，例如要使用的已安装JDK版本:![](img/ptXtiYwi.jpg)
- en: After clicking on **Finish**, you should have your Play 2 web application loaded
    correctly on IntelliJ IDEA 14:![](img/RGPlTj7A.jpg)
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**完成**后，您应该在IntelliJ IDEA 14上正确加载了您的Play 2网络应用:![](img/RGPlTj7A.jpg)
- en: How it works…
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we simply used Activator's built-in support for IntelliJ IDEA
    to generate our Play 2 web applications IDEA project files using the command `activator
    idea`. Once we generated the IDEA project files from our current code base, all
    we needed to do was import it into IntelliJ IDEA and follow the project settings
    screens. We should now be able to work on our Play 2 web applications using IntelliJ
    IDEA.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们简单地使用了Activator内置对IntelliJ IDEA的支持，通过命令`activator idea`生成我们的Play 2网络应用IDEA项目文件。一旦我们从当前代码库中生成了IDEA项目文件，我们所需做的就是将其导入到IntelliJ
    IDEA中，并按照项目设置屏幕进行操作。现在我们应该能够使用IntelliJ IDEA来处理我们的Play 2网络应用。
