- en: '*Chapter 7*: Handling Microservice Concerns'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：处理微服务问题'
- en: Any microservice architecture implementation is incomplete without handling
    some fundamental microservice concerns such as **configuration management**, **API
    documentation**, **service discovery**, **API gateways**, and **fault tolerance**.
    Hitherto we were focused on the disintegration journey of the microservices, such
    as how to separate the concerns in modular microservices. For seamless and unified
    application access, we need the microservices to integrate and expose a coalesced
    interface. A coalesced interface enables the upstream consumers to interact with
    backend microservices as though they were one.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何微服务架构的实施如果没有处理一些基本的微服务问题都是不完整的，例如**配置管理**、**API文档**、**服务发现**、**API网关**和**容错**。迄今为止，我们关注的是微服务的分解之旅，例如如何在模块化微服务中分离关注点。为了实现无缝和统一的应用访问，我们需要微服务集成并暴露一个聚合接口。聚合接口使上游消费者能够像与单个微服务交互一样与后端微服务交互。
- en: A key benefit of implementing microservices is fault tolerance. Fault tolerance
    mechanisms such as on-demand scaling, fallbacks, and circuit breakers make microservices
    ubiquitous and robust.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 实施微服务的一个关键好处是容错性。如按需扩展、回退和断路器等容错机制使微服务无处不在且稳健。
- en: 'In this chapter, we will explore ways to handle and implement the following
    microservice concerns:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨处理和实施以下微服务问题的方法：
- en: Externalizing the application configuration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部化应用程序配置
- en: Documenting the service APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录服务API文档
- en: Implementing service discovery
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施服务发现
- en: Implementing the API gateway
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施API网关
- en: Implementing the fault-tolerance mechanisms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施容错机制
- en: By the end of this chapter, you will have practical knowledge of handling and
    implementing these key microservice concerns in the Micronaut framework.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将具备在Micronaut框架中处理和实施这些关键微服务问题的实际知识。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the commands and technical instructions in this chapter run on Windows 10
    and macOS. The code examples covered in this chapter are available on the book's
    GitHub repo at [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter07](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter07).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有命令和技术说明均在Windows 10和macOS上运行。本章涵盖的代码示例可在本书的GitHub仓库中找到，网址为[https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter07](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter07)。
- en: 'The following tools need to be installed and set up in the development environment:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在开发环境中安装和设置以下工具：
- en: '**Java SDK** version 13 or above (we used Java 14).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java SDK**版本13或更高（我们使用了Java 14）。'
- en: '**Maven** – This is optional and only required if you would like to use Maven
    as the build system. However, we recommend having Maven set up on any development
    machine. Instructions to download and install Maven can be found at [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maven** – 这不是必需的，只有当你想使用Maven作为构建系统时才需要。然而，我们建议在任何开发机器上设置Maven。有关下载和安装Maven的说明，请参阅[https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi)。'
- en: '**A development IDE** – Based on your preference, any Java-based IDE can be
    used, but for purpose of writing this chapter, IntelliJ was used.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发IDE** – 根据您的偏好，可以使用任何基于Java的IDE，但为了编写本章，我们使用了IntelliJ。'
- en: '**Git** – Instructions to download and install this can be found at [https://git-scm.com/downloads](https://git-scm.com/downloads).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Git** – 有关下载和安装的说明，请参阅[https://git-scm.com/downloads](https://git-scm.com/downloads)。'
- en: '**PostgreSQL** – Instructions to download and install this can be found at
    [https://www.postgresql.org/download/](https://www.postgresql.org/download/).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PostgreSQL** – 有关下载和安装的说明，请参阅[https://www.postgresql.org/download/](https://www.postgresql.org/download/)。'
- en: '**MongoDB** – MongoDB Atlas provides a free online database-as-a-service with
    up to 512 MB storage. However, if a local database is preferred then instructions
    to download and install this can be found at [https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/).
    We used a local installation for writing this chapter.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MongoDB** – MongoDB Atlas提供了一个免费在线数据库即服务，存储空间高达512 MB。然而，如果您更喜欢本地数据库，则有关下载和安装的说明，请参阅[https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/)。我们为本章的编写使用了本地安装。'
- en: '**A REST client** – Any HTTP REST client can be used. We used the Advanced
    REST Client Chrome plugin.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**REST客户端** – 可以使用任何HTTP REST客户端。我们使用了Advanced REST Client Chrome插件。'
- en: '**Docker** – Instructions to download and install Docker can be found at [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker** – 有关下载和安装Docker的说明，请参阅[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)。'
- en: Externalizing the application configuration
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部化应用程序配置
- en: Irrespective of the size and complexities of a microservice application, the
    task of maintaining the configuration settings for each service seems one of the
    most crucial aspects of working with microservices. Decoupling the service configurations
    goes back to our earlier discussion on separating the concerns. In the earlier
    chapters, we have seen how we can handle service configurations using the `application.properties`
    files. Though this is a step up from not hard-coding these configurations in production
    code, it's still not enough.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 无论微服务应用的大小和复杂性如何，维护每个服务的配置设置的任务似乎是与微服务一起工作的最关键方面之一。解耦服务配置回到了我们之前关于分离关注点的讨论。在前面的章节中，我们看到了如何使用`application.properties`文件来处理服务配置。尽管这比在生产代码中硬编码这些配置要好，但这仍然不够。
- en: One of the key requirements for any microservice is agility. An ideal microservice
    should be flexible and rapid in addressing any change in the user's requirements,
    as well as handling code defects or network issues. Having said that, each enterprise
    application needs to meet the specific demands of compliance and auditing, which
    implies that a developer often can't just deploy a code artifact from their workspace
    directly to a production environment. If the configurations are decoupled from
    the service code logic then we can easily build the artifact once (without configurations)
    and deploy it to many environments (where each environment can bootstrap its own
    configurations).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 任何微服务的关键要求之一是敏捷性。一个理想的微服务应该能够灵活且快速地应对用户需求的变化，以及处理代码缺陷或网络问题。话虽如此，每个企业应用都需要满足特定的合规性和审计要求，这意味着开发者通常不能直接将工作区中的代码工件部署到生产环境中。如果配置与服务代码逻辑解耦，那么我们可以轻松地构建一次（不包含配置）的工件，并将其部署到多个环境中（每个环境都可以启动自己的配置）。
- en: In the next section, we will dive into how we can manage distributed service
    configurations in the Micronaut framework.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入了解如何在Micronaut框架中管理分布式服务配置。
- en: Using distributed configuration management to externalize the configuration
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用分布式配置管理来外部化配置
- en: Micronaut has out-of-the-box features for `pet-owner` microservice.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Micronaut为`pet-owner`微服务提供了开箱即用的功能。
- en: Implementing a configuration store in Consul
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Consul中实现配置存储
- en: 'We will use a Dockerized Consul instance. Work through the following instructions
    for installing and running Consul in Docker:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Docker化的Consul实例。按照以下说明在Docker中安装和运行Consul：
- en: 'Make sure the Docker application is running in your workspace/environment.
    Then open a bash terminal (I used Git Bash) and run the following command:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Docker应用正在您的 workspace/environment 中运行。然后打开一个bash终端（我使用的是Git Bash）并运行以下命令：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Wait for Docker to download and install **Consul**.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待Docker下载并安装**Consul**。
- en: The preceding command will kick-start a single-node Consul instance and expose
    it on port `8500`. We can verify the installation by accessing the Consul web
    interface at `http://localhost:8500/`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将启动一个单节点Consul实例，并在端口`8500`上公开。我们可以通过访问`http://localhost:8500/`的Consul网页界面来验证安装。
- en: 'Now, to create a configuration store in Consul, follow these instructions:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要创建Consul中的配置存储，请按照以下说明操作：
- en: Open the `http://localhost:8500/` and select **Key/Value** from the top header.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`http://localhost:8500/`并从顶部标题中选择**键/值**。
- en: Click on the **Create** button.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**按钮。
- en: Type `config/pet-owner/application.yml` in the **Key or folder** input box.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**键或文件夹**输入框中输入`config/pet-owner/application.yml`。
- en: 'Add the `pet-owner` `application.properties` in the text area:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本区域中添加`pet-owner`的`application.properties`：
- en: '[PRE1]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By following the preceding steps, we have set up a key-value store in Consul
    for the `pet-owner` microservice.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循前面的步骤，我们已经在Consul中为`pet-owner`微服务设置了一个键值存储。
- en: It's a good practice to keep a backup of these properties in the `pet-owner
    resource` folder as the Dockerized Consul instance may lose the configurations
    upon restarting.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些属性备份到`pet-owner资源`文件夹是一个好习惯，因为Docker化的Consul实例在重启时可能会丢失配置。
- en: 'We can review the configurations by navigating to the `pet-owner application.yml`
    file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过导航到`pet-owner application.yml`文件来查看配置：
- en: '![Figure 7.1 – Managing the pet-owner configurations in Consul'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.1 – Managing the pet-owner configurations in Consul'
- en: '](img/Figure_7.1_B16585_Fixed.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.1 – Pet-owner microservice loading the service configurations from
    Consul at bootup'
- en: Figure 7.1 – Managing the pet-owner configurations in Consul
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 7.1 – Managing the pet-owner configurations in Consul
- en: As shown in *Figure 7.1*, we can easily review/modify application configurations
    in Consul. We have the option to `application.yml` file (in case you want to start
    fresh).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图7.1*所示，我们可以在Consul中轻松地查看/修改应用程序配置。我们有选择将`application.yml`文件（如果您想从头开始）。
- en: Now let's dive into the changes we need to make in the `pet-owner` microservice
    to integrate it with Consul configuration management.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解在`pet-owner`微服务中需要进行的更改，以将其与Consul配置管理集成。
- en: Integrating the pet-owner microservice with Consul configuration management
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将pet-owner微服务与Consul配置管理集成
- en: 'To integrate the `pet-owner` microservice with Consul, we will need to add
    the following dependency to the `pom.xml` project:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`pet-owner`微服务与Consul集成，我们需要将以下依赖项添加到`pom.xml`项目中：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By importing the `micronaut-discover-client` dependency, we can leverage out-of-the-box
    features for service discovery (which we will cover later in the chapter) and
    integration with Consul.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导入`micronaut-discover-client`依赖项，我们可以利用开箱即用的服务发现功能（我们将在本章后面介绍）以及与Consul的集成。
- en: 'We will also need to add a new `bootstrap.yml` file in the `pet-owner` microservice
    resources directory. Bootstrap YAML will inform the service to load (or bootstrap)
    the application properties from an external resource while starting up. To do
    so, add the following configurations to the `bootstrap.yml` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`pet-owner`微服务的资源目录中添加一个新的`bootstrap.yml`文件。Bootstrap YAML将在启动时通知服务从外部资源加载（或引导）应用程序属性。为此，请将以下配置添加到`bootstrap.yml`文件中：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'All the configurations related to the Consul server are prefixed with the keyword
    `consul`. Some configurations to ponder are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与Consul服务器相关的配置都以前缀关键字`consul`开头。以下是一些值得思考的配置：
- en: '`8500`.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`8500`。'
- en: '`application.yml` relative path on the Consul server.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application.yml`在Consul服务器上的相对路径。'
- en: 'These changes in `bootstap.yml` will enable the loading of the configuration
    for the `pet-owner` microservice from the Consul server. We can verify the changes
    made by running the `pet-owner` microservice. When booting up, it should sync
    with Consul to load the configuration:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在`bootstap.yml`中的更改将启用从Consul服务器加载`pet-owner`微服务的配置。我们可以通过运行`pet-owner`微服务来验证所做的更改。当启动时，它应该与Consul同步以加载配置：
- en: '![Figure 7.2 – Pet-owner microservice loading the service configurations from
    Consul at bootup'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.2 – Pet-owner microservice loading the service configurations from
    Consul at bootup'
- en: '](img/Figure_7.2_B16585_Fixed.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.2 – Pet-owner microservice loading the service configurations from
    Consul at bootup'
- en: Figure 7.2 – Pet-owner microservice loading the service configurations from
    Consul at bootup
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 7.2 – Pet-owner microservice loading the service configurations from
    Consul at bootup
- en: When we boot up the pet-owner microservice, `bootstap.yml` will inform the service
    to load the configuration from the Consul server. Built-in components in `micronaut-discover-client`
    dependency will sync with Consul and load this external configuration.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动pet-owner微服务时，`bootstap.yml`将通知服务从Consul服务器加载配置。`micronaut-discover-client`依赖项中的内置组件将与Consul同步并加载此外部配置。
- en: Up to here, you have learned how to employ Micronaut for distributed configuration
    management. In the next section, we will implement API documentation using the
    Micronaut framework.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学会了如何使用Micronaut进行分布式配置管理。在下一节中，我们将使用Micronaut框架实现API文档。
- en: Documenting the service APIs
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录服务API
- en: API documentation is especially important in a microservices architecture for
    intuitive access to the API information, since an application can have multiple
    microservices and each microservice runs several API endpoints. `pet-owner` microservice.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，API文档尤为重要，因为它可以直观地访问API信息，因为一个应用程序可以有多个微服务，每个微服务运行多个API端点。`pet-owner`微服务。
- en: Using Swagger to document the pet-owner service endpoints
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Swagger记录pet-owner服务端点
- en: 'To start using Swagger in the `pet-owner` microservice, we first need to import
    the following dependency into the `pom.xml` project:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`pet-owner`微服务中开始使用Swagger，我们首先需要将以下依赖项导入到`pom.xml`项目中：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'By importing the preceding dependency, we can leverage the `swagger.version`
    in the prompt properties section. We will also need to amend the annotation processing
    so that the annotation processor can generate Swagger artifacts at compile time.
    Add the following path to the `maven-compiler-plugin` annotation processing paths:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导入前面的依赖项，我们可以在提示属性部分利用`swagger.version`。我们还需要修改注解处理，以便注解处理器可以在编译时生成Swagger工件。将以下路径添加到`maven-compiler-plugin`注解处理路径中：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Adding `micronaut-openapi` to the annotation processor paths will enable `maven-compile`
    to build the Swagger artifacts for the project. Once you have made the changes
    to the project prompt, add the following annotation to the main class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将`micronaut-openapi`添加到注解处理路径中，将使`maven-compile`能够为项目构建Swagger工件。一旦你对项目提示进行了更改，请将以下注解添加到主类中：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using the `@OpenAPIDefinition` annotation will create a Swagger artifact with
    the `<title>-<version>.yml` pattern in the generated sources. In our case, it
    will create the `pet-owner-service-1.0.yml` Swagger artifact when we build the
    project:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@OpenAPIDefinition`注解将在生成的源中创建一个具有`<title>-<version>.yml`模式的Swagger工件。在我们的例子中，当我们构建项目时，它将创建`pet-owner-service-1.0.yml`
    Swagger工件：
- en: '![Figure 7.3 – Generated Swagger artifact'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 – 生成的Swagger工件'
- en: '](img/Figure_7.3_B16585_Fixed.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.3_B16585_Fixed.jpg)'
- en: Figure 7.3 – Generated Swagger artifact
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 生成的Swagger工件
- en: 'As shown in *Figure 7.3*, Swagger will create the `pet-owner-service-1.0.yml`
    artifact in the target folder. The generated text-only artifact can be opened
    in the Swagger Editor at [https://editor.swagger.io/](https://editor.swagger.io/):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图7.3*所示，Swagger将在目标文件夹中创建`pet-owner-service-1.0.yml`工件。生成的纯文本工件可以在Swagger编辑器中打开，网址为[https://editor.swagger.io/](https://editor.swagger.io/)：
- en: '![Figure 7.4 – Reviewing the Swagger YAML in the Editor'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4 – 在编辑器中审查Swagger YAML'
- en: '](img/Figure_7.4_B16585_Fixed.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.4_B16585_Fixed.jpg)'
- en: Figure 7.4 – Reviewing the Swagger YAML in the Editor
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 在编辑器中审查Swagger YAML
- en: Using the Swagger Editor to review the generated YAML is very intuitive. It
    provides a simple user interface for all the service endpoints including the option
    to try out an API call. Though Micronaut provides a mechanism to generate Swagger
    UI views, it's very new and requires a lot of changes. Therefore, using the standard
    Swagger Editor is an easier and quicker option.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Swagger编辑器审查生成的YAML非常直观。它提供了一个简单的用户界面，包括尝试API调用的选项。尽管Micronaut提供了一个生成Swagger
    UI视图的机制，但它非常新，需要很多更改。因此，使用标准的Swagger编辑器是一个更简单、更快捷的选择。
- en: API documentation comes in handy when we have different product teams working
    on isolated microservices. Moreover, if a microservice is exposed to the end users,
    it's the go-to resource to know everything about a service endpoint. Continuing
    with this amalgamation journey, in the next section, we will implement service
    discovery for all the microservices in the `pet-clinic` application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有多支产品团队在独立微服务上工作时，API文档就非常有用。此外，如果一个微服务暴露给最终用户，它就是了解服务端点的首选资源。继续我们的合并之旅，在下一节中，我们将为`pet-clinic`应用中的所有微服务实现服务发现。
- en: Implementing service discovery
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现服务发现
- en: In the traditional monolithic architecture, if an application has multiple services
    then often these services are running on fixed and well-known locations (such
    as a URL or ports). This understanding of "well-known" is coupled into the code
    logic to make inter-service calls. A consumer service will call another service
    either at the code level or use hardcoded remote calls over the network.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的单体架构中，如果一个应用程序有多个服务，那么这些服务通常运行在固定且众所周知的位置（例如URL或端口）。这种对“众所周知”的理解被耦合到代码逻辑中，以实现服务间调用。消费者服务将调用另一个服务，要么在代码级别，要么使用硬编码的远程网络调用。
- en: By contrast, often microservices are running in virtualized or containerized
    environments and IP ports are assigned dynamically. To facilitate inter-service
    calls, we implement service discovery. In the service discovery pattern, all the
    microservices will register their running instances with service discovery, and
    clients (that is, upstream clients or even another service) will then sync up
    with service discovery to get the network location of the required service. Furthermore,
    service discovery will maintain a continuous health check on all the registered
    services. In the following section, we will implement service discovery using
    Consul in the Micronaut framework.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，微服务通常在虚拟化或容器化环境中运行，IP端口是动态分配的。为了便于服务间调用，我们实现了服务发现。在服务发现模式中，所有微服务都将将自己的运行实例注册到服务发现中，然后客户端（即上游客户端或另一个服务）将与服务发现同步以获取所需服务的网络位置。此外，服务发现将对所有已注册服务进行持续的健康检查。在下一节中，我们将在Micronaut框架中使用Consul实现服务发现。
- en: Implementing service discovery using Consul
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Consul实现服务发现
- en: 'To enable service discovery, you need to import the following dependency in
    the `pom.xml` project file. We have already added this to the `pet-owner` microservice;
    now add this to the `pet-clinic` and `pet-clinic-reviews` microservices as well:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用服务发现，您需要在`pom.xml`项目文件中导入以下依赖项。我们已将其添加到`pet-owner`微服务中；现在也将其添加到`pet-clinic`和`pet-clinic-reviews`微服务中：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once `micronaut-discovery-client` is imported into the services, we can leverage
    its service discovery capabilities.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将`micronaut-discovery-client`导入到服务中，我们就可以利用其服务发现功能。
- en: 'In order to synchronize the services with Consul, make the following changes
    in the `pet-clinic` and `pet-clinic-reviews` microservices:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与Consul同步服务，请在`pet-clinic`和`pet-clinic-reviews`微服务中进行以下更改：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'By making these changes, we enable the `pet-clinic` and `pet-clinic-reviews`
    microservices to register with Consul service discovery. Micronaut''s `micronaut-discovery-client`
    implementation already has the required tools so we don''t need to make any code
    changes. To verify that all the services are registered with Consul, just run
    the services and they will automatically register with their application name,
    as shown in the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，我们使`pet-clinic`和`pet-clinic-reviews`微服务能够注册到Consul服务发现中。Micronaut的`micronaut-discovery-client`实现已经包含了所需的工具，因此我们不需要进行任何代码更改。为了验证所有服务都已注册到Consul，只需运行服务，它们将自动以它们的应用程序名称注册，如下面的屏幕截图所示：
- en: Note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are using `pet-clinic` and `pet-clinic-reviews` microservices, then start
    up the Docker container for Apache Kafka before the services start up.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用`pet-clinic`和`pet-clinic-reviews`微服务，那么在服务启动之前启动Apache Kafka的Docker容器。
- en: '![Figure 7.5 – Pet-clinic application service discovery'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 – 宠物诊所应用服务发现'
- en: '](img/Figure_7.5_B16585.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 – 宠物诊所应用服务发现](img/Figure_7.5_B16585.jpg)'
- en: Figure 7.5 – Pet-clinic application service discovery
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 宠物诊所应用服务发现
- en: After successful startups, all the microservices will register their instances
    with the Consul service discovery. We can view the running services by going to
    the **Services** screen on Consul.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功启动后，所有微服务都将将自己的实例注册到Consul服务发现中。我们可以在Consul的**服务**屏幕上查看正在运行的服务。
- en: Though service discovery brings all the services under one umbrella by centralizing
    the runtime metadata (mainly the network locations), it still leaves a gap for
    upstream consumers as we don't have a unified interface yet. In the next section,
    we will implement an API gateway for the `pet-clinic` application, which will
    provide a unified interface for all the clients.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然服务发现通过集中运行时元数据（主要是网络位置）将所有服务统一在一起，但它仍然为上游消费者留下了一个缺口，因为我们还没有一个统一的接口。在下一节中，我们将为`pet-clinic`应用程序实现一个API网关，它将为所有客户端提供一个统一的接口。
- en: Implementing the API gateway
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现API网关
- en: To further the earlier discussion on dynamic network locations in the *microservices
    architecture*, we will focus on the API gateway now. The API gateway is an orchestrator
    service meant to provide unified, ubiquitous access to all the services. Though
    we can have multiple microservices running in the backend, an API gateway can
    provide a unified interface for the upstream consumers to access them. For the
    upstream consumers, the API gateway appears to be the only service running in
    the backend. On receiving a client request, the API gateway determines which service
    instance to call using service discovery.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步讨论 *微服务架构* 中的动态网络位置，我们现在将关注 API 网关。API 网关是一个编排服务，旨在为所有服务提供统一、无处不在的访问。尽管我们可以在后端运行多个微服务，但
    API 网关可以为上游消费者提供一个统一的接口来访问它们。对于上游消费者来说，API 网关看起来是后端运行的唯一服务。在收到客户端请求后，API 网关将使用服务发现来确定调用哪个服务实例。
- en: 'In order to learn how to implement the API gateway, we will add an API gateway
    service to the `pet-clinic` application. Since this microservice is an orchestrator
    service, we can call it `pet-clinic-concierge`. The system components after the
    gateway service would be as seen in *Figure 7.6*:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解如何实现 API 网关，我们将向 `pet-clinic` 应用程序添加一个 API 网关服务。由于这个微服务是一个编排服务，我们可以将其称为
    `pet-clinic-concierge`。网关服务之后的系统组件将如 *图 7.6* 所示：
- en: '![Figure 7.6 – Pet Clinic Application with service discovery and an API gateway'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6 – 带有服务发现和 API 网关的宠物诊所应用程序'
- en: '](img/Figure_7.6_B16585_Fixed.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.6_B16585_Fixed.jpg)'
- en: Figure 7.6 – Pet Clinic Application with service discovery and an API gateway
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 带有服务发现和 API 网关的宠物诊所应用程序
- en: In the preceding diagram, we can see the `pet-clinic` application. The `pet-clinic-concierge`
    service will implement the API gateway, and any service consumer will invoke the
    gateway (not the service or service discovery), which will determine the service
    instance by synchronizing up with service discovery. The double-line connectors
    in the diagram show how an actual service request will be executed inside the
    `pet-clinic` application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到 `pet-clinic` 应用程序。`pet-clinic-concierge` 服务将实现 API 网关，任何服务消费者都将调用网关（而不是服务或服务发现），网关将通过与服务发现同步来确定服务实例。图中的双线连接器显示了实际服务请求如何在
    `pet-clinic` 应用程序内部执行。
- en: In the next section, we will dive into how to implement the API gateway in the
    `pet-clinic-concierge` service.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入了解如何在 `pet-clinic-concierge` 服务中实现 API 网关。
- en: Implementing the API gateway service
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现API网关服务
- en: 'In order to learn how we can implement an API gateway in Micronaut, we will
    create a new service project called `pet-clinic-concierge`. To generate the boilerplate,
    follow the instructions:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解我们如何在 Micronaut 中实现 API 网关，我们将创建一个新的服务项目，名为 `pet-clinic-concierge`。要生成样板代码，请按照以下说明操作：
- en: Open **Micronaut Launch** by accessing [https://micronaut.io/launch/](https://micronaut.io/launch/).
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问 [https://micronaut.io/launch/](https://micronaut.io/launch/) 打开 **Micronaut
    Launch**。
- en: Select **Micronaut Application** from the **Application Type** dropdown.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **应用程序类型** 下拉菜单中选择 **Micronaut 应用程序**。
- en: Select **Java 13** from the **Java Version** dropdown.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Java 版本** 下拉菜单中选择 **Java 13**。
- en: Enter `com.packtpub.micronaut` in the **Base Package** input box.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **基础包** 输入框中输入 `com.packtpub.micronaut`。
- en: Enter `pet-clinic-concierge` in the **Name** input box.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **名称** 输入框中输入 `pet-clinic-concierge`。
- en: 'Select the following features from the **Features** multi-selection options:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **功能** 多选选项中选择以下功能：
- en: '**config-consul discovery-consul**'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**config-consul discovery-consul**'
- en: '**http-client**'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**http-client**'
- en: '**netflix-hystrix**'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**netflix-hystrix**'
- en: '**netflix-ribbon**'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**netflix-ribbon**'
- en: '**openapi**'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**openapi**'
- en: Hit **Generate Project** button and select the **Download Zip** option.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **生成项目** 按钮，并选择 **下载 Zip** 选项。
- en: Micronaut Launch will now generate the boilerplate for the `pet-clinic-concierge`
    service. In Micronaut Launch, we opted for discovery and OpenAPI, so the boilerplate
    will have these features already enabled and configured. In the next section,
    we will explore implementing a unified service façade in the `pet-clinic-concierge`
    service.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Micronaut Launch 现在将为 `pet-clinic-concierge` 服务生成样板代码。在 Micronaut Launch 中，我们选择了发现和
    OpenAPI，因此样板代码已经启用了这些功能并进行了配置。在下一节中，我们将探讨在 `pet-clinic-concierge` 服务中实现统一服务外观。
- en: Implementing a unified service façade for the API gateway
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现API网关的统一服务外观
- en: To begin, we will need to copy all the `pet-clinic-concierge` service. These
    DTOs will be used in implementing clients for all the `pet-clinic` services. Copy
    all the DTOs in the `pet-clinic-concierge` project. We can then define the clients
    for all the RESTful services.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要复制所有的`pet-clinic-concierge`服务。这些DTO将在实现所有`pet-clinic`服务的客户端中使用。复制`pet-clinic-concierge`项目中的所有DTO。然后我们可以定义所有RESTful服务的客户端。
- en: In the next section, we will focus on defining the client for the `pet-owner`
    microservice.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将专注于定义`pet-owner`微服务的客户端。
- en: Accessing pet-owner resources
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 访问宠物主资源
- en: 'To access the `pet-owner` resources, we will create clients under the `com.packtpub.micronaut.web.rest.client.petowner`
    package. For each resource controller in the `pet-owner` microservice, we will
    declare an HTTP client interface. The following is the client interface for `OwnerResource`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问`pet-owner`资源，我们将在`com.packtpub.micronaut.web.rest.client.petowner`包下创建客户端。对于`pet-owner`微服务中的每个资源控制器，我们将声明一个HTTP客户端接口。以下是为`OwnerResource`声明的客户端接口：
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `@Client` annotation will implement a concrete client. This client will
    integrate with a Consul service instance for the `pet-owner` service. We would
    need to declare all the RESTful methods exposed in `OwnerResource` with their
    relative paths.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Client`注解将实现一个具体的客户端。这个客户端将集成Consul服务实例的`pet-owner`服务。我们需要声明`OwnerResource`中公开的所有RESTful方法及其相对路径。'
- en: 'Although post-build we will have a concrete `OwnerResourceClient`, we will
    still need to map the various RESTful methods in `OwnerResourceClient` to a local
    controller. This controller will then be exposed as a service façade for the upstream
    consumer. For `OwnerResourceClient` we can create `OwnerResourceClientController`
    as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在构建后我们将有一个具体的`OwnerResourceClient`，我们仍然需要将`OwnerResourceClient`中的各种RESTful方法映射到本地控制器。然后这个控制器将被暴露为上游消费者的服务外观。对于`OwnerResourceClient`，我们可以创建`OwnerResourceClientController`如下：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In `OwnerResourceClientController`, we are injecting `OwnerResourceClient`.
    Any incoming request to `OwnerResourceClientController` will be passed to the
    client, which will then call a `pet-owner` service instance (after syncing with
    Consul service discovery) for further processing. Similarly, you can implement
    `Clients` and `Controllers` for other resources in the `pet-owner` microservice.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OwnerResourceClientController`中，我们正在注入`OwnerResourceClient`。任何发送到`OwnerResourceClientController`的请求都将传递给客户端，然后客户端将调用一个`pet-owner`服务实例（在同步Consul服务发现之后）进行进一步处理。同样，你可以为`pet-owner`微服务中的其他资源实现`Clients`和`Controllers`。
- en: Next, we will implement the service façade for the `pet-clinic` resources as
    well.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现`pet-clinic`资源的服务外观。
- en: Accessing the pet-clinic resources
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 访问宠物诊所资源
- en: 'To access the `pet-clinic` resources we will create clients under the `com.packtpub.micronaut.web.rest.client.petclinic`
    package. For each resource controller in the `pet-clinic` microservice, we will
    declare an HTTP client interface. The following is the client interface for `VetResource`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问`pet-clinic`资源，我们将在`com.packtpub.micronaut.web.rest.client.petclinic`包下创建客户端。对于`pet-clinic`微服务中的每个资源控制器，我们将声明一个HTTP客户端接口。以下是为`VetResource`声明的客户端接口：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `@Client` annotation will implement a concrete client using the `pet-clinic`
    service instance in service discovery. To expose these methods on a service façade,
    we will implement `VetResourceClientController`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Client`注解将使用服务发现中的`pet-clinic`服务实例实现一个具体的客户端。为了在服务外观上公开这些方法，我们将实现`VetResourceClientController`：'
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We are injecting `VetResourceClient` into `VetResourceClientController`, so
    any incoming request to the controller will be passed to the client, which will
    invoke a `pet-clinic` service instance for further processing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将`VetResourceClient`注入到`VetResourceClientController`中，因此任何发送到控制器的请求都将传递给客户端，然后客户端将调用一个`pet-clinic`服务实例进行进一步处理。
- en: In the next section, our focus will be on implementing the service façade for
    `pet-clinic-reviews`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们的重点将是实现`pet-clinic-reviews`的服务外观。
- en: Accessing the pet-clinic-reviews resources
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 访问宠物诊所评论资源
- en: 'For accessing `pet-clinic-reviews` resources, you will create clients under
    the `com.packtpub.micronaut.web.rest.client.petclinicreviews` package. We will
    first declare a client interface for `VetReviewResource`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于访问`pet-clinic-reviews`资源，你将在`com.packtpub.micronaut.web.rest.client.petclinicreviews`包下创建客户端。我们将首先声明一个`VetReviewResource`的客户端接口：
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `@Client` annotation will implement a concrete client using the `pet-clinic-reviews`
    service instance in service discovery. To expose these methods on a service façade
    we will implement `VetReviewResourceClientController`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Client` 注解将实现一个具体的客户端，使用服务发现中的 `pet-clinic-reviews` 服务实例。为了在服务外观上公开这些方法，我们将实现
    `VetReviewResourceClientController`：'
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here we inject `VetReviewResourceClient` into `VetReviewResourceClientController`
    and incoming requests to the controller will be passed to the client, which we
    will invoke on a `pet-clinic-reviews` service instance for further processing.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `VetReviewResourceClient` 注入到 `VetReviewResourceClientController` 中，并将进入控制器的请求传递给客户端，我们将在
    `pet-clinic-reviews` 服务实例上调用该客户端以进行进一步处理。
- en: In the next section, we will focus on handling fault tolerance concerns in regard
    to the microservices.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将重点关注处理与微服务相关的容错问题。
- en: Implementing the fault tolerance mechanisms
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现容错机制
- en: Faults and failures are inevitable in a microservice environment. As the numbers
    of distributed components increase, the number of faults both within each component
    and those originating from their interactions increase as well. Any microservices
    application must have built-in resilience for these unfortunate scenarios. In
    this section, we will explore and implement different ways to handle faults and
    failures in the Micronaut framework.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务环境中，故障和失败是不可避免的。随着分布式组件数量的增加，每个组件内部的故障以及由它们交互产生的故障数量也在增加。任何微服务应用程序都必须为这些不幸的情况内置弹性。在本节中，我们将探讨和实现
    Micronaut 框架中处理故障和失败的不同方法。
- en: Leveraging built-in mechanisms
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用内置机制
- en: Micronaut is a cloud-native framework and has built-in capabilities to handle
    faults and failures. Essentially, its fault tolerance is driven by `@Retryable`
    and `@CircuitBreaker` annotations that can be used in any HTTP client.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Micronaut 是一个云原生框架，并具有内置的错误和故障处理能力。本质上，其容错性是由 `@Retryable` 和 `@CircuitBreaker`
    注解驱动的，这些注解可以在任何 HTTP 客户端中使用。
- en: Using @Retryable in an HTTP client
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 HTTP 客户端使用 @Retryable
- en: '**@Retryable** is an effortless but effective fault tolerance mechanism – to
    put it simply, it''s used to try again in case of a failure. These try attempts
    can be made again after a fixed delay and can continue until the service either
    responds back or no more attempts are left.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**@Retryable** 是一种简单但有效的容错机制——简单来说，它用于在出现故障时再次尝试。这些尝试可以在固定延迟后再次进行，并且可以继续进行，直到服务响应或没有更多尝试为止。'
- en: 'To use `@Retryable` we can just annotate the client declaration. We can use
    `@Retryable` on `OwnerResource` as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `@Retryable`，我们只需在客户端声明上添加注解。我们可以在 `OwnerResource` 上使用 `@Retryable` 如下所示：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'By using `@Retryable` on `OwnerResourceClient` you enable fault-tolerance on
    all its methods. If the `pet-owner` microservice is down then `OwnerResourceClient`
    will retry attempting to establish the communication for a maximum of five attempts.
    We can configure `@Retryable` with the following settings:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `OwnerResourceClient` 上使用 `@Retryable`，您可以在所有方法上启用容错性。如果 `pet-owner` 微服务关闭，则
    `OwnerResourceClient` 将尝试最多五次建立通信。我们可以使用以下设置配置 `@Retryable`：
- en: '**attempts**: This denotes the maximum number of retries the client can make.
    By default, this is 3 attempts.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尝试次数**：这表示客户端可以尝试的最大重试次数。默认为 3 次尝试。'
- en: '**delay**: This marks the delay between the retries and is 1 second by default.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟**：这表示重试之间的延迟，默认为 1 秒。'
- en: '**multiplier**: This specifies the multiplier used to calculate the delay and
    is 1.0 by default.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**乘数**：这指定了用于计算延迟的乘数，默认为 1.0。'
- en: '**maxDelay**: This specifies the maximum overall delay and is empty by default.
    If specified, any retry attempts will be halted if retries reach the maximum delay
    limit.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大延迟**：这指定了最大整体延迟，默认为空。如果指定，任何重试尝试将在达到最大延迟限制时停止。'
- en: '`@Retryable` is well suited for temporary/momentary faults but for long-lasting
    faults, we would need to use the circuit breaker pattern. In the next section,
    we will see how we can use the circuit breaker in the Micronaut framework.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Retryable` 非常适合处理暂时性的故障，但对于持续时间较长的故障，我们需要使用断路器模式。在下一节中，我们将看到如何在 Micronaut
    框架中使用断路器。'
- en: Using @CircuitBreaker in an HTTP client
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 HTTP 客户端使用 @CircuitBreaker
- en: As we discussed, failure in a highly distributed system such as microservices
    is inevitable. In a microservice architecture, if a service goes down there is
    another defensive mechanism to help avoid congesting the service traffic with
    more requests until the service is healthy again. This mechanism is called the
    **circuit breaker**. In normal circumstances, the circuit is open and accepting
    requests. On a failure instance, a counter is increased until it reaches a specified
    threshold. After reaching the threshold, the circuit is put into a closed state
    and the service will respond immediately with an error avoiding any timeouts.
    The circuit breaker has an internal polling mechanism to determine the health
    of the service and if the service is healthy again then the circuit is put back
    to an open state.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simply use Micronaut''s built-in annotation to specify a circuit breaker
    on an HTTP client. Let''s implement a circuit breaker in `PetResourceClient`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding circuit breaker implementation, if the `PetResource` endpoints
    fail then `PetResourceClient` will try five attempts, waiting for 3 seconds for
    the first attempt and a multiplier of two for future attempts. After five attempts,
    if the service is still not responding, then the circuit will be put into a closed
    state. It will try to access it again after a reset interval of 5 minutes to check
    if the service is healthy yet.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Using @Fallback for an HTTP client
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Often in a circuit breaker implementation, there are **feign clients** or **fallbacks**.
    Instead of raising a server error when the circuit is closed, a fallback implementation
    can handle the request and respond normally. This is especially effective when
    the actual service call might be returning that a fallback can also return.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example of the circuit breaker in `PetResourceClient`, we
    can create a simple fallback that will handle the incoming requests when the circuit
    is closed:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`PetResourceFallback` has default implementations of all the `PetResource`
    endpoints and it will provide a gracious response when `PetResource` is unaccessible.
    In this example, we return an empty response from all the endpoints. You can tinker
    with the implementation and create a default response as desired.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to handle various microservice concerns in
    the Micronaut framework. We kickstarted the journey by externalizing the application
    configurations using Consul and learned why distributed configuration management
    is required in the microservices. We then dived into how to automate API documentation
    using OpenAPI and Swagger. Later, we discussed service discovery and the API gateway
    and implemented those in the pet clinic application.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: At last, we explored the need for fault tolerance and how you can simply use
    the built-in mechanism in the Micronaut framework for building resilience in your
    microservices application.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has equipped you with all the first-hand knowledge you require
    to handle various microservice concerns relating to service discovery, API gateways,
    and fault tolerance. The chapter took a practical approach by adding to the pet-clinic
    application while covering these aspects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为你提供了处理与服务发现、API 网关和容错相关的各种微服务问题的所有第一手知识。本章通过在 `pet-clinic` 应用程序中添加这些方面，采用了实用的方法。
- en: In the next chapter, you will explore various ways to deploy the `pet-clinic`
    microservice application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将探索部署 `pet-clinic` 微服务应用程序的各种方法。
- en: Questions
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is distributed configuration management?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分布式配置管理是什么？
- en: How can you implement a configuration store in Consul?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Consul 中实现配置存储？
- en: How can you automate the process of API documentation using Swagger in the Micronaut
    framework?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Micronaut 框架中使用 Swagger 自动化 API 文档的生成过程？
- en: What is service discovery?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务发现是什么？
- en: How can you implement service discovery in the Micronaut framework?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Micronaut 框架中实现服务发现？
- en: What is an API gateway in the microservices architecture?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在微服务架构中，API 网关是什么？
- en: How can you implement an API gateway in the Micronaut framework?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Micronaut 框架中实现 API 网关？
- en: What is `@Retryable` in Micronaut?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Micronaut 中的 `@Retryable` 是什么？
- en: What is `@CircuitBreaker` in Micronaut?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Micronaut 中的 `@CircuitBreaker` 是什么？
- en: How can you implement a circuit breaker in the Micronaut framework?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Micronaut 框架中实现断路器？
- en: How can you implement a fallback in Micronaut?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Micronaut 中实现回退机制？
