- en: '*Chapter 7*: Handling Microservice Concerns'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any microservice architecture implementation is incomplete without handling
    some fundamental microservice concerns such as **configuration management**, **API
    documentation**, **service discovery**, **API gateways**, and **fault tolerance**.
    Hitherto we were focused on the disintegration journey of the microservices, such
    as how to separate the concerns in modular microservices. For seamless and unified
    application access, we need the microservices to integrate and expose a coalesced
    interface. A coalesced interface enables the upstream consumers to interact with
    backend microservices as though they were one.
  prefs: []
  type: TYPE_NORMAL
- en: A key benefit of implementing microservices is fault tolerance. Fault tolerance
    mechanisms such as on-demand scaling, fallbacks, and circuit breakers make microservices
    ubiquitous and robust.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore ways to handle and implement the following
    microservice concerns:'
  prefs: []
  type: TYPE_NORMAL
- en: Externalizing the application configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting the service APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing service discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the API gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the fault-tolerance mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have practical knowledge of handling and
    implementing these key microservice concerns in the Micronaut framework.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the commands and technical instructions in this chapter run on Windows 10
    and macOS. The code examples covered in this chapter are available on the book's
    GitHub repo at [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter07](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following tools need to be installed and set up in the development environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java SDK** version 13 or above (we used Java 14).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maven** – This is optional and only required if you would like to use Maven
    as the build system. However, we recommend having Maven set up on any development
    machine. Instructions to download and install Maven can be found at [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A development IDE** – Based on your preference, any Java-based IDE can be
    used, but for purpose of writing this chapter, IntelliJ was used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Git** – Instructions to download and install this can be found at [https://git-scm.com/downloads](https://git-scm.com/downloads).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PostgreSQL** – Instructions to download and install this can be found at
    [https://www.postgresql.org/download/](https://www.postgresql.org/download/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MongoDB** – MongoDB Atlas provides a free online database-as-a-service with
    up to 512 MB storage. However, if a local database is preferred then instructions
    to download and install this can be found at [https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/).
    We used a local installation for writing this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A REST client** – Any HTTP REST client can be used. We used the Advanced
    REST Client Chrome plugin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker** – Instructions to download and install Docker can be found at [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Externalizing the application configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Irrespective of the size and complexities of a microservice application, the
    task of maintaining the configuration settings for each service seems one of the
    most crucial aspects of working with microservices. Decoupling the service configurations
    goes back to our earlier discussion on separating the concerns. In the earlier
    chapters, we have seen how we can handle service configurations using the `application.properties`
    files. Though this is a step up from not hard-coding these configurations in production
    code, it's still not enough.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key requirements for any microservice is agility. An ideal microservice
    should be flexible and rapid in addressing any change in the user's requirements,
    as well as handling code defects or network issues. Having said that, each enterprise
    application needs to meet the specific demands of compliance and auditing, which
    implies that a developer often can't just deploy a code artifact from their workspace
    directly to a production environment. If the configurations are decoupled from
    the service code logic then we can easily build the artifact once (without configurations)
    and deploy it to many environments (where each environment can bootstrap its own
    configurations).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will dive into how we can manage distributed service
    configurations in the Micronaut framework.
  prefs: []
  type: TYPE_NORMAL
- en: Using distributed configuration management to externalize the configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Micronaut has out-of-the-box features for `pet-owner` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a configuration store in Consul
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will use a Dockerized Consul instance. Work through the following instructions
    for installing and running Consul in Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure the Docker application is running in your workspace/environment.
    Then open a bash terminal (I used Git Bash) and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Wait for Docker to download and install **Consul**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding command will kick-start a single-node Consul instance and expose
    it on port `8500`. We can verify the installation by accessing the Consul web
    interface at `http://localhost:8500/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to create a configuration store in Consul, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `http://localhost:8500/` and select **Key/Value** from the top header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `config/pet-owner/application.yml` in the **Key or folder** input box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `pet-owner` `application.properties` in the text area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By following the preceding steps, we have set up a key-value store in Consul
    for the `pet-owner` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: It's a good practice to keep a backup of these properties in the `pet-owner
    resource` folder as the Dockerized Consul instance may lose the configurations
    upon restarting.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can review the configurations by navigating to the `pet-owner application.yml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Managing the pet-owner configurations in Consul'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.1_B16585_Fixed.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Managing the pet-owner configurations in Consul
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 7.1*, we can easily review/modify application configurations
    in Consul. We have the option to `application.yml` file (in case you want to start
    fresh).
  prefs: []
  type: TYPE_NORMAL
- en: Now let's dive into the changes we need to make in the `pet-owner` microservice
    to integrate it with Consul configuration management.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the pet-owner microservice with Consul configuration management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To integrate the `pet-owner` microservice with Consul, we will need to add
    the following dependency to the `pom.xml` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By importing the `micronaut-discover-client` dependency, we can leverage out-of-the-box
    features for service discovery (which we will cover later in the chapter) and
    integration with Consul.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need to add a new `bootstrap.yml` file in the `pet-owner` microservice
    resources directory. Bootstrap YAML will inform the service to load (or bootstrap)
    the application properties from an external resource while starting up. To do
    so, add the following configurations to the `bootstrap.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'All the configurations related to the Consul server are prefixed with the keyword
    `consul`. Some configurations to ponder are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`8500`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application.yml` relative path on the Consul server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These changes in `bootstap.yml` will enable the loading of the configuration
    for the `pet-owner` microservice from the Consul server. We can verify the changes
    made by running the `pet-owner` microservice. When booting up, it should sync
    with Consul to load the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Pet-owner microservice loading the service configurations from
    Consul at bootup'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.2_B16585_Fixed.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – Pet-owner microservice loading the service configurations from
    Consul at bootup
  prefs: []
  type: TYPE_NORMAL
- en: When we boot up the pet-owner microservice, `bootstap.yml` will inform the service
    to load the configuration from the Consul server. Built-in components in `micronaut-discover-client`
    dependency will sync with Consul and load this external configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Up to here, you have learned how to employ Micronaut for distributed configuration
    management. In the next section, we will implement API documentation using the
    Micronaut framework.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting the service APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: API documentation is especially important in a microservices architecture for
    intuitive access to the API information, since an application can have multiple
    microservices and each microservice runs several API endpoints. `pet-owner` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Using Swagger to document the pet-owner service endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start using Swagger in the `pet-owner` microservice, we first need to import
    the following dependency into the `pom.xml` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'By importing the preceding dependency, we can leverage the `swagger.version`
    in the prompt properties section. We will also need to amend the annotation processing
    so that the annotation processor can generate Swagger artifacts at compile time.
    Add the following path to the `maven-compiler-plugin` annotation processing paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding `micronaut-openapi` to the annotation processor paths will enable `maven-compile`
    to build the Swagger artifacts for the project. Once you have made the changes
    to the project prompt, add the following annotation to the main class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `@OpenAPIDefinition` annotation will create a Swagger artifact with
    the `<title>-<version>.yml` pattern in the generated sources. In our case, it
    will create the `pet-owner-service-1.0.yml` Swagger artifact when we build the
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Generated Swagger artifact'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.3_B16585_Fixed.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – Generated Swagger artifact
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 7.3*, Swagger will create the `pet-owner-service-1.0.yml`
    artifact in the target folder. The generated text-only artifact can be opened
    in the Swagger Editor at [https://editor.swagger.io/](https://editor.swagger.io/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Reviewing the Swagger YAML in the Editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.4_B16585_Fixed.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – Reviewing the Swagger YAML in the Editor
  prefs: []
  type: TYPE_NORMAL
- en: Using the Swagger Editor to review the generated YAML is very intuitive. It
    provides a simple user interface for all the service endpoints including the option
    to try out an API call. Though Micronaut provides a mechanism to generate Swagger
    UI views, it's very new and requires a lot of changes. Therefore, using the standard
    Swagger Editor is an easier and quicker option.
  prefs: []
  type: TYPE_NORMAL
- en: API documentation comes in handy when we have different product teams working
    on isolated microservices. Moreover, if a microservice is exposed to the end users,
    it's the go-to resource to know everything about a service endpoint. Continuing
    with this amalgamation journey, in the next section, we will implement service
    discovery for all the microservices in the `pet-clinic` application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing service discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the traditional monolithic architecture, if an application has multiple services
    then often these services are running on fixed and well-known locations (such
    as a URL or ports). This understanding of "well-known" is coupled into the code
    logic to make inter-service calls. A consumer service will call another service
    either at the code level or use hardcoded remote calls over the network.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, often microservices are running in virtualized or containerized
    environments and IP ports are assigned dynamically. To facilitate inter-service
    calls, we implement service discovery. In the service discovery pattern, all the
    microservices will register their running instances with service discovery, and
    clients (that is, upstream clients or even another service) will then sync up
    with service discovery to get the network location of the required service. Furthermore,
    service discovery will maintain a continuous health check on all the registered
    services. In the following section, we will implement service discovery using
    Consul in the Micronaut framework.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing service discovery using Consul
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable service discovery, you need to import the following dependency in
    the `pom.xml` project file. We have already added this to the `pet-owner` microservice;
    now add this to the `pet-clinic` and `pet-clinic-reviews` microservices as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once `micronaut-discovery-client` is imported into the services, we can leverage
    its service discovery capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to synchronize the services with Consul, make the following changes
    in the `pet-clinic` and `pet-clinic-reviews` microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'By making these changes, we enable the `pet-clinic` and `pet-clinic-reviews`
    microservices to register with Consul service discovery. Micronaut''s `micronaut-discovery-client`
    implementation already has the required tools so we don''t need to make any code
    changes. To verify that all the services are registered with Consul, just run
    the services and they will automatically register with their application name,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are using `pet-clinic` and `pet-clinic-reviews` microservices, then start
    up the Docker container for Apache Kafka before the services start up.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Pet-clinic application service discovery'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.5_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – Pet-clinic application service discovery
  prefs: []
  type: TYPE_NORMAL
- en: After successful startups, all the microservices will register their instances
    with the Consul service discovery. We can view the running services by going to
    the **Services** screen on Consul.
  prefs: []
  type: TYPE_NORMAL
- en: Though service discovery brings all the services under one umbrella by centralizing
    the runtime metadata (mainly the network locations), it still leaves a gap for
    upstream consumers as we don't have a unified interface yet. In the next section,
    we will implement an API gateway for the `pet-clinic` application, which will
    provide a unified interface for all the clients.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the API gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To further the earlier discussion on dynamic network locations in the *microservices
    architecture*, we will focus on the API gateway now. The API gateway is an orchestrator
    service meant to provide unified, ubiquitous access to all the services. Though
    we can have multiple microservices running in the backend, an API gateway can
    provide a unified interface for the upstream consumers to access them. For the
    upstream consumers, the API gateway appears to be the only service running in
    the backend. On receiving a client request, the API gateway determines which service
    instance to call using service discovery.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to learn how to implement the API gateway, we will add an API gateway
    service to the `pet-clinic` application. Since this microservice is an orchestrator
    service, we can call it `pet-clinic-concierge`. The system components after the
    gateway service would be as seen in *Figure 7.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Pet Clinic Application with service discovery and an API gateway'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.6_B16585_Fixed.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – Pet Clinic Application with service discovery and an API gateway
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we can see the `pet-clinic` application. The `pet-clinic-concierge`
    service will implement the API gateway, and any service consumer will invoke the
    gateway (not the service or service discovery), which will determine the service
    instance by synchronizing up with service discovery. The double-line connectors
    in the diagram show how an actual service request will be executed inside the
    `pet-clinic` application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will dive into how to implement the API gateway in the
    `pet-clinic-concierge` service.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the API gateway service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to learn how we can implement an API gateway in Micronaut, we will
    create a new service project called `pet-clinic-concierge`. To generate the boilerplate,
    follow the instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Micronaut Launch** by accessing [https://micronaut.io/launch/](https://micronaut.io/launch/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Micronaut Application** from the **Application Type** dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Java 13** from the **Java Version** dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `com.packtpub.micronaut` in the **Base Package** input box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `pet-clinic-concierge` in the **Name** input box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the following features from the **Features** multi-selection options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**config-consul discovery-consul**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**http-client**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**netflix-hystrix**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**netflix-ribbon**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**openapi**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Hit **Generate Project** button and select the **Download Zip** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Micronaut Launch will now generate the boilerplate for the `pet-clinic-concierge`
    service. In Micronaut Launch, we opted for discovery and OpenAPI, so the boilerplate
    will have these features already enabled and configured. In the next section,
    we will explore implementing a unified service façade in the `pet-clinic-concierge`
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a unified service façade for the API gateway
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To begin, we will need to copy all the `pet-clinic-concierge` service. These
    DTOs will be used in implementing clients for all the `pet-clinic` services. Copy
    all the DTOs in the `pet-clinic-concierge` project. We can then define the clients
    for all the RESTful services.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will focus on defining the client for the `pet-owner`
    microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing pet-owner resources
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To access the `pet-owner` resources, we will create clients under the `com.packtpub.micronaut.web.rest.client.petowner`
    package. For each resource controller in the `pet-owner` microservice, we will
    declare an HTTP client interface. The following is the client interface for `OwnerResource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `@Client` annotation will implement a concrete client. This client will
    integrate with a Consul service instance for the `pet-owner` service. We would
    need to declare all the RESTful methods exposed in `OwnerResource` with their
    relative paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although post-build we will have a concrete `OwnerResourceClient`, we will
    still need to map the various RESTful methods in `OwnerResourceClient` to a local
    controller. This controller will then be exposed as a service façade for the upstream
    consumer. For `OwnerResourceClient` we can create `OwnerResourceClientController`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In `OwnerResourceClientController`, we are injecting `OwnerResourceClient`.
    Any incoming request to `OwnerResourceClientController` will be passed to the
    client, which will then call a `pet-owner` service instance (after syncing with
    Consul service discovery) for further processing. Similarly, you can implement
    `Clients` and `Controllers` for other resources in the `pet-owner` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will implement the service façade for the `pet-clinic` resources as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the pet-clinic resources
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To access the `pet-clinic` resources we will create clients under the `com.packtpub.micronaut.web.rest.client.petclinic`
    package. For each resource controller in the `pet-clinic` microservice, we will
    declare an HTTP client interface. The following is the client interface for `VetResource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@Client` annotation will implement a concrete client using the `pet-clinic`
    service instance in service discovery. To expose these methods on a service façade,
    we will implement `VetResourceClientController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We are injecting `VetResourceClient` into `VetResourceClientController`, so
    any incoming request to the controller will be passed to the client, which will
    invoke a `pet-clinic` service instance for further processing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, our focus will be on implementing the service façade for
    `pet-clinic-reviews`.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the pet-clinic-reviews resources
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For accessing `pet-clinic-reviews` resources, you will create clients under
    the `com.packtpub.micronaut.web.rest.client.petclinicreviews` package. We will
    first declare a client interface for `VetReviewResource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@Client` annotation will implement a concrete client using the `pet-clinic-reviews`
    service instance in service discovery. To expose these methods on a service façade
    we will implement `VetReviewResourceClientController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here we inject `VetReviewResourceClient` into `VetReviewResourceClientController`
    and incoming requests to the controller will be passed to the client, which we
    will invoke on a `pet-clinic-reviews` service instance for further processing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will focus on handling fault tolerance concerns in regard
    to the microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the fault tolerance mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Faults and failures are inevitable in a microservice environment. As the numbers
    of distributed components increase, the number of faults both within each component
    and those originating from their interactions increase as well. Any microservices
    application must have built-in resilience for these unfortunate scenarios. In
    this section, we will explore and implement different ways to handle faults and
    failures in the Micronaut framework.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging built-in mechanisms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Micronaut is a cloud-native framework and has built-in capabilities to handle
    faults and failures. Essentially, its fault tolerance is driven by `@Retryable`
    and `@CircuitBreaker` annotations that can be used in any HTTP client.
  prefs: []
  type: TYPE_NORMAL
- en: Using @Retryable in an HTTP client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**@Retryable** is an effortless but effective fault tolerance mechanism – to
    put it simply, it''s used to try again in case of a failure. These try attempts
    can be made again after a fixed delay and can continue until the service either
    responds back or no more attempts are left.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `@Retryable` we can just annotate the client declaration. We can use
    `@Retryable` on `OwnerResource` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'By using `@Retryable` on `OwnerResourceClient` you enable fault-tolerance on
    all its methods. If the `pet-owner` microservice is down then `OwnerResourceClient`
    will retry attempting to establish the communication for a maximum of five attempts.
    We can configure `@Retryable` with the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**attempts**: This denotes the maximum number of retries the client can make.
    By default, this is 3 attempts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**delay**: This marks the delay between the retries and is 1 second by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**multiplier**: This specifies the multiplier used to calculate the delay and
    is 1.0 by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**maxDelay**: This specifies the maximum overall delay and is empty by default.
    If specified, any retry attempts will be halted if retries reach the maximum delay
    limit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Retryable` is well suited for temporary/momentary faults but for long-lasting
    faults, we would need to use the circuit breaker pattern. In the next section,
    we will see how we can use the circuit breaker in the Micronaut framework.'
  prefs: []
  type: TYPE_NORMAL
- en: Using @CircuitBreaker in an HTTP client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we discussed, failure in a highly distributed system such as microservices
    is inevitable. In a microservice architecture, if a service goes down there is
    another defensive mechanism to help avoid congesting the service traffic with
    more requests until the service is healthy again. This mechanism is called the
    **circuit breaker**. In normal circumstances, the circuit is open and accepting
    requests. On a failure instance, a counter is increased until it reaches a specified
    threshold. After reaching the threshold, the circuit is put into a closed state
    and the service will respond immediately with an error avoiding any timeouts.
    The circuit breaker has an internal polling mechanism to determine the health
    of the service and if the service is healthy again then the circuit is put back
    to an open state.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simply use Micronaut''s built-in annotation to specify a circuit breaker
    on an HTTP client. Let''s implement a circuit breaker in `PetResourceClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding circuit breaker implementation, if the `PetResource` endpoints
    fail then `PetResourceClient` will try five attempts, waiting for 3 seconds for
    the first attempt and a multiplier of two for future attempts. After five attempts,
    if the service is still not responding, then the circuit will be put into a closed
    state. It will try to access it again after a reset interval of 5 minutes to check
    if the service is healthy yet.
  prefs: []
  type: TYPE_NORMAL
- en: Using @Fallback for an HTTP client
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Often in a circuit breaker implementation, there are **feign clients** or **fallbacks**.
    Instead of raising a server error when the circuit is closed, a fallback implementation
    can handle the request and respond normally. This is especially effective when
    the actual service call might be returning that a fallback can also return.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example of the circuit breaker in `PetResourceClient`, we
    can create a simple fallback that will handle the incoming requests when the circuit
    is closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`PetResourceFallback` has default implementations of all the `PetResource`
    endpoints and it will provide a gracious response when `PetResource` is unaccessible.
    In this example, we return an empty response from all the endpoints. You can tinker
    with the implementation and create a default response as desired.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to handle various microservice concerns in
    the Micronaut framework. We kickstarted the journey by externalizing the application
    configurations using Consul and learned why distributed configuration management
    is required in the microservices. We then dived into how to automate API documentation
    using OpenAPI and Swagger. Later, we discussed service discovery and the API gateway
    and implemented those in the pet clinic application.
  prefs: []
  type: TYPE_NORMAL
- en: At last, we explored the need for fault tolerance and how you can simply use
    the built-in mechanism in the Micronaut framework for building resilience in your
    microservices application.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has equipped you with all the first-hand knowledge you require
    to handle various microservice concerns relating to service discovery, API gateways,
    and fault tolerance. The chapter took a practical approach by adding to the pet-clinic
    application while covering these aspects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will explore various ways to deploy the `pet-clinic`
    microservice application.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is distributed configuration management?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you implement a configuration store in Consul?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you automate the process of API documentation using Swagger in the Micronaut
    framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is service discovery?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you implement service discovery in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an API gateway in the microservices architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you implement an API gateway in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `@Retryable` in Micronaut?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `@CircuitBreaker` in Micronaut?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you implement a circuit breaker in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you implement a fallback in Micronaut?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
