- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Testing Strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will further guide our entry into the world of complex testing
    methods and will offer clear guides to ensure that our software is reliable and
    robust. It will cover a range of topics: from a consideration of the basics of
    **test-driven development** (**TDD**) to specifics such as unit testing web controllers
    with security considerations, integration of different parts of an application,
    and the unique challenges of testing in reactive environments. This should make
    you a better developer who can write tests that cover all code. These techniques
    provide a strong foundation for ensuring improvements in quality and that these
    improvements are applicable to diverse software architectures – from classical
    web applications to reactive systems of modern software architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, by learning these testing strategies, you work not only to catch
    bugs or prevent errors but to prepare for the modern demands of software development.
    This chapter outlines everything you need to create high-performing, scalable,
    and maintainable applications. As we go on through the chapter, you will understand
    when and how to apply those testing techniques confidently, regardless of the
    complexity of your application or its architecture. This chapter will prepare
    you with the information and tools necessary to go successfully through the constantly
    changing world of software management.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: TDD in Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing of controllers with a security layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing – bridging components together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing reactive components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin this journey of learning how to make your Spring Boot applications
    secure and robust!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, we are going to need some settings in our local machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java 17 Development Kit** (**JDK 17**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A modern **integrated development environment** (**IDE**) – I recommend IntelliJ
    IDEA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub repository**: You can clone all repositories related to [*Chapter
    6*](B18400_06.xhtml#_idTextAnchor192) from here: [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Desktop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD in Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I was first introduced to the concept of TDD, I admit I was quite skeptical.
    I felt the concept of writing unit tests before the code itself just seemed ridiculous,
    or, in other words, crazy. I was not different from others who felt it was just
    an added process to slow down an already jam-packed development life cycle. But
    now, having explored the use of TDD during application development with Spring
    Boot 3.0, I know that this is not the case.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot 3.0 was a very fantastic platform to go for TDD-based work. I’d
    just taken on a new project and started moving forward based on the concept of
    TDD. The process itself was awkward, to say the least. It’s like pre-judging the
    future through writing a code test for code that doesn’t even exist. However,
    I continued with it. The unit tests literally drove the writing of the code in
    a way that I’ve never seen before. Having a clear and defined purpose in every
    single test and the development of code that would meet it made each relevant
    approach to the development focused and considered.
  prefs: []
  type: TYPE_NORMAL
- en: Its purpose was to catch early bugs and make the code base organized and maintainable.
    Writing tests in this manner becomes a cycle through **Red** (writing a failing
    test), **Green** (making the test pass), and **Refactor** (cleaning up the code).
    It bounces you along the project. The time spent upfront in writing tests gets
    paid off by a reduction in debugging and revising faulty code later.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s proceed practically to apply the theory in our Bookstore application.
    In this section, we will practice TDD, building a feature in our application.
    You will learn how to first write and then pass the tests according to the feature.
    All of this practical experience is intended to provide you with a solid foundation,
    rather than just theoretical knowledge, in application development with Spring
    Boot 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: This, of course, is meant to make you feel comfortable and confident when using
    TDD in your projects. Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing TDD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will start a new TDD journey. As a part of this task, we
    have a new requirement for our Bookstore application: introducing an additional
    service layer between the controller and the repository for `Author` flows. The
    controller has two GET methods and one PUT, one POST, and one DELETE method. The
    requirements are to create a class called `AuthorService.java`, provide the methods
    the controller class needs, and throw an `EntityNotFound` exception when `Author`
    is not found in the database in the `DELETE` process. Let’s achieve this task
    by using the TDD approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AuthorServiceTest.java` under the `src/test/java` folder. First, we will write
    our first test for the potential `getAuthor` method. However, when we start writing
    the test method, we will see we don’t have a service class yet, and we will create
    an empty service class called `AuthorService.java`. But when we try to autocomplete
    the `getAuthor` method, we will see there is no method named like this. So, we
    will create a new method in the service class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, this method almost is empty. However, we know we will have
    a method called `getAuthor`, accept `Id` as a parameter, and return `Optional<Author>`.
    In all tests, we need to prepare the environment for this test such as creating
    the required data. So, we will inject the `authorRepository` class in both service
    and test classes. Now, we can write the first test case:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`when`: This helps us to manipulate the returned object of the mocked methods.
    In our sample, it mocks when `authorRepository.findById()` is called, and it will
    always return `savedAuthor`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`assertTrue`: This asserts the method returns true.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`assertEquals`: This asserts that the provided two values are equal.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we run the `givenExistingAuthorId_whenGetAuthor_thenReturnAuthor` method,
    the test will fail because our method is always returning `Optional.empty()`.
    So, we have a failing test on our hands; let’s go and fix it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Green (making the test pass)**: In order to pass this test, we need to use
    the repository class in our method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, it is done. When we run the tests again, we will see it will pass.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Refactor (cleaning up the code)**: In this step, we need to check both the
    test and source classes and see whether they need refactoring. In our case, in
    the source class, we don’t need any refactoring, but on the test side, we may
    tidy up a little bit. We can remove the object creation from the test class and
    make the test case more readable. Also, we can reuse that object in other test
    classes in the future:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have introduced a `setup` method for setting the common variables to reduce
    code duplications in the test class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After introducing the `setup` method, our test method became clearer with fewer
    lines of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have completed one iteration of TDD for the Author service. We need to do
    the same iterations for all methods until we have a mature `AuthorService` that
    can be used in the controller class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At the end of these processes, we will have `AuthorServiceTest` as in the GitHub
    repository. However, we will also have some new terminology for unit tests, which
    we will discuss in the *Discussing terminology for unit* *tests* section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We have left one final step: updating the `AuthorController` class to consume
    this new (`AuthorService`) service instead of the repository.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will need to inject the `AuthorService` class into the controller class and
    use the methods in `AuthorService` instead of the repository methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can see the updated `AuthorController` in the GitHub repository ([https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/main/java/com/packt/ahmeric/bookstore/controller/AuthorController.java](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/main/java/com/packt/ahmeric/bookstore/controller/AuthorController.java)).
    I would like to mention the `delete` method here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we have replaced the methods and, in the `delete` function,
    we have added an exception handler to cover `EntityNotFoundException`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this section, we have learned about the TDD and how to implement it in a
    real-world sample. This will take some time, and it requires some patience to
    make it a habit in the development cycle. However, once you have learned how to
    go with TDD, you will have fewer bugs and more maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: Discussing terminology for unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s discuss some essential terminology in unit testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assertThrows()`: This is a method used in JUnit tests to assert that a specific
    type of exception is thrown during the execution of a piece of code. It is particularly
    useful when you want to test that your code properly handles error conditions.
    In our test class, you can see it as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method takes two main parameters: the expected exception type and a functional
    interface (usually a lambda expression), which contains the code expected to throw
    the exception. If the specified exception is thrown, the test passes; otherwise,
    it fails.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`verify()`: Mockito is a library that we always use in unit testing. It has
    very useful methods that make our tests more reliable and readable. `verify()`
    is one of them; it is used to check that certain interactions with mock objects
    occur. It can verify that methods were called with specific parameters, a certain
    number of times, or even that they were never called. This is crucial for testing
    that your code interacts with dependencies as expected. In our test class, you
    can see it as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`@InjectMocks`: The `@InjectMocks` annotation in Mockito is used to create
    instances of a class and inject mock fields into it. This is particularly useful
    when you have a class that depends on other components or services, and you want
    to test the class in isolation by using mock versions of its dependencies. The
    following code snippet shows a sample usage:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`@ExtendWith(MockitoExtension.class)`: This annotation is used with JUnit 5
    to enable Mockito support in tests. By declaring `@ExtendWith(MockitoExtension.class)`
    at the class level, you allow Mockito to initialize mocks and inject them before
    tests are run. This makes it easier to write cleaner test code with less boilerplate.
    You can see it here in our test class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`@BeforeEach`: In JUnit 5, the `@BeforeEach` annotation is used on a method
    to specify that it should be executed before each test method in the current test
    class. It’s commonly used for setup tasks that are common to all tests, ensuring
    each test starts with a fresh state. It is used with a method, as you can see
    in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we are now aware of the new terminology in the unit test, in the next section,
    we will use our unit test knowledge and improve it by learning how to test controller
    classes, especially the ones with a security layer.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing of controllers with a security layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this new section, we will deal with testing controller classes. Why do we
    have a different test approach for controller classes? The request and response
    can be represented as JSON objects, similar to a real Request and Response, not
    like the objects in our project. This will help us check that everything is OK
    to accept requests and also assert the JSON response if they match the requirements.
    We will discuss some new annotations and next, we will focus on how to implement
    these new annotations for `AuthorControllerTest` step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Key annotations for Spring MVC controller testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring `@WebMvcTest`, `@Import`, `@WithMockUser`, and `@MockBean`, which are
    essential players in Spring MVC controller testing. These annotations help establish
    a testing framework that ensures our controllers perform as expected whether in
    isolation or when integrated with Spring’s web context and security components.
    Let’s take a look at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@WebMvcTest(AuthorController.class)`: The `@WebMvcTest` annotation is used
    for unit testing Spring MVC applications in a more focused way. It is applied
    to test classes that need to test Spring MVC controllers. Using `@WebMvcTest`
    with a specific controller class, such as `AuthorController.class`, tells Spring
    Boot to only instantiate the given controller and its required dependencies, not
    the whole context. This makes the tests run faster and focus strictly on the MVC
    components. This annotation automatically configures the Spring MVC infrastructure
    for your tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Import(SecurityConfig.class)`: The `@Import` annotation allows you to import
    additional configuration classes into the Spring test context. When used in controller
    tests, particularly alongside `@WebMvcTest`, it’s often necessary to include specific
    configuration classes that aren’t automatically picked up by `@WebMvcTest`. By
    specifying `@Import(SecurityConfig.class)`, you’re explicitly telling Spring to
    load your `SecurityConfig` class. This class contains security configurations
    (such as authentication and authorization settings) that are necessary for your
    tests to run in an environment that closely mimics your application’s security
    setup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@MockBean`: Spring application context uses beans such as Service and Repository,
    and in our test context, we need to mock these beans. `@MockBean` adds mock objects
    to the Spring application context, and these mocked objects are used instead of
    real Service and Repository objects. This is useful for injecting mock implementations
    for services, repositories, or any other components that your controller depends
    on, without actually loading those beans from the real application context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@WithMockUser`: This annotation is used in Spring Security tests to simulate
    running a test with a mock authenticated user. This annotation allows you to specify
    details of the mock user, such as username, roles, and authorities, without the
    need to interact with the actual security environment or authentication mechanism.
    It’s particularly useful for controller tests where you want to test the behavior
    of your endpoints under different authentication or authorization scenarios. By
    using `@WithMockUser`, you can easily emulate different user contexts, testing
    how your application responds to various levels of access and ensuring that security
    constraints are correctly enforced. This makes it an essential tool for comprehensive
    testing of secured endpoints in a Spring Boot application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For controller tests, especially with a security layer, these annotations play
    crucial roles in ensuring that your tests are focused and fast and reflect your
    application’s actual running conditions as closely as possible. In the next section,
    we will get our hands dirty while implementing these into our test class.
  prefs: []
  type: TYPE_NORMAL
- en: Crafting controller tests with Spring annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we start working on creating tests, for controllers, it’s important to
    make use of Springs annotations. These annotations, such as `@WebMvcTest`, `@Import`,
    `@WithMockUser`, and `@MockBean`, are crucial for establishing the testing environment
    that mirrors our application’s web layer and security setups. This section focuses
    on utilizing these annotations to develop targeted tests for our controllers.
    By incorporating these tools, our goal is to strike a balance between speed and
    accuracy in testing to ensure that our controllers operate effectively within
    the web environment. Let’s explore how we can practically apply these annotations
    to mimic real-world scenarios and verify the functionality of our Spring MVC controllers
    in certain situations.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a comprehensive test suite for `AuthorController` in a Spring Boot
    application involves several steps, from setting up the initial testing environment
    with specific annotations to writing detailed test cases for different user roles
    and operations. Here is a step-by-step guide to achieve the final state of `AuthorControllerTest.java`
    as described.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – setting up your test environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To set up your environment, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a test class file named `AuthorControllerTest.java`. Annotate the class
    with `@WebMvcTest(AuthorController.class)` to focus on testing only `AuthorController`.
    This tells Spring Boot to configure only the MVC components necessary for the
    test, without the full application context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `@Import(SecurityConfig.class)` to include your custom security configuration
    in the test context. This is crucial for accurately simulating security behaviors
    during testing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the required fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ApplicationContext` to set up the `MockMvc` object'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A `MockMvc` object for performing and asserting HTTP requests
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Mock beans for any services or components the controller depends on, such as
    `AuthorService` and `JwtDecoder`, using the `@``MockBean` annotation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An `ObjectMapper` for JSON serialization and deserialization in tests
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the code changes of this step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have set up our test class by mocking `AuthorService` and `JwtDecoder`.
    We will be able to manipulate them when needed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – initializing the testing framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Implement a setup method annotated with `@BeforeEach` to initialize the `MockMvc`
    object before each test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This method uses the `MockMvcBuilders` utility to build the `MockMvc` object
    with the web application context and Spring Security integration.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – writing test cases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After setting up our test class, we can start to write our test cases step
    by step:'
  prefs: []
  type: TYPE_NORMAL
- en: Write parameterized test cases for adding and getting authors with different
    roles. Use `@ParameterizedTest` and `@MethodSource` to supply the roles and expected
    HTTP statuses. In these tests, you’ll simulate requests with different user roles
    and assert the expected outcomes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For adding authors, mock the `AuthorService` response and perform a POST request,
    asserting the status based on the role.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For getting an author by ID, mock the `AuthorService` response and perform a
    GET request, asserting both the status and the content based on the role.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Write tests for fetching all authors, updating an author, and deleting an author.
    Utilize `@Test` and `@WithMockUser` to specify the user details inline. These
    tests will do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mock service layer responses
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform the relevant HTTP request (GET for all authors, PUT for updating, DELETE
    for deleting)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Assert the expected outcomes, including status codes and, when applicable, response
    body content
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see how these steps are implemented in the controller test class. You
    can see five test methods in the GitHub repository, which validates the test cases,
    as we mentioned in this section, at [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/com/packt/ahmeric/bookstore/controller/AuthorControllerTest.java](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/com/packt/ahmeric/bookstore/controller/AuthorControllerTest.java).
    We will discuss how we can test exception handling in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – handling exceptional cases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Write a test case for handling a scenario where an author to be deleted is
    not found. Mock the service to throw `EntityNotFoundException` when attempting
    to delete a non-existent author, and assert that the controller correctly responds
    with a `404` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this test method, we are manipulating our `authorService.deleteAuthor` method
    to throw an exception by using the `doThrow()` method, and we are expecting a
    `not found` status as a response.
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 – running the tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Run your tests to verify that all pass and that your controller behaves as expected
    across various scenarios and user roles.
  prefs: []
  type: TYPE_NORMAL
- en: This comprehensive testing approach not only validates the functional aspects
    of `AuthorController` but also ensures that security constraints are respected,
    providing confidence in both the application’s behavior and its security posture.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to write controller tests by using Spring MVC
    controllers with security configurations. We have written the tests for both assertions,
    functionality, and security. By these tests, we are sure our controllers and the
    security filters are working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: After completing our journey in the unit test, we will focus on the integration
    test in the next section. We will explore how to test the integration/interaction
    between various components of our project, including databases, web services,
    and external APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing – bridging components together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you understand the concepts of unit testing, especially when dealing with
    tricky security layers, you can expand your vision to integration testing. While
    writing unit tests, you can think of quality checks on bricks that are carried
    out to ensure that a wall built with those bricks will keep you and your family
    safe from rain, snow, and everything else. Integration testing assesses how well
    different pieces of our application work. This is where the complete application
    tests are run at full length: the module interaction, databases, web services,
    and interaction with all the other external systems required are cross-examined
    to affirm that it is all smooth.'
  prefs: []
  type: TYPE_NORMAL
- en: Why integration tests? Are unit tests not enough to prove our application is
    robust? The quick answer is no. In unit tests, we are just proving the methods
    are working as expected, but in real life, the methods are not working on their
    own. They interact with other components. So, integration tests are crucial to
    see whether any component has been affected by your change.
  prefs: []
  type: TYPE_NORMAL
- en: So, fasten your seatbelts, because we are now going to take a ride. Just to
    be sure, a big integrated system will stand by all the requirements and possible
    scenarios – this, in fact, leaves your application far better prepared for the
    real world and the ultimate test of meeting user needs against expectations. We
    guide you with clear, practical examples to finally give you concise integration
    tests, ensuring peace of mind that your high-quality software product can finally
    be delivered.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the testing environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main purpose of integration testing is to identify and solve problems attached
    to the interaction amid different parts of the application. This may comprise
    designed interactions between several service layers, databases, or external APIs,
    all together aimed at having them purposefully work together in the same way functions
    are supposed to take place. Unlike unit testing, integration testing ensures that
    isolated functionality is correct since it studies how the system behaves. Overall,
    the application itself should be tested from the interface level part, to ensure
    that the quality and functionality are full, avoiding interface lack in the defects,
    performance bottlenecks, and other integration issues left from unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our integration testing strategy for the Author Controller endpoints, we
    utilize these two primary classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AbstractIntegrationTest`: This class serves as the foundation for our integration
    tests, providing common configuration and setup routines that are shared across
    multiple test classes. It is an abstract class that does not directly run tests;
    instead, it sets up the testing environment. This includes configuring test containers
    for databases, initializing WireMock for mocking external services, and setting
    up Spring’s application context with the necessary profiles and configurations
    for integration testing. WireMock is a library that we use for mocking services
    such as REST and **Simple Object Access Protocol** (**SOAP**) services. By this
    mocking power, we can isolate our component from external connections and the
    potential faults of these services. We can use this abstract class for all integration
    tests since they will also need the same setup. The usage of an abstract base
    class helps us maintain a clean and **Don’t Repeat Yourself** (**DRY**) testing
    code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AuthorControllerIntegrationTest`: Extending from `AbstractIntegrationTest`,
    this class focuses specifically on testing the Author Controller endpoints. It
    inherits the common testing environment setup from `AbstractIntegrationTest` and
    adds tests that cover the functionality of the Author Controller, such as creating,
    reading, updating, and deleting authors. The `AuthorControllerIntegrationTest`
    class utilizes Spring’s MockMvc to simulate HTTP requests and assert the responses,
    ensuring that the Author Controller behaves as expected when integrated with other
    application components such as the security layer and the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By structuring our integration tests this way, we achieve a layered testing
    approach that allows us to isolate the testing of specific components (such as
    the Author Controller) while still leveraging a common setup for aspects shared
    across tests. This organization makes our tests more efficient and easier to maintain
    and ensures that we comprehensively test the interactions and integrations crucial
    for the application’s overall performance and reliability.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring application properties for integration testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In integration tests, our application will need to run as it would in a real
    environment. So, it is crucial to set up the application properties file. However,
    we also need to isolate the integration test environment from other test environments.
    That’s why we are initiating a new `application-integration-test.properties`.
    By this segregation, we ensure that the configuration in the integration test
    environment is just for that environment and it won’t affect the other test and
    development environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are adding the same properties as we are using in the current source code.
    This is because the following parameters will be needed by our application when
    it is running in the integration test profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: By configuring these properties, we create a controlled, predictable, and isolated
    environment that allows us to test our application’s integration points thoroughly
    and accurately. This setup is crucial for evaluating the application’s behavior
    in a simulated production environment, ensuring that all components work harmoniously
    together.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll dive into the practical application of these configurations, where
    we set the stage for robust, environment-true testing.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the database with Testcontainers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Testcontainers` is a Java library designed for JUnit and systems testing.
    It usually provides a lightweight, throw-away instance manner on the run of shared
    databases and Selenium web browsers or anything that can run inside a Docker container.
    Under the hood, `Testcontainers` uses Docker to help with the full setup and,
    especially, tear-down of actual database instances, which are isolated, ephemeral,
    and fully in one’s control. With the help of tools such as `Testcontainers`, one
    can accurately test the database interaction and persistence necessary for business
    needs without much overhead, the complexity of database installations, or setups
    of some sort of shared test instances.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now configure PostgreSQL and MongoDB containers by initializing `Testcontainers`
    for PostgreSQL and MongoDB databases in the `AbstractIntegrationTest` class. Here’s
    how it’s done:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Testcontainers` library. This method specifies the Docker image to use (`postgres:latest`),
    as well as database-specific configurations such as the database name, username,
    and password. Once initialized, the container is started, and the **Java Database
    Connectivity** (**JDBC**) URL, username, and password are dynamically injected
    into the Spring application context. This allows the integration tests to interact
    with a real PostgreSQL database instance that’s identical to what would be used
    in production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Testcontainers` library by specifying the Docker image (`mongo:4.4.6`). Upon
    starting the MongoDB container, the connection URI is injected into the Spring
    application context, enabling tests to communicate with a real MongoDB instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To initialize the database, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, we will define the required parameters such as database image versions
    and the database name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use these parameters when we are initiating our test database containers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code block, first, we define the container and call the container initialize
    function in it. The container initialize function consumes the parameters defined
    in the previous code block in *Step 1*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will need some dynamic properties, which will be defined after containers
    are triggered. By using the following code, we can let the application know which
    data source URL will be used for connecting to the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each container is automatically run up, prepared, and torn down before and after
    tests, ensuring that every test suite runs against a clean, isolated database
    environment. This automated process elevates the reliability and repeatability
    of integration tests and simplifies the setup and troubleshooting of database
    interactions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the databases ready and set up in containerized sandboxes, the next section
    is going to show us how to do just that: simulate responses from our dependencies
    on external APIs so that we can burrow deep into our code base to offer a full,
    no-holds-barred testing strategy.'
  prefs: []
  type: TYPE_NORMAL
- en: Mocking external services with WireMock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the context of integration testing, the ability to simulate external services
    is important because you cannot run all external devices in your integration test
    environment. Even if you can run them, the purpose of integration tests is to
    test the codes in the component. The external system’s problems are unrelated
    to the quality of the application’s code. WireMock offers a powerful solution
    for this challenge. By creating programmable HTTP servers that mimic the behavior
    of these external services, WireMock allows developers to produce reliable, consistent,
    and fast tests. Mocking external services ensures that tests are not only isolated
    from factors outside the application’s control but also that they can be run in
    any environment without the need for actual service connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'To effectively simulate the interaction with an OpenID Connect provider, WireMock
    can be configured to respond to authentication and token requests with predefined
    responses. We need this setup to test secured endpoints without needing to interact
    with the real authentication service. Here’s how to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AbstractIntegrationTest` class, set up a WireMock server to run on a specific
    port. This server acts as your mock OpenID Connect provider.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Stubbing the OpenID configuration**: Configure WireMock to serve responses
    for the OpenID Connect discovery document and other related endpoints. We need
    to stub the endpoint to return the provider metadata, which includes URLs for
    the authorization, token, user information, and **JSON Web Key Set** (**JWKS**)
    URIs. This ensures that when your application tries to discover the OpenID Connect
    provider’s configuration, it receives a consistent and controlled response from
    WireMock.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Mocking token and authorization responses**: Further configure WireMock to
    respond to token and authorization requests with mock responses. These responses
    should mimic the structure of real responses from an OpenID Connect provider,
    including access tokens, ID tokens, and refresh tokens as necessary.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please see the related abstract class in the GitHub repository to see how we
    need to mock the key-cloak server at [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/integrationtests/AbstractIntegrationTest.java](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/integrationtests/AbstractIntegrationTest.java).
    Whenever our application needs to communicate with key-cloak, our mock server
    respond to our application as we expected.
  prefs: []
  type: TYPE_NORMAL
- en: By mocking the OpenID Connect provider in this manner, you can test your application’s
    authentication and authorization flow accurately and consistently, ensuring that
    your security mechanisms work as intended without relying on external systems.
  prefs: []
  type: TYPE_NORMAL
- en: Having established a controlled environment for both database interactions and
    external service dependencies, we’re now well prepared to start writing our integration
    tests in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing integration tests for Author Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before diving into the tests themselves, ensuring a clean page for each test
    run is crucial. The `@BeforeEach` method plays a vital role in this process, allowing
    us to reset our database to a known state before every test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: By invoking methods such as `authorRepository.deleteAll()`, we can clear all
    data, preventing cross-test contamination and ensuring each test operates independently.
  prefs: []
  type: TYPE_NORMAL
- en: Securing tests with @WithMockUser
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since our application has a security layer, we need to write our tests by considering
    this layer, even if we have a mocked third-party security dependency. Our application
    still checks the roles of the requests in the security filter. We have a very
    helpful annotation for this: the `@WithMockUser` annotation allows us to simulate
    requests from authenticated users with specific roles, ensuring that our tests
    accurately reflect the application’s security constraints. In this way, we can
    confirm our security configuration is working effectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the endpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we are ready to write our tests for each endpoint. We have up-and-running
    test databases and mocked third-party dependencies. Now, we just need to send
    requests and assert the responses to the `/authors` endpoints. This part is very
    similar to the controller unit tests but the difference is we will not mock the
    service – we will use the service itself. The tests will all run end to end. So,
    we will ensure our application is running as expected with its all components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, we will write a test case for the `Get /``authors/{authorId}`
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we make a GET request to our application with a mock user with an admin
    role, and we prepare the database by inserting a sample `Author` object. We also
    expect to get a valid response from the application. As you can see, we didn’t
    mock the repository class or service class, therefore, when the application starts
    working, and we initiate a `GET` request, all related classes and methods are
    really working like a real application.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of the test cases, you can check out our GitHub repository at [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/integrationtests/AuthorControllerIntegrationTest.java](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/integrationtests/AuthorControllerIntegrationTest.java).
  prefs: []
  type: TYPE_NORMAL
- en: When we run our test class, it will test all the endpoints end to end. Integration
    testing bridges the gap between unit testing and end-to-end testing, focusing
    on the interactions between different parts of the application. It verifies that
    the application components work together as expected, identifying issues that
    might not be visible when testing components in isolation. Through the use of
    tools such as `Testcontainers` and WireMock, we’ve seen how to simulate real-world
    environments and dependencies, allowing for comprehensive and reliable testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In conclusion, we can see how important integration testing is in the software
    development cycle. It offers a comprehensive test of our application’s overall
    functionality. I always imagine these integration tests are like local development
    tests. When you change a code base, you can rely on integration tests to be sure
    your change doesn’t break any other flow. In the next section, we will deal with
    the asynchronous environment: reactive components.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing reactive components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll delve into testing reactive components, focusing on the
    `UserController` endpoints in our sample reactive Spring Boot application. Testing
    reactive components is slightly different from traditional applications because
    reactive programming offers a non-blocking, event-driven approach to handling
    data streams and the propagation of change. We’ll use Spring WebFlux along with
    `WebTestClient` for testing reactive HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the testing environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we learned in [*Chapter 3*](B18400_03.xhtml#_idTextAnchor064), reactive programming
    in Spring, facilitated by Spring WebFlux, introduces an approach to a non-blocking,
    event-driven model that efficiently handles asynchronous data streams. That’s
    why we need a slightly different strategy to test these reactive components to
    ensure that the asynchronous and non-blocking behavior is accurately accounted
    for. The reactive testing environment must be capable of dealing with data flows
    and sequences over time, making it crucial to understand how to set up and utilize
    the right tools effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use `WebTestClient` to test reactive components instead of `MockMVC`,
    as we used in non-reactive application tests. In the `UserControllerTest` class,
    configured with `@WebFluxTest(controllers = UserController.class)`, `WebTestClient`
    is autowired to enable direct interaction with the `UserController` endpoints.
    This annotation helps us to isolate our controller from the full configuration.
    It ensures that tests are lightweight and targeted, significantly speeding up
    the testing process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`@WebFluxTest` also sets up `WebTestClient` for our test environment and it
    becomes ready to use for sending simulated HTTP requests and asserting the responses.'
  prefs: []
  type: TYPE_NORMAL
- en: '`WebTestClient` helps to mock the behavior of requests and responses as they
    would occur in a live, reactive web environment. It also shows us again how Spring
    seamlessly supports the testing of reactive endpoints. After this theoretical
    information, we will delve into mocking the components in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing mock components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mocking plays a pivotal role in preventing actual database operations during
    tests, which is crucial for several reasons. Firstly, it ensures test isolation,
    allowing each test to run independently without the side effects of shared data.
    You already knew this from the previous chapter. So, we are directly diving into
    the code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With our dependencies mocked and test data freshly initialized before each test,
    we’re well equipped to dive into the core of our testing strategy, examining how
    each endpoint in `UserController` is tested. Next, we’ll start writing test cases,
    where we’ll break down the testing process for each operation, ensuring `UserController`
    behaves as expected under various conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Writing test cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we are ready to write our tests for each method. We have mocked our dependencies;
    we just need to write unit tests and see whether they return the expected results.
    The only difference between testing non-reactive components and this is that we
    will use `webTestClient` instead of `mockMVC`. Let’s start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this code block, we have written a unit test to get all user endpoints. First,
    we have manipulated the `userRepositry.findAll()` method to return a Flux `testUser`
    object, and we expect a successful response.
  prefs: []
  type: TYPE_NORMAL
- en: For the test methods for other endpoints, please see the GitHub repository at
    [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-reactive-test/src/test/java/com/packt/ahmeric/reactivesample/controller/UserControllerTest.java](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-reactive-test/src/test/java/com/packt/ahmeric/reactivesample/controller/UserControllerTest.java).
  prefs: []
  type: TYPE_NORMAL
- en: A look back is in order as we end our hands-on to test reactive components in
    our Spring Boot applications. A transition to the programming of reactivity obliges
    the developer to change their way of crafting applications and communicating in
    essence – chiefly focusing on non-blocking, asynchronous, and scalable interaction
    under pressure. However, great responsibility follows great power, and the testing
    of code stands at the pinnacle of that principle. The principal test challenges
    that testing these very reactive components brings in are the guaranteed handling
    of data streams, assured non-blocking nature, and dealing with backpressure.
  prefs: []
  type: TYPE_NORMAL
- en: With a myriad of approaches discussed in this section for testing a target,
    right from setting up the testing environment via `@WebFluxTest` to specifying
    dependencies and testing asynchronous results with `WebTestClient`, one is set
    up with the tools required to achieve quality, scalability, and maintainability
    in your reactive Spring Boot application. These then are ensuring strategies toward
    the guarantee that no matter what conditions are realized at runtime, the application
    behaves well and delivers the desired functionality and the desired performance.
  prefs: []
  type: TYPE_NORMAL
- en: The third good practice in testing is “reactive.” When applications become more
    complex and bigger in scale, the ability to effectively test these reactive components
    becomes a cornerstone of a successful development life cycle. In another light,
    developers who practice these testing methodologies can catch issues before they
    even rise to the level of annoyance and find a way to instill cultures of quality
    and resilience.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the way to test the reactive part is an accent of the dynamically
    changing web development landscape, which is always running into innovation in
    best development and best testing practices. With these insights and techniques
    from this exploration, go forth into future builds of more robust, responsible,
    and user-friendly applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we wrap up this comprehensive exploration into advanced testing strategies
    for both non-reactive and reactive Spring Boot applications, it’s clear that the
    journey has been both enlightening and empowering. We learned how testing is important
    for the development life cycle and how it is easy with Springboot capabilities.
    With practical examples and hands-on guidance, this chapter has equipped you with
    essential skills and insights that are critical in today’s fast-paced software
    development landscape. Here’s a summary of what we’ve covered:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Foundational principles of TDD**: We learned the foundational principles
    of TDD and its impact on software quality and reliability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit testing controllers**: We explored techniques for unit testing controllers
    with a security layer, ensuring that our applications are not only functional
    but also secure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Importance of integration testing**: We learned the importance of integration
    testing in validating the interaction between different parts of our applications,
    ensuring they work together seamlessly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing reactive components**: We explored strategies for testing reactive
    components, addressing the unique challenges presented by the reactive programming
    paradigm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These skills will make your applications tested, more reliable, scalable, and
    maintainable. Mastering these testing techniques in Spring Boot sets you apart
    as a developer.
  prefs: []
  type: TYPE_NORMAL
- en: Looking ahead, the journey through software development continues to evolve,
    bringing new challenges and opportunities. In the next chapter, we’ll dive into
    the world of containerization and orchestration. This upcoming chapter promises
    to unveil how Spring Boot applications can be made container ready, and how they
    can be orchestrated using Kubernetes for enhanced scalability and manageability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 4: Deployment, Scalability, and Productivity'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will shift our focus towards deploying and scaling applications
    effectively, alongside boosting productivity. [*Chapter 7*](B18400_07.xhtml#_idTextAnchor213)
    explores the latest Spring Boot 3.0 features, particularly those that enhance
    containerization and orchestration for smoother deployment processes. [*Chapter
    8*](B18400_08.xhtml#_idTextAnchor233) dives into building event-driven systems
    with Kafka, which are crucial for managing high-throughput data with scalability
    in mind. Lastly, [*Chapter 9*](B18400_09.xhtml#_idTextAnchor249) covers strategies
    to enhance productivity and simplify development, ensuring you can maintain a
    rapid and efficient workflow as your projects grow. This section is key to mastering
    the operational side of software development, preparing you to handle large-scale
    deployments with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18400_07.xhtml#_idTextAnchor213), *Spring Boot 3.0 Features
    for Containerization and Orchestration*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18400_08.xhtml#_idTextAnchor233), *Exploring Event-Driven Systems
    with Kafka*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18400_09.xhtml#_idTextAnchor249), *Enhancing Productivity and
    Development Simplification*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
