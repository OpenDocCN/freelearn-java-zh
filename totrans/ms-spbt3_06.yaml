- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Testing Strategies
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will further guide our entry into the world of complex testing
    methods and will offer clear guides to ensure that our software is reliable and
    robust. It will cover a range of topics: from a consideration of the basics of
    **test-driven development** (**TDD**) to specifics such as unit testing web controllers
    with security considerations, integration of different parts of an application,
    and the unique challenges of testing in reactive environments. This should make
    you a better developer who can write tests that cover all code. These techniques
    provide a strong foundation for ensuring improvements in quality and that these
    improvements are applicable to diverse software architectures – from classical
    web applications to reactive systems of modern software architecture.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In other words, by learning these testing strategies, you work not only to catch
    bugs or prevent errors but to prepare for the modern demands of software development.
    This chapter outlines everything you need to create high-performing, scalable,
    and maintainable applications. As we go on through the chapter, you will understand
    when and how to apply those testing techniques confidently, regardless of the
    complexity of your application or its architecture. This chapter will prepare
    you with the information and tools necessary to go successfully through the constantly
    changing world of software management.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: TDD in Spring Boot
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing of controllers with a security layer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing – bridging components together
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing reactive components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin this journey of learning how to make your Spring Boot applications
    secure and robust!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, we are going to need some settings in our local machines:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '**Java 17 Development Kit** (**JDK 17**)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A modern **integrated development environment** (**IDE**) – I recommend IntelliJ
    IDEA
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub repository**: You can clone all repositories related to [*Chapter
    6*](B18400_06.xhtml#_idTextAnchor192) from here: [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Desktop
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD in Spring Boot
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I was first introduced to the concept of TDD, I admit I was quite skeptical.
    I felt the concept of writing unit tests before the code itself just seemed ridiculous,
    or, in other words, crazy. I was not different from others who felt it was just
    an added process to slow down an already jam-packed development life cycle. But
    now, having explored the use of TDD during application development with Spring
    Boot 3.0, I know that this is not the case.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot 3.0 was a very fantastic platform to go for TDD-based work. I’d
    just taken on a new project and started moving forward based on the concept of
    TDD. The process itself was awkward, to say the least. It’s like pre-judging the
    future through writing a code test for code that doesn’t even exist. However,
    I continued with it. The unit tests literally drove the writing of the code in
    a way that I’ve never seen before. Having a clear and defined purpose in every
    single test and the development of code that would meet it made each relevant
    approach to the development focused and considered.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 3.0是一个非常出色的平台，可以用于基于TDD的工作。我刚刚接手了一个新项目，并开始基于TDD的概念前进。这个过程本身至少是尴尬的。它就像通过为不存在的代码编写测试来预先判断未来。然而，我继续这样做。单元测试实际上以我以前从未见过的方式推动了代码的编写。每个测试都有一个明确和定义的目的，以及编写满足它的代码，这使得每个相关的发展方法都变得专注和经过深思熟虑。
- en: Its purpose was to catch early bugs and make the code base organized and maintainable.
    Writing tests in this manner becomes a cycle through **Red** (writing a failing
    test), **Green** (making the test pass), and **Refactor** (cleaning up the code).
    It bounces you along the project. The time spent upfront in writing tests gets
    paid off by a reduction in debugging and revising faulty code later.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 其目的是捕捉早期错误，并使代码库有组织且易于维护。以这种方式编写测试形成了一个通过**红**（编写失败的测试）、**绿**（使测试通过）和**重构**（清理代码）的循环。它推动着项目前进。在编写测试时投入的时间通过减少后续的调试和修正错误代码而得到回报。
- en: Now, let’s proceed practically to apply the theory in our Bookstore application.
    In this section, we will practice TDD, building a feature in our application.
    You will learn how to first write and then pass the tests according to the feature.
    All of this practical experience is intended to provide you with a solid foundation,
    rather than just theoretical knowledge, in application development with Spring
    Boot 3.0.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实际操作，将理论应用到我们的书店应用中。在本节中，我们将练习TDD，构建应用中的一个功能。你将学习如何首先编写测试，然后根据功能通过测试。所有这些实践经验旨在为你提供一个坚实的基础，而不仅仅是理论上的知识，在Spring
    Boot 3.0的应用开发中。
- en: This, of course, is meant to make you feel comfortable and confident when using
    TDD in your projects. Let’s get started!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然是为了让你在使用TDD时感到舒适和自信。让我们开始吧！
- en: Implementing TDD
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施TDD
- en: 'In this section, we will start a new TDD journey. As a part of this task, we
    have a new requirement for our Bookstore application: introducing an additional
    service layer between the controller and the repository for `Author` flows. The
    controller has two GET methods and one PUT, one POST, and one DELETE method. The
    requirements are to create a class called `AuthorService.java`, provide the methods
    the controller class needs, and throw an `EntityNotFound` exception when `Author`
    is not found in the database in the `DELETE` process. Let’s achieve this task
    by using the TDD approach:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开始一个新的TDD之旅。作为这项任务的一部分，我们对书店应用有一个新的需求：在控制器和`Author`流程的存储库之间引入一个额外的服务层。控制器有两个GET方法，一个PUT方法，一个POST方法和一个DELETE方法。要求是创建一个名为`AuthorService.java`的类，提供控制器类需要的方法，并在`DELETE`过程中在数据库中找不到`Author`时抛出`EntityNotFound`异常。让我们通过使用TDD方法来完成这个任务：
- en: '`AuthorServiceTest.java` under the `src/test/java` folder. First, we will write
    our first test for the potential `getAuthor` method. However, when we start writing
    the test method, we will see we don’t have a service class yet, and we will create
    an empty service class called `AuthorService.java`. But when we try to autocomplete
    the `getAuthor` method, we will see there is no method named like this. So, we
    will create a new method in the service class as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/test/java`文件夹下的`AuthorServiceTest.java`。首先，我们将为潜在的`getAuthor`方法编写第一个测试。然而，当我们开始编写测试方法时，我们会看到我们还没有服务类，我们将创建一个名为`AuthorService.java`的空服务类。但当我们尝试自动完成`getAuthor`方法时，我们会看到没有这样的方法。因此，我们将在服务类中创建一个新的方法，如下所示：
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, this method almost is empty. However, we know we will have
    a method called `getAuthor`, accept `Id` as a parameter, and return `Optional<Author>`.
    In all tests, we need to prepare the environment for this test such as creating
    the required data. So, we will inject the `authorRepository` class in both service
    and test classes. Now, we can write the first test case:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，这种方法几乎是空的。然而，我们知道我们将有一个名为`getAuthor`的方法，接受`Id`作为参数，并返回`Optional<Author>`。在所有测试中，我们需要为这个测试准备环境，例如创建所需的数据。因此，我们将`authorRepository`类注入到服务和测试类中。现在，我们可以编写第一个测试用例：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`when`: This helps us to manipulate the returned object of the mocked methods.
    In our sample, it mocks when `authorRepository.findById()` is called, and it will
    always return `savedAuthor`.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`when`：这有助于我们操作模拟方法的返回对象。在我们的示例中，它模拟了当调用 `authorRepository.findById()` 时，它将始终返回
    `savedAuthor`。'
- en: '`assertTrue`: This asserts the method returns true.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`assertTrue`：这个断言断言方法返回 true。'
- en: '`assertEquals`: This asserts that the provided two values are equal.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`assertEquals`：这个断言断言提供的两个值是相等的。'
- en: When we run the `givenExistingAuthorId_whenGetAuthor_thenReturnAuthor` method,
    the test will fail because our method is always returning `Optional.empty()`.
    So, we have a failing test on our hands; let’s go and fix it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `givenExistingAuthorId_whenGetAuthor_thenReturnAuthor` 方法时，测试将失败，因为我们的方法始终返回
    `Optional.empty()`。所以，我们手头有一个失败的测试；让我们去修复它。
- en: '**Green (making the test pass)**: In order to pass this test, we need to use
    the repository class in our method:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**绿色（使测试通过）**：为了通过这个测试，我们需要在我们的方法中使用仓库类：'
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, it is done. When we run the tests again, we will see it will pass.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，它已经完成了。当我们再次运行测试时，我们会看到它会通过。
- en: '**Refactor (cleaning up the code)**: In this step, we need to check both the
    test and source classes and see whether they need refactoring. In our case, in
    the source class, we don’t need any refactoring, but on the test side, we may
    tidy up a little bit. We can remove the object creation from the test class and
    make the test case more readable. Also, we can reuse that object in other test
    classes in the future:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重构（清理代码）**：在这个步骤中，我们需要检查测试和源类，看看它们是否需要重构。在我们的例子中，在源类中我们不需要任何重构，但在测试方面，我们可能需要稍微整理一下。我们可以从测试类中移除对象创建，使测试用例更易于阅读。此外，我们可以在未来的其他测试类中重用该对象：'
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have introduced a `setup` method for setting the common variables to reduce
    code duplications in the test class.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们引入了一个 `setup` 方法来设置公共变量，以减少测试类中的代码重复。
- en: 'After introducing the `setup` method, our test method became clearer with fewer
    lines of code:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在引入 `setup` 方法之后，我们的测试方法变得更加清晰，代码行数更少：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have completed one iteration of TDD for the Author service. We need to do
    the same iterations for all methods until we have a mature `AuthorService` that
    can be used in the controller class.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经完成了对作者服务的 TDD 迭代。我们需要对所有方法进行相同的迭代，直到我们有一个成熟的 `AuthorService`，可以在控制器类中使用。
- en: At the end of these processes, we will have `AuthorServiceTest` as in the GitHub
    repository. However, we will also have some new terminology for unit tests, which
    we will discuss in the *Discussing terminology for unit* *tests* section.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这些过程结束时，我们将拥有 GitHub 仓库中的 `AuthorServiceTest`。然而，我们还将有一些新的单元测试术语，我们将在 *讨论单元测试术语*
    部分中进行讨论。
- en: 'We have left one final step: updating the `AuthorController` class to consume
    this new (`AuthorService`) service instead of the repository.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经留下了一步最后的工作：将 `AuthorController` 类更新为使用这个新的 (`AuthorService`) 服务，而不是使用仓库。
- en: We will need to inject the `AuthorService` class into the controller class and
    use the methods in `AuthorService` instead of the repository methods.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要将 `AuthorService` 类注入到控制器类中，并使用 `AuthorService` 中的方法，而不是使用仓库中的方法。
- en: 'You can see the updated `AuthorController` in the GitHub repository ([https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/main/java/com/packt/ahmeric/bookstore/controller/AuthorController.java](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/main/java/com/packt/ahmeric/bookstore/controller/AuthorController.java)).
    I would like to mention the `delete` method here:'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 仓库中看到更新的 `AuthorController`（[https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/main/java/com/packt/ahmeric/bookstore/controller/AuthorController.java](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/main/java/com/packt/ahmeric/bookstore/controller/AuthorController.java)）。我想在这里提到
    `delete` 方法：
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, we have replaced the methods and, in the `delete` function,
    we have added an exception handler to cover `EntityNotFoundException`.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们已经替换了方法，在 `delete` 函数中，我们添加了一个异常处理程序来覆盖 `EntityNotFoundException`。
- en: In this section, we have learned about the TDD and how to implement it in a
    real-world sample. This will take some time, and it requires some patience to
    make it a habit in the development cycle. However, once you have learned how to
    go with TDD, you will have fewer bugs and more maintainable code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了 TDD（测试驱动开发）以及如何在现实世界的示例中实现它。这需要一些时间，并且需要一些耐心，使其成为开发周期中的习惯。然而，一旦你学会了如何进行
    TDD，你将会有更少的错误和更易于维护的代码。
- en: Discussing terminology for unit tests
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s discuss some essential terminology in unit testing:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '`assertThrows()`: This is a method used in JUnit tests to assert that a specific
    type of exception is thrown during the execution of a piece of code. It is particularly
    useful when you want to test that your code properly handles error conditions.
    In our test class, you can see it as follows:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This method takes two main parameters: the expected exception type and a functional
    interface (usually a lambda expression), which contains the code expected to throw
    the exception. If the specified exception is thrown, the test passes; otherwise,
    it fails.'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`verify()`: Mockito is a library that we always use in unit testing. It has
    very useful methods that make our tests more reliable and readable. `verify()`
    is one of them; it is used to check that certain interactions with mock objects
    occur. It can verify that methods were called with specific parameters, a certain
    number of times, or even that they were never called. This is crucial for testing
    that your code interacts with dependencies as expected. In our test class, you
    can see it as follows:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`@InjectMocks`: The `@InjectMocks` annotation in Mockito is used to create
    instances of a class and inject mock fields into it. This is particularly useful
    when you have a class that depends on other components or services, and you want
    to test the class in isolation by using mock versions of its dependencies. The
    following code snippet shows a sample usage:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`@ExtendWith(MockitoExtension.class)`: This annotation is used with JUnit 5
    to enable Mockito support in tests. By declaring `@ExtendWith(MockitoExtension.class)`
    at the class level, you allow Mockito to initialize mocks and inject them before
    tests are run. This makes it easier to write cleaner test code with less boilerplate.
    You can see it here in our test class:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`@BeforeEach`: In JUnit 5, the `@BeforeEach` annotation is used on a method
    to specify that it should be executed before each test method in the current test
    class. It’s commonly used for setup tasks that are common to all tests, ensuring
    each test starts with a fresh state. It is used with a method, as you can see
    in the following code:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we are now aware of the new terminology in the unit test, in the next section,
    we will use our unit test knowledge and improve it by learning how to test controller
    classes, especially the ones with a security layer.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing of controllers with a security layer
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this new section, we will deal with testing controller classes. Why do we
    have a different test approach for controller classes? The request and response
    can be represented as JSON objects, similar to a real Request and Response, not
    like the objects in our project. This will help us check that everything is OK
    to accept requests and also assert the JSON response if they match the requirements.
    We will discuss some new annotations and next, we will focus on how to implement
    these new annotations for `AuthorControllerTest` step by step.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新章节中，我们将处理测试控制器类。为什么我们为控制器类采用不同的测试方法？请求和响应可以表示为JSON对象，类似于真实的请求和响应，而不是我们项目中的对象。这将帮助我们检查是否一切正常以接受请求，并在它们符合要求时断言JSON响应。我们将讨论一些新的注解，接下来，我们将逐步关注如何为`AuthorControllerTest`实现这些新注解。
- en: Key annotations for Spring MVC controller testing
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring MVC控制器测试的关键注解
- en: 'Spring `@WebMvcTest`, `@Import`, `@WithMockUser`, and `@MockBean`, which are
    essential players in Spring MVC controller testing. These annotations help establish
    a testing framework that ensures our controllers perform as expected whether in
    isolation or when integrated with Spring’s web context and security components.
    Let’s take a look at them:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Spring的`@WebMvcTest`、`@Import`、`@WithMockUser`和`@MockBean`是Spring MVC控制器测试中的关键角色。这些注解帮助建立测试框架，确保我们的控制器无论在独立测试还是与Spring的Web上下文和安全组件集成时都能按预期执行。让我们来看看它们：
- en: '`@WebMvcTest(AuthorController.class)`: The `@WebMvcTest` annotation is used
    for unit testing Spring MVC applications in a more focused way. It is applied
    to test classes that need to test Spring MVC controllers. Using `@WebMvcTest`
    with a specific controller class, such as `AuthorController.class`, tells Spring
    Boot to only instantiate the given controller and its required dependencies, not
    the whole context. This makes the tests run faster and focus strictly on the MVC
    components. This annotation automatically configures the Spring MVC infrastructure
    for your tests.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@WebMvcTest(AuthorController.class)`：`@WebMvcTest`注解用于以更集中的方式对Spring MVC应用程序进行单元测试。它应用于需要测试Spring
    MVC控制器的测试类。使用`@WebMvcTest`与特定的控制器类，如`AuthorController.class`，告诉Spring Boot仅实例化给定的控制器及其所需依赖项，而不是整个上下文。这使得测试运行更快，并且严格关注MVC组件。此注解会自动为测试配置Spring
    MVC基础设施。'
- en: '`@Import(SecurityConfig.class)`: The `@Import` annotation allows you to import
    additional configuration classes into the Spring test context. When used in controller
    tests, particularly alongside `@WebMvcTest`, it’s often necessary to include specific
    configuration classes that aren’t automatically picked up by `@WebMvcTest`. By
    specifying `@Import(SecurityConfig.class)`, you’re explicitly telling Spring to
    load your `SecurityConfig` class. This class contains security configurations
    (such as authentication and authorization settings) that are necessary for your
    tests to run in an environment that closely mimics your application’s security
    setup.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Import(SecurityConfig.class)`：`@Import`注解允许您将额外的配置类导入Spring测试上下文。在控制器测试中，尤其是在与`@WebMvcTest`一起使用时，通常需要包含特定的配置类，这些配置类不是由`@WebMvcTest`自动获取的。通过指定`@Import(SecurityConfig.class)`，您明确告诉Spring加载您的`SecurityConfig`类。此类包含安全配置（如身份验证和授权设置），这对于测试在接近您应用程序安全设置的环境中运行是必要的。'
- en: '`@MockBean`: Spring application context uses beans such as Service and Repository,
    and in our test context, we need to mock these beans. `@MockBean` adds mock objects
    to the Spring application context, and these mocked objects are used instead of
    real Service and Repository objects. This is useful for injecting mock implementations
    for services, repositories, or any other components that your controller depends
    on, without actually loading those beans from the real application context.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@MockBean`：Spring应用程序上下文使用诸如Service和Repository之类的bean，在我们的测试上下文中，我们需要模拟这些bean。`@MockBean`将模拟对象添加到Spring应用程序上下文中，这些模拟对象将用于替代真实的Service和Repository对象。这对于注入模拟实现服务、存储库或控制器所依赖的任何其他组件非常有用，而无需从真实的应用程序上下文中实际加载这些bean。'
- en: '`@WithMockUser`: This annotation is used in Spring Security tests to simulate
    running a test with a mock authenticated user. This annotation allows you to specify
    details of the mock user, such as username, roles, and authorities, without the
    need to interact with the actual security environment or authentication mechanism.
    It’s particularly useful for controller tests where you want to test the behavior
    of your endpoints under different authentication or authorization scenarios. By
    using `@WithMockUser`, you can easily emulate different user contexts, testing
    how your application responds to various levels of access and ensuring that security
    constraints are correctly enforced. This makes it an essential tool for comprehensive
    testing of secured endpoints in a Spring Boot application.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@WithMockUser`：这个注解用于 Spring Security 测试，用于模拟使用模拟认证用户运行测试。此注解允许您指定模拟用户的具体细节，例如用户名、角色和权限，而无需与实际的安全环境或认证机制交互。它特别适用于控制器测试，您希望测试端点在不同认证或授权场景下的行为。通过使用
    `@WithMockUser`，您可以轻松模拟不同的用户上下文，测试应用程序如何响应不同的访问级别，并确保安全约束得到正确执行。这使得它成为全面测试 Spring
    Boot 应用程序中受保护端点的必备工具。'
- en: For controller tests, especially with a security layer, these annotations play
    crucial roles in ensuring that your tests are focused and fast and reflect your
    application’s actual running conditions as closely as possible. In the next section,
    we will get our hands dirty while implementing these into our test class.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于控制器测试，尤其是在有安全层的情况下，这些注解在确保您的测试专注且快速，尽可能反映应用程序的实际运行条件方面发挥着关键作用。在下一节中，我们将将这些注解实现到测试类中。
- en: Crafting controller tests with Spring annotations
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Spring 注解构建控制器测试
- en: When we start working on creating tests, for controllers, it’s important to
    make use of Springs annotations. These annotations, such as `@WebMvcTest`, `@Import`,
    `@WithMockUser`, and `@MockBean`, are crucial for establishing the testing environment
    that mirrors our application’s web layer and security setups. This section focuses
    on utilizing these annotations to develop targeted tests for our controllers.
    By incorporating these tools, our goal is to strike a balance between speed and
    accuracy in testing to ensure that our controllers operate effectively within
    the web environment. Let’s explore how we can practically apply these annotations
    to mimic real-world scenarios and verify the functionality of our Spring MVC controllers
    in certain situations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始为控制器创建测试时，使用 Spring 注解非常重要。这些注解，例如 `@WebMvcTest`、`@Import`、`@WithMockUser`
    和 `@MockBean`，对于建立与我们的应用程序的 Web 层和安全设置相匹配的测试环境至关重要。本节重点介绍如何利用这些注解来为我们的控制器开发有针对性的测试。通过整合这些工具，我们的目标是平衡测试的速度和准确性，以确保我们的控制器在
    Web 环境中有效运行。让我们探讨如何实际应用这些注解来模拟现实场景，并验证我们的 Spring MVC 控制器在某些情况下的功能。
- en: Creating a comprehensive test suite for `AuthorController` in a Spring Boot
    application involves several steps, from setting up the initial testing environment
    with specific annotations to writing detailed test cases for different user roles
    and operations. Here is a step-by-step guide to achieve the final state of `AuthorControllerTest.java`
    as described.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring Boot 应用程序中为 `AuthorController` 创建一个全面的测试套件涉及多个步骤，从使用特定注解设置初始测试环境到为不同的用户角色和操作编写详细的测试用例。以下是实现
    `AuthorControllerTest.java` 最终状态的逐步指南。
- en: Step 1 – setting up your test environment
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 1 步 - 设置您的测试环境
- en: 'To set up your environment, follow these steps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置您的环境，请按照以下步骤操作：
- en: Create a test class file named `AuthorControllerTest.java`. Annotate the class
    with `@WebMvcTest(AuthorController.class)` to focus on testing only `AuthorController`.
    This tells Spring Boot to configure only the MVC components necessary for the
    test, without the full application context.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `AuthorControllerTest.java` 的测试类文件。使用 `@WebMvcTest(AuthorController.class)`
    注解该类，以专注于测试 `AuthorController`。这告诉 Spring Boot 仅配置测试所需的 MVC 组件，而不使用完整的应用程序上下文。
- en: Use `@Import(SecurityConfig.class)` to include your custom security configuration
    in the test context. This is crucial for accurately simulating security behaviors
    during testing.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `@Import(SecurityConfig.class)` 将您的自定义安全配置包含在测试上下文中。这在测试期间准确模拟安全行为至关重要。
- en: 'Declare the required fields:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明所需的字段：
- en: '`ApplicationContext` to set up the `MockMvc` object'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplicationContext` 用于设置 `MockMvc` 对象'
- en: A `MockMvc` object for performing and asserting HTTP requests
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于执行和断言 HTTP 请求的 `MockMvc` 对象
- en: Mock beans for any services or components the controller depends on, such as
    `AuthorService` and `JwtDecoder`, using the `@``MockBean` annotation
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@MockBean` 注解模拟控制器所依赖的任何服务或组件，例如 `AuthorService` 和 `JwtDecoder`。
- en: An `ObjectMapper` for JSON serialization and deserialization in tests
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于测试中 JSON 序列化和反序列化的 `ObjectMapper`
- en: 'These are the code changes of this step:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这一步的代码更改：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we have set up our test class by mocking `AuthorService` and `JwtDecoder`.
    We will be able to manipulate them when needed in the next section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经通过模拟 `AuthorService` 和 `JwtDecoder` 来设置测试类。我们将在下一节中需要时能够操纵它们。
- en: Step 2 – initializing the testing framework
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2 步 – 初始化测试框架
- en: 'Implement a setup method annotated with `@BeforeEach` to initialize the `MockMvc`
    object before each test:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个带有 `@BeforeEach` 注解的设置方法，以便在每个测试之前初始化 `MockMvc` 对象：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This method uses the `MockMvcBuilders` utility to build the `MockMvc` object
    with the web application context and Spring Security integration.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用 `MockMvcBuilders` 工具构建带有 Web 应用程序上下文和 Spring Security 集成的 `MockMvc` 对象。
- en: Step 3 – writing test cases
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3 步 – 编写测试用例
- en: 'After setting up our test class, we can start to write our test cases step
    by step:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置我们的测试类之后，我们可以开始逐步编写我们的测试用例：
- en: Write parameterized test cases for adding and getting authors with different
    roles. Use `@ParameterizedTest` and `@MethodSource` to supply the roles and expected
    HTTP statuses. In these tests, you’ll simulate requests with different user roles
    and assert the expected outcomes.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写针对添加和获取不同角色作者的参数化测试用例。使用 `@ParameterizedTest` 和 `@MethodSource` 来提供角色和预期的
    HTTP 状态。在这些测试中，您将模拟具有不同用户角色的请求并断言预期的结果。
- en: For adding authors, mock the `AuthorService` response and perform a POST request,
    asserting the status based on the role.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于添加作者，模拟 `AuthorService` 的响应并执行 POST 请求，根据角色断言状态。
- en: For getting an author by ID, mock the `AuthorService` response and perform a
    GET request, asserting both the status and the content based on the role.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于通过 ID 获取作者，模拟 `AuthorService` 的响应并执行 GET 请求，根据角色断言状态和内容。
- en: 'Write tests for fetching all authors, updating an author, and deleting an author.
    Utilize `@Test` and `@WithMockUser` to specify the user details inline. These
    tests will do the following:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写获取所有作者、更新作者和删除作者的测试用例。利用 `@Test` 和 `@WithMockUser` 注解指定用户详细信息。这些测试将执行以下操作：
- en: Mock service layer responses
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟服务层响应
- en: Perform the relevant HTTP request (GET for all authors, PUT for updating, DELETE
    for deleting)
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行相关的 HTTP 请求（GET 用于获取所有作者，PUT 用于更新，DELETE 用于删除）
- en: Assert the expected outcomes, including status codes and, when applicable, response
    body content
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言预期的结果，包括状态码和，当适用时，响应体内容
- en: You can see how these steps are implemented in the controller test class. You
    can see five test methods in the GitHub repository, which validates the test cases,
    as we mentioned in this section, at [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/com/packt/ahmeric/bookstore/controller/AuthorControllerTest.java](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/com/packt/ahmeric/bookstore/controller/AuthorControllerTest.java).
    We will discuss how we can test exception handling in the next section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在控制器测试类中看到这些步骤是如何实现的。您可以在 GitHub 仓库中看到五个测试方法，这些方法验证了本节中提到的测试用例，链接为 [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/com/packt/ahmeric/bookstore/controller/AuthorControllerTest.java](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/com/packt/ahmeric/bookstore/controller/AuthorControllerTest.java)。我们将在下一节讨论如何测试异常处理。
- en: Step 4 – handling exceptional cases
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 4 步 – 处理异常情况
- en: 'Write a test case for handling a scenario where an author to be deleted is
    not found. Mock the service to throw `EntityNotFoundException` when attempting
    to delete a non-existent author, and assert that the controller correctly responds
    with a `404` status:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个处理要删除的作者未找到场景的测试用例。模拟服务在尝试删除不存在的作者时抛出 `EntityNotFoundException`，并断言控制器正确地响应了
    `404` 状态：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this test method, we are manipulating our `authorService.deleteAuthor` method
    to throw an exception by using the `doThrow()` method, and we are expecting a
    `not found` status as a response.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试方法中，我们通过使用 `doThrow()` 方法操纵 `authorService.deleteAuthor` 方法来抛出异常，并期望得到一个“未找到”的状态响应。
- en: Step 5 – running the tests
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 5 步 – 运行测试
- en: Run your tests to verify that all pass and that your controller behaves as expected
    across various scenarios and user roles.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的测试以验证所有测试都通过，并且你的控制器在各种场景和用户角色下表现如预期。
- en: This comprehensive testing approach not only validates the functional aspects
    of `AuthorController` but also ensures that security constraints are respected,
    providing confidence in both the application’s behavior and its security posture.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种全面的测试方法不仅验证了`AuthorController`的功能方面，还确保了安全约束得到尊重，从而在应用程序的行为和安全性方面提供了信心。
- en: In this section, we learned how to write controller tests by using Spring MVC
    controllers with security configurations. We have written the tests for both assertions,
    functionality, and security. By these tests, we are sure our controllers and the
    security filters are working as expected.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用具有安全配置的Spring MVC控制器编写控制器测试。我们已经为断言、功能和安全编写了测试。通过这些测试，我们确信我们的控制器和安全过滤器按预期工作。
- en: After completing our journey in the unit test, we will focus on the integration
    test in the next section. We will explore how to test the integration/interaction
    between various components of our project, including databases, web services,
    and external APIs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成单元测试之旅后，我们将在下一节中关注集成测试。我们将探讨如何测试我们项目中的不同组件之间的集成/交互，包括数据库、网络服务和外部API。
- en: Integration testing – bridging components together
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试 – 将组件连接起来
- en: 'Once you understand the concepts of unit testing, especially when dealing with
    tricky security layers, you can expand your vision to integration testing. While
    writing unit tests, you can think of quality checks on bricks that are carried
    out to ensure that a wall built with those bricks will keep you and your family
    safe from rain, snow, and everything else. Integration testing assesses how well
    different pieces of our application work. This is where the complete application
    tests are run at full length: the module interaction, databases, web services,
    and interaction with all the other external systems required are cross-examined
    to affirm that it is all smooth.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了单元测试的概念，尤其是在处理棘手的网络安全层时，你可以将你的视野扩展到集成测试。在编写单元测试时，你可以将质量检查想象成对砖块进行的检查，以确保用这些砖块建造的墙能让你和家人免受雨、雪以及其他一切天气的影响。集成测试评估我们应用程序的不同部分如何协同工作。这就是完整的应用程序测试在全面运行的地方：模块交互、数据库、网络服务和与其他所有外部系统的交互都会被交叉检验，以确保一切顺利。
- en: Why integration tests? Are unit tests not enough to prove our application is
    robust? The quick answer is no. In unit tests, we are just proving the methods
    are working as expected, but in real life, the methods are not working on their
    own. They interact with other components. So, integration tests are crucial to
    see whether any component has been affected by your change.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要集成测试？单元测试不足以证明我们的应用程序是健壮的吗？简短的答案是：不。在单元测试中，我们只是在证明方法按预期工作，但在现实生活中，这些方法并不是独立工作的。它们与其他组件交互。因此，集成测试对于查看任何组件是否受到你的更改的影响是至关重要的。
- en: So, fasten your seatbelts, because we are now going to take a ride. Just to
    be sure, a big integrated system will stand by all the requirements and possible
    scenarios – this, in fact, leaves your application far better prepared for the
    real world and the ultimate test of meeting user needs against expectations. We
    guide you with clear, practical examples to finally give you concise integration
    tests, ensuring peace of mind that your high-quality software product can finally
    be delivered.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，系好安全带，因为我们现在要开始一段旅程。为了确保万无一失，一个大型集成系统将满足所有要求和可能的场景——这实际上让你的应用程序为现实世界和满足用户需求的最终测试做好了更好的准备。我们将通过清晰、实用的示例引导你，最终提供简洁的集成测试，确保你的高质量软件产品最终能够交付。
- en: Setting up the testing environment
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置测试环境
- en: The main purpose of integration testing is to identify and solve problems attached
    to the interaction amid different parts of the application. This may comprise
    designed interactions between several service layers, databases, or external APIs,
    all together aimed at having them purposefully work together in the same way functions
    are supposed to take place. Unlike unit testing, integration testing ensures that
    isolated functionality is correct since it studies how the system behaves. Overall,
    the application itself should be tested from the interface level part, to ensure
    that the quality and functionality are full, avoiding interface lack in the defects,
    performance bottlenecks, and other integration issues left from unit testing.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试的主要目的是识别和解决与应用程序不同部分之间交互相关的问题。这可能包括几个服务层、数据库或外部API之间的设计交互，所有这些共同的目标是让它们有目的地以相同的方式协同工作，就像函数应该执行一样。与单元测试不同，集成测试确保隔离的功能是正确的，因为它研究系统的行为。总的来说，应该从接口级别部分测试应用程序本身，以确保质量和功能完整，避免在缺陷、性能瓶颈和其他集成问题中留下接口缺失，这些问题可能来自单元测试。
- en: 'In our integration testing strategy for the Author Controller endpoints, we
    utilize these two primary classes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对作者控制器端点的集成测试策略中，我们利用这两个主要类：
- en: '`AbstractIntegrationTest`: This class serves as the foundation for our integration
    tests, providing common configuration and setup routines that are shared across
    multiple test classes. It is an abstract class that does not directly run tests;
    instead, it sets up the testing environment. This includes configuring test containers
    for databases, initializing WireMock for mocking external services, and setting
    up Spring’s application context with the necessary profiles and configurations
    for integration testing. WireMock is a library that we use for mocking services
    such as REST and **Simple Object Access Protocol** (**SOAP**) services. By this
    mocking power, we can isolate our component from external connections and the
    potential faults of these services. We can use this abstract class for all integration
    tests since they will also need the same setup. The usage of an abstract base
    class helps us maintain a clean and **Don’t Repeat Yourself** (**DRY**) testing
    code base.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractIntegrationTest`：这个类作为我们集成测试的基础，提供跨多个测试类共享的常见配置和设置例程。它是一个抽象类，不直接运行测试；相反，它设置测试环境。这包括为数据库配置测试容器，初始化WireMock以模拟外部服务，以及设置Spring的应用程序上下文，包括集成测试所需的必要配置文件和配置。WireMock是我们用于模拟REST和**简单对象访问协议**（**SOAP**）服务等的库。通过这种模拟能力，我们可以隔离我们的组件，避免与外部连接以及这些服务的潜在故障。由于所有集成测试也需要相同的设置，我们可以使用这个抽象类。使用抽象基类有助于我们维护一个干净且**不要重复自己**（**DRY**）的测试代码库。'
- en: '`AuthorControllerIntegrationTest`: Extending from `AbstractIntegrationTest`,
    this class focuses specifically on testing the Author Controller endpoints. It
    inherits the common testing environment setup from `AbstractIntegrationTest` and
    adds tests that cover the functionality of the Author Controller, such as creating,
    reading, updating, and deleting authors. The `AuthorControllerIntegrationTest`
    class utilizes Spring’s MockMvc to simulate HTTP requests and assert the responses,
    ensuring that the Author Controller behaves as expected when integrated with other
    application components such as the security layer and the database.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthorControllerIntegrationTest`：从`AbstractIntegrationTest`扩展而来，这个类专门用于测试作者控制器端点。它从`AbstractIntegrationTest`继承了常见的测试环境设置，并添加了覆盖作者控制器功能的测试，例如创建、读取、更新和删除作者。`AuthorControllerIntegrationTest`类利用Spring的MockMvc来模拟HTTP请求并断言响应，确保当与其他应用程序组件（如安全层和数据库）集成时，作者控制器表现如预期。'
- en: By structuring our integration tests this way, we achieve a layered testing
    approach that allows us to isolate the testing of specific components (such as
    the Author Controller) while still leveraging a common setup for aspects shared
    across tests. This organization makes our tests more efficient and easier to maintain
    and ensures that we comprehensively test the interactions and integrations crucial
    for the application’s overall performance and reliability.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以这种方式构建我们的集成测试，我们实现了一种分层测试方法，使我们能够在仍然利用测试之间共享的公共设置的同时，隔离特定组件（如作者控制器）的测试。这种组织结构使我们的测试更加高效，更容易维护，并确保我们全面测试对应用程序整体性能和可靠性至关重要的交互和集成。
- en: Configuring application properties for integration testing
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置集成测试的应用程序属性
- en: In integration tests, our application will need to run as it would in a real
    environment. So, it is crucial to set up the application properties file. However,
    we also need to isolate the integration test environment from other test environments.
    That’s why we are initiating a new `application-integration-test.properties`.
    By this segregation, we ensure that the configuration in the integration test
    environment is just for that environment and it won’t affect the other test and
    development environments.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'We are adding the same properties as we are using in the current source code.
    This is because the following parameters will be needed by our application when
    it is running in the integration test profile:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By configuring these properties, we create a controlled, predictable, and isolated
    environment that allows us to test our application’s integration points thoroughly
    and accurately. This setup is crucial for evaluating the application’s behavior
    in a simulated production environment, ensuring that all components work harmoniously
    together.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll dive into the practical application of these configurations, where
    we set the stage for robust, environment-true testing.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the database with Testcontainers
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Testcontainers` is a Java library designed for JUnit and systems testing.
    It usually provides a lightweight, throw-away instance manner on the run of shared
    databases and Selenium web browsers or anything that can run inside a Docker container.
    Under the hood, `Testcontainers` uses Docker to help with the full setup and,
    especially, tear-down of actual database instances, which are isolated, ephemeral,
    and fully in one’s control. With the help of tools such as `Testcontainers`, one
    can accurately test the database interaction and persistence necessary for business
    needs without much overhead, the complexity of database installations, or setups
    of some sort of shared test instances.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now configure PostgreSQL and MongoDB containers by initializing `Testcontainers`
    for PostgreSQL and MongoDB databases in the `AbstractIntegrationTest` class. Here’s
    how it’s done:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '`Testcontainers` library. This method specifies the Docker image to use (`postgres:latest`),
    as well as database-specific configurations such as the database name, username,
    and password. Once initialized, the container is started, and the **Java Database
    Connectivity** (**JDBC**) URL, username, and password are dynamically injected
    into the Spring application context. This allows the integration tests to interact
    with a real PostgreSQL database instance that’s identical to what would be used
    in production.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Testcontainers` library by specifying the Docker image (`mongo:4.4.6`). Upon
    starting the MongoDB container, the connection URI is injected into the Spring
    application context, enabling tests to communicate with a real MongoDB instance.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To initialize the database, follow these steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, we will define the required parameters such as database image versions
    and the database name:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will use these parameters when we are initiating our test database containers:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this code block, first, we define the container and call the container initialize
    function in it. The container initialize function consumes the parameters defined
    in the previous code block in *Step 1*.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will need some dynamic properties, which will be defined after containers
    are triggered. By using the following code, we can let the application know which
    data source URL will be used for connecting to the database:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Each container is automatically run up, prepared, and torn down before and after
    tests, ensuring that every test suite runs against a clean, isolated database
    environment. This automated process elevates the reliability and repeatability
    of integration tests and simplifies the setup and troubleshooting of database
    interactions.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the databases ready and set up in containerized sandboxes, the next section
    is going to show us how to do just that: simulate responses from our dependencies
    on external APIs so that we can burrow deep into our code base to offer a full,
    no-holds-barred testing strategy.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Mocking external services with WireMock
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the context of integration testing, the ability to simulate external services
    is important because you cannot run all external devices in your integration test
    environment. Even if you can run them, the purpose of integration tests is to
    test the codes in the component. The external system’s problems are unrelated
    to the quality of the application’s code. WireMock offers a powerful solution
    for this challenge. By creating programmable HTTP servers that mimic the behavior
    of these external services, WireMock allows developers to produce reliable, consistent,
    and fast tests. Mocking external services ensures that tests are not only isolated
    from factors outside the application’s control but also that they can be run in
    any environment without the need for actual service connectivity.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'To effectively simulate the interaction with an OpenID Connect provider, WireMock
    can be configured to respond to authentication and token requests with predefined
    responses. We need this setup to test secured endpoints without needing to interact
    with the real authentication service. Here’s how to achieve this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '`AbstractIntegrationTest` class, set up a WireMock server to run on a specific
    port. This server acts as your mock OpenID Connect provider.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Stubbing the OpenID configuration**: Configure WireMock to serve responses
    for the OpenID Connect discovery document and other related endpoints. We need
    to stub the endpoint to return the provider metadata, which includes URLs for
    the authorization, token, user information, and **JSON Web Key Set** (**JWKS**)
    URIs. This ensures that when your application tries to discover the OpenID Connect
    provider’s configuration, it receives a consistent and controlled response from
    WireMock.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Mocking token and authorization responses**: Further configure WireMock to
    respond to token and authorization requests with mock responses. These responses
    should mimic the structure of real responses from an OpenID Connect provider,
    including access tokens, ID tokens, and refresh tokens as necessary.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please see the related abstract class in the GitHub repository to see how we
    need to mock the key-cloak server at [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/integrationtests/AbstractIntegrationTest.java](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/integrationtests/AbstractIntegrationTest.java).
    Whenever our application needs to communicate with key-cloak, our mock server
    respond to our application as we expected.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: By mocking the OpenID Connect provider in this manner, you can test your application’s
    authentication and authorization flow accurately and consistently, ensuring that
    your security mechanisms work as intended without relying on external systems.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Having established a controlled environment for both database interactions and
    external service dependencies, we’re now well prepared to start writing our integration
    tests in the next section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Writing integration tests for Author Controller
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before diving into the tests themselves, ensuring a clean page for each test
    run is crucial. The `@BeforeEach` method plays a vital role in this process, allowing
    us to reset our database to a known state before every test:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By invoking methods such as `authorRepository.deleteAll()`, we can clear all
    data, preventing cross-test contamination and ensuring each test operates independently.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Securing tests with @WithMockUser
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since our application has a security layer, we need to write our tests by considering
    this layer, even if we have a mocked third-party security dependency. Our application
    still checks the roles of the requests in the security filter. We have a very
    helpful annotation for this: the `@WithMockUser` annotation allows us to simulate
    requests from authenticated users with specific roles, ensuring that our tests
    accurately reflect the application’s security constraints. In this way, we can
    confirm our security configuration is working effectively.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Testing the endpoints
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we are ready to write our tests for each endpoint. We have up-and-running
    test databases and mocked third-party dependencies. Now, we just need to send
    requests and assert the responses to the `/authors` endpoints. This part is very
    similar to the controller unit tests but the difference is we will not mock the
    service – we will use the service itself. The tests will all run end to end. So,
    we will ensure our application is running as expected with its all components.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, we will write a test case for the `Get /``authors/{authorId}`
    endpoint:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we make a GET request to our application with a mock user with an admin
    role, and we prepare the database by inserting a sample `Author` object. We also
    expect to get a valid response from the application. As you can see, we didn’t
    mock the repository class or service class, therefore, when the application starts
    working, and we initiate a `GET` request, all related classes and methods are
    really working like a real application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of the test cases, you can check out our GitHub repository at [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/integrationtests/AuthorControllerIntegrationTest.java](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/integrationtests/AuthorControllerIntegrationTest.java).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: When we run our test class, it will test all the endpoints end to end. Integration
    testing bridges the gap between unit testing and end-to-end testing, focusing
    on the interactions between different parts of the application. It verifies that
    the application components work together as expected, identifying issues that
    might not be visible when testing components in isolation. Through the use of
    tools such as `Testcontainers` and WireMock, we’ve seen how to simulate real-world
    environments and dependencies, allowing for comprehensive and reliable testing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'In conclusion, we can see how important integration testing is in the software
    development cycle. It offers a comprehensive test of our application’s overall
    functionality. I always imagine these integration tests are like local development
    tests. When you change a code base, you can rely on integration tests to be sure
    your change doesn’t break any other flow. In the next section, we will deal with
    the asynchronous environment: reactive components.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Testing reactive components
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll delve into testing reactive components, focusing on the
    `UserController` endpoints in our sample reactive Spring Boot application. Testing
    reactive components is slightly different from traditional applications because
    reactive programming offers a non-blocking, event-driven approach to handling
    data streams and the propagation of change. We’ll use Spring WebFlux along with
    `WebTestClient` for testing reactive HTTP requests.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the testing environment
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we learned in [*Chapter 3*](B18400_03.xhtml#_idTextAnchor064), reactive programming
    in Spring, facilitated by Spring WebFlux, introduces an approach to a non-blocking,
    event-driven model that efficiently handles asynchronous data streams. That’s
    why we need a slightly different strategy to test these reactive components to
    ensure that the asynchronous and non-blocking behavior is accurately accounted
    for. The reactive testing environment must be capable of dealing with data flows
    and sequences over time, making it crucial to understand how to set up and utilize
    the right tools effectively.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use `WebTestClient` to test reactive components instead of `MockMVC`,
    as we used in non-reactive application tests. In the `UserControllerTest` class,
    configured with `@WebFluxTest(controllers = UserController.class)`, `WebTestClient`
    is autowired to enable direct interaction with the `UserController` endpoints.
    This annotation helps us to isolate our controller from the full configuration.
    It ensures that tests are lightweight and targeted, significantly speeding up
    the testing process:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`@WebFluxTest` also sets up `WebTestClient` for our test environment and it
    becomes ready to use for sending simulated HTTP requests and asserting the responses.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '`WebTestClient` helps to mock the behavior of requests and responses as they
    would occur in a live, reactive web environment. It also shows us again how Spring
    seamlessly supports the testing of reactive endpoints. After this theoretical
    information, we will delve into mocking the components in the next section.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Preparing mock components
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mocking plays a pivotal role in preventing actual database operations during
    tests, which is crucial for several reasons. Firstly, it ensures test isolation,
    allowing each test to run independently without the side effects of shared data.
    You already knew this from the previous chapter. So, we are directly diving into
    the code snippet:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With our dependencies mocked and test data freshly initialized before each test,
    we’re well equipped to dive into the core of our testing strategy, examining how
    each endpoint in `UserController` is tested. Next, we’ll start writing test cases,
    where we’ll break down the testing process for each operation, ensuring `UserController`
    behaves as expected under various conditions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Writing test cases
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we are ready to write our tests for each method. We have mocked our dependencies;
    we just need to write unit tests and see whether they return the expected results.
    The only difference between testing non-reactive components and this is that we
    will use `webTestClient` instead of `mockMVC`. Let’s start:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this code block, we have written a unit test to get all user endpoints. First,
    we have manipulated the `userRepositry.findAll()` method to return a Flux `testUser`
    object, and we expect a successful response.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: For the test methods for other endpoints, please see the GitHub repository at
    [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-reactive-test/src/test/java/com/packt/ahmeric/reactivesample/controller/UserControllerTest.java](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-reactive-test/src/test/java/com/packt/ahmeric/reactivesample/controller/UserControllerTest.java).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: A look back is in order as we end our hands-on to test reactive components in
    our Spring Boot applications. A transition to the programming of reactivity obliges
    the developer to change their way of crafting applications and communicating in
    essence – chiefly focusing on non-blocking, asynchronous, and scalable interaction
    under pressure. However, great responsibility follows great power, and the testing
    of code stands at the pinnacle of that principle. The principal test challenges
    that testing these very reactive components brings in are the guaranteed handling
    of data streams, assured non-blocking nature, and dealing with backpressure.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: With a myriad of approaches discussed in this section for testing a target,
    right from setting up the testing environment via `@WebFluxTest` to specifying
    dependencies and testing asynchronous results with `WebTestClient`, one is set
    up with the tools required to achieve quality, scalability, and maintainability
    in your reactive Spring Boot application. These then are ensuring strategies toward
    the guarantee that no matter what conditions are realized at runtime, the application
    behaves well and delivers the desired functionality and the desired performance.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The third good practice in testing is “reactive.” When applications become more
    complex and bigger in scale, the ability to effectively test these reactive components
    becomes a cornerstone of a successful development life cycle. In another light,
    developers who practice these testing methodologies can catch issues before they
    even rise to the level of annoyance and find a way to instill cultures of quality
    and resilience.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the way to test the reactive part is an accent of the dynamically
    changing web development landscape, which is always running into innovation in
    best development and best testing practices. With these insights and techniques
    from this exploration, go forth into future builds of more robust, responsible,
    and user-friendly applications.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we wrap up this comprehensive exploration into advanced testing strategies
    for both non-reactive and reactive Spring Boot applications, it’s clear that the
    journey has been both enlightening and empowering. We learned how testing is important
    for the development life cycle and how it is easy with Springboot capabilities.
    With practical examples and hands-on guidance, this chapter has equipped you with
    essential skills and insights that are critical in today’s fast-paced software
    development landscape. Here’s a summary of what we’ve covered:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '**Foundational principles of TDD**: We learned the foundational principles
    of TDD and its impact on software quality and reliability.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit testing controllers**: We explored techniques for unit testing controllers
    with a security layer, ensuring that our applications are not only functional
    but also secure.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Importance of integration testing**: We learned the importance of integration
    testing in validating the interaction between different parts of our applications,
    ensuring they work together seamlessly.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing reactive components**: We explored strategies for testing reactive
    components, addressing the unique challenges presented by the reactive programming
    paradigm.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These skills will make your applications tested, more reliable, scalable, and
    maintainable. Mastering these testing techniques in Spring Boot sets you apart
    as a developer.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Looking ahead, the journey through software development continues to evolve,
    bringing new challenges and opportunities. In the next chapter, we’ll dive into
    the world of containerization and orchestration. This upcoming chapter promises
    to unveil how Spring Boot applications can be made container ready, and how they
    can be orchestrated using Kubernetes for enhanced scalability and manageability.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 4: Deployment, Scalability, and Productivity'
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will shift our focus towards deploying and scaling applications
    effectively, alongside boosting productivity. [*Chapter 7*](B18400_07.xhtml#_idTextAnchor213)
    explores the latest Spring Boot 3.0 features, particularly those that enhance
    containerization and orchestration for smoother deployment processes. [*Chapter
    8*](B18400_08.xhtml#_idTextAnchor233) dives into building event-driven systems
    with Kafka, which are crucial for managing high-throughput data with scalability
    in mind. Lastly, [*Chapter 9*](B18400_09.xhtml#_idTextAnchor249) covers strategies
    to enhance productivity and simplify development, ensuring you can maintain a
    rapid and efficient workflow as your projects grow. This section is key to mastering
    the operational side of software development, preparing you to handle large-scale
    deployments with ease.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18400_07.xhtml#_idTextAnchor213), *Spring Boot 3.0 Features
    for Containerization and Orchestration*'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18400_08.xhtml#_idTextAnchor233), *Exploring Event-Driven Systems
    with Kafka*'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18400_09.xhtml#_idTextAnchor249), *Enhancing Productivity and
    Development Simplification*'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
