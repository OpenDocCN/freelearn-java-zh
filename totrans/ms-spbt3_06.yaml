- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Advanced Testing Strategies
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级测试策略
- en: 'This chapter will further guide our entry into the world of complex testing
    methods and will offer clear guides to ensure that our software is reliable and
    robust. It will cover a range of topics: from a consideration of the basics of
    **test-driven development** (**TDD**) to specifics such as unit testing web controllers
    with security considerations, integration of different parts of an application,
    and the unique challenges of testing in reactive environments. This should make
    you a better developer who can write tests that cover all code. These techniques
    provide a strong foundation for ensuring improvements in quality and that these
    improvements are applicable to diverse software architectures – from classical
    web applications to reactive systems of modern software architecture.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将进一步引导我们进入复杂测试方法的领域，并提供清晰的指南，以确保我们的软件可靠且健壮。它将涵盖一系列主题：从考虑**测试驱动开发**（**TDD**）的基本原理到具体内容，如考虑安全因素的单元测试网络控制器、应用程序不同部分的集成以及反应式环境测试的独特挑战。这将使你成为一个更好的开发者，能够编写覆盖所有代码的测试。这些技术为确保质量改进提供了坚实的基础，并且这些改进适用于各种软件架构
    – 从经典网络应用程序到现代软件架构的反应式系统。
- en: In other words, by learning these testing strategies, you work not only to catch
    bugs or prevent errors but to prepare for the modern demands of software development.
    This chapter outlines everything you need to create high-performing, scalable,
    and maintainable applications. As we go on through the chapter, you will understand
    when and how to apply those testing techniques confidently, regardless of the
    complexity of your application or its architecture. This chapter will prepare
    you with the information and tools necessary to go successfully through the constantly
    changing world of software management.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，通过学习这些测试策略，你不仅是为了捕捉错误或防止错误，而是为了应对现代软件开发的需求。本章概述了创建高性能、可扩展和可维护应用程序所需的一切。随着我们继续阅读本章，你将了解何时以及如何自信地应用这些测试技术，无论你的应用程序或其架构的复杂性如何。本章将为你提供必要的信息和工具，以成功地穿越不断变化的软件管理世界。
- en: 'In this chapter, we’ll cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: TDD in Spring Boot
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot中的TDD
- en: Unit testing of controllers with a security layer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有安全层的控制器单元测试
- en: Integration testing – bridging components together
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试 – 将组件连接起来
- en: Testing reactive components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试反应式组件
- en: Let’s begin this journey of learning how to make your Spring Boot applications
    secure and robust!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始这段学习之旅，了解如何使你的Spring Boot应用程序安全且健壮！
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, we are going to need some settings in our local machines:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们需要在我们的本地机器上设置一些配置：
- en: '**Java 17 Development Kit** (**JDK 17**)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 17 开发工具包**（**JDK 17**）'
- en: A modern **integrated development environment** (**IDE**) – I recommend IntelliJ
    IDEA
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个现代**集成开发环境**（**IDE**） – 我推荐IntelliJ IDEA
- en: '**GitHub repository**: You can clone all repositories related to [*Chapter
    6*](B18400_06.xhtml#_idTextAnchor192) from here: [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub仓库**：您可以从这里克隆与[*第6章*](B18400_06.xhtml#_idTextAnchor192)相关的所有仓库：[https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0)'
- en: Docker Desktop
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Desktop
- en: TDD in Spring Boot
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot中的TDD
- en: When I was first introduced to the concept of TDD, I admit I was quite skeptical.
    I felt the concept of writing unit tests before the code itself just seemed ridiculous,
    or, in other words, crazy. I was not different from others who felt it was just
    an added process to slow down an already jam-packed development life cycle. But
    now, having explored the use of TDD during application development with Spring
    Boot 3.0, I know that this is not the case.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次接触到TDD的概念时，我承认我相当怀疑。我觉得在编写代码之前先写单元测试的想法似乎很荒谬，或者说，疯狂。我和其他人一样，觉得这只是一个额外的过程，会减缓已经非常繁忙的开发周期。但现在，在探索了使用Spring
    Boot 3.0进行应用程序开发中的TDD之后，我知道情况并非如此。
- en: Spring Boot 3.0 was a very fantastic platform to go for TDD-based work. I’d
    just taken on a new project and started moving forward based on the concept of
    TDD. The process itself was awkward, to say the least. It’s like pre-judging the
    future through writing a code test for code that doesn’t even exist. However,
    I continued with it. The unit tests literally drove the writing of the code in
    a way that I’ve never seen before. Having a clear and defined purpose in every
    single test and the development of code that would meet it made each relevant
    approach to the development focused and considered.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 3.0是一个非常出色的平台，可以用于基于TDD的工作。我刚刚接手了一个新项目，并开始基于TDD的概念前进。这个过程本身至少是尴尬的。它就像通过为不存在的代码编写测试来预先判断未来。然而，我继续这样做。单元测试实际上以我以前从未见过的方式推动了代码的编写。每个测试都有一个明确和定义的目的，以及编写满足它的代码，这使得每个相关的发展方法都变得专注和经过深思熟虑。
- en: Its purpose was to catch early bugs and make the code base organized and maintainable.
    Writing tests in this manner becomes a cycle through **Red** (writing a failing
    test), **Green** (making the test pass), and **Refactor** (cleaning up the code).
    It bounces you along the project. The time spent upfront in writing tests gets
    paid off by a reduction in debugging and revising faulty code later.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 其目的是捕捉早期错误，并使代码库有组织且易于维护。以这种方式编写测试形成了一个通过**红**（编写失败的测试）、**绿**（使测试通过）和**重构**（清理代码）的循环。它推动着项目前进。在编写测试时投入的时间通过减少后续的调试和修正错误代码而得到回报。
- en: Now, let’s proceed practically to apply the theory in our Bookstore application.
    In this section, we will practice TDD, building a feature in our application.
    You will learn how to first write and then pass the tests according to the feature.
    All of this practical experience is intended to provide you with a solid foundation,
    rather than just theoretical knowledge, in application development with Spring
    Boot 3.0.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实际操作，将理论应用到我们的书店应用中。在本节中，我们将练习TDD，构建应用中的一个功能。你将学习如何首先编写测试，然后根据功能通过测试。所有这些实践经验旨在为你提供一个坚实的基础，而不仅仅是理论上的知识，在Spring
    Boot 3.0的应用开发中。
- en: This, of course, is meant to make you feel comfortable and confident when using
    TDD in your projects. Let’s get started!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然是为了让你在使用TDD时感到舒适和自信。让我们开始吧！
- en: Implementing TDD
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施TDD
- en: 'In this section, we will start a new TDD journey. As a part of this task, we
    have a new requirement for our Bookstore application: introducing an additional
    service layer between the controller and the repository for `Author` flows. The
    controller has two GET methods and one PUT, one POST, and one DELETE method. The
    requirements are to create a class called `AuthorService.java`, provide the methods
    the controller class needs, and throw an `EntityNotFound` exception when `Author`
    is not found in the database in the `DELETE` process. Let’s achieve this task
    by using the TDD approach:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开始一个新的TDD之旅。作为这项任务的一部分，我们对书店应用有一个新的需求：在控制器和`Author`流程的存储库之间引入一个额外的服务层。控制器有两个GET方法，一个PUT方法，一个POST方法和一个DELETE方法。要求是创建一个名为`AuthorService.java`的类，提供控制器类需要的方法，并在`DELETE`过程中在数据库中找不到`Author`时抛出`EntityNotFound`异常。让我们通过使用TDD方法来完成这个任务：
- en: '`AuthorServiceTest.java` under the `src/test/java` folder. First, we will write
    our first test for the potential `getAuthor` method. However, when we start writing
    the test method, we will see we don’t have a service class yet, and we will create
    an empty service class called `AuthorService.java`. But when we try to autocomplete
    the `getAuthor` method, we will see there is no method named like this. So, we
    will create a new method in the service class as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/test/java`文件夹下的`AuthorServiceTest.java`。首先，我们将为潜在的`getAuthor`方法编写第一个测试。然而，当我们开始编写测试方法时，我们会看到我们还没有服务类，我们将创建一个名为`AuthorService.java`的空服务类。但当我们尝试自动完成`getAuthor`方法时，我们会看到没有这样的方法。因此，我们将在服务类中创建一个新的方法，如下所示：
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, this method almost is empty. However, we know we will have
    a method called `getAuthor`, accept `Id` as a parameter, and return `Optional<Author>`.
    In all tests, we need to prepare the environment for this test such as creating
    the required data. So, we will inject the `authorRepository` class in both service
    and test classes. Now, we can write the first test case:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，这种方法几乎是空的。然而，我们知道我们将有一个名为`getAuthor`的方法，接受`Id`作为参数，并返回`Optional<Author>`。在所有测试中，我们需要为这个测试准备环境，例如创建所需的数据。因此，我们将`authorRepository`类注入到服务和测试类中。现在，我们可以编写第一个测试用例：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`when`: This helps us to manipulate the returned object of the mocked methods.
    In our sample, it mocks when `authorRepository.findById()` is called, and it will
    always return `savedAuthor`.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`when`：这有助于我们操作模拟方法的返回对象。在我们的示例中，它模拟了当调用 `authorRepository.findById()` 时，它将始终返回
    `savedAuthor`。'
- en: '`assertTrue`: This asserts the method returns true.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`assertTrue`：这个断言断言方法返回 true。'
- en: '`assertEquals`: This asserts that the provided two values are equal.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`assertEquals`：这个断言断言提供的两个值是相等的。'
- en: When we run the `givenExistingAuthorId_whenGetAuthor_thenReturnAuthor` method,
    the test will fail because our method is always returning `Optional.empty()`.
    So, we have a failing test on our hands; let’s go and fix it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `givenExistingAuthorId_whenGetAuthor_thenReturnAuthor` 方法时，测试将失败，因为我们的方法始终返回
    `Optional.empty()`。所以，我们手头有一个失败的测试；让我们去修复它。
- en: '**Green (making the test pass)**: In order to pass this test, we need to use
    the repository class in our method:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**绿色（使测试通过）**：为了通过这个测试，我们需要在我们的方法中使用仓库类：'
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, it is done. When we run the tests again, we will see it will pass.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，它已经完成了。当我们再次运行测试时，我们会看到它会通过。
- en: '**Refactor (cleaning up the code)**: In this step, we need to check both the
    test and source classes and see whether they need refactoring. In our case, in
    the source class, we don’t need any refactoring, but on the test side, we may
    tidy up a little bit. We can remove the object creation from the test class and
    make the test case more readable. Also, we can reuse that object in other test
    classes in the future:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重构（清理代码）**：在这个步骤中，我们需要检查测试和源类，看看它们是否需要重构。在我们的例子中，在源类中我们不需要任何重构，但在测试方面，我们可能需要稍微整理一下。我们可以从测试类中移除对象创建，使测试用例更易于阅读。此外，我们可以在未来的其他测试类中重用该对象：'
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have introduced a `setup` method for setting the common variables to reduce
    code duplications in the test class.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们引入了一个 `setup` 方法来设置公共变量，以减少测试类中的代码重复。
- en: 'After introducing the `setup` method, our test method became clearer with fewer
    lines of code:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在引入 `setup` 方法之后，我们的测试方法变得更加清晰，代码行数更少：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have completed one iteration of TDD for the Author service. We need to do
    the same iterations for all methods until we have a mature `AuthorService` that
    can be used in the controller class.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经完成了对作者服务的 TDD 迭代。我们需要对所有方法进行相同的迭代，直到我们有一个成熟的 `AuthorService`，可以在控制器类中使用。
- en: At the end of these processes, we will have `AuthorServiceTest` as in the GitHub
    repository. However, we will also have some new terminology for unit tests, which
    we will discuss in the *Discussing terminology for unit* *tests* section.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这些过程结束时，我们将拥有 GitHub 仓库中的 `AuthorServiceTest`。然而，我们还将有一些新的单元测试术语，我们将在 *讨论单元测试术语*
    部分中进行讨论。
- en: 'We have left one final step: updating the `AuthorController` class to consume
    this new (`AuthorService`) service instead of the repository.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经留下了一步最后的工作：将 `AuthorController` 类更新为使用这个新的 (`AuthorService`) 服务，而不是使用仓库。
- en: We will need to inject the `AuthorService` class into the controller class and
    use the methods in `AuthorService` instead of the repository methods.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要将 `AuthorService` 类注入到控制器类中，并使用 `AuthorService` 中的方法，而不是使用仓库中的方法。
- en: 'You can see the updated `AuthorController` in the GitHub repository ([https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/main/java/com/packt/ahmeric/bookstore/controller/AuthorController.java](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/main/java/com/packt/ahmeric/bookstore/controller/AuthorController.java)).
    I would like to mention the `delete` method here:'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 仓库中看到更新的 `AuthorController`（[https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/main/java/com/packt/ahmeric/bookstore/controller/AuthorController.java](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/main/java/com/packt/ahmeric/bookstore/controller/AuthorController.java)）。我想在这里提到
    `delete` 方法：
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, we have replaced the methods and, in the `delete` function,
    we have added an exception handler to cover `EntityNotFoundException`.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们已经替换了方法，在 `delete` 函数中，我们添加了一个异常处理程序来覆盖 `EntityNotFoundException`。
- en: In this section, we have learned about the TDD and how to implement it in a
    real-world sample. This will take some time, and it requires some patience to
    make it a habit in the development cycle. However, once you have learned how to
    go with TDD, you will have fewer bugs and more maintainable code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了 TDD（测试驱动开发）以及如何在现实世界的示例中实现它。这需要一些时间，并且需要一些耐心，使其成为开发周期中的习惯。然而，一旦你学会了如何进行
    TDD，你将会有更少的错误和更易于维护的代码。
- en: Discussing terminology for unit tests
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论单元测试术语
- en: 'Let’s discuss some essential terminology in unit testing:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些单元测试中的基本术语：
- en: '`assertThrows()`: This is a method used in JUnit tests to assert that a specific
    type of exception is thrown during the execution of a piece of code. It is particularly
    useful when you want to test that your code properly handles error conditions.
    In our test class, you can see it as follows:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertThrows()`: 这是一个在JUnit测试中使用的用于断言在执行代码片段期间抛出特定类型的异常的方法。当您想测试您的代码是否正确处理错误条件时，它特别有用。在我们的测试类中，您可以看到如下：'
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This method takes two main parameters: the expected exception type and a functional
    interface (usually a lambda expression), which contains the code expected to throw
    the exception. If the specified exception is thrown, the test passes; otherwise,
    it fails.'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法接受两个主要参数：预期的异常类型和一个功能接口（通常是lambda表达式），其中包含预期抛出异常的代码。如果指定的异常被抛出，则测试通过；否则，测试失败。
- en: '`verify()`: Mockito is a library that we always use in unit testing. It has
    very useful methods that make our tests more reliable and readable. `verify()`
    is one of them; it is used to check that certain interactions with mock objects
    occur. It can verify that methods were called with specific parameters, a certain
    number of times, or even that they were never called. This is crucial for testing
    that your code interacts with dependencies as expected. In our test class, you
    can see it as follows:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verify()`: Mockito是我们始终在单元测试中使用的库。它有一些非常有用的方法，使我们的测试更加可靠和可读。`verify()`是其中之一；它用于检查与模拟对象发生的某些交互。它可以验证方法是否以特定的参数、特定次数调用，甚至从未被调用。这对于测试您的代码是否按预期与依赖项交互至关重要。在我们的测试类中，您可以看到如下：'
- en: '[PRE7]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`@InjectMocks`: The `@InjectMocks` annotation in Mockito is used to create
    instances of a class and inject mock fields into it. This is particularly useful
    when you have a class that depends on other components or services, and you want
    to test the class in isolation by using mock versions of its dependencies. The
    following code snippet shows a sample usage:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@InjectMocks`: Mockito中的`@InjectMocks`注解用于创建类的实例并将模拟字段注入其中。这在您有一个依赖于其他组件或服务的类时特别有用，您想通过使用其依赖项的模拟版本来单独测试该类。以下代码片段展示了示例用法：'
- en: '[PRE8]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`@ExtendWith(MockitoExtension.class)`: This annotation is used with JUnit 5
    to enable Mockito support in tests. By declaring `@ExtendWith(MockitoExtension.class)`
    at the class level, you allow Mockito to initialize mocks and inject them before
    tests are run. This makes it easier to write cleaner test code with less boilerplate.
    You can see it here in our test class:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ExtendWith(MockitoExtension.class)`: 此注解与JUnit 5一起使用，以在测试中启用Mockito支持。通过在类级别声明`@ExtendWith(MockitoExtension.class)`，您允许Mockito在测试运行之前初始化模拟并注入它们。这使得编写更干净的测试代码并减少样板代码变得更容易。您可以在我们的测试类中看到它：'
- en: '[PRE9]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`@BeforeEach`: In JUnit 5, the `@BeforeEach` annotation is used on a method
    to specify that it should be executed before each test method in the current test
    class. It’s commonly used for setup tasks that are common to all tests, ensuring
    each test starts with a fresh state. It is used with a method, as you can see
    in the following code:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@BeforeEach`: 在JUnit 5中，`@BeforeEach`注解用于方法上，指定它应该在当前测试类中的每个测试方法之前执行。它通常用于所有测试都通用的设置任务，确保每个测试从一个新鲜的状态开始。它与方法一起使用，正如您在以下代码中可以看到的：'
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we are now aware of the new terminology in the unit test, in the next section,
    we will use our unit test knowledge and improve it by learning how to test controller
    classes, especially the ones with a security layer.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了单元测试中的新术语，在下一节中，我们将利用我们的单元测试知识，通过学习如何测试控制器类，特别是带有安全层的控制器类来提高它。
- en: Unit testing of controllers with a security layer
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有安全层的控制器单元测试
- en: In this new section, we will deal with testing controller classes. Why do we
    have a different test approach for controller classes? The request and response
    can be represented as JSON objects, similar to a real Request and Response, not
    like the objects in our project. This will help us check that everything is OK
    to accept requests and also assert the JSON response if they match the requirements.
    We will discuss some new annotations and next, we will focus on how to implement
    these new annotations for `AuthorControllerTest` step by step.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新章节中，我们将处理测试控制器类。为什么我们为控制器类采用不同的测试方法？请求和响应可以表示为JSON对象，类似于真实的请求和响应，而不是我们项目中的对象。这将帮助我们检查是否一切正常以接受请求，并在它们符合要求时断言JSON响应。我们将讨论一些新的注解，接下来，我们将逐步关注如何为`AuthorControllerTest`实现这些新注解。
- en: Key annotations for Spring MVC controller testing
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring MVC控制器测试的关键注解
- en: 'Spring `@WebMvcTest`, `@Import`, `@WithMockUser`, and `@MockBean`, which are
    essential players in Spring MVC controller testing. These annotations help establish
    a testing framework that ensures our controllers perform as expected whether in
    isolation or when integrated with Spring’s web context and security components.
    Let’s take a look at them:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Spring的`@WebMvcTest`、`@Import`、`@WithMockUser`和`@MockBean`是Spring MVC控制器测试中的关键角色。这些注解帮助建立测试框架，确保我们的控制器无论在独立测试还是与Spring的Web上下文和安全组件集成时都能按预期执行。让我们来看看它们：
- en: '`@WebMvcTest(AuthorController.class)`: The `@WebMvcTest` annotation is used
    for unit testing Spring MVC applications in a more focused way. It is applied
    to test classes that need to test Spring MVC controllers. Using `@WebMvcTest`
    with a specific controller class, such as `AuthorController.class`, tells Spring
    Boot to only instantiate the given controller and its required dependencies, not
    the whole context. This makes the tests run faster and focus strictly on the MVC
    components. This annotation automatically configures the Spring MVC infrastructure
    for your tests.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@WebMvcTest(AuthorController.class)`：`@WebMvcTest`注解用于以更集中的方式对Spring MVC应用程序进行单元测试。它应用于需要测试Spring
    MVC控制器的测试类。使用`@WebMvcTest`与特定的控制器类，如`AuthorController.class`，告诉Spring Boot仅实例化给定的控制器及其所需依赖项，而不是整个上下文。这使得测试运行更快，并且严格关注MVC组件。此注解会自动为测试配置Spring
    MVC基础设施。'
- en: '`@Import(SecurityConfig.class)`: The `@Import` annotation allows you to import
    additional configuration classes into the Spring test context. When used in controller
    tests, particularly alongside `@WebMvcTest`, it’s often necessary to include specific
    configuration classes that aren’t automatically picked up by `@WebMvcTest`. By
    specifying `@Import(SecurityConfig.class)`, you’re explicitly telling Spring to
    load your `SecurityConfig` class. This class contains security configurations
    (such as authentication and authorization settings) that are necessary for your
    tests to run in an environment that closely mimics your application’s security
    setup.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Import(SecurityConfig.class)`：`@Import`注解允许您将额外的配置类导入Spring测试上下文。在控制器测试中，尤其是在与`@WebMvcTest`一起使用时，通常需要包含特定的配置类，这些配置类不是由`@WebMvcTest`自动获取的。通过指定`@Import(SecurityConfig.class)`，您明确告诉Spring加载您的`SecurityConfig`类。此类包含安全配置（如身份验证和授权设置），这对于测试在接近您应用程序安全设置的环境中运行是必要的。'
- en: '`@MockBean`: Spring application context uses beans such as Service and Repository,
    and in our test context, we need to mock these beans. `@MockBean` adds mock objects
    to the Spring application context, and these mocked objects are used instead of
    real Service and Repository objects. This is useful for injecting mock implementations
    for services, repositories, or any other components that your controller depends
    on, without actually loading those beans from the real application context.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@MockBean`：Spring应用程序上下文使用诸如Service和Repository之类的bean，在我们的测试上下文中，我们需要模拟这些bean。`@MockBean`将模拟对象添加到Spring应用程序上下文中，这些模拟对象将用于替代真实的Service和Repository对象。这对于注入模拟实现服务、存储库或控制器所依赖的任何其他组件非常有用，而无需从真实的应用程序上下文中实际加载这些bean。'
- en: '`@WithMockUser`: This annotation is used in Spring Security tests to simulate
    running a test with a mock authenticated user. This annotation allows you to specify
    details of the mock user, such as username, roles, and authorities, without the
    need to interact with the actual security environment or authentication mechanism.
    It’s particularly useful for controller tests where you want to test the behavior
    of your endpoints under different authentication or authorization scenarios. By
    using `@WithMockUser`, you can easily emulate different user contexts, testing
    how your application responds to various levels of access and ensuring that security
    constraints are correctly enforced. This makes it an essential tool for comprehensive
    testing of secured endpoints in a Spring Boot application.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@WithMockUser`：这个注解用于 Spring Security 测试，用于模拟使用模拟认证用户运行测试。此注解允许您指定模拟用户的具体细节，例如用户名、角色和权限，而无需与实际的安全环境或认证机制交互。它特别适用于控制器测试，您希望测试端点在不同认证或授权场景下的行为。通过使用
    `@WithMockUser`，您可以轻松模拟不同的用户上下文，测试应用程序如何响应不同的访问级别，并确保安全约束得到正确执行。这使得它成为全面测试 Spring
    Boot 应用程序中受保护端点的必备工具。'
- en: For controller tests, especially with a security layer, these annotations play
    crucial roles in ensuring that your tests are focused and fast and reflect your
    application’s actual running conditions as closely as possible. In the next section,
    we will get our hands dirty while implementing these into our test class.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于控制器测试，尤其是在有安全层的情况下，这些注解在确保您的测试专注且快速，尽可能反映应用程序的实际运行条件方面发挥着关键作用。在下一节中，我们将将这些注解实现到测试类中。
- en: Crafting controller tests with Spring annotations
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Spring 注解构建控制器测试
- en: When we start working on creating tests, for controllers, it’s important to
    make use of Springs annotations. These annotations, such as `@WebMvcTest`, `@Import`,
    `@WithMockUser`, and `@MockBean`, are crucial for establishing the testing environment
    that mirrors our application’s web layer and security setups. This section focuses
    on utilizing these annotations to develop targeted tests for our controllers.
    By incorporating these tools, our goal is to strike a balance between speed and
    accuracy in testing to ensure that our controllers operate effectively within
    the web environment. Let’s explore how we can practically apply these annotations
    to mimic real-world scenarios and verify the functionality of our Spring MVC controllers
    in certain situations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始为控制器创建测试时，使用 Spring 注解非常重要。这些注解，例如 `@WebMvcTest`、`@Import`、`@WithMockUser`
    和 `@MockBean`，对于建立与我们的应用程序的 Web 层和安全设置相匹配的测试环境至关重要。本节重点介绍如何利用这些注解来为我们的控制器开发有针对性的测试。通过整合这些工具，我们的目标是平衡测试的速度和准确性，以确保我们的控制器在
    Web 环境中有效运行。让我们探讨如何实际应用这些注解来模拟现实场景，并验证我们的 Spring MVC 控制器在某些情况下的功能。
- en: Creating a comprehensive test suite for `AuthorController` in a Spring Boot
    application involves several steps, from setting up the initial testing environment
    with specific annotations to writing detailed test cases for different user roles
    and operations. Here is a step-by-step guide to achieve the final state of `AuthorControllerTest.java`
    as described.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring Boot 应用程序中为 `AuthorController` 创建一个全面的测试套件涉及多个步骤，从使用特定注解设置初始测试环境到为不同的用户角色和操作编写详细的测试用例。以下是实现
    `AuthorControllerTest.java` 最终状态的逐步指南。
- en: Step 1 – setting up your test environment
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 1 步 - 设置您的测试环境
- en: 'To set up your environment, follow these steps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置您的环境，请按照以下步骤操作：
- en: Create a test class file named `AuthorControllerTest.java`. Annotate the class
    with `@WebMvcTest(AuthorController.class)` to focus on testing only `AuthorController`.
    This tells Spring Boot to configure only the MVC components necessary for the
    test, without the full application context.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `AuthorControllerTest.java` 的测试类文件。使用 `@WebMvcTest(AuthorController.class)`
    注解该类，以专注于测试 `AuthorController`。这告诉 Spring Boot 仅配置测试所需的 MVC 组件，而不使用完整的应用程序上下文。
- en: Use `@Import(SecurityConfig.class)` to include your custom security configuration
    in the test context. This is crucial for accurately simulating security behaviors
    during testing.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `@Import(SecurityConfig.class)` 将您的自定义安全配置包含在测试上下文中。这在测试期间准确模拟安全行为至关重要。
- en: 'Declare the required fields:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明所需的字段：
- en: '`ApplicationContext` to set up the `MockMvc` object'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplicationContext` 用于设置 `MockMvc` 对象'
- en: A `MockMvc` object for performing and asserting HTTP requests
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于执行和断言 HTTP 请求的 `MockMvc` 对象
- en: Mock beans for any services or components the controller depends on, such as
    `AuthorService` and `JwtDecoder`, using the `@``MockBean` annotation
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@MockBean` 注解模拟控制器所依赖的任何服务或组件，例如 `AuthorService` 和 `JwtDecoder`。
- en: An `ObjectMapper` for JSON serialization and deserialization in tests
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于测试中 JSON 序列化和反序列化的 `ObjectMapper`
- en: 'These are the code changes of this step:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这一步的代码更改：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we have set up our test class by mocking `AuthorService` and `JwtDecoder`.
    We will be able to manipulate them when needed in the next section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经通过模拟 `AuthorService` 和 `JwtDecoder` 来设置测试类。我们将在下一节中需要时能够操纵它们。
- en: Step 2 – initializing the testing framework
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2 步 – 初始化测试框架
- en: 'Implement a setup method annotated with `@BeforeEach` to initialize the `MockMvc`
    object before each test:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个带有 `@BeforeEach` 注解的设置方法，以便在每个测试之前初始化 `MockMvc` 对象：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This method uses the `MockMvcBuilders` utility to build the `MockMvc` object
    with the web application context and Spring Security integration.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用 `MockMvcBuilders` 工具构建带有 Web 应用程序上下文和 Spring Security 集成的 `MockMvc` 对象。
- en: Step 3 – writing test cases
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3 步 – 编写测试用例
- en: 'After setting up our test class, we can start to write our test cases step
    by step:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置我们的测试类之后，我们可以开始逐步编写我们的测试用例：
- en: Write parameterized test cases for adding and getting authors with different
    roles. Use `@ParameterizedTest` and `@MethodSource` to supply the roles and expected
    HTTP statuses. In these tests, you’ll simulate requests with different user roles
    and assert the expected outcomes.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写针对添加和获取不同角色作者的参数化测试用例。使用 `@ParameterizedTest` 和 `@MethodSource` 来提供角色和预期的
    HTTP 状态。在这些测试中，您将模拟具有不同用户角色的请求并断言预期的结果。
- en: For adding authors, mock the `AuthorService` response and perform a POST request,
    asserting the status based on the role.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于添加作者，模拟 `AuthorService` 的响应并执行 POST 请求，根据角色断言状态。
- en: For getting an author by ID, mock the `AuthorService` response and perform a
    GET request, asserting both the status and the content based on the role.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于通过 ID 获取作者，模拟 `AuthorService` 的响应并执行 GET 请求，根据角色断言状态和内容。
- en: 'Write tests for fetching all authors, updating an author, and deleting an author.
    Utilize `@Test` and `@WithMockUser` to specify the user details inline. These
    tests will do the following:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写获取所有作者、更新作者和删除作者的测试用例。利用 `@Test` 和 `@WithMockUser` 注解指定用户详细信息。这些测试将执行以下操作：
- en: Mock service layer responses
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟服务层响应
- en: Perform the relevant HTTP request (GET for all authors, PUT for updating, DELETE
    for deleting)
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行相关的 HTTP 请求（GET 用于获取所有作者，PUT 用于更新，DELETE 用于删除）
- en: Assert the expected outcomes, including status codes and, when applicable, response
    body content
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言预期的结果，包括状态码和，当适用时，响应体内容
- en: You can see how these steps are implemented in the controller test class. You
    can see five test methods in the GitHub repository, which validates the test cases,
    as we mentioned in this section, at [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/com/packt/ahmeric/bookstore/controller/AuthorControllerTest.java](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/com/packt/ahmeric/bookstore/controller/AuthorControllerTest.java).
    We will discuss how we can test exception handling in the next section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在控制器测试类中看到这些步骤是如何实现的。您可以在 GitHub 仓库中看到五个测试方法，这些方法验证了本节中提到的测试用例，链接为 [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/com/packt/ahmeric/bookstore/controller/AuthorControllerTest.java](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/com/packt/ahmeric/bookstore/controller/AuthorControllerTest.java)。我们将在下一节讨论如何测试异常处理。
- en: Step 4 – handling exceptional cases
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 4 步 – 处理异常情况
- en: 'Write a test case for handling a scenario where an author to be deleted is
    not found. Mock the service to throw `EntityNotFoundException` when attempting
    to delete a non-existent author, and assert that the controller correctly responds
    with a `404` status:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个处理要删除的作者未找到场景的测试用例。模拟服务在尝试删除不存在的作者时抛出 `EntityNotFoundException`，并断言控制器正确地响应了
    `404` 状态：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this test method, we are manipulating our `authorService.deleteAuthor` method
    to throw an exception by using the `doThrow()` method, and we are expecting a
    `not found` status as a response.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试方法中，我们通过使用 `doThrow()` 方法操纵 `authorService.deleteAuthor` 方法来抛出异常，并期望得到一个“未找到”的状态响应。
- en: Step 5 – running the tests
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 5 步 – 运行测试
- en: Run your tests to verify that all pass and that your controller behaves as expected
    across various scenarios and user roles.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的测试以验证所有测试都通过，并且你的控制器在各种场景和用户角色下表现如预期。
- en: This comprehensive testing approach not only validates the functional aspects
    of `AuthorController` but also ensures that security constraints are respected,
    providing confidence in both the application’s behavior and its security posture.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种全面的测试方法不仅验证了`AuthorController`的功能方面，还确保了安全约束得到尊重，从而在应用程序的行为和安全性方面提供了信心。
- en: In this section, we learned how to write controller tests by using Spring MVC
    controllers with security configurations. We have written the tests for both assertions,
    functionality, and security. By these tests, we are sure our controllers and the
    security filters are working as expected.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用具有安全配置的Spring MVC控制器编写控制器测试。我们已经为断言、功能和安全编写了测试。通过这些测试，我们确信我们的控制器和安全过滤器按预期工作。
- en: After completing our journey in the unit test, we will focus on the integration
    test in the next section. We will explore how to test the integration/interaction
    between various components of our project, including databases, web services,
    and external APIs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成单元测试之旅后，我们将在下一节中关注集成测试。我们将探讨如何测试我们项目中的不同组件之间的集成/交互，包括数据库、网络服务和外部API。
- en: Integration testing – bridging components together
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试 – 将组件连接起来
- en: 'Once you understand the concepts of unit testing, especially when dealing with
    tricky security layers, you can expand your vision to integration testing. While
    writing unit tests, you can think of quality checks on bricks that are carried
    out to ensure that a wall built with those bricks will keep you and your family
    safe from rain, snow, and everything else. Integration testing assesses how well
    different pieces of our application work. This is where the complete application
    tests are run at full length: the module interaction, databases, web services,
    and interaction with all the other external systems required are cross-examined
    to affirm that it is all smooth.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了单元测试的概念，尤其是在处理棘手的网络安全层时，你可以将你的视野扩展到集成测试。在编写单元测试时，你可以将质量检查想象成对砖块进行的检查，以确保用这些砖块建造的墙能让你和家人免受雨、雪以及其他一切天气的影响。集成测试评估我们应用程序的不同部分如何协同工作。这就是完整的应用程序测试在全面运行的地方：模块交互、数据库、网络服务和与其他所有外部系统的交互都会被交叉检验，以确保一切顺利。
- en: Why integration tests? Are unit tests not enough to prove our application is
    robust? The quick answer is no. In unit tests, we are just proving the methods
    are working as expected, but in real life, the methods are not working on their
    own. They interact with other components. So, integration tests are crucial to
    see whether any component has been affected by your change.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要集成测试？单元测试不足以证明我们的应用程序是健壮的吗？简短的答案是：不。在单元测试中，我们只是在证明方法按预期工作，但在现实生活中，这些方法并不是独立工作的。它们与其他组件交互。因此，集成测试对于查看任何组件是否受到你的更改的影响是至关重要的。
- en: So, fasten your seatbelts, because we are now going to take a ride. Just to
    be sure, a big integrated system will stand by all the requirements and possible
    scenarios – this, in fact, leaves your application far better prepared for the
    real world and the ultimate test of meeting user needs against expectations. We
    guide you with clear, practical examples to finally give you concise integration
    tests, ensuring peace of mind that your high-quality software product can finally
    be delivered.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，系好安全带，因为我们现在要开始一段旅程。为了确保万无一失，一个大型集成系统将满足所有要求和可能的场景——这实际上让你的应用程序为现实世界和满足用户需求的最终测试做好了更好的准备。我们将通过清晰、实用的示例引导你，最终提供简洁的集成测试，确保你的高质量软件产品最终能够交付。
- en: Setting up the testing environment
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置测试环境
- en: The main purpose of integration testing is to identify and solve problems attached
    to the interaction amid different parts of the application. This may comprise
    designed interactions between several service layers, databases, or external APIs,
    all together aimed at having them purposefully work together in the same way functions
    are supposed to take place. Unlike unit testing, integration testing ensures that
    isolated functionality is correct since it studies how the system behaves. Overall,
    the application itself should be tested from the interface level part, to ensure
    that the quality and functionality are full, avoiding interface lack in the defects,
    performance bottlenecks, and other integration issues left from unit testing.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试的主要目的是识别和解决与应用程序不同部分之间交互相关的问题。这可能包括几个服务层、数据库或外部API之间的设计交互，所有这些共同的目标是让它们有目的地以相同的方式协同工作，就像函数应该执行一样。与单元测试不同，集成测试确保隔离的功能是正确的，因为它研究系统的行为。总的来说，应该从接口级别部分测试应用程序本身，以确保质量和功能完整，避免在缺陷、性能瓶颈和其他集成问题中留下接口缺失，这些问题可能来自单元测试。
- en: 'In our integration testing strategy for the Author Controller endpoints, we
    utilize these two primary classes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对作者控制器端点的集成测试策略中，我们利用这两个主要类：
- en: '`AbstractIntegrationTest`: This class serves as the foundation for our integration
    tests, providing common configuration and setup routines that are shared across
    multiple test classes. It is an abstract class that does not directly run tests;
    instead, it sets up the testing environment. This includes configuring test containers
    for databases, initializing WireMock for mocking external services, and setting
    up Spring’s application context with the necessary profiles and configurations
    for integration testing. WireMock is a library that we use for mocking services
    such as REST and **Simple Object Access Protocol** (**SOAP**) services. By this
    mocking power, we can isolate our component from external connections and the
    potential faults of these services. We can use this abstract class for all integration
    tests since they will also need the same setup. The usage of an abstract base
    class helps us maintain a clean and **Don’t Repeat Yourself** (**DRY**) testing
    code base.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractIntegrationTest`：这个类作为我们集成测试的基础，提供跨多个测试类共享的常见配置和设置例程。它是一个抽象类，不直接运行测试；相反，它设置测试环境。这包括为数据库配置测试容器，初始化WireMock以模拟外部服务，以及设置Spring的应用程序上下文，包括集成测试所需的必要配置文件和配置。WireMock是我们用于模拟REST和**简单对象访问协议**（**SOAP**）服务等的库。通过这种模拟能力，我们可以隔离我们的组件，避免与外部连接以及这些服务的潜在故障。由于所有集成测试也需要相同的设置，我们可以使用这个抽象类。使用抽象基类有助于我们维护一个干净且**不要重复自己**（**DRY**）的测试代码库。'
- en: '`AuthorControllerIntegrationTest`: Extending from `AbstractIntegrationTest`,
    this class focuses specifically on testing the Author Controller endpoints. It
    inherits the common testing environment setup from `AbstractIntegrationTest` and
    adds tests that cover the functionality of the Author Controller, such as creating,
    reading, updating, and deleting authors. The `AuthorControllerIntegrationTest`
    class utilizes Spring’s MockMvc to simulate HTTP requests and assert the responses,
    ensuring that the Author Controller behaves as expected when integrated with other
    application components such as the security layer and the database.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthorControllerIntegrationTest`：从`AbstractIntegrationTest`扩展而来，这个类专门用于测试作者控制器端点。它从`AbstractIntegrationTest`继承了常见的测试环境设置，并添加了覆盖作者控制器功能的测试，例如创建、读取、更新和删除作者。`AuthorControllerIntegrationTest`类利用Spring的MockMvc来模拟HTTP请求并断言响应，确保当与其他应用程序组件（如安全层和数据库）集成时，作者控制器表现如预期。'
- en: By structuring our integration tests this way, we achieve a layered testing
    approach that allows us to isolate the testing of specific components (such as
    the Author Controller) while still leveraging a common setup for aspects shared
    across tests. This organization makes our tests more efficient and easier to maintain
    and ensures that we comprehensively test the interactions and integrations crucial
    for the application’s overall performance and reliability.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以这种方式构建我们的集成测试，我们实现了一种分层测试方法，使我们能够在仍然利用测试之间共享的公共设置的同时，隔离特定组件（如作者控制器）的测试。这种组织结构使我们的测试更加高效，更容易维护，并确保我们全面测试对应用程序整体性能和可靠性至关重要的交互和集成。
- en: Configuring application properties for integration testing
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置集成测试的应用程序属性
- en: In integration tests, our application will need to run as it would in a real
    environment. So, it is crucial to set up the application properties file. However,
    we also need to isolate the integration test environment from other test environments.
    That’s why we are initiating a new `application-integration-test.properties`.
    By this segregation, we ensure that the configuration in the integration test
    environment is just for that environment and it won’t affect the other test and
    development environments.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成测试中，我们的应用程序将需要以它在真实环境中的方式运行。因此，设置应用程序属性文件至关重要。然而，我们还需要将集成测试环境与其他测试环境隔离开来。这就是我们启动一个新的`application-integration-test.properties`文件的原因。通过这种隔离，我们确保集成测试环境中的配置仅针对该环境，并且不会影响其他测试和开发环境。
- en: 'We are adding the same properties as we are using in the current source code.
    This is because the following parameters will be needed by our application when
    it is running in the integration test profile:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在添加与当前源代码中使用的相同的属性。这是因为以下参数将在我们的应用程序以集成测试配置运行时被需要：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By configuring these properties, we create a controlled, predictable, and isolated
    environment that allows us to test our application’s integration points thoroughly
    and accurately. This setup is crucial for evaluating the application’s behavior
    in a simulated production environment, ensuring that all components work harmoniously
    together.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过配置这些属性，我们创建了一个受控、可预测和隔离的环境，使我们能够彻底和准确地测试应用程序的集成点。这种设置对于评估应用程序在模拟生产环境中的行为至关重要，确保所有组件协同工作。
- en: Next, we’ll dive into the practical application of these configurations, where
    we set the stage for robust, environment-true testing.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入了解这些配置的实际应用，为稳健、真实环境测试做好准备。
- en: Initializing the database with Testcontainers
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Testcontainers初始化数据库
- en: '`Testcontainers` is a Java library designed for JUnit and systems testing.
    It usually provides a lightweight, throw-away instance manner on the run of shared
    databases and Selenium web browsers or anything that can run inside a Docker container.
    Under the hood, `Testcontainers` uses Docker to help with the full setup and,
    especially, tear-down of actual database instances, which are isolated, ephemeral,
    and fully in one’s control. With the help of tools such as `Testcontainers`, one
    can accurately test the database interaction and persistence necessary for business
    needs without much overhead, the complexity of database installations, or setups
    of some sort of shared test instances.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Testcontainers`是一个为JUnit和系统测试设计的Java库。它通常在运行时提供轻量级、可丢弃的实例方式，用于共享数据库和Selenium网络浏览器或任何可以在Docker容器内运行的东西。在底层，`Testcontainers`使用Docker来帮助完成实际的数据库实例的设置和，特别是，拆卸，这些实例是隔离的、短暂的，并且完全受控。借助像`Testcontainers`这样的工具，可以在不增加太多开销的情况下，准确测试满足业务需求的数据库交互和持久性，无需数据库安装的复杂性或某些共享测试实例的设置。'
- en: 'We will now configure PostgreSQL and MongoDB containers by initializing `Testcontainers`
    for PostgreSQL and MongoDB databases in the `AbstractIntegrationTest` class. Here’s
    how it’s done:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将通过在`AbstractIntegrationTest`类中初始化PostgreSQL和MongoDB数据库的`Testcontainers`来配置PostgreSQL和MongoDB容器。以下是操作方法：
- en: '`Testcontainers` library. This method specifies the Docker image to use (`postgres:latest`),
    as well as database-specific configurations such as the database name, username,
    and password. Once initialized, the container is started, and the **Java Database
    Connectivity** (**JDBC**) URL, username, and password are dynamically injected
    into the Spring application context. This allows the integration tests to interact
    with a real PostgreSQL database instance that’s identical to what would be used
    in production.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Testcontainers`库。此方法指定要使用的Docker镜像（`postgres:latest`），以及数据库特定的配置，如数据库名称、用户名和密码。一旦初始化，容器就会被启动，并且**Java数据库连接**（**JDBC**）URL、用户名和密码将被动态注入到Spring应用程序上下文中。这允许集成测试与一个真实的PostgreSQL数据库实例交互，该实例与生产中使用的实例相同。
- en: '`Testcontainers` library by specifying the Docker image (`mongo:4.4.6`). Upon
    starting the MongoDB container, the connection URI is injected into the Spring
    application context, enabling tests to communicate with a real MongoDB instance.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指定Docker镜像（`mongo:4.4.6`）使用`Testcontainers`库。在启动MongoDB容器时，连接URI被注入到Spring应用程序上下文中，使测试能够与真实的MongoDB实例通信。
- en: 'To initialize the database, follow these steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化数据库，请按照以下步骤操作：
- en: 'First off, we will define the required parameters such as database image versions
    and the database name:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将定义所需的参数，例如数据库镜像版本和数据库名称：
- en: '[PRE15]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will use these parameters when we are initiating our test database containers:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们初始化我们的测试数据库容器时，我们将使用这些参数：
- en: '[PRE16]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this code block, first, we define the container and call the container initialize
    function in it. The container initialize function consumes the parameters defined
    in the previous code block in *Step 1*.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此代码块中，首先，我们定义容器并在其中调用容器初始化函数。容器初始化函数消耗在前面代码块中定义的*步骤1*中的参数。
- en: 'We will need some dynamic properties, which will be defined after containers
    are triggered. By using the following code, we can let the application know which
    data source URL will be used for connecting to the database:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一些动态属性，这些属性将在容器被触发后定义。通过以下代码，我们可以让应用程序知道将使用哪个数据源URL来连接到数据库：
- en: '[PRE17]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Each container is automatically run up, prepared, and torn down before and after
    tests, ensuring that every test suite runs against a clean, isolated database
    environment. This automated process elevates the reliability and repeatability
    of integration tests and simplifies the setup and troubleshooting of database
    interactions.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个容器在测试前后都会自动启动、准备和拆除，确保每个测试套件都在一个干净、隔离的数据库环境中运行。这个自动化过程提高了集成测试的可靠性和可重复性，并简化了数据库交互的设置和故障排除。
- en: 'With the databases ready and set up in containerized sandboxes, the next section
    is going to show us how to do just that: simulate responses from our dependencies
    on external APIs so that we can burrow deep into our code base to offer a full,
    no-holds-barred testing strategy.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库已经准备好并在容器化的沙盒中设置好之后，下一节将展示如何做到这一点：模拟外部API的响应，以便我们可以深入到我们的代码库中，提供一个全面、无保留的测试策略。
- en: Mocking external services with WireMock
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用WireMock模拟外部服务
- en: In the context of integration testing, the ability to simulate external services
    is important because you cannot run all external devices in your integration test
    environment. Even if you can run them, the purpose of integration tests is to
    test the codes in the component. The external system’s problems are unrelated
    to the quality of the application’s code. WireMock offers a powerful solution
    for this challenge. By creating programmable HTTP servers that mimic the behavior
    of these external services, WireMock allows developers to produce reliable, consistent,
    and fast tests. Mocking external services ensures that tests are not only isolated
    from factors outside the application’s control but also that they can be run in
    any environment without the need for actual service connectivity.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成测试的上下文中，模拟外部服务的能力很重要，因为你不能在集成测试环境中运行所有外部设备。即使你可以运行它们，集成测试的目的也是测试组件中的代码。外部系统的问题与应用程序代码的质量无关。WireMock为这个挑战提供了一个强大的解决方案。通过创建模拟这些外部服务行为的可编程HTTP服务器，WireMock允许开发者生成可靠、一致和快速的测试。模拟外部服务确保测试不仅从应用程序控制之外的因素中隔离出来，而且可以在任何环境中运行，无需实际服务连接。
- en: 'To effectively simulate the interaction with an OpenID Connect provider, WireMock
    can be configured to respond to authentication and token requests with predefined
    responses. We need this setup to test secured endpoints without needing to interact
    with the real authentication service. Here’s how to achieve this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地模拟与OpenID Connect提供者的交互，WireMock可以被配置为以预定义的响应来响应身份验证和令牌请求。我们需要这个设置来测试受保护的端点，而无需与真实的身份验证服务交互。以下是实现此目的的方法：
- en: '`AbstractIntegrationTest` class, set up a WireMock server to run on a specific
    port. This server acts as your mock OpenID Connect provider.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AbstractIntegrationTest`类中，设置一个WireMock服务器在特定端口上运行。这个服务器充当你的模拟OpenID Connect提供者。
- en: '**Stubbing the OpenID configuration**: Configure WireMock to serve responses
    for the OpenID Connect discovery document and other related endpoints. We need
    to stub the endpoint to return the provider metadata, which includes URLs for
    the authorization, token, user information, and **JSON Web Key Set** (**JWKS**)
    URIs. This ensures that when your application tries to discover the OpenID Connect
    provider’s configuration, it receives a consistent and controlled response from
    WireMock.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模拟OpenID配置**：配置WireMock为OpenID Connect发现文档和其他相关端点提供服务。我们需要模拟端点以返回提供者元数据，包括授权、令牌、用户信息和**JSON
    Web Key Set**（**JWKS**）URI的URL。这确保了当你的应用程序尝试发现OpenID Connect提供者的配置时，它会从WireMock接收到一致和受控的响应。'
- en: '**Mocking token and authorization responses**: Further configure WireMock to
    respond to token and authorization requests with mock responses. These responses
    should mimic the structure of real responses from an OpenID Connect provider,
    including access tokens, ID tokens, and refresh tokens as necessary.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模拟令牌和授权响应**：进一步配置WireMock以模拟响应令牌和授权请求。这些响应应模仿来自OpenID Connect提供者的真实响应结构，包括必要的访问令牌、ID令牌和刷新令牌。'
- en: Please see the related abstract class in the GitHub repository to see how we
    need to mock the key-cloak server at [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/integrationtests/AbstractIntegrationTest.java](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/integrationtests/AbstractIntegrationTest.java).
    Whenever our application needs to communicate with key-cloak, our mock server
    respond to our application as we expected.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅GitHub仓库中的相关抽象类，了解我们如何在[https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/integrationtests/AbstractIntegrationTest.java](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/integrationtests/AbstractIntegrationTest.java)中模拟key-cloak服务器。每当我们的应用程序需要与key-cloak通信时，我们的模拟服务器将按预期响应我们的应用程序。
- en: By mocking the OpenID Connect provider in this manner, you can test your application’s
    authentication and authorization flow accurately and consistently, ensuring that
    your security mechanisms work as intended without relying on external systems.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式模拟OpenID Connect提供者，您可以准确且一致地测试您的应用程序的认证和授权流程，确保您的安全机制按预期工作，而不依赖于外部系统。
- en: Having established a controlled environment for both database interactions and
    external service dependencies, we’re now well prepared to start writing our integration
    tests in the next section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在为数据库交互和外部服务依赖项建立了受控环境之后，我们现在已准备好在下一节开始编写集成测试。
- en: Writing integration tests for Author Controller
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为作者控制器编写集成测试
- en: 'Before diving into the tests themselves, ensuring a clean page for each test
    run is crucial. The `@BeforeEach` method plays a vital role in this process, allowing
    us to reset our database to a known state before every test:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入测试本身之前，确保每个测试运行都有一个干净的页面至关重要。`@BeforeEach`方法在这个过程中起着至关重要的作用，它允许我们在每次测试之前将我们的数据库重置到已知状态：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By invoking methods such as `authorRepository.deleteAll()`, we can clear all
    data, preventing cross-test contamination and ensuring each test operates independently.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用如`authorRepository.deleteAll()`这样的方法，我们可以清除所有数据，防止跨测试污染并确保每个测试独立运行。
- en: Securing tests with @WithMockUser
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用@WithMockUser保护测试
- en: 'Since our application has a security layer, we need to write our tests by considering
    this layer, even if we have a mocked third-party security dependency. Our application
    still checks the roles of the requests in the security filter. We have a very
    helpful annotation for this: the `@WithMockUser` annotation allows us to simulate
    requests from authenticated users with specific roles, ensuring that our tests
    accurately reflect the application’s security constraints. In this way, we can
    confirm our security configuration is working effectively.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序有一个安全层，我们需要考虑这个层来编写我们的测试，即使我们有模拟的第三方安全依赖项。我们的应用程序仍然检查安全过滤器中的请求角色。我们有一个非常有用的注解：`@WithMockUser`注解允许我们模拟具有特定角色的认证用户请求，确保我们的测试准确反映了应用程序的安全约束。这样，我们可以确认我们的安全配置正在有效工作。
- en: Testing the endpoints
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试端点
- en: Now, we are ready to write our tests for each endpoint. We have up-and-running
    test databases and mocked third-party dependencies. Now, we just need to send
    requests and assert the responses to the `/authors` endpoints. This part is very
    similar to the controller unit tests but the difference is we will not mock the
    service – we will use the service itself. The tests will all run end to end. So,
    we will ensure our application is running as expected with its all components.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已准备好为每个端点编写测试。我们拥有运行中的测试数据库和模拟的第三方依赖项。现在，我们只需向`/authors`端点发送请求并断言响应。这部分与控制器单元测试非常相似，但不同之处在于我们不会模拟服务——我们将使用服务本身。所有测试都将从头到尾运行。因此，我们将确保我们的应用程序及其所有组件按预期运行。
- en: 'In the following code block, we will write a test case for the `Get /``authors/{authorId}`
    endpoint:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们将为`Get /authors/{authorId}`端点编写一个测试用例：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we make a GET request to our application with a mock user with an admin
    role, and we prepare the database by inserting a sample `Author` object. We also
    expect to get a valid response from the application. As you can see, we didn’t
    mock the repository class or service class, therefore, when the application starts
    working, and we initiate a `GET` request, all related classes and methods are
    really working like a real application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向应用程序发送一个带有管理员角色的模拟用户GET请求，并通过插入一个样本`Author`对象来准备数据库。我们还期望从应用程序获得有效的响应。正如你所看到的，我们没有模拟仓库类或服务类，因此当应用程序开始工作时，我们发起一个`GET`请求，所有相关的类和方法都真的像真实应用程序一样工作。
- en: For the rest of the test cases, you can check out our GitHub repository at [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/integrationtests/AuthorControllerIntegrationTest.java](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/integrationtests/AuthorControllerIntegrationTest.java).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其余的测试用例，你可以在我们的GitHub仓库[https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/integrationtests/AuthorControllerIntegrationTest.java](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-unit-integration-test/src/test/java/integrationtests/AuthorControllerIntegrationTest.java)中查看。
- en: When we run our test class, it will test all the endpoints end to end. Integration
    testing bridges the gap between unit testing and end-to-end testing, focusing
    on the interactions between different parts of the application. It verifies that
    the application components work together as expected, identifying issues that
    might not be visible when testing components in isolation. Through the use of
    tools such as `Testcontainers` and WireMock, we’ve seen how to simulate real-world
    environments and dependencies, allowing for comprehensive and reliable testing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行我们的测试类时，它将测试所有端点的端到端。集成测试在单元测试和端到端测试之间架起了一座桥梁，专注于应用程序不同部分之间的交互。它验证了应用程序组件按预期协同工作，并识别出在单独测试组件时可能看不到的问题。通过使用`Testcontainers`和WireMock等工具，我们已经看到了如何模拟真实世界的环境和依赖关系，从而实现全面和可靠的测试。
- en: 'In conclusion, we can see how important integration testing is in the software
    development cycle. It offers a comprehensive test of our application’s overall
    functionality. I always imagine these integration tests are like local development
    tests. When you change a code base, you can rely on integration tests to be sure
    your change doesn’t break any other flow. In the next section, we will deal with
    the asynchronous environment: reactive components.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们可以看到在软件开发周期中集成测试是多么重要。它为我们应用程序的整体功能提供了一个全面的测试。我总是想象这些集成测试就像本地开发测试一样。当你更改代码库时，你可以依赖集成测试来确保你的更改不会破坏其他流程。在下一节中，我们将处理异步环境：响应式组件。
- en: Testing reactive components
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试响应式组件
- en: In this section, we’ll delve into testing reactive components, focusing on the
    `UserController` endpoints in our sample reactive Spring Boot application. Testing
    reactive components is slightly different from traditional applications because
    reactive programming offers a non-blocking, event-driven approach to handling
    data streams and the propagation of change. We’ll use Spring WebFlux along with
    `WebTestClient` for testing reactive HTTP requests.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入研究测试响应式组件，重点关注我们示例响应式Spring Boot应用程序中的`UserController`端点。测试响应式组件与传统应用程序略有不同，因为响应式编程提供了一种非阻塞、事件驱动的处理数据流和变化传播的方法。我们将使用Spring
    WebFlux和`WebTestClient`来测试响应式HTTP请求。
- en: Setting up the testing environment
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置测试环境
- en: As we learned in [*Chapter 3*](B18400_03.xhtml#_idTextAnchor064), reactive programming
    in Spring, facilitated by Spring WebFlux, introduces an approach to a non-blocking,
    event-driven model that efficiently handles asynchronous data streams. That’s
    why we need a slightly different strategy to test these reactive components to
    ensure that the asynchronous and non-blocking behavior is accurately accounted
    for. The reactive testing environment must be capable of dealing with data flows
    and sequences over time, making it crucial to understand how to set up and utilize
    the right tools effectively.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第3章*](B18400_03.xhtml#_idTextAnchor064)中学到的，Spring中的响应式编程，由Spring WebFlux提供支持，引入了一种非阻塞、事件驱动的模型，该模型能够有效地处理异步数据流。这就是为什么我们需要一个稍微不同的策略来测试这些响应式组件，以确保异步和非阻塞行为被准确考虑。响应式测试环境必须能够处理随时间变化的数据流和序列，因此理解如何有效地设置和使用正确的工具至关重要。
- en: 'We will use `WebTestClient` to test reactive components instead of `MockMVC`,
    as we used in non-reactive application tests. In the `UserControllerTest` class,
    configured with `@WebFluxTest(controllers = UserController.class)`, `WebTestClient`
    is autowired to enable direct interaction with the `UserController` endpoints.
    This annotation helps us to isolate our controller from the full configuration.
    It ensures that tests are lightweight and targeted, significantly speeding up
    the testing process:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`WebTestClient`来测试反应式组件，而不是像在非反应式应用测试中使用的那样使用`MockMVC`。在配置了`@WebFluxTest(controllers
    = UserController.class)`的`UserControllerTest`类中，`WebTestClient`被自动注入，以便能够直接与`UserController`端点进行交互。这个注解帮助我们隔离控制器，确保测试轻量级且具有针对性，从而显著加快测试过程：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`@WebFluxTest` also sets up `WebTestClient` for our test environment and it
    becomes ready to use for sending simulated HTTP requests and asserting the responses.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`@WebFluxTest`还为我们的测试环境设置了`WebTestClient`，使其准备好发送模拟的HTTP请求并断言响应。'
- en: '`WebTestClient` helps to mock the behavior of requests and responses as they
    would occur in a live, reactive web environment. It also shows us again how Spring
    seamlessly supports the testing of reactive endpoints. After this theoretical
    information, we will delve into mocking the components in the next section.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebTestClient`有助于模拟请求和响应的行为，就像它们在一个实时、反应式网络环境中发生一样。它还再次展示了Spring如何无缝支持反应式端点的测试。在接下来的理论信息之后，我们将深入到下一节中模拟组件的部分。'
- en: Preparing mock components
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备模拟组件
- en: 'Mocking plays a pivotal role in preventing actual database operations during
    tests, which is crucial for several reasons. Firstly, it ensures test isolation,
    allowing each test to run independently without the side effects of shared data.
    You already knew this from the previous chapter. So, we are directly diving into
    the code snippet:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟在测试期间防止实际数据库操作中起着关键作用，这有几个重要原因。首先，它确保了测试隔离，允许每个测试独立运行，而不会受到共享数据的影响。您已经在上一章中知道了这一点。因此，我们直接进入代码片段：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With our dependencies mocked and test data freshly initialized before each test,
    we’re well equipped to dive into the core of our testing strategy, examining how
    each endpoint in `UserController` is tested. Next, we’ll start writing test cases,
    where we’ll break down the testing process for each operation, ensuring `UserController`
    behaves as expected under various conditions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个测试之前，我们已经模拟了依赖项并初始化了测试数据，这使得我们能够深入到测试策略的核心，检查`UserController`中的每个端点是如何被测试的。接下来，我们将开始编写测试用例，我们将分解每个操作的测试过程，确保`UserController`在各种条件下都能按预期行为。
- en: Writing test cases
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写测试用例
- en: 'Now, we are ready to write our tests for each method. We have mocked our dependencies;
    we just need to write unit tests and see whether they return the expected results.
    The only difference between testing non-reactive components and this is that we
    will use `webTestClient` instead of `mockMVC`. Let’s start:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备为每个方法编写测试。我们已经模拟了依赖项；我们只需要编写单元测试并查看它们是否返回预期的结果。与非反应式组件测试的唯一区别是，我们将使用`webTestClient`而不是`mockMVC`。让我们开始吧：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this code block, we have written a unit test to get all user endpoints. First,
    we have manipulated the `userRepositry.findAll()` method to return a Flux `testUser`
    object, and we expect a successful response.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码块中，我们编写了一个单元测试来获取所有用户端点。首先，我们操作了`userRepositry.findAll()`方法，使其返回一个`Flux`
    `testUser`对象，并期望得到一个成功的响应。
- en: For the test methods for other endpoints, please see the GitHub repository at
    [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-reactive-test/src/test/java/com/packt/ahmeric/reactivesample/controller/UserControllerTest.java](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-reactive-test/src/test/java/com/packt/ahmeric/reactivesample/controller/UserControllerTest.java).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他端点的测试方法，请参阅GitHub仓库[https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-reactive-test/src/test/java/com/packt/ahmeric/reactivesample/controller/UserControllerTest.java](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/blob/main/Chapter-6-reactive-test/src/test/java/com/packt/ahmeric/reactivesample/controller/UserControllerTest.java)。
- en: A look back is in order as we end our hands-on to test reactive components in
    our Spring Boot applications. A transition to the programming of reactivity obliges
    the developer to change their way of crafting applications and communicating in
    essence – chiefly focusing on non-blocking, asynchronous, and scalable interaction
    under pressure. However, great responsibility follows great power, and the testing
    of code stands at the pinnacle of that principle. The principal test challenges
    that testing these very reactive components brings in are the guaranteed handling
    of data streams, assured non-blocking nature, and dealing with backpressure.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束对Spring Boot应用程序中测试反应性组件的动手实践之前，回顾一下是有必要的。转向反应性编程迫使开发者改变他们构建应用程序和沟通的方式，本质上主要关注在压力下的非阻塞、异步和可扩展交互。然而，巨大的权力伴随着巨大的责任，代码的测试正是这一原则的顶峰。测试这些非常反应性组件带来的主要测试挑战是确保处理数据流、保证非阻塞性质和处理背压。
- en: With a myriad of approaches discussed in this section for testing a target,
    right from setting up the testing environment via `@WebFluxTest` to specifying
    dependencies and testing asynchronous results with `WebTestClient`, one is set
    up with the tools required to achieve quality, scalability, and maintainability
    in your reactive Spring Boot application. These then are ensuring strategies toward
    the guarantee that no matter what conditions are realized at runtime, the application
    behaves well and delivers the desired functionality and the desired performance.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中讨论了多种测试目标的方法，从通过`@WebFluxTest`设置测试环境到指定依赖关系，以及使用`WebTestClient`测试异步结果，一个人就可以配备上实现反应性Spring
    Boot应用程序质量、可扩展性和可维护性的所需工具。这些策略确保无论运行时实现什么条件，应用程序都能表现良好，并交付预期的功能和性能。
- en: The third good practice in testing is “reactive.” When applications become more
    complex and bigger in scale, the ability to effectively test these reactive components
    becomes a cornerstone of a successful development life cycle. In another light,
    developers who practice these testing methodologies can catch issues before they
    even rise to the level of annoyance and find a way to instill cultures of quality
    and resilience.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的第三个良好实践是“反应性”。当应用程序变得更加复杂和规模更大时，有效地测试这些反应性组件的能力成为成功开发生命周期的基石。从另一个角度来看，实践这些测试方法的开发者可以在问题甚至上升到令人烦恼的程度之前捕捉到它们，并找到一种方法来培养质量和弹性的文化。
- en: In other words, the way to test the reactive part is an accent of the dynamically
    changing web development landscape, which is always running into innovation in
    best development and best testing practices. With these insights and techniques
    from this exploration, go forth into future builds of more robust, responsible,
    and user-friendly applications.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，测试反应性部分是动态变化的Web开发景观的一个特色，它总是在最佳开发和最佳测试实践中遇到创新。通过这次探索的见解和技术，我们向未来构建更稳健、负责任和用户友好的应用程序迈进。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'As we wrap up this comprehensive exploration into advanced testing strategies
    for both non-reactive and reactive Spring Boot applications, it’s clear that the
    journey has been both enlightening and empowering. We learned how testing is important
    for the development life cycle and how it is easy with Springboot capabilities.
    With practical examples and hands-on guidance, this chapter has equipped you with
    essential skills and insights that are critical in today’s fast-paced software
    development landscape. Here’s a summary of what we’ve covered:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们结束对非反应性和反应性Spring Boot应用程序的高级测试策略的全面探索，很明显，这次旅程既具有启发性又具有赋权性。我们学习了测试对于开发生命周期的重要性，以及它如何利用Springboot的能力变得简单。通过实际示例和动手指导，本章为您提供了在当今快速发展的软件开发领域中至关重要的基本技能和见解。以下是我们所涵盖内容的总结：
- en: '**Foundational principles of TDD**: We learned the foundational principles
    of TDD and its impact on software quality and reliability.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TDD的基础原则**：我们学习了TDD的基础原则及其对软件质量和可靠性的影响。'
- en: '**Unit testing controllers**: We explored techniques for unit testing controllers
    with a security layer, ensuring that our applications are not only functional
    but also secure.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试控制器**：我们探索了使用安全层进行单元测试控制器的技术，确保我们的应用程序不仅功能齐全，而且安全。'
- en: '**Importance of integration testing**: We learned the importance of integration
    testing in validating the interaction between different parts of our applications,
    ensuring they work together seamlessly.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试的重要性**：我们学习了集成测试的重要性，确保我们应用程序的不同部分能够无缝协作。'
- en: '**Testing reactive components**: We explored strategies for testing reactive
    components, addressing the unique challenges presented by the reactive programming
    paradigm.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试响应式组件**：我们探讨了测试响应式组件的策略，解决了响应式编程范式带来的独特挑战。'
- en: These skills will make your applications tested, more reliable, scalable, and
    maintainable. Mastering these testing techniques in Spring Boot sets you apart
    as a developer.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技能将使你的应用程序经过测试，更加可靠、可扩展和易于维护。掌握 Spring Boot 中的这些测试技术，将使你作为一个开发者脱颖而出。
- en: Looking ahead, the journey through software development continues to evolve,
    bringing new challenges and opportunities. In the next chapter, we’ll dive into
    the world of containerization and orchestration. This upcoming chapter promises
    to unveil how Spring Boot applications can be made container ready, and how they
    can be orchestrated using Kubernetes for enhanced scalability and manageability.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 展望未来，软件开发之旅持续演变，带来新的挑战和机遇。在下一章中，我们将深入探讨容器化和编排的世界。这一即将到来的章节将揭示如何使 Spring Boot
    应用程序准备好容器化，以及如何使用 Kubernetes 进行编排以增强可扩展性和可管理性。
- en: 'Part 4: Deployment, Scalability, and Productivity'
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4部分：部署、可扩展性和生产力
- en: In this part, we will shift our focus towards deploying and scaling applications
    effectively, alongside boosting productivity. [*Chapter 7*](B18400_07.xhtml#_idTextAnchor213)
    explores the latest Spring Boot 3.0 features, particularly those that enhance
    containerization and orchestration for smoother deployment processes. [*Chapter
    8*](B18400_08.xhtml#_idTextAnchor233) dives into building event-driven systems
    with Kafka, which are crucial for managing high-throughput data with scalability
    in mind. Lastly, [*Chapter 9*](B18400_09.xhtml#_idTextAnchor249) covers strategies
    to enhance productivity and simplify development, ensuring you can maintain a
    rapid and efficient workflow as your projects grow. This section is key to mastering
    the operational side of software development, preparing you to handle large-scale
    deployments with ease.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将把重点转向有效地部署和扩展应用程序，同时提高生产力。[*第7章*](B18400_07.xhtml#_idTextAnchor213)
    探讨了最新的 Spring Boot 3.0 功能，特别是那些增强容器化和编排以简化部署流程的功能。[*第8章*](B18400_08.xhtml#_idTextAnchor233)
    深入探讨了使用 Kafka 构建事件驱动系统，这对于考虑可扩展性管理高吞吐量数据至关重要。最后，[*第9章*](B18400_09.xhtml#_idTextAnchor249)
    介绍了提高生产力和简化开发策略，确保随着项目的增长，你可以保持快速高效的流程。这一部分对于掌握软件开发的操作方面至关重要，为你轻松处理大规模部署做好准备。
- en: 'This part has the following chapters:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 7*](B18400_07.xhtml#_idTextAnchor213), *Spring Boot 3.0 Features
    for Containerization and Orchestration*'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18400_07.xhtml#_idTextAnchor213)，*Spring Boot 3.0 的容器化和编排功能*'
- en: '[*Chapter 8*](B18400_08.xhtml#_idTextAnchor233), *Exploring Event-Driven Systems
    with Kafka*'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18400_08.xhtml#_idTextAnchor233)，*使用 Kafka 探索事件驱动系统*'
- en: '[*Chapter 9*](B18400_09.xhtml#_idTextAnchor249), *Enhancing Productivity and
    Development Simplification*'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18400_09.xhtml#_idTextAnchor249)，*提高生产力和开发简化*'
