- en: Preface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Chapter 1,* *Type inference*, Java has long been criticized for being verbose,
    Java 10 introduces type inference with local variables, by using the keyword var.
    It shouldn’t be confused with dynamic binding. Java still has static binding.
    Type inference evolved from previous Java versions, from generics in Java 5 to
    try-with-resources in Java 7 and inferred lambda parameters types in Java 8\.
    Instead of making you type out variable type information, Java compiler infers
    it and adds it to the bytecode.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 2*, *Application class data sharing*, Application Class Data Sharing
    (ADS) extends Class-Data Sharing (CDS) which allows a JVM to record a set of classes
    and process them into a shared archive file. This archive can be memory mapped
    into the JVM process on the next run to reduce startup time. The file can be shared
    across JVMs and this can reduce overall memory footprint when multiple JVMs are
    running on the same host.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 3,* *Garbage Collector optimizations*, the Java garbage collector
    has been both a boon and a pain point. Consistent efforts are being made to optimize
    the garbage collections. With Java 9, G1 became the default garbage collector.
    With Java 10, G1 becomes more efficient by allowing full GC parallel. With garbage
    collector interface, applications could be deployed with alternative garbage collectors.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 4,* *API Improvements and other changes*, this is not all, Java 10
    has more to offer - it includes improvements to the existing API, like adding
    API for creating unmodifiable collections, thread local handshakes to stop selected
    threads and consolidating JDK forest into a single repository.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 5,* Local variable syntax for lambda parameters, one of the most eagerly
    awaited feature of Java 11, local variable syntax for lambda parameters introduces
    usage of var with lambda parameters. This chapter will cover its syntax and usage
    with the challenges.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 6,* *Epsilon and its design considerations*, Java 11 introduces Epsilon;
    which reduces the latency in garbage collection. In this chapter, you’ll see why
    it is required and its design considerations.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 7,* *HTTP Client and other changes*, with Java 11, removal of deprecated
    Java EE and corba packages has started since Java EE has moved to Eclipse foundation,
    renamed as Jakrata EE. Java 11 rewrites the implementation of HTTP client, introduced
    in Java 9, making it completely asynchronous.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 8,* *Enhanced Enumism Project Amber*, existing enums provide limited
    functionality. Project Amber will enhance enums by allowing type-variables (generic
    enums), and performing sharper type-checking for enum constants.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 9,* *Data classes and their usage*, data classes are wrappers to store
    object states. Even though an IDE can generate the accessors and mutation methods
    for such class, it still needs to be scanned by the developers to determine if
    it hides any business logic. Data classes make this language ceremony simpler
    by defining data classes, using the keyword data. This chapter cover the need
    of data class, their definition and usage.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 10,* *Raw String literals*, string concatenation is a used quite often
    by programmers to return string representation of objects, JSON or XML request
    or responses, SQL queries, and many others. Until now Java’s String concatenation
    used clumsy combination of concatenation operators, quotes and special characters
    negations using backslashes, which is inconvenient to write and maintain. This
    chapter eases String concatenation by demonstrating creation and usage of raw
    string literals.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 11,* *Lambda leftovers*, lambda leftover includes usage of underscore
    (_) to denote an unnamed method, exception or lambda parameter. The chapter covers
    the challenges in implementing it, creation and usage.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 12,* *Pattern matching and switch expressions*, to get started, pattern
    matching will cover type test and constant patterns to enhance the Java language
    constructs. The chapter will take you through the patterns and how it significantly
    affects the way switch expressions are used.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 13,* *Value based optimizations*, objects, when stored in arrays,
    have an overhead, their immediate values aren’t stored in the array. The array
    of objects store metadata about the array objects and multiple data references.
    This consumes much more memory than is required. Value types, a new language modification,
    enables creation of data types; which use just the memory required to store the
    actual value in an array.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 14,* *Generics improvements*, with proposal of addition of value types
    to Java, limiting generic arguments to objects hurts. The chapter covers generics
    improvements to extend generic types to support the specialization of generic
    classes and interfaces over primitive types.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 15,* *Filters and Continuations*, ever since its first release, Java
    became popular with its support for creation of threads. Fibers and continuations
    will move it way more steps forward; by creating ultra-light threads, called,
    fibers.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 16,* *JVM and native code*, Analogous to the Panama channel, which
    connects the Atlantic and Pacific ocean, Project Panama plans to bridge the gap
    between the JVM and the native code. This chapter will take you through the thought
    process of opening of native libraries, say, written in C, to Java developers.'
  prefs: []
  type: TYPE_NORMAL
