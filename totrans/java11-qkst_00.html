<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Preface</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6"><em class="calibre7">Chapter 1,</em> <em class="calibre7">Type inference</em><span class="calibre8">, Java has long been criticized for being verbose, Java 10 introduces type inference with local variables, by using the keyword var. It shouldn’t be confused with dynamic binding. Java still has static binding. Type inference evolved from previous Java versions, from generics in Java 5 to try-with-resources in Java 7 and inferred lambda parameters types in Java 8. Instead of making you type out variable type information, Java compiler infers it and adds it to the bytecode.</span></p>
<p class="calibre6"><em class="calibre7">Chapter 2</em>, <em class="calibre7">Application class data sharing</em><span class="calibre8">, Application Class Data Sharing (ADS) extends Class-Data Sharing (CDS) which allows a JVM to record a set of classes and process them into a shared archive file. This archive can be memory mapped into the JVM process on the next run to reduce startup time. The file can be shared across JVMs and this can reduce overall memory footprint when multiple JVMs are running on the same host.</span></p>
<p class="calibre6"><em class="calibre7">Chapter 3,</em> <em class="calibre7">Garbage Collector optimizations</em><span class="calibre8">, the Java garbage collector has been both a boon and a pain point. Consistent efforts are being made to optimize the garbage collections. With Java 9, G1 became the default garbage collector. With Java 10, G1 becomes more efficient by allowing full GC parallel. With garbage collector interface, applications could be deployed with alternative garbage collectors.</span></p>
<p class="calibre6"><em class="calibre7">Chapter 4,</em> <em class="calibre7">API Improvements and other changes</em><span class="calibre8">, this is not all, Java 10 has more to offer - it includes improvements to the existing API, like adding API for creating unmodifiable collections, thread local handshakes to stop selected threads and consolidating JDK forest into a single repository.</span></p>
<p class="calibre6"><em class="calibre7">Chapter 5,</em> Local variable syntax for lambda parameters<span class="calibre8">, o</span><span class="calibre8">ne of the most eagerly awaited feature of Java 11, local variable syntax for lambda parameters introduces usage of var with lambda parameters. This chapter will cover its syntax and usage with the challenges.</span></p>
<p class="calibre6"><em class="calibre7">Chapter 6,</em> <em class="calibre7">Epsilon and its design considerations</em><span class="calibre8">, </span><span class="calibre8">Java 11 introduces Epsilon; which reduces the latency in garbage collection. In this chapter, you’ll see why it is required and its design considerations.</span></p>
<p class="calibre6"><em class="calibre7">Chapter 7,</em> <em class="calibre7">HTTP Client and other changes</em><span class="calibre8">, w</span><span class="calibre8">ith Java 11, removal of deprecated Java EE and corba packages has started since Java EE has moved to Eclipse foundation, renamed as Jakrata EE. Java 11 rewrites the implementation of HTTP client, introduced in Java 9, making it completely asynchronous.</span></p>
<p class="calibre6"><em class="calibre7">Chapter 8,</em> <em class="calibre7">Enhanced Enumism Project Amber</em><span class="calibre8">, e</span><span class="calibre8">xisting enums provide limited functionality. Project Amber will enhance enums by allowing type-variables (generic enums), and performing sharper type-checking for enum constants.</span></p>
<p class="calibre6"><em class="calibre7">Chapter 9,</em> <em class="calibre7">Data classes and their usage</em><span class="calibre8">, data classes are wrappers to store object states. Even though an IDE can generate the accessors and mutation methods for such class, it still needs to be scanned by the developers to determine if it hides any business logic. Data classes make this language ceremony simpler by defining data classes, using the keyword data. This chapter cover the need of data class, their definition and usage.</span></p>
<p class="calibre6"><em class="calibre7">Chapter 10,</em><span class="calibre8"> </span><em class="calibre7">Raw String literals</em><span class="calibre8">, string concatenation is a used quite often by programmers to return string representation of objects, JSON or XML request or responses, SQL queries, and many others. Until now Java’s String concatenation used clumsy combination of concatenation operators, quotes and special characters negations using backslashes, which is inconvenient to write and maintain. This chapter eases String concatenation by demonstrating creation and usage of raw string literals.</span></p>
<p class="calibre6"><em class="calibre7">Chapter 11,</em><span class="calibre8"> </span><em class="calibre7">Lambda leftovers</em><span class="calibre8">, lambda leftover includes usage of underscore (_) to denote an unnamed method, exception or lambda parameter. The chapter covers the challenges in implementing it, creation and usage.</span></p>
<p class="calibre6"><em class="calibre7">Chapter 12,</em><span class="calibre8"> </span><em class="calibre7">Pattern matching and switch expressions</em><span class="calibre8">, t</span><span class="calibre8">o get started, pattern matching will cover type test and constant patterns to enhance the Java language constructs. The chapter will take you through the patterns and how it significantly affects the way switch expressions are used.</span></p>
<p class="calibre6"><em class="calibre7">Chapter 13,</em><span class="calibre8"> </span><em class="calibre7">Value based optimizations</em><span class="calibre8">, objects, when stored in arrays, have an overhead, their immediate values aren’t stored in the array. The array of objects store metadata about the array objects and multiple data references. This consumes much more memory than is required. Value types, a new language modification, enables creation of data types; which use just the memory required to store the actual value in an array.</span></p>
<p class="calibre6"><em class="calibre7">Chapter 14,</em><span class="calibre8"> </span><em class="calibre7">Generics improvements</em><span class="calibre8">, with proposal of addition of value types to Java, limiting generic arguments to objects hurts. The chapter covers generics improvements to extend generic types to support the specialization of generic classes and interfaces over primitive types.</span></p>
<p class="calibre6"><em class="calibre7">Chapter 15,</em><span class="calibre8"> </span><em class="calibre7">Filters and Continuations</em><span class="calibre8">, e</span><span class="calibre8">ver since its first release, Java became popular with its support for creation of threads. Fibers and continuations will move it way more steps forward; by creating ultra-light threads, called, fibers.</span></p>
<p class="calibre6"><em class="calibre7">Chapter 16,</em><span class="calibre8"> </span><em class="calibre7">JVM and native code</em><span class="calibre8">, Analogous to the Panama channel, which connects the Atlantic and Pacific ocean, Project Panama plans to bridge the gap between the JVM and the native code. This chapter will take you through the thought process of opening of native libraries, say, written in C, to Java developers.</span></p>


            </article>

            
        </section>
    </div>



  </body></html>