<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building Lightweight Solutions Using Microservices</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre8">This chapter covers the following recipes:</span><br class="calibre9"/></p>
<ul class="calibre13">
<li class="calibre14">Building microservices from a monolith</li>
<li class="calibre14">Building decoupled services</li>
<li class="calibre14">Building an automated pipeline for microservices</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre7">Microservices</strong> are really one of the top buzzwords nowadays. It's easy to understand why: in a growing software industry where the amount of services, data, and users increases crazily, we really need a way to build and deliver faster, decoupled, and scalable solutions.</p>
<p class="mce-root">Why are microservices good? Why use them?</p>
<p class="mce-root">Actually, with growing demand, the need to deal with each module separately has increased. For example, in your customer application, maybe user information needs to be scaled in a different way from the address information.</p>
<p class="mce-root">In the monolith paradigm, you need to deal with it atomically: you build a cluster for the whole application or you scale up (or down) your entire host. The problem with this approach is that you can't focus your effort and resources on a specific feature, module, or function: you are always guided by what is needed at that moment.</p>
<p class="mce-root">In the microservice approach, you do it separately. Then you can not only scale (up or down) one single unit in your application, but you can also separate your data for each service (which you should do), separate technology (best tool for the best work), and more.</p>
<p class="mce-root">Other than scale technology, microservices are made to scale people. With a bigger application, bigger architecture, and bigger databases, also come bigger teams. And if you build your team like a monolith application, you are probably getting likely results.</p>
<p class="mce-root">So, as the application is split into a few (or a lot of) modules, you can also define cross-functional teams to take care of each module. This means that each team can have its own programmer, designer, database administrator, system administrator, network specialist, manager, and so on. Each team has responsibility over the module it is dealing with.</p>
<p class="mce-root">It brings agility to the process of thinking about and delivering software, and then maintaining and evolving it.</p>
<p class="mce-root">In this chapter, there are some recipes to help you get started with microservices or go deeper into your ongoing project.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building microservices from a monolith</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">One common question that I have already heard dozens of times is, <em class="calibre17">"how do I break down my monolith into microservices?",</em> or, <em class="calibre17">"how do I migrate from a monolith approach to microservices?"</em></p>
<p class="mce-root">Well, that's what this recipe is all about.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">For both monolith and microservice projects, we will use the same dependency:</p>
<pre class="calibre21">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's begin by building a monolith to split into microservices.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building a monolith</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">First, we need the entities that will represent the data kept by the application.</p>
<p class="mce-root">Here is the <kbd class="calibre16">User</kbd> entity:</p>
<pre class="calibre21">@Entity<br class="calibre2"/>public class User implements Serializable {<br class="calibre2"/><br class="calibre2"/>    private static final long serialVersionUID = 1L;<br class="calibre2"/><br class="calibre2"/>    @Id<br class="calibre2"/>    @GeneratedValue(strategy = GenerationType.AUTO)<br class="calibre2"/>    private Long id;<br class="calibre2"/>    <br class="calibre2"/>    @Column<br class="calibre2"/>    private String name;<br class="calibre2"/>    <br class="calibre2"/>    @Column<br class="calibre2"/>    private String email;<br class="calibre2"/><br class="calibre2"/>    public User(){   <br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public User(String name, String email) {<br class="calibre2"/>        this.name = name;<br class="calibre2"/>        this.email = email;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public Long getId() {<br class="calibre2"/>        return id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setId(Long id) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public String getName() {<br class="calibre2"/>        return name;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setName(String name) {<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getEmail() {<br class="calibre2"/>        return email;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setEmail(String email) {<br class="calibre2"/>        this.email = email;<br class="calibre2"/>    } <br class="calibre2"/>}</pre>
<p class="mce-root">Here is the <kbd class="calibre16">UserAddress</kbd> entity:</p>
<pre class="calibre21">@Entity<br class="calibre2"/>public class UserAddress implements Serializable {<br class="calibre2"/><br class="calibre2"/>    private static final long serialVersionUID = 1L;<br class="calibre2"/><br class="calibre2"/>    @Id<br class="calibre2"/>    @GeneratedValue(strategy = GenerationType.AUTO)<br class="calibre2"/>    private Long id;<br class="calibre2"/><br class="calibre2"/>    @Column<br class="calibre2"/>    @ManyToOne<br class="calibre2"/>    private User user;<br class="calibre2"/>    <br class="calibre2"/>    @Column<br class="calibre2"/>    private String street;<br class="calibre2"/>    <br class="calibre2"/>    @Column<br class="calibre2"/>    private String number;<br class="calibre2"/>    <br class="calibre2"/>    @Column<br class="calibre2"/>    private String city;<br class="calibre2"/>    <br class="calibre2"/>    @Column<br class="calibre2"/>    private String zip;<br class="calibre2"/>    <br class="calibre2"/>    public UserAddress(){<br class="calibre2"/>        <br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public UserAddress(User user, String street, String number, <br class="calibre2"/>                       String city, String zip) {<br class="calibre2"/>        this.user = user;<br class="calibre2"/>        this.street = street;<br class="calibre2"/>        this.number = number;<br class="calibre2"/>        this.city = city;<br class="calibre2"/>        this.zip = zip;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public Long getId() {<br class="calibre2"/>        return id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setId(Long id) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public User getUser() {<br class="calibre2"/>        return user;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setUser(User user) {<br class="calibre2"/>        this.user = user;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getStreet() {<br class="calibre2"/>        return street;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setStreet(String street) {<br class="calibre2"/>        this.street = street;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getNumber() {<br class="calibre2"/>        return number;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setNumber(String number) {<br class="calibre2"/>        this.number = number;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getCity() {<br class="calibre2"/>        return city;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setCity(String city) {<br class="calibre2"/>        this.city = city;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getZip() {<br class="calibre2"/>        return zip;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setZip(String zip) {<br class="calibre2"/>        this.zip = zip;<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">Now we define one bean to deal with the transaction over each entity.</p>
<p class="mce-root">Here is the <kbd class="calibre16">UserBean</kbd> class:</p>
<pre class="calibre21">@Stateless<br class="calibre2"/>public class UserBean {<br class="calibre2"/><br class="calibre2"/>    @PersistenceContext<br class="calibre2"/>    private EntityManager em;<br class="calibre2"/><br class="calibre2"/>    public void add(User user) {<br class="calibre2"/>        em.persist(user);<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void remove(User user) {<br class="calibre2"/>        em.remove(user);<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void update(User user) {<br class="calibre2"/>        em.merge(user);<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public User findById(Long id) {<br class="calibre2"/>        return em.find(User.class, id);<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public List&lt;User&gt; get() {<br class="calibre2"/>        CriteriaBuilder cb = em.getCriteriaBuilder();<br class="calibre2"/>        CriteriaQuery&lt;User&gt; cq = cb.createQuery(User.class);<br class="calibre2"/>        Root&lt;User&gt; pet = cq.from(User.class);<br class="calibre2"/>        cq.select(pet);<br class="calibre2"/>        TypedQuery&lt;User&gt; q = em.createQuery(cq);<br class="calibre2"/>        return q.getResultList();<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>}</pre>
<p class="mce-root">Here is the <kbd class="calibre16">UserAddressBean</kbd> class:</p>
<pre class="calibre21">@Stateless<br class="calibre2"/>public class UserAddressBean {<br class="calibre2"/><br class="calibre2"/>    @PersistenceContext<br class="calibre2"/>    private EntityManager em;<br class="calibre2"/>    <br class="calibre2"/>    public void add(UserAddress address){<br class="calibre2"/>        em.persist(address);<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public void remove(UserAddress address){<br class="calibre2"/>        em.remove(address);<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public void update(UserAddress address){<br class="calibre2"/>        em.merge(address);<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public UserAddress findById(Long id){<br class="calibre2"/>        return em.find(UserAddress.class, id);<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public List&lt;UserAddress&gt; get() {<br class="calibre2"/>        CriteriaBuilder cb = em.getCriteriaBuilder();<br class="calibre2"/>        CriteriaQuery&lt;UserAddress&gt; cq = cb.createQuery(UserAddress.class);<br class="calibre2"/>        Root&lt;UserAddress&gt; pet = cq.from(UserAddress.class);<br class="calibre2"/>        cq.select(pet);<br class="calibre2"/>        TypedQuery&lt;UserAddress&gt; q = em.createQuery(cq);<br class="calibre2"/>        return q.getResultList();<br class="calibre2"/>    } <br class="calibre2"/>}</pre>
<p class="mce-root">Finally, we build two services to perform the communication between the client and the beans.</p>
<p class="mce-root">Here is the <kbd class="calibre16">UserService</kbd> class:</p>
<pre class="calibre21">@Path("userService")<br class="calibre2"/>public class UserService {<br class="calibre2"/>    <br class="calibre2"/>    @EJB<br class="calibre2"/>    private UserBean userBean;<br class="calibre2"/>    <br class="calibre2"/>    @GET<br class="calibre2"/>    @Path("findById/{id}")<br class="calibre2"/>    @Consumes(MediaType.APPLICATION_JSON)<br class="calibre2"/>    @Produces(MediaType.APPLICATION_JSON)<br class="calibre2"/>    public Response findById(@PathParam("id") Long id){<br class="calibre2"/>        return Response.ok(userBean.findById(id)).build();<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @GET<br class="calibre2"/>    @Path("get")<br class="calibre2"/>    @Consumes(MediaType.APPLICATION_JSON)<br class="calibre2"/>    @Produces(MediaType.APPLICATION_JSON)<br class="calibre2"/>    public Response get(){<br class="calibre2"/>        return Response.ok(userBean.get()).build();<br class="calibre2"/>    } <br class="calibre2"/>    <br class="calibre2"/>    @POST<br class="calibre2"/>    @Path("add")<br class="calibre2"/>    @Consumes(MediaType.APPLICATION_JSON)<br class="calibre2"/>    @Produces(MediaType.APPLICATION_JSON) <br class="calibre2"/>    public Response add(User user){<br class="calibre2"/>        userBean.add(user);<br class="calibre2"/>        return Response.accepted().build();<br class="calibre2"/>    } <br class="calibre2"/>    <br class="calibre2"/>    @DELETE<br class="calibre2"/>    @Path("remove/{id}")<br class="calibre2"/>    @Consumes(MediaType.APPLICATION_JSON)<br class="calibre2"/>    @Produces(MediaType.APPLICATION_JSON) <br class="calibre2"/>    public Response remove(@PathParam("id") Long id){<br class="calibre2"/>        userBean.remove(userBean.findById(id));<br class="calibre2"/>        return Response.accepted().build();<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">Here is the <kbd class="calibre16">UserAddressService</kbd> class:</p>
<pre class="calibre21">@Path("userAddressService")<br class="calibre2"/>public class UserAddressService {<br class="calibre2"/>    <br class="calibre2"/>    @EJB<br class="calibre2"/>    private UserAddressBean userAddressBean;<br class="calibre2"/>    <br class="calibre2"/>    @GET<br class="calibre2"/>    @Path("findById/{id}")<br class="calibre2"/>    @Consumes(MediaType.APPLICATION_JSON)<br class="calibre2"/>    @Produces(MediaType.APPLICATION_JSON)<br class="calibre2"/>    public Response findById(@PathParam("id") Long id){<br class="calibre2"/>        return Response.ok(userAddressBean.findById(id)).build();<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @GET<br class="calibre2"/>    @Path("get")<br class="calibre2"/>    @Consumes(MediaType.APPLICATION_JSON)<br class="calibre2"/>    @Produces(MediaType.APPLICATION_JSON)<br class="calibre2"/>    public Response get(){<br class="calibre2"/>        return Response.ok(userAddressBean.get()).build();<br class="calibre2"/>    } <br class="calibre2"/>    <br class="calibre2"/>    @POST<br class="calibre2"/>    @Path("add")<br class="calibre2"/>    @Consumes(MediaType.APPLICATION_JSON)<br class="calibre2"/>    @Produces(MediaType.APPLICATION_JSON) <br class="calibre2"/>    public Response add(UserAddress address){<br class="calibre2"/>        userAddressBean.add(address);<br class="calibre2"/>        return Response.accepted().build();<br class="calibre2"/>    } <br class="calibre2"/>    <br class="calibre2"/>    @DELETE<br class="calibre2"/>    @Path("remove/{id}")<br class="calibre2"/>    @Consumes(MediaType.APPLICATION_JSON)<br class="calibre2"/>    @Produces(MediaType.APPLICATION_JSON) <br class="calibre2"/>    public Response remove(@PathParam("id") Long id){<br class="calibre2"/>        userAddressBean.remove(userAddressBean.findById(id));<br class="calibre2"/>        return Response.accepted().build();<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">Now let's break it down!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building microservices from the monolith</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Our monolith deals with <kbd class="calibre16">User</kbd> and <kbd class="calibre16">UserAddress</kbd>. So we will break it down into three microservices:</p>
<ul class="calibre13">
<li class="calibre14">A user microservice</li>
<li class="calibre14">A user address microservice</li>
<li class="calibre14">A gateway microservice</li>
</ul>
<p class="mce-root">A gateway service is an API between the application client and the services. Using it allows you to simplify this communication, also giving you the freedom of doing whatever you like with your services without breaking the API contracts (or at least minimizing it).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The user microservice</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre16">User</kbd> entity, <kbd class="calibre16">UserBean</kbd>, and <kbd class="calibre16">UserService</kbd> will remain exactly as they are in the monolith. Only now they will be delivered as a separated unit of deployment.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The user address microservice</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre16">UserAddress</kbd> classes will suffer just a single change from the monolith version, but keep their original APIs (that is great from the point of view of the client).</p>
<p class="mce-root">Here is the <kbd class="calibre16">UserAddress</kbd> entity:</p>
<pre class="calibre21">@Entity<br class="calibre2"/>public class UserAddress implements Serializable {<br class="calibre2"/><br class="calibre2"/>    private static final long serialVersionUID = 1L;<br class="calibre2"/><br class="calibre2"/>    @Id<br class="calibre2"/>    @GeneratedValue(strategy = GenerationType.AUTO)<br class="calibre2"/>    private Long id;<br class="calibre2"/><br class="calibre2"/>    @Column<br class="calibre2"/>    private Long idUser;<br class="calibre2"/>    <br class="calibre2"/>    @Column<br class="calibre2"/>    private String street;<br class="calibre2"/>    <br class="calibre2"/>    @Column<br class="calibre2"/>    private String number;<br class="calibre2"/>    <br class="calibre2"/>    @Column<br class="calibre2"/>    private String city;<br class="calibre2"/>    <br class="calibre2"/>    @Column<br class="calibre2"/>    private String zip;<br class="calibre2"/>    <br class="calibre2"/>    public UserAddress(){<br class="calibre2"/>        <br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public UserAddress(Long user, String street, String number, <br class="calibre2"/>                       String city, String zip) {<br class="calibre2"/>        this.idUser = user;<br class="calibre2"/>        this.street = street;<br class="calibre2"/>        this.number = number;<br class="calibre2"/>        this.city = city;<br class="calibre2"/>        this.zip = zip;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public Long getId() {<br class="calibre2"/>        return id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setId(Long id) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public Long getIdUser() {<br class="calibre2"/>        return idUser;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setIdUser(Long user) {<br class="calibre2"/>        this.idUser = user;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getStreet() {<br class="calibre2"/>        return street;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setStreet(String street) {<br class="calibre2"/>        this.street = street;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getNumber() {<br class="calibre2"/>        return number;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setNumber(String number) {<br class="calibre2"/>        this.number = number;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getCity() {<br class="calibre2"/>        return city;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setCity(String city) {<br class="calibre2"/>        this.city = city;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getZip() {<br class="calibre2"/>        return zip;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setZip(String zip) {<br class="calibre2"/>        this.zip = zip;<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">Note that <kbd class="calibre16">User</kbd> is no longer a property/field in the <kbd class="calibre16">UserAddress</kbd> entity, but only a number (<kbd class="calibre16">idUser</kbd>). We will get into more details about it in the following section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The gateway microservice</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">First, we create a class that helps us deal with the responses:</p>
<pre class="calibre21">public class GatewayResponse {<br class="calibre2"/><br class="calibre2"/>    private String response;<br class="calibre2"/>    private String from;<br class="calibre2"/><br class="calibre2"/>    public String getResponse() {<br class="calibre2"/>        return response;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setResponse(String response) {<br class="calibre2"/>        this.response = response;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getFrom() {<br class="calibre2"/>        return from;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setFrom(String from) {<br class="calibre2"/>        this.from = from;<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">Then, we create our gateway service:</p>
<pre class="calibre21">@Consumes(MediaType.APPLICATION_JSON)<br class="calibre2"/>@Path("gatewayResource")<br class="calibre2"/>@RequestScoped<br class="calibre2"/>public class GatewayResource {<br class="calibre2"/><br class="calibre2"/>    private final String hostURI = "http://localhost:8080/";<br class="calibre2"/>    private Client client;<br class="calibre2"/>    private WebTarget targetUser;<br class="calibre2"/>    private WebTarget targetAddress;<br class="calibre2"/><br class="calibre2"/>    @PostConstruct<br class="calibre2"/>    public void init() {<br class="calibre2"/>        client = ClientBuilder.newClient();<br class="calibre2"/>        targetUser = client.target(hostURI + <br class="calibre2"/>        "ch08-micro_x_mono-micro-user/");<br class="calibre2"/>        targetAddress = client.target(hostURI +<br class="calibre2"/>        "ch08-micro_x_mono-micro-address/");<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @PreDestroy<br class="calibre2"/>    public void destroy(){<br class="calibre2"/>        client.close();<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @GET<br class="calibre2"/>    @Path("getUsers")<br class="calibre2"/>    @Produces(MediaType.APPLICATION_JSON)<br class="calibre2"/>    public Response getUsers() {<br class="calibre2"/>        WebTarget service = <br class="calibre2"/>        targetUser.path("webresources/userService/get");<br class="calibre2"/><br class="calibre2"/>        Response response;<br class="calibre2"/>        try {<br class="calibre2"/>            response = service.request().get();<br class="calibre2"/>        } catch (ProcessingException e) {<br class="calibre2"/>            return Response.status(408).build();<br class="calibre2"/>        }<br class="calibre2"/><br class="calibre2"/>        GatewayResponse gatewayResponse = new GatewayResponse();<br class="calibre2"/>        gatewayResponse.setResponse(response.readEntity(String.class));<br class="calibre2"/>        gatewayResponse.setFrom(targetUser.getUri().toString());<br class="calibre2"/><br class="calibre2"/>        return Response.ok(gatewayResponse).build();<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @POST<br class="calibre2"/>    @Path("addAddress")<br class="calibre2"/>    @Produces(MediaType.APPLICATION_JSON) <br class="calibre2"/>    public Response addAddress(UserAddress address) {<br class="calibre2"/>        WebTarget service = <br class="calibre2"/>        targetAddress.path("webresources/userAddressService/add");<br class="calibre2"/><br class="calibre2"/>        Response response;<br class="calibre2"/>        try {<br class="calibre2"/>            response = service.request().post(Entity.json(address));<br class="calibre2"/>        } catch (ProcessingException e) {<br class="calibre2"/>            return Response.status(408).build();<br class="calibre2"/>        }<br class="calibre2"/><br class="calibre2"/>        return Response.fromResponse(response).build();<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root">As we receive the <kbd class="calibre16">UserAddress</kbd> entity in the gateway, we have to have a version of it in the gateway project too. For brevity, we will omit the code, as it is the same as in the <kbd class="calibre16">UserAddress</kbd> project.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's understand how things work here.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The monolith</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The monolith application couldn't be simpler: just a project with two services using two beans to manage two entities. If you want to understand what is happening there regarding JAX-RS, CDI, and/or JPA, check the relevant recipes earlier in this book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The microservices</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">So we split the monolith into three projects (microservices): the user service, the user address service, and the gateway service.</p>
<p class="mce-root">The user service classes remained unchanged after the migration from the monolith version. So there's nothing to comment on.</p>
<p class="mce-root">The <kbd class="calibre16">UserAddress</kbd> class had to be changed to become a microservice. The first change was made on the entity.</p>
<p class="mce-root">Here is the monolith version:</p>
<pre class="calibre21">@Entity<br class="calibre2"/>public class UserAddress implements Serializable {<br class="calibre2"/><br class="calibre2"/>    ...<br class="calibre2"/><br class="calibre2"/>    @Column<br class="calibre2"/>    @ManyToOne<br class="calibre2"/>    private User user;<br class="calibre2"/>    <br class="calibre2"/>    ...<br class="calibre2"/>    <br class="calibre2"/>    public UserAddress(User user, String street, String number, <br class="calibre2"/>                       String city, String zip) {<br class="calibre2"/>        this.user = user;<br class="calibre2"/>        this.street = street;<br class="calibre2"/>        this.number = number;<br class="calibre2"/>        this.city = city;<br class="calibre2"/>        this.zip = zip;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    ...<br class="calibre2"/><br class="calibre2"/>    public User getUser() {<br class="calibre2"/>        return user;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setUser(User user) {<br class="calibre2"/>        this.user = user;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    ...<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root">Here is the microservice version:</p>
<pre class="calibre21">@Entity<br class="calibre2"/>public class UserAddress implements Serializable {<br class="calibre2"/><br class="calibre2"/>    ...<br class="calibre2"/><br class="calibre2"/>    @Column<br class="calibre2"/>    private Long idUser;<br class="calibre2"/>    <br class="calibre2"/>    ...<br class="calibre2"/>    <br class="calibre2"/>    public UserAddress(Long user, String street, String number, <br class="calibre2"/>                       String city, String zip) {<br class="calibre2"/>        this.idUser = user;<br class="calibre2"/>        this.street = street;<br class="calibre2"/>        this.number = number;<br class="calibre2"/>        this.city = city;<br class="calibre2"/>        this.zip = zip;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public Long getIdUser() {<br class="calibre2"/>        return idUser;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setIdUser(Long user) {<br class="calibre2"/>        this.idUser = user;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    ...<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root">Note that in the monolith version, <kbd class="calibre16">user</kbd> was an instance of the <kbd class="calibre16">User</kbd> entity:</p>
<pre class="calibre21">private User user;</pre>
<p class="mce-root">In the microservice version, it became a number:</p>
<pre class="calibre21">private Long idUser;</pre>
<p class="mce-root">This happened for two main reasons:</p>
<ol class="calibre19">
<li class="chapter">In the monolith, we have the two tables in the same database <kbd class="calibre16">(User</kbd> and <kbd class="calibre16">UserAddress</kbd>), and they both have physical and logical relationships (foreign key). So it makes sense to also keep the relationship between both the objects.</li>
<li class="chapter">The microservice should have its own database, completely independent from the other services. So we choose to keep only the user ID, as it is enough to load the address properly anytime the client needs.</li>
</ol>
<p class="mce-root">This change also resulted in a change in the constructor.</p>
<p class="mce-root">Here is the monolith version:</p>
<pre class="calibre21">public UserAddress(User user, String street, String number, <br class="calibre2"/>                   String city, String zip)</pre>
<p class="mce-root">Here is the microservice version:</p>
<pre class="calibre21">public UserAddress(Long user, String street, String number, <br class="calibre2"/>                   String city, String zip)</pre>
<p class="mce-root">This could lead to a change of contract with the client regarding the change of the constructor signature. But thanks to the way it was built, it wasn't necessary.</p>
<p class="mce-root">Here is the monolith version:</p>
<pre class="calibre21">public Response add(UserAddress address)</pre>
<p class="mce-root">Here is the microservice version:</p>
<pre class="calibre21">public Response add(UserAddress address)</pre>
<p class="mce-root">Even if the method is changed, it could easily be solved with <kbd class="calibre16">@Path</kbd> annotation, or if we really need to change the client, it would be only the method name and not the parameters (which used to be more painful).</p>
<p class="mce-root">Finally, we have the gateway service, which is our implementation of the API gateway design pattern. Basically it is the one single point to access the other services.</p>
<p class="mce-root">The nice thing about it is that your client doesn't need to care about whether the other services changed the URL, the signature, or even whether they are available. The gateway will take care of them.</p>
<p class="mce-root">The bad part is that it is also on a single point of failure. Or, in other words, without the gateway, all services are unreachable. But you can deal with it using a cluster, for example.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Though Java EE is perfect for microservices, there are other options using the same bases and that may be a little lighter in some scenarios.</p>
<p class="mce-root">One of them is KumuluzEE (<a href="https://ee.kumuluz.com/" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://ee.kumuluz.com/</a>). It's based on Java EE and has many microservice <em class="calibre17">must-have</em> features, such as service discovery. It won a Duke Choice Awards prize, which is huge!</p>
<p class="mce-root">The other one is Payara Micro (<a href="https://www.payara.fish/payara_micro" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://www.payara.fish/payara_micro</a>). Payara is the company that owns a commercial implementation of GlassFish, the Payara Server, and from the Payara Server, they created the Payara Fish. The cool thing about it is that it is just a 60 MB JAR file that you start using the command line and boom! Your microservice is running.</p>
<p class="mce-root">Finally, the awesome thing about these two projects is that they are aligned with the Eclipse MicroProfile project (<a href="http://microprofile.io/" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">http://microprofile.io/</a>). MicroProfile is defining the path and the standards for microservices in the Java EE ecosystem  right now, so it is worth following.</p>
<p class="mce-root">One last note about the code covered in this recipe: it would be nice in a real-world solution to use a DTO to separate the database representation from the service one. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The full source code of this recipe can be found in the following repositories:</p>
<ul class="calibre13">
<li class="calibre14"><strong class="calibre3">Monolith</strong>: <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-mono" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-mono</a></li>
<li class="calibre14"><strong class="calibre3">User microservice</strong>: <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-user" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-user</a></li>
<li class="calibre14"><strong class="calibre3">UserAddress microservice</strong>: <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-address" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-address</a></li>
<li class="calibre14"><strong class="calibre3">Gateway microservice</strong>: <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-gateway" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-gateway</a></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building decoupled services</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Maybe you have, at least heard something about building decoupled things in the software world: decoupled classes, decoupled modules, and also decoupled services. </p>
<p class="mce-root">But what does it mean for a software unit being decoupled from another? </p>
<p class="mce-root">In a practical way, two things are coupled when any changes made to one of them requires you to also change the other one. For example, if you have a method that returns a String and changes it to return a Double, all the methods calling that one are required to be changed.</p>
<p class="mce-root">There are levels of coupling. For example, you could have all your classes and methods very well designed for loose coupling, but they are all written in Java. If you change one of them to .NET and would like to keep all of them together (in the same deployment package), you need to change all the other ones to the new language.</p>
<p class="mce-root">Another thing to mention about coupling is how much one unit <em class="calibre17">knows</em> about the other one. They are tightly coupled when they know a lot about each other and they are the opposite, loosely coupled, if they know a little or almost nothing about each other. This point of view is related mostly to the behavior of two (or more) parts. </p>
<p class="mce-root">The last way to look at coupling is in terms of a contract. If changing the contract breaks the clients, they are tightly coupled. If not, they are loosely coupled. That's why the best way to promote loose coupling is using interfaces. As they create contracts for its implementers, using them for communication between classes promotes loose coupling.</p>
<p class="mce-root">Well... what about services? In our case, microservices.</p>
<p class="mce-root">One service is loosely coupled from another one when changing it does not require changing the other. You can think about both in terms of behavior or contract.</p>
<p class="mce-root">This is especially important when talking about microservices, because you can have dozens, hundreds, or even thousands of them in your application and if changing one of them requires you to change the others, you could just ruin you entire application.</p>
<p class="mce-root">This recipe will show you how to avoid tight coupling in your microservices, from the first line of code, so you can avoid refactoring in the future (at least for this reason).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's start by adding our Java EE 8 dependency:</p>
<pre class="calibre21">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">First, we create a <kbd class="calibre16">User</kbd> POJO:</li>
</ol>
<pre class="mce-root2">public class User implements Serializable{<br class="calibre2"/><br class="calibre2"/>    private String name;<br class="calibre2"/>    private String email;<br class="calibre2"/><br class="calibre2"/>    public String getName() {<br class="calibre2"/>        return name;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setName(String name) {<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getEmail() {<br class="calibre2"/>        return email;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setEmail(String email) {<br class="calibre2"/>        this.email = email;<br class="calibre2"/>    }   <br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">Then we create a class with two methods (endpoints) for returning <kbd class="calibre16">User</kbd>:</li>
</ol>
<pre class="mce-root2">@Path("userService")<br class="calibre2"/>public class UserService {<br class="calibre2"/>    <br class="calibre2"/>    @GET<br class="calibre2"/>    @Path("getUserCoupled/{name}/{email}")<br class="calibre2"/>    @Produces(MediaType.APPLICATION_JSON)<br class="calibre2"/>    public Response getUserCoupled(<br class="calibre2"/>            @PathParam("name") String name, <br class="calibre2"/>            @PathParam("email") String email){<br class="calibre2"/>        //GET USER CODE<br class="calibre2"/>        <br class="calibre2"/>        return Response.ok().build();<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @GET<br class="calibre2"/>    @Path("getUserDecoupled")<br class="calibre2"/>    @Produces(MediaType.APPLICATION_JSON)<br class="calibre2"/>    public Response getUserDecoupled(@HeaderParam("User") <br class="calibre2"/>    User user){<br class="calibre2"/>        //GET USER CODE<br class="calibre2"/>        <br class="calibre2"/>        return Response.ok().build();<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="3" class="calibre19">
<li class="chapter">Finally, we create another service (another project) to consume <kbd class="calibre16">UserService</kbd>:</li>
</ol>
<pre class="mce-root2">@Path("doSomethingService")<br class="calibre2"/>public class DoSomethingService {<br class="calibre2"/>    <br class="calibre2"/>    private final String hostURI = "http://localhost:8080/";<br class="calibre2"/>    private Client client;<br class="calibre2"/>    private WebTarget target;<br class="calibre2"/><br class="calibre2"/>    @PostConstruct<br class="calibre2"/>    public void init() {<br class="calibre2"/>        client = ClientBuilder.newClient();<br class="calibre2"/>        target = client.target(hostURI + "ch08-decoupled-user/");<br class="calibre2"/>    } <br class="calibre2"/>    <br class="calibre2"/>    @Path("doSomethingCoupled")<br class="calibre2"/>    @Produces(MediaType.APPLICATION_JSON)<br class="calibre2"/>    public Response doSomethingCoupled(String name, String email){<br class="calibre2"/>        WebTarget service = <br class="calibre2"/>        target.path("webresources/userService/getUserCoupled");<br class="calibre2"/>        service.queryParam("name", name);<br class="calibre2"/>        service.queryParam("email", email);<br class="calibre2"/><br class="calibre2"/>        Response response;<br class="calibre2"/>        try {<br class="calibre2"/>            response = service.request().get();<br class="calibre2"/>        } catch (ProcessingException e) {<br class="calibre2"/>            return Response.status(408).build();<br class="calibre2"/>        }<br class="calibre2"/><br class="calibre2"/>        return <br class="calibre2"/>        Response.ok(response.readEntity(String.class)).build();<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @Path("doSomethingDecoupled")<br class="calibre2"/>    @Produces(MediaType.APPLICATION_JSON)<br class="calibre2"/>    public Response doSomethingDecoupled(User user){<br class="calibre2"/>        WebTarget service = <br class="calibre2"/>        target.path("webresources/userService/getUserDecoupled");<br class="calibre2"/><br class="calibre2"/>        Response response;<br class="calibre2"/>        try {<br class="calibre2"/>            response = service.request().header("User", <br class="calibre2"/>            Entity.json(user)).get();<br class="calibre2"/>        } catch (ProcessingException e) {<br class="calibre2"/>            return Response.status(408).build();<br class="calibre2"/>        }<br class="calibre2"/><br class="calibre2"/>        return <br class="calibre2"/>        Response.ok(response.readEntity(String.class)).build();<br class="calibre2"/>    } <br class="calibre2"/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">As you may have already noticed, we created two situations in this code: one clearly coupled (<kbd class="calibre16">getUserCoupled</kbd>) and another decoupled (<kbd class="calibre16">getUserDecoupled</kbd>):</p>
<pre class="calibre21">    public Response getUserCoupled(<br class="calibre2"/>            @PathParam("name") String name, <br class="calibre2"/>            @PathParam("email") String email)</pre>
<p class="mce-root">Why is this a coupled method and thus a coupled service? Because it is highly attached to the method signature. Imagine it is a search service and <kbd class="calibre16">"name"</kbd> and <kbd class="calibre16">"email"</kbd> are filters. Now imagine that sometime in the future you need to add another filter. One more parameter in the signature.</p>
<p class="mce-root">OK, you could keep the two methods alive at the same time, so that you wouldn't break the client and have to change the clients. How many are there? Mobile, services, web pages, and many more. All those need to be changed to support the new feature.</p>
<p class="mce-root">Now look at this:</p>
<pre class="calibre21">    public Response getUserDecoupled(@HeaderParam("User") User user)</pre>
<p class="mce-root">In this <kbd class="calibre16">User</kbd> search method, what if you need to add a new parameter to the filter? OK, go ahead and add it! No changes in the contract, all clients are happy.</p>
<p class="mce-root">If your <kbd class="calibre16">User</kbd> POJO starts with only two properties and ends with a hundred after a year, no problem. Your service contract is left untouched and even your clients, who are not using the new fields, are still working. Sweet!</p>
<p class="mce-root">The result of coupled/decoupled services can be seen in the calling <span class="calibre8">service</span>: </p>
<pre class="calibre21">    public Response doSomethingCoupled(String name, String email){<br class="calibre2"/>        WebTarget service = <br class="calibre2"/>        target.path("webresources/userService/getUserCoupled");<br class="calibre2"/>        service.queryParam("name", name);<br class="calibre2"/>        service.queryParam("email", email);<br class="calibre2"/><br class="calibre2"/>        ...<br class="calibre2"/>    }</pre>
<p class="mce-root">The calling service is totally coupled to the called one: it has to <em class="calibre17">know</em> the called service properties' names and needs to add/update each time it changes.</p>
<p class="mce-root">Now look at this:</p>
<pre class="calibre21">    public Response doSomethingDecoupled(User user){<br class="calibre2"/>        WebTarget service = <br class="calibre2"/>        target.path("webresources/userService/getUserDecoupled");<br class="calibre2"/><br class="calibre2"/>        Response response;<br class="calibre2"/>        try {<br class="calibre2"/>            response = service.request().header("User", <br class="calibre2"/>            Entity.json(user)).get();<br class="calibre2"/>            ...<br class="calibre2"/>    }</pre>
<p class="mce-root">In this case, you only need to refer to the one and only service parameter (<kbd class="calibre16">"User"</kbd>) and it will never change, no matter how the <kbd class="calibre16">User</kbd> POJO is changed.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">See the full source code at the following links:</p>
<ul class="calibre13">
<li class="calibre14"><strong class="calibre3">UserService</strong>: <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-decoupled-user" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-decoupled-user</a></li>
<li class="calibre14"><strong class="calibre3">DoSomethingService</strong>: <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-decoupled-dosomethingwithuser" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-decoupled-dosomethingwithuser</a></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building an automated pipeline for microservices</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Maybe you are wondering, <em class="calibre17">"why is there an automation recipe in a Java EE 8 book?"</em>, or even, <em class="calibre17">"is there any specification under Java EE 8 that defines a pipeline automation?"</em></p>
<p class="mce-root">The answer to the second question is <em class="calibre17">no</em>. At least no at this very moment. The answer to the first one I'll explain here.</p>
<p class="mce-root">Many times in conferences I am asked the question, <em class="calibre17">"how do I migrate my monolith to microservices?"</em> It comes in some variations, but at the end of the day the question is the same.</p>
<p class="mce-root">People want to do it for different reasons:</p>
<ul class="calibre13">
<li class="calibre14">They want to keep up with the trend</li>
<li class="calibre14">They want to work with something that looks like a new fashion</li>
<li class="calibre14">They want to scale an application</li>
<li class="calibre14">They want to be able to use different stacks under the same solution</li>
<li class="calibre14">They want to look cool</li>
</ul>
<p class="mce-root">Any of these reasons are OK and you can justify your migration to microservices with any of them, if you want. I would question the real motivation of some of them, but...</p>
<p class="mce-root">Instead of giving them advice, tips, guidelines, or any other tech talk, I usually ask a simple question: <em class="calibre17">"Do you already have an automated pipeline for your monolith?"</em></p>
<p class="mce-root">Most of the time, the answer is a disappointed "<em class="calibre17">no"</em>, followed by a curious, <em class="calibre17">"why?"</em>.</p>
<p class="mce-root">Well the answer is simple: if you don't automate the pipeline you, monolith, one single package, and sometimes you have problems with it, then what makes you think that it will be easier when you have dozens, hundreds, or even thousands of deployment files?</p>
<p class="mce-root">Let me be more specific:</p>
<ul class="calibre13">
<li class="calibre14">Do you build your deployment artifact manually? Using an IDE or something?</li>
<li class="calibre14">Do you deploy it manually?</li>
<li class="calibre14">Did you ever have problems with the deployment for any reason such as errors, missing artifacts, or anything else?</li>
<li class="calibre14">Did you ever have problems due to the lack of tests?</li>
</ul>
<p class="mce-root">If you answered <em class="calibre17">yes</em> to at least one of these questions and don't have an automated pipeline, imagine these problems multiplied by... again, dozens, hundreds, or thousands.</p>
<p class="mce-root">Some people don't even write unit tests. Imagine those hidden errors going to production in a countless amount of artifacts called microservices. Your microservices project will probably fail even before going live.</p>
<p class="mce-root">So yes, you need to automate as many things as possible in your pipeline before even thinking of microservices. This is the only way to prevent the problems from spreading out.</p>
<p class="mce-root">There are three maturity stages for an automation pipeline:</p>
<ol class="calibre19">
<li class="chapter"><strong class="calibre3">Continuous integration</strong> (<strong class="calibre3">CI</strong>): Basically, this ensures that your new code will be merged into the main branch (for example, the <kbd class="calibre16">master</kbd> branch) as soon as possible. It is based on the fact that the less code you merge, the fewer errors you add to it. It is reached mostly by running unit tests during build time.</li>
<li class="chapter"><strong class="calibre3">Continuous delivery</strong>: This is one step further from <span class="calibre5">CI</span>, where you guarantee your artifact will be ready to be deployed just by a click of a button. This usually requires an artifact repository for your binaries and a tool to manage it. When using continuous delivery, you decide when you will do the deployment, but the best practice is to do it as soon as possible to avoid adding a lot of new code in production in just one shot.</li>
<li class="chapter"><strong class="calibre3">Continuous deployment</strong> (<strong class="calibre3">CD</strong>): This is the last, <em class="calibre28">state-of-the-art</em> part of automation. In CD, there's no human interaction since the code is committed until it is deployed in production. The only thing that would prevent an artifact from being deployed is an error in any of the pipeline stages. All the major success cases of microservices worldwide use CD in their projects, doing hundreds or even thousands of deployments daily.</li>
</ol>
<p class="mce-root">This recipe will show you how you can go from zero (no automation at all) to three (CD) in any Java EE project. It's <span class="calibre8">little</span> a conceptual recipe, but with also some code.</p>
<p class="mce-root">Don't argue against concepts; they are the key to your career as a Java EE developer.</p>
<p class="mce-root">"Going microservices" is a huge thing and means lots of things both in your application and organization. Some people even say that microservices are all about scaling people, and not technology.</p>
<p class="mce-root">Here we will, of course, keep on the tech side of things.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Being a lot of things, microservices will also bring a lot of tools with them. This recipe doesn't intend to go deep into the setup of each tool, but shows you how it will work in a microservices-automated pipeline.</p>
<p class="mce-root">The tools chosen here are not the only option for the roles they perform. They are only my favorites for those roles.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Preparing the application</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To prepare your application—your microservices—for an automation, you will need:</p>
<ul class="calibre13">
<li class="calibre14"><strong class="calibre3">Apache Maven</strong>: This is mainly used to build the stage and it will also help you with many activities surrounding it. It manages the dependencies, runs unit tests, and many more.</li>
<li class="calibre14"><strong class="calibre3">JUnit</strong>: This is used to write unit tests that will be executed at the build stage.</li>
<li class="calibre14"><strong class="calibre3">Git</strong>: For the sake of the most sacred things you can imagine, use some version control for your source code. Here, I'll base it on GitHub.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Preparing the environment</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To prepare the environment of your pipeline, you will need:</p>
<ul class="calibre13">
<li class="calibre14"><strong class="calibre3">Sonatype Nexus</strong>: This is a binary repository. In other words, when you build your artifact, it will be stored in Nexus and be ready to be deployed wherever you need/want.</li>
<li class="calibre14"><strong class="calibre3">Jenkins</strong>: I used to say that Jenkins is an automator for everything. Actually I've worked in a project where we used it to build an automated pipeline (continuous delivery) for about 70 applications, with completely different technologies (languages, databases, operation systems, and so on). You will use it basically for building and deploying.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">You will be guided to reach each one of the three automation maturity stages: continuous integration, continuous delivery, and continuous deployment.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Continuous integration</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Here, you need to make your new code go to the main branch as soon as possible. You will achieve it by using:</p>
<ul class="calibre13">
<li class="calibre14">Git</li>
<li class="calibre14">Maven</li>
<li class="calibre14">JUnit</li>
</ul>
<p class="mce-root">So, you will guarantee that your code is building properly and that the tests are planned and executed successfully.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Git</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">I'll not get too deeply into how to use Git and its commands, as it's not the focus of this book. If you are completely new to the Git world, get started by looking at this cheat sheet:</p>
<p class="mce-root"><a href="https://education.github.com/git-cheat-sheet-education.pdf" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://education.github.com/git-cheat-sheet-education.pdf</a></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Maven</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Maven is one of the most powerful tools I've ever seen, and thus has a bunch of features embedded. If you are new to it, check out this reference:</p>
<p class="mce-root"><a href="https://maven.apache.org/guides/MavenQuickReferenceCard.pdf" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://maven.apache.org/guides/MavenQuickReferenceCard.pdf</a></p>
<p class="mce-root"/>
<p class="mce-root">The most important file in a Maven-based project is the <kbd class="calibre16">pom.xml</kbd> (<strong class="calibre7">POM</strong> stands for <strong class="calibre7">Project Object Model</strong>). For example, when you create a new Java EE 8 project, it should look like this:</p>
<pre class="calibre21">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br class="calibre2"/>&lt;project   xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;<br class="calibre2"/>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br class="calibre2"/><br class="calibre2"/>    &lt;groupId&gt;com.eldermoraes&lt;/groupId&gt;<br class="calibre2"/>    &lt;artifactId&gt;javaee8-project-template&lt;/artifactId&gt;<br class="calibre2"/>    &lt;version&gt;1.0&lt;/version&gt;<br class="calibre2"/>    &lt;packaging&gt;war&lt;/packaging&gt;<br class="calibre2"/><br class="calibre2"/>    &lt;name&gt;javaee8-project-template&lt;/name&gt;<br class="calibre2"/><br class="calibre2"/>    &lt;properties&gt;<br class="calibre2"/>        &lt;endorsed.dir&gt;${project.build.directory}/endorsed&lt;/endorsed.dir&gt;<br class="calibre2"/>        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;<br class="calibre2"/>    &lt;/properties&gt;<br class="calibre2"/>    <br class="calibre2"/>    &lt;dependencies&gt;<br class="calibre2"/>        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;<br class="calibre2"/>    &lt;/dependencies&gt;<br class="calibre2"/><br class="calibre2"/>    &lt;build&gt;<br class="calibre2"/>        &lt;plugins&gt;<br class="calibre2"/>            &lt;plugin&gt;<br class="calibre2"/>                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br class="calibre2"/>                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;<br class="calibre2"/>                &lt;version&gt;3.1&lt;/version&gt;<br class="calibre2"/>                &lt;configuration&gt;<br class="calibre2"/>                    &lt;source&gt;1.8&lt;/source&gt;<br class="calibre2"/>                    &lt;target&gt;1.8&lt;/target&gt;<br class="calibre2"/>                    &lt;compilerArguments&gt;<br class="calibre2"/>                        &lt;endorseddirs&gt;${endorsed.dir}&lt;/endorseddirs&gt;<br class="calibre2"/>                    &lt;/compilerArguments&gt;<br class="calibre2"/>                &lt;/configuration&gt;<br class="calibre2"/>            &lt;/plugin&gt;<br class="calibre2"/>            &lt;plugin&gt;<br class="calibre2"/>                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br class="calibre2"/>                &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;<br class="calibre2"/>                &lt;version&gt;2.3&lt;/version&gt;<br class="calibre2"/>                &lt;configuration&gt;<br class="calibre2"/>                    &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;<br class="calibre2"/>                &lt;/configuration&gt;<br class="calibre2"/>            &lt;/plugin&gt;<br class="calibre2"/>        &lt;/plugins&gt;<br class="calibre2"/>    &lt;/build&gt;<br class="calibre2"/><br class="calibre2"/>&lt;/project&gt;</pre>
<p class="mce-root">Then your project is ready for building using Maven like this (running in the same folder where <kbd class="calibre16">pom.xml</kbd> is located):</p>
<pre class="calibre21"><strong class="calibre3">mvn</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">JUnit</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">You will use JUnit to run your unit tests. Let's check it.</p>
<p class="mce-root">Here is a class to be tested:</p>
<pre class="calibre21">public class JUnitExample {<br class="calibre2"/>    <br class="calibre2"/>    @Size (min = 6, max = 10,message = "Name should be between 6 and 10 <br class="calibre2"/>           characters")<br class="calibre2"/>    private String name;<br class="calibre2"/><br class="calibre2"/>    public String getName() {<br class="calibre2"/>        return name;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setName(String name) {<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>}</pre>
<p class="mce-root">Here is a testing class:</p>
<pre class="calibre21">public class JUnitTest {<br class="calibre2"/>    <br class="calibre2"/>    private static Validator VALIDATOR;<br class="calibre2"/>    <br class="calibre2"/>    @BeforeClass<br class="calibre2"/>    public static void setUpClass() {<br class="calibre2"/>        VALIDATOR = Validation.buildDefaultValidatorFactory().getValidator();<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @Test<br class="calibre2"/>    public void smallName(){<br class="calibre2"/>        JUnitExample junit = new JUnitExample();<br class="calibre2"/>        <br class="calibre2"/>        junit.setName("Name");<br class="calibre2"/>        <br class="calibre2"/>        Set&lt;ConstraintViolation&lt;JUnitExample&gt;&gt; cv = <br class="calibre2"/>        VALIDATOR.validate(junit);<br class="calibre2"/>        assertFalse(cv.isEmpty());<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @Test<br class="calibre2"/>    public void validName(){<br class="calibre2"/>        JUnitExample junit = new JUnitExample();<br class="calibre2"/>        <br class="calibre2"/>        junit.setName("Valid Name");<br class="calibre2"/>        <br class="calibre2"/>        Set&lt;ConstraintViolation&lt;JUnitExample&gt;&gt; cv = <br class="calibre2"/>        VALIDATOR.validate(junit);<br class="calibre2"/>        assertTrue(cv.isEmpty());<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @Test<br class="calibre2"/>    public void invalidName(){<br class="calibre2"/>        JUnitExample junit = new JUnitExample();<br class="calibre2"/>        <br class="calibre2"/>        junit.setName("Invalid Name");<br class="calibre2"/>        <br class="calibre2"/>        Set&lt;ConstraintViolation&lt;JUnitExample&gt;&gt; cv = <br class="calibre2"/>        VALIDATOR.validate(junit);<br class="calibre2"/>        assertFalse(cv.isEmpty());<br class="calibre2"/>    } <br class="calibre2"/>}</pre>
<p class="mce-root">Whenever you run the building process for this project, the preceding test will be executed and will ensure that those conditions are still valid.</p>
<p class="mce-root">Now you are ready for continuous integration. Just make sure to merge your new and working code into the main branch as soon as possible. Now let's move on to continuous delivery.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Continuous delivery</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Now that you are a committer machine, let's go to the next level and make your application ready to deploy whenever you want.</p>
<p class="mce-root">First, you'll need your just-built artifact to be available in a proper repository. This is when we use Sonatype Nexus.</p>
<p class="mce-root">I won't go into the setup details in this book. One easy way to do it is by using Docker containers. You can see more information about it at, <a href="https://hub.docker.com/r/sonatype/nexus/" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://hub.docker.com/r/sonatype/nexus/</a>.</p>
<p class="mce-root">Once your Nexus is available, you need to go to the <kbd class="calibre16">pom.xml</kbd> file and add this configuration:</p>
<pre class="calibre21">    &lt;distributionManagement&gt;<br class="calibre2"/>        &lt;repository&gt;<br class="calibre2"/>            &lt;id&gt;Releases&lt;/id&gt;<br class="calibre2"/>            &lt;name&gt;Project&lt;/name&gt;<br class="calibre2"/>            &lt;url&gt;[NEXUS_URL]/nexus/content/repositories/releases/&lt;/url&gt;<br class="calibre2"/>        &lt;/repository&gt;<br class="calibre2"/>     &lt;/distributionManagement&gt;</pre>
<p class="mce-root">Now instead of building, just use the following:</p>
<pre class="calibre21"><strong class="calibre3">mvn</strong></pre>
<p class="mce-root">You'll do so like this:</p>
<pre class="calibre21"><strong class="calibre3">mvn deploy</strong></pre>
<p class="mce-root">So once your artifact is built, Maven will upload it to Sonatype Nexus. Now it is properly stored for future deployment.</p>
<p class="mce-root">Now you are almost ready to dance to the automation song. Let's bring Jenkins to the party.</p>
<p class="mce-root">As mentioned for Nexus, I will not get into the details about setting up Jenkins. I also recommend you do it using Docker. See the following link for details:</p>
<p class="mce-root"><a href="https://hub.docker.com/_/jenkins/" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://hub.docker.com/_/jenkins/</a></p>
<p class="mce-root">If you have absolutely no idea on how to use Jenkins, please refer to this official guide:</p>
<p class="mce-root"><a href="https://jenkins.io/user-handbook.pdf" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://jenkins.io/user-handbook.pdf</a></p>
<p class="mce-root">Once your Jenkins is up and running, you'll create two jobs:</p>
<ol class="calibre19">
<li class="chapter"><strong class="calibre3">Your-Project-Build</strong>: This job will be used to build your project from the source code.</li>
<li class="chapter"><strong class="calibre3">Your-Project-Deploy</strong>: This job will be used to deploy your artifact after being built and stored in Nexus.</li>
</ol>
<p class="mce-root">You will configure the first one to download the source code of your project and build it using Maven. The second will download it from Nexus and deploy to the application server.</p>
<p class="mce-root">Remember that the deployment process involves some steps in most cases:</p>
<ol class="calibre19">
<li class="chapter">Stop the application server.</li>
<li class="chapter">Remove the previous version.</li>
<li class="chapter">Download the new version from Nexus.</li>
<li class="chapter">Deploy the new version.</li>
<li class="chapter">Start the application server.</li>
</ol>
<p class="mce-root">So you'd probably create a shell script to be executed by Jenkins. Remember, we are automating, so no manual processes.</p>
<p class="mce-root">Downloading the artifact can be a little tricky, so maybe you could use something like this in your shell script:</p>
<pre class="calibre21">wget --user=username --password=password "[NEXUS_URL]/nexus/service/local/artifact/maven/content?g=&lt;group&gt;&amp;a=&lt;artifact&gt;<br class="calibre2"/>&amp;v=&lt;version&gt;&amp;r=releases"</pre>
<p class="mce-root">If everything goes fine until this point, then you'll have two buttons: one for building and another for deploying. You are ready and set to build with no need to use any IDE to deploy, and no need to touch the application server.</p>
<p class="mce-root">Now you are sure that both processes (build and deploy) will be executed exactly the same way every time. You can now plan them to be executed in a shorter period of time.</p>
<p class="mce-root">Well, now we will move to the next and best step: continuous deployment.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Continuous deployment</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To move from delivery to deployment is a matter of maturity—you need a reliable process that ensures only the working code is going into production.</p>
<p class="mce-root">You already have your code running unit tests on every build. Actually, you didn't forget to write unit tests, right?</p>
<p class="mce-root">On every success, your built artifact is properly stored and you manage the right versioning for your application.</p>
<p class="mce-root">You have mastered the deployment process for your application, dealing properly with any condition that might occur. Your application server is never going down again without your knowledge and you achieved it with the help of just two buttons! Build and deploy. You rock!</p>
<p class="mce-root">If you are at this point, your next move shouldn't be a big deal. You only need to automate the two jobs so you don't need to hit the button anymore.</p>
<p class="mce-root">In the build job, you'll set it to be executed whenever Jenkins finds any changes in the source code repository (check the documentation if you don't know how to do it).</p>
<p class="mce-root">Once it is done, there is just one last configuration: make the build step on the build job call another job—the deploy job. So any time the build is executed successfully, the deploy is also executed right away.</p>
<p class="mce-root">Cheers! You've made it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Of course, you will not only perform unit tests or API tests. You also need to test your UI, if you have one.</p>
<p class="mce-root">I'd recommend to do it using the Selenium Webdriver. You can find more information here, <a href="http://www.seleniumhq.org/docs/03_webdriver.jsp" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">http://www.seleniumhq.org/docs/03_webdriver.jsp</a>.</p>
<p class="mce-root">In this case, you would probably want to deploy your application to a QA environment, run the UI tests, and then go into production if everything is fine. So it's just a matter of adding some new jobs to your pipeline, now you know how to do it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">The source code of the JUnit example can be found at, <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-automation" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-automation</a>.</li>
</ul>
<p class="mce-root"> </p>
<p class="mce-root"> </p>
<p class="mce-root"> </p>


            </article>

            
        </section>
    </div>



  </body></html>