["```java\nsbt new scala-fundamentals/scala-play.g8 --name=shopping --organization=io.fscala\n```", "```java\nlibraryDependencies ++= Seq(\n  \"com.typesafe.play\" %% \"play-slick\" % \"3.0.0\",\n  \"com.typesafe.play\" %% \"play-slick-evolutions\" % \"3.0.0\",\n  \"com.h2database\" % \"h2\" % \"1.4.196\"\n)\n```", "```java\n# Default database configuration\nslick.dbs.default.profile=\"slick.jdbc.H2Profile$\"\nslick.dbs.default.db.driver=\"org.h2.Driver\"\nslick.dbs.default.db.url=\"jdbc:h2:mem:shopping\"\n\nplay.evolutions.enabled=true\nplay.evolutions.db.default.autoApply=true\n```", "```java\nclass ProductDaoSpec extends PlaySpec with ScalaFutures with GuiceOneAppPerSuite {\n  \"ProductDao\" should {\n    \"Have default rows on database creation\" in {\n      val app2dao = Application.instanceCache[ProductDao]\n      val dao: ProductDao = app2dao(app)\n\n      val expected = Set(\n        Product(\"PEPPER\", \"ALD2\", \"PEPPER is a robot moving with wheels \n        and with a screen as human interaction\", 7000),\n        Product(\"NAO\", \"ALD1\", \"NAO is an humanoid robot.\", 3500),\n        Product(\"BEOBOT\", \"BEO1\", \"Beobot is a multipurpose robot.\", \n        159.0)\n      )\n\n      dao.all().futureValue should contain theSameElementsAs (expected)\n    }\n  }\n}\n```", "```java\nclass CartDaoSpec extends PlaySpec with ScalaFutures with GuiceOneAppPerSuite {\n\n  \"CartDao\" should {\n    val app2dao = Application.instanceCache[CartDao]\n\n    \"be empty on database creation\" in {\n      val dao: CartDao = app2dao(app)\n      dao.all().futureValue shouldBe empty\n    }\n\n    \"accept to add new cart\" in {\n      val dao: CartDao = app2dao(app)\n      val user = \"userAdd\"\n\n      val expected = Set(\n        Cart(user, \"ALD1\", 1),\n        Cart(user, \"BEO1\", 5)\n      )\n      val noise = Set(\n        Cart(\"userNoise\", \"ALD2\", 10)\n      )\n      val allCarts = expected ++ noise\n\n      val insertFutures = allCarts.map(dao.insert)\n\n      whenReady(Future.sequence(insertFutures)) { _ =>\n        dao.cart4(user).futureValue should contain theSameElementsAs expected\n        dao.all().futureValue.size should equal(allCarts.size)\n      }\n    }\n  }\n}\n```", "```java\n\"error thrown when adding a cart with same user and productCode\" in {\n  val dao: CartDao = app2dao(app)\n  val user = \"userAdd\"\n  val expected = Set(\n    Cart(user, \"ALD1\", 1),\n    Cart(user, \"BEO1\", 5)\n  )\n  val noise = Set(\n    Cart(user, \"ALD1\", 10)\n  )\n  val allCarts = expected ++ noise\n  val insertFutures = allCarts.map(dao.insert)\n  recoverToSucceededIf[org.h2.jdbc.JdbcSQLException]{\n    Future.sequence(insertFutures)\n  }\n}\n```", "```java\n\"accept to remove a product from a cart\" in {\n  val dao: CartDao = app2dao(app)\n  val user = \"userRmv\"\n  val initial = Vector(\n    Cart(user, \"ALD1\", 1),\n    Cart(user, \"BEO1\", 5)\n  )\n  val expected = Vector(Cart(user, \"ALD1\", 1))\n\n  whenReady(Future.sequence(initial.map(dao.insert(_)))) { _ =>\n    dao.remove(ProductInCart(user, \"BEO1\")).futureValue\n    dao.cart4(user).futureValue should contain theSameElementsAs \n      (expected)\n  }\n}\n```", "```java\n\"accept to update quantities of an item in a cart\" in {\n  val dao: CartDao = app2dao(app)\n  val user = \"userUpd\"\n  val initial = Vector(Cart(user, \"ALD1\", 1))\n  val expected = Vector(Cart(user, \"ALD1\", 5))\n\n  whenReady(Future.sequence(initial.map(dao.insert(_)))) { _ =>\n    dao.update(Cart(user, \"ALD1\", 5)).futureValue\n    dao.cart4(user).futureValue should contain theSameElementsAs \n      (expected)\n  }\n}\n```", "```java\nAwait.result(awaitable: Awaitable[T], atMost: Duration)\n```", "```java\nImport scala.concurrent.{Await, Future}\nimport scala.util.{Failure, Success}\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.concurrent.duration._\n\nval f: Future[String] = Future {\n  Thread.sleep(1000)\n  “Finished”\n}\nf.onComplete {\n  case Success(value) => println(value)\n  case Failure(e) => e.printStackTrace()\n}\n```", "```java\nval f1 = Future {1}\nval f2 = Future {2}\nval f3 = Future {3}\n```", "```java\nval res = for {\n  v1 <- f1\n  v2 <- f2\n  v3 <- f3\n  } yield (v1 + v2 + v3)\n```", "```java\nval response = Await.result(res, 1 second)\n```", "```java\ndef sum(v: Int*) = v.sum\n```", "```java\nval minExpected = 5\n\nval res = for {\n  v1 <- f1\n  v2 <- f2\n  v3 <- f3\n  if (sum(v1, v2, v3) > minExpected)\n} yield (v1, v2, v3)\n```", "```java\nres.onComplete {\n  case Success(result) => println(s\"The result is $result\")\n  case Failure(e) => println(\"The sum is not big enough\")\n}\n```", "```java\nThe result is (1,2,3)\n```", "```java\nThe sum is not big enough\n```", "```java\nFuture(Failure(java.util.NoSuchElementException: Future.filter predicate is not satisfied))\n```", "```java\nimport scala.concurrent.ExecutionContext.Implicits.global\n```", "```java\n# --- !Ups\nCREATE TABLE IF NOT EXISTS PUBLIC.PRODUCTS (\n  name VARCHAR(100) NOT NULL,\n  code VARCHAR(255) NOT NULL,\n  description VARCHAR(1000) NOT NULL,\n  price INT NOT NULL,\n  PRIMARY KEY(code)\n);\n```", "```java\nINSERT INTO PUBLIC.PRODUCTS (name,code, description, price) VALUES ('NAO','ALD1','NAO is an humanoid robot.', 3500);\nINSERT INTO PUBLIC.PRODUCTS (name,code, description, price) VALUES ('PEPER','ALD2','PEPPER is a robot moving with wheels and with a screen as human interaction',7000);\nINSERT INTO PUBLIC.PRODUCTS (name,code, description, price) VALUES ('BEOBOT','BEO1','Beobot is a multipurpose robot.',159);\n```", "```java\nCREATE TABLE IF NOT EXISTS PUBLIC.CART (\n  id BIGINT AUTO_INCREMENT,\n  user VARCHAR(255) NOT NULL,\n  code VARCHAR(255) NOT NULL,\n  qty INT NOT NULL,\n  PRIMARY KEY(id),\n  CONSTRAINT UC_CART UNIQUE (user,code)\n);\n```", "```java\n# --- !Ups\n```", "```java\n# --- !Downs\n```", "```java\n# --- !Downs\nDROP TABLE PRODUCTS;\nDROP TABLE CART;\n```", "```java\nclass ProductsDao @Inject()(protected val dbConfigProvider: DatabaseConfigProvider)(implicit executionContext: ExecutionContext) extends HasDatabaseConfigProvider[JdbcProfile] {\n\n  import profile.api._\n\n  def all(): Future[Seq[Product]] = db.run(products.result)\n\n  def insert(product: Product): Future[Unit] = db.run(products \n    insertOrUpdate product).map { _ => () }\n\n  private class ProductsTable(tag: Tag) extends Table[Product](tag, \n    \"PRODUCTS\") {\n    def name = column[String](\"NAME\")\n\n    def code = column[String](\"CODE\")\n\n    def description = column[String](\"DESCRIPTION\")\n\n    def price = column[Double](\"PRICE\")\n\n    override def * = (name, code, description, price) <>     \n    (Product.tupled, Product.unapply)\n  }\n\n  private val products = TableQuery[ProductsTable]\n}\n```", "```java\ncase class Product(name: String,\n                   code : String,\n                   description : String,\n                   price: Double)\n```", "```java\nclass CartsDao @Inject()(protected val dbConfigProvider: DatabaseConfigProvider)(implicit executionContext: ExecutionContext) extends HasDatabaseConfigProvider[JdbcProfile] {\n\n  import profile.api._\n\n  def cart4(usr : String): Future[Seq[Cart]] = \n    db.run(carts.filter(_.user === usr).result)\n\n  def insert(cart: Cart): Future[_] = db.run(carts += cart)\n\n  def remove(cart: ProductInCart): Future[Int] = \n    db.run(carts.filter(c => matchKey(c, cart)).delete)\n\n  def update(cart: Cart): Future[Int] = {\n    val q = for {\n      c <- carts if matchKey(c, cart)\n    } yield c.quantity\n    db.run(q.update(cart.quantity))\n  }\n\n  private def matchKey(c: CartTable, cart: CartKey): Rep[Boolean] = {\n    c.user === cart.user && c.productCode === cart.productCode\n  }\n\n  def all(): Future[Seq[Cart]] = db.run(carts.result)\n\n  private class CartsTable(tag: Tag) extends Table[Cart](tag, \"CART\") {\n\n    def user = column[String](\"USER\")\n\n    def productCode = column[String](\"CODE\")\n\n    def quantity = column[Int](\"QTY\")\n\n    override def * = \n      (user, productCode, quantity) <> (Cart.tupled, Cart.unapply)\n  }\n\n  private val carts = TableQuery[CartsTable]\n\n}\n```", "```java\nabstract class CartKey {\n  def user: String\n  def productCode: String\n}\n\ncase class ProductInCart(user:String, productCode: String) extends CartKey\n\ncase class Cart(user:String, productCode: String, quantity: Int) extends CartKey\n```", "```java\nheroku login\n```", "```java\ngit init\n```", "```java\nheroku git:remote -a shopping-fs\n```", "```java\nset git remote heroku to https://git.heroku.com/shopping-fs.git\n```", "```java\ngit add . git commit -am 'Initial commit'\n```", "```java\ngit push heroku master\n```", "```java\n..........\nremote: -----> Launching... remote: Released v4 remote:https://shopping-fs.herokuapp.com/ deployed to Heroku remote:\n```", "```java\nweb: server/target/universal/stage/bin/server -Dhttp.port=$PORT -Dconfig.file=server/conf/heroku.conf\n```"]